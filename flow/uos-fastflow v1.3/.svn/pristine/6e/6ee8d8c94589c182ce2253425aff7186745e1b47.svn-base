(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["fishTopoNetwork"] = factory();
	else
		root["fishTopoNetwork"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(1);


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Export fishTopo as CommonJS module
	 */
	module.exports = __webpack_require__(2);
	
	//兼容IE8 引入VML 如果不需要兼容IE8请删除
	__webpack_require__(117);


/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	
	    var graphic = __webpack_require__(3);
	    var ExtensionAPI = __webpack_require__(58);
	    var Eventful = __webpack_require__(11);
	    var zrender = __webpack_require__(59);
	    var zrUtil = __webpack_require__(4);
	    var util = __webpack_require__(71);
	    var NetworkModel = __webpack_require__(74);
	    var NetworkNode = __webpack_require__(77);
	    var RackNode = __webpack_require__(79);
	    var NetworkUtil = __webpack_require__(80);
	
	    function FishTopoNetwork (dom, opts) {
	        /**
	         * @type {string}
	         */
	        this.id;
	        /**
	         * Group id
	         * @type {string}
	         */
	        this.group;
	
	        /**
	         * @type {HTMLDomElement}
	         * @private
	         */
	        this._dom = dom;
	
	        this.allNodes = [];
	
	        this._api = new ExtensionAPI(this);
	
	        this.tipNode = null;
	
	        /**
	         * @type {module:zrender/ZRender}
	         * @private
	         */
	        this._zr = init(this, opts); 
	
	        Eventful.call(this);
	        if ( !NetworkNode.hasClass("RackNode")) {
	            NetworkUtil.registerNetworkNode(); 
	        }     
	    }
	
	    function init(p_this, p_opts) {
	
	        var topoDiv = '<div class="topoDiv" id = "topoDiv" style="width:100%; height:100%; overflow:auto;"></div>';
	        p_this._dom.innerHTML = topoDiv;
	        
	        var dom = document.getElementById("topoDiv");
	
	        var zRenderer = zrender.init(dom, {
	            renderer: p_opts.renderer || 'canvas',
	            devicePixelRatio: p_opts.devicePixelRatio
	        });
	        return zRenderer;    
	    };
	
	    var fishTopoProto = FishTopoNetwork.prototype;
	
	    /**
	     * @return {HTMLDomElement}
	     */
	    fishTopoProto.getDom = function () {
	        return this._dom;
	    };
	
	    /**
	     * @return {module:zrender~ZRender}
	     */
	    fishTopoProto.getZr = function () {
	        return this._zr;
	    };
	    /**
	     * @return {number}
	     */
	    fishTopoProto.getWidth = function () {
	        return this._zr.getWidth();
	    };
	
	    /**
	     * @return {number}
	     */
	    fishTopoProto.getHeight = function () {
	        return this._zr.getHeight();
	    };
	
	    /**
	     * 调整尺寸  在窗口大小发生改变时需要手工调用
	     */
	    fishTopoProto.resize = function ( p_width, p_height) {
	        p_width = p_width !== undefined ? p_width : this.getWidth;
	        p_height = p_height !== undefined ? p_height : this.getHeight() - 50;
	        this._zr.painter.resize(p_width, p_height);
	    }; 
	
	    /**
	     * 根据模型增加节点
	     * @param {[type]} model [description]
	     */
	    fishTopoProto.addNodeByModel = function(model) {
	        var that = this;
	        var Shape = NetworkNode.getClass(model.get("stencil.type"));
	        if (Shape) {
	            node = new Shape(model, this._api);
	            this._zr.add(node); 
	            node.on('click',function(e){
	                that._api.trigger(e, {});  
	            });         
	        }         
	             
	    };  
	
	    fishTopoProto.getNodeClass = function (className) {
	        return NetworkNode.getClass(className);
	    };
	
	    /**
	     * 鼠标悬停提示框展示
	     * @param {[type]} model [description]
	     */
	    fishTopoProto.showTipWindow = function(model) {
	        var Shape = NetworkNode.getClass("TipWindowNode");
	        if (Shape) {
	            var height = this._zr.getHeight();           
	            if( this.allWidth != undefined ) {
	                this._zr.painter.resize( this.allWidth + model.width, 730);
	            }
	            
	            var node = new Shape(model, this._api);
	            this._zr.add(node); 
	            this.tipNode = node;
	            // node.on('mousedown',function(e){
	            //     //that.newDrag(this,e.event.clientX,e.event.clientY);   
	            // });         
	        }         
	
	    };
	
	    /**
	     * 鼠标悬停提示框展示
	     * @param {[type]} model [description]
	     */
	    fishTopoProto.hideTipWindow = function(model) { 
	        if (this.tipNode && this.tipNode !== null ) {
	            this._zr.remove(this.tipNode);      
	        }         
	    };
	
	    fishTopoProto.init = function () {
	        var isSelected = this.isSelected;
	                
	    };
	
	    fishTopoProto.clear = function () {
	        this._zr.clear();
	    };   
	
	    fishTopoProto.exportJson = function() {
	        var networkModel = new NetworkModel({});
	        networkModel.set("resourceId", util.getUUID());
	        return NetworkUtil.exportJson(networkModel, this.allNodes);
	    };
	
	    fishTopoProto.drawFromJson = function(json) {
	        var topoType = json.type;
	        if ( topoType === "rack" ) {
	            var clientWidth = this._zr.getWidth();
	            if ( (50 + (json.data.length * 250)) > clientWidth ) {
	                this._zr.painter.resize( 50 + (json.data.length * 250), 730);
	                if ( clientWidth < this._zr.getWidth() ) {
	                    this.allWidth = this._zr.getWidth();
	                }
	            } 
	        } else if ( topoType === "topo" ) {
	            var clientWidth = this._zr.getWidth();
	            var clientHeight = 700;
	            this.width = clientWidth;
	            this.height = clientHeight;
	        }
	        else if ( topoType === "cluster" ) {
	            var clientWidth = this._zr.getWidth();
	            var clientHeight = 630;
	            this.width = clientWidth;
	            this.height = clientHeight;
	        }
	        return NetworkUtil.fromJson(this, json);
	    };  
	
	    zrUtil.mixin(FishTopoNetwork, Eventful);
	
	    // ---------对外暴露fishTopoNetWork------------------
	    var idBase = new Date() - 0;
	    var instances = {};
	    var DOM_ATTRIBUTE_KEY = '_fishTopoNetwork_instance_';
	    var fishTopoNetWork = {
	        /**
	         * @type {number}
	         */
	        version: '1.0.0',
	        dependencies: {
	            zrender: '3.0.4'
	        }
	    };
	
	    /**
	     * @param {HTMLDomElement} dom
	     * @param {Object} opts
	     */
	    fishTopoNetWork.init = function (dom, opts) {
	        if (!dom) {
	            throw new Error('Initialize failed: invalid dom.');
	        }
	
	        opts = opts || {};
	        // Default value
	        zrUtil.defaults(opts,
	            {
	                type: "bpmn",
	                showGridLine: true,
	                devicePixelRatio: 1,
	                gridLineSpacing:10
	            }
	        );
	
	        var fishTopoNetWork = new FishTopoNetwork(dom, opts);
	        fishTopoNetWork.init();
	
	        fishTopoNetWork.id = 'ft_' + idBase++;
	        instances[fishTopoNetWork.id] = fishTopoNetWork;
	
	        dom.setAttribute && dom.setAttribute(DOM_ATTRIBUTE_KEY, fishTopoNetWork.id);
	
	        return fishTopoNetWork;
	    };
	
	
	    /**
	     * @param  {HTMLDomElement} dom
	     * @return {fishTopo}
	     */
	    fishTopoNetWork.getInstanceByDom = function (dom) {
	        var key = dom.getAttribute(DOM_ATTRIBUTE_KEY);
	        return instances[key];
	    };
	
	    /**
	     * Dispose a fishTopo instance
	     * @param  {module:fishTopo|HTMLDomElement|string} fishTopo
	     */
	    fishTopoNetWork.dispose = function (chart) {
	        var topo;
	        if (zrUtil.isDom(chart)) {
	            topo = fishTopoNetWork.getInstanceByDom(chart);
	        }
	        else if (typeof chart === 'string') {
	            topo = instances[chart];
	        }
	        if ((topo instanceof fishTopoNetWork) && !topo.isDisposed()) {
	            topo.dispose();
	        }
	    };
	
	    module.exports = fishTopoNetWork;
	


/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	
	    var zrUtil = __webpack_require__(4);
	
	    var pathTool = __webpack_require__(5);
	    var round = Math.round;
	    var Path = __webpack_require__(6);
	    var colorTool = __webpack_require__(19);
	    var matrix = __webpack_require__(13);
	    var vector = __webpack_require__(14);
	    var Gradient = __webpack_require__(37);
	    var Draggable = __webpack_require__(38);
	
	    var graphic = {};
	    graphic.Util = zrUtil;
	    graphic.Group = __webpack_require__(39);
	
	    graphic.Image = __webpack_require__(40);
	
	    graphic.Text = __webpack_require__(42);
	
	    graphic.textContain = __webpack_require__(23);
	
	    graphic.Circle = __webpack_require__(43);
	
	    graphic.Sector = __webpack_require__(44);
	
	    graphic.Ring = __webpack_require__(45);
	
	    graphic.Polygon = __webpack_require__(46);
	
	    graphic.Polyline = __webpack_require__(50);
	
	    graphic.Rect = __webpack_require__(51);
	
	    graphic.Line = __webpack_require__(53);
	
	    graphic.BezierCurve = __webpack_require__(54);
	
	    graphic.Arc = __webpack_require__(55);
	
	    graphic.LinearGradient = __webpack_require__(56);
	
	    graphic.RadialGradient = __webpack_require__(57);
	
	    graphic.BoundingRect = __webpack_require__(24);
	
	    /**
	     * Extend shape with parameters
	     */
	    graphic.extendShape = function (opts) {
	        return Path.extend(opts);
	    };
	
	    /**
	     * Extend path
	     */
	    graphic.extendPath = function (pathData, opts) {
	        return pathTool.extendFromString(pathData, opts);
	    };
	
	    /**
	     * Create a path element from path data string
	     * @param {string} pathData
	     * @param {Object} opts
	     * @param {module:zrender/core/BoundingRect} rect
	     * @param {string} [layout=cover] 'center' or 'cover'
	     */
	    graphic.makePath = function (pathData, opts, rect, layout) {
	        var path = pathTool.createFromString(pathData, opts);
	        Draggable.call(path);
	        var boundingRect = path.getBoundingRect();
	        if (rect) {
	            var aspect = boundingRect.width / boundingRect.height;
	
	            if (layout === 'center') {
	                // Set rect to center, keep width / height ratio.
	                var width = rect.height * aspect;
	                var height;
	                if (width <= rect.width) {
	                    height = rect.height;
	                }
	                else {
	                    width = rect.width;
	                    height = width / aspect;
	                }
	                var cx = rect.x + rect.width / 2;
	                var cy = rect.y + rect.height / 2;
	
	                rect.x = cx - width / 2;
	                rect.y = cy - height / 2;
	                rect.width = width;
	                rect.height = height;
	            }
	
	            this.resizePath(path, rect);
	        }
	
	        zrUtil.inherits(path, Draggable);
	        return path;
	    };
	
	    graphic.mergePath = pathTool.mergePath;
	
	    /**
	     * Resize a path to fit the rect
	     * @param {module:zrender/graphic/Path} path
	     * @param {Object} rect
	     */
	    graphic.resizePath = function (path, rect) {
	        if (!path.applyTransform) {
	            return;
	        }
	
	        var pathRect = path.getBoundingRect();
	
	        var m = pathRect.calculateTransform(rect);
	
	        path.applyTransform(m);
	    };
	
	    /**
	     * Sub pixel optimize line for canvas
	     *
	     * @param {Object} param
	     * @param {Object} [param.shape]
	     * @param {number} [param.shape.x1]
	     * @param {number} [param.shape.y1]
	     * @param {number} [param.shape.x2]
	     * @param {number} [param.shape.y2]
	     * @param {Object} [param.style]
	     * @param {number} [param.style.lineWidth]
	     * @return {Object} Modified param
	     */
	    graphic.subPixelOptimizeLine = function (param) {
	        var subPixelOptimize = graphic.subPixelOptimize;
	        var shape = param.shape;
	        var lineWidth = param.style.lineWidth;
	
	        if (round(shape.x1 * 2) === round(shape.x2 * 2)) {
	            shape.x1 = shape.x2 = subPixelOptimize(shape.x1, lineWidth, true);
	        }
	        if (round(shape.y1 * 2) === round(shape.y2 * 2)) {
	            shape.y1 = shape.y2 = subPixelOptimize(shape.y1, lineWidth, true);
	        }
	        return param;
	    };
	
	    /**
	     * Sub pixel optimize rect for canvas
	     *
	     * @param {Object} param
	     * @param {Object} [param.shape]
	     * @param {number} [param.shape.x]
	     * @param {number} [param.shape.y]
	     * @param {number} [param.shape.width]
	     * @param {number} [param.shape.height]
	     * @param {Object} [param.style]
	     * @param {number} [param.style.lineWidth]
	     * @return {Object} Modified param
	     */
	    graphic.subPixelOptimizeRect = function (param) {
	        var subPixelOptimize = graphic.subPixelOptimize;
	        var shape = param.shape;
	        var lineWidth = param.style.lineWidth;
	        var originX = shape.x;
	        var originY = shape.y;
	        var originWidth = shape.width;
	        var originHeight = shape.height;
	        shape.x = subPixelOptimize(shape.x, lineWidth, true);
	        shape.y = subPixelOptimize(shape.y, lineWidth, true);
	        shape.width = Math.max(
	            subPixelOptimize(originX + originWidth, lineWidth, false) - shape.x,
	            originWidth === 0 ? 0 : 1
	        );
	        shape.height = Math.max(
	            subPixelOptimize(originY + originHeight, lineWidth, false) - shape.y,
	            originHeight === 0 ? 0 : 1
	        );
	        return param;
	    };
	
	    /**
	     * Sub pixel optimize for canvas
	     *
	     * @param {number} position Coordinate, such as x, y
	     * @param {number} lineWidth Should be nonnegative integer.
	     * @param {boolean=} positiveOrNegative Default false (negative).
	     * @return {number} Optimized position.
	     */
	    graphic.subPixelOptimize = function (position, lineWidth, positiveOrNegative) {
	        // Assure that (position + lineWidth / 2) is near integer edge,
	        // otherwise line will be fuzzy in canvas.
	        var doubledPosition = round(position * 2);
	        return (doubledPosition + round(lineWidth)) % 2 === 0
	            ? doubledPosition / 2
	            : (doubledPosition + (positiveOrNegative ? 1 : -1)) / 2;
	    };
	
	    /**
	     * @private
	     */
	    function doSingleEnterHover(el) {
	        if (el.__isHover) {
	            return;
	        }
	        if (el.__hoverStlDirty) {
	            var stroke = el.style.stroke;
	            var fill = el.style.fill;
	
	            // Create hoverStyle on mouseover
	            var hoverStyle = el.__hoverStl;
	            var lift = colorTool.lift;
	            hoverStyle.fill = hoverStyle.fill
	                || (fill && (fill instanceof Gradient ? fill : lift(fill, -0.1)));
	            hoverStyle.stroke = hoverStyle.stroke
	                || (stroke && (stroke instanceof Gradient ? stroke : lift(stroke, -0.1)));
	
	            var normalStyle = {};
	            for (var name in hoverStyle) {
	                if (hoverStyle.hasOwnProperty(name)) {
	                    normalStyle[name] = el.style[name];
	                }
	            }
	
	            el.__normalStl = normalStyle;
	
	            el.__hoverStlDirty = false;
	        }
	        el.setStyle(el.__hoverStl);
	        el.z2 += 1;
	
	        el.__isHover = true;
	    }
	
	    /**
	     * @inner
	     */
	    function doSingleLeaveHover(el) {
	        if (!el.__isHover) {
	            return;
	        }
	
	        var normalStl = el.__normalStl;
	        normalStl && el.setStyle(normalStl);
	        el.z2 -= 1;
	
	        el.__isHover = false;
	    }
	
	    /**
	     * @inner
	     */
	    function doEnterHover(el) {
	        el.type === 'group'
	            ? el.traverse(function (child) {
	                if (child.type !== 'group') {
	                    doSingleEnterHover(child);
	                }
	            })
	            : doSingleEnterHover(el);
	    }
	    graphic.doEnterHover = doEnterHover;
	    function doLeaveHover(el) {
	        el.type === 'group'
	            ? el.traverse(function (child) {
	                if (child.type !== 'group') {
	                    doSingleLeaveHover(child);
	                }
	            })
	            : doSingleLeaveHover(el);
	    }
	    graphic.doLeaveHover = doLeaveHover;
	    /**
	     * @inner
	     */
	    function setElementHoverStl(el, hoverStl) {
	        // If element has sepcified hoverStyle, then use it instead of given hoverStyle
	        // Often used when item group has a label element and it's hoverStyle is different
	        el.__hoverStl = el.hoverStyle || hoverStl || {};
	        el.__hoverStlDirty = true;
	    }
	    graphic.setElementHoverStl = setElementHoverStl;
	    /**
	     * @inner
	     */
	    function onElementMouseOver() {
	        // Only if element is not in emphasis status
	        !this.__isEmphasis && doEnterHover(this);
	    }
	
	    /**
	     * @inner
	     */
	    function onElementMouseOut() {
	        // Only if element is not in emphasis status
	        !this.__isEmphasis && doLeaveHover(this);
	    }
	
	    /**
	     * @inner
	     */
	    function enterEmphasis() {
	        this.__isEmphasis = true;
	        doEnterHover(this);
	    }
	
	    /**
	     * @inner
	     */
	    function leaveEmphasis() {
	        this.__isEmphasis = false;
	        doLeaveHover(this);
	    }
	
	    /**
	     * Set hover style of element
	     * @param {module:zrender/Element} el
	     * @param {Object} [hoverStyle]
	     */
	    graphic.setHoverStyle = function (el, hoverStyle) {
	        el.type === 'group'
	            ? el.traverse(function (child) {
	                if (child.type !== 'group') {
	                    setElementHoverStl(child, hoverStyle);
	                }
	            })
	            : setElementHoverStl(el, hoverStyle);
	        // Remove previous bound handlers
	        el.on('mouseover', onElementMouseOver)
	          .on('mouseout', onElementMouseOut);
	
	        // Emphasis, normal can be triggered manually
	        el.on('emphasis', enterEmphasis)
	          .on('normal', leaveEmphasis);
	    };
	
	    graphic.setNormalStyle = function(el, options) {
	        if (el.__normalStl) {
	            for (var name in options) {
	                if (el.__normalStl.hasOwnProperty(name)) {
	                    el.__normalStl[name] = options[name];
	                }
	            }
	        }
	    };
	
	    /**
	     * Set text option in the style
	     * @param {Object} textStyle
	     * @param {module:echarts/model/Model} labelModel
	     * @param {string} color
	     */
	    graphic.setText = function (textStyle, labelModel, color) {
	        var labelPosition = labelModel.getShallow('position') || 'inside';
	        var labelColor = labelPosition.indexOf('inside') >= 0 ? 'white' : color;
	        var textStyleModel = labelModel.getModel('textStyle');
	        zrUtil.extend(textStyle, {
	            textDistance: labelModel.getShallow('distance') || 5,
	            textFont: textStyleModel.getFont(),
	            textPosition: labelPosition,
	            textFill: textStyleModel.getTextColor() || labelColor
	        });
	    };
	
	    function animateOrSetProps(isUpdate, el, props, animatableModel, cb) {
	        var postfix = isUpdate ? 'Update' : '';
	        var duration = animatableModel
	            && animatableModel.getShallow('animationDuration' + postfix);
	        var animationEasing = animatableModel
	            && animatableModel.getShallow('animationEasing' + postfix);
	
	        animatableModel && animatableModel.getShallow('animation')
	            ? el.animateTo(props, duration, animationEasing, cb)
	            : (el.attr(props), cb && cb());
	    }
	    /**
	     * Update graphic element properties with or without animation according to the configuration in series
	     * @param {module:zrender/Element} el
	     * @param {Object} props
	     * @param {module:echarts/model/Model} [animatableModel]
	     * @param {Function} cb
	     */
	    graphic.updateProps = zrUtil.curry(animateOrSetProps, true);
	
	    /**
	     * Init graphic element properties with or without animation according to the configuration in series
	     * @param {module:zrender/Element} el
	     * @param {Object} props
	     * @param {module:echarts/model/Model} [animatableModel]
	     * @param {Function} cb
	     */
	    graphic.initProps = zrUtil.curry(animateOrSetProps, false);
	
	    /**
	     * Get transform matrix of target (param target),
	     * in coordinate of its ancestor (param ancestor)
	     *
	     * @param {module:zrender/mixin/Transformable} target
	     * @param {module:zrender/mixin/Transformable} ancestor
	     */
	    graphic.getTransform = function (target, ancestor) {
	        var mat = matrix.identity([]);
	
	        while (target && target !== ancestor) {
	            matrix.mul(mat, target.getLocalTransform(), mat);
	            target = target.parent;
	        }
	
	        return mat;
	    };
	
	    /**
	     * Apply transform to an vertex.
	     * @param {Array.<number>} vertex [x, y]
	     * @param {Array.<number>} transform Transform matrix: like [1, 0, 0, 1, 0, 0]
	     * @param {boolean=} invert Whether use invert matrix.
	     * @return {Array.<number>} [x, y]
	     */
	    graphic.applyTransform = function (vertex, transform, invert) {
	        if (invert) {
	            transform = matrix.invert([], transform);
	        }
	        return vector.applyTransform([], vertex, transform);
	    };
	
	    /**
	     * @param {string} direction 'left' 'right' 'top' 'bottom'
	     * @param {Array.<number>} transform Transform matrix: like [1, 0, 0, 1, 0, 0]
	     * @param {boolean=} invert Whether use invert matrix.
	     * @return {string} Transformed direction. 'left' 'right' 'top' 'bottom'
	     */
	    graphic.transformDirection = function (direction, transform, invert) {
	
	        // Pick a base, ensure that transform result will not be (0, 0).
	        var hBase = (transform[4] === 0 || transform[5] === 0 || transform[0] === 0)
	            ? 1 : Math.abs(2 * transform[4] / transform[0]);
	        var vBase = (transform[4] === 0 || transform[5] === 0 || transform[2] === 0)
	            ? 1 : Math.abs(2 * transform[4] / transform[2]);
	
	        var vertex = [
	            direction === 'left' ? -hBase : direction === 'right' ? hBase : 0,
	            direction === 'top' ? -vBase : direction === 'bottom' ? vBase : 0
	        ];
	
	        vertex = graphic.applyTransform(vertex, transform, invert);
	
	        return Math.abs(vertex[0]) > Math.abs(vertex[1])
	            ? (vertex[0] > 0 ? 'right' : 'left')
	            : (vertex[1] > 0 ? 'bottom' : 'top');
	    };
	
	    module.exports = graphic;
	


/***/ },
/* 4 */
/***/ function(module, exports) {

	/**
	 * @module zrender/core/util
	 */
	
	
	    // 用于处理merge时无法遍历Date等对象的问题
	    var BUILTIN_OBJECT = {
	        '[object Function]': 1,
	        '[object RegExp]': 1,
	        '[object Date]': 1,
	        '[object Error]': 1,
	        '[object CanvasGradient]': 1,
	        '[object CanvasPattern]': 1,
	        // In node-canvas Image can be Canvas.Image
	        '[object Image]': 1
	    };
	
	    var objToString = Object.prototype.toString;
	
	    var arrayProto = Array.prototype;
	    var nativeForEach = arrayProto.forEach;
	    var nativeFilter = arrayProto.filter;
	    var nativeSlice = arrayProto.slice;
	    var nativeMap = arrayProto.map;
	    var nativeReduce = arrayProto.reduce;
	
	    /**
	     * @param {*} source
	     * @return {*} 拷贝后的新对象
	     */
	    function clone(source) {
	        if (typeof source == 'object' && source !== null) {
	            var result = source;
	            if (source instanceof Array) {
	                result = [];
	                for (var i = 0, len = source.length; i < len; i++) {
	                    result[i] = clone(source[i]);
	                }
	            }
	            else if (
	                !isBuildInObject(source)
	                // 是否为 dom 对象
	                && !isDom(source)
	            ) {
	                result = {};
	                for (var key in source) {
	                    if (source.hasOwnProperty(key)) {
	                        result[key] = clone(source[key]);
	                    }
	                }
	            }
	
	            return result;
	        }
	
	        return source;
	    }
	
	    /**
	     * @memberOf module:zrender/core/util
	     * @param {*} target
	     * @param {*} source
	     * @param {boolean} [overwrite=false]
	     */
	    function merge(target, source, overwrite) {
	        // We should escapse that source is string
	        // and enter for ... in ...
	        if (!isObject(source) || !isObject(target)) {
	            return overwrite ? clone(source) : target;
	        }
	
	        for (var key in source) {
	            if (source.hasOwnProperty(key)) {
	                var targetProp = target[key];
	                var sourceProp = source[key];
	
	                if (isObject(sourceProp)
	                    && isObject(targetProp)
	                    && !isArray(sourceProp)
	                    && !isArray(targetProp)
	                    && !isDom(sourceProp)
	                    && !isDom(targetProp)
	                    && !isBuildInObject(sourceProp)
	                    && !isBuildInObject(targetProp)
	                ) {
	                    // 如果需要递归覆盖，就递归调用merge
	                    merge(targetProp, sourceProp, overwrite);
	                }
	                else if (overwrite || !(key in target)) {
	                    // 否则只处理overwrite为true，或者在目标对象中没有此属性的情况
	                    // NOTE，在 target[key] 不存在的时候也是直接覆盖
	                    target[key] = clone(source[key], true);
	                }
	            }
	        }
	
	        return target;
	    }
	
	    /**
	     * @param {Array} targetAndSources The first item is target, and the rests are source.
	     * @param {boolean} [overwrite=false]
	     * @return {*} target
	     */
	    function mergeAll(targetAndSources, overwrite) {
	        var result = targetAndSources[0];
	        for (var i = 1, len = targetAndSources.length; i < len; i++) {
	            result = merge(result, targetAndSources[i], overwrite);
	        }
	        return result;
	    }
	
	    /**
	     * @param {*} target
	     * @param {*} source
	     * @memberOf module:zrender/core/util
	     */
	    function extend(target, source) {
	        for (var key in source) {
	            if (source.hasOwnProperty(key)) {
	                target[key] = source[key];
	            }
	        }
	        return target;
	    }
	
	    /**
	     * @param {*} target
	     * @param {*} source
	     * @param {boolen} [overlay=false]
	     * @memberOf module:zrender/core/util
	     */
	    function defaults(target, source, overlay) {
	        for (var key in source) {
	            if (source.hasOwnProperty(key)
	                && (overlay ? source[key] != null : target[key] == null)
	            ) {
	                target[key] = source[key];
	            }
	        }
	        return target;
	    }
	
	    function createCanvas() {
	        return document.createElement('canvas');
	    }
	    // FIXME
	    var _ctx;
	    function getContext() {
	        if (!_ctx) {
	            // Use util.createCanvas instead of createCanvas
	            // because createCanvas may be overwritten in different environment
	            _ctx = util.createCanvas().getContext('2d');
	        }
	        return _ctx;
	    }
	
	    /**
	     * 查询数组中元素的index
	     * @memberOf module:zrender/core/util
	     */
	    function indexOf(array, value) {
	        if (array) {
	            if (array.indexOf) {
	                return array.indexOf(value);
	            }
	            for (var i = 0, len = array.length; i < len; i++) {
	                if (array[i] === value) {
	                    return i;
	                }
	            }
	        }
	        return -1;
	    }
	
	    /**
	     * 构造类继承关系
	     *
	     * @memberOf module:zrender/core/util
	     * @param {Function} clazz 源类
	     * @param {Function} baseClazz 基类
	     */
	    function inherits(clazz, baseClazz) {
	        var clazzPrototype = clazz.prototype;
	        function F() {}
	        F.prototype = baseClazz.prototype;
	        clazz.prototype = new F();
	
	        for (var prop in clazzPrototype) {
	            clazz.prototype[prop] = clazzPrototype[prop];
	        }
	        clazz.prototype.constructor = clazz;
	        clazz.superClass = baseClazz;
	    }
	
	    /**
	     * @memberOf module:zrender/core/util
	     * @param {Object|Function} target
	     * @param {Object|Function} sorce
	     * @param {boolean} overlay
	     */
	    function mixin(target, source, overlay) {
	        target = 'prototype' in target ? target.prototype : target;
	        source = 'prototype' in source ? source.prototype : source;
	
	        defaults(target, source, overlay);
	    }
	
	    /**
	     * @param {Array|TypedArray} data
	     */
	    function isArrayLike(data) {
	        if (! data) {
	            return;
	        }
	        if (typeof data == 'string') {
	            return false;
	        }
	        return typeof data.length == 'number';
	    }
	
	    /**
	     * 数组或对象遍历
	     * @memberOf module:zrender/core/util
	     * @param {Object|Array} obj
	     * @param {Function} cb
	     * @param {*} [context]
	     */
	    function each(obj, cb, context) {
	        if (!(obj && cb)) {
	            return;
	        }
	        if (obj.forEach && obj.forEach === nativeForEach) {
	            obj.forEach(cb, context);
	        }
	        else if (obj.length === +obj.length) {
	            for (var i = 0, len = obj.length; i < len; i++) {
	                cb.call(context, obj[i], i, obj);
	            }
	        }
	        else {
	            for (var key in obj) {
	                if (obj.hasOwnProperty(key)) {
	                    cb.call(context, obj[key], key, obj);
	                }
	            }
	        }
	    }
	
	    /**
	     * 数组映射
	     * @memberOf module:zrender/core/util
	     * @param {Array} obj
	     * @param {Function} cb
	     * @param {*} [context]
	     * @return {Array}
	     */
	    function map(obj, cb, context) {
	        if (!(obj && cb)) {
	            return;
	        }
	        if (obj.map && obj.map === nativeMap) {
	            return obj.map(cb, context);
	        }
	        else {
	            var result = [];
	            for (var i = 0, len = obj.length; i < len; i++) {
	                result.push(cb.call(context, obj[i], i, obj));
	            }
	            return result;
	        }
	    }
	
	    /**
	     * @memberOf module:zrender/core/util
	     * @param {Array} obj
	     * @param {Function} cb
	     * @param {Object} [memo]
	     * @param {*} [context]
	     * @return {Array}
	     */
	    function reduce(obj, cb, memo, context) {
	        if (!(obj && cb)) {
	            return;
	        }
	        if (obj.reduce && obj.reduce === nativeReduce) {
	            return obj.reduce(cb, memo, context);
	        }
	        else {
	            for (var i = 0, len = obj.length; i < len; i++) {
	                memo = cb.call(context, memo, obj[i], i, obj);
	            }
	            return memo;
	        }
	    }
	
	    /**
	     * 数组过滤
	     * @memberOf module:zrender/core/util
	     * @param {Array} obj
	     * @param {Function} cb
	     * @param {*} [context]
	     * @return {Array}
	     */
	    function filter(obj, cb, context) {
	        if (!(obj && cb)) {
	            return;
	        }
	        if (obj.filter && obj.filter === nativeFilter) {
	            return obj.filter(cb, context);
	        }
	        else {
	            var result = [];
	            for (var i = 0, len = obj.length; i < len; i++) {
	                if (cb.call(context, obj[i], i, obj)) {
	                    result.push(obj[i]);
	                }
	            }
	            return result;
	        }
	    }
	
	    /**
	     * 数组项查找
	     * @memberOf module:zrender/core/util
	     * @param {Array} obj
	     * @param {Function} cb
	     * @param {*} [context]
	     * @return {Array}
	     */
	    function find(obj, cb, context) {
	        if (!(obj && cb)) {
	            return;
	        }
	        for (var i = 0, len = obj.length; i < len; i++) {
	            if (cb.call(context, obj[i], i, obj)) {
	                return obj[i];
	            }
	        }
	    }
	
	    /**
	     * @memberOf module:zrender/core/util
	     * @param {Function} func
	     * @param {*} context
	     * @return {Function}
	     */
	    function bind(func, context) {
	        var args = nativeSlice.call(arguments, 2);
	        return function () {
	            return func.apply(context, args.concat(nativeSlice.call(arguments)));
	        };
	    }
	
	    /**
	     * @memberOf module:zrender/core/util
	     * @param {Function} func
	     * @return {Function}
	     */
	    function curry(func) {
	        var args = nativeSlice.call(arguments, 1);
	        return function () {
	            return func.apply(this, args.concat(nativeSlice.call(arguments)));
	        };
	    }
	
	    /**
	     * @memberOf module:zrender/core/util
	     * @param {*} value
	     * @return {boolean}
	     */
	    function isArray(value) {
	        return objToString.call(value) === '[object Array]';
	    }
	
	    /**
	     * @memberOf module:zrender/core/util
	     * @param {*} value
	     * @return {boolean}
	     */
	    function isFunction(value) {
	        return typeof value === 'function';
	    }
	
	    /**
	     * @memberOf module:zrender/core/util
	     * @param {*} value
	     * @return {boolean}
	     */
	    function isString(value) {
	        return objToString.call(value) === '[object String]';
	    }
	
	    /**
	     * @memberOf module:zrender/core/util
	     * @param {*} value
	     * @return {boolean}
	     */
	    function isObject(value) {
	        // Avoid a V8 JIT bug in Chrome 19-20.
	        // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
	        var type = typeof value;
	        return type === 'function' || (!!value && type == 'object');
	    }
	
	    /**
	     * @memberOf module:zrender/core/util
	     * @param {*} value
	     * @return {boolean}
	     */
	    function isBuildInObject(value) {
	        return !!BUILTIN_OBJECT[objToString.call(value)];
	    }
	
	    /**
	     * @memberOf module:zrender/core/util
	     * @param {*} value
	     * @return {boolean}
	     */
	    function isDom(value) {
	        return value && value.nodeType === 1
	               && typeof(value.nodeName) == 'string';
	    }
	
	    /**
	     * If value1 is not null, then return value1, otherwise judget rest of values.
	     * @memberOf module:zrender/core/util
	     * @return {*} Final value
	     */
	    function retrieve(values) {
	        for (var i = 0, len = arguments.length; i < len; i++) {
	            if (arguments[i] != null) {
	                return arguments[i];
	            }
	        }
	    }
	
	    /**
	     * @memberOf module:zrender/core/util
	     * @param {Array} arr
	     * @param {number} startIndex
	     * @param {number} endIndex
	     * @return {Array}
	     */
	    function slice() {
	        return Function.call.apply(nativeSlice, arguments);
	    }
	
	    /**
	     * @memberOf module:zrender/core/util
	     * @param {boolean} condition
	     * @param {string} message
	     */
	    function assert(condition, message) {
	        if (!condition) {
	            throw new Error(message);
	        }
	    }
	
	    var util = {
	        inherits: inherits,
	        mixin: mixin,
	        clone: clone,
	        merge: merge,
	        mergeAll: mergeAll,
	        extend: extend,
	        defaults: defaults,
	        getContext: getContext,
	        createCanvas: createCanvas,
	        indexOf: indexOf,
	        slice: slice,
	        find: find,
	        isArrayLike: isArrayLike,
	        each: each,
	        map: map,
	        reduce: reduce,
	        filter: filter,
	        bind: bind,
	        curry: curry,
	        isArray: isArray,
	        isString: isString,
	        isObject: isObject,
	        isFunction: isFunction,
	        isBuildInObject: isBuildInObject,
	        isDom: isDom,
	        retrieve: retrieve,
	        assert: assert,
	        noop: function () {}
	    };
	    module.exports = util;
	


/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	
	
	    var Path = __webpack_require__(6);
	    var PathProxy = __webpack_require__(25);
	    var transformPath = __webpack_require__(36);
	    var matrix = __webpack_require__(13);
	
	    // command chars
	    var cc = [
	        'm', 'M', 'l', 'L', 'v', 'V', 'h', 'H', 'z', 'Z',
	        'c', 'C', 'q', 'Q', 't', 'T', 's', 'S', 'a', 'A'
	    ];
	
	    var mathSqrt = Math.sqrt;
	    var mathSin = Math.sin;
	    var mathCos = Math.cos;
	    var PI = Math.PI;
	
	    var vMag = function(v) {
	        return Math.sqrt(v[0] * v[0] + v[1] * v[1]);
	    };
	    var vRatio = function(u, v) {
	        return (u[0] * v[0] + u[1] * v[1]) / (vMag(u) * vMag(v));
	    };
	    var vAngle = function(u, v) {
	        return (u[0] * v[1] < u[1] * v[0] ? -1 : 1)
	                * Math.acos(vRatio(u, v));
	    };
	
	    function processArc(x1, y1, x2, y2, fa, fs, rx, ry, psiDeg, cmd, path) {
	        var psi = psiDeg * (PI / 180.0);
	        var xp = mathCos(psi) * (x1 - x2) / 2.0
	                 + mathSin(psi) * (y1 - y2) / 2.0;
	        var yp = -1 * mathSin(psi) * (x1 - x2) / 2.0
	                 + mathCos(psi) * (y1 - y2) / 2.0;
	
	        var lambda = (xp * xp) / (rx * rx) + (yp * yp) / (ry * ry);
	
	        if (lambda > 1) {
	            rx *= mathSqrt(lambda);
	            ry *= mathSqrt(lambda);
	        }
	
	        var f = (fa === fs ? -1 : 1)
	            * mathSqrt((((rx * rx) * (ry * ry))
	                    - ((rx * rx) * (yp * yp))
	                    - ((ry * ry) * (xp * xp))) / ((rx * rx) * (yp * yp)
	                    + (ry * ry) * (xp * xp))
	                ) || 0;
	
	        var cxp = f * rx * yp / ry;
	        var cyp = f * -ry * xp / rx;
	
	        var cx = (x1 + x2) / 2.0
	                 + mathCos(psi) * cxp
	                 - mathSin(psi) * cyp;
	        var cy = (y1 + y2) / 2.0
	                + mathSin(psi) * cxp
	                + mathCos(psi) * cyp;
	
	        var theta = vAngle([ 1, 0 ], [ (xp - cxp) / rx, (yp - cyp) / ry ]);
	        var u = [ (xp - cxp) / rx, (yp - cyp) / ry ];
	        var v = [ (-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry ];
	        var dTheta = vAngle(u, v);
	
	        if (vRatio(u, v) <= -1) {
	            dTheta = PI;
	        }
	        if (vRatio(u, v) >= 1) {
	            dTheta = 0;
	        }
	        if (fs === 0 && dTheta > 0) {
	            dTheta = dTheta - 2 * PI;
	        }
	        if (fs === 1 && dTheta < 0) {
	            dTheta = dTheta + 2 * PI;
	        }
	
	        path.addData(cmd, cx, cy, rx, ry, theta, dTheta, psi, fs);
	    }
	
	    function createPathProxyFromString(data) {
	        if (!data) {
	            return [];
	        }
	
	        // command string
	        var cs = data.replace(/-/g, ' -')
	            .replace(/  /g, ' ')
	            .replace(/ /g, ',')
	            .replace(/,,/g, ',');
	
	        var n;
	        // create pipes so that we can split the data
	        for (n = 0; n < cc.length; n++) {
	            cs = cs.replace(new RegExp(cc[n], 'g'), '|' + cc[n]);
	        }
	
	        // create array
	        var arr = cs.split('|');
	        // init context point
	        var cpx = 0;
	        var cpy = 0;
	
	        var path = new PathProxy();
	        var CMD = PathProxy.CMD;
	
	        var prevCmd;
	        for (n = 1; n < arr.length; n++) {
	            var str = arr[n];
	            var c = str.charAt(0);
	            var off = 0;
	            var p = str.slice(1).replace(/e,-/g, 'e-').split(',');
	            var cmd;
	
	            if (p.length > 0 && p[0] === '') {
	                p.shift();
	            }
	
	            for (var i = 0; i < p.length; i++) {
	                p[i] = parseFloat(p[i]);
	            }
	            while (off < p.length && !isNaN(p[off])) {
	                if (isNaN(p[0])) {
	                    break;
	                }
	                var ctlPtx;
	                var ctlPty;
	
	                var rx;
	                var ry;
	                var psi;
	                var fa;
	                var fs;
	
	                var x1 = cpx;
	                var y1 = cpy;
	
	                // convert l, H, h, V, and v to L
	                switch (c) {
	                    case 'l':
	                        cpx += p[off++];
	                        cpy += p[off++];
	                        cmd = CMD.L;
	                        path.addData(cmd, cpx, cpy);
	                        break;
	                    case 'L':
	                        cpx = p[off++];
	                        cpy = p[off++];
	                        cmd = CMD.L;
	                        path.addData(cmd, cpx, cpy);
	                        break;
	                    case 'm':
	                        cpx += p[off++];
	                        cpy += p[off++];
	                        cmd = CMD.M;
	                        path.addData(cmd, cpx, cpy);
	                        c = 'l';
	                        break;
	                    case 'M':
	                        cpx = p[off++];
	                        cpy = p[off++];
	                        cmd = CMD.M;
	                        path.addData(cmd, cpx, cpy);
	                        c = 'L';
	                        break;
	                    case 'h':
	                        cpx += p[off++];
	                        cmd = CMD.L;
	                        path.addData(cmd, cpx, cpy);
	                        break;
	                    case 'H':
	                        cpx = p[off++];
	                        cmd = CMD.L;
	                        path.addData(cmd, cpx, cpy);
	                        break;
	                    case 'v':
	                        cpy += p[off++];
	                        cmd = CMD.L;
	                        path.addData(cmd, cpx, cpy);
	                        break;
	                    case 'V':
	                        cpy = p[off++];
	                        cmd = CMD.L;
	                        path.addData(cmd, cpx, cpy);
	                        break;
	                    case 'C':
	                        cmd = CMD.C;
	                        path.addData(
	                            cmd, p[off++], p[off++], p[off++], p[off++], p[off++], p[off++]
	                        );
	                        cpx = p[off - 2];
	                        cpy = p[off - 1];
	                        break;
	                    case 'c':
	                        cmd = CMD.C;
	                        path.addData(
	                            cmd,
	                            p[off++] + cpx, p[off++] + cpy,
	                            p[off++] + cpx, p[off++] + cpy,
	                            p[off++] + cpx, p[off++] + cpy
	                        );
	                        cpx += p[off - 2];
	                        cpy += p[off - 1];
	                        break;
	                    case 'S':
	                        ctlPtx = cpx;
	                        ctlPty = cpy;
	                        var len = path.len();
	                        var pathData = path.data;
	                        if (prevCmd === CMD.C) {
	                            ctlPtx += cpx - pathData[len - 4];
	                            ctlPty += cpy - pathData[len - 3];
	                        }
	                        cmd = CMD.C;
	                        x1 = p[off++];
	                        y1 = p[off++];
	                        cpx = p[off++];
	                        cpy = p[off++];
	                        path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);
	                        break;
	                    case 's':
	                        ctlPtx = cpx;
	                        ctlPty = cpy;
	                        var len = path.len();
	                        var pathData = path.data;
	                        if (prevCmd === CMD.C) {
	                            ctlPtx += cpx - pathData[len - 4];
	                            ctlPty += cpy - pathData[len - 3];
	                        }
	                        cmd = CMD.C;
	                        x1 = cpx + p[off++];
	                        y1 = cpy + p[off++];
	                        cpx += p[off++];
	                        cpy += p[off++];
	                        path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);
	                        break;
	                    case 'Q':
	                        x1 = p[off++];
	                        y1 = p[off++];
	                        cpx = p[off++];
	                        cpy = p[off++];
	                        cmd = CMD.Q;
	                        path.addData(cmd, x1, y1, cpx, cpy);
	                        break;
	                    case 'q':
	                        x1 = p[off++] + cpx;
	                        y1 = p[off++] + cpy;
	                        cpx += p[off++];
	                        cpy += p[off++];
	                        cmd = CMD.Q;
	                        path.addData(cmd, x1, y1, cpx, cpy);
	                        break;
	                    case 'T':
	                        ctlPtx = cpx;
	                        ctlPty = cpy;
	                        var len = path.len();
	                        var pathData = path.data;
	                        if (prevCmd === CMD.Q) {
	                            ctlPtx += cpx - pathData[len - 4];
	                            ctlPty += cpy - pathData[len - 3];
	                        }
	                        cpx = p[off++];
	                        cpy = p[off++];
	                        cmd = CMD.Q;
	                        path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);
	                        break;
	                    case 't':
	                        ctlPtx = cpx;
	                        ctlPty = cpy;
	                        var len = path.len();
	                        var pathData = path.data;
	                        if (prevCmd === CMD.Q) {
	                            ctlPtx += cpx - pathData[len - 4];
	                            ctlPty += cpy - pathData[len - 3];
	                        }
	                        cpx += p[off++];
	                        cpy += p[off++];
	                        cmd = CMD.Q;
	                        path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);
	                        break;
	                    case 'A':
	                        rx = p[off++];
	                        ry = p[off++];
	                        psi = p[off++];
	                        fa = p[off++];
	                        fs = p[off++];
	
	                        x1 = cpx, y1 = cpy;
	                        cpx = p[off++];
	                        cpy = p[off++];
	                        cmd = CMD.A;
	                        processArc(
	                            x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path
	                        );
	                        break;
	                    case 'a':
	                        rx = p[off++];
	                        ry = p[off++];
	                        psi = p[off++];
	                        fa = p[off++];
	                        fs = p[off++];
	
	                        x1 = cpx, y1 = cpy;
	                        cpx += p[off++];
	                        cpy += p[off++];
	                        cmd = CMD.A;
	                        processArc(
	                            x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path
	                        );
	                        break;
	                }
	            }
	
	            if (c === 'z' || c === 'Z') {
	                cmd = CMD.Z;
	                path.addData(cmd);
	            }
	
	            prevCmd = cmd;
	        }
	
	        path.toStatic();
	
	        return path;
	    }
	
	    // TODO Optimize double memory cost problem
	    function createPathOptions(str, opts) {
	        var pathProxy = createPathProxyFromString(str);
	        var transform;
	        opts = opts || {};
	        opts.buildPath = function (path) {
	            path.setData(pathProxy.data);
	            transform && transformPath(path, transform);
	            // Svg and vml renderer don't have context
	            var ctx = path.getContext();
	            if (ctx) {
	                path.rebuildPath(ctx);
	            }
	        };
	
	        opts.applyTransform = function (m) {
	            if (!transform) {
	                transform = matrix.create();
	            }
	            matrix.mul(transform, m, transform);
	            this.dirty(true);
	        };
	
	        return opts;
	    }
	
	    module.exports = {
	        /**
	         * Create a Path object from path string data
	         * http://www.w3.org/TR/SVG/paths.html#PathData
	         * @param  {Object} opts Other options
	         */
	        createFromString: function (str, opts) {
	            return new Path(createPathOptions(str, opts));
	        },
	
	        /**
	         * Create a Path class from path string data
	         * @param  {string} str
	         * @param  {Object} opts Other options
	         */
	        extendFromString: function (str, opts) {
	            return Path.extend(createPathOptions(str, opts));
	        },
	
	        /**
	         * Merge multiple paths
	         */
	        // TODO Apply transform
	        // TODO stroke dash
	        // TODO Optimize double memory cost problem
	        mergePath: function (pathEls, opts) {
	            var pathList = [];
	            var len = pathEls.length;
	            for (var i = 0; i < len; i++) {
	                var pathEl = pathEls[i];
	                if (pathEl.__dirty) {
	                    pathEl.buildPath(pathEl.path, pathEl.shape, true);
	                }
	                pathList.push(pathEl.path);
	            }
	
	            var pathBundle = new Path(opts);
	            pathBundle.buildPath = function (path) {
	                path.appendPath(pathList);
	                // Svg and vml renderer don't have context
	                var ctx = path.getContext();
	                if (ctx) {
	                    path.rebuildPath(ctx);
	                }
	            };
	
	            return pathBundle;
	        }
	    };


/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Path element
	 * @module zrender/graphic/Path
	 */
	
	
	
	    var Displayable = __webpack_require__(7);
	    var zrUtil = __webpack_require__(4);
	    var PathProxy = __webpack_require__(25);
	    var pathContain = __webpack_require__(28);
	
	    var Pattern = __webpack_require__(35);
	    var getCanvasPattern = Pattern.prototype.getCanvasPattern;
	
	    var abs = Math.abs;
	
	    /**
	     * @alias module:zrender/graphic/Path
	     * @extends module:zrender/graphic/Displayable
	     * @constructor
	     * @param {Object} opts
	     */
	    function Path(opts) {
	        Displayable.call(this, opts);
	
	        /**
	         * @type {module:zrender/core/PathProxy}
	         * @readOnly
	         */
	        this.path = new PathProxy();
	    }
	
	    Path.prototype = {
	
	        constructor: Path,
	
	        type: 'path',
	
	        __dirtyPath: true,
	
	        strokeContainThreshold: 5,
	
	        brush: function (ctx, prevEl) {
	            var style = this.style;
	            var path = this.path;
	            var hasStroke = style.hasStroke();
	            var hasFill = style.hasFill();
	            var fill = style.fill;
	            var stroke = style.stroke;
	            var hasFillGradient = hasFill && !!(fill.colorStops);
	            var hasStrokeGradient = hasStroke && !!(stroke.colorStops);
	            var hasFillPattern = hasFill && !!(fill.image);
	            var hasStrokePattern = hasStroke && !!(stroke.image);
	
	            style.bind(ctx, this, prevEl);
	            this.setTransform(ctx);
	
	            if (this.__dirty) {
	                var rect = this.getBoundingRect();
	                // Update gradient because bounding rect may changed
	                if (hasFillGradient) {
	                    this._fillGradient = style.getGradient(ctx, fill, rect);
	                }
	                if (hasStrokeGradient) {
	                    this._strokeGradient = style.getGradient(ctx, stroke, rect);
	                }
	            }
	            // Use the gradient or pattern
	            if (hasFillGradient) {
	                // PENDING If may have affect the state
	                ctx.fillStyle = this._fillGradient;
	            }
	            else if (hasFillPattern) {
	                ctx.fillStyle = getCanvasPattern.call(fill, ctx);
	            }
	            if (hasStrokeGradient) {
	                ctx.strokeStyle = this._strokeGradient;
	            }
	            else if (hasStrokePattern) {
	                ctx.strokeStyle = getCanvasPattern.call(stroke, ctx);
	            }
	
	            var lineDash = style.lineDash;
	            var lineDashOffset = style.lineDashOffset;
	
	            var ctxLineDash = !!ctx.setLineDash;
	
	            // Update path sx, sy
	            var scale = this.getGlobalScale();
	            path.setScale(scale[0], scale[1]);
	
	            // Proxy context
	            // Rebuild path in following 2 cases
	            // 1. Path is dirty
	            // 2. Path needs javascript implemented lineDash stroking.
	            //    In this case, lineDash information will not be saved in PathProxy
	            if (this.__dirtyPath || (
	                lineDash && !ctxLineDash && hasStroke
	            )) {
	                path = this.path.beginPath(ctx);
	
	                // Setting line dash before build path
	                if (lineDash && !ctxLineDash) {
	                    path.setLineDash(lineDash);
	                    path.setLineDashOffset(lineDashOffset);
	                }
	
	                this.buildPath(path, this.shape, false);
	
	                // Clear path dirty flag
	                this.__dirtyPath = false;
	            }
	            else {
	                // Replay path building
	                ctx.beginPath();
	                this.path.rebuildPath(ctx);
	            }
	
	            hasFill && path.fill(ctx);
	
	            if (lineDash && ctxLineDash) {
	                ctx.setLineDash(lineDash);
	                ctx.lineDashOffset = lineDashOffset;
	            }
	
	            hasStroke && path.stroke(ctx);
	
	            if (lineDash && ctxLineDash) {
	                // PENDING
	                // Remove lineDash
	                ctx.setLineDash([]);
	            }
	
	
	            this.restoreTransform(ctx);
	
	            // Draw rect text
	            if (style.text || style.text === 0) {
	                // var rect = this.getBoundingRect();
	                this.drawRectText(ctx, this.getBoundingRect());
	            }
	        },
	
	        // When bundling path, some shape may decide if use moveTo to begin a new subpath or closePath
	        // Like in circle
	        buildPath: function (ctx, shapeCfg, inBundle) {},
	
	        getBoundingRect: function () {
	            var rect = this._rect;
	            var style = this.style;
	            var needsUpdateRect = !rect;
	            if (needsUpdateRect) {
	                var path = this.path;
	                if (this.__dirtyPath) {
	                    path.beginPath();
	                    this.buildPath(path, this.shape, false);
	                }
	                rect = path.getBoundingRect();
	            }
	            this._rect = rect;
	
	            if (style.hasStroke()) {
	                // Needs update rect with stroke lineWidth when
	                // 1. Element changes scale or lineWidth
	                // 2. Shape is changed
	                var rectWithStroke = this._rectWithStroke || (this._rectWithStroke = rect.clone());
	                if (this.__dirty || needsUpdateRect) {
	                    rectWithStroke.copy(rect);
	                    // FIXME Must after updateTransform
	                    var w = style.lineWidth;
	                    // PENDING, Min line width is needed when line is horizontal or vertical
	                    var lineScale = style.strokeNoScale ? this.getLineScale() : 1;
	
	                    // Only add extra hover lineWidth when there are no fill
	                    if (!style.hasFill()) {
	                        w = Math.max(w, this.strokeContainThreshold || 4);
	                    }
	                    // Consider line width
	                    // Line scale can't be 0;
	                    if (lineScale > 1e-10) {
	                        rectWithStroke.width += w / lineScale;
	                        rectWithStroke.height += w / lineScale;
	                        rectWithStroke.x -= w / lineScale / 2;
	                        rectWithStroke.y -= w / lineScale / 2;
	                    }
	                }
	
	                // Return rect with stroke
	                return rectWithStroke;
	            }
	
	            return rect;
	        },
	
	        contain: function (x, y) {
	            var localPos = this.transformCoordToLocal(x, y);
	            var rect = this.getBoundingRect();
	            var style = this.style;
	            x = localPos[0];
	            y = localPos[1];
	
	            if (rect.contain(x, y)) {
	                var pathData = this.path.data;
	                if (style.hasStroke()) {
	                    var lineWidth = style.lineWidth;
	                    var lineScale = style.strokeNoScale ? this.getLineScale() : 1;
	                    // Line scale can't be 0;
	                    if (lineScale > 1e-10) {
	                        // Only add extra hover lineWidth when there are no fill
	                        if (!style.hasFill()) {
	                            lineWidth = Math.max(lineWidth, this.strokeContainThreshold);
	                        }
	                        if (pathContain.containStroke(
	                            pathData, lineWidth / lineScale, x, y
	                        )) {
	                            return true;
	                        }
	                    }
	                }
	                if (style.hasFill()) {
	                    return pathContain.contain(pathData, x, y);
	                }
	            }
	            return false;
	        },
	
	        /**
	         * @param  {boolean} dirtyPath
	         */
	        dirty: function (dirtyPath) {
	            if (dirtyPath == null) {
	                dirtyPath = true;
	            }
	            // Only mark dirty, not mark clean
	            if (dirtyPath) {
	                this.__dirtyPath = dirtyPath;
	                this._rect = null;
	            }
	
	            this.__dirty = true;
	
	            this.__zr && this.__zr.refresh();
	
	            // Used as a clipping path
	            if (this.__clipTarget) {
	                this.__clipTarget.dirty();
	            }
	        },
	
	        /**
	         * Alias for animate('shape')
	         * @param {boolean} loop
	         */
	        animateShape: function (loop) {
	            return this.animate('shape', loop);
	        },
	
	        // Overwrite attrKV
	        attrKV: function (key, value) {
	            // FIXME
	            if (key === 'shape') {
	                this.setShape(value);
	                this.__dirtyPath = true;
	                this._rect = null;
	            }
	            else {
	                Displayable.prototype.attrKV.call(this, key, value);
	            }
	        },
	
	        /**
	         * @param {Object|string} key
	         * @param {*} value
	         */
	        setShape: function (key, value) {
	            var shape = this.shape;
	            // Path from string may not have shape
	            if (shape) {
	                if (zrUtil.isObject(key)) {
	                    for (var name in key) {
	                        shape[name] = key[name];
	                    }
	                }
	                else {
	                    shape[key] = value;
	                }
	                this.dirty(true);
	            }
	            return this;
	        },
	
	        getLineScale: function () {
	            var m = this.transform;
	            // Get the line scale.
	            // Determinant of `m` means how much the area is enlarged by the
	            // transformation. So its square root can be used as a scale factor
	            // for width.
	            return m && abs(m[0] - 1) > 1e-10 && abs(m[3] - 1) > 1e-10
	                ? Math.sqrt(abs(m[0] * m[3] - m[2] * m[1]))
	                : 1;
	        }
	    };
	
	    /**
	     * 扩展一个 Path element, 比如星形，圆等。
	     * Extend a path element
	     * @param {Object} props
	     * @param {string} props.type Path type
	     * @param {Function} props.init Initialize
	     * @param {Function} props.buildPath Overwrite buildPath method
	     * @param {Object} [props.style] Extended default style config
	     * @param {Object} [props.shape] Extended default shape config
	     */
	    Path.extend = function (defaults) {
	        var Sub = function (opts) {
	            Path.call(this, opts);
	
	            if (defaults.style) {
	                // Extend default style
	                this.style.extendFrom(defaults.style, false);
	            }
	
	            // Extend default shape
	            var defaultShape = defaults.shape;
	            if (defaultShape) {
	                this.shape = this.shape || {};
	                var thisShape = this.shape;
	                for (var name in defaultShape) {
	                    if (
	                        ! thisShape.hasOwnProperty(name)
	                        && defaultShape.hasOwnProperty(name)
	                    ) {
	                        thisShape[name] = defaultShape[name];
	                    }
	                }
	            }
	
	            defaults.init && defaults.init.call(this, opts);
	        };
	
	        zrUtil.inherits(Sub, Path);
	
	        // FIXME 不能 extend position, rotation 等引用对象
	        for (var name in defaults) {
	            // Extending prototype values and methods
	            if (name !== 'style' && name !== 'shape') {
	                Sub.prototype[name] = defaults[name];
	            }
	        }
	
	        return Sub;
	    };
	
	    zrUtil.inherits(Path, Displayable);
	
	    module.exports = Path;


/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * 可绘制的图形基类
	 * Base class of all displayable graphic objects
	 * @module zrender/graphic/Displayable
	 */
	
	
	
	    var zrUtil = __webpack_require__(4);
	
	    var Style = __webpack_require__(8);
	
	    var Element = __webpack_require__(9);
	    var RectText = __webpack_require__(22);
	    // var Stateful = require('./mixin/Stateful');
	
	    /**
	     * @alias module:zrender/graphic/Displayable
	     * @extends module:zrender/Element
	     * @extends module:zrender/graphic/mixin/RectText
	     */
	    function Displayable(opts) {
	
	        opts = opts || {};
	
	        Element.call(this, opts);
	
	        // Extend properties
	        for (var name in opts) {
	            if (
	                opts.hasOwnProperty(name) &&
	                name !== 'style'
	            ) {
	                this[name] = opts[name];
	            }
	        }
	
	        /**
	         * @type {module:zrender/graphic/Style}
	         */
	        this.style = new Style(opts.style);
	
	        this._rect = null;
	        // Shapes for cascade clipping.
	        this.__clipPaths = [];
	
	        // FIXME Stateful must be mixined after style is setted
	        // Stateful.call(this, opts);
	    }
	
	    Displayable.prototype = {
	
	        constructor: Displayable,
	
	        type: 'displayable',
	
	        /**
	         * Displayable 是否为脏，Painter 中会根据该标记判断是否需要是否需要重新绘制
	         * Dirty flag. From which painter will determine if this displayable object needs brush
	         * @name module:zrender/graphic/Displayable#__dirty
	         * @type {boolean}
	         */
	        __dirty: true,
	
	        /**
	         * 图形是否可见，为true时不绘制图形，但是仍能触发鼠标事件
	         * If ignore drawing of the displayable object. Mouse event will still be triggered
	         * @name module:/zrender/graphic/Displayable#invisible
	         * @type {boolean}
	         * @default false
	         */
	        invisible: false,
	
	        /**
	         * @name module:/zrender/graphic/Displayable#z
	         * @type {number}
	         * @default 0
	         */
	        z: 0,
	
	        /**
	         * @name module:/zrender/graphic/Displayable#z
	         * @type {number}
	         * @default 0
	         */
	        z2: 0,
	
	        /**
	         * z层level，决定绘画在哪层canvas中
	         * @name module:/zrender/graphic/Displayable#zlevel
	         * @type {number}
	         * @default 0
	         */
	        zlevel: 0,
	
	        /**
	         * 是否可拖拽
	         * @name module:/zrender/graphic/Displayable#draggable
	         * @type {boolean}
	         * @default false
	         */
	        draggable: false,
	
	        /**
	         * 是否正在拖拽
	         * @name module:/zrender/graphic/Displayable#draggable
	         * @type {boolean}
	         * @default false
	         */
	        dragging: false,
	
	        /**
	         * 是否相应鼠标事件
	         * @name module:/zrender/graphic/Displayable#silent
	         * @type {boolean}
	         * @default false
	         */
	        silent: false,
	
	        /**
	         * If enable culling
	         * @type {boolean}
	         * @default false
	         */
	        culling: false,
	
	        /**
	         * Mouse cursor when hovered
	         * @name module:/zrender/graphic/Displayable#cursor
	         * @type {string}
	         */
	        cursor: 'pointer',
	
	        /**
	         * If hover area is bounding rect
	         * @name module:/zrender/graphic/Displayable#rectHover
	         * @type {string}
	         */
	        rectHover: false,
	
	        /**
	         * Render the element progressively when the value >= 0,
	         * usefull for large data.
	         * @type {number}
	         */
	        progressive: -1,
	
	        beforeBrush: function (ctx) {},
	
	        afterBrush: function (ctx) {},
	
	        /**
	         * 图形绘制方法
	         * @param {Canvas2DRenderingContext} ctx
	         */
	        // Interface
	        brush: function (ctx, prevEl) {},
	
	        /**
	         * 获取最小包围盒
	         * @return {module:zrender/core/BoundingRect}
	         */
	        // Interface
	        getBoundingRect: function () {},
	
	        /**
	         * 判断坐标 x, y 是否在图形上
	         * If displayable element contain coord x, y
	         * @param  {number} x
	         * @param  {number} y
	         * @return {boolean}
	         */
	        contain: function (x, y) {
	            return this.rectContain(x, y);
	        },
	
	        /**
	         * @param  {Function} cb
	         * @param  {}   context
	         */
	        traverse: function (cb, context) {
	            cb.call(context, this);
	        },
	
	        /**
	         * 判断坐标 x, y 是否在图形的包围盒上
	         * If bounding rect of element contain coord x, y
	         * @param  {number} x
	         * @param  {number} y
	         * @return {boolean}
	         */
	        rectContain: function (x, y) {
	            var coord = this.transformCoordToLocal(x, y);
	            var rect = this.getBoundingRect();
	            return rect.contain(coord[0], coord[1]);
	        },
	
	        /**
	         * 标记图形元素为脏，并且在下一帧重绘
	         * Mark displayable element dirty and refresh next frame
	         */
	        dirty: function () {
	            this.__dirty = true;
	
	            this._rect = null;
	
	            this.__zr && this.__zr.refresh();
	        },
	
	        /**
	         * 图形是否会触发事件
	         * If displayable object binded any event
	         * @return {boolean}
	         */
	        // TODO, 通过 bind 绑定的事件
	        // isSilent: function () {
	        //     return !(
	        //         this.hoverable || this.draggable
	        //         || this.onmousemove || this.onmouseover || this.onmouseout
	        //         || this.onmousedown || this.onmouseup || this.onclick
	        //         || this.ondragenter || this.ondragover || this.ondragleave
	        //         || this.ondrop
	        //     );
	        // },
	        /**
	         * Alias for animate('style')
	         * @param {boolean} loop
	         */
	        animateStyle: function (loop) {
	            return this.animate('style', loop);
	        },
	
	        attrKV: function (key, value) {
	            if (key !== 'style') {
	                Element.prototype.attrKV.call(this, key, value);
	            }
	            else {
	                this.style.set(value);
	            }
	        },
	
	        /**
	         * @param {Object|string} key
	         * @param {*} value
	         */
	        setStyle: function (key, value) {
	            this.style.set(key, value);
	            this.dirty(false);
	            return this;
	        },
	
	        /**
	         * Use given style object
	         * @param  {Object} obj
	         */
	        useStyle: function (obj) {
	            this.style = new Style(obj);
	            this.dirty(false);
	            return this;
	        }
	    };
	
	    zrUtil.inherits(Displayable, Element);
	
	    zrUtil.mixin(Displayable, RectText);
	    // zrUtil.mixin(Displayable, Stateful);
	
	    module.exports = Displayable;


/***/ },
/* 8 */
/***/ function(module, exports) {

	/**
	 * @module zrender/graphic/Style
	 */
	
	
	    var STYLE_COMMON_PROPS = [
	        ['shadowBlur', 0], ['shadowOffsetX', 0], ['shadowOffsetY', 0], ['shadowColor', '#000'],
	        ['lineCap', 'butt'], ['lineJoin', 'miter'], ['miterLimit', 10]
	    ];
	
	    // var SHADOW_PROPS = STYLE_COMMON_PROPS.slice(0, 4);
	    // var LINE_PROPS = STYLE_COMMON_PROPS.slice(4);
	
	    var Style = function (opts) {
	        this.extendFrom(opts);
	    };
	
	    function createLinearGradient(ctx, obj, rect) {
	        // var size =
	        var x = obj.x;
	        var x2 = obj.x2;
	        var y = obj.y;
	        var y2 = obj.y2;
	
	        if (!obj.global) {
	            x = x * rect.width + rect.x;
	            x2 = x2 * rect.width + rect.x;
	            y = y * rect.height + rect.y;
	            y2 = y2 * rect.height + rect.y;
	        }
	
	        var canvasGradient = ctx.createLinearGradient(x, y, x2, y2);
	
	        return canvasGradient;
	    }
	
	    function createRadialGradient(ctx, obj, rect) {
	        var width = rect.width;
	        var height = rect.height;
	        var min = Math.min(width, height);
	
	        var x = obj.x;
	        var y = obj.y;
	        var r = obj.r;
	        if (!obj.global) {
	            x = x * width + rect.x;
	            y = y * height + rect.y;
	            r = r * min;
	        }
	
	        var canvasGradient = ctx.createRadialGradient(x, y, 0, x, y, r);
	
	        return canvasGradient;
	    }
	
	
	    Style.prototype = {
	
	        constructor: Style,
	
	        /**
	         * @type {string}
	         */
	        fill: '#000000',
	
	        /**
	         * @type {string}
	         */
	        stroke: null,
	
	        /**
	         * @type {number}
	         */
	        opacity: 1,
	
	        /**
	         * @type {Array.<number>}
	         */
	        lineDash: null,
	
	        /**
	         * @type {number}
	         */
	        lineDashOffset: 0,
	
	        /**
	         * @type {number}
	         */
	        shadowBlur: 0,
	
	        /**
	         * @type {number}
	         */
	        shadowOffsetX: 0,
	
	        /**
	         * @type {number}
	         */
	        shadowOffsetY: 0,
	
	        /**
	         * @type {number}
	         */
	        lineWidth: 1,
	
	        /**
	         * If stroke ignore scale
	         * @type {Boolean}
	         */
	        strokeNoScale: false,
	
	        // Bounding rect text configuration
	        // Not affected by element transform
	        /**
	         * @type {string}
	         */
	        text: null,
	
	        /**
	         * @type {string}
	         */
	        textFill: '#000',
	
	        /**
	         * @type {string}
	         */
	        textStroke: null,
	
	        /**
	         * 'inside', 'left', 'right', 'top', 'bottom'
	         * [x, y]
	         * @type {string|Array.<number>}
	         * @default 'inside'
	         */
	        textPosition: 'inside',
	
	        /**
	         * @type {string}
	         */
	        textBaseline: null,
	
	        /**
	         * @type {string}
	         */
	        textAlign: null,
	
	        /**
	         * @type {string}
	         */
	        textVerticalAlign: null,
	
	        /**
	         * Only useful in Path and Image element
	         * @type {number}
	         */
	        textDistance: 5,
	
	        /**
	         * Only useful in Path and Image element
	         * @type {number}
	         */
	        textShadowBlur: 0,
	
	        /**
	         * Only useful in Path and Image element
	         * @type {number}
	         */
	        textShadowOffsetX: 0,
	
	        /**
	         * Only useful in Path and Image element
	         * @type {number}
	         */
	        textShadowOffsetY: 0,
	
	        /**
	         * If transform text
	         * Only useful in Path and Image element
	         * @type {boolean}
	         */
	        textTransform: false,
	
	        /**
	         * Text rotate around position of Path or Image
	         * Only useful in Path and Image element and textTransform is false.
	         */
	        textRotation: 0,
	
	        /**
	         * @type {string}
	         * https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation
	         */
	        blend: null,
	
	        /**
	         * @param {CanvasRenderingContext2D} ctx
	         */
	        bind: function (ctx, el, prevEl) {
	            var style = this;
	            var prevStyle = prevEl && prevEl.style;
	            var firstDraw = !prevStyle;
	
	            for (var i = 0; i < STYLE_COMMON_PROPS.length; i++) {
	                var prop = STYLE_COMMON_PROPS[i];
	                var styleName = prop[0];
	
	                if (firstDraw || style[styleName] !== prevStyle[styleName]) {
	                    // FIXME Invalid property value will cause style leak from previous element.
	                    ctx[styleName] = style[styleName] || prop[1];
	                }
	            }
	
	            if ((firstDraw || style.fill !== prevStyle.fill)) {
	                ctx.fillStyle = style.fill;
	            }
	            if ((firstDraw || style.stroke !== prevStyle.stroke)) {
	                ctx.strokeStyle = style.stroke;
	            }
	            if ((firstDraw || style.opacity !== prevStyle.opacity)) {
	                ctx.globalAlpha = style.opacity == null ? 1 : style.opacity;
	            }
	
	            if ((firstDraw || style.blend !== prevStyle.blend)) {
	                ctx.globalCompositeOperation = style.blend || 'source-over';
	            }
	            if (this.hasStroke()) {
	                var lineWidth = style.lineWidth;
	                ctx.lineWidth = lineWidth / (
	                    (this.strokeNoScale && el && el.getLineScale) ? el.getLineScale() : 1
	                );
	            }
	        },
	
	        hasFill: function () {
	            var fill = this.fill;
	            return fill != null && fill !== 'none';
	        },
	
	        hasStroke: function () {
	            var stroke = this.stroke;
	            return stroke != null && stroke !== 'none' && this.lineWidth > 0;
	        },
	
	        /**
	         * Extend from other style
	         * @param {zrender/graphic/Style} otherStyle
	         * @param {boolean} overwrite
	         */
	        extendFrom: function (otherStyle, overwrite) {
	            if (otherStyle) {
	                var target = this;
	                for (var name in otherStyle) {
	                    if (otherStyle.hasOwnProperty(name)
	                        && (overwrite || ! target.hasOwnProperty(name))
	                    ) {
	                        target[name] = otherStyle[name];
	                    }
	                }
	            }
	        },
	
	        /**
	         * Batch setting style with a given object
	         * @param {Object|string} obj
	         * @param {*} [obj]
	         */
	        set: function (obj, value) {
	            if (typeof obj === 'string') {
	                this[obj] = value;
	            }
	            else {
	                this.extendFrom(obj, true);
	            }
	        },
	
	        /**
	         * Clone
	         * @return {zrender/graphic/Style} [description]
	         */
	        clone: function () {
	            var newStyle = new this.constructor();
	            newStyle.extendFrom(this, true);
	            return newStyle;
	        },
	
	        getGradient: function (ctx, obj, rect) {
	            var method = obj.type === 'radial' ? createRadialGradient : createLinearGradient;
	            var canvasGradient = method(ctx, obj, rect);
	            var colorStops = obj.colorStops;
	            for (var i = 0; i < colorStops.length; i++) {
	                canvasGradient.addColorStop(
	                    colorStops[i].offset, colorStops[i].color
	                );
	            }
	            return canvasGradient;
	        }
	    };
	
	    var styleProto = Style.prototype;
	    for (var i = 0; i < STYLE_COMMON_PROPS.length; i++) {
	        var prop = STYLE_COMMON_PROPS[i];
	        if (!(prop[0] in styleProto)) {
	            styleProto[prop[0]] = prop[1];
	        }
	    }
	
	    // Provide for others
	    Style.getGradient = styleProto.getGradient;
	
	    module.exports = Style;


/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	/**
	 * @module zrender/Element
	 */
	
	
	    var guid = __webpack_require__(10);
	    var Eventful = __webpack_require__(11);
	    var Transformable = __webpack_require__(12);
	    var Animatable = __webpack_require__(15);
	    var zrUtil = __webpack_require__(4);
	
	    /**
	     * @alias module:zrender/Element
	     * @constructor
	     * @extends {module:zrender/mixin/Animatable}
	     * @extends {module:zrender/mixin/Transformable}
	     * @extends {module:zrender/mixin/Eventful}
	     */
	    var Element = function (opts) {
	
	        Transformable.call(this, opts);
	        Eventful.call(this, opts);
	        Animatable.call(this, opts);
	
	        /**
	         * 画布元素ID
	         * @type {string}
	         */
	        this.id = opts.id || guid();
	    };
	
	    Element.prototype = {
	
	        /**
	         * 元素类型
	         * Element type
	         * @type {string}
	         */
	        type: 'element',
	
	        /**
	         * 元素名字
	         * Element name
	         * @type {string}
	         */
	        name: '',
	
	        /**
	         * ZRender 实例对象，会在 element 添加到 zrender 实例中后自动赋值
	         * ZRender instance will be assigned when element is associated with zrender
	         * @name module:/zrender/Element#__zr
	         * @type {module:zrender/ZRender}
	         */
	        __zr: null,
	
	        /**
	         * 图形是否忽略，为true时忽略图形的绘制以及事件触发
	         * If ignore drawing and events of the element object
	         * @name module:/zrender/Element#ignore
	         * @type {boolean}
	         * @default false
	         */
	        ignore: false,
	
	        /**
	         * 用于裁剪的路径(shape)，所有 Group 内的路径在绘制时都会被这个路径裁剪
	         * 该路径会继承被裁减对象的变换
	         * @type {module:zrender/graphic/Path}
	         * @see http://www.w3.org/TR/2dcontext/#clipping-region
	         * @readOnly
	         */
	        clipPath: null,
	
	        /**
	         * Drift element
	         * @param  {number} dx dx on the global space
	         * @param  {number} dy dy on the global space
	         */
	        drift: function (dx, dy) {
	            switch (this.draggable) {
	                case 'horizontal':
	                    dy = 0;
	                    break;
	                case 'vertical':
	                    dx = 0;
	                    break;
	            }
	
	            var m = this.transform;
	            if (!m) {
	                m = this.transform = [1, 0, 0, 1, 0, 0];
	            }
	            m[4] += dx;
	            m[5] += dy;
	
	            this.decomposeTransform();
	            this.dirty(false);
	        },
	
	        /**
	         * Hook before update
	         */
	        beforeUpdate: function () {},
	        /**
	         * Hook after update
	         */
	        afterUpdate: function () {},
	        /**
	         * Update each frame
	         */
	        update: function () {
	            this.updateTransform();
	        },
	
	        /**
	         * @param  {Function} cb
	         * @param  {}   context
	         */
	        traverse: function (cb, context) {},
	
	        /**
	         * @protected
	         */
	        attrKV: function (key, value) {
	            if (key === 'position' || key === 'scale' || key === 'origin') {
	                // Copy the array
	                if (value) {
	                    var target = this[key];
	                    if (!target) {
	                        target = this[key] = [];
	                    }
	                    target[0] = value[0];
	                    target[1] = value[1];
	                }
	            }
	            else {
	                this[key] = value;
	            }
	        },
	
	        /**
	         * Hide the element
	         */
	        hide: function () {
	            this.ignore = true;
	            this.__zr && this.__zr.refresh();
	        },
	
	        /**
	         * Show the element
	         */
	        show: function () {
	            this.ignore = false;
	            this.__zr && this.__zr.refresh();
	        },
	
	        /**
	         * @param {string|Object} key
	         * @param {*} value
	         */
	        attr: function (key, value) {
	            if (typeof key === 'string') {
	                this.attrKV(key, value);
	            }
	            else if (zrUtil.isObject(key)) {
	                for (var name in key) {
	                    if (key.hasOwnProperty(name)) {
	                        this.attrKV(name, key[name]);
	                    }
	                }
	            }
	
	            this.dirty(false);
	
	            return this;
	        },
	
	        /**
	         * @param {module:zrender/graphic/Path} clipPath
	         */
	        setClipPath: function (clipPath) {
	            var zr = this.__zr;
	            if (zr) {
	                clipPath.addSelfToZr(zr);
	            }
	
	            // Remove previous clip path
	            if (this.clipPath && this.clipPath !== clipPath) {
	                this.removeClipPath();
	            }
	
	            this.clipPath = clipPath;
	            clipPath.__zr = zr;
	            clipPath.__clipTarget = this;
	
	            this.dirty(false);
	        },
	
	        /**
	         */
	        removeClipPath: function () {
	            var clipPath = this.clipPath;
	            if (clipPath) {
	                if (clipPath.__zr) {
	                    clipPath.removeSelfFromZr(clipPath.__zr);
	                }
	
	                clipPath.__zr = null;
	                clipPath.__clipTarget = null;
	                this.clipPath = null;
	
	                this.dirty(false);
	            }
	        },
	
	        /**
	         * Add self from zrender instance.
	         * Not recursively because it will be invoked when element added to storage.
	         * @param {module:zrender/ZRender} zr
	         */
	        addSelfToZr: function (zr) {
	            this.__zr = zr;
	            // 添加动画
	            var animators = this.animators;
	            if (animators) {
	                for (var i = 0; i < animators.length; i++) {
	                    zr.animation.addAnimator(animators[i]);
	                }
	            }
	
	            if (this.clipPath) {
	                this.clipPath.addSelfToZr(zr);
	            }
	        },
	
	        /**
	         * Remove self from zrender instance.
	         * Not recursively because it will be invoked when element added to storage.
	         * @param {module:zrender/ZRender} zr
	         */
	        removeSelfFromZr: function (zr) {
	            this.__zr = null;
	            // 移除动画
	            var animators = this.animators;
	            if (animators) {
	                for (var i = 0; i < animators.length; i++) {
	                    zr.animation.removeAnimator(animators[i]);
	                }
	            }
	
	            if (this.clipPath) {
	                this.clipPath.removeSelfFromZr(zr);
	            }
	        }
	    };
	
	    zrUtil.mixin(Element, Animatable);
	    zrUtil.mixin(Element, Transformable);
	    zrUtil.mixin(Element, Eventful);
	
	    module.exports = Element;


/***/ },
/* 10 */
/***/ function(module, exports) {

	/**
	 * zrender: 生成唯一id
	 *
	 * @author errorrik (errorrik@gmail.com)
	 */
	
	
	    var idStart = 0x0907;
	
	    module.exports = function () {
	        return idStart++;
	    };
	


/***/ },
/* 11 */
/***/ function(module, exports) {

	/**
	 * 事件扩展
	 * @module zrender/mixin/Eventful
	 * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)
	 *         pissang (https://www.github.com/pissang)
	 */
	
	
	    var arrySlice = Array.prototype.slice;
	
	    /**
	     * 事件分发器
	     * @alias module:zrender/mixin/Eventful
	     * @constructor
	     */
	    var Eventful = function () {
	        this._$handlers = {};
	    };
	
	    Eventful.prototype = {
	
	        constructor: Eventful,
	
	        /**
	         * 单次触发绑定，trigger后销毁
	         *
	         * @param {string} event 事件名
	         * @param {Function} handler 响应函数
	         * @param {Object} context
	         */
	        one: function (event, handler, context) {
	            var _h = this._$handlers;
	
	            if (!handler || !event) {
	                return this;
	            }
	
	            if (!_h[event]) {
	                _h[event] = [];
	            }
	
	            for (var i = 0; i < _h[event].length; i++) {
	                if (_h[event][i].h === handler) {
	                    return this;
	                }
	            }
	
	            _h[event].push({
	                h: handler,
	                one: true,
	                ctx: context || this
	            });
	
	            return this;
	        },
	
	        /**
	         * 绑定事件
	         * @param {string} event 事件名
	         * @param {Function} handler 事件处理函数
	         * @param {Object} [context]
	         */
	        on: function (event, handler, context) {
	            var _h = this._$handlers;
	
	            if (!handler || !event) {
	                return this;
	            }
	
	            if (!_h[event]) {
	                _h[event] = [];
	            }
	
	            for (var i = 0; i < _h[event].length; i++) {
	                if (_h[event][i].h === handler) {
	                    return this;
	                }
	            }
	
	            _h[event].push({
	                h: handler,
	                one: false,
	                ctx: context || this
	            });
	
	            return this;
	        },
	
	        /**
	         * 是否绑定了事件
	         * @param  {string}  event
	         * @return {boolean}
	         */
	        isSilent: function (event) {
	            var _h = this._$handlers;
	            return _h[event] && _h[event].length;
	        },
	
	        /**
	         * 解绑事件
	         * @param {string} event 事件名
	         * @param {Function} [handler] 事件处理函数
	         */
	        off: function (event, handler) {
	            var _h = this._$handlers;
	
	            if (!event) {
	                this._$handlers = {};
	                return this;
	            }
	
	            if (handler) {
	                if (_h[event]) {
	                    var newList = [];
	                    for (var i = 0, l = _h[event].length; i < l; i++) {
	                        if (_h[event][i]['h'] != handler) {
	                            newList.push(_h[event][i]);
	                        }
	                    }
	                    _h[event] = newList;
	                }
	
	                if (_h[event] && _h[event].length === 0) {
	                    delete _h[event];
	                }
	            }
	            else {
	                delete _h[event];
	            }
	
	            return this;
	        },
	
	        /**
	         * 事件分发
	         *
	         * @param {string} type 事件类型
	         */
	        trigger: function (type) {
	            if (this._$handlers[type]) {
	                var args = arguments;
	                var argLen = args.length;
	
	                if (argLen > 3) {
	                    args = arrySlice.call(args, 1);
	                }
	
	                var _h = this._$handlers[type];
	                var len = _h.length;
	                for (var i = 0; i < len;) {
	                    // Optimize advise from backbone
	                    switch (argLen) {
	                        case 1:
	                            _h[i]['h'].call(_h[i]['ctx']);
	                            break;
	                        case 2:
	                            _h[i]['h'].call(_h[i]['ctx'], args[1]);
	                            break;
	                        case 3:
	                            _h[i]['h'].call(_h[i]['ctx'], args[1], args[2]);
	                            break;
	                        default:
	                            // have more than 2 given arguments
	                            _h[i]['h'].apply(_h[i]['ctx'], args);
	                            break;
	                    }
	
	                    if (_h[i]['one']) {
	                        _h.splice(i, 1);
	                        len--;
	                    }
	                    else {
	                        i++;
	                    }
	                }
	            }
	
	            return this;
	        },
	
	        /**
	         * 带有context的事件分发, 最后一个参数是事件回调的context
	         * @param {string} type 事件类型
	         */
	        triggerWithContext: function (type) {
	            if (this._$handlers[type]) {
	                var args = arguments;
	                var argLen = args.length;
	
	                if (argLen > 4) {
	                    args = arrySlice.call(args, 1, args.length - 1);
	                }
	                var ctx = args[args.length - 1];
	
	                var _h = this._$handlers[type];
	                var len = _h.length;
	                for (var i = 0; i < len;) {
	                    // Optimize advise from backbone
	                    switch (argLen) {
	                        case 1:
	                            _h[i]['h'].call(ctx);
	                            break;
	                        case 2:
	                            _h[i]['h'].call(ctx, args[1]);
	                            break;
	                        case 3:
	                            _h[i]['h'].call(ctx, args[1], args[2]);
	                            break;
	                        default:
	                            // have more than 2 given arguments
	                            _h[i]['h'].apply(ctx, args);
	                            break;
	                    }
	
	                    if (_h[i]['one']) {
	                        _h.splice(i, 1);
	                        len--;
	                    }
	                    else {
	                        i++;
	                    }
	                }
	            }
	
	            return this;
	        }
	    };
	
	    // 对象可以通过 onxxxx 绑定事件
	    /**
	     * @event module:zrender/mixin/Eventful#onclick
	     * @type {Function}
	     * @default null
	     */
	    /**
	     * @event module:zrender/mixin/Eventful#onmouseover
	     * @type {Function}
	     * @default null
	     */
	    /**
	     * @event module:zrender/mixin/Eventful#onmouseout
	     * @type {Function}
	     * @default null
	     */
	    /**
	     * @event module:zrender/mixin/Eventful#onmousemove
	     * @type {Function}
	     * @default null
	     */
	    /**
	     * @event module:zrender/mixin/Eventful#onmousewheel
	     * @type {Function}
	     * @default null
	     */
	    /**
	     * @event module:zrender/mixin/Eventful#onmousedown
	     * @type {Function}
	     * @default null
	     */
	    /**
	     * @event module:zrender/mixin/Eventful#onmouseup
	     * @type {Function}
	     * @default null
	     */
	    /**
	     * @event module:zrender/mixin/Eventful#ondragstart
	     * @type {Function}
	     * @default null
	     */
	    /**
	     * @event module:zrender/mixin/Eventful#ondragend
	     * @type {Function}
	     * @default null
	     */
	    /**
	     * @event module:zrender/mixin/Eventful#ondragenter
	     * @type {Function}
	     * @default null
	     */
	    /**
	     * @event module:zrender/mixin/Eventful#ondragleave
	     * @type {Function}
	     * @default null
	     */
	    /**
	     * @event module:zrender/mixin/Eventful#ondragover
	     * @type {Function}
	     * @default null
	     */
	    /**
	     * @event module:zrender/mixin/Eventful#ondrop
	     * @type {Function}
	     * @default null
	     */
	
	    module.exports = Eventful;
	


/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	/**
	 * 提供变换扩展
	 * @module zrender/mixin/Transformable
	 * @author pissang (https://www.github.com/pissang)
	 */
	
	
	    var matrix = __webpack_require__(13);
	    var vector = __webpack_require__(14);
	    var mIdentity = matrix.identity;
	
	    var EPSILON = 5e-5;
	
	    function isNotAroundZero(val) {
	        return val > EPSILON || val < -EPSILON;
	    }
	
	    /**
	     * @alias module:zrender/mixin/Transformable
	     * @constructor
	     */
	    var Transformable = function (opts) {
	        opts = opts || {};
	        // If there are no given position, rotation, scale
	        if (!opts.position) {
	            /**
	             * 平移
	             * @type {Array.<number>}
	             * @default [0, 0]
	             */
	            this.position = [0, 0];
	        }
	        if (opts.rotation == null) {
	            /**
	             * 旋转
	             * @type {Array.<number>}
	             * @default 0
	             */
	            this.rotation = 0;
	        }
	        if (!opts.scale) {
	            /**
	             * 缩放
	             * @type {Array.<number>}
	             * @default [1, 1]
	             */
	            this.scale = [1, 1];
	        }
	        /**
	         * 旋转和缩放的原点
	         * @type {Array.<number>}
	         * @default null
	         */
	        this.origin = this.origin || null;
	    };
	
	    var transformableProto = Transformable.prototype;
	    transformableProto.transform = null;
	
	    /**
	     * 判断是否需要有坐标变换
	     * 如果有坐标变换, 则从position, rotation, scale以及父节点的transform计算出自身的transform矩阵
	     */
	    transformableProto.needLocalTransform = function () {
	        return isNotAroundZero(this.rotation)
	            || isNotAroundZero(this.position[0])
	            || isNotAroundZero(this.position[1])
	            || isNotAroundZero(this.scale[0] - 1)
	            || isNotAroundZero(this.scale[1] - 1);
	    };
	
	    transformableProto.updateTransform = function () {
	        var parent = this.parent;
	        var parentHasTransform = parent && parent.transform;
	        var needLocalTransform = this.needLocalTransform();
	
	        var m = this.transform;
	        if (!(needLocalTransform || parentHasTransform)) {
	            m && mIdentity(m);
	            return;
	        }
	
	        m = m || matrix.create();
	
	        if (needLocalTransform) {
	            this.getLocalTransform(m);
	        }
	        else {
	            mIdentity(m);
	        }
	
	        // 应用父节点变换
	        if (parentHasTransform) {
	            if (needLocalTransform) {
	                matrix.mul(m, parent.transform, m);
	            }
	            else {
	                matrix.copy(m, parent.transform);
	            }
	        }
	        // 保存这个变换矩阵
	        this.transform = m;
	
	        this.invTransform = this.invTransform || matrix.create();
	        matrix.invert(this.invTransform, m);
	    };
	
	    transformableProto.getLocalTransform = function (m) {
	        m = m || [];
	        mIdentity(m);
	
	        var origin = this.origin;
	
	        var scale = this.scale;
	        var rotation = this.rotation;
	        var position = this.position;
	        if (origin) {
	            // Translate to origin
	            m[4] -= origin[0];
	            m[5] -= origin[1];
	        }
	        matrix.scale(m, m, scale);
	        if (rotation) {
	            matrix.rotate(m, m, rotation);
	        }
	        if (origin) {
	            // Translate back from origin
	            m[4] += origin[0];
	            m[5] += origin[1];
	        }
	
	        m[4] += position[0];
	        m[5] += position[1];
	
	        return m;
	    };
	    /**
	     * 将自己的transform应用到context上
	     * @param {Context2D} ctx
	     */
	    transformableProto.setTransform = function (ctx) {
	        var m = this.transform;
	        var dpr = ctx.dpr || 1;
	        if (m) {
	            ctx.setTransform(dpr * m[0], dpr * m[1], dpr * m[2], dpr * m[3], dpr * m[4], dpr * m[5]);
	        }
	        else {
	            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
	        }
	    };
	
	    transformableProto.restoreTransform = function (ctx) {
	        var m = this.transform;
	        var dpr = ctx.dpr || 1;
	        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
	    }
	
	    var tmpTransform = [];
	
	    /**
	     * 分解`transform`矩阵到`position`, `rotation`, `scale`
	     */
	    transformableProto.decomposeTransform = function () {
	        if (!this.transform) {
	            return;
	        }
	        var parent = this.parent;
	        var m = this.transform;
	        if (parent && parent.transform) {
	            // Get local transform and decompose them to position, scale, rotation
	            matrix.mul(tmpTransform, parent.invTransform, m);
	            m = tmpTransform;
	        }
	        var sx = m[0] * m[0] + m[1] * m[1];
	        var sy = m[2] * m[2] + m[3] * m[3];
	        var position = this.position;
	        var scale = this.scale;
	        if (isNotAroundZero(sx - 1)) {
	            sx = Math.sqrt(sx);
	        }
	        if (isNotAroundZero(sy - 1)) {
	            sy = Math.sqrt(sy);
	        }
	        if (m[0] < 0) {
	            sx = -sx;
	        }
	        if (m[3] < 0) {
	            sy = -sy;
	        }
	        position[0] = m[4];
	        position[1] = m[5];
	        scale[0] = sx;
	        scale[1] = sy;
	        this.rotation = Math.atan2(-m[1] / sy, m[0] / sx);
	    };
	
	    /**
	     * Get global scale
	     * @return {Array.<number>}
	     */
	    transformableProto.getGlobalScale = function () {
	        var m = this.transform;
	        if (!m) {
	            return [1, 1];
	        }
	        var sx = Math.sqrt(m[0] * m[0] + m[1] * m[1]);
	        var sy = Math.sqrt(m[2] * m[2] + m[3] * m[3]);
	        if (m[0] < 0) {
	            sx = -sx;
	        }
	        if (m[3] < 0) {
	            sy = -sy;
	        }
	        return [sx, sy];
	    };
	    /**
	     * 变换坐标位置到 shape 的局部坐标空间
	     * @method
	     * @param {number} x
	     * @param {number} y
	     * @return {Array.<number>}
	     */
	    transformableProto.transformCoordToLocal = function (x, y) {
	        var v2 = [x, y];
	        var invTransform = this.invTransform;
	        if (invTransform) {
	            vector.applyTransform(v2, v2, invTransform);
	        }
	        return v2;
	    };
	
	    /**
	     * 变换局部坐标位置到全局坐标空间
	     * @method
	     * @param {number} x
	     * @param {number} y
	     * @return {Array.<number>}
	     */
	    transformableProto.transformCoordToGlobal = function (x, y) {
	        var v2 = [x, y];
	        var transform = this.transform;
	        if (transform) {
	            vector.applyTransform(v2, v2, transform);
	        }
	        return v2;
	    };
	
	    module.exports = Transformable;
	


/***/ },
/* 13 */
/***/ function(module, exports) {

	
	    var ArrayCtor = typeof Float32Array === 'undefined'
	        ? Array
	        : Float32Array;
	    /**
	     * 3x2矩阵操作类
	     * @exports zrender/tool/matrix
	     */
	    var matrix = {
	        /**
	         * 创建一个单位矩阵
	         * @return {Float32Array|Array.<number>}
	         */
	        create : function() {
	            var out = new ArrayCtor(6);
	            matrix.identity(out);
	
	            return out;
	        },
	        /**
	         * 设置矩阵为单位矩阵
	         * @param {Float32Array|Array.<number>} out
	         */
	        identity : function(out) {
	            out[0] = 1;
	            out[1] = 0;
	            out[2] = 0;
	            out[3] = 1;
	            out[4] = 0;
	            out[5] = 0;
	            return out;
	        },
	        /**
	         * 复制矩阵
	         * @param {Float32Array|Array.<number>} out
	         * @param {Float32Array|Array.<number>} m
	         */
	        copy: function(out, m) {
	            out[0] = m[0];
	            out[1] = m[1];
	            out[2] = m[2];
	            out[3] = m[3];
	            out[4] = m[4];
	            out[5] = m[5];
	            return out;
	        },
	        /**
	         * 矩阵相乘
	         * @param {Float32Array|Array.<number>} out
	         * @param {Float32Array|Array.<number>} m1
	         * @param {Float32Array|Array.<number>} m2
	         */
	        mul : function (out, m1, m2) {
	            // Consider matrix.mul(m, m2, m);
	            // where out is the same as m2.
	            // So use temp variable to escape error.
	            var out0 = m1[0] * m2[0] + m1[2] * m2[1];
	            var out1 = m1[1] * m2[0] + m1[3] * m2[1];
	            var out2 = m1[0] * m2[2] + m1[2] * m2[3];
	            var out3 = m1[1] * m2[2] + m1[3] * m2[3];
	            var out4 = m1[0] * m2[4] + m1[2] * m2[5] + m1[4];
	            var out5 = m1[1] * m2[4] + m1[3] * m2[5] + m1[5];
	            out[0] = out0;
	            out[1] = out1;
	            out[2] = out2;
	            out[3] = out3;
	            out[4] = out4;
	            out[5] = out5;
	            return out;
	        },
	        /**
	         * 平移变换
	         * @param {Float32Array|Array.<number>} out
	         * @param {Float32Array|Array.<number>} a
	         * @param {Float32Array|Array.<number>} v
	         */
	        translate : function(out, a, v) {
	            out[0] = a[0];
	            out[1] = a[1];
	            out[2] = a[2];
	            out[3] = a[3];
	            out[4] = a[4] + v[0];
	            out[5] = a[5] + v[1];
	            return out;
	        },
	        /**
	         * 旋转变换
	         * @param {Float32Array|Array.<number>} out
	         * @param {Float32Array|Array.<number>} a
	         * @param {number} rad
	         */
	        rotate : function(out, a, rad) {
	            var aa = a[0];
	            var ac = a[2];
	            var atx = a[4];
	            var ab = a[1];
	            var ad = a[3];
	            var aty = a[5];
	            var st = Math.sin(rad);
	            var ct = Math.cos(rad);
	
	            out[0] = aa * ct + ab * st;
	            out[1] = -aa * st + ab * ct;
	            out[2] = ac * ct + ad * st;
	            out[3] = -ac * st + ct * ad;
	            out[4] = ct * atx + st * aty;
	            out[5] = ct * aty - st * atx;
	            return out;
	        },
	        /**
	         * 缩放变换
	         * @param {Float32Array|Array.<number>} out
	         * @param {Float32Array|Array.<number>} a
	         * @param {Float32Array|Array.<number>} v
	         */
	        scale : function(out, a, v) {
	            var vx = v[0];
	            var vy = v[1];
	            out[0] = a[0] * vx;
	            out[1] = a[1] * vy;
	            out[2] = a[2] * vx;
	            out[3] = a[3] * vy;
	            out[4] = a[4] * vx;
	            out[5] = a[5] * vy;
	            return out;
	        },
	        /**
	         * 求逆矩阵
	         * @param {Float32Array|Array.<number>} out
	         * @param {Float32Array|Array.<number>} a
	         */
	        invert : function(out, a) {
	
	            var aa = a[0];
	            var ac = a[2];
	            var atx = a[4];
	            var ab = a[1];
	            var ad = a[3];
	            var aty = a[5];
	
	            var det = aa * ad - ab * ac;
	            if (!det) {
	                return null;
	            }
	            det = 1.0 / det;
	
	            out[0] = ad * det;
	            out[1] = -ab * det;
	            out[2] = -ac * det;
	            out[3] = aa * det;
	            out[4] = (ac * aty - ad * atx) * det;
	            out[5] = (ab * atx - aa * aty) * det;
	            return out;
	        }
	    };
	
	    module.exports = matrix;
	


/***/ },
/* 14 */
/***/ function(module, exports) {

	
	    var ArrayCtor = typeof Float32Array === 'undefined'
	        ? Array
	        : Float32Array;
	
	    /**
	     * @typedef {Float32Array|Array.<number>} Vector2
	     */
	    /**
	     * 二维向量类
	     * @exports zrender/tool/vector
	     */
	    var vector = {
	        /**
	         * 创建一个向量
	         * @param {number} [x=0]
	         * @param {number} [y=0]
	         * @return {Vector2}
	         */
	        create: function (x, y) {
	            var out = new ArrayCtor(2);
	            if (x == null) {
	                x = 0;
	            }
	            if (y == null) {
	                y = 0;
	            }
	            out[0] = x;
	            out[1] = y;
	            return out;
	        },
	
	        /**
	         * 复制向量数据
	         * @param {Vector2} out
	         * @param {Vector2} v
	         * @return {Vector2}
	         */
	        copy: function (out, v) {
	            out[0] = v[0];
	            out[1] = v[1];
	            return out;
	        },
	
	        /**
	         * 克隆一个向量
	         * @param {Vector2} v
	         * @return {Vector2}
	         */
	        clone: function (v) {
	            var out = new ArrayCtor(2);
	            out[0] = v[0];
	            out[1] = v[1];
	            return out;
	        },
	
	        /**
	         * 设置向量的两个项
	         * @param {Vector2} out
	         * @param {number} a
	         * @param {number} b
	         * @return {Vector2} 结果
	         */
	        set: function (out, a, b) {
	            out[0] = a;
	            out[1] = b;
	            return out;
	        },
	
	        /**
	         * 向量相加
	         * @param {Vector2} out
	         * @param {Vector2} v1
	         * @param {Vector2} v2
	         */
	        add: function (out, v1, v2) {
	            out[0] = v1[0] + v2[0];
	            out[1] = v1[1] + v2[1];
	            return out;
	        },
	
	        /**
	         * 向量缩放后相加
	         * @param {Vector2} out
	         * @param {Vector2} v1
	         * @param {Vector2} v2
	         * @param {number} a
	         */
	        scaleAndAdd: function (out, v1, v2, a) {
	            out[0] = v1[0] + v2[0] * a;
	            out[1] = v1[1] + v2[1] * a;
	            return out;
	        },
	
	        /**
	         * 向量相减
	         * @param {Vector2} out
	         * @param {Vector2} v1
	         * @param {Vector2} v2
	         */
	        sub: function (out, v1, v2) {
	            out[0] = v1[0] - v2[0];
	            out[1] = v1[1] - v2[1];
	            return out;
	        },
	
	        /**
	         * 向量长度
	         * @param {Vector2} v
	         * @return {number}
	         */
	        len: function (v) {
	            return Math.sqrt(this.lenSquare(v));
	        },
	
	        /**
	         * 向量长度平方
	         * @param {Vector2} v
	         * @return {number}
	         */
	        lenSquare: function (v) {
	            return v[0] * v[0] + v[1] * v[1];
	        },
	
	        /**
	         * 向量乘法
	         * @param {Vector2} out
	         * @param {Vector2} v1
	         * @param {Vector2} v2
	         */
	        mul: function (out, v1, v2) {
	            out[0] = v1[0] * v2[0];
	            out[1] = v1[1] * v2[1];
	            return out;
	        },
	
	        /**
	         * 向量除法
	         * @param {Vector2} out
	         * @param {Vector2} v1
	         * @param {Vector2} v2
	         */
	        div: function (out, v1, v2) {
	            out[0] = v1[0] / v2[0];
	            out[1] = v1[1] / v2[1];
	            return out;
	        },
	
	        /**
	         * 向量点乘
	         * @param {Vector2} v1
	         * @param {Vector2} v2
	         * @return {number}
	         */
	        dot: function (v1, v2) {
	            return v1[0] * v2[0] + v1[1] * v2[1];
	        },
	
	        /**
	         * 向量缩放
	         * @param {Vector2} out
	         * @param {Vector2} v
	         * @param {number} s
	         */
	        scale: function (out, v, s) {
	            out[0] = v[0] * s;
	            out[1] = v[1] * s;
	            return out;
	        },
	
	        /**
	         * 向量归一化
	         * @param {Vector2} out
	         * @param {Vector2} v
	         */
	        normalize: function (out, v) {
	            var d = vector.len(v);
	            if (d === 0) {
	                out[0] = 0;
	                out[1] = 0;
	            }
	            else {
	                out[0] = v[0] / d;
	                out[1] = v[1] / d;
	            }
	            return out;
	        },
	
	        /**
	         * 计算向量间距离
	         * @param {Vector2} v1
	         * @param {Vector2} v2
	         * @return {number}
	         */
	        distance: function (v1, v2) {
	            return Math.sqrt(
	                (v1[0] - v2[0]) * (v1[0] - v2[0])
	                + (v1[1] - v2[1]) * (v1[1] - v2[1])
	            );
	        },
	
	        /**
	         * 向量距离平方
	         * @param {Vector2} v1
	         * @param {Vector2} v2
	         * @return {number}
	         */
	        distanceSquare: function (v1, v2) {
	            return (v1[0] - v2[0]) * (v1[0] - v2[0])
	                + (v1[1] - v2[1]) * (v1[1] - v2[1]);
	        },
	
	        /**
	         * 求负向量
	         * @param {Vector2} out
	         * @param {Vector2} v
	         */
	        negate: function (out, v) {
	            out[0] = -v[0];
	            out[1] = -v[1];
	            return out;
	        },
	
	        /**
	         * 插值两个点
	         * @param {Vector2} out
	         * @param {Vector2} v1
	         * @param {Vector2} v2
	         * @param {number} t
	         */
	        lerp: function (out, v1, v2, t) {
	            out[0] = v1[0] + t * (v2[0] - v1[0]);
	            out[1] = v1[1] + t * (v2[1] - v1[1]);
	            return out;
	        },
	
	        /**
	         * 矩阵左乘向量
	         * @param {Vector2} out
	         * @param {Vector2} v
	         * @param {Vector2} m
	         */
	        applyTransform: function (out, v, m) {
	            var x = v[0];
	            var y = v[1];
	            out[0] = m[0] * x + m[2] * y + m[4];
	            out[1] = m[1] * x + m[3] * y + m[5];
	            return out;
	        },
	        /**
	         * 求两个向量最小值
	         * @param  {Vector2} out
	         * @param  {Vector2} v1
	         * @param  {Vector2} v2
	         */
	        min: function (out, v1, v2) {
	            out[0] = Math.min(v1[0], v2[0]);
	            out[1] = Math.min(v1[1], v2[1]);
	            return out;
	        },
	        /**
	         * 求两个向量最大值
	         * @param  {Vector2} out
	         * @param  {Vector2} v1
	         * @param  {Vector2} v2
	         */
	        max: function (out, v1, v2) {
	            out[0] = Math.max(v1[0], v2[0]);
	            out[1] = Math.max(v1[1], v2[1]);
	            return out;
	        }
	    };
	
	    vector.length = vector.len;
	    vector.lengthSquare = vector.lenSquare;
	    vector.dist = vector.distance;
	    vector.distSquare = vector.distanceSquare;
	
	    module.exports = vector;
	


/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	/**
	 * @module zrender/mixin/Animatable
	 */
	
	
	    var Animator = __webpack_require__(16);
	    var util = __webpack_require__(4);
	    var isString = util.isString;
	    var isFunction = util.isFunction;
	    var isObject = util.isObject;
	    var log = __webpack_require__(20);
	
	    /**
	     * @alias modue:zrender/mixin/Animatable
	     * @constructor
	     */
	    var Animatable = function () {
	
	        /**
	         * @type {Array.<module:zrender/animation/Animator>}
	         * @readOnly
	         */
	        this.animators = [];
	    };
	
	    Animatable.prototype = {
	
	        constructor: Animatable,
	
	        /**
	         * 动画
	         *
	         * @param {string} path 需要添加动画的属性获取路径，可以通过a.b.c来获取深层的属性
	         * @param {boolean} [loop] 动画是否循环
	         * @return {module:zrender/animation/Animator}
	         * @example:
	         *     el.animate('style', false)
	         *         .when(1000, {x: 10} )
	         *         .done(function(){ // Animation done })
	         *         .start()
	         */
	        animate: function (path, loop) {
	            var target;
	            var animatingShape = false;
	            var el = this;
	            var zr = this.__zr;
	            if (path) {
	                var pathSplitted = path.split('.');
	                var prop = el;
	                // If animating shape
	                animatingShape = pathSplitted[0] === 'shape';
	                for (var i = 0, l = pathSplitted.length; i < l; i++) {
	                    if (!prop) {
	                        continue;
	                    }
	                    prop = prop[pathSplitted[i]];
	                }
	                if (prop) {
	                    target = prop;
	                }
	            }
	            else {
	                target = el;
	            }
	
	            if (!target) {
	                log(
	                    'Property "'
	                    + path
	                    + '" is not existed in element '
	                    + el.id
	                );
	                return;
	            }
	
	            var animators = el.animators;
	
	            var animator = new Animator(target, loop);
	
	            animator.during(function (target) {
	                el.dirty(animatingShape);
	            })
	            .done(function () {
	                // FIXME Animator will not be removed if use `Animator#stop` to stop animation
	                animators.splice(util.indexOf(animators, animator), 1);
	            });
	
	            animators.push(animator);
	
	            // If animate after added to the zrender
	            if (zr) {
	                zr.animation.addAnimator(animator);
	            }
	
	            return animator;
	        },
	
	        /**
	         * 停止动画
	         * @param {boolean} forwardToLast If move to last frame before stop
	         */
	        stopAnimation: function (forwardToLast) {
	            var animators = this.animators;
	            var len = animators.length;
	            for (var i = 0; i < len; i++) {
	                animators[i].stop(forwardToLast);
	            }
	            animators.length = 0;
	
	            return this;
	        },
	
	        /**
	         * @param {Object} target
	         * @param {number} [time=500] Time in ms
	         * @param {string} [easing='linear']
	         * @param {number} [delay=0]
	         * @param {Function} [callback]
	         *
	         * @example
	         *  // Animate position
	         *  el.animateTo({
	         *      position: [10, 10]
	         *  }, function () { // done })
	         *
	         *  // Animate shape, style and position in 100ms, delayed 100ms, with cubicOut easing
	         *  el.animateTo({
	         *      shape: {
	         *          width: 500
	         *      },
	         *      style: {
	         *          fill: 'red'
	         *      }
	         *      position: [10, 10]
	         *  }, 100, 100, 'cubicOut', function () { // done })
	         */
	         // TODO Return animation key
	        animateTo: function (target, time, delay, easing, callback) {
	            // animateTo(target, time, easing, callback);
	            if (isString(delay)) {
	                callback = easing;
	                easing = delay;
	                delay = 0;
	            }
	            // animateTo(target, time, delay, callback);
	            else if (isFunction(easing)) {
	                callback = easing;
	                easing = 'linear';
	                delay = 0;
	            }
	            // animateTo(target, time, callback);
	            else if (isFunction(delay)) {
	                callback = delay;
	                delay = 0;
	            }
	            // animateTo(target, callback)
	            else if (isFunction(time)) {
	                callback = time;
	                time = 500;
	            }
	            // animateTo(target)
	            else if (!time) {
	                time = 500;
	            }
	            // Stop all previous animations
	            this.stopAnimation();
	            this._animateToShallow('', this, target, time, delay, easing, callback);
	
	            // Animators may be removed immediately after start
	            // if there is nothing to animate
	            var animators = this.animators.slice();
	            var count = animators.length;
	            function done() {
	                count--;
	                if (!count) {
	                    callback && callback();
	                }
	            }
	
	            // No animators. This should be checked before animators[i].start(),
	            // because 'done' may be executed immediately if no need to animate.
	            if (!count) {
	                callback && callback();
	            }
	            // Start after all animators created
	            // Incase any animator is done immediately when all animation properties are not changed
	            for (var i = 0; i < animators.length; i++) {
	                animators[i]
	                    .done(done)
	                    .start(easing);
	            }
	        },
	
	        /**
	         * @private
	         * @param {string} path=''
	         * @param {Object} source=this
	         * @param {Object} target
	         * @param {number} [time=500]
	         * @param {number} [delay=0]
	         *
	         * @example
	         *  // Animate position
	         *  el._animateToShallow({
	         *      position: [10, 10]
	         *  })
	         *
	         *  // Animate shape, style and position in 100ms, delayed 100ms
	         *  el._animateToShallow({
	         *      shape: {
	         *          width: 500
	         *      },
	         *      style: {
	         *          fill: 'red'
	         *      }
	         *      position: [10, 10]
	         *  }, 100, 100)
	         */
	        _animateToShallow: function (path, source, target, time, delay) {
	            var objShallow = {};
	            var propertyCount = 0;
	            for (var name in target) {
	                if (source[name] != null) {
	                    if (isObject(target[name]) && !util.isArrayLike(target[name])) {
	                        this._animateToShallow(
	                            path ? path + '.' + name : name,
	                            source[name],
	                            target[name],
	                            time,
	                            delay
	                        );
	                    }
	                    else {
	                        objShallow[name] = target[name];
	                        propertyCount++;
	                    }
	                }
	                else if (target[name] != null) {
	                    // Attr directly if not has property
	                    // FIXME, if some property not needed for element ?
	                    if (!path) {
	                        this.attr(name, target[name]);
	                    }
	                    else {  // Shape or style
	                        var props = {};
	                        props[path] = {};
	                        props[path][name] = target[name];
	                        this.attr(props);
	                    }
	                }
	            }
	
	            if (propertyCount > 0) {
	                this.animate(path, false)
	                    .when(time == null ? 500 : time, objShallow)
	                    .delay(delay || 0);
	            }
	
	            return this;
	        }
	    };
	
	    module.exports = Animatable;


/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @module echarts/animation/Animator
	 */
	
	
	    var Clip = __webpack_require__(17);
	    var color = __webpack_require__(19);
	    var util = __webpack_require__(4);
	    var isArrayLike = util.isArrayLike;
	
	    var arraySlice = Array.prototype.slice;
	
	    function defaultGetter(target, key) {
	        return target[key];
	    }
	
	    function defaultSetter(target, key, value) {
	        target[key] = value;
	    }
	
	    /**
	     * @param  {number} p0
	     * @param  {number} p1
	     * @param  {number} percent
	     * @return {number}
	     */
	    function interpolateNumber(p0, p1, percent) {
	        return (p1 - p0) * percent + p0;
	    }
	
	    /**
	     * @param  {string} p0
	     * @param  {string} p1
	     * @param  {number} percent
	     * @return {string}
	     */
	    function interpolateString(p0, p1, percent) {
	        return percent > 0.5 ? p1 : p0;
	    }
	
	    /**
	     * @param  {Array} p0
	     * @param  {Array} p1
	     * @param  {number} percent
	     * @param  {Array} out
	     * @param  {number} arrDim
	     */
	    function interpolateArray(p0, p1, percent, out, arrDim) {
	        var len = p0.length;
	        if (arrDim == 1) {
	            for (var i = 0; i < len; i++) {
	                out[i] = interpolateNumber(p0[i], p1[i], percent);
	            }
	        }
	        else {
	            var len2 = p0[0].length;
	            for (var i = 0; i < len; i++) {
	                for (var j = 0; j < len2; j++) {
	                    out[i][j] = interpolateNumber(
	                        p0[i][j], p1[i][j], percent
	                    );
	                }
	            }
	        }
	    }
	
	    // arr0 is source array, arr1 is target array.
	    // Do some preprocess to avoid error happened when interpolating from arr0 to arr1
	    function fillArr(arr0, arr1, arrDim) {
	        var arr0Len = arr0.length;
	        var arr1Len = arr1.length;
	        if (arr0Len !== arr1Len) {
	            // FIXME Not work for TypedArray
	            var isPreviousLarger = arr0Len > arr1Len;
	            if (isPreviousLarger) {
	                // Cut the previous
	                arr0.length = arr1Len;
	            }
	            else {
	                // Fill the previous
	                for (var i = arr0Len; i < arr1Len; i++) {
	                    arr0.push(
	                        arrDim === 1 ? arr1[i] : arraySlice.call(arr1[i])
	                    );
	                }
	            }
	        }
	        // Handling NaN value
	        var len2 = arr0[0] && arr0[0].length;
	        for (var i = 0; i < arr0.length; i++) {
	            if (arrDim === 1) {
	                if (isNaN(arr0[i])) {
	                    arr0[i] = arr1[i];
	                }
	            }
	            else {
	                for (var j = 0; j < len2; j++) {
	                    if (isNaN(arr0[i][j])) {
	                        arr0[i][j] = arr1[i][j];
	                    }
	                }
	            }
	        }
	    }
	
	    /**
	     * @param  {Array} arr0
	     * @param  {Array} arr1
	     * @param  {number} arrDim
	     * @return {boolean}
	     */
	    function isArraySame(arr0, arr1, arrDim) {
	        if (arr0 === arr1) {
	            return true;
	        }
	        var len = arr0.length;
	        if (len !== arr1.length) {
	            return false;
	        }
	        if (arrDim === 1) {
	            for (var i = 0; i < len; i++) {
	                if (arr0[i] !== arr1[i]) {
	                    return false;
	                }
	            }
	        }
	        else {
	            var len2 = arr0[0].length;
	            for (var i = 0; i < len; i++) {
	                for (var j = 0; j < len2; j++) {
	                    if (arr0[i][j] !== arr1[i][j]) {
	                        return false;
	                    }
	                }
	            }
	        }
	        return true;
	    }
	
	    /**
	     * Catmull Rom interpolate array
	     * @param  {Array} p0
	     * @param  {Array} p1
	     * @param  {Array} p2
	     * @param  {Array} p3
	     * @param  {number} t
	     * @param  {number} t2
	     * @param  {number} t3
	     * @param  {Array} out
	     * @param  {number} arrDim
	     */
	    function catmullRomInterpolateArray(
	        p0, p1, p2, p3, t, t2, t3, out, arrDim
	    ) {
	        var len = p0.length;
	        if (arrDim == 1) {
	            for (var i = 0; i < len; i++) {
	                out[i] = catmullRomInterpolate(
	                    p0[i], p1[i], p2[i], p3[i], t, t2, t3
	                );
	            }
	        }
	        else {
	            var len2 = p0[0].length;
	            for (var i = 0; i < len; i++) {
	                for (var j = 0; j < len2; j++) {
	                    out[i][j] = catmullRomInterpolate(
	                        p0[i][j], p1[i][j], p2[i][j], p3[i][j],
	                        t, t2, t3
	                    );
	                }
	            }
	        }
	    }
	
	    /**
	     * Catmull Rom interpolate number
	     * @param  {number} p0
	     * @param  {number} p1
	     * @param  {number} p2
	     * @param  {number} p3
	     * @param  {number} t
	     * @param  {number} t2
	     * @param  {number} t3
	     * @return {number}
	     */
	    function catmullRomInterpolate(p0, p1, p2, p3, t, t2, t3) {
	        var v0 = (p2 - p0) * 0.5;
	        var v1 = (p3 - p1) * 0.5;
	        return (2 * (p1 - p2) + v0 + v1) * t3
	                + (-3 * (p1 - p2) - 2 * v0 - v1) * t2
	                + v0 * t + p1;
	    }
	
	    function cloneValue(value) {
	        if (isArrayLike(value)) {
	            var len = value.length;
	            if (isArrayLike(value[0])) {
	                var ret = [];
	                for (var i = 0; i < len; i++) {
	                    ret.push(arraySlice.call(value[i]));
	                }
	                return ret;
	            }
	
	            return arraySlice.call(value);
	        }
	
	        return value;
	    }
	
	    function rgba2String(rgba) {
	        rgba[0] = Math.floor(rgba[0]);
	        rgba[1] = Math.floor(rgba[1]);
	        rgba[2] = Math.floor(rgba[2]);
	
	        return 'rgba(' + rgba.join(',') + ')';
	    }
	
	    function createTrackClip (animator, easing, oneTrackDone, keyframes, propName) {
	        var getter = animator._getter;
	        var setter = animator._setter;
	        var useSpline = easing === 'spline';
	
	        var trackLen = keyframes.length;
	        if (!trackLen) {
	            return;
	        }
	        // Guess data type
	        var firstVal = keyframes[0].value;
	        var isValueArray = isArrayLike(firstVal);
	        var isValueColor = false;
	        var isValueString = false;
	
	        // For vertices morphing
	        var arrDim = (
	                isValueArray
	                && isArrayLike(firstVal[0])
	            )
	            ? 2 : 1;
	        var trackMaxTime;
	        // Sort keyframe as ascending
	        keyframes.sort(function(a, b) {
	            return a.time - b.time;
	        });
	
	        trackMaxTime = keyframes[trackLen - 1].time;
	        // Percents of each keyframe
	        var kfPercents = [];
	        // Value of each keyframe
	        var kfValues = [];
	        var prevValue = keyframes[0].value;
	        var isAllValueEqual = true;
	        for (var i = 0; i < trackLen; i++) {
	            kfPercents.push(keyframes[i].time / trackMaxTime);
	            // Assume value is a color when it is a string
	            var value = keyframes[i].value;
	
	            // Check if value is equal, deep check if value is array
	            if (!((isValueArray && isArraySame(value, prevValue, arrDim))
	                || (!isValueArray && value === prevValue))) {
	                isAllValueEqual = false;
	            }
	            prevValue = value;
	
	            // Try converting a string to a color array
	            if (typeof value == 'string') {
	                var colorArray = color.parse(value);
	                if (colorArray) {
	                    value = colorArray;
	                    isValueColor = true;
	                }
	                else {
	                    isValueString = true;
	                }
	            }
	            kfValues.push(value);
	        }
	        if (isAllValueEqual) {
	            return;
	        }
	
	        var lastValue = kfValues[trackLen - 1];
	        // Polyfill array and NaN value
	        for (var i = 0; i < trackLen - 1; i++) {
	            if (isValueArray) {
	                fillArr(kfValues[i], lastValue, arrDim);
	            }
	            else {
	                if (isNaN(kfValues[i]) && !isNaN(lastValue) && !isValueString && !isValueColor) {
	                    kfValues[i] = lastValue;
	                }
	            }
	        }
	        isValueArray && fillArr(getter(animator._target, propName), lastValue, arrDim);
	
	        // Cache the key of last frame to speed up when
	        // animation playback is sequency
	        var lastFrame = 0;
	        var lastFramePercent = 0;
	        var start;
	        var w;
	        var p0;
	        var p1;
	        var p2;
	        var p3;
	
	        if (isValueColor) {
	            var rgba = [0, 0, 0, 0];
	        }
	
	        var onframe = function (target, percent) {
	            // Find the range keyframes
	            // kf1-----kf2---------current--------kf3
	            // find kf2 and kf3 and do interpolation
	            var frame;
	            // In the easing function like elasticOut, percent may less than 0
	            if (percent < 0) {
	                frame = 0;
	            }
	            else if (percent < lastFramePercent) {
	                // Start from next key
	                // PENDING start from lastFrame ?
	                start = Math.min(lastFrame + 1, trackLen - 1);
	                for (frame = start; frame >= 0; frame--) {
	                    if (kfPercents[frame] <= percent) {
	                        break;
	                    }
	                }
	                // PENDING really need to do this ?
	                frame = Math.min(frame, trackLen - 2);
	            }
	            else {
	                for (frame = lastFrame; frame < trackLen; frame++) {
	                    if (kfPercents[frame] > percent) {
	                        break;
	                    }
	                }
	                frame = Math.min(frame - 1, trackLen - 2);
	            }
	            lastFrame = frame;
	            lastFramePercent = percent;
	
	            var range = (kfPercents[frame + 1] - kfPercents[frame]);
	            if (range === 0) {
	                return;
	            }
	            else {
	                w = (percent - kfPercents[frame]) / range;
	            }
	            if (useSpline) {
	                p1 = kfValues[frame];
	                p0 = kfValues[frame === 0 ? frame : frame - 1];
	                p2 = kfValues[frame > trackLen - 2 ? trackLen - 1 : frame + 1];
	                p3 = kfValues[frame > trackLen - 3 ? trackLen - 1 : frame + 2];
	                if (isValueArray) {
	                    catmullRomInterpolateArray(
	                        p0, p1, p2, p3, w, w * w, w * w * w,
	                        getter(target, propName),
	                        arrDim
	                    );
	                }
	                else {
	                    var value;
	                    if (isValueColor) {
	                        value = catmullRomInterpolateArray(
	                            p0, p1, p2, p3, w, w * w, w * w * w,
	                            rgba, 1
	                        );
	                        value = rgba2String(rgba);
	                    }
	                    else if (isValueString) {
	                        // String is step(0.5)
	                        return interpolateString(p1, p2, w);
	                    }
	                    else {
	                        value = catmullRomInterpolate(
	                            p0, p1, p2, p3, w, w * w, w * w * w
	                        );
	                    }
	                    setter(
	                        target,
	                        propName,
	                        value
	                    );
	                }
	            }
	            else {
	                if (isValueArray) {
	                    interpolateArray(
	                        kfValues[frame], kfValues[frame + 1], w,
	                        getter(target, propName),
	                        arrDim
	                    );
	                }
	                else {
	                    var value;
	                    if (isValueColor) {
	                        interpolateArray(
	                            kfValues[frame], kfValues[frame + 1], w,
	                            rgba, 1
	                        );
	                        value = rgba2String(rgba);
	                    }
	                    else if (isValueString) {
	                        // String is step(0.5)
	                        return interpolateString(kfValues[frame], kfValues[frame + 1], w);
	                    }
	                    else {
	                        value = interpolateNumber(kfValues[frame], kfValues[frame + 1], w);
	                    }
	                    setter(
	                        target,
	                        propName,
	                        value
	                    );
	                }
	            }
	        };
	
	        var clip = new Clip({
	            target: animator._target,
	            life: trackMaxTime,
	            loop: animator._loop,
	            delay: animator._delay,
	            onframe: onframe,
	            ondestroy: oneTrackDone
	        });
	
	        if (easing && easing !== 'spline') {
	            clip.easing = easing;
	        }
	
	        return clip;
	    }
	
	    /**
	     * @alias module:zrender/animation/Animator
	     * @constructor
	     * @param {Object} target
	     * @param {boolean} loop
	     * @param {Function} getter
	     * @param {Function} setter
	     */
	    var Animator = function(target, loop, getter, setter) {
	        this._tracks = {};
	        this._target = target;
	
	        this._loop = loop || false;
	
	        this._getter = getter || defaultGetter;
	        this._setter = setter || defaultSetter;
	
	        this._clipCount = 0;
	
	        this._delay = 0;
	
	        this._doneList = [];
	
	        this._onframeList = [];
	
	        this._clipList = [];
	    };
	
	    Animator.prototype = {
	        /**
	         * 设置动画关键帧
	         * @param  {number} time 关键帧时间，单位是ms
	         * @param  {Object} props 关键帧的属性值，key-value表示
	         * @return {module:zrender/animation/Animator}
	         */
	        when: function(time /* ms */, props) {
	            var tracks = this._tracks;
	            for (var propName in props) {
	                if (!tracks[propName]) {
	                    tracks[propName] = [];
	                    // Invalid value
	                    var value = this._getter(this._target, propName);
	                    if (value == null) {
	                        // zrLog('Invalid property ' + propName);
	                        continue;
	                    }
	                    // If time is 0
	                    //  Then props is given initialize value
	                    // Else
	                    //  Initialize value from current prop value
	                    if (time !== 0) {
	                        tracks[propName].push({
	                            time: 0,
	                            value: cloneValue(value)
	                        });
	                    }
	                }
	                tracks[propName].push({
	                    time: time,
	                    value: props[propName]
	                });
	            }
	            return this;
	        },
	        /**
	         * 添加动画每一帧的回调函数
	         * @param  {Function} callback
	         * @return {module:zrender/animation/Animator}
	         */
	        during: function (callback) {
	            this._onframeList.push(callback);
	            return this;
	        },
	
	        _doneCallback: function () {
	            // Clear all tracks
	            this._tracks = {};
	            // Clear all clips
	            this._clipList.length = 0;
	
	            var doneList = this._doneList;
	            var len = doneList.length;
	            for (var i = 0; i < len; i++) {
	                doneList[i].call(this);
	            }
	        },
	        /**
	         * 开始执行动画
	         * @param  {string|Function} easing
	         *         动画缓动函数，详见{@link module:zrender/animation/easing}
	         * @return {module:zrender/animation/Animator}
	         */
	        start: function (easing) {
	
	            var self = this;
	            var clipCount = 0;
	
	            var oneTrackDone = function() {
	                clipCount--;
	                if (!clipCount) {
	                    self._doneCallback();
	                }
	            };
	
	            var lastClip;
	            for (var propName in this._tracks) {
	                var clip = createTrackClip(
	                    this, easing, oneTrackDone,
	                    this._tracks[propName], propName
	                );
	                if (clip) {
	                    this._clipList.push(clip);
	                    clipCount++;
	
	                    // If start after added to animation
	                    if (this.animation) {
	                        this.animation.addClip(clip);
	                    }
	
	                    lastClip = clip;
	                }
	            }
	
	            // Add during callback on the last clip
	            if (lastClip) {
	                var oldOnFrame = lastClip.onframe;
	                lastClip.onframe = function (target, percent) {
	                    oldOnFrame(target, percent);
	
	                    for (var i = 0; i < self._onframeList.length; i++) {
	                        self._onframeList[i](target, percent);
	                    }
	                };
	            }
	
	            if (!clipCount) {
	                this._doneCallback();
	            }
	            return this;
	        },
	        /**
	         * 停止动画
	         * @param {boolean} forwardToLast If move to last frame before stop
	         */
	        stop: function (forwardToLast) {
	            var clipList = this._clipList;
	            var animation = this.animation;
	            for (var i = 0; i < clipList.length; i++) {
	                var clip = clipList[i];
	                if (forwardToLast) {
	                    // Move to last frame before stop
	                    clip.onframe(this._target, 1);
	                }
	                animation && animation.removeClip(clip);
	            }
	            clipList.length = 0;
	        },
	        /**
	         * 设置动画延迟开始的时间
	         * @param  {number} time 单位ms
	         * @return {module:zrender/animation/Animator}
	         */
	        delay: function (time) {
	            this._delay = time;
	            return this;
	        },
	        /**
	         * 添加动画结束的回调
	         * @param  {Function} cb
	         * @return {module:zrender/animation/Animator}
	         */
	        done: function(cb) {
	            if (cb) {
	                this._doneList.push(cb);
	            }
	            return this;
	        },
	
	        /**
	         * @return {Array.<module:zrender/animation/Clip>}
	         */
	        getClips: function () {
	            return this._clipList;
	        }
	    };
	
	    module.exports = Animator;


/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * 动画主控制器
	 * @config target 动画对象，可以是数组，如果是数组的话会批量分发onframe等事件
	 * @config life(1000) 动画时长
	 * @config delay(0) 动画延迟时间
	 * @config loop(true)
	 * @config gap(0) 循环的间隔时间
	 * @config onframe
	 * @config easing(optional)
	 * @config ondestroy(optional)
	 * @config onrestart(optional)
	 *
	 * TODO pause
	 */
	
	
	    var easingFuncs = __webpack_require__(18);
	
	    function Clip(options) {
	
	        this._target = options.target;
	
	        // 生命周期
	        this._life = options.life || 1000;
	        // 延时
	        this._delay = options.delay || 0;
	        // 开始时间
	        // this._startTime = new Date().getTime() + this._delay;// 单位毫秒
	        this._initialized = false;
	
	        // 是否循环
	        this.loop = options.loop == null ? false : options.loop;
	
	        this.gap = options.gap || 0;
	
	        this.easing = options.easing || 'Linear';
	
	        this.onframe = options.onframe;
	        this.ondestroy = options.ondestroy;
	        this.onrestart = options.onrestart;
	    }
	
	    Clip.prototype = {
	
	        constructor: Clip,
	
	        step: function (globalTime) {
	            // Set startTime on first step, or _startTime may has milleseconds different between clips
	            // PENDING
	            if (!this._initialized) {
	                this._startTime = globalTime + this._delay;
	                this._initialized = true;
	            }
	
	            var percent = (globalTime - this._startTime) / this._life;
	
	            // 还没开始
	            if (percent < 0) {
	                return;
	            }
	
	            percent = Math.min(percent, 1);
	
	            var easing = this.easing;
	            var easingFunc = typeof easing == 'string' ? easingFuncs[easing] : easing;
	            var schedule = typeof easingFunc === 'function'
	                ? easingFunc(percent)
	                : percent;
	
	            this.fire('frame', schedule);
	
	            // 结束
	            if (percent == 1) {
	                if (this.loop) {
	                    this.restart (globalTime);
	                    // 重新开始周期
	                    // 抛出而不是直接调用事件直到 stage.update 后再统一调用这些事件
	                    return 'restart';
	                }
	
	                // 动画完成将这个控制器标识为待删除
	                // 在Animation.update中进行批量删除
	                this._needsRemove = true;
	                return 'destroy';
	            }
	
	            return null;
	        },
	
	        restart: function (globalTime) {
	            var remainder = (globalTime - this._startTime) % this._life;
	            this._startTime = globalTime - remainder + this.gap;
	
	            this._needsRemove = false;
	        },
	
	        fire: function(eventType, arg) {
	            eventType = 'on' + eventType;
	            if (this[eventType]) {
	                this[eventType](this._target, arg);
	            }
	        }
	    };
	
	    module.exports = Clip;
	


/***/ },
/* 18 */
/***/ function(module, exports) {

	/**
	 * 缓动代码来自 https://github.com/sole/tween.js/blob/master/src/Tween.js
	 * @see http://sole.github.io/tween.js/examples/03_graphs.html
	 * @exports zrender/animation/easing
	 */
	
	    var easing = {
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        linear: function (k) {
	            return k;
	        },
	
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        quadraticIn: function (k) {
	            return k * k;
	        },
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        quadraticOut: function (k) {
	            return k * (2 - k);
	        },
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        quadraticInOut: function (k) {
	            if ((k *= 2) < 1) {
	                return 0.5 * k * k;
	            }
	            return -0.5 * (--k * (k - 2) - 1);
	        },
	
	        // 三次方的缓动（t^3）
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        cubicIn: function (k) {
	            return k * k * k;
	        },
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        cubicOut: function (k) {
	            return --k * k * k + 1;
	        },
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        cubicInOut: function (k) {
	            if ((k *= 2) < 1) {
	                return 0.5 * k * k * k;
	            }
	            return 0.5 * ((k -= 2) * k * k + 2);
	        },
	
	        // 四次方的缓动（t^4）
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        quarticIn: function (k) {
	            return k * k * k * k;
	        },
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        quarticOut: function (k) {
	            return 1 - (--k * k * k * k);
	        },
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        quarticInOut: function (k) {
	            if ((k *= 2) < 1) {
	                return 0.5 * k * k * k * k;
	            }
	            return -0.5 * ((k -= 2) * k * k * k - 2);
	        },
	
	        // 五次方的缓动（t^5）
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        quinticIn: function (k) {
	            return k * k * k * k * k;
	        },
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        quinticOut: function (k) {
	            return --k * k * k * k * k + 1;
	        },
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        quinticInOut: function (k) {
	            if ((k *= 2) < 1) {
	                return 0.5 * k * k * k * k * k;
	            }
	            return 0.5 * ((k -= 2) * k * k * k * k + 2);
	        },
	
	        // 正弦曲线的缓动（sin(t)）
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        sinusoidalIn: function (k) {
	            return 1 - Math.cos(k * Math.PI / 2);
	        },
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        sinusoidalOut: function (k) {
	            return Math.sin(k * Math.PI / 2);
	        },
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        sinusoidalInOut: function (k) {
	            return 0.5 * (1 - Math.cos(Math.PI * k));
	        },
	
	        // 指数曲线的缓动（2^t）
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        exponentialIn: function (k) {
	            return k === 0 ? 0 : Math.pow(1024, k - 1);
	        },
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        exponentialOut: function (k) {
	            return k === 1 ? 1 : 1 - Math.pow(2, -10 * k);
	        },
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        exponentialInOut: function (k) {
	            if (k === 0) {
	                return 0;
	            }
	            if (k === 1) {
	                return 1;
	            }
	            if ((k *= 2) < 1) {
	                return 0.5 * Math.pow(1024, k - 1);
	            }
	            return 0.5 * (-Math.pow(2, -10 * (k - 1)) + 2);
	        },
	
	        // 圆形曲线的缓动（sqrt(1-t^2)）
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        circularIn: function (k) {
	            return 1 - Math.sqrt(1 - k * k);
	        },
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        circularOut: function (k) {
	            return Math.sqrt(1 - (--k * k));
	        },
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        circularInOut: function (k) {
	            if ((k *= 2) < 1) {
	                return -0.5 * (Math.sqrt(1 - k * k) - 1);
	            }
	            return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);
	        },
	
	        // 创建类似于弹簧在停止前来回振荡的动画
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        elasticIn: function (k) {
	            var s;
	            var a = 0.1;
	            var p = 0.4;
	            if (k === 0) {
	                return 0;
	            }
	            if (k === 1) {
	                return 1;
	            }
	            if (!a || a < 1) {
	                a = 1; s = p / 4;
	            }
	            else {
	                s = p * Math.asin(1 / a) / (2 * Math.PI);
	            }
	            return -(a * Math.pow(2, 10 * (k -= 1)) *
	                        Math.sin((k - s) * (2 * Math.PI) / p));
	        },
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        elasticOut: function (k) {
	            var s;
	            var a = 0.1;
	            var p = 0.4;
	            if (k === 0) {
	                return 0;
	            }
	            if (k === 1) {
	                return 1;
	            }
	            if (!a || a < 1) {
	                a = 1; s = p / 4;
	            }
	            else {
	                s = p * Math.asin(1 / a) / (2 * Math.PI);
	            }
	            return (a * Math.pow(2, -10 * k) *
	                    Math.sin((k - s) * (2 * Math.PI) / p) + 1);
	        },
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        elasticInOut: function (k) {
	            var s;
	            var a = 0.1;
	            var p = 0.4;
	            if (k === 0) {
	                return 0;
	            }
	            if (k === 1) {
	                return 1;
	            }
	            if (!a || a < 1) {
	                a = 1; s = p / 4;
	            }
	            else {
	                s = p * Math.asin(1 / a) / (2 * Math.PI);
	            }
	            if ((k *= 2) < 1) {
	                return -0.5 * (a * Math.pow(2, 10 * (k -= 1))
	                    * Math.sin((k - s) * (2 * Math.PI) / p));
	            }
	            return a * Math.pow(2, -10 * (k -= 1))
	                    * Math.sin((k - s) * (2 * Math.PI) / p) * 0.5 + 1;
	
	        },
	
	        // 在某一动画开始沿指示的路径进行动画处理前稍稍收回该动画的移动
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        backIn: function (k) {
	            var s = 1.70158;
	            return k * k * ((s + 1) * k - s);
	        },
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        backOut: function (k) {
	            var s = 1.70158;
	            return --k * k * ((s + 1) * k + s) + 1;
	        },
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        backInOut: function (k) {
	            var s = 1.70158 * 1.525;
	            if ((k *= 2) < 1) {
	                return 0.5 * (k * k * ((s + 1) * k - s));
	            }
	            return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);
	        },
	
	        // 创建弹跳效果
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        bounceIn: function (k) {
	            return 1 - easing.bounceOut(1 - k);
	        },
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        bounceOut: function (k) {
	            if (k < (1 / 2.75)) {
	                return 7.5625 * k * k;
	            }
	            else if (k < (2 / 2.75)) {
	                return 7.5625 * (k -= (1.5 / 2.75)) * k + 0.75;
	            }
	            else if (k < (2.5 / 2.75)) {
	                return 7.5625 * (k -= (2.25 / 2.75)) * k + 0.9375;
	            }
	            else {
	                return 7.5625 * (k -= (2.625 / 2.75)) * k + 0.984375;
	            }
	        },
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        bounceInOut: function (k) {
	            if (k < 0.5) {
	                return easing.bounceIn(k * 2) * 0.5;
	            }
	            return easing.bounceOut(k * 2 - 1) * 0.5 + 0.5;
	        }
	    };
	
	    module.exports = easing;
	
	


/***/ },
/* 19 */
/***/ function(module, exports) {

	/**
	 * @module zrender/tool/color
	 */
	
	
	    var kCSSColorTable = {
	        'transparent': [0,0,0,0], 'aliceblue': [240,248,255,1],
	        'antiquewhite': [250,235,215,1], 'aqua': [0,255,255,1],
	        'aquamarine': [127,255,212,1], 'azure': [240,255,255,1],
	        'beige': [245,245,220,1], 'bisque': [255,228,196,1],
	        'black': [0,0,0,1], 'blanchedalmond': [255,235,205,1],
	        'blue': [0,0,255,1], 'blueviolet': [138,43,226,1],
	        'brown': [165,42,42,1], 'burlywood': [222,184,135,1],
	        'cadetblue': [95,158,160,1], 'chartreuse': [127,255,0,1],
	        'chocolate': [210,105,30,1], 'coral': [255,127,80,1],
	        'cornflowerblue': [100,149,237,1], 'cornsilk': [255,248,220,1],
	        'crimson': [220,20,60,1], 'cyan': [0,255,255,1],
	        'darkblue': [0,0,139,1], 'darkcyan': [0,139,139,1],
	        'darkgoldenrod': [184,134,11,1], 'darkgray': [169,169,169,1],
	        'darkgreen': [0,100,0,1], 'darkgrey': [169,169,169,1],
	        'darkkhaki': [189,183,107,1], 'darkmagenta': [139,0,139,1],
	        'darkolivegreen': [85,107,47,1], 'darkorange': [255,140,0,1],
	        'darkorchid': [153,50,204,1], 'darkred': [139,0,0,1],
	        'darksalmon': [233,150,122,1], 'darkseagreen': [143,188,143,1],
	        'darkslateblue': [72,61,139,1], 'darkslategray': [47,79,79,1],
	        'darkslategrey': [47,79,79,1], 'darkturquoise': [0,206,209,1],
	        'darkviolet': [148,0,211,1], 'deeppink': [255,20,147,1],
	        'deepskyblue': [0,191,255,1], 'dimgray': [105,105,105,1],
	        'dimgrey': [105,105,105,1], 'dodgerblue': [30,144,255,1],
	        'firebrick': [178,34,34,1], 'floralwhite': [255,250,240,1],
	        'forestgreen': [34,139,34,1], 'fuchsia': [255,0,255,1],
	        'gainsboro': [220,220,220,1], 'ghostwhite': [248,248,255,1],
	        'gold': [255,215,0,1], 'goldenrod': [218,165,32,1],
	        'gray': [128,128,128,1], 'green': [0,128,0,1],
	        'greenyellow': [173,255,47,1], 'grey': [128,128,128,1],
	        'honeydew': [240,255,240,1], 'hotpink': [255,105,180,1],
	        'indianred': [205,92,92,1], 'indigo': [75,0,130,1],
	        'ivory': [255,255,240,1], 'khaki': [240,230,140,1],
	        'lavender': [230,230,250,1], 'lavenderblush': [255,240,245,1],
	        'lawngreen': [124,252,0,1], 'lemonchiffon': [255,250,205,1],
	        'lightblue': [173,216,230,1], 'lightcoral': [240,128,128,1],
	        'lightcyan': [224,255,255,1], 'lightgoldenrodyellow': [250,250,210,1],
	        'lightgray': [211,211,211,1], 'lightgreen': [144,238,144,1],
	        'lightgrey': [211,211,211,1], 'lightpink': [255,182,193,1],
	        'lightsalmon': [255,160,122,1], 'lightseagreen': [32,178,170,1],
	        'lightskyblue': [135,206,250,1], 'lightslategray': [119,136,153,1],
	        'lightslategrey': [119,136,153,1], 'lightsteelblue': [176,196,222,1],
	        'lightyellow': [255,255,224,1], 'lime': [0,255,0,1],
	        'limegreen': [50,205,50,1], 'linen': [250,240,230,1],
	        'magenta': [255,0,255,1], 'maroon': [128,0,0,1],
	        'mediumaquamarine': [102,205,170,1], 'mediumblue': [0,0,205,1],
	        'mediumorchid': [186,85,211,1], 'mediumpurple': [147,112,219,1],
	        'mediumseagreen': [60,179,113,1], 'mediumslateblue': [123,104,238,1],
	        'mediumspringgreen': [0,250,154,1], 'mediumturquoise': [72,209,204,1],
	        'mediumvioletred': [199,21,133,1], 'midnightblue': [25,25,112,1],
	        'mintcream': [245,255,250,1], 'mistyrose': [255,228,225,1],
	        'moccasin': [255,228,181,1], 'navajowhite': [255,222,173,1],
	        'navy': [0,0,128,1], 'oldlace': [253,245,230,1],
	        'olive': [128,128,0,1], 'olivedrab': [107,142,35,1],
	        'orange': [255,165,0,1], 'orangered': [255,69,0,1],
	        'orchid': [218,112,214,1], 'palegoldenrod': [238,232,170,1],
	        'palegreen': [152,251,152,1], 'paleturquoise': [175,238,238,1],
	        'palevioletred': [219,112,147,1], 'papayawhip': [255,239,213,1],
	        'peachpuff': [255,218,185,1], 'peru': [205,133,63,1],
	        'pink': [255,192,203,1], 'plum': [221,160,221,1],
	        'powderblue': [176,224,230,1], 'purple': [128,0,128,1],
	        'red': [255,0,0,1], 'rosybrown': [188,143,143,1],
	        'royalblue': [65,105,225,1], 'saddlebrown': [139,69,19,1],
	        'salmon': [250,128,114,1], 'sandybrown': [244,164,96,1],
	        'seagreen': [46,139,87,1], 'seashell': [255,245,238,1],
	        'sienna': [160,82,45,1], 'silver': [192,192,192,1],
	        'skyblue': [135,206,235,1], 'slateblue': [106,90,205,1],
	        'slategray': [112,128,144,1], 'slategrey': [112,128,144,1],
	        'snow': [255,250,250,1], 'springgreen': [0,255,127,1],
	        'steelblue': [70,130,180,1], 'tan': [210,180,140,1],
	        'teal': [0,128,128,1], 'thistle': [216,191,216,1],
	        'tomato': [255,99,71,1], 'turquoise': [64,224,208,1],
	        'violet': [238,130,238,1], 'wheat': [245,222,179,1],
	        'white': [255,255,255,1], 'whitesmoke': [245,245,245,1],
	        'yellow': [255,255,0,1], 'yellowgreen': [154,205,50,1]
	    };
	
	    function clampCssByte(i) {  // Clamp to integer 0 .. 255.
	        i = Math.round(i);  // Seems to be what Chrome does (vs truncation).
	        return i < 0 ? 0 : i > 255 ? 255 : i;
	    }
	
	    function clampCssAngle(i) {  // Clamp to integer 0 .. 360.
	        i = Math.round(i);  // Seems to be what Chrome does (vs truncation).
	        return i < 0 ? 0 : i > 360 ? 360 : i;
	    }
	
	    function clampCssFloat(f) {  // Clamp to float 0.0 .. 1.0.
	        return f < 0 ? 0 : f > 1 ? 1 : f;
	    }
	
	    function parseCssInt(str) {  // int or percentage.
	        if (str.length && str.charAt(str.length - 1) === '%') {
	            return clampCssByte(parseFloat(str) / 100 * 255);
	        }
	        return clampCssByte(parseInt(str, 10));
	    }
	
	    function parseCssFloat(str) {  // float or percentage.
	        if (str.length && str.charAt(str.length - 1) === '%') {
	            return clampCssFloat(parseFloat(str) / 100);
	        }
	        return clampCssFloat(parseFloat(str));
	    }
	
	    function cssHueToRgb(m1, m2, h) {
	        if (h < 0) {
	            h += 1;
	        }
	        else if (h > 1) {
	            h -= 1;
	        }
	
	        if (h * 6 < 1) {
	            return m1 + (m2 - m1) * h * 6;
	        }
	        if (h * 2 < 1) {
	            return m2;
	        }
	        if (h * 3 < 2) {
	            return m1 + (m2 - m1) * (2/3 - h) * 6;
	        }
	        return m1;
	    }
	
	    function lerp(a, b, p) {
	        return a + (b - a) * p;
	    }
	
	    /**
	     * @param {string} colorStr
	     * @return {Array.<number>}
	     * @memberOf module:zrender/util/color
	     */
	    function parse(colorStr) {
	        if (!colorStr) {
	            return;
	        }
	        // colorStr may be not string
	        colorStr = colorStr + '';
	        // Remove all whitespace, not compliant, but should just be more accepting.
	        var str = colorStr.replace(/ /g, '').toLowerCase();
	
	        // Color keywords (and transparent) lookup.
	        if (str in kCSSColorTable) {
	            return kCSSColorTable[str].slice();  // dup.
	        }
	
	        // #abc and #abc123 syntax.
	        if (str.charAt(0) === '#') {
	            if (str.length === 4) {
	                var iv = parseInt(str.substr(1), 16);  // TODO(deanm): Stricter parsing.
	                if (!(iv >= 0 && iv <= 0xfff)) {
	                    return;  // Covers NaN.
	                }
	                return [
	                    ((iv & 0xf00) >> 4) | ((iv & 0xf00) >> 8),
	                    (iv & 0xf0) | ((iv & 0xf0) >> 4),
	                    (iv & 0xf) | ((iv & 0xf) << 4),
	                    1
	                ];
	            }
	            else if (str.length === 7) {
	                var iv = parseInt(str.substr(1), 16);  // TODO(deanm): Stricter parsing.
	                if (!(iv >= 0 && iv <= 0xffffff)) {
	                    return;  // Covers NaN.
	                }
	                return [
	                    (iv & 0xff0000) >> 16,
	                    (iv & 0xff00) >> 8,
	                    iv & 0xff,
	                    1
	                ];
	            }
	
	            return;
	        }
	        var op = str.indexOf('('), ep = str.indexOf(')');
	        if (op !== -1 && ep + 1 === str.length) {
	            var fname = str.substr(0, op);
	            var params = str.substr(op + 1, ep - (op + 1)).split(',');
	            var alpha = 1;  // To allow case fallthrough.
	            switch (fname) {
	                case 'rgba':
	                    if (params.length !== 4) {
	                        return;
	                    }
	                    alpha = parseCssFloat(params.pop()); // jshint ignore:line
	                // Fall through.
	                case 'rgb':
	                    if (params.length !== 3) {
	                        return;
	                    }
	                    return [
	                        parseCssInt(params[0]),
	                        parseCssInt(params[1]),
	                        parseCssInt(params[2]),
	                        alpha
	                    ];
	                case 'hsla':
	                    if (params.length !== 4) {
	                        return;
	                    }
	                    params[3] = parseCssFloat(params[3]);
	                    return hsla2rgba(params);
	                case 'hsl':
	                    if (params.length !== 3) {
	                        return;
	                    }
	                    return hsla2rgba(params);
	                default:
	                    return;
	            }
	        }
	
	        return;
	    }
	
	    /**
	     * @param {Array.<number>} hsla
	     * @return {Array.<number>} rgba
	     */
	    function hsla2rgba(hsla) {
	        var h = (((parseFloat(hsla[0]) % 360) + 360) % 360) / 360;  // 0 .. 1
	        // NOTE(deanm): According to the CSS spec s/l should only be
	        // percentages, but we don't bother and let float or percentage.
	        var s = parseCssFloat(hsla[1]);
	        var l = parseCssFloat(hsla[2]);
	        var m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;
	        var m1 = l * 2 - m2;
	
	        var rgba = [
	            clampCssByte(cssHueToRgb(m1, m2, h + 1 / 3) * 255),
	            clampCssByte(cssHueToRgb(m1, m2, h) * 255),
	            clampCssByte(cssHueToRgb(m1, m2, h - 1 / 3) * 255)
	        ];
	
	        if (hsla.length === 4) {
	            rgba[3] = hsla[3];
	        }
	
	        return rgba;
	    }
	
	    /**
	     * @param {Array.<number>} rgba
	     * @return {Array.<number>} hsla
	     */
	    function rgba2hsla(rgba) {
	        if (!rgba) {
	            return;
	        }
	
	        // RGB from 0 to 255
	        var R = rgba[0] / 255;
	        var G = rgba[1] / 255;
	        var B = rgba[2] / 255;
	
	        var vMin = Math.min(R, G, B); // Min. value of RGB
	        var vMax = Math.max(R, G, B); // Max. value of RGB
	        var delta = vMax - vMin; // Delta RGB value
	
	        var L = (vMax + vMin) / 2;
	        var H;
	        var S;
	        // HSL results from 0 to 1
	        if (delta === 0) {
	            H = 0;
	            S = 0;
	        }
	        else {
	            if (L < 0.5) {
	                S = delta / (vMax + vMin);
	            }
	            else {
	                S = delta / (2 - vMax - vMin);
	            }
	
	            var deltaR = (((vMax - R) / 6) + (delta / 2)) / delta;
	            var deltaG = (((vMax - G) / 6) + (delta / 2)) / delta;
	            var deltaB = (((vMax - B) / 6) + (delta / 2)) / delta;
	
	            if (R === vMax) {
	                H = deltaB - deltaG;
	            }
	            else if (G === vMax) {
	                H = (1 / 3) + deltaR - deltaB;
	            }
	            else if (B === vMax) {
	                H = (2 / 3) + deltaG - deltaR;
	            }
	
	            if (H < 0) {
	                H += 1;
	            }
	
	            if (H > 1) {
	                H -= 1;
	            }
	        }
	
	        var hsla = [H * 360, S, L];
	
	        if (rgba[3] != null) {
	            hsla.push(rgba[3]);
	        }
	
	        return hsla;
	    }
	
	    /**
	     * @param {string} color
	     * @param {number} level
	     * @return {string}
	     * @memberOf module:zrender/util/color
	     */
	    function lift(color, level) {
	        var colorArr = parse(color);
	        if (colorArr) {
	            for (var i = 0; i < 3; i++) {
	                if (level < 0) {
	                    colorArr[i] = colorArr[i] * (1 - level) | 0;
	                }
	                else {
	                    colorArr[i] = ((255 - colorArr[i]) * level + colorArr[i]) | 0;
	                }
	            }
	            return stringify(colorArr, colorArr.length === 4 ? 'rgba' : 'rgb');
	        }
	    }
	
	    /**
	     * @param {string} color
	     * @return {string}
	     * @memberOf module:zrender/util/color
	     */
	    function toHex(color, level) {
	        var colorArr = parse(color);
	        if (colorArr) {
	            return ((1 << 24) + (colorArr[0] << 16) + (colorArr[1] << 8) + (+colorArr[2])).toString(16).slice(1);
	        }
	    }
	
	    /**
	     * Map value to color. Faster than mapToColor methods because color is represented by rgba array
	     * @param {number} normalizedValue A float between 0 and 1.
	     * @param {Array.<Array.<number>>} colors List of rgba color array
	     * @param {Array.<number>} [out] Mapped gba color array
	     * @return {Array.<number>}
	     */
	    function fastMapToColor(normalizedValue, colors, out) {
	        if (!(colors && colors.length)
	            || !(normalizedValue >= 0 && normalizedValue <= 1)
	        ) {
	            return;
	        }
	        out = out || [0, 0, 0, 0];
	        var value = normalizedValue * (colors.length - 1);
	        var leftIndex = Math.floor(value);
	        var rightIndex = Math.ceil(value);
	        var leftColor = colors[leftIndex];
	        var rightColor = colors[rightIndex];
	        var dv = value - leftIndex;
	        out[0] = clampCssByte(lerp(leftColor[0], rightColor[0], dv));
	        out[1] = clampCssByte(lerp(leftColor[1], rightColor[1], dv));
	        out[2] = clampCssByte(lerp(leftColor[2], rightColor[2], dv));
	        out[3] = clampCssByte(lerp(leftColor[3], rightColor[3], dv));
	        return out;
	    }
	    /**
	     * @param {number} normalizedValue A float between 0 and 1.
	     * @param {Array.<string>} colors Color list.
	     * @param {boolean=} fullOutput Default false.
	     * @return {(string|Object)} Result color. If fullOutput,
	     *                           return {color: ..., leftIndex: ..., rightIndex: ..., value: ...},
	     * @memberOf module:zrender/util/color
	     */
	    function mapToColor(normalizedValue, colors, fullOutput) {
	        if (!(colors && colors.length)
	            || !(normalizedValue >= 0 && normalizedValue <= 1)
	        ) {
	            return;
	        }
	
	        var value = normalizedValue * (colors.length - 1);
	        var leftIndex = Math.floor(value);
	        var rightIndex = Math.ceil(value);
	        var leftColor = parse(colors[leftIndex]);
	        var rightColor = parse(colors[rightIndex]);
	        var dv = value - leftIndex;
	
	        var color = stringify(
	            [
	                clampCssByte(lerp(leftColor[0], rightColor[0], dv)),
	                clampCssByte(lerp(leftColor[1], rightColor[1], dv)),
	                clampCssByte(lerp(leftColor[2], rightColor[2], dv)),
	                clampCssFloat(lerp(leftColor[3], rightColor[3], dv))
	            ],
	            'rgba'
	        );
	
	        return fullOutput
	            ? {
	                color: color,
	                leftIndex: leftIndex,
	                rightIndex: rightIndex,
	                value: value
	            }
	            : color;
	    }
	
	    /**
	     * @param {string} color
	     * @param {number=} h 0 ~ 360, ignore when null.
	     * @param {number=} s 0 ~ 1, ignore when null.
	     * @param {number=} l 0 ~ 1, ignore when null.
	     * @return {string} Color string in rgba format.
	     * @memberOf module:zrender/util/color
	     */
	    function modifyHSL(color, h, s, l) {
	        color = parse(color);
	
	        if (color) {
	            color = rgba2hsla(color);
	            h != null && (color[0] = clampCssAngle(h));
	            s != null && (color[1] = parseCssFloat(s));
	            l != null && (color[2] = parseCssFloat(l));
	
	            return stringify(hsla2rgba(color), 'rgba');
	        }
	    }
	
	    /**
	     * @param {string} color
	     * @param {number=} alpha 0 ~ 1
	     * @return {string} Color string in rgba format.
	     * @memberOf module:zrender/util/color
	     */
	    function modifyAlpha(color, alpha) {
	        color = parse(color);
	
	        if (color && alpha != null) {
	            color[3] = clampCssFloat(alpha);
	            return stringify(color, 'rgba');
	        }
	    }
	
	    /**
	     * @param {Array.<string>} colors Color list.
	     * @param {string} type 'rgba', 'hsva', ...
	     * @return {string} Result color.
	     */
	    function stringify(arrColor, type) {
	        var colorStr = arrColor[0] + ',' + arrColor[1] + ',' + arrColor[2];
	        if (type === 'rgba' || type === 'hsva' || type === 'hsla') {
	            colorStr += ',' + arrColor[3];
	        }
	        return type + '(' + colorStr + ')';
	    }
	
	    module.exports = {
	        parse: parse,
	        lift: lift,
	        toHex: toHex,
	        fastMapToColor: fastMapToColor,
	        mapToColor: mapToColor,
	        modifyHSL: modifyHSL,
	        modifyAlpha: modifyAlpha,
	        stringify: stringify
	    };
	
	


/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	
	        var config = __webpack_require__(21);
	
	        /**
	         * @exports zrender/tool/log
	         * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)
	         */
	        module.exports = function() {
	            if (config.debugMode === 0) {
	                return;
	            }
	            else if (config.debugMode == 1) {
	                for (var k in arguments) {
	                    throw new Error(arguments[k]);
	                }
	            }
	            else if (config.debugMode > 1) {
	                for (var k in arguments) {
	                    console.log(arguments[k]);
	                }
	            }
	        };
	
	        /* for debug
	        return function(mes) {
	            document.getElementById('wrong-message').innerHTML =
	                mes + ' ' + (new Date() - 0)
	                + '<br/>' 
	                + document.getElementById('wrong-message').innerHTML;
	        };
	        */
	    


/***/ },
/* 21 */
/***/ function(module, exports) {

	
	    var dpr = 1;
	    // If in browser environment
	    if (typeof window !== 'undefined') {
	        dpr = Math.max(window.devicePixelRatio || 1, 1);
	    }
	    /**
	     * config默认配置项
	     * @exports zrender/config
	     * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)
	     */
	    var config = {
	        /**
	         * debug日志选项：catchBrushException为true下有效
	         * 0 : 不生成debug数据，发布用
	         * 1 : 异常抛出，调试用
	         * 2 : 控制台输出，调试用
	         */
	        debugMode: 0,
	
	        // retina 屏幕优化
	        devicePixelRatio: dpr
	    };
	    module.exports = config;
	
	


/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Mixin for drawing text in a element bounding rect
	 * @module zrender/mixin/RectText
	 */
	
	
	
	    var textContain = __webpack_require__(23);
	    var BoundingRect = __webpack_require__(24);
	
	    var tmpRect = new BoundingRect();
	
	    var RectText = function () {};
	
	    function parsePercent(value, maxValue) {
	        if (typeof value === 'string') {
	            if (value.lastIndexOf('%') >= 0) {
	                return parseFloat(value) / 100 * maxValue;
	            }
	            return parseFloat(value);
	        }
	        return value;
	    }
	
	    RectText.prototype = {
	
	        constructor: RectText,
	
	        /**
	         * Draw text in a rect with specified position.
	         * @param  {CanvasRenderingContext} ctx
	         * @param  {Object} rect Displayable rect
	         * @return {Object} textRect Alternative precalculated text bounding rect
	         */
	        drawRectText: function (ctx, rect, textRect) {
	            var style = this.style;
	            var text = style.text;
	            // Convert to string
	            text != null && (text += '');
	            if (!text) {
	                return;
	            }
	
	            // FIXME
	            ctx.save();
	
	            var x;
	            var y;
	            var textPosition = style.textPosition;
	            var distance = style.textDistance;
	            var align = style.textAlign;
	            var font = style.textFont || style.font;
	            var baseline = style.textBaseline;
	            var verticalAlign = style.textVerticalAlign;
	
	            textRect = textRect || textContain.getBoundingRect(text, font, align, baseline);
	
	            // Transform rect to view space
	            var transform = this.transform;
	            if (!style.textTransform) {
	                if (transform) {
	                    tmpRect.copy(rect);
	                    tmpRect.applyTransform(transform);
	                    rect = tmpRect;
	                }
	            }
	            else {
	                this.setTransform(ctx);
	            }
	
	            // Text position represented by coord
	            if (textPosition instanceof Array) {
	                // Percent
	                x = rect.x + parsePercent(textPosition[0], rect.width);
	                y = rect.y + parsePercent(textPosition[1], rect.height);
	                align = align || 'left';
	                baseline = baseline || 'top';
	
	                if (verticalAlign) {
	                    switch (verticalAlign) {
	                        case 'middle':
	                            y -= textRect.height / 2 - textRect.lineHeight / 2;
	                            break;
	                        case 'bottom':
	                            y -= textRect.height - textRect.lineHeight / 2;
	                            break;
	                        default:
	                            y += textRect.lineHeight / 2;
	                    }
	                    // Force bseline to be middle
	                    baseline = 'middle';
	                }
	            }
	            else {
	                var res = textContain.adjustTextPositionOnRect(
	                    textPosition, rect, textRect, distance
	                );
	                x = res.x;
	                y = res.y;
	                // Default align and baseline when has textPosition
	                align = align || res.textAlign;
	                baseline = baseline || res.textBaseline;
	            }
	
	            // Use canvas default left textAlign. Giving invalid value will cause state not change
	            ctx.textAlign = align || 'left';
	            // Use canvas default alphabetic baseline
	            ctx.textBaseline = baseline || 'alphabetic';
	
	            var textFill = style.textFill;
	            var textStroke = style.textStroke;
	            textFill && (ctx.fillStyle = textFill);
	            textStroke && (ctx.strokeStyle = textStroke);
	
	            // TODO Invalid font
	            ctx.font = font || '12px sans-serif';
	
	            // Text shadow
	            // Always set shadowBlur and shadowOffset to avoid leak from displayable
	            ctx.shadowBlur = style.textShadowBlur;
	            ctx.shadowColor = style.textShadowColor || 'transparent';
	            ctx.shadowOffsetX = style.textShadowOffsetX;
	            ctx.shadowOffsetY = style.textShadowOffsetY;
	
	            var textLines = text.split('\n');
	
	            if (style.textRotation) {
	                transform && ctx.translate(transform[4], transform[5]);
	                ctx.rotate(style.textRotation);
	                transform && ctx.translate(-transform[4], -transform[5]);
	            }
	
	            for (var i = 0; i < textLines.length; i++) {
	                textFill && ctx.fillText(textLines[i], x, y);
	                textStroke && ctx.strokeText(textLines[i], x, y);
	                y += textRect.lineHeight;
	            }
	
	            ctx.restore();
	        }
	    };
	
	    module.exports = RectText;


/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	
	
	    var textWidthCache = {};
	    var textWidthCacheCounter = 0;
	    var TEXT_CACHE_MAX = 5000;
	
	    var util = __webpack_require__(4);
	    var BoundingRect = __webpack_require__(24);
	    var retrieve = util.retrieve;
	
	    function getTextWidth(text, textFont) {
	        var key = text + ':' + textFont;
	        if (textWidthCache[key]) {
	            return textWidthCache[key];
	        }
	
	        var textLines = (text + '').split('\n');
	        var width = 0;
	
	        for (var i = 0, l = textLines.length; i < l; i++) {
	            // measureText 可以被覆盖以兼容不支持 Canvas 的环境
	            width = Math.max(textContain.measureText(textLines[i], textFont).width, width);
	        }
	
	        if (textWidthCacheCounter > TEXT_CACHE_MAX) {
	            textWidthCacheCounter = 0;
	            textWidthCache = {};
	        }
	        textWidthCacheCounter++;
	        textWidthCache[key] = width;
	
	        return width;
	    }
	
	    function getTextRect(text, textFont, textAlign, textBaseline) {
	        var textLineLen = ((text || '') + '').split('\n').length;
	
	        var width = getTextWidth(text, textFont);
	        // FIXME 高度计算比较粗暴
	        var lineHeight = getTextWidth('国', textFont);
	        var height = textLineLen * lineHeight;
	
	        var rect = new BoundingRect(0, 0, width, height);
	        // Text has a special line height property
	        rect.lineHeight = lineHeight;
	
	        switch (textBaseline) {
	            case 'bottom':
	            case 'alphabetic':
	                rect.y -= lineHeight;
	                break;
	            case 'middle':
	                rect.y -= lineHeight / 2;
	                break;
	            // case 'hanging':
	            // case 'top':
	        }
	
	        // FIXME Right to left language
	        switch (textAlign) {
	            case 'end':
	            case 'right':
	                rect.x -= rect.width;
	                break;
	            case 'center':
	                rect.x -= rect.width / 2;
	                break;
	            // case 'start':
	            // case 'left':
	        }
	
	        return rect;
	    }
	
	    function adjustTextPositionOnRect(textPosition, rect, textRect, distance) {
	
	        var x = rect.x;
	        var y = rect.y;
	
	        var height = rect.height;
	        var width = rect.width;
	
	        var textHeight = textRect.height;
	
	        var halfHeight = height / 2 - textHeight / 2;
	
	        var textAlign = 'left';
	
	        switch (textPosition) {
	            case 'left':
	                x -= distance;
	                y += halfHeight;
	                textAlign = 'right';
	                break;
	            case 'right':
	                x += distance + width;
	                y += halfHeight;
	                textAlign = 'left';
	                break;
	            case 'top':
	                x += width / 2;
	                y -= distance + textHeight;
	                textAlign = 'center';
	                break;
	            case 'bottom':
	                x += width / 2;
	                y += height + distance;
	                textAlign = 'center';
	                break;
	            case 'inside':
	                x += width / 2;
	                y += halfHeight;
	                textAlign = 'center';
	                break;
	            case 'insideLeft':
	                x += distance;
	                y += halfHeight;
	                textAlign = 'left';
	                break;
	            case 'insideRight':
	                x += width - distance;
	                y += halfHeight;
	                textAlign = 'right';
	                break;
	            case 'insideTop':
	                x += width / 2;
	                y += distance;
	                textAlign = 'center';
	                break;
	            case 'insideBottom':
	                x += width / 2;
	                y += height - textHeight - distance;
	                textAlign = 'center';
	                break;
	            case 'insideTopLeft':
	                x += distance;
	                y += distance;
	                textAlign = 'left';
	                break;
	            case 'insideTopRight':
	                x += width - distance;
	                y += distance;
	                textAlign = 'right';
	                break;
	            case 'insideBottomLeft':
	                x += distance;
	                y += height - textHeight - distance;
	                break;
	            case 'insideBottomRight':
	                x += width - distance;
	                y += height - textHeight - distance;
	                textAlign = 'right';
	                break;
	        }
	
	        return {
	            x: x,
	            y: y,
	            textAlign: textAlign,
	            textBaseline: 'top'
	        };
	    }
	
	    /**
	     * Show ellipsis if overflow.
	     *
	     * @param  {string} text
	     * @param  {string} containerWidth
	     * @param  {string} textFont
	     * @param  {number} [ellipsis='...']
	     * @param  {Object} [options]
	     * @param  {number} [options.maxIterations=3]
	     * @param  {number} [options.minChar=0] If truncate result are less
	     *                  then minChar, ellipsis will not show, which is
	     *                  better for user hint in some cases.
	     * @param  {number} [options.placeholder=''] When all truncated, use the placeholder.
	     * @return {string}
	     */
	    function truncateText(text, containerWidth, textFont, ellipsis, options) {
	        if (!containerWidth) {
	            return '';
	        }
	
	        options = options || {};
	
	        ellipsis = retrieve(ellipsis, '...');
	        var maxIterations = retrieve(options.maxIterations, 2);
	        var minChar = retrieve(options.minChar, 0);
	        // FIXME
	        // Other languages?
	        var cnCharWidth = getTextWidth('国', textFont);
	        // FIXME
	        // Consider proportional font?
	        var ascCharWidth = getTextWidth('a', textFont);
	        var placeholder = retrieve(options.placeholder, '');
	
	        // Example 1: minChar: 3, text: 'asdfzxcv', truncate result: 'asdf', but not: 'a...'.
	        // Example 2: minChar: 3, text: '维度', truncate result: '维', but not: '...'.
	        var contentWidth = containerWidth = Math.max(0, containerWidth - 1); // Reserve some gap.
	        for (var i = 0; i < minChar && contentWidth >= ascCharWidth; i++) {
	            contentWidth -= ascCharWidth;
	        }
	
	        var ellipsisWidth = getTextWidth(ellipsis);
	        if (ellipsisWidth > contentWidth) {
	            ellipsis = '';
	            ellipsisWidth = 0;
	        }
	
	        contentWidth = containerWidth - ellipsisWidth;
	
	        var textLines = (text + '').split('\n');
	
	        for (var i = 0, len = textLines.length; i < len; i++) {
	            var textLine = textLines[i];
	            var lineWidth = getTextWidth(textLine, textFont);
	
	            if (lineWidth <= containerWidth) {
	                continue;
	            }
	
	            for (var j = 0;; j++) {
	                if (lineWidth <= contentWidth || j >= maxIterations) {
	                    textLine += ellipsis;
	                    break;
	                }
	
	                var subLength = j === 0
	                    ? estimateLength(textLine, contentWidth, ascCharWidth, cnCharWidth)
	                    : lineWidth > 0
	                    ? Math.floor(textLine.length * contentWidth / lineWidth)
	                    : 0;
	
	                textLine = textLine.substr(0, subLength);
	                lineWidth = getTextWidth(textLine, textFont);
	            }
	
	            if (textLine === '') {
	                textLine = placeholder;
	            }
	
	            textLines[i] = textLine;
	        }
	
	        return textLines.join('\n');
	    }
	
	    function estimateLength(text, contentWidth, ascCharWidth, cnCharWidth) {
	        var width = 0;
	        var i = 0;
	        for (var len = text.length; i < len && width < contentWidth; i++) {
	            var charCode = text.charCodeAt(i);
	            width += (0 <= charCode && charCode <= 127) ? ascCharWidth : cnCharWidth;
	        }
	        return i;
	    }
	
	    var textContain = {
	
	        getWidth: getTextWidth,
	
	        getBoundingRect: getTextRect,
	
	        adjustTextPositionOnRect: adjustTextPositionOnRect,
	
	        truncateText: truncateText,
	
	        measureText: function (text, textFont) {
	            var ctx = util.getContext();
	            ctx.font = textFont || '12px sans-serif';
	            return ctx.measureText(text);
	        }
	    };
	
	    module.exports = textContain;


/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	/**
	 * @module echarts/core/BoundingRect
	 */
	
	
	    var vec2 = __webpack_require__(14);
	    var matrix = __webpack_require__(13);
	
	    var v2ApplyTransform = vec2.applyTransform;
	    var mathMin = Math.min;
	    var mathAbs = Math.abs;
	    var mathMax = Math.max;
	    /**
	     * @alias module:echarts/core/BoundingRect
	     */
	    function BoundingRect(x, y, width, height) {
	        /**
	         * @type {number}
	         */
	        this.x = x;
	        /**
	         * @type {number}
	         */
	        this.y = y;
	        /**
	         * @type {number}
	         */
	        this.width = width;
	        /**
	         * @type {number}
	         */
	        this.height = height;
	    }
	
	    BoundingRect.prototype = {
	
	        constructor: BoundingRect,
	
	        /**
	         * @param {module:echarts/core/BoundingRect} other
	         */
	        union: function (other) {
	            var x = mathMin(other.x, this.x);
	            var y = mathMin(other.y, this.y);
	
	            this.width = mathMax(
	                    other.x + other.width,
	                    this.x + this.width
	                ) - x;
	            this.height = mathMax(
	                    other.y + other.height,
	                    this.y + this.height
	                ) - y;
	            this.x = x;
	            this.y = y;
	        },
	
	        /**
	         * @param {Array.<number>} m
	         * @methods
	         */
	        applyTransform: (function () {
	            var min = [];
	            var max = [];
	            return function (m) {
	                // In case usage like this
	                // el.getBoundingRect().applyTransform(el.transform)
	                // And element has no transform
	                if (!m) {
	                    return;
	                }
	                min[0] = this.x;
	                min[1] = this.y;
	                max[0] = this.x + this.width;
	                max[1] = this.y + this.height;
	
	                v2ApplyTransform(min, min, m);
	                v2ApplyTransform(max, max, m);
	
	                this.x = mathMin(min[0], max[0]);
	                this.y = mathMin(min[1], max[1]);
	                this.width = mathAbs(max[0] - min[0]);
	                this.height = mathAbs(max[1] - min[1]);
	            };
	        })(),
	
	        /**
	         * Calculate matrix of transforming from self to target rect
	         * @param  {module:zrender/core/BoundingRect} b
	         * @return {Array.<number>}
	         */
	        calculateTransform: function (b) {
	            var a = this;
	            var sx = b.width / a.width;
	            var sy = b.height / a.height;
	
	            var m = matrix.create();
	
	            // 矩阵右乘
	            matrix.translate(m, m, [-a.x, -a.y]);
	            matrix.scale(m, m, [sx, sy]);
	            matrix.translate(m, m, [b.x, b.y]);
	
	            return m;
	        },
	
	        /**
	         * @param {(module:echarts/core/BoundingRect|Object)} b
	         * @return {boolean}
	         */
	        intersect: function (b) {
	            var a = this;
	            var ax0 = a.x;
	            var ax1 = a.x + a.width;
	            var ay0 = a.y;
	            var ay1 = a.y + a.height;
	
	            var bx0 = b.x;
	            var bx1 = b.x + b.width;
	            var by0 = b.y;
	            var by1 = b.y + b.height;
	
	            return ! (ax1 < bx0 || bx1 < ax0 || ay1 < by0 || by1 < ay0);
	        },
	
	        contain: function (x, y) {
	            var rect = this;
	            return x >= rect.x
	                && x <= (rect.x + rect.width)
	                && y >= rect.y
	                && y <= (rect.y + rect.height);
	        },
	
	        /**
	         * @return {module:echarts/core/BoundingRect}
	         */
	        clone: function () {
	            return new BoundingRect(this.x, this.y, this.width, this.height);
	        },
	
	        /**
	         * Copy from another rect
	         */
	        copy: function (other) {
	            this.x = other.x;
	            this.y = other.y;
	            this.width = other.width;
	            this.height = other.height;
	        }
	    };
	
	    module.exports = BoundingRect;


/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	/**
	 * Path 代理，可以在`buildPath`中用于替代`ctx`, 会保存每个path操作的命令到pathCommands属性中
	 * 可以用于 isInsidePath 判断以及获取boundingRect
	 *
	 * @module zrender/core/PathProxy
	 * @author Yi Shen (http://www.github.com/pissang)
	 */
	
	 // TODO getTotalLength, getPointAtLength
	
	
	    var curve = __webpack_require__(26);
	    var vec2 = __webpack_require__(14);
	    var bbox = __webpack_require__(27);
	    var BoundingRect = __webpack_require__(24);
	    var dpr = __webpack_require__(21).devicePixelRatio;
	
	    var CMD = {
	        M: 1,
	        L: 2,
	        C: 3,
	        Q: 4,
	        A: 5,
	        Z: 6,
	        // Rect
	        R: 7
	    };
	
	    var min = [];
	    var max = [];
	    var min2 = [];
	    var max2 = [];
	    var mathMin = Math.min;
	    var mathMax = Math.max;
	    var mathCos = Math.cos;
	    var mathSin = Math.sin;
	    var mathSqrt = Math.sqrt;
	    var mathAbs = Math.abs;
	
	    var hasTypedArray = typeof Float32Array != 'undefined';
	
	    /**
	     * @alias module:zrender/core/PathProxy
	     * @constructor
	     */
	    var PathProxy = function () {
	
	        /**
	         * Path data. Stored as flat array
	         * @type {Array.<Object>}
	         */
	        this.data = [];
	
	        this._len = 0;
	
	        this._ctx = null;
	
	        this._xi = 0;
	        this._yi = 0;
	
	        this._x0 = 0;
	        this._y0 = 0;
	
	        // Unit x, Unit y. Provide for avoiding drawing that too short line segment
	        this._ux = 0;
	        this._uy = 0;
	    };
	
	    /**
	     * 快速计算Path包围盒（并不是最小包围盒）
	     * @return {Object}
	     */
	    PathProxy.prototype = {
	
	        constructor: PathProxy,
	
	        _lineDash: null,
	
	        _dashOffset: 0,
	
	        _dashIdx: 0,
	
	        _dashSum: 0,
	
	        /**
	         * @readOnly
	         */
	        setScale: function (sx, sy) {
	            this._ux = mathAbs(1 / dpr / sx) || 0;
	            this._uy = mathAbs(1 / dpr / sy) || 0;
	        },
	
	        getContext: function () {
	            return this._ctx;
	        },
	
	        /**
	         * @param  {CanvasRenderingContext2D} ctx
	         * @return {module:zrender/core/PathProxy}
	         */
	        beginPath: function (ctx) {
	
	            this._ctx = ctx;
	
	            ctx && ctx.beginPath();
	
	            ctx && (this.dpr = ctx.dpr);
	
	            // Reset
	            this._len = 0;
	
	            if (this._lineDash) {
	                this._lineDash = null;
	
	                this._dashOffset = 0;
	            }
	
	            return this;
	        },
	
	        /**
	         * @param  {number} x
	         * @param  {number} y
	         * @return {module:zrender/core/PathProxy}
	         */
	        moveTo: function (x, y) {
	            this.addData(CMD.M, x, y);
	            this._ctx && this._ctx.moveTo(x, y);
	
	            // x0, y0, xi, yi 是记录在 _dashedXXXXTo 方法中使用
	            // xi, yi 记录当前点, x0, y0 在 closePath 的时候回到起始点。
	            // 有可能在 beginPath 之后直接调用 lineTo，这时候 x0, y0 需要
	            // 在 lineTo 方法中记录，这里先不考虑这种情况，dashed line 也只在 IE10- 中不支持
	            this._x0 = x;
	            this._y0 = y;
	
	            this._xi = x;
	            this._yi = y;
	
	            return this;
	        },
	
	        /**
	         * @param  {number} x
	         * @param  {number} y
	         * @return {module:zrender/core/PathProxy}
	         */
	        lineTo: function (x, y) {
	            var exceedUnit = mathAbs(x - this._xi) > this._ux
	                || mathAbs(y - this._yi) > this._uy
	                // Force draw the first segment
	                || this._len < 5;
	
	            this.addData(CMD.L, x, y);
	
	            if (this._ctx && exceedUnit) {
	                this._needsDash() ? this._dashedLineTo(x, y)
	                    : this._ctx.lineTo(x, y);
	            }
	            if (exceedUnit) {
	                this._xi = x;
	                this._yi = y;
	            }
	
	            return this;
	        },
	
	        /**
	         * @param  {number} x1
	         * @param  {number} y1
	         * @param  {number} x2
	         * @param  {number} y2
	         * @param  {number} x3
	         * @param  {number} y3
	         * @return {module:zrender/core/PathProxy}
	         */
	        bezierCurveTo: function (x1, y1, x2, y2, x3, y3) {
	            this.addData(CMD.C, x1, y1, x2, y2, x3, y3);
	            if (this._ctx) {
	                this._needsDash() ? this._dashedBezierTo(x1, y1, x2, y2, x3, y3)
	                    : this._ctx.bezierCurveTo(x1, y1, x2, y2, x3, y3);
	            }
	            this._xi = x3;
	            this._yi = y3;
	            return this;
	        },
	
	        /**
	         * @param  {number} x1
	         * @param  {number} y1
	         * @param  {number} x2
	         * @param  {number} y2
	         * @return {module:zrender/core/PathProxy}
	         */
	        quadraticCurveTo: function (x1, y1, x2, y2) {
	            this.addData(CMD.Q, x1, y1, x2, y2);
	            if (this._ctx) {
	                this._needsDash() ? this._dashedQuadraticTo(x1, y1, x2, y2)
	                    : this._ctx.quadraticCurveTo(x1, y1, x2, y2);
	            }
	            this._xi = x2;
	            this._yi = y2;
	            return this;
	        },
	
	        /**
	         * @param  {number} cx
	         * @param  {number} cy
	         * @param  {number} r
	         * @param  {number} startAngle
	         * @param  {number} endAngle
	         * @param  {boolean} anticlockwise
	         * @return {module:zrender/core/PathProxy}
	         */
	        arc: function (cx, cy, r, startAngle, endAngle, anticlockwise) {
	            this.addData(
	                CMD.A, cx, cy, r, r, startAngle, endAngle - startAngle, 0, anticlockwise ? 0 : 1
	            );
	            this._ctx && this._ctx.arc(cx, cy, r, startAngle, endAngle, anticlockwise);
	
	            this._xi = mathCos(endAngle) * r + cx;
	            this._xi = mathSin(endAngle) * r + cx;
	            return this;
	        },
	
	        // TODO
	        arcTo: function (x1, y1, x2, y2, radius) {
	            if (this._ctx) {
	                this._ctx.arcTo(x1, y1, x2, y2, radius);
	            }
	            return this;
	        },
	
	        // TODO
	        rect: function (x, y, w, h) {
	            this._ctx && this._ctx.rect(x, y, w, h);
	            this.addData(CMD.R, x, y, w, h);
	            return this;
	        },
	
	        /**
	         * @return {module:zrender/core/PathProxy}
	         */
	        closePath: function () {
	            this.addData(CMD.Z);
	
	            var ctx = this._ctx;
	            var x0 = this._x0;
	            var y0 = this._y0;
	            if (ctx) {
	                this._needsDash() && this._dashedLineTo(x0, y0);
	                ctx.closePath();
	            }
	
	            this._xi = x0;
	            this._yi = y0;
	            return this;
	        },
	
	        /**
	         * Context 从外部传入，因为有可能是 rebuildPath 完之后再 fill。
	         * stroke 同样
	         * @param {CanvasRenderingContext2D} ctx
	         * @return {module:zrender/core/PathProxy}
	         */
	        fill: function (ctx) {
	            ctx && ctx.fill();
	            this.toStatic();
	        },
	
	        /**
	         * @param {CanvasRenderingContext2D} ctx
	         * @return {module:zrender/core/PathProxy}
	         */
	        stroke: function (ctx) {
	            ctx && ctx.stroke();
	            this.toStatic();
	        },
	
	        /**
	         * 必须在其它绘制命令前调用
	         * Must be invoked before all other path drawing methods
	         * @return {module:zrender/core/PathProxy}
	         */
	        setLineDash: function (lineDash) {
	            if (lineDash instanceof Array) {
	                this._lineDash = lineDash;
	
	                this._dashIdx = 0;
	
	                var lineDashSum = 0;
	                for (var i = 0; i < lineDash.length; i++) {
	                    lineDashSum += lineDash[i];
	                }
	                this._dashSum = lineDashSum;
	            }
	            return this;
	        },
	
	        /**
	         * 必须在其它绘制命令前调用
	         * Must be invoked before all other path drawing methods
	         * @return {module:zrender/core/PathProxy}
	         */
	        setLineDashOffset: function (offset) {
	            this._dashOffset = offset;
	            return this;
	        },
	
	        /**
	         *
	         * @return {boolean}
	         */
	        len: function () {
	            return this._len;
	        },
	
	        /**
	         * 直接设置 Path 数据
	         */
	        setData: function (data) {
	
	            var len = data.length;
	
	            if (! (this.data && this.data.length == len) && hasTypedArray) {
	                this.data = new Float32Array(len);
	            }
	
	            for (var i = 0; i < len; i++) {
	                this.data[i] = data[i];
	            }
	
	            this._len = len;
	        },
	
	        /**
	         * 添加子路径
	         * @param {module:zrender/core/PathProxy|Array.<module:zrender/core/PathProxy>} path
	         */
	        appendPath: function (path) {
	            if (!(path instanceof Array)) {
	                path = [path];
	            }
	            var len = path.length;
	            var appendSize = 0;
	            var offset = this._len;
	            for (var i = 0; i < len; i++) {
	                appendSize += path[i].len();
	            }
	            if (hasTypedArray && (this.data instanceof Float32Array)) {
	                this.data = new Float32Array(offset + appendSize);
	            }
	            for (var i = 0; i < len; i++) {
	                var appendPathData = path[i].data;
	                for (var k = 0; k < appendPathData.length; k++) {
	                    this.data[offset++] = appendPathData[k];
	                }
	            }
	            this._len = offset;
	        },
	
	        /**
	         * 填充 Path 数据。
	         * 尽量复用而不申明新的数组。大部分图形重绘的指令数据长度都是不变的。
	         */
	        addData: function (cmd) {
	            var data = this.data;
	            if (this._len + arguments.length > data.length) {
	                // 因为之前的数组已经转换成静态的 Float32Array
	                // 所以不够用时需要扩展一个新的动态数组
	                this._expandData();
	                data = this.data;
	            }
	            for (var i = 0; i < arguments.length; i++) {
	                data[this._len++] = arguments[i];
	            }
	
	            this._prevCmd = cmd;
	        },
	
	        _expandData: function () {
	            // Only if data is Float32Array
	            if (!(this.data instanceof Array)) {
	                var newData = [];
	                for (var i = 0; i < this._len; i++) {
	                    newData[i] = this.data[i];
	                }
	                this.data = newData;
	            }
	        },
	
	        /**
	         * If needs js implemented dashed line
	         * @return {boolean}
	         * @private
	         */
	        _needsDash: function () {
	            return this._lineDash;
	        },
	
	        _dashedLineTo: function (x1, y1) {
	            var dashSum = this._dashSum;
	            var offset = this._dashOffset;
	            var lineDash = this._lineDash;
	            var ctx = this._ctx;
	
	            var x0 = this._xi;
	            var y0 = this._yi;
	            var dx = x1 - x0;
	            var dy = y1 - y0;
	            var dist = mathSqrt(dx * dx + dy * dy);
	            var x = x0;
	            var y = y0;
	            var dash;
	            var nDash = lineDash.length;
	            var idx;
	            dx /= dist;
	            dy /= dist;
	
	            if (offset < 0) {
	                // Convert to positive offset
	                offset = dashSum + offset;
	            }
	            offset %= dashSum;
	            x -= offset * dx;
	            y -= offset * dy;
	
	            while ((dx > 0 && x <= x1) || (dx < 0 && x >= x1)
	            || (dx == 0 && ((dy > 0 && y <= y1) || (dy < 0 && y >= y1)))) {
	                idx = this._dashIdx;
	                dash = lineDash[idx];
	                x += dx * dash;
	                y += dy * dash;
	                this._dashIdx = (idx + 1) % nDash;
	                // Skip positive offset
	                if ((dx > 0 && x < x0) || (dx < 0 && x > x0) || (dy > 0 && y < y0) || (dy < 0 && y > y0)) {
	                    continue;
	                }
	                ctx[idx % 2 ? 'moveTo' : 'lineTo'](
	                    dx >= 0 ? mathMin(x, x1) : mathMax(x, x1),
	                    dy >= 0 ? mathMin(y, y1) : mathMax(y, y1)
	                );
	            }
	            // Offset for next lineTo
	            dx = x - x1;
	            dy = y - y1;
	            this._dashOffset = -mathSqrt(dx * dx + dy * dy);
	        },
	
	        // Not accurate dashed line to
	        _dashedBezierTo: function (x1, y1, x2, y2, x3, y3) {
	            var dashSum = this._dashSum;
	            var offset = this._dashOffset;
	            var lineDash = this._lineDash;
	            var ctx = this._ctx;
	
	            var x0 = this._xi;
	            var y0 = this._yi;
	            var t;
	            var dx;
	            var dy;
	            var cubicAt = curve.cubicAt;
	            var bezierLen = 0;
	            var idx = this._dashIdx;
	            var nDash = lineDash.length;
	
	            var x;
	            var y;
	
	            var tmpLen = 0;
	
	            if (offset < 0) {
	                // Convert to positive offset
	                offset = dashSum + offset;
	            }
	            offset %= dashSum;
	            // Bezier approx length
	            for (t = 0; t < 1; t += 0.1) {
	                dx = cubicAt(x0, x1, x2, x3, t + 0.1)
	                    - cubicAt(x0, x1, x2, x3, t);
	                dy = cubicAt(y0, y1, y2, y3, t + 0.1)
	                    - cubicAt(y0, y1, y2, y3, t);
	                bezierLen += mathSqrt(dx * dx + dy * dy);
	            }
	
	            // Find idx after add offset
	            for (; idx < nDash; idx++) {
	                tmpLen += lineDash[idx];
	                if (tmpLen > offset) {
	                    break;
	                }
	            }
	            t = (tmpLen - offset) / bezierLen;
	
	            while (t <= 1) {
	
	                x = cubicAt(x0, x1, x2, x3, t);
	                y = cubicAt(y0, y1, y2, y3, t);
	
	                // Use line to approximate dashed bezier
	                // Bad result if dash is long
	                idx % 2 ? ctx.moveTo(x, y)
	                    : ctx.lineTo(x, y);
	
	                t += lineDash[idx] / bezierLen;
	
	                idx = (idx + 1) % nDash;
	            }
	
	            // Finish the last segment and calculate the new offset
	            (idx % 2 !== 0) && ctx.lineTo(x3, y3);
	            dx = x3 - x;
	            dy = y3 - y;
	            this._dashOffset = -mathSqrt(dx * dx + dy * dy);
	        },
	
	        _dashedQuadraticTo: function (x1, y1, x2, y2) {
	            // Convert quadratic to cubic using degree elevation
	            var x3 = x2;
	            var y3 = y2;
	            x2 = (x2 + 2 * x1) / 3;
	            y2 = (y2 + 2 * y1) / 3;
	            x1 = (this._xi + 2 * x1) / 3;
	            y1 = (this._yi + 2 * y1) / 3;
	
	            this._dashedBezierTo(x1, y1, x2, y2, x3, y3);
	        },
	
	        /**
	         * 转成静态的 Float32Array 减少堆内存占用
	         * Convert dynamic array to static Float32Array
	         */
	        toStatic: function () {
	            var data = this.data;
	            if (data instanceof Array) {
	                data.length = this._len;
	                if (hasTypedArray) {
	                    this.data = new Float32Array(data);
	                }
	            }
	        },
	
	        /**
	         * @return {module:zrender/core/BoundingRect}
	         */
	        getBoundingRect: function () {
	            min[0] = min[1] = min2[0] = min2[1] = Number.MAX_VALUE;
	            max[0] = max[1] = max2[0] = max2[1] = -Number.MAX_VALUE;
	
	            var data = this.data;
	            var xi = 0;
	            var yi = 0;
	            var x0 = 0;
	            var y0 = 0;
	
	            for (var i = 0; i < data.length;) {
	                var cmd = data[i++];
	
	                if (i == 1) {
	                    // 如果第一个命令是 L, C, Q
	                    // 则 previous point 同绘制命令的第一个 point
	                    //
	                    // 第一个命令为 Arc 的情况下会在后面特殊处理
	                    xi = data[i];
	                    yi = data[i + 1];
	
	                    x0 = xi;
	                    y0 = yi;
	                }
	
	                switch (cmd) {
	                    case CMD.M:
	                        // moveTo 命令重新创建一个新的 subpath, 并且更新新的起点
	                        // 在 closePath 的时候使用
	                        x0 = data[i++];
	                        y0 = data[i++];
	                        xi = x0;
	                        yi = y0;
	                        min2[0] = x0;
	                        min2[1] = y0;
	                        max2[0] = x0;
	                        max2[1] = y0;
	                        break;
	                    case CMD.L:
	                        bbox.fromLine(xi, yi, data[i], data[i + 1], min2, max2);
	                        xi = data[i++];
	                        yi = data[i++];
	                        break;
	                    case CMD.C:
	                        bbox.fromCubic(
	                            xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1],
	                            min2, max2
	                        );
	                        xi = data[i++];
	                        yi = data[i++];
	                        break;
	                    case CMD.Q:
	                        bbox.fromQuadratic(
	                            xi, yi, data[i++], data[i++], data[i], data[i + 1],
	                            min2, max2
	                        );
	                        xi = data[i++];
	                        yi = data[i++];
	                        break;
	                    case CMD.A:
	                        // TODO Arc 判断的开销比较大
	                        var cx = data[i++];
	                        var cy = data[i++];
	                        var rx = data[i++];
	                        var ry = data[i++];
	                        var startAngle = data[i++];
	                        var endAngle = data[i++] + startAngle;
	                        // TODO Arc 旋转
	                        var psi = data[i++];
	                        var anticlockwise = 1 - data[i++];
	
	                        if (i == 1) {
	                            // 直接使用 arc 命令
	                            // 第一个命令起点还未定义
	                            x0 = mathCos(startAngle) * rx + cx;
	                            y0 = mathSin(startAngle) * ry + cy;
	                        }
	
	                        bbox.fromArc(
	                            cx, cy, rx, ry, startAngle, endAngle,
	                            anticlockwise, min2, max2
	                        );
	
	                        xi = mathCos(endAngle) * rx + cx;
	                        yi = mathSin(endAngle) * ry + cy;
	                        break;
	                    case CMD.R:
	                        x0 = xi = data[i++];
	                        y0 = yi = data[i++];
	                        var width = data[i++];
	                        var height = data[i++];
	                        // Use fromLine
	                        bbox.fromLine(x0, y0, x0 + width, y0 + height, min2, max2);
	                        break;
	                    case CMD.Z:
	                        xi = x0;
	                        yi = y0;
	                        break;
	                }
	
	                // Union
	                vec2.min(min, min, min2);
	                vec2.max(max, max, max2);
	            }
	
	            // No data
	            if (i === 0) {
	                min[0] = min[1] = max[0] = max[1] = 0;
	            }
	
	            return new BoundingRect(
	                min[0], min[1], max[0] - min[0], max[1] - min[1]
	            );
	        },
	
	        /**
	         * Rebuild path from current data
	         * Rebuild path will not consider javascript implemented line dash.
	         * @param {CanvasRenderingContext} ctx
	         */
	        rebuildPath: function (ctx) {
	            var d = this.data;
	            var x0, y0;
	            var xi, yi;
	            var x, y;
	            var ux = this._ux;
	            var uy = this._uy;
	            var len = this._len;
	            for (var i = 0; i < len;) {
	                var cmd = d[i++];
	
	                if (i == 1) {
	                    // 如果第一个命令是 L, C, Q
	                    // 则 previous point 同绘制命令的第一个 point
	                    //
	                    // 第一个命令为 Arc 的情况下会在后面特殊处理
	                    xi = d[i];
	                    yi = d[i + 1];
	
	                    x0 = xi;
	                    y0 = yi;
	                }
	                switch (cmd) {
	                    case CMD.M:
	                        x0 = xi = d[i++];
	                        y0 = yi = d[i++];
	                        ctx.moveTo(xi, yi);
	                        break;
	                    case CMD.L:
	                        x = d[i++];
	                        y = d[i++];
	                        // Not draw too small seg between
	                        if (mathAbs(x - xi) > ux || mathAbs(y - yi) > uy || i === len - 1) {
	                            ctx.lineTo(x, y);
	                            xi = x;
	                            yi = y;
	                        }
	                        break;
	                    case CMD.C:
	                        ctx.bezierCurveTo(
	                            d[i++], d[i++], d[i++], d[i++], d[i++], d[i++]
	                        );
	                        xi = d[i - 2];
	                        yi = d[i - 1];
	                        break;
	                    case CMD.Q:
	                        ctx.quadraticCurveTo(d[i++], d[i++], d[i++], d[i++]);
	                        xi = d[i - 2];
	                        yi = d[i - 1];
	                        break;
	                    case CMD.A:
	                        var cx = d[i++];
	                        var cy = d[i++];
	                        var rx = d[i++];
	                        var ry = d[i++];
	                        var theta = d[i++];
	                        var dTheta = d[i++];
	                        var psi = d[i++];
	                        var fs = d[i++];
	                        var r = (rx > ry) ? rx : ry;
	                        var scaleX = (rx > ry) ? 1 : rx / ry;
	                        var scaleY = (rx > ry) ? ry / rx : 1;
	                        var isEllipse = Math.abs(rx - ry) > 1e-3;
	                        var endAngle = theta + dTheta;
	                        if (isEllipse) {
	                            ctx.translate(cx, cy);
	                            ctx.rotate(psi);
	                            ctx.scale(scaleX, scaleY);
	                            ctx.arc(0, 0, r, theta, endAngle, 1 - fs);
	                            ctx.scale(1 / scaleX, 1 / scaleY);
	                            ctx.rotate(-psi);
	                            ctx.translate(-cx, -cy);
	                        }
	                        else {
	                            ctx.arc(cx, cy, r, theta, endAngle, 1 - fs);
	                        }
	
	                        if (i == 1) {
	                            // 直接使用 arc 命令
	                            // 第一个命令起点还未定义
	                            x0 = mathCos(theta) * rx + cx;
	                            y0 = mathSin(theta) * ry + cy;
	                        }
	                        xi = mathCos(endAngle) * rx + cx;
	                        yi = mathSin(endAngle) * ry + cy;
	                        break;
	                    case CMD.R:
	                        x0 = xi = d[i];
	                        y0 = yi = d[i + 1];
	                        ctx.rect(d[i++], d[i++], d[i++], d[i++]);
	                        break;
	                    case CMD.Z:
	                        ctx.closePath();
	                        xi = x0;
	                        yi = y0;
	                }
	            }
	        }
	    };
	
	    PathProxy.CMD = CMD;
	
	    module.exports = PathProxy;


/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	/**
	 * 曲线辅助模块
	 * @module zrender/core/curve
	 * @author pissang(https://www.github.com/pissang)
	 */
	
	
	    var vec2 = __webpack_require__(14);
	    var v2Create = vec2.create;
	    var v2DistSquare = vec2.distSquare;
	    var mathPow = Math.pow;
	    var mathSqrt = Math.sqrt;
	
	    var EPSILON = 1e-8;
	    var EPSILON_NUMERIC = 1e-4;
	
	    var THREE_SQRT = mathSqrt(3);
	    var ONE_THIRD = 1 / 3;
	
	    // 临时变量
	    var _v0 = v2Create();
	    var _v1 = v2Create();
	    var _v2 = v2Create();
	    // var _v3 = vec2.create();
	
	    function isAroundZero(val) {
	        return val > -EPSILON && val < EPSILON;
	    }
	    function isNotAroundZero(val) {
	        return val > EPSILON || val < -EPSILON;
	    }
	    /**
	     * 计算三次贝塞尔值
	     * @memberOf module:zrender/core/curve
	     * @param  {number} p0
	     * @param  {number} p1
	     * @param  {number} p2
	     * @param  {number} p3
	     * @param  {number} t
	     * @return {number}
	     */
	    function cubicAt(p0, p1, p2, p3, t) {
	        var onet = 1 - t;
	        return onet * onet * (onet * p0 + 3 * t * p1)
	             + t * t * (t * p3 + 3 * onet * p2);
	    }
	
	    /**
	     * 计算三次贝塞尔导数值
	     * @memberOf module:zrender/core/curve
	     * @param  {number} p0
	     * @param  {number} p1
	     * @param  {number} p2
	     * @param  {number} p3
	     * @param  {number} t
	     * @return {number}
	     */
	    function cubicDerivativeAt(p0, p1, p2, p3, t) {
	        var onet = 1 - t;
	        return 3 * (
	            ((p1 - p0) * onet + 2 * (p2 - p1) * t) * onet
	            + (p3 - p2) * t * t
	        );
	    }
	
	    /**
	     * 计算三次贝塞尔方程根，使用盛金公式
	     * @memberOf module:zrender/core/curve
	     * @param  {number} p0
	     * @param  {number} p1
	     * @param  {number} p2
	     * @param  {number} p3
	     * @param  {number} val
	     * @param  {Array.<number>} roots
	     * @return {number} 有效根数目
	     */
	    function cubicRootAt(p0, p1, p2, p3, val, roots) {
	        // Evaluate roots of cubic functions
	        var a = p3 + 3 * (p1 - p2) - p0;
	        var b = 3 * (p2 - p1 * 2 + p0);
	        var c = 3 * (p1  - p0);
	        var d = p0 - val;
	
	        var A = b * b - 3 * a * c;
	        var B = b * c - 9 * a * d;
	        var C = c * c - 3 * b * d;
	
	        var n = 0;
	
	        if (isAroundZero(A) && isAroundZero(B)) {
	            if (isAroundZero(b)) {
	                roots[0] = 0;
	            }
	            else {
	                var t1 = -c / b;  //t1, t2, t3, b is not zero
	                if (t1 >= 0 && t1 <= 1) {
	                    roots[n++] = t1;
	                }
	            }
	        }
	        else {
	            var disc = B * B - 4 * A * C;
	
	            if (isAroundZero(disc)) {
	                var K = B / A;
	                var t1 = -b / a + K;  // t1, a is not zero
	                var t2 = -K / 2;  // t2, t3
	                if (t1 >= 0 && t1 <= 1) {
	                    roots[n++] = t1;
	                }
	                if (t2 >= 0 && t2 <= 1) {
	                    roots[n++] = t2;
	                }
	            }
	            else if (disc > 0) {
	                var discSqrt = mathSqrt(disc);
	                var Y1 = A * b + 1.5 * a * (-B + discSqrt);
	                var Y2 = A * b + 1.5 * a * (-B - discSqrt);
	                if (Y1 < 0) {
	                    Y1 = -mathPow(-Y1, ONE_THIRD);
	                }
	                else {
	                    Y1 = mathPow(Y1, ONE_THIRD);
	                }
	                if (Y2 < 0) {
	                    Y2 = -mathPow(-Y2, ONE_THIRD);
	                }
	                else {
	                    Y2 = mathPow(Y2, ONE_THIRD);
	                }
	                var t1 = (-b - (Y1 + Y2)) / (3 * a);
	                if (t1 >= 0 && t1 <= 1) {
	                    roots[n++] = t1;
	                }
	            }
	            else {
	                var T = (2 * A * b - 3 * a * B) / (2 * mathSqrt(A * A * A));
	                var theta = Math.acos(T) / 3;
	                var ASqrt = mathSqrt(A);
	                var tmp = Math.cos(theta);
	
	                var t1 = (-b - 2 * ASqrt * tmp) / (3 * a);
	                var t2 = (-b + ASqrt * (tmp + THREE_SQRT * Math.sin(theta))) / (3 * a);
	                var t3 = (-b + ASqrt * (tmp - THREE_SQRT * Math.sin(theta))) / (3 * a);
	                if (t1 >= 0 && t1 <= 1) {
	                    roots[n++] = t1;
	                }
	                if (t2 >= 0 && t2 <= 1) {
	                    roots[n++] = t2;
	                }
	                if (t3 >= 0 && t3 <= 1) {
	                    roots[n++] = t3;
	                }
	            }
	        }
	        return n;
	    }
	
	    /**
	     * 计算三次贝塞尔方程极限值的位置
	     * @memberOf module:zrender/core/curve
	     * @param  {number} p0
	     * @param  {number} p1
	     * @param  {number} p2
	     * @param  {number} p3
	     * @param  {Array.<number>} extrema
	     * @return {number} 有效数目
	     */
	    function cubicExtrema(p0, p1, p2, p3, extrema) {
	        var b = 6 * p2 - 12 * p1 + 6 * p0;
	        var a = 9 * p1 + 3 * p3 - 3 * p0 - 9 * p2;
	        var c = 3 * p1 - 3 * p0;
	
	        var n = 0;
	        if (isAroundZero(a)) {
	            if (isNotAroundZero(b)) {
	                var t1 = -c / b;
	                if (t1 >= 0 && t1 <=1) {
	                    extrema[n++] = t1;
	                }
	            }
	        }
	        else {
	            var disc = b * b - 4 * a * c;
	            if (isAroundZero(disc)) {
	                extrema[0] = -b / (2 * a);
	            }
	            else if (disc > 0) {
	                var discSqrt = mathSqrt(disc);
	                var t1 = (-b + discSqrt) / (2 * a);
	                var t2 = (-b - discSqrt) / (2 * a);
	                if (t1 >= 0 && t1 <= 1) {
	                    extrema[n++] = t1;
	                }
	                if (t2 >= 0 && t2 <= 1) {
	                    extrema[n++] = t2;
	                }
	            }
	        }
	        return n;
	    }
	
	    /**
	     * 细分三次贝塞尔曲线
	     * @memberOf module:zrender/core/curve
	     * @param  {number} p0
	     * @param  {number} p1
	     * @param  {number} p2
	     * @param  {number} p3
	     * @param  {number} t
	     * @param  {Array.<number>} out
	     */
	    function cubicSubdivide(p0, p1, p2, p3, t, out) {
	        var p01 = (p1 - p0) * t + p0;
	        var p12 = (p2 - p1) * t + p1;
	        var p23 = (p3 - p2) * t + p2;
	
	        var p012 = (p12 - p01) * t + p01;
	        var p123 = (p23 - p12) * t + p12;
	
	        var p0123 = (p123 - p012) * t + p012;
	        // Seg0
	        out[0] = p0;
	        out[1] = p01;
	        out[2] = p012;
	        out[3] = p0123;
	        // Seg1
	        out[4] = p0123;
	        out[5] = p123;
	        out[6] = p23;
	        out[7] = p3;
	    }
	
	    /**
	     * 投射点到三次贝塞尔曲线上，返回投射距离。
	     * 投射点有可能会有一个或者多个，这里只返回其中距离最短的一个。
	     * @param {number} x0
	     * @param {number} y0
	     * @param {number} x1
	     * @param {number} y1
	     * @param {number} x2
	     * @param {number} y2
	     * @param {number} x3
	     * @param {number} y3
	     * @param {number} x
	     * @param {number} y
	     * @param {Array.<number>} [out] 投射点
	     * @return {number}
	     */
	    function cubicProjectPoint(
	        x0, y0, x1, y1, x2, y2, x3, y3,
	        x, y, out
	    ) {
	        // http://pomax.github.io/bezierinfo/#projections
	        var t;
	        var interval = 0.005;
	        var d = Infinity;
	        var prev;
	        var next;
	        var d1;
	        var d2;
	
	        _v0[0] = x;
	        _v0[1] = y;
	
	        // 先粗略估计一下可能的最小距离的 t 值
	        // PENDING
	        for (var _t = 0; _t < 1; _t += 0.05) {
	            _v1[0] = cubicAt(x0, x1, x2, x3, _t);
	            _v1[1] = cubicAt(y0, y1, y2, y3, _t);
	            d1 = v2DistSquare(_v0, _v1);
	            if (d1 < d) {
	                t = _t;
	                d = d1;
	            }
	        }
	        d = Infinity;
	
	        // At most 32 iteration
	        for (var i = 0; i < 32; i++) {
	            if (interval < EPSILON_NUMERIC) {
	                break;
	            }
	            prev = t - interval;
	            next = t + interval;
	            // t - interval
	            _v1[0] = cubicAt(x0, x1, x2, x3, prev);
	            _v1[1] = cubicAt(y0, y1, y2, y3, prev);
	
	            d1 = v2DistSquare(_v1, _v0);
	
	            if (prev >= 0 && d1 < d) {
	                t = prev;
	                d = d1;
	            }
	            else {
	                // t + interval
	                _v2[0] = cubicAt(x0, x1, x2, x3, next);
	                _v2[1] = cubicAt(y0, y1, y2, y3, next);
	                d2 = v2DistSquare(_v2, _v0);
	
	                if (next <= 1 && d2 < d) {
	                    t = next;
	                    d = d2;
	                }
	                else {
	                    interval *= 0.5;
	                }
	            }
	        }
	        // t
	        if (out) {
	            out[0] = cubicAt(x0, x1, x2, x3, t);
	            out[1] = cubicAt(y0, y1, y2, y3, t);
	        }
	        // console.log(interval, i);
	        return mathSqrt(d);
	    }
	
	    /**
	     * 计算二次方贝塞尔值
	     * @param  {number} p0
	     * @param  {number} p1
	     * @param  {number} p2
	     * @param  {number} t
	     * @return {number}
	     */
	    function quadraticAt(p0, p1, p2, t) {
	        var onet = 1 - t;
	        return onet * (onet * p0 + 2 * t * p1) + t * t * p2;
	    }
	
	    /**
	     * 计算二次方贝塞尔导数值
	     * @param  {number} p0
	     * @param  {number} p1
	     * @param  {number} p2
	     * @param  {number} t
	     * @return {number}
	     */
	    function quadraticDerivativeAt(p0, p1, p2, t) {
	        return 2 * ((1 - t) * (p1 - p0) + t * (p2 - p1));
	    }
	
	    /**
	     * 计算二次方贝塞尔方程根
	     * @param  {number} p0
	     * @param  {number} p1
	     * @param  {number} p2
	     * @param  {number} t
	     * @param  {Array.<number>} roots
	     * @return {number} 有效根数目
	     */
	    function quadraticRootAt(p0, p1, p2, val, roots) {
	        var a = p0 - 2 * p1 + p2;
	        var b = 2 * (p1 - p0);
	        var c = p0 - val;
	
	        var n = 0;
	        if (isAroundZero(a)) {
	            if (isNotAroundZero(b)) {
	                var t1 = -c / b;
	                if (t1 >= 0 && t1 <= 1) {
	                    roots[n++] = t1;
	                }
	            }
	        }
	        else {
	            var disc = b * b - 4 * a * c;
	            if (isAroundZero(disc)) {
	                var t1 = -b / (2 * a);
	                if (t1 >= 0 && t1 <= 1) {
	                    roots[n++] = t1;
	                }
	            }
	            else if (disc > 0) {
	                var discSqrt = mathSqrt(disc);
	                var t1 = (-b + discSqrt) / (2 * a);
	                var t2 = (-b - discSqrt) / (2 * a);
	                if (t1 >= 0 && t1 <= 1) {
	                    roots[n++] = t1;
	                }
	                if (t2 >= 0 && t2 <= 1) {
	                    roots[n++] = t2;
	                }
	            }
	        }
	        return n;
	    }
	
	    /**
	     * 计算二次贝塞尔方程极限值
	     * @memberOf module:zrender/core/curve
	     * @param  {number} p0
	     * @param  {number} p1
	     * @param  {number} p2
	     * @return {number}
	     */
	    function quadraticExtremum(p0, p1, p2) {
	        var divider = p0 + p2 - 2 * p1;
	        if (divider === 0) {
	            // p1 is center of p0 and p2
	            return 0.5;
	        }
	        else {
	            return (p0 - p1) / divider;
	        }
	    }
	
	    /**
	     * 细分二次贝塞尔曲线
	     * @memberOf module:zrender/core/curve
	     * @param  {number} p0
	     * @param  {number} p1
	     * @param  {number} p2
	     * @param  {number} t
	     * @param  {Array.<number>} out
	     */
	    function quadraticSubdivide(p0, p1, p2, t, out) {
	        var p01 = (p1 - p0) * t + p0;
	        var p12 = (p2 - p1) * t + p1;
	        var p012 = (p12 - p01) * t + p01;
	
	        // Seg0
	        out[0] = p0;
	        out[1] = p01;
	        out[2] = p012;
	
	        // Seg1
	        out[3] = p012;
	        out[4] = p12;
	        out[5] = p2;
	    }
	
	    /**
	     * 投射点到二次贝塞尔曲线上，返回投射距离。
	     * 投射点有可能会有一个或者多个，这里只返回其中距离最短的一个。
	     * @param {number} x0
	     * @param {number} y0
	     * @param {number} x1
	     * @param {number} y1
	     * @param {number} x2
	     * @param {number} y2
	     * @param {number} x
	     * @param {number} y
	     * @param {Array.<number>} out 投射点
	     * @return {number}
	     */
	    function quadraticProjectPoint(
	        x0, y0, x1, y1, x2, y2,
	        x, y, out
	    ) {
	        // http://pomax.github.io/bezierinfo/#projections
	        var t;
	        var interval = 0.005;
	        var d = Infinity;
	
	        _v0[0] = x;
	        _v0[1] = y;
	
	        // 先粗略估计一下可能的最小距离的 t 值
	        // PENDING
	        for (var _t = 0; _t < 1; _t += 0.05) {
	            _v1[0] = quadraticAt(x0, x1, x2, _t);
	            _v1[1] = quadraticAt(y0, y1, y2, _t);
	            var d1 = v2DistSquare(_v0, _v1);
	            if (d1 < d) {
	                t = _t;
	                d = d1;
	            }
	        }
	        d = Infinity;
	
	        // At most 32 iteration
	        for (var i = 0; i < 32; i++) {
	            if (interval < EPSILON_NUMERIC) {
	                break;
	            }
	            var prev = t - interval;
	            var next = t + interval;
	            // t - interval
	            _v1[0] = quadraticAt(x0, x1, x2, prev);
	            _v1[1] = quadraticAt(y0, y1, y2, prev);
	
	            var d1 = v2DistSquare(_v1, _v0);
	
	            if (prev >= 0 && d1 < d) {
	                t = prev;
	                d = d1;
	            }
	            else {
	                // t + interval
	                _v2[0] = quadraticAt(x0, x1, x2, next);
	                _v2[1] = quadraticAt(y0, y1, y2, next);
	                var d2 = v2DistSquare(_v2, _v0);
	                if (next <= 1 && d2 < d) {
	                    t = next;
	                    d = d2;
	                }
	                else {
	                    interval *= 0.5;
	                }
	            }
	        }
	        // t
	        if (out) {
	            out[0] = quadraticAt(x0, x1, x2, t);
	            out[1] = quadraticAt(y0, y1, y2, t);
	        }
	        // console.log(interval, i);
	        return mathSqrt(d);
	    }
	
	    module.exports = {
	
	        cubicAt: cubicAt,
	
	        cubicDerivativeAt: cubicDerivativeAt,
	
	        cubicRootAt: cubicRootAt,
	
	        cubicExtrema: cubicExtrema,
	
	        cubicSubdivide: cubicSubdivide,
	
	        cubicProjectPoint: cubicProjectPoint,
	
	        quadraticAt: quadraticAt,
	
	        quadraticDerivativeAt: quadraticDerivativeAt,
	
	        quadraticRootAt: quadraticRootAt,
	
	        quadraticExtremum: quadraticExtremum,
	
	        quadraticSubdivide: quadraticSubdivide,
	
	        quadraticProjectPoint: quadraticProjectPoint
	    };


/***/ },
/* 27 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @author Yi Shen(https://github.com/pissang)
	 */
	
	
	    var vec2 = __webpack_require__(14);
	    var curve = __webpack_require__(26);
	
	    var bbox = {};
	    var mathMin = Math.min;
	    var mathMax = Math.max;
	    var mathSin = Math.sin;
	    var mathCos = Math.cos;
	
	    var start = vec2.create();
	    var end = vec2.create();
	    var extremity = vec2.create();
	
	    var PI2 = Math.PI * 2;
	    /**
	     * 从顶点数组中计算出最小包围盒，写入`min`和`max`中
	     * @module zrender/core/bbox
	     * @param {Array<Object>} points 顶点数组
	     * @param {number} min
	     * @param {number} max
	     */
	    bbox.fromPoints = function(points, min, max) {
	        if (points.length === 0) {
	            return;
	        }
	        var p = points[0];
	        var left = p[0];
	        var right = p[0];
	        var top = p[1];
	        var bottom = p[1];
	        var i;
	
	        for (i = 1; i < points.length; i++) {
	            p = points[i];
	            left = mathMin(left, p[0]);
	            right = mathMax(right, p[0]);
	            top = mathMin(top, p[1]);
	            bottom = mathMax(bottom, p[1]);
	        }
	
	        min[0] = left;
	        min[1] = top;
	        max[0] = right;
	        max[1] = bottom;
	    };
	
	    /**
	     * @memberOf module:zrender/core/bbox
	     * @param {number} x0
	     * @param {number} y0
	     * @param {number} x1
	     * @param {number} y1
	     * @param {Array.<number>} min
	     * @param {Array.<number>} max
	     */
	    bbox.fromLine = function (x0, y0, x1, y1, min, max) {
	        min[0] = mathMin(x0, x1);
	        min[1] = mathMin(y0, y1);
	        max[0] = mathMax(x0, x1);
	        max[1] = mathMax(y0, y1);
	    };
	
	    var xDim = [];
	    var yDim = [];
	    /**
	     * 从三阶贝塞尔曲线(p0, p1, p2, p3)中计算出最小包围盒，写入`min`和`max`中
	     * @memberOf module:zrender/core/bbox
	     * @param {number} x0
	     * @param {number} y0
	     * @param {number} x1
	     * @param {number} y1
	     * @param {number} x2
	     * @param {number} y2
	     * @param {number} x3
	     * @param {number} y3
	     * @param {Array.<number>} min
	     * @param {Array.<number>} max
	     */
	    bbox.fromCubic = function(
	        x0, y0, x1, y1, x2, y2, x3, y3, min, max
	    ) {
	        var cubicExtrema = curve.cubicExtrema;
	        var cubicAt = curve.cubicAt;
	        var i;
	        var n = cubicExtrema(x0, x1, x2, x3, xDim);
	        min[0] = Infinity;
	        min[1] = Infinity;
	        max[0] = -Infinity;
	        max[1] = -Infinity;
	
	        for (i = 0; i < n; i++) {
	            var x = cubicAt(x0, x1, x2, x3, xDim[i]);
	            min[0] = mathMin(x, min[0]);
	            max[0] = mathMax(x, max[0]);
	        }
	        n = cubicExtrema(y0, y1, y2, y3, yDim);
	        for (i = 0; i < n; i++) {
	            var y = cubicAt(y0, y1, y2, y3, yDim[i]);
	            min[1] = mathMin(y, min[1]);
	            max[1] = mathMax(y, max[1]);
	        }
	
	        min[0] = mathMin(x0, min[0]);
	        max[0] = mathMax(x0, max[0]);
	        min[0] = mathMin(x3, min[0]);
	        max[0] = mathMax(x3, max[0]);
	
	        min[1] = mathMin(y0, min[1]);
	        max[1] = mathMax(y0, max[1]);
	        min[1] = mathMin(y3, min[1]);
	        max[1] = mathMax(y3, max[1]);
	    };
	
	    /**
	     * 从二阶贝塞尔曲线(p0, p1, p2)中计算出最小包围盒，写入`min`和`max`中
	     * @memberOf module:zrender/core/bbox
	     * @param {number} x0
	     * @param {number} y0
	     * @param {number} x1
	     * @param {number} y1
	     * @param {number} x2
	     * @param {number} y2
	     * @param {Array.<number>} min
	     * @param {Array.<number>} max
	     */
	    bbox.fromQuadratic = function(x0, y0, x1, y1, x2, y2, min, max) {
	        var quadraticExtremum = curve.quadraticExtremum;
	        var quadraticAt = curve.quadraticAt;
	        // Find extremities, where derivative in x dim or y dim is zero
	        var tx =
	            mathMax(
	                mathMin(quadraticExtremum(x0, x1, x2), 1), 0
	            );
	        var ty =
	            mathMax(
	                mathMin(quadraticExtremum(y0, y1, y2), 1), 0
	            );
	
	        var x = quadraticAt(x0, x1, x2, tx);
	        var y = quadraticAt(y0, y1, y2, ty);
	
	        min[0] = mathMin(x0, x2, x);
	        min[1] = mathMin(y0, y2, y);
	        max[0] = mathMax(x0, x2, x);
	        max[1] = mathMax(y0, y2, y);
	    };
	
	    /**
	     * 从圆弧中计算出最小包围盒，写入`min`和`max`中
	     * @method
	     * @memberOf module:zrender/core/bbox
	     * @param {number} x
	     * @param {number} y
	     * @param {number} rx
	     * @param {number} ry
	     * @param {number} startAngle
	     * @param {number} endAngle
	     * @param {number} anticlockwise
	     * @param {Array.<number>} min
	     * @param {Array.<number>} max
	     */
	    bbox.fromArc = function (
	        x, y, rx, ry, startAngle, endAngle, anticlockwise, min, max
	    ) {
	        var vec2Min = vec2.min;
	        var vec2Max = vec2.max;
	
	        var diff = Math.abs(startAngle - endAngle);
	
	
	        if (diff % PI2 < 1e-4 && diff > 1e-4) {
	            // Is a circle
	            min[0] = x - rx;
	            min[1] = y - ry;
	            max[0] = x + rx;
	            max[1] = y + ry;
	            return;
	        }
	
	        start[0] = mathCos(startAngle) * rx + x;
	        start[1] = mathSin(startAngle) * ry + y;
	
	        end[0] = mathCos(endAngle) * rx + x;
	        end[1] = mathSin(endAngle) * ry + y;
	
	        vec2Min(min, start, end);
	        vec2Max(max, start, end);
	
	        // Thresh to [0, Math.PI * 2]
	        startAngle = startAngle % (PI2);
	        if (startAngle < 0) {
	            startAngle = startAngle + PI2;
	        }
	        endAngle = endAngle % (PI2);
	        if (endAngle < 0) {
	            endAngle = endAngle + PI2;
	        }
	
	        if (startAngle > endAngle && !anticlockwise) {
	            endAngle += PI2;
	        }
	        else if (startAngle < endAngle && anticlockwise) {
	            startAngle += PI2;
	        }
	        if (anticlockwise) {
	            var tmp = endAngle;
	            endAngle = startAngle;
	            startAngle = tmp;
	        }
	
	        // var number = 0;
	        // var step = (anticlockwise ? -Math.PI : Math.PI) / 2;
	        for (var angle = 0; angle < endAngle; angle += Math.PI / 2) {
	            if (angle > startAngle) {
	                extremity[0] = mathCos(angle) * rx + x;
	                extremity[1] = mathSin(angle) * ry + y;
	
	                vec2Min(min, extremity, min);
	                vec2Max(max, extremity, max);
	            }
	        }
	    };
	
	    module.exports = bbox;
	


/***/ },
/* 28 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	
	    var CMD = __webpack_require__(25).CMD;
	    var line = __webpack_require__(29);
	    var cubic = __webpack_require__(30);
	    var quadratic = __webpack_require__(31);
	    var arc = __webpack_require__(32);
	    var normalizeRadian = __webpack_require__(33).normalizeRadian;
	    var curve = __webpack_require__(26);
	
	    var windingLine = __webpack_require__(34);
	
	    var containStroke = line.containStroke;
	
	    var PI2 = Math.PI * 2;
	
	    var EPSILON = 1e-4;
	
	    function isAroundEqual(a, b) {
	        return Math.abs(a - b) < EPSILON;
	    }
	
	    // 临时数组
	    var roots = [-1, -1, -1];
	    var extrema = [-1, -1];
	
	    function swapExtrema() {
	        var tmp = extrema[0];
	        extrema[0] = extrema[1];
	        extrema[1] = tmp;
	    }
	
	    function windingCubic(x0, y0, x1, y1, x2, y2, x3, y3, x, y) {
	        // Quick reject
	        if (
	            (y > y0 && y > y1 && y > y2 && y > y3)
	            || (y < y0 && y < y1 && y < y2 && y < y3)
	        ) {
	            return 0;
	        }
	        var nRoots = curve.cubicRootAt(y0, y1, y2, y3, y, roots);
	        if (nRoots === 0) {
	            return 0;
	        }
	        else {
	            var w = 0;
	            var nExtrema = -1;
	            var y0_, y1_;
	            for (var i = 0; i < nRoots; i++) {
	                var t = roots[i];
	
	                // Avoid winding error when intersection point is the connect point of two line of polygon
	                var unit = (t === 0 || t === 1) ? 0.5 : 1;
	
	                var x_ = curve.cubicAt(x0, x1, x2, x3, t);
	                if (x_ < x) { // Quick reject
	                    continue;
	                }
	                if (nExtrema < 0) {
	                    nExtrema = curve.cubicExtrema(y0, y1, y2, y3, extrema);
	                    if (extrema[1] < extrema[0] && nExtrema > 1) {
	                        swapExtrema();
	                    }
	                    y0_ = curve.cubicAt(y0, y1, y2, y3, extrema[0]);
	                    if (nExtrema > 1) {
	                        y1_ = curve.cubicAt(y0, y1, y2, y3, extrema[1]);
	                    }
	                }
	                if (nExtrema == 2) {
	                    // 分成三段单调函数
	                    if (t < extrema[0]) {
	                        w += y0_ < y0 ? unit : -unit;
	                    }
	                    else if (t < extrema[1]) {
	                        w += y1_ < y0_ ? unit : -unit;
	                    }
	                    else {
	                        w += y3 < y1_ ? unit : -unit;
	                    }
	                }
	                else {
	                    // 分成两段单调函数
	                    if (t < extrema[0]) {
	                        w += y0_ < y0 ? unit : -unit;
	                    }
	                    else {
	                        w += y3 < y0_ ? unit : -unit;
	                    }
	                }
	            }
	            return w;
	        }
	    }
	
	    function windingQuadratic(x0, y0, x1, y1, x2, y2, x, y) {
	        // Quick reject
	        if (
	            (y > y0 && y > y1 && y > y2)
	            || (y < y0 && y < y1 && y < y2)
	        ) {
	            return 0;
	        }
	        var nRoots = curve.quadraticRootAt(y0, y1, y2, y, roots);
	        if (nRoots === 0) {
	            return 0;
	        }
	        else {
	            var t = curve.quadraticExtremum(y0, y1, y2);
	            if (t >= 0 && t <= 1) {
	                var w = 0;
	                var y_ = curve.quadraticAt(y0, y1, y2, t);
	                for (var i = 0; i < nRoots; i++) {
	                    // Remove one endpoint.
	                    var unit = (roots[i] === 0 || roots[i] === 1) ? 0.5 : 1;
	
	                    var x_ = curve.quadraticAt(x0, x1, x2, roots[i]);
	                    if (x_ < x) {   // Quick reject
	                        continue;
	                    }
	                    if (roots[i] < t) {
	                        w += y_ < y0 ? unit : -unit;
	                    }
	                    else {
	                        w += y2 < y_ ? unit : -unit;
	                    }
	                }
	                return w;
	            }
	            else {
	                // Remove one endpoint.
	                var unit = (roots[0] === 0 || roots[0] === 1) ? 0.5 : 1;
	
	                var x_ = curve.quadraticAt(x0, x1, x2, roots[0]);
	                if (x_ < x) {   // Quick reject
	                    return 0;
	                }
	                return y2 < y0 ? unit : -unit;
	            }
	        }
	    }
	
	    // TODO
	    // Arc 旋转
	    function windingArc(
	        cx, cy, r, startAngle, endAngle, anticlockwise, x, y
	    ) {
	        y -= cy;
	        if (y > r || y < -r) {
	            return 0;
	        }
	        var tmp = Math.sqrt(r * r - y * y);
	        roots[0] = -tmp;
	        roots[1] = tmp;
	
	        var diff = Math.abs(startAngle - endAngle);
	        if (diff < 1e-4) {
	            return 0;
	        }
	        if (diff % PI2 < 1e-4) {
	            // Is a circle
	            startAngle = 0;
	            endAngle = PI2;
	            var dir = anticlockwise ? 1 : -1;
	            if (x >= roots[0] + cx && x <= roots[1] + cx) {
	                return dir;
	            } else {
	                return 0;
	            }
	        }
	
	        if (anticlockwise) {
	            var tmp = startAngle;
	            startAngle = normalizeRadian(endAngle);
	            endAngle = normalizeRadian(tmp);
	        }
	        else {
	            startAngle = normalizeRadian(startAngle);
	            endAngle = normalizeRadian(endAngle);
	        }
	        if (startAngle > endAngle) {
	            endAngle += PI2;
	        }
	
	        var w = 0;
	        for (var i = 0; i < 2; i++) {
	            var x_ = roots[i];
	            if (x_ + cx > x) {
	                var angle = Math.atan2(y, x_);
	                var dir = anticlockwise ? 1 : -1;
	                if (angle < 0) {
	                    angle = PI2 + angle;
	                }
	                if (
	                    (angle >= startAngle && angle <= endAngle)
	                    || (angle + PI2 >= startAngle && angle + PI2 <= endAngle)
	                ) {
	                    if (angle > Math.PI / 2 && angle < Math.PI * 1.5) {
	                        dir = -dir;
	                    }
	                    w += dir;
	                }
	            }
	        }
	        return w;
	    }
	
	    function containPath(data, lineWidth, isStroke, x, y) {
	        var w = 0;
	        var xi = 0;
	        var yi = 0;
	        var x0 = 0;
	        var y0 = 0;
	
	        for (var i = 0; i < data.length;) {
	            var cmd = data[i++];
	            // Begin a new subpath
	            if (cmd === CMD.M && i > 1) {
	                // Close previous subpath
	                if (!isStroke) {
	                    w += windingLine(xi, yi, x0, y0, x, y);
	                }
	                // 如果被任何一个 subpath 包含
	                // if (w !== 0) {
	                //     return true;
	                // }
	            }
	
	            if (i == 1) {
	                // 如果第一个命令是 L, C, Q
	                // 则 previous point 同绘制命令的第一个 point
	                //
	                // 第一个命令为 Arc 的情况下会在后面特殊处理
	                xi = data[i];
	                yi = data[i + 1];
	
	                x0 = xi;
	                y0 = yi;
	            }
	
	            switch (cmd) {
	                case CMD.M:
	                    // moveTo 命令重新创建一个新的 subpath, 并且更新新的起点
	                    // 在 closePath 的时候使用
	                    x0 = data[i++];
	                    y0 = data[i++];
	                    xi = x0;
	                    yi = y0;
	                    break;
	                case CMD.L:
	                    if (isStroke) {
	                        if (containStroke(xi, yi, data[i], data[i + 1], lineWidth, x, y)) {
	                            return true;
	                        }
	                    }
	                    else {
	                        // NOTE 在第一个命令为 L, C, Q 的时候会计算出 NaN
	                        w += windingLine(xi, yi, data[i], data[i + 1], x, y) || 0;
	                    }
	                    xi = data[i++];
	                    yi = data[i++];
	                    break;
	                case CMD.C:
	                    if (isStroke) {
	                        if (cubic.containStroke(xi, yi,
	                            data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1],
	                            lineWidth, x, y
	                        )) {
	                            return true;
	                        }
	                    }
	                    else {
	                        w += windingCubic(
	                            xi, yi,
	                            data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1],
	                            x, y
	                        ) || 0;
	                    }
	                    xi = data[i++];
	                    yi = data[i++];
	                    break;
	                case CMD.Q:
	                    if (isStroke) {
	                        if (quadratic.containStroke(xi, yi,
	                            data[i++], data[i++], data[i], data[i + 1],
	                            lineWidth, x, y
	                        )) {
	                            return true;
	                        }
	                    }
	                    else {
	                        w += windingQuadratic(
	                            xi, yi,
	                            data[i++], data[i++], data[i], data[i + 1],
	                            x, y
	                        ) || 0;
	                    }
	                    xi = data[i++];
	                    yi = data[i++];
	                    break;
	                case CMD.A:
	                    // TODO Arc 判断的开销比较大
	                    var cx = data[i++];
	                    var cy = data[i++];
	                    var rx = data[i++];
	                    var ry = data[i++];
	                    var theta = data[i++];
	                    var dTheta = data[i++];
	                    // TODO Arc 旋转
	                    var psi = data[i++];
	                    var anticlockwise = 1 - data[i++];
	                    var x1 = Math.cos(theta) * rx + cx;
	                    var y1 = Math.sin(theta) * ry + cy;
	                    // 不是直接使用 arc 命令
	                    if (i > 1) {
	                        w += windingLine(xi, yi, x1, y1, x, y);
	                    }
	                    else {
	                        // 第一个命令起点还未定义
	                        x0 = x1;
	                        y0 = y1;
	                    }
	                    // zr 使用scale来模拟椭圆, 这里也对x做一定的缩放
	                    var _x = (x - cx) * ry / rx + cx;
	                    if (isStroke) {
	                        if (arc.containStroke(
	                            cx, cy, ry, theta, theta + dTheta, anticlockwise,
	                            lineWidth, _x, y
	                        )) {
	                            return true;
	                        }
	                    }
	                    else {
	                        w += windingArc(
	                            cx, cy, ry, theta, theta + dTheta, anticlockwise,
	                            _x, y
	                        );
	                    }
	                    xi = Math.cos(theta + dTheta) * rx + cx;
	                    yi = Math.sin(theta + dTheta) * ry + cy;
	                    break;
	                case CMD.R:
	                    x0 = xi = data[i++];
	                    y0 = yi = data[i++];
	                    var width = data[i++];
	                    var height = data[i++];
	                    var x1 = x0 + width;
	                    var y1 = y0 + height;
	                    if (isStroke) {
	                        if (containStroke(x0, y0, x1, y0, lineWidth, x, y)
	                          || containStroke(x1, y0, x1, y1, lineWidth, x, y)
	                          || containStroke(x1, y1, x0, y1, lineWidth, x, y)
	                          || containStroke(x0, y1, x0, y0, lineWidth, x, y)
	                        ) {
	                            return true;
	                        }
	                    }
	                    else {
	                        // FIXME Clockwise ?
	                        w += windingLine(x1, y0, x1, y1, x, y);
	                        w += windingLine(x0, y1, x0, y0, x, y);
	                    }
	                    break;
	                case CMD.Z:
	                    if (isStroke) {
	                        if (containStroke(
	                            xi, yi, x0, y0, lineWidth, x, y
	                        )) {
	                            return true;
	                        }
	                    }
	                    else {
	                        // Close a subpath
	                        w += windingLine(xi, yi, x0, y0, x, y);
	                        // 如果被任何一个 subpath 包含
	                        // FIXME subpaths may overlap
	                        // if (w !== 0) {
	                        //     return true;
	                        // }
	                    }
	                    xi = x0;
	                    yi = y0;
	                    break;
	            }
	        }
	        if (!isStroke && !isAroundEqual(yi, y0)) {
	            w += windingLine(xi, yi, x0, y0, x, y) || 0;
	        }
	        return w !== 0;
	    }
	
	    module.exports = {
	        contain: function (pathData, x, y) {
	            return containPath(pathData, 0, false, x, y);
	        },
	
	        containStroke: function (pathData, lineWidth, x, y) {
	            return containPath(pathData, lineWidth, true, x, y);
	        }
	    };


/***/ },
/* 29 */
/***/ function(module, exports) {

	
	    module.exports = {
	        /**
	         * 线段包含判断
	         * @param  {number}  x0
	         * @param  {number}  y0
	         * @param  {number}  x1
	         * @param  {number}  y1
	         * @param  {number}  lineWidth
	         * @param  {number}  x
	         * @param  {number}  y
	         * @return {boolean}
	         */
	        containStroke: function (x0, y0, x1, y1, lineWidth, x, y) {
	            if (lineWidth === 0) {
	                return false;
	            }
	            var _l = lineWidth;
	            var _a = 0;
	            var _b = x0;
	            // Quick reject
	            if (
	                (y > y0 + _l && y > y1 + _l)
	                || (y < y0 - _l && y < y1 - _l)
	                || (x > x0 + _l && x > x1 + _l)
	                || (x < x0 - _l && x < x1 - _l)
	            ) {
	                return false;
	            }
	
	            if (x0 !== x1) {
	                _a = (y0 - y1) / (x0 - x1);
	                _b = (x0 * y1 - x1 * y0) / (x0 - x1) ;
	            }
	            else {
	                return Math.abs(x - x0) <= _l / 2;
	            }
	            var tmp = _a * x - y + _b;
	            var _s = tmp * tmp / (_a * _a + 1);
	            return _s <= _l / 2 * _l / 2;
	        }
	    };


/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

	
	
	    var curve = __webpack_require__(26);
	
	    module.exports = {
	        /**
	         * 三次贝塞尔曲线描边包含判断
	         * @param  {number}  x0
	         * @param  {number}  y0
	         * @param  {number}  x1
	         * @param  {number}  y1
	         * @param  {number}  x2
	         * @param  {number}  y2
	         * @param  {number}  x3
	         * @param  {number}  y3
	         * @param  {number}  lineWidth
	         * @param  {number}  x
	         * @param  {number}  y
	         * @return {boolean}
	         */
	        containStroke: function(x0, y0, x1, y1, x2, y2, x3, y3, lineWidth, x, y) {
	            if (lineWidth === 0) {
	                return false;
	            }
	            var _l = lineWidth;
	            // Quick reject
	            if (
	                (y > y0 + _l && y > y1 + _l && y > y2 + _l && y > y3 + _l)
	                || (y < y0 - _l && y < y1 - _l && y < y2 - _l && y < y3 - _l)
	                || (x > x0 + _l && x > x1 + _l && x > x2 + _l && x > x3 + _l)
	                || (x < x0 - _l && x < x1 - _l && x < x2 - _l && x < x3 - _l)
	            ) {
	                return false;
	            }
	            var d = curve.cubicProjectPoint(
	                x0, y0, x1, y1, x2, y2, x3, y3,
	                x, y, null
	            );
	            return d <= _l / 2;
	        }
	    };


/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	
	
	    var curve = __webpack_require__(26);
	
	    module.exports = {
	        /**
	         * 二次贝塞尔曲线描边包含判断
	         * @param  {number}  x0
	         * @param  {number}  y0
	         * @param  {number}  x1
	         * @param  {number}  y1
	         * @param  {number}  x2
	         * @param  {number}  y2
	         * @param  {number}  lineWidth
	         * @param  {number}  x
	         * @param  {number}  y
	         * @return {boolean}
	         */
	        containStroke: function (x0, y0, x1, y1, x2, y2, lineWidth, x, y) {
	            if (lineWidth === 0) {
	                return false;
	            }
	            var _l = lineWidth;
	            // Quick reject
	            if (
	                (y > y0 + _l && y > y1 + _l && y > y2 + _l)
	                || (y < y0 - _l && y < y1 - _l && y < y2 - _l)
	                || (x > x0 + _l && x > x1 + _l && x > x2 + _l)
	                || (x < x0 - _l && x < x1 - _l && x < x2 - _l)
	            ) {
	                return false;
	            }
	            var d = curve.quadraticProjectPoint(
	                x0, y0, x1, y1, x2, y2,
	                x, y, null
	            );
	            return d <= _l / 2;
	        }
	    };


/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

	
	
	    var normalizeRadian = __webpack_require__(33).normalizeRadian;
	    var PI2 = Math.PI * 2;
	
	    module.exports = {
	        /**
	         * 圆弧描边包含判断
	         * @param  {number}  cx
	         * @param  {number}  cy
	         * @param  {number}  r
	         * @param  {number}  startAngle
	         * @param  {number}  endAngle
	         * @param  {boolean}  anticlockwise
	         * @param  {number} lineWidth
	         * @param  {number}  x
	         * @param  {number}  y
	         * @return {Boolean}
	         */
	        containStroke: function (
	            cx, cy, r, startAngle, endAngle, anticlockwise,
	            lineWidth, x, y
	        ) {
	
	            if (lineWidth === 0) {
	                return false;
	            }
	            var _l = lineWidth;
	
	            x -= cx;
	            y -= cy;
	            var d = Math.sqrt(x * x + y * y);
	
	            if ((d - _l > r) || (d + _l < r)) {
	                return false;
	            }
	            if (Math.abs(startAngle - endAngle) % PI2 < 1e-4) {
	                // Is a circle
	                return true;
	            }
	            if (anticlockwise) {
	                var tmp = startAngle;
	                startAngle = normalizeRadian(endAngle);
	                endAngle = normalizeRadian(tmp);
	            } else {
	                startAngle = normalizeRadian(startAngle);
	                endAngle = normalizeRadian(endAngle);
	            }
	            if (startAngle > endAngle) {
	                endAngle += PI2;
	            }
	
	            var angle = Math.atan2(y, x);
	            if (angle < 0) {
	                angle += PI2;
	            }
	            return (angle >= startAngle && angle <= endAngle)
	                || (angle + PI2 >= startAngle && angle + PI2 <= endAngle);
	        }
	    };


/***/ },
/* 33 */
/***/ function(module, exports) {

	
	
	    var PI2 = Math.PI * 2;
	    module.exports = {
	        normalizeRadian: function(angle) {
	            angle %= PI2;
	            if (angle < 0) {
	                angle += PI2;
	            }
	            return angle;
	        }
	    };


/***/ },
/* 34 */
/***/ function(module, exports) {

	
	    module.exports = function windingLine(x0, y0, x1, y1, x, y) {
	        if ((y > y0 && y > y1) || (y < y0 && y < y1)) {
	            return 0;
	        }
	        // Ignore horizontal line
	        if (y1 === y0) {
	            return 0;
	        }
	        var dir = y1 < y0 ? 1 : -1;
	        var t = (y - y0) / (y1 - y0);
	
	        // Avoid winding error when intersection point is the connect point of two line of polygon
	        if (t === 1 || t === 0) {
	            dir = y1 < y0 ? 0.5 : -0.5;
	        }
	
	        var x_ = t * (x1 - x0) + x0;
	
	        return x_ > x ? dir : 0;
	    };


/***/ },
/* 35 */
/***/ function(module, exports) {

	
	
	    var Pattern = function (image, repeat) {
	        this.image = image;
	        this.repeat = repeat;
	
	        // Can be cloned
	        this.type = 'pattern';
	    };
	
	    Pattern.prototype.getCanvasPattern = function (ctx) {
	
	        return this._canvasPattern
	            || (this._canvasPattern = ctx.createPattern(this.image, this.repeat));
	    };
	
	    module.exports = Pattern;


/***/ },
/* 36 */
/***/ function(module, exports, __webpack_require__) {

	
	
	    var CMD = __webpack_require__(25).CMD;
	    var vec2 = __webpack_require__(14);
	    var v2ApplyTransform = vec2.applyTransform;
	
	    var points = [[], [], []];
	    var mathSqrt = Math.sqrt;
	    var mathAtan2 = Math.atan2;
	    function transformPath(path, m) {
	        var data = path.data;
	        var cmd;
	        var nPoint;
	        var i;
	        var j;
	        var k;
	        var p;
	
	        var M = CMD.M;
	        var C = CMD.C;
	        var L = CMD.L;
	        var R = CMD.R;
	        var A = CMD.A;
	        var Q = CMD.Q;
	
	        for (i = 0, j = 0; i < data.length;) {
	            cmd = data[i++];
	            j = i;
	            nPoint = 0;
	
	            switch (cmd) {
	                case M:
	                    nPoint = 1;
	                    break;
	                case L:
	                    nPoint = 1;
	                    break;
	                case C:
	                    nPoint = 3;
	                    break;
	                case Q:
	                    nPoint = 2;
	                    break;
	                case A:
	                    var x = m[4];
	                    var y = m[5];
	                    var sx = mathSqrt(m[0] * m[0] + m[1] * m[1]);
	                    var sy = mathSqrt(m[2] * m[2] + m[3] * m[3]);
	                    var angle = mathAtan2(-m[1] / sy, m[0] / sx);
	                    // cx
	                    data[i++] += x;
	                    // cy
	                    data[i++] += y;
	                    // Scale rx and ry
	                    // FIXME Assume psi is 0 here
	                    data[i++] *= sx;
	                    data[i++] *= sy;
	
	                    // Start angle
	                    data[i++] += angle;
	                    // end angle
	                    data[i++] += angle;
	                    // FIXME psi
	                    i += 2;
	                    j = i;
	                    break;
	                case R:
	                    // x0, y0
	                    p[0] = data[i++];
	                    p[1] = data[i++];
	                    v2ApplyTransform(p, p, m);
	                    data[j++] = p[0];
	                    data[j++] = p[1];
	                    // x1, y1
	                    p[0] += data[i++];
	                    p[1] += data[i++];
	                    v2ApplyTransform(p, p, m);
	                    data[j++] = p[0];
	                    data[j++] = p[1];
	            }
	
	            for (k = 0; k < nPoint; k++) {
	                var p = points[k];
	                p[0] = data[i++];
	                p[1] = data[i++];
	
	                v2ApplyTransform(p, p, m);
	                // Write back
	                data[j++] = p[0];
	                data[j++] = p[1];
	            }
	        }
	    }
	
	    module.exports = transformPath;


/***/ },
/* 37 */
/***/ function(module, exports) {

	
	
	    /**
	     * @param {Array.<Object>} colorStops
	     */
	    var Gradient = function (colorStops) {
	
	        this.colorStops = colorStops || [];
	    };
	
	    Gradient.prototype = {
	
	        constructor: Gradient,
	
	        addColorStop: function (offset, color) {
	            this.colorStops.push({
	
	                offset: offset,
	
	                color: color
	            });
	        }
	    };
	
	    module.exports = Gradient;


/***/ },
/* 38 */
/***/ function(module, exports) {

	// TODO Draggable for group
	// FIXME Draggable on element which has parent rotation or scale
	
	    function Draggable() {
	
	        this.on('mousedown', this._dragStart, this);
	        this.on('mousemove', this._drag, this);
	        this.on('mouseup', this._dragEnd, this);
	        this.on('globalout', this._dragEnd, this);
	        // this._dropTarget = null;
	        // this._draggingTarget = null;
	
	        // this._x = 0;
	        // this._y = 0;
	    }
	
	    Draggable.prototype = {
	
	        constructor: Draggable,
	
	        _dragStart: function (e) {
	            var draggingTarget = e.target;
	            if (draggingTarget && draggingTarget.draggable) {
	                this._draggingTarget = draggingTarget;
	                draggingTarget.dragging = true;
	                this._x = e.offsetX;
	                this._y = e.offsetY;
	
	                this.dispatchToElement(draggingTarget, 'dragstart', e.event);
	            }
	        },
	
	        _drag: function (e) {
	            var draggingTarget = this._draggingTarget;
	            if (draggingTarget) {
	
	                var x = e.offsetX;
	                var y = e.offsetY;
	
	                var dx = x - this._x;
	                var dy = y - this._y;
	                this._x = x;
	                this._y = y;
	
	                draggingTarget.drift(dx, dy, e);
	                this.dispatchToElement(draggingTarget, 'drag', e.event);
	
	                var dropTarget = this.findHover(x, y, draggingTarget);
	                var lastDropTarget = this._dropTarget;
	                this._dropTarget = dropTarget;
	
	                if (draggingTarget !== dropTarget) {
	                    if (lastDropTarget && dropTarget !== lastDropTarget) {
	                        this.dispatchToElement(lastDropTarget, 'dragleave', e.event);
	                    }
	                    if (dropTarget && dropTarget !== lastDropTarget) {
	                        this.dispatchToElement(dropTarget, 'dragenter', e.event);
	                    }
	                }
	            }
	        },
	
	        _dragEnd: function (e) {
	            var draggingTarget = this._draggingTarget;
	
	            if (draggingTarget) {
	                draggingTarget.dragging = false;
	            }
	
	            this.dispatchToElement(draggingTarget, 'dragend', e.event);
	
	            if (this._dropTarget) {
	                this.dispatchToElement(this._dropTarget, 'drop', e.event);
	            }
	
	            this._draggingTarget = null;
	            this._dropTarget = null;
	        }
	
	    };
	
	    module.exports = Draggable;


/***/ },
/* 39 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Group是一个容器，可以插入子节点，Group的变换也会被应用到子节点上
	 * @module zrender/graphic/Group
	 * @example
	 *     var Group = require('zrender/lib/container/Group');
	 *     var Circle = require('zrender/lib/graphic/shape/Circle');
	 *     var g = new Group();
	 *     g.position[0] = 100;
	 *     g.position[1] = 100;
	 *     g.add(new Circle({
	 *         style: {
	 *             x: 100,
	 *             y: 100,
	 *             r: 20,
	 *         }
	 *     }));
	 *     zr.add(g);
	 */
	
	
	    var zrUtil = __webpack_require__(4);
	    var Element = __webpack_require__(9);
	    var BoundingRect = __webpack_require__(24);
	
	    /**
	     * @alias module:zrender/graphic/Group
	     * @constructor
	     * @extends module:zrender/mixin/Transformable
	     * @extends module:zrender/mixin/Eventful
	     */
	    var Group = function (opts) {
	
	        opts = opts || {};
	
	        Element.call(this, opts);
	
	        for (var key in opts) {
	            this[key] = opts[key];
	        }
	
	        this._children = [];
	
	        this.__storage = null;
	
	        this.__dirty = true;
	    };
	
	    Group.prototype = {
	
	        constructor: Group,
	
	        isGroup: true,
	
	        /**
	         * @type {string}
	         */
	        type: 'group',
	
	        /**
	         * 所有子孙元素是否响应鼠标事件
	         * @name module:/zrender/container/Group#silent
	         * @type {boolean}
	         * @default false
	         */
	        silent: false,
	
	        /**
	         * @return {Array.<module:zrender/Element>}
	         */
	        children: function () {
	            return this._children.slice();
	        },
	
	        /**
	         * 获取指定 index 的儿子节点
	         * @param  {number} idx
	         * @return {module:zrender/Element}
	         */
	        childAt: function (idx) {
	            return this._children[idx];
	        },
	
	        /**
	         * 获取指定名字的儿子节点
	         * @param  {string} name
	         * @return {module:zrender/Element}
	         */
	        childOfName: function (name) {
	            var children = this._children;
	            for (var i = 0; i < children.length; i++) {
	                if (children[i].name === name) {
	                    return children[i];
	                }
	             }
	        },
	
	        /**
	         * @return {number}
	         */
	        childCount: function () {
	            return this._children.length;
	        },
	
	        /**
	         * 添加子节点到最后
	         * @param {module:zrender/Element} child
	         */
	        add: function (child) {
	            if (child && child !== this && child.parent !== this) {
	
	                this._children.push(child);
	
	                this._doAdd(child);
	            }
	
	            return this;
	        },
	
	        /**
	         * 添加子节点在 nextSibling 之前
	         * @param {module:zrender/Element} child
	         * @param {module:zrender/Element} nextSibling
	         */
	        addBefore: function (child, nextSibling) {
	            if (child && child !== this && child.parent !== this
	                && nextSibling && nextSibling.parent === this) {
	
	                var children = this._children;
	                var idx = children.indexOf(nextSibling);
	
	                if (idx >= 0) {
	                    children.splice(idx, 0, child);
	                    this._doAdd(child);
	                }
	            }
	
	            return this;
	        },
	
	        _doAdd: function (child) {
	            if (child.parent) {
	                child.parent.remove(child);
	            }
	
	            child.parent = this;
	
	            var storage = this.__storage;
	            var zr = this.__zr;
	            if (storage && storage !== child.__storage) {
	
	                storage.addToMap(child);
	
	                if (child instanceof Group) {
	                    child.addChildrenToStorage(storage);
	                }
	            }
	
	            zr && zr.refresh();
	        },
	
	        /**
	         * 移除子节点
	         * @param {module:zrender/Element} child
	         */
	        remove: function (child) {
	            var zr = this.__zr;
	            var storage = this.__storage;
	            var children = this._children;
	
	            var idx = zrUtil.indexOf(children, child);
	            if (idx < 0) {
	                return this;
	            }
	            children.splice(idx, 1);
	
	            child.parent = null;
	
	            if (storage) {
	
	                storage.delFromMap(child.id);
	
	                if (child instanceof Group) {
	                    child.delChildrenFromStorage(storage);
	                }
	            }
	
	            zr && zr.refresh();
	
	            return this;
	        },
	
	        /**
	         * 移除所有子节点
	         */
	        removeAll: function () {
	            var children = this._children;
	            var storage = this.__storage;
	            var child;
	            var i;
	            for (i = 0; i < children.length; i++) {
	                child = children[i];
	                if (storage) {
	                    storage.delFromMap(child.id);
	                    if (child instanceof Group) {
	                        child.delChildrenFromStorage(storage);
	                    }
	                }
	                child.parent = null;
	            }
	            children.length = 0;
	
	            return this;
	        },
	
	        /**
	         * 遍历所有子节点
	         * @param  {Function} cb
	         * @param  {}   context
	         */
	        eachChild: function (cb, context) {
	            var children = this._children;
	            for (var i = 0; i < children.length; i++) {
	                var child = children[i];
	                cb.call(context, child, i);
	            }
	            return this;
	        },
	
	        /**
	         * 深度优先遍历所有子孙节点
	         * @param  {Function} cb
	         * @param  {}   context
	         */
	        traverse: function (cb, context) {
	            for (var i = 0; i < this._children.length; i++) {
	                var child = this._children[i];
	                cb.call(context, child);
	
	                if (child.type === 'group') {
	                    child.traverse(cb, context);
	                }
	            }
	            return this;
	        },
	
	        addChildrenToStorage: function (storage) {
	            for (var i = 0; i < this._children.length; i++) {
	                var child = this._children[i];
	                storage.addToMap(child);
	                if (child instanceof Group) {
	                    child.addChildrenToStorage(storage);
	                }
	            }
	        },
	
	        delChildrenFromStorage: function (storage) {
	            for (var i = 0; i < this._children.length; i++) {
	                var child = this._children[i];
	                storage.delFromMap(child.id);
	                if (child instanceof Group) {
	                    child.delChildrenFromStorage(storage);
	                }
	            }
	        },
	
	        dirty: function () {
	            this.__dirty = true;
	            this.__zr && this.__zr.refresh();
	            return this;
	        },
	
	        /**
	         * @return {module:zrender/core/BoundingRect}
	         */
	        getBoundingRect: function (includeChildren) {
	            // TODO Caching
	            // TODO Transform
	            var rect = null;
	            var tmpRect = new BoundingRect(0, 0, 0, 0);
	            var children = includeChildren || this._children;
	            var tmpMat = [];
	
	            for (var i = 0; i < children.length; i++) {
	                var child = children[i];
	                if (child.ignore || child.invisible) {
	                    continue;
	                }
	
	                var childRect = child.getBoundingRect();
	                var transform = child.getLocalTransform(tmpMat);
	                if (transform) {
	                    tmpRect.copy(childRect);
	                    tmpRect.applyTransform(transform);
	                    rect = rect || tmpRect.clone();
	                    rect.union(tmpRect);
	                }
	                else {
	                    rect = rect || childRect.clone();
	                    rect.union(childRect);
	                }
	            }
	            return rect || tmpRect;
	        }
	    };
	
	    zrUtil.inherits(Group, Element);
	
	    module.exports = Group;


/***/ },
/* 40 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Image element
	 * @module zrender/graphic/Image
	 */
	
	
	
	    var Displayable = __webpack_require__(7);
	    var BoundingRect = __webpack_require__(24);
	    var zrUtil = __webpack_require__(4);
	
	    var LRU = __webpack_require__(41);
	    var globalImageCache = new LRU(50);
	    /**
	     * @alias zrender/graphic/Image
	     * @extends module:zrender/graphic/Displayable
	     * @constructor
	     * @param {Object} opts
	     */
	    function ZImage(opts) {
	        Displayable.call(this, opts);
	    }
	
	    ZImage.prototype = {
	
	        constructor: ZImage,
	
	        type: 'image',
	
	        brush: function (ctx, prevEl) {
	            var style = this.style;
	            var src = style.image;
	            var image;
	
	            // Must bind each time
	            style.bind(ctx, this, prevEl);
	            // style.image is a url string
	            if (typeof src === 'string') {
	                image = this._image;
	            }
	            // style.image is an HTMLImageElement or HTMLCanvasElement or Canvas
	            else {
	                image = src;
	            }
	            // FIXME Case create many images with src
	            if (!image && src) {
	                // Try get from global image cache
	                var cachedImgObj = globalImageCache.get(src);
	                if (!cachedImgObj) {
	                    // Create a new image
	                    image = new Image();
	                    image.onload = function () {
	                        image.onload = null;
	                        for (var i = 0; i < cachedImgObj.pending.length; i++) {
	                            cachedImgObj.pending[i].dirty();
	                        }
	                    };
	                    cachedImgObj = {
	                        image: image,
	                        pending: [this]
	                    };
	                    image.src = src;
	                    globalImageCache.put(src, cachedImgObj);
	                    this._image = image;
	                    return;
	                }
	                else {
	                    image = cachedImgObj.image;
	                    this._image = image;
	                    // Image is not complete finish, add to pending list
	                    if (!image.width || !image.height) {
	                        cachedImgObj.pending.push(this);
	                        return;
	                    }
	                }
	            }
	
	            if (image) {
	                // 图片已经加载完成
	                // if (image.nodeName.toUpperCase() == 'IMG') {
	                //     if (!image.complete) {
	                //         return;
	                //     }
	                // }
	                // Else is canvas
	
	                var width = style.width || image.width;
	                var height = style.height || image.height;
	                var x = style.x || 0;
	                var y = style.y || 0;
	                // 图片加载失败
	                if (!image.width || !image.height) {
	                    return;
	                }
	
	                // 设置transform
	                this.setTransform(ctx);
	
	
	                if (style.sWidth && style.sHeight) {
	                    var sx = style.sx || 0;
	                    var sy = style.sy || 0;
	                    ctx.drawImage(
	                        image,
	                        sx, sy, style.sWidth, style.sHeight,
	                        x, y, width, height
	                    );
	                }
	                else if (style.sx && style.sy) {
	                    var sx = style.sx;
	                    var sy = style.sy;
	                    var sWidth = width - sx;
	                    var sHeight = height - sy;
	                    ctx.drawImage(
	                        image,
	                        sx, sy, sWidth, sHeight,
	                        x, y, width, height
	                    );
	                }
	                else {
	                    ctx.drawImage(image, x, y, width, height);
	                }
	
	                // 如果没设置宽和高的话自动根据图片宽高设置
	                if (style.width == null) {
	                    style.width = width;
	                }
	                if (style.height == null) {
	                    style.height = height;
	                }
	
	                this.restoreTransform(ctx);
	
	                // Draw rect text
	                if (style.text != null) {
	                    this.drawRectText(ctx, this.getBoundingRect());
	                }
	
	            }
	        },
	
	        getBoundingRect: function () {
	            var style = this.style;
	            if (! this._rect) {
	                this._rect = new BoundingRect(
	                    style.x || 0, style.y || 0, style.width || 0, style.height || 0
	                );
	            }
	            return this._rect;
	        }
	    };
	
	    zrUtil.inherits(ZImage, Displayable);
	
	    module.exports = ZImage;


/***/ },
/* 41 */
/***/ function(module, exports) {

	// Simple LRU cache use doubly linked list
	// @module zrender/core/LRU
	
	
	    /**
	     * Simple double linked list. Compared with array, it has O(1) remove operation.
	     * @constructor
	     */
	    var LinkedList = function() {
	
	        /**
	         * @type {module:zrender/core/LRU~Entry}
	         */
	        this.head = null;
	
	        /**
	         * @type {module:zrender/core/LRU~Entry}
	         */
	        this.tail = null;
	
	        this._len = 0;
	    };
	
	    var linkedListProto = LinkedList.prototype;
	    /**
	     * Insert a new value at the tail
	     * @param  {} val
	     * @return {module:zrender/core/LRU~Entry}
	     */
	    linkedListProto.insert = function(val) {
	        var entry = new Entry(val);
	        this.insertEntry(entry);
	        return entry;
	    };
	
	    /**
	     * Insert an entry at the tail
	     * @param  {module:zrender/core/LRU~Entry} entry
	     */
	    linkedListProto.insertEntry = function(entry) {
	        if (!this.head) {
	            this.head = this.tail = entry;
	        }
	        else {
	            this.tail.next = entry;
	            entry.prev = this.tail;
	            this.tail = entry;
	        }
	        this._len++;
	    };
	
	    /**
	     * Remove entry.
	     * @param  {module:zrender/core/LRU~Entry} entry
	     */
	    linkedListProto.remove = function(entry) {
	        var prev = entry.prev;
	        var next = entry.next;
	        if (prev) {
	            prev.next = next;
	        }
	        else {
	            // Is head
	            this.head = next;
	        }
	        if (next) {
	            next.prev = prev;
	        }
	        else {
	            // Is tail
	            this.tail = prev;
	        }
	        entry.next = entry.prev = null;
	        this._len--;
	    };
	
	    /**
	     * @return {number}
	     */
	    linkedListProto.len = function() {
	        return this._len;
	    };
	
	    /**
	     * @constructor
	     * @param {} val
	     */
	    var Entry = function(val) {
	        /**
	         * @type {}
	         */
	        this.value = val;
	
	        /**
	         * @type {module:zrender/core/LRU~Entry}
	         */
	        this.next;
	
	        /**
	         * @type {module:zrender/core/LRU~Entry}
	         */
	        this.prev;
	    };
	
	    /**
	     * LRU Cache
	     * @constructor
	     * @alias module:zrender/core/LRU
	     */
	    var LRU = function(maxSize) {
	
	        this._list = new LinkedList();
	
	        this._map = {};
	
	        this._maxSize = maxSize || 10;
	    };
	
	    var LRUProto = LRU.prototype;
	
	    /**
	     * @param  {string} key
	     * @param  {} value
	     */
	    LRUProto.put = function(key, value) {
	        var list = this._list;
	        var map = this._map;
	        if (map[key] == null) {
	            var len = list.len();
	            if (len >= this._maxSize && len > 0) {
	                // Remove the least recently used
	                var leastUsedEntry = list.head;
	                list.remove(leastUsedEntry);
	                delete map[leastUsedEntry.key];
	            }
	
	            var entry = list.insert(value);
	            entry.key = key;
	            map[key] = entry;
	        }
	    };
	
	    /**
	     * @param  {string} key
	     * @return {}
	     */
	    LRUProto.get = function(key) {
	        var entry = this._map[key];
	        var list = this._list;
	        if (entry != null) {
	            // Put the latest used entry in the tail
	            if (entry !== list.tail) {
	                list.remove(entry);
	                list.insertEntry(entry);
	            }
	
	            return entry.value;
	        }
	    };
	
	    /**
	     * Clear the cache
	     */
	    LRUProto.clear = function() {
	        this._list.clear();
	        this._map = {};
	    };
	
	    module.exports = LRU;


/***/ },
/* 42 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Text element
	 * @module zrender/graphic/Text
	 *
	 * TODO Wrapping
	 *
	 * Text not support gradient
	 */
	
	
	
	    var Displayable = __webpack_require__(7);
	    var zrUtil = __webpack_require__(4);
	    var textContain = __webpack_require__(23);
	
	    /**
	     * @alias zrender/graphic/Text
	     * @extends module:zrender/graphic/Displayable
	     * @constructor
	     * @param {Object} opts
	     */
	    var Text = function (opts) {
	        Displayable.call(this, opts);
	    };
	
	    Text.prototype = {
	
	        constructor: Text,
	
	        type: 'text',
	
	        brush: function (ctx, prevEl) {
	            var style = this.style;
	            var x = style.x || 0;
	            var y = style.y || 0;
	            // Convert to string
	            var text = style.text;
	
	            // Convert to string
	            text != null && (text += '');
	
	            // Always bind style
	            style.bind(ctx, this, prevEl);
	
	            if (text) {
	
	                this.setTransform(ctx);
	
	                var textBaseline;
	                var textAlign = style.textAlign;
	                var font = style.textFont || style.font;
	                if (style.textVerticalAlign) {
	                    var rect = textContain.getBoundingRect(
	                        text, font, style.textAlign, 'top'
	                    );
	                    // Ignore textBaseline
	                    textBaseline = 'middle';
	                    switch (style.textVerticalAlign) {
	                        case 'middle':
	                            y -= rect.height / 2 - rect.lineHeight / 2;
	                            break;
	                        case 'bottom':
	                            y -= rect.height - rect.lineHeight / 2;
	                            break;
	                        default:
	                            y += rect.lineHeight / 2;
	                    }
	                }
	                else {
	                    textBaseline = style.textBaseline;
	                }
	
	                // TODO Invalid font
	                ctx.font = font || '12px sans-serif';
	                ctx.textAlign = textAlign || 'left';
	                // Use canvas default left textAlign. Giving invalid value will cause state not change
	                if (ctx.textAlign !== textAlign) {
	                    ctx.textAlign = 'left';
	                }
	                ctx.textBaseline = textBaseline || 'alphabetic';
	                // Use canvas default alphabetic baseline
	                if (ctx.textBaseline !== textBaseline) {
	                    ctx.textBaseline = 'alphabetic';
	                }
	
	                var lineHeight = textContain.measureText('国', ctx.font).width;
	
	                var textLines = text.split('\n');
	                for (var i = 0; i < textLines.length; i++) {
	                    style.hasFill() && ctx.fillText(textLines[i], x, y);
	                    style.hasStroke() && ctx.strokeText(textLines[i], x, y);
	                    y += lineHeight;
	                }
	
	                this.restoreTransform(ctx);
	            }
	        },
	
	        getBoundingRect: function () {
	            if (!this._rect) {
	                var style = this.style;
	                var textVerticalAlign = style.textVerticalAlign;
	                var rect = textContain.getBoundingRect(
	                    style.text + '', style.textFont || style.font, style.textAlign,
	                    textVerticalAlign ? 'top' : style.textBaseline
	                );
	                switch (textVerticalAlign) {
	                    case 'middle':
	                        rect.y -= rect.height / 2;
	                        break;
	                    case 'bottom':
	                        rect.y -= rect.height;
	                        break;
	                }
	                rect.x += style.x || 0;
	                rect.y += style.y || 0;
	                this._rect = rect;
	            }
	            return this._rect;
	        }
	    };
	
	    zrUtil.inherits(Text, Displayable);
	
	    module.exports = Text;


/***/ },
/* 43 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	/**
	 * 圆形
	 * @module zrender/shape/Circle
	 */
	
	
	
	    module.exports = __webpack_require__(6).extend({
	
	        type: 'circle',
	
	        shape: {
	            cx: 0,
	            cy: 0,
	            r: 0
	        },
	
	
	        buildPath : function (ctx, shape, inBundle) {
	            // Better stroking in ShapeBundle
	            // Always do it may have performence issue ( fill may be 2x more cost)
	            if (inBundle) {
	                ctx.moveTo(shape.cx + shape.r, shape.cy);
	            }
	            // Better stroking in ShapeBundle
	            // ctx.moveTo(shape.cx + shape.r, shape.cy);
	            ctx.arc(shape.cx, shape.cy, shape.r, 0, Math.PI * 2, true);
	        }
	    });
	


/***/ },
/* 44 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * 扇形
	 * @module zrender/graphic/shape/Sector
	 */
	
	
	
	    module.exports = __webpack_require__(6).extend({
	
	        type: 'sector',
	
	        shape: {
	
	            cx: 0,
	
	            cy: 0,
	
	            r0: 0,
	
	            r: 0,
	
	            startAngle: 0,
	
	            endAngle: Math.PI * 2,
	
	            clockwise: true
	        },
	
	        buildPath: function (ctx, shape) {
	
	            var x = shape.cx;
	            var y = shape.cy;
	            var r0 = Math.max(shape.r0 || 0, 0);
	            var r = Math.max(shape.r, 0);
	            var startAngle = shape.startAngle;
	            var endAngle = shape.endAngle;
	            var clockwise = shape.clockwise;
	
	            var unitX = Math.cos(startAngle);
	            var unitY = Math.sin(startAngle);
	
	            ctx.moveTo(unitX * r0 + x, unitY * r0 + y);
	
	            ctx.lineTo(unitX * r + x, unitY * r + y);
	
	            ctx.arc(x, y, r, startAngle, endAngle, !clockwise);
	
	            ctx.lineTo(
	                Math.cos(endAngle) * r0 + x,
	                Math.sin(endAngle) * r0 + y
	            );
	
	            if (r0 !== 0) {
	                ctx.arc(x, y, r0, endAngle, startAngle, clockwise);
	            }
	
	            ctx.closePath();
	        }
	    });
	


/***/ },
/* 45 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * 圆环
	 * @module zrender/graphic/shape/Ring
	 */
	
	
	    module.exports = __webpack_require__(6).extend({
	
	        type: 'ring',
	
	        shape: {
	            cx: 0,
	            cy: 0,
	            r: 0,
	            r0: 0
	        },
	
	        buildPath: function (ctx, shape) {
	            var x = shape.cx;
	            var y = shape.cy;
	            var PI2 = Math.PI * 2;
	            ctx.moveTo(x + shape.r, y);
	            ctx.arc(x, y, shape.r, 0, PI2, false);
	            ctx.moveTo(x + shape.r0, y);
	            ctx.arc(x, y, shape.r0, 0, PI2, true);
	        }
	    });
	


/***/ },
/* 46 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * 多边形
	 * @module zrender/shape/Polygon
	 */
	
	
	    var polyHelper = __webpack_require__(47);
	
	    module.exports = __webpack_require__(6).extend({
	        
	        type: 'polygon',
	
	        shape: {
	            points: null,
	
	            smooth: false,
	
	            smoothConstraint: null
	        },
	
	        buildPath: function (ctx, shape) {
	            polyHelper.buildPath(ctx, shape, true);
	        }
	    });


/***/ },
/* 47 */
/***/ function(module, exports, __webpack_require__) {

	
	
	    var smoothSpline = __webpack_require__(48);
	    var smoothBezier = __webpack_require__(49);
	
	    module.exports = {
	        buildPath: function (ctx, shape, closePath) {
	            var points = shape.points;
	            var smooth = shape.smooth;
	            if (points && points.length >= 2) {
	                if (smooth && smooth !== 'spline') {
	                    var controlPoints = smoothBezier(
	                        points, smooth, closePath, shape.smoothConstraint
	                    );
	
	                    ctx.moveTo(points[0][0], points[0][1]);
	                    var len = points.length;
	                    for (var i = 0; i < (closePath ? len : len - 1); i++) {
	                        var cp1 = controlPoints[i * 2];
	                        var cp2 = controlPoints[i * 2 + 1];
	                        var p = points[(i + 1) % len];
	                        ctx.bezierCurveTo(
	                            cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]
	                        );
	                    }
	                }
	                else {
	                    if (smooth === 'spline') {
	                        points = smoothSpline(points, closePath);
	                    }
	
	                    ctx.moveTo(points[0][0], points[0][1]);
	                    for (var i = 1, l = points.length; i < l; i++) {
	                        ctx.lineTo(points[i][0], points[i][1]);
	                    }
	                }
	
	                closePath && ctx.closePath();
	            }
	        }
	    };


/***/ },
/* 48 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Catmull-Rom spline 插值折线
	 * @module zrender/shape/util/smoothSpline
	 * @author pissang (https://www.github.com/pissang)
	 *         Kener (@Kener-林峰, kener.linfeng@gmail.com)
	 *         errorrik (errorrik@gmail.com)
	 */
	
	    var vec2 = __webpack_require__(14);
	
	    /**
	     * @inner
	     */
	    function interpolate(p0, p1, p2, p3, t, t2, t3) {
	        var v0 = (p2 - p0) * 0.5;
	        var v1 = (p3 - p1) * 0.5;
	        return (2 * (p1 - p2) + v0 + v1) * t3
	                + (-3 * (p1 - p2) - 2 * v0 - v1) * t2
	                + v0 * t + p1;
	    }
	
	    /**
	     * @alias module:zrender/shape/util/smoothSpline
	     * @param {Array} points 线段顶点数组
	     * @param {boolean} isLoop
	     * @return {Array}
	     */
	    module.exports = function (points, isLoop) {
	        var len = points.length;
	        var ret = [];
	
	        var distance = 0;
	        for (var i = 1; i < len; i++) {
	            distance += vec2.distance(points[i - 1], points[i]);
	        }
	
	        var segs = distance / 2;
	        segs = segs < len ? len : segs;
	        for (var i = 0; i < segs; i++) {
	            var pos = i / (segs - 1) * (isLoop ? len : len - 1);
	            var idx = Math.floor(pos);
	
	            var w = pos - idx;
	
	            var p0;
	            var p1 = points[idx % len];
	            var p2;
	            var p3;
	            if (!isLoop) {
	                p0 = points[idx === 0 ? idx : idx - 1];
	                p2 = points[idx > len - 2 ? len - 1 : idx + 1];
	                p3 = points[idx > len - 3 ? len - 1 : idx + 2];
	            }
	            else {
	                p0 = points[(idx - 1 + len) % len];
	                p2 = points[(idx + 1) % len];
	                p3 = points[(idx + 2) % len];
	            }
	
	            var w2 = w * w;
	            var w3 = w * w2;
	
	            ret.push([
	                interpolate(p0[0], p1[0], p2[0], p3[0], w, w2, w3),
	                interpolate(p0[1], p1[1], p2[1], p3[1], w, w2, w3)
	            ]);
	        }
	        return ret;
	    };
	


/***/ },
/* 49 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * 贝塞尔平滑曲线
	 * @module zrender/shape/util/smoothBezier
	 * @author pissang (https://www.github.com/pissang)
	 *         Kener (@Kener-林峰, kener.linfeng@gmail.com)
	 *         errorrik (errorrik@gmail.com)
	 */
	
	
	    var vec2 = __webpack_require__(14);
	    var v2Min = vec2.min;
	    var v2Max = vec2.max;
	    var v2Scale = vec2.scale;
	    var v2Distance = vec2.distance;
	    var v2Add = vec2.add;
	
	    /**
	     * 贝塞尔平滑曲线
	     * @alias module:zrender/shape/util/smoothBezier
	     * @param {Array} points 线段顶点数组
	     * @param {number} smooth 平滑等级, 0-1
	     * @param {boolean} isLoop
	     * @param {Array} constraint 将计算出来的控制点约束在一个包围盒内
	     *                           比如 [[0, 0], [100, 100]], 这个包围盒会与
	     *                           整个折线的包围盒做一个并集用来约束控制点。
	     * @param {Array} 计算出来的控制点数组
	     */
	    module.exports = function (points, smooth, isLoop, constraint) {
	        var cps = [];
	
	        var v = [];
	        var v1 = [];
	        var v2 = [];
	        var prevPoint;
	        var nextPoint;
	
	        var min, max;
	        if (constraint) {
	            min = [Infinity, Infinity];
	            max = [-Infinity, -Infinity];
	            for (var i = 0, len = points.length; i < len; i++) {
	                v2Min(min, min, points[i]);
	                v2Max(max, max, points[i]);
	            }
	            // 与指定的包围盒做并集
	            v2Min(min, min, constraint[0]);
	            v2Max(max, max, constraint[1]);
	        }
	
	        for (var i = 0, len = points.length; i < len; i++) {
	            var point = points[i];
	
	            if (isLoop) {
	                prevPoint = points[i ? i - 1 : len - 1];
	                nextPoint = points[(i + 1) % len];
	            }
	            else {
	                if (i === 0 || i === len - 1) {
	                    cps.push(vec2.clone(points[i]));
	                    continue;
	                }
	                else {
	                    prevPoint = points[i - 1];
	                    nextPoint = points[i + 1];
	                }
	            }
	
	            vec2.sub(v, nextPoint, prevPoint);
	
	            // use degree to scale the handle length
	            v2Scale(v, v, smooth);
	
	            var d0 = v2Distance(point, prevPoint);
	            var d1 = v2Distance(point, nextPoint);
	            var sum = d0 + d1;
	            if (sum !== 0) {
	                d0 /= sum;
	                d1 /= sum;
	            }
	
	            v2Scale(v1, v, -d0);
	            v2Scale(v2, v, d1);
	            var cp0 = v2Add([], point, v1);
	            var cp1 = v2Add([], point, v2);
	            if (constraint) {
	                v2Max(cp0, cp0, min);
	                v2Min(cp0, cp0, max);
	                v2Max(cp1, cp1, min);
	                v2Min(cp1, cp1, max);
	            }
	            cps.push(cp0);
	            cps.push(cp1);
	        }
	
	        if (isLoop) {
	            cps.push(cps.shift());
	        }
	
	        return cps;
	    };
	


/***/ },
/* 50 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @module zrender/graphic/shape/Polyline
	 */
	
	
	    var polyHelper = __webpack_require__(47);
	
	    module.exports = __webpack_require__(6).extend({
	        
	        type: 'polyline',
	
	        shape: {
	            points: null,
	
	            smooth: false,
	
	            smoothConstraint: null
	        },
	
	        style: {
	            stroke: '#000',
	
	            fill: null
	        },
	
	        buildPath: function (ctx, shape) {
	            polyHelper.buildPath(ctx, shape, false);
	        }
	    });


/***/ },
/* 51 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * 矩形
	 * @module zrender/graphic/shape/Rect
	 */
	
	
	    var roundRectHelper = __webpack_require__(52);
	
	    module.exports = __webpack_require__(6).extend({
	
	        type: 'rect',
	
	        shape: {
	            // 左上、右上、右下、左下角的半径依次为r1、r2、r3、r4
	            // r缩写为1         相当于 [1, 1, 1, 1]
	            // r缩写为[1]       相当于 [1, 1, 1, 1]
	            // r缩写为[1, 2]    相当于 [1, 2, 1, 2]
	            // r缩写为[1, 2, 3] 相当于 [1, 2, 3, 2]
	            r: 0,
	
	            x: 0,
	            y: 0,
	            width: 0,
	            height: 0
	        },
	
	        buildPath: function (ctx, shape) {
	            var x = shape.x;
	            var y = shape.y;
	            var width = shape.width;
	            var height = shape.height;
	            if (!shape.r) {
	                ctx.rect(x, y, width, height);
	            }
	            else {
	                roundRectHelper.buildPath(ctx, shape);
	            }
	            ctx.closePath();
	            return;
	        }
	    });
	


/***/ },
/* 52 */
/***/ function(module, exports) {

	
	
	    module.exports = {
	        buildPath: function (ctx, shape) {
	            var x = shape.x;
	            var y = shape.y;
	            var width = shape.width;
	            var height = shape.height;
	            var r = shape.r;
	            var r1;
	            var r2;
	            var r3;
	            var r4;
	
	            // Convert width and height to positive for better borderRadius
	            if (width < 0) {
	                x = x + width;
	                width = -width;
	            }
	            if (height < 0) {
	                y = y + height;
	                height = -height;
	            }
	
	            if (typeof r === 'number') {
	                r1 = r2 = r3 = r4 = r;
	            }
	            else if (r instanceof Array) {
	                if (r.length === 1) {
	                    r1 = r2 = r3 = r4 = r[0];
	                }
	                else if (r.length === 2) {
	                    r1 = r3 = r[0];
	                    r2 = r4 = r[1];
	                }
	                else if (r.length === 3) {
	                    r1 = r[0];
	                    r2 = r4 = r[1];
	                    r3 = r[2];
	                }
	                else {
	                    r1 = r[0];
	                    r2 = r[1];
	                    r3 = r[2];
	                    r4 = r[3];
	                }
	            }
	            else {
	                r1 = r2 = r3 = r4 = 0;
	            }
	
	            var total;
	            if (r1 + r2 > width) {
	                total = r1 + r2;
	                r1 *= width / total;
	                r2 *= width / total;
	            }
	            if (r3 + r4 > width) {
	                total = r3 + r4;
	                r3 *= width / total;
	                r4 *= width / total;
	            }
	            if (r2 + r3 > height) {
	                total = r2 + r3;
	                r2 *= height / total;
	                r3 *= height / total;
	            }
	            if (r1 + r4 > height) {
	                total = r1 + r4;
	                r1 *= height / total;
	                r4 *= height / total;
	            }
	            ctx.moveTo(x + r1, y);
	            ctx.lineTo(x + width - r2, y);
	            r2 !== 0 && ctx.quadraticCurveTo(
	                x + width, y, x + width, y + r2
	            );
	            ctx.lineTo(x + width, y + height - r3);
	            r3 !== 0 && ctx.quadraticCurveTo(
	                x + width, y + height, x + width - r3, y + height
	            );
	            ctx.lineTo(x + r4, y + height);
	            r4 !== 0 && ctx.quadraticCurveTo(
	                x, y + height, x, y + height - r4
	            );
	            ctx.lineTo(x, y + r1);
	            r1 !== 0 && ctx.quadraticCurveTo(x, y, x + r1, y);
	        }
	    };


/***/ },
/* 53 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * 直线
	 * @module zrender/graphic/shape/Line
	 */
	
	    module.exports = __webpack_require__(6).extend({
	
	        type: 'line',
	
	        shape: {
	            // Start point
	            x1: 0,
	            y1: 0,
	            // End point
	            x2: 0,
	            y2: 0,
	
	            percent: 1
	        },
	
	        style: {
	            stroke: '#000',
	            fill: null
	        },
	
	        buildPath: function (ctx, shape) {
	            var x1 = shape.x1;
	            var y1 = shape.y1;
	            var x2 = shape.x2;
	            var y2 = shape.y2;
	            var percent = shape.percent;
	
	            if (percent === 0) {
	                return;
	            }
	
	            ctx.moveTo(x1, y1);
	
	            if (percent < 1) {
	                x2 = x1 * (1 - percent) + x2 * percent;
	                y2 = y1 * (1 - percent) + y2 * percent;
	            }
	            ctx.lineTo(x2, y2);
	        },
	
	        /**
	         * Get point at percent
	         * @param  {number} percent
	         * @return {Array.<number>}
	         */
	        pointAt: function (p) {
	            var shape = this.shape;
	            return [
	                shape.x1 * (1 - p) + shape.x2 * p,
	                shape.y1 * (1 - p) + shape.y2 * p
	            ];
	        }
	    });
	


/***/ },
/* 54 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	/**
	 * 贝塞尔曲线
	 * @module zrender/shape/BezierCurve
	 */
	
	
	    var curveTool = __webpack_require__(26);
	    var vec2 = __webpack_require__(14);
	    var quadraticSubdivide = curveTool.quadraticSubdivide;
	    var cubicSubdivide = curveTool.cubicSubdivide;
	    var quadraticAt = curveTool.quadraticAt;
	    var cubicAt = curveTool.cubicAt;
	    var quadraticDerivativeAt = curveTool.quadraticDerivativeAt;
	    var cubicDerivativeAt = curveTool.cubicDerivativeAt;
	
	    var out = [];
	
	    function someVectorAt(shape, t, isTangent) {
	        var cpx2 = shape.cpx2;
	        var cpy2 = shape.cpy2;
	        if (cpx2 === null || cpy2 === null) {
	            return [
	                (isTangent ? cubicDerivativeAt : cubicAt)(shape.x1, shape.cpx1, shape.cpx2, shape.x2, t),
	                (isTangent ? cubicDerivativeAt : cubicAt)(shape.y1, shape.cpy1, shape.cpy2, shape.y2, t)
	            ];
	        }
	        else {
	            return [
	                (isTangent ? quadraticDerivativeAt : quadraticAt)(shape.x1, shape.cpx1, shape.x2, t),
	                (isTangent ? quadraticDerivativeAt : quadraticAt)(shape.y1, shape.cpy1, shape.y2, t)
	            ];
	        }
	    }
	    module.exports = __webpack_require__(6).extend({
	
	        type: 'bezier-curve',
	
	        shape: {
	            x1: 0,
	            y1: 0,
	            x2: 0,
	            y2: 0,
	            cpx1: 0,
	            cpy1: 0,
	            // cpx2: 0,
	            // cpy2: 0
	
	            // Curve show percent, for animating
	            percent: 1
	        },
	
	        style: {
	            stroke: '#000',
	            fill: null
	        },
	
	        buildPath: function (ctx, shape) {
	            var x1 = shape.x1;
	            var y1 = shape.y1;
	            var x2 = shape.x2;
	            var y2 = shape.y2;
	            var cpx1 = shape.cpx1;
	            var cpy1 = shape.cpy1;
	            var cpx2 = shape.cpx2;
	            var cpy2 = shape.cpy2;
	            var percent = shape.percent;
	            if (percent === 0) {
	                return;
	            }
	
	            ctx.moveTo(x1, y1);
	
	            if (cpx2 == null || cpy2 == null) {
	                if (percent < 1) {
	                    quadraticSubdivide(
	                        x1, cpx1, x2, percent, out
	                    );
	                    cpx1 = out[1];
	                    x2 = out[2];
	                    quadraticSubdivide(
	                        y1, cpy1, y2, percent, out
	                    );
	                    cpy1 = out[1];
	                    y2 = out[2];
	                }
	
	                ctx.quadraticCurveTo(
	                    cpx1, cpy1,
	                    x2, y2
	                );
	            }
	            else {
	                if (percent < 1) {
	                    cubicSubdivide(
	                        x1, cpx1, cpx2, x2, percent, out
	                    );
	                    cpx1 = out[1];
	                    cpx2 = out[2];
	                    x2 = out[3];
	                    cubicSubdivide(
	                        y1, cpy1, cpy2, y2, percent, out
	                    );
	                    cpy1 = out[1];
	                    cpy2 = out[2];
	                    y2 = out[3];
	                }
	                ctx.bezierCurveTo(
	                    cpx1, cpy1,
	                    cpx2, cpy2,
	                    x2, y2
	                );
	            }
	        },
	
	        /**
	         * Get point at percent
	         * @param  {number} t
	         * @return {Array.<number>}
	         */
	        pointAt: function (t) {
	            return someVectorAt(this.shape, t, false);
	        },
	
	        /**
	         * Get tangent at percent
	         * @param  {number} t
	         * @return {Array.<number>}
	         */
	        tangentAt: function (t) {
	            var p = someVectorAt(this.shape, t, true);
	            return vec2.normalize(p, p);
	        }
	    });
	


/***/ },
/* 55 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * 圆弧
	 * @module zrender/graphic/shape/Arc
	 */
	 
	
	    module.exports = __webpack_require__(6).extend({
	
	        type: 'arc',
	
	        shape: {
	
	            cx: 0,
	
	            cy: 0,
	
	            r: 0,
	
	            startAngle: 0,
	
	            endAngle: Math.PI * 2,
	
	            clockwise: true
	        },
	
	        style: {
	
	            stroke: '#000',
	
	            fill: null
	        },
	
	        buildPath: function (ctx, shape) {
	
	            var x = shape.cx;
	            var y = shape.cy;
	            var r = Math.max(shape.r, 0);
	            var startAngle = shape.startAngle;
	            var endAngle = shape.endAngle;
	            var clockwise = shape.clockwise;
	
	            var unitX = Math.cos(startAngle);
	            var unitY = Math.sin(startAngle);
	
	            ctx.moveTo(unitX * r + x, unitY * r + y);
	            ctx.arc(x, y, r, startAngle, endAngle, !clockwise);
	        }
	    });


/***/ },
/* 56 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	
	    var zrUtil = __webpack_require__(4);
	
	    var Gradient = __webpack_require__(37);
	
	    /**
	     * x, y, x2, y2 are all percent from 0 to 1
	     * @param {number} [x=0]
	     * @param {number} [y=0]
	     * @param {number} [x2=1]
	     * @param {number} [y2=0]
	     * @param {Array.<Object>} colorStops
	     * @param {boolean} [globalCoord=false]
	     */
	    var LinearGradient = function (x, y, x2, y2, colorStops, globalCoord) {
	        this.x = x == null ? 0 : x;
	
	        this.y = y == null ? 0 : y;
	
	        this.x2 = x2 == null ? 1 : x2;
	
	        this.y2 = y2 == null ? 0 : y2;
	
	        // Can be cloned
	        this.type = 'linear';
	
	        // If use global coord
	        this.global = globalCoord || false;
	
	        Gradient.call(this, colorStops);
	    };
	
	    LinearGradient.prototype = {
	
	        constructor: LinearGradient
	    };
	
	    zrUtil.inherits(LinearGradient, Gradient);
	
	    module.exports = LinearGradient;


/***/ },
/* 57 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	
	    var zrUtil = __webpack_require__(4);
	
	    var Gradient = __webpack_require__(37);
	
	    /**
	     * x, y, r are all percent from 0 to 1
	     * @param {number} [x=0.5]
	     * @param {number} [y=0.5]
	     * @param {number} [r=0.5]
	     * @param {Array.<Object>} [colorStops]
	     * @param {boolean} [globalCoord=false]
	     */
	    var RadialGradient = function (x, y, r, colorStops, globalCoord) {
	        this.x = x == null ? 0.5 : x;
	
	        this.y = y == null ? 0.5 : y;
	
	        this.r = r == null ? 0.5 : r;
	
	        // Can be cloned
	        this.type = 'radial';
	
	        // If use global coord
	        this.global = globalCoord || false;
	
	        Gradient.call(this, colorStops);
	    };
	
	    RadialGradient.prototype = {
	
	        constructor: RadialGradient
	    };
	
	    zrUtil.inherits(RadialGradient, Gradient);
	
	    module.exports = RadialGradient;


/***/ },
/* 58 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	
	    var zrUtil = __webpack_require__(4);
	
	    var apiList = [
	        'getDom', 'getZr', 'getWidth', 'getHeight', 'dispatchAction',
	        'on', 'off', 'trigger', 'getDataURL', 'getConnectedDataURL', 'getModel', 'getOption', 'getNodeClass', 'showTipWindow', 'hideTipWindow', 'resize', 'clear'
	    ];
	
	    function ExtensionAPI(instance) {
	        zrUtil.each(apiList, function (name) {
	            this[name] = zrUtil.bind(instance[name], instance);
	        }, this);
	    }
	
	    module.exports = ExtensionAPI;
	


/***/ },
/* 59 */
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * ZRender, a high performance 2d drawing library.
	 *
	 * Copyright (c) 2013, Baidu Inc.
	 * All rights reserved.
	 *
	 * LICENSE
	 * https://github.com/ecomfe/zrender/blob/master/LICENSE.txt
	 */
	// Global defines
	
	    var guid = __webpack_require__(10);
	    var env = __webpack_require__(60);
	
	    var Handler = __webpack_require__(61);
	    var Storage = __webpack_require__(62);
	    var Animation = __webpack_require__(64);
	    var HandlerProxy = __webpack_require__(67);
	
	    var useVML = !env.canvasSupported;
	
	    var painterCtors = {
	        canvas: __webpack_require__(69)
	    };
	
	    var instances = {};    // ZRender实例map索引
	
	    var zrender = {};
	    /**
	     * @type {string}
	     */
	    zrender.version = '3.1.3';
	
	    /**
	     * Initializing a zrender instance
	     * @param {HTMLElement} dom
	     * @param {Object} opts
	     * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg'
	     * @param {number} [opts.devicePixelRatio]
	     * @return {module:zrender/ZRender}
	     */
	    zrender.init = function(dom, opts) {
	        var zr = new ZRender(guid(), dom, opts);
	        instances[zr.id] = zr;
	        return zr;
	    };
	
	    /**
	     * Dispose zrender instance
	     * @param {module:zrender/ZRender} zr
	     */
	    zrender.dispose = function (zr) {
	        if (zr) {
	            zr.dispose();
	        }
	        else {
	            for (var key in instances) {
	                instances[key].dispose();
	            }
	            instances = {};
	        }
	
	        return zrender;
	    };
	
	    /**
	     * Get zrender instance by id
	     * @param {string} id zrender instance id
	     * @return {module:zrender/ZRender}
	     */
	    zrender.getInstance = function (id) {
	        return instances[id];
	    };
	
	    zrender.registerPainter = function (name, Ctor) {
	        painterCtors[name] = Ctor;
	    };
	
	    function delInstance(id) {
	        delete instances[id];
	    }
	
	    /**
	     * @module zrender/ZRender
	     */
	    /**
	     * @constructor
	     * @alias module:zrender/ZRender
	     * @param {string} id
	     * @param {HTMLDomElement} dom
	     * @param {Object} opts
	     * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg'
	     * @param {number} [opts.devicePixelRatio]
	     */
	    var ZRender = function(id, dom, opts) {
	
	        opts = opts || {};
	
	        /**
	         * @type {HTMLDomElement}
	         */
	        this.dom = dom;
	
	        /**
	         * @type {string}
	         */
	        this.id = id;
	
	        var self = this;
	        var storage = new Storage();
	
	        var rendererType = opts.renderer;
	        if (useVML) {
	            if (!painterCtors.vml) {
	                throw new Error('You need to require \'zrender/vml/vml\' to support IE8');
	            }
	            rendererType = 'vml';
	        }
	        else if (!rendererType || !painterCtors[rendererType]) {
	            rendererType = 'canvas';
	        }
	        var painter = new painterCtors[rendererType](dom, storage, opts);
	
	        this.storage = storage;
	        this.painter = painter;
	
	        var handerProxy = !env.node ? new HandlerProxy(painter.getViewportRoot()) : null;
	        this.handler = new Handler(storage, painter, handerProxy);
	
	        /**
	         * @type {module:zrender/animation/Animation}
	         */
	        this.animation = new Animation({
	            stage: {
	                update: function () {
	                    if (self._needsRefresh) {
	                        self.refreshImmediately();
	                    }
	                    if (self._needsRefreshHover) {
	                        self.refreshHoverImmediately();
	                    }
	                }
	            }
	        });
	        this.animation.start();
	
	        /**
	         * @type {boolean}
	         * @private
	         */
	        this._needsRefresh;
	
	        // 修改 storage.delFromMap, 每次删除元素之前删除动画
	        // FIXME 有点ugly
	        var oldDelFromMap = storage.delFromMap;
	        var oldAddToMap = storage.addToMap;
	
	        storage.delFromMap = function (elId) {
	            var el = storage.get(elId);
	
	            oldDelFromMap.call(storage, elId);
	
	            el && el.removeSelfFromZr(self);
	        };
	
	        storage.addToMap = function (el) {
	            oldAddToMap.call(storage, el);
	
	            el.addSelfToZr(self);
	        };
	    };
	
	    ZRender.prototype = {
	
	        constructor: ZRender,
	        /**
	         * 获取实例唯一标识
	         * @return {string}
	         */
	        getId: function () {
	            return this.id;
	        },
	
	        /**
	         * 添加元素
	         * @param  {module:zrender/Element} el
	         */
	        add: function (el) {
	            this.storage.addRoot(el);
	            this._needsRefresh = true;
	        },
	
	        /**
	         * 删除元素
	         * @param  {module:zrender/Element} el
	         */
	        remove: function (el) {
	            this.storage.delRoot(el);
	            this._needsRefresh = true;
	        },
	
	        /**
	         * Change configuration of layer
	         * @param {string} zLevel
	         * @param {Object} config
	         * @param {string} [config.clearColor=0] Clear color
	         * @param {string} [config.motionBlur=false] If enable motion blur
	         * @param {number} [config.lastFrameAlpha=0.7] Motion blur factor. Larger value cause longer trailer
	        */
	        configLayer: function (zLevel, config) {
	            this.painter.configLayer(zLevel, config);
	            this._needsRefresh = true;
	        },
	
	        /**
	         * Repaint the canvas immediately
	         */
	        refreshImmediately: function () {
	            // Clear needsRefresh ahead to avoid something wrong happens in refresh
	            // Or it will cause zrender refreshes again and again.
	            this._needsRefresh = false;
	            this.painter.refresh();
	            /**
	             * Avoid trigger zr.refresh in Element#beforeUpdate hook
	             */
	            this._needsRefresh = false;
	        },
	
	        /**
	         * Mark and repaint the canvas in the next frame of browser
	         */
	        refresh: function() {
	            this._needsRefresh = true;
	        },
	
	        /**
	         * Add element to hover layer
	         * @param  {module:zrender/Element} el
	         * @param {Object} style
	         */
	        addHover: function (el, style) {
	            if (this.painter.addHover) {
	                this.painter.addHover(el, style);
	                this.refreshHover();
	            }
	        },
	
	        /**
	         * Add element from hover layer
	         * @param  {module:zrender/Element} el
	         */
	        removeHover: function (el) {
	            if (this.painter.removeHover) {
	                this.painter.removeHover(el);
	                this.refreshHover();
	            }
	        },
	
	        /**
	         * Clear all hover elements in hover layer
	         * @param  {module:zrender/Element} el
	         */
	        clearHover: function () {
	            if (this.painter.clearHover) {
	                this.painter.clearHover();
	                this.refreshHover();
	            }
	        },
	
	        /**
	         * Refresh hover in next frame
	         */
	        refreshHover: function () {
	            this._needsRefreshHover = true;
	        },
	
	        /**
	         * Refresh hover immediately
	         */
	        refreshHoverImmediately: function () {
	            this._needsRefreshHover = false;
	            this.painter.refreshHover && this.painter.refreshHover();
	        },
	
	        /**
	         * Resize the canvas.
	         * Should be invoked when container size is changed
	         */
	        resize: function() {
	            this.painter.resize();
	            this.handler.resize();
	        },
	
	        /**
	         * Stop and clear all animation immediately
	         */
	        clearAnimation: function () {
	            this.animation.clear();
	        },
	
	        /**
	         * Get container width
	         */
	        getWidth: function() {
	            return this.painter.getWidth();
	        },
	
	        /**
	         * Get container height
	         */
	        getHeight: function() {
	            return this.painter.getHeight();
	        },
	
	        /**
	         * Export the canvas as Base64 URL
	         * @param {string} type
	         * @param {string} [backgroundColor='#fff']
	         * @return {string} Base64 URL
	         */
	        // toDataURL: function(type, backgroundColor) {
	        //     return this.painter.getRenderedCanvas({
	        //         backgroundColor: backgroundColor
	        //     }).toDataURL(type);
	        // },
	
	        /**
	         * Converting a path to image.
	         * It has much better performance of drawing image rather than drawing a vector path.
	         * @param {module:zrender/graphic/Path} e
	         * @param {number} width
	         * @param {number} height
	         */
	        pathToImage: function(e, width, height) {
	            var id = guid();
	            return this.painter.pathToImage(id, e, width, height);
	        },
	
	        /**
	         * Set default cursor
	         * @param {string} [cursorStyle='default'] 例如 crosshair
	         */
	        setCursorStyle: function (cursorStyle) {
	            this.handler.setCursorStyle(cursorStyle);
	        },
	
	        /**
	         * Bind event
	         *
	         * @param {string} eventName Event name
	         * @param {Function} eventHandler Handler function
	         * @param {Object} [context] Context object
	         */
	        on: function(eventName, eventHandler, context) {
	            this.handler.on(eventName, eventHandler, context);
	        },
	
	        /**
	         * Unbind event
	         * @param {string} eventName Event name
	         * @param {Function} [eventHandler] Handler function
	         */
	        off: function(eventName, eventHandler) {
	            this.handler.off(eventName, eventHandler);
	        },
	
	        /**
	         * Trigger event manually
	         *
	         * @param {string} eventName Event name
	         * @param {event=} event Event object
	         */
	        trigger: function (eventName, event) {
	            this.handler.trigger(eventName, event);
	        },
	
	
	        /**
	         * Clear all objects and the canvas.
	         */
	        clear: function () {
	            this.storage.delRoot();
	            this.painter.clear();
	        },
	
	        /**
	         * Dispose self.
	         */
	        dispose: function () {
	            this.animation.stop();
	
	            this.clear();
	            this.storage.dispose();
	            this.painter.dispose();
	            this.handler.dispose();
	
	            this.animation =
	            this.storage =
	            this.painter =
	            this.handler = null;
	
	            delInstance(this.id);
	        }
	    };
	
	    module.exports = zrender;
	


/***/ },
/* 60 */
/***/ function(module, exports) {

	/**
	 * echarts设备环境识别
	 *
	 * @desc echarts基于Canvas，纯Javascript图表库，提供直观，生动，可交互，可个性化定制的数据统计图表。
	 * @author firede[firede@firede.us]
	 * @desc thanks zepto.
	 */
	
	    var env = {};
	    if (typeof navigator === 'undefined') {
	        // In node
	        env = {
	            browser: {},
	            os: {},
	            node: true,
	            // Assume canvas is supported
	            canvasSupported: true
	        };
	    }
	    else {
	        env = detect(navigator.userAgent);
	    }
	
	    module.exports = env;
	
	    // Zepto.js
	    // (c) 2010-2013 Thomas Fuchs
	    // Zepto.js may be freely distributed under the MIT license.
	
	    function detect(ua) {
	        var os = {};
	        var browser = {};
	        // var webkit = ua.match(/Web[kK]it[\/]{0,1}([\d.]+)/);
	        // var android = ua.match(/(Android);?[\s\/]+([\d.]+)?/);
	        // var ipad = ua.match(/(iPad).*OS\s([\d_]+)/);
	        // var ipod = ua.match(/(iPod)(.*OS\s([\d_]+))?/);
	        // var iphone = !ipad && ua.match(/(iPhone\sOS)\s([\d_]+)/);
	        // var webos = ua.match(/(webOS|hpwOS)[\s\/]([\d.]+)/);
	        // var touchpad = webos && ua.match(/TouchPad/);
	        // var kindle = ua.match(/Kindle\/([\d.]+)/);
	        // var silk = ua.match(/Silk\/([\d._]+)/);
	        // var blackberry = ua.match(/(BlackBerry).*Version\/([\d.]+)/);
	        // var bb10 = ua.match(/(BB10).*Version\/([\d.]+)/);
	        // var rimtabletos = ua.match(/(RIM\sTablet\sOS)\s([\d.]+)/);
	        // var playbook = ua.match(/PlayBook/);
	        // var chrome = ua.match(/Chrome\/([\d.]+)/) || ua.match(/CriOS\/([\d.]+)/);
	        var firefox = ua.match(/Firefox\/([\d.]+)/);
	        // var safari = webkit && ua.match(/Mobile\//) && !chrome;
	        // var webview = ua.match(/(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/) && !chrome;
	        var ie = ua.match(/MSIE\s([\d.]+)/)
	            // IE 11 Trident/7.0; rv:11.0
	            || ua.match(/Trident\/.+?rv:(([\d.]+))/);
	        var edge = ua.match(/Edge\/([\d.]+)/); // IE 12 and 12+
	
	        // Todo: clean this up with a better OS/browser seperation:
	        // - discern (more) between multiple browsers on android
	        // - decide if kindle fire in silk mode is android or not
	        // - Firefox on Android doesn't specify the Android version
	        // - possibly devide in os, device and browser hashes
	
	        // if (browser.webkit = !!webkit) browser.version = webkit[1];
	
	        // if (android) os.android = true, os.version = android[2];
	        // if (iphone && !ipod) os.ios = os.iphone = true, os.version = iphone[2].replace(/_/g, '.');
	        // if (ipad) os.ios = os.ipad = true, os.version = ipad[2].replace(/_/g, '.');
	        // if (ipod) os.ios = os.ipod = true, os.version = ipod[3] ? ipod[3].replace(/_/g, '.') : null;
	        // if (webos) os.webos = true, os.version = webos[2];
	        // if (touchpad) os.touchpad = true;
	        // if (blackberry) os.blackberry = true, os.version = blackberry[2];
	        // if (bb10) os.bb10 = true, os.version = bb10[2];
	        // if (rimtabletos) os.rimtabletos = true, os.version = rimtabletos[2];
	        // if (playbook) browser.playbook = true;
	        // if (kindle) os.kindle = true, os.version = kindle[1];
	        // if (silk) browser.silk = true, browser.version = silk[1];
	        // if (!silk && os.android && ua.match(/Kindle Fire/)) browser.silk = true;
	        // if (chrome) browser.chrome = true, browser.version = chrome[1];
	        if (firefox) browser.firefox = true, browser.version = firefox[1];
	        // if (safari && (ua.match(/Safari/) || !!os.ios)) browser.safari = true;
	        // if (webview) browser.webview = true;
	        if (ie) {
	            browser.ie = true; browser.version = ie[1];
	        }
	        if (ie) {
	            browser.ie = true;
	            browser.version = ie[1];
	        }
	        if (edge) {
	            browser.edge = true;
	            browser.version = edge[1];
	        }
	
	        // os.tablet = !!(ipad || playbook || (android && !ua.match(/Mobile/)) ||
	        //     (firefox && ua.match(/Tablet/)) || (ie && !ua.match(/Phone/) && ua.match(/Touch/)));
	        // os.phone  = !!(!os.tablet && !os.ipod && (android || iphone || webos ||
	        //     (chrome && ua.match(/Android/)) || (chrome && ua.match(/CriOS\/([\d.]+)/)) ||
	        //     (firefox && ua.match(/Mobile/)) || (ie && ua.match(/Touch/))));
	
	        return {
	            browser: browser,
	            os: os,
	            node: false,
	            // 原生canvas支持，改极端点了
	            // canvasSupported : !(browser.ie && parseFloat(browser.version) < 9)
	            canvasSupported : document.createElement('canvas').getContext ? true : false,
	            // @see <http://stackoverflow.com/questions/4817029/whats-the-best-way-to-detect-a-touch-screen-device-using-javascript>
	            // works on most browsers
	            // IE10/11 does not support touch event, and MS Edge supports them but not by
	            // default, so we dont check navigator.maxTouchPoints for them here.
	            touchEventsSupported: 'ontouchstart' in window && !browser.ie && !browser.edge,
	            // <http://caniuse.com/#search=pointer%20event>.
	            pointerEventsSupported: 'onpointerdown' in window
	                // Firefox supports pointer but not by default,
	                // only MS browsers are reliable on pointer events currently.
	                && (browser.edge || (browser.ie && browser.version >= 10))
	        };
	    }


/***/ },
/* 61 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	/**
	 * Handler
	 * @module zrender/Handler
	 * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)
	 *         errorrik (errorrik@gmail.com)
	 *         pissang (shenyi.914@gmail.com)
	 */
	
	
	    var util = __webpack_require__(4);
	    var Draggable = __webpack_require__(38);
	
	    var Eventful = __webpack_require__(11);
	
	    function makeEventPacket(eveType, target, event) {
	        return {
	            type: eveType,
	            event: event,
	            target: target,
	            cancelBubble: false,
	            offsetX: event.zrX,
	            offsetY: event.zrY,
	            gestureEvent: event.gestureEvent,
	            pinchX: event.pinchX,
	            pinchY: event.pinchY,
	            pinchScale: event.pinchScale,
	            wheelDelta: event.zrDelta
	        };
	    }
	
	    function EmptyProxy () {}
	    EmptyProxy.prototype.dispose = function () {};
	
	    var handlerNames = [
	        'click', 'dblclick', 'mousewheel', 'mouseout',
	        'mouseup', 'mousedown', 'mousemove'
	    ];
	    /**
	     * @alias module:zrender/Handler
	     * @constructor
	     * @extends module:zrender/mixin/Eventful
	     * @param {HTMLElement} root Main HTML element for painting.
	     * @param {module:zrender/Storage} storage Storage instance.
	     * @param {module:zrender/Painter} painter Painter instance.
	     */
	    var Handler = function(storage, painter, proxy) {
	        Eventful.call(this);
	
	        this.storage = storage;
	
	        this.painter = painter;
	
	        proxy = proxy || new EmptyProxy();
	        /**
	         * Proxy of event. can be Dom, WebGLSurface, etc.
	         */
	        this.proxy = proxy;
	
	        // Attach handler
	        proxy.handler = this;
	
	        /**
	         * @private
	         * @type {boolean}
	         */
	        this._hovered;
	
	        /**
	         * @private
	         * @type {Date}
	         */
	        this._lastTouchMoment;
	
	        /**
	         * @private
	         * @type {number}
	         */
	        this._lastX;
	
	        /**
	         * @private
	         * @type {number}
	         */
	        this._lastY;
	
	
	        Draggable.call(this);
	
	        util.each(handlerNames, function (name) {
	            proxy.on && proxy.on(name, this[name], this);
	        }, this);
	    };
	
	    Handler.prototype = {
	
	        constructor: Handler,
	
	        mousemove: function (event) {
	            var x = event.zrX;
	            var y = event.zrY;
	
	            var hovered = this.findHover(x, y, null);
	            var lastHovered = this._hovered;
	            var proxy = this.proxy;
	
	            this._hovered = hovered;
	
	            proxy.setCursor && proxy.setCursor(hovered ? hovered.cursor : 'default');
	
	            // Mouse out on previous hovered element
	            if (lastHovered && hovered !== lastHovered && lastHovered.__zr) {
	                this.dispatchToElement(lastHovered, 'mouseout', event);
	            }
	
	            // Mouse moving on one element
	            this.dispatchToElement(hovered, 'mousemove', event);
	
	            // Mouse over on a new element
	            if (hovered && hovered !== lastHovered) {
	                this.dispatchToElement(hovered, 'mouseover', event);
	            }
	        },
	
	        mouseout: function (event) {
	            this.dispatchToElement(this._hovered, 'mouseout', event);
	
	            this.trigger('globalout', {
	                event: event
	            });
	        },
	
	        /**
	         * Resize
	         */
	        resize: function (event) {
	            this._hovered = null;
	        },
	
	        /**
	         * Dispatch event
	         * @param {string} eventName
	         * @param {event=} eventArgs
	         */
	        dispatch: function (eventName, eventArgs) {
	            var handler = this[eventName];
	            handler && handler.call(this, eventArgs);
	        },
	
	        /**
	         * Dispose
	         */
	        dispose: function () {
	
	            this.proxy.dispose();
	
	            this.storage =
	            this.proxy =
	            this.painter = null;
	        },
	
	        /**
	         * 设置默认的cursor style
	         * @param {string} [cursorStyle='default'] 例如 crosshair
	         */
	        setCursorStyle: function (cursorStyle) {
	            var proxy = this.proxy;
	            proxy.setCursor && proxy.setCursor(cursorStyle);
	        },
	
	        /**
	         * 事件分发代理
	         *
	         * @private
	         * @param {Object} targetEl 目标图形元素
	         * @param {string} eventName 事件名称
	         * @param {Object} event 事件对象
	         */
	        dispatchToElement: function (targetEl, eventName, event) {
	            var eventHandler = 'on' + eventName;
	            var eventPacket = makeEventPacket(eventName, targetEl, event);
	
	            var el = targetEl;
	
	            while (el) {
	                el[eventHandler]
	                    && (eventPacket.cancelBubble = el[eventHandler].call(el, eventPacket));
	
	                el.trigger(eventName, eventPacket);
	
	                el = el.parent;
	
	                if (eventPacket.cancelBubble) {
	                    break;
	                }
	            }
	
	            if (!eventPacket.cancelBubble) {
	                // 冒泡到顶级 zrender 对象
	                this.trigger(eventName, eventPacket);
	                // 分发事件到用户自定义层
	                // 用户有可能在全局 click 事件中 dispose，所以需要判断下 painter 是否存在
	                this.painter && this.painter.eachOtherLayer(function (layer) {
	                    if (typeof(layer[eventHandler]) == 'function') {
	                        layer[eventHandler].call(layer, eventPacket);
	                    }
	                    if (layer.trigger) {
	                        layer.trigger(eventName, eventPacket);
	                    }
	                });
	            }
	        },
	
	        /**
	         * @private
	         * @param {number} x
	         * @param {number} y
	         * @param {module:zrender/graphic/Displayable} exclude
	         * @method
	         */
	        findHover: function(x, y, exclude) {
	            var list = this.storage.getDisplayList();
	            for (var i = list.length - 1; i >= 0 ; i--) {
	                if (!list[i].silent
	                 && list[i] !== exclude
	                 // getDisplayList may include ignored item in VML mode
	                 && !list[i].ignore
	                 && isHover(list[i], x, y)) {
	                    return list[i];
	                }
	            }
	        }
	    };
	
	    // Common handlers
	    util.each(['click', 'mousedown', 'mouseup', 'mousewheel', 'dblclick'], function (name) {
	        Handler.prototype[name] = function (event) {
	            // Find hover again to avoid click event is dispatched manually. Or click is triggered without mouseover
	            var hovered = this.findHover(event.zrX, event.zrY, null);
	
	            if (name === 'mousedown') {
	                this._downel = hovered;
	                // In case click triggered before mouseup
	                this._upel = hovered;
	            }
	            else if (name === 'mosueup') {
	                this._upel = hovered;
	            }
	            else if (name === 'click') {
	                if (this._downel !== this._upel) {
	                    return;
	                }
	            }
	
	            this.dispatchToElement(hovered, name, event);
	        };
	    });
	
	    function isHover(displayable, x, y) {
	        if (displayable[displayable.rectHover ? 'rectContain' : 'contain'](x, y)) {
	            var el = displayable;
	            while (el) {
	                // If ancestor is silent or clipped by ancestor
	                if (el.silent || (el.clipPath && !el.clipPath.contain(x, y)))  {
	                    return false;
	                }
	                el = el.parent;
	            }
	            return true;
	        }
	
	        return false;
	    }
	
	    util.mixin(Handler, Eventful);
	    util.mixin(Handler, Draggable);
	
	    module.exports = Handler;


/***/ },
/* 62 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	/**
	 * Storage内容仓库模块
	 * @module zrender/Storage
	 * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)
	 * @author errorrik (errorrik@gmail.com)
	 * @author pissang (https://github.com/pissang/)
	 */
	
	
	    var util = __webpack_require__(4);
	    var env = __webpack_require__(60);
	
	    var Group = __webpack_require__(39);
	
	    // Use timsort because in most case elements are partially sorted
	    // https://jsfiddle.net/pissang/jr4x7mdm/8/
	    var timsort = __webpack_require__(63);
	
	    function shapeCompareFunc(a, b) {
	        if (a.zlevel === b.zlevel) {
	            if (a.z === b.z) {
	                // if (a.z2 === b.z2) {
	                //     // FIXME Slow has renderidx compare
	                //     // http://stackoverflow.com/questions/20883421/sorting-in-javascript-should-every-compare-function-have-a-return-0-statement
	                //     // https://github.com/v8/v8/blob/47cce544a31ed5577ffe2963f67acb4144ee0232/src/js/array.js#L1012
	                //     return a.__renderidx - b.__renderidx;
	                // }
	                return a.z2 - b.z2;
	            }
	            return a.z - b.z;
	        }
	        return a.zlevel - b.zlevel;
	    }
	    /**
	     * 内容仓库 (M)
	     * @alias module:zrender/Storage
	     * @constructor
	     */
	    var Storage = function () {
	        // 所有常规形状，id索引的map
	        this._elements = {};
	
	        this._roots = [];
	
	        this._displayList = [];
	
	        this._displayListLen = 0;
	    };
	
	    Storage.prototype = {
	
	        constructor: Storage,
	
	        /**
	         * @param  {Function} cb
	         *
	         */
	        traverse: function (cb, context) {
	            for (var i = 0; i < this._roots.length; i++) {
	                this._roots[i].traverse(cb, context);
	            }
	        },
	
	        /**
	         * 返回所有图形的绘制队列
	         * @param {boolean} [update=false] 是否在返回前更新该数组
	         * @param {boolean} [includeIgnore=false] 是否包含 ignore 的数组, 在 update 为 true 的时候有效
	         *
	         * 详见{@link module:zrender/graphic/Displayable.prototype.updateDisplayList}
	         * @return {Array.<module:zrender/graphic/Displayable>}
	         */
	        getDisplayList: function (update, includeIgnore) {
	            includeIgnore = includeIgnore || false;
	            if (update) {
	                this.updateDisplayList(includeIgnore);
	            }
	            return this._displayList;
	        },
	
	        /**
	         * 更新图形的绘制队列。
	         * 每次绘制前都会调用，该方法会先深度优先遍历整个树，更新所有Group和Shape的变换并且把所有可见的Shape保存到数组中，
	         * 最后根据绘制的优先级（zlevel > z > 插入顺序）排序得到绘制队列
	         * @param {boolean} [includeIgnore=false] 是否包含 ignore 的数组
	         */
	        updateDisplayList: function (includeIgnore) {
	            this._displayListLen = 0;
	            var roots = this._roots;
	            var displayList = this._displayList;
	            for (var i = 0, len = roots.length; i < len; i++) {
	                this._updateAndAddDisplayable(roots[i], null, includeIgnore);
	            }
	            displayList.length = this._displayListLen;
	
	            // for (var i = 0, len = displayList.length; i < len; i++) {
	            //     displayList[i].__renderidx = i;
	            // }
	
	            // displayList.sort(shapeCompareFunc);
	            env.canvasSupported && timsort(displayList, shapeCompareFunc);
	        },
	
	        _updateAndAddDisplayable: function (el, clipPaths, includeIgnore) {
	
	            if (el.ignore && !includeIgnore) {
	                return;
	            }
	
	            el.beforeUpdate();
	
	            if (el.__dirty) {
	
	                el.update();
	
	            }
	
	            el.afterUpdate();
	
	            var clipPath = el.clipPath;
	            if (clipPath) {
	                // clipPath 的变换是基于 group 的变换
	                clipPath.parent = el;
	                clipPath.updateTransform();
	
	                // FIXME 效率影响
	                if (clipPaths) {
	                    clipPaths = clipPaths.slice();
	                    clipPaths.push(clipPath);
	                }
	                else {
	                    clipPaths = [clipPath];
	                }
	            }
	
	            if (el.isGroup) {
	                var children = el._children;
	
	                for (var i = 0; i < children.length; i++) {
	                    var child = children[i];
	
	                    // Force to mark as dirty if group is dirty
	                    // FIXME __dirtyPath ?
	                    if (el.__dirty) {
	                        child.__dirty = true;
	                    }
	
	                    this._updateAndAddDisplayable(child, clipPaths, includeIgnore);
	                }
	
	                // Mark group clean here
	                el.__dirty = false;
	
	            }
	            else {
	                el.__clipPaths = clipPaths;
	
	                this._displayList[this._displayListLen++] = el;
	            }
	        },
	
	        /**
	         * 添加图形(Shape)或者组(Group)到根节点
	         * @param {module:zrender/Element} el
	         */
	        addRoot: function (el) {
	            // Element has been added
	            if (this._elements[el.id]) {
	                return;
	            }
	
	            if (el instanceof Group) {
	                el.addChildrenToStorage(this);
	            }
	
	            this.addToMap(el);
	            this._roots.push(el);
	        },
	
	        /**
	         * 删除指定的图形(Shape)或者组(Group)
	         * @param {string|Array.<string>} [elId] 如果为空清空整个Storage
	         */
	        delRoot: function (elId) {
	            if (elId == null) {
	                // 不指定elId清空
	                for (var i = 0; i < this._roots.length; i++) {
	                    var root = this._roots[i];
	                    if (root instanceof Group) {
	                        root.delChildrenFromStorage(this);
	                    }
	                }
	
	                this._elements = {};
	                this._roots = [];
	                this._displayList = [];
	                this._displayListLen = 0;
	
	                return;
	            }
	
	            if (elId instanceof Array) {
	                for (var i = 0, l = elId.length; i < l; i++) {
	                    this.delRoot(elId[i]);
	                }
	                return;
	            }
	
	            var el;
	            if (typeof(elId) == 'string') {
	                el = this._elements[elId];
	            }
	            else {
	                el = elId;
	            }
	
	            var idx = util.indexOf(this._roots, el);
	            if (idx >= 0) {
	                this.delFromMap(el.id);
	                this._roots.splice(idx, 1);
	                if (el instanceof Group) {
	                    el.delChildrenFromStorage(this);
	                }
	            }
	        },
	
	        addToMap: function (el) {
	            if (el instanceof Group) {
	                el.__storage = this;
	            }
	            el.dirty(false);
	
	            this._elements[el.id] = el;
	
	            return this;
	        },
	
	        get: function (elId) {
	            return this._elements[elId];
	        },
	
	        delFromMap: function (elId) {
	            var elements = this._elements;
	            var el = elements[elId];
	            if (el) {
	                delete elements[elId];
	                if (el instanceof Group) {
	                    el.__storage = null;
	                }
	            }
	
	            return this;
	        },
	
	        /**
	         * 清空并且释放Storage
	         */
	        dispose: function () {
	            this._elements =
	            this._renderList =
	            this._roots = null;
	        },
	
	        displayableSortFunc: shapeCompareFunc
	    };
	
	    module.exports = Storage;
	


/***/ },
/* 63 */
/***/ function(module, exports) {

	// https://github.com/mziccard/node-timsort
	
	    var DEFAULT_MIN_MERGE = 32;
	
	    var DEFAULT_MIN_GALLOPING = 7;
	
	    var DEFAULT_TMP_STORAGE_LENGTH = 256;
	
	    function minRunLength(n) {
	        var r = 0;
	
	        while (n >= DEFAULT_MIN_MERGE) {
	            r |= n & 1;
	            n >>= 1;
	        }
	
	        return n + r;
	    }
	
	    function makeAscendingRun(array, lo, hi, compare) {
	        var runHi = lo + 1;
	
	        if (runHi === hi) {
	            return 1;
	        }
	
	        if (compare(array[runHi++], array[lo]) < 0) {
	            while (runHi < hi && compare(array[runHi], array[runHi - 1]) < 0) {
	                runHi++;
	            }
	
	            reverseRun(array, lo, runHi);
	        }
	        else {
	            while (runHi < hi && compare(array[runHi], array[runHi - 1]) >= 0) {
	                runHi++;
	            }
	        }
	
	        return runHi - lo;
	    }
	
	    function reverseRun(array, lo, hi) {
	        hi--;
	
	        while (lo < hi) {
	            var t = array[lo];
	            array[lo++] = array[hi];
	            array[hi--] = t;
	        }
	    }
	
	    function binaryInsertionSort(array, lo, hi, start, compare) {
	        if (start === lo) {
	            start++;
	        }
	
	        for (; start < hi; start++) {
	            var pivot = array[start];
	
	            var left = lo;
	            var right = start;
	            var mid;
	
	            while (left < right) {
	                mid = left + right >>> 1;
	
	                if (compare(pivot, array[mid]) < 0) {
	                    right = mid;
	                }
	                else {
	                    left = mid + 1;
	                }
	            }
	
	            var n = start - left;
	
	            switch (n) {
	                case 3:
	                    array[left + 3] = array[left + 2];
	
	                case 2:
	                    array[left + 2] = array[left + 1];
	
	                case 1:
	                    array[left + 1] = array[left];
	                    break;
	                default:
	                    while (n > 0) {
	                        array[left + n] = array[left + n - 1];
	                        n--;
	                    }
	            }
	
	            array[left] = pivot;
	        }
	    }
	
	    function gallopLeft(value, array, start, length, hint, compare) {
	        var lastOffset = 0;
	        var maxOffset = 0;
	        var offset = 1;
	
	        if (compare(value, array[start + hint]) > 0) {
	            maxOffset = length - hint;
	
	            while (offset < maxOffset && compare(value, array[start + hint + offset]) > 0) {
	                lastOffset = offset;
	                offset = (offset << 1) + 1;
	
	                if (offset <= 0) {
	                    offset = maxOffset;
	                }
	            }
	
	            if (offset > maxOffset) {
	                offset = maxOffset;
	            }
	
	            lastOffset += hint;
	            offset += hint;
	        }
	        else {
	            maxOffset = hint + 1;
	            while (offset < maxOffset && compare(value, array[start + hint - offset]) <= 0) {
	                lastOffset = offset;
	                offset = (offset << 1) + 1;
	
	                if (offset <= 0) {
	                    offset = maxOffset;
	                }
	            }
	            if (offset > maxOffset) {
	                offset = maxOffset;
	            }
	
	            var tmp = lastOffset;
	            lastOffset = hint - offset;
	            offset = hint - tmp;
	        }
	
	        lastOffset++;
	        while (lastOffset < offset) {
	            var m = lastOffset + (offset - lastOffset >>> 1);
	
	            if (compare(value, array[start + m]) > 0) {
	                lastOffset = m + 1;
	            }
	            else {
	                offset = m;
	            }
	        }
	        return offset;
	    }
	
	    function gallopRight(value, array, start, length, hint, compare) {
	        var lastOffset = 0;
	        var maxOffset = 0;
	        var offset = 1;
	
	        if (compare(value, array[start + hint]) < 0) {
	            maxOffset = hint + 1;
	
	            while (offset < maxOffset && compare(value, array[start + hint - offset]) < 0) {
	                lastOffset = offset;
	                offset = (offset << 1) + 1;
	
	                if (offset <= 0) {
	                    offset = maxOffset;
	                }
	            }
	
	            if (offset > maxOffset) {
	                offset = maxOffset;
	            }
	
	            var tmp = lastOffset;
	            lastOffset = hint - offset;
	            offset = hint - tmp;
	        }
	        else {
	            maxOffset = length - hint;
	
	            while (offset < maxOffset && compare(value, array[start + hint + offset]) >= 0) {
	                lastOffset = offset;
	                offset = (offset << 1) + 1;
	
	                if (offset <= 0) {
	                    offset = maxOffset;
	                }
	            }
	
	            if (offset > maxOffset) {
	                offset = maxOffset;
	            }
	
	            lastOffset += hint;
	            offset += hint;
	        }
	
	        lastOffset++;
	
	        while (lastOffset < offset) {
	            var m = lastOffset + (offset - lastOffset >>> 1);
	
	            if (compare(value, array[start + m]) < 0) {
	                offset = m;
	            }
	            else {
	                lastOffset = m + 1;
	            }
	        }
	
	        return offset;
	    }
	
	    function TimSort(array, compare) {
	        var minGallop = DEFAULT_MIN_GALLOPING;
	        var length = 0;
	        var tmpStorageLength = DEFAULT_TMP_STORAGE_LENGTH;
	        var stackLength = 0;
	        var runStart;
	        var runLength;
	        var stackSize = 0;
	
	        length = array.length;
	
	        if (length < 2 * DEFAULT_TMP_STORAGE_LENGTH) {
	            tmpStorageLength = length >>> 1;
	        }
	
	        var tmp = [];
	
	        stackLength = length < 120 ? 5 : length < 1542 ? 10 : length < 119151 ? 19 : 40;
	
	        runStart = [];
	        runLength = [];
	
	        function pushRun(_runStart, _runLength) {
	            runStart[stackSize] = _runStart;
	            runLength[stackSize] = _runLength;
	            stackSize += 1;
	        }
	
	        function mergeRuns() {
	            while (stackSize > 1) {
	                var n = stackSize - 2;
	
	                if (n >= 1 && runLength[n - 1] <= runLength[n] + runLength[n + 1] || n >= 2 && runLength[n - 2] <= runLength[n] + runLength[n - 1]) {
	                    if (runLength[n - 1] < runLength[n + 1]) {
	                        n--;
	                    }
	                }
	                else if (runLength[n] > runLength[n + 1]) {
	                    break;
	                }
	                mergeAt(n);
	            }
	        }
	
	        function forceMergeRuns() {
	            while (stackSize > 1) {
	                var n = stackSize - 2;
	
	                if (n > 0 && runLength[n - 1] < runLength[n + 1]) {
	                    n--;
	                }
	
	                mergeAt(n);
	            }
	        }
	
	        function mergeAt(i) {
	            var start1 = runStart[i];
	            var length1 = runLength[i];
	            var start2 = runStart[i + 1];
	            var length2 = runLength[i + 1];
	
	            runLength[i] = length1 + length2;
	
	            if (i === stackSize - 3) {
	                runStart[i + 1] = runStart[i + 2];
	                runLength[i + 1] = runLength[i + 2];
	            }
	
	            stackSize--;
	
	            var k = gallopRight(array[start2], array, start1, length1, 0, compare);
	            start1 += k;
	            length1 -= k;
	
	            if (length1 === 0) {
	                return;
	            }
	
	            length2 = gallopLeft(array[start1 + length1 - 1], array, start2, length2, length2 - 1, compare);
	
	            if (length2 === 0) {
	                return;
	            }
	
	            if (length1 <= length2) {
	                mergeLow(start1, length1, start2, length2);
	            }
	            else {
	                mergeHigh(start1, length1, start2, length2);
	            }
	        }
	
	        function mergeLow(start1, length1, start2, length2) {
	            var i = 0;
	
	            for (i = 0; i < length1; i++) {
	                tmp[i] = array[start1 + i];
	            }
	
	            var cursor1 = 0;
	            var cursor2 = start2;
	            var dest = start1;
	
	            array[dest++] = array[cursor2++];
	
	            if (--length2 === 0) {
	                for (i = 0; i < length1; i++) {
	                    array[dest + i] = tmp[cursor1 + i];
	                }
	                return;
	            }
	
	            if (length1 === 1) {
	                for (i = 0; i < length2; i++) {
	                    array[dest + i] = array[cursor2 + i];
	                }
	                array[dest + length2] = tmp[cursor1];
	                return;
	            }
	
	            var _minGallop = minGallop;
	            var count1, count2, exit;
	
	            while (1) {
	                count1 = 0;
	                count2 = 0;
	                exit = false;
	
	                do {
	                    if (compare(array[cursor2], tmp[cursor1]) < 0) {
	                        array[dest++] = array[cursor2++];
	                        count2++;
	                        count1 = 0;
	
	                        if (--length2 === 0) {
	                            exit = true;
	                            break;
	                        }
	                    }
	                    else {
	                        array[dest++] = tmp[cursor1++];
	                        count1++;
	                        count2 = 0;
	                        if (--length1 === 1) {
	                            exit = true;
	                            break;
	                        }
	                    }
	                } while ((count1 | count2) < _minGallop);
	
	                if (exit) {
	                    break;
	                }
	
	                do {
	                    count1 = gallopRight(array[cursor2], tmp, cursor1, length1, 0, compare);
	
	                    if (count1 !== 0) {
	                        for (i = 0; i < count1; i++) {
	                            array[dest + i] = tmp[cursor1 + i];
	                        }
	
	                        dest += count1;
	                        cursor1 += count1;
	                        length1 -= count1;
	                        if (length1 <= 1) {
	                            exit = true;
	                            break;
	                        }
	                    }
	
	                    array[dest++] = array[cursor2++];
	
	                    if (--length2 === 0) {
	                        exit = true;
	                        break;
	                    }
	
	                    count2 = gallopLeft(tmp[cursor1], array, cursor2, length2, 0, compare);
	
	                    if (count2 !== 0) {
	                        for (i = 0; i < count2; i++) {
	                            array[dest + i] = array[cursor2 + i];
	                        }
	
	                        dest += count2;
	                        cursor2 += count2;
	                        length2 -= count2;
	
	                        if (length2 === 0) {
	                            exit = true;
	                            break;
	                        }
	                    }
	                    array[dest++] = tmp[cursor1++];
	
	                    if (--length1 === 1) {
	                        exit = true;
	                        break;
	                    }
	
	                    _minGallop--;
	                } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);
	
	                if (exit) {
	                    break;
	                }
	
	                if (_minGallop < 0) {
	                    _minGallop = 0;
	                }
	
	                _minGallop += 2;
	            }
	
	            minGallop = _minGallop;
	
	            minGallop < 1 && (minGallop = 1);
	
	            if (length1 === 1) {
	                for (i = 0; i < length2; i++) {
	                    array[dest + i] = array[cursor2 + i];
	                }
	                array[dest + length2] = tmp[cursor1];
	            }
	            else if (length1 === 0) {
	                throw new Error();
	                // throw new Error('mergeLow preconditions were not respected');
	            }
	            else {
	                for (i = 0; i < length1; i++) {
	                    array[dest + i] = tmp[cursor1 + i];
	                }
	            }
	        }
	
	        function mergeHigh (start1, length1, start2, length2) {
	            var i = 0;
	
	            for (i = 0; i < length2; i++) {
	                tmp[i] = array[start2 + i];
	            }
	
	            var cursor1 = start1 + length1 - 1;
	            var cursor2 = length2 - 1;
	            var dest = start2 + length2 - 1;
	            var customCursor = 0;
	            var customDest = 0;
	
	            array[dest--] = array[cursor1--];
	
	            if (--length1 === 0) {
	                customCursor = dest - (length2 - 1);
	
	                for (i = 0; i < length2; i++) {
	                    array[customCursor + i] = tmp[i];
	                }
	
	                return;
	            }
	
	            if (length2 === 1) {
	                dest -= length1;
	                cursor1 -= length1;
	                customDest = dest + 1;
	                customCursor = cursor1 + 1;
	
	                for (i = length1 - 1; i >= 0; i--) {
	                    array[customDest + i] = array[customCursor + i];
	                }
	
	                array[dest] = tmp[cursor2];
	                return;
	            }
	
	            var _minGallop = minGallop;
	
	            while (true) {
	                var count1 = 0;
	                var count2 = 0;
	                var exit = false;
	
	                do {
	                    if (compare(tmp[cursor2], array[cursor1]) < 0) {
	                        array[dest--] = array[cursor1--];
	                        count1++;
	                        count2 = 0;
	                        if (--length1 === 0) {
	                            exit = true;
	                            break;
	                        }
	                    }
	                    else {
	                        array[dest--] = tmp[cursor2--];
	                        count2++;
	                        count1 = 0;
	                        if (--length2 === 1) {
	                            exit = true;
	                            break;
	                        }
	                    }
	                } while ((count1 | count2) < _minGallop);
	
	                if (exit) {
	                    break;
	                }
	
	                do {
	                    count1 = length1 - gallopRight(tmp[cursor2], array, start1, length1, length1 - 1, compare);
	
	                    if (count1 !== 0) {
	                        dest -= count1;
	                        cursor1 -= count1;
	                        length1 -= count1;
	                        customDest = dest + 1;
	                        customCursor = cursor1 + 1;
	
	                        for (i = count1 - 1; i >= 0; i--) {
	                            array[customDest + i] = array[customCursor + i];
	                        }
	
	                        if (length1 === 0) {
	                            exit = true;
	                            break;
	                        }
	                    }
	
	                    array[dest--] = tmp[cursor2--];
	
	                    if (--length2 === 1) {
	                        exit = true;
	                        break;
	                    }
	
	                    count2 = length2 - gallopLeft(array[cursor1], tmp, 0, length2, length2 - 1, compare);
	
	                    if (count2 !== 0) {
	                        dest -= count2;
	                        cursor2 -= count2;
	                        length2 -= count2;
	                        customDest = dest + 1;
	                        customCursor = cursor2 + 1;
	
	                        for (i = 0; i < count2; i++) {
	                            array[customDest + i] = tmp[customCursor + i];
	                        }
	
	                        if (length2 <= 1) {
	                            exit = true;
	                            break;
	                        }
	                    }
	
	                    array[dest--] = array[cursor1--];
	
	                    if (--length1 === 0) {
	                        exit = true;
	                        break;
	                    }
	
	                    _minGallop--;
	                } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);
	
	                if (exit) {
	                    break;
	                }
	
	                if (_minGallop < 0) {
	                    _minGallop = 0;
	                }
	
	                _minGallop += 2;
	            }
	
	            minGallop = _minGallop;
	
	            if (minGallop < 1) {
	                minGallop = 1;
	            }
	
	            if (length2 === 1) {
	                dest -= length1;
	                cursor1 -= length1;
	                customDest = dest + 1;
	                customCursor = cursor1 + 1;
	
	                for (i = length1 - 1; i >= 0; i--) {
	                    array[customDest + i] = array[customCursor + i];
	                }
	
	                array[dest] = tmp[cursor2];
	            }
	            else if (length2 === 0) {
	                throw new Error();
	                // throw new Error('mergeHigh preconditions were not respected');
	            }
	            else {
	                customCursor = dest - (length2 - 1);
	                for (i = 0; i < length2; i++) {
	                    array[customCursor + i] = tmp[i];
	                }
	            }
	        }
	
	        this.mergeRuns = mergeRuns;
	        this.forceMergeRuns = forceMergeRuns;
	        this.pushRun = pushRun;
	    }
	
	    function sort(array, compare, lo, hi) {
	        if (!lo) {
	            lo = 0;
	        }
	        if (!hi) {
	            hi = array.length;
	        }
	
	        var remaining = hi - lo;
	
	        if (remaining < 2) {
	            return;
	        }
	
	        var runLength = 0;
	
	        if (remaining < DEFAULT_MIN_MERGE) {
	            runLength = makeAscendingRun(array, lo, hi, compare);
	            binaryInsertionSort(array, lo, hi, lo + runLength, compare);
	            return;
	        }
	
	        var ts = new TimSort(array, compare);
	
	        var minRun = minRunLength(remaining);
	
	        do {
	            runLength = makeAscendingRun(array, lo, hi, compare);
	            if (runLength < minRun) {
	                var force = remaining;
	                if (force > minRun) {
	                    force = minRun;
	                }
	
	                binaryInsertionSort(array, lo, lo + force, lo + runLength, compare);
	                runLength = force;
	            }
	
	            ts.pushRun(lo, runLength);
	            ts.mergeRuns();
	
	            remaining -= runLength;
	            lo += runLength;
	        } while (remaining !== 0);
	
	        ts.forceMergeRuns();
	    }
	
	    module.exports = sort;


/***/ },
/* 64 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	/**
	 * 动画主类, 调度和管理所有动画控制器
	 *
	 * @module zrender/animation/Animation
	 * @author pissang(https://github.com/pissang)
	 */
	// TODO Additive animation
	// http://iosoteric.com/additive-animations-animatewithduration-in-ios-8/
	// https://developer.apple.com/videos/wwdc2014/#236
	
	
	    var util = __webpack_require__(4);
	    var Dispatcher = __webpack_require__(65).Dispatcher;
	
	    var requestAnimationFrame = __webpack_require__(66);
	
	    var Animator = __webpack_require__(16);
	    /**
	     * @typedef {Object} IZRenderStage
	     * @property {Function} update
	     */
	
	    /**
	     * @alias module:zrender/animation/Animation
	     * @constructor
	     * @param {Object} [options]
	     * @param {Function} [options.onframe]
	     * @param {IZRenderStage} [options.stage]
	     * @example
	     *     var animation = new Animation();
	     *     var obj = {
	     *         x: 100,
	     *         y: 100
	     *     };
	     *     animation.animate(node.position)
	     *         .when(1000, {
	     *             x: 500,
	     *             y: 500
	     *         })
	     *         .when(2000, {
	     *             x: 100,
	     *             y: 100
	     *         })
	     *         .start('spline');
	     */
	    var Animation = function (options) {
	
	        options = options || {};
	
	        this.stage = options.stage || {};
	
	        this.onframe = options.onframe || function() {};
	
	        // private properties
	        this._clips = [];
	
	        this._running = false;
	
	        this._time;
	
	        this._pausedTime;
	
	        this._pauseStart;
	
	        this._paused = false;
	
	        Dispatcher.call(this);
	    };
	
	    Animation.prototype = {
	
	        constructor: Animation,
	        /**
	         * 添加 clip
	         * @param {module:zrender/animation/Clip} clip
	         */
	        addClip: function (clip) {
	            this._clips.push(clip);
	        },
	        /**
	         * 添加 animator
	         * @param {module:zrender/animation/Animator} animator
	         */
	        addAnimator: function (animator) {
	            animator.animation = this;
	            var clips = animator.getClips();
	            for (var i = 0; i < clips.length; i++) {
	                this.addClip(clips[i]);
	            }
	        },
	        /**
	         * 删除动画片段
	         * @param {module:zrender/animation/Clip} clip
	         */
	        removeClip: function(clip) {
	            var idx = util.indexOf(this._clips, clip);
	            if (idx >= 0) {
	                this._clips.splice(idx, 1);
	            }
	        },
	
	        /**
	         * 删除动画片段
	         * @param {module:zrender/animation/Animator} animator
	         */
	        removeAnimator: function (animator) {
	            var clips = animator.getClips();
	            for (var i = 0; i < clips.length; i++) {
	                this.removeClip(clips[i]);
	            }
	            animator.animation = null;
	        },
	
	        _update: function() {
	
	            var time = new Date().getTime() - this._pausedTime;
	            var delta = time - this._time;
	            var clips = this._clips;
	            var len = clips.length;
	
	            var deferredEvents = [];
	            var deferredClips = [];
	            for (var i = 0; i < len; i++) {
	                var clip = clips[i];
	                var e = clip.step(time);
	                // Throw out the events need to be called after
	                // stage.update, like destroy
	                if (e) {
	                    deferredEvents.push(e);
	                    deferredClips.push(clip);
	                }
	            }
	
	            // Remove the finished clip
	            for (var i = 0; i < len;) {
	                if (clips[i]._needsRemove) {
	                    clips[i] = clips[len - 1];
	                    clips.pop();
	                    len--;
	                }
	                else {
	                    i++;
	                }
	            }
	
	            len = deferredEvents.length;
	            for (var i = 0; i < len; i++) {
	                deferredClips[i].fire(deferredEvents[i]);
	            }
	
	            this._time = time;
	
	            this.onframe(delta);
	
	            this.trigger('frame', delta);
	
	            if (this.stage.update) {
	                this.stage.update();
	            }
	        },
	
	        _startLoop: function () {
	            var self = this;
	
	            this._running = true;
	
	            function step() {
	                if (self._running) {
	
	                    requestAnimationFrame(step);
	
	                    !self._paused && self._update();
	                }
	            }
	
	            requestAnimationFrame(step);
	        },
	
	        /**
	         * 开始运行动画
	         */
	        start: function () {
	
	            this._time = new Date().getTime();
	            this._pausedTime = 0;
	
	            this._startLoop();
	        },
	        /**
	         * 停止运行动画
	         */
	        stop: function () {
	            this._running = false;
	        },
	
	        /**
	         * Pause
	         */
	        pause: function () {
	            if (!this._paused) {
	                this._pauseStart = new Date().getTime();
	                this._paused = true;
	            }
	        },
	
	        /**
	         * Resume
	         */
	        resume: function () {
	            if (this._paused) {
	                this._pausedTime += (new Date().getTime()) - this._pauseStart;
	                this._paused = false;
	            }
	        },
	
	        /**
	         * 清除所有动画片段
	         */
	        clear: function () {
	            this._clips = [];
	        },
	        /**
	         * 对一个目标创建一个animator对象，可以指定目标中的属性使用动画
	         * @param  {Object} target
	         * @param  {Object} options
	         * @param  {boolean} [options.loop=false] 是否循环播放动画
	         * @param  {Function} [options.getter=null]
	         *         如果指定getter函数，会通过getter函数取属性值
	         * @param  {Function} [options.setter=null]
	         *         如果指定setter函数，会通过setter函数设置属性值
	         * @return {module:zrender/animation/Animation~Animator}
	         */
	        // TODO Gap
	        animate: function (target, options) {
	            options = options || {};
	            var animator = new Animator(
	                target,
	                options.loop,
	                options.getter,
	                options.setter
	            );
	
	            return animator;
	        }
	    };
	
	    util.mixin(Animation, Dispatcher);
	
	    module.exports = Animation;
	


/***/ },
/* 65 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	/**
	 * 事件辅助类
	 * @module zrender/core/event
	 * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)
	 */
	
	
	    var Eventful = __webpack_require__(11);
	
	    var isDomLevel2 = (typeof window !== 'undefined') && !!window.addEventListener;
	
	    function getBoundingClientRect(el) {
	        // BlackBerry 5, iOS 3 (original iPhone) don't have getBoundingRect
	        return el.getBoundingClientRect ? el.getBoundingClientRect() : {left: 0, top: 0};
	    }
	
	    function clientToLocal(el, e, out) {
	        // clientX/clientY is according to view port.
	        var box = getBoundingClientRect(el);
	        out = out || {};
	        out.zrX = e.clientX - box.left;
	        out.zrY = e.clientY - box.top;
	        return out;
	    }
	
	    /**
	     * 如果存在第三方嵌入的一些dom触发的事件，或touch事件，需要转换一下事件坐标
	     */
	    function normalizeEvent(el, e) {
	
	        e = e || window.event;
	
	        if (e.zrX != null) {
	            return e;
	        }
	
	        var eventType = e.type;
	        var isTouch = eventType && eventType.indexOf('touch') >= 0;
	
	        if (!isTouch) {
	            clientToLocal(el, e, e);
	            e.zrDelta = (e.wheelDelta) ? e.wheelDelta / 120 : -(e.detail || 0) / 3;
	        }
	        else {
	            var touch = eventType != 'touchend'
	                ? e.targetTouches[0]
	                : e.changedTouches[0];
	            touch && clientToLocal(el, touch, e);
	        }
	
	        return e;
	    }
	
	    function addEventListener(el, name, handler) {
	        if (isDomLevel2) {
	            el.addEventListener(name, handler);
	        }
	        else {
	            el.attachEvent('on' + name, handler);
	        }
	    }
	
	    function removeEventListener(el, name, handler) {
	        if (isDomLevel2) {
	            el.removeEventListener(name, handler);
	        }
	        else {
	            el.detachEvent('on' + name, handler);
	        }
	    }
	
	    /**
	     * 停止冒泡和阻止默认行为
	     * @memberOf module:zrender/core/event
	     * @method
	     * @param {Event} e : event对象
	     */
	    var stop = isDomLevel2
	        ? function (e) {
	            e.preventDefault();
	            e.stopPropagation();
	            e.cancelBubble = true;
	        }
	        : function (e) {
	            e.returnValue = false;
	            e.cancelBubble = true;
	        };
	
	    module.exports = {
	        clientToLocal: clientToLocal,
	        normalizeEvent: normalizeEvent,
	        addEventListener: addEventListener,
	        removeEventListener: removeEventListener,
	
	        stop: stop,
	        // 做向上兼容
	        Dispatcher: Eventful
	    };
	


/***/ },
/* 66 */
/***/ function(module, exports) {

	
	
	    module.exports = (typeof window !== 'undefined' &&
	                                    (window.requestAnimationFrame
	                                    || window.msRequestAnimationFrame
	                                    || window.mozRequestAnimationFrame
	                                    || window.webkitRequestAnimationFrame))
	                                || function (func) {
	                                    setTimeout(func, 16);
	                                };
	


/***/ },
/* 67 */
/***/ function(module, exports, __webpack_require__) {

	
	
	    var eventTool = __webpack_require__(65);
	    var zrUtil = __webpack_require__(4);
	    var Eventful = __webpack_require__(11);
	    var env = __webpack_require__(60);
	    var GestureMgr = __webpack_require__(68);
	
	    var addEventListener = eventTool.addEventListener;
	    var removeEventListener = eventTool.removeEventListener;
	    var normalizeEvent = eventTool.normalizeEvent;
	
	    var TOUCH_CLICK_DELAY = 300;
	
	    var mouseHandlerNames = [
	        'click', 'dblclick', 'mousewheel', 'mouseout',
	        'mouseup', 'mousedown', 'mousemove'
	    ];
	
	    var touchHandlerNames = [
	        'touchstart', 'touchend', 'touchmove'
	    ];
	
	    function eventNameFix(name) {
	        return (name === 'mousewheel' && env.browser.firefox) ? 'DOMMouseScroll' : name;
	    }
	
	    function processGesture(proxy, event, stage) {
	        var gestureMgr = proxy._gestureMgr;
	
	        stage === 'start' && gestureMgr.clear();
	
	        var gestureInfo = gestureMgr.recognize(
	            event,
	            proxy.handler.findHover(event.zrX, event.zrY, null),
	            proxy.dom
	        );
	
	        stage === 'end' && gestureMgr.clear();
	
	        if (gestureInfo) {
	            // eventTool.stop(event);
	            var type = gestureInfo.type;
	            event.gestureEvent = type;
	
	            proxy.handler.dispatchToElement(gestureInfo.target, type, gestureInfo.event);
	        }
	    }
	
	    /**
	     * Prevent mouse event from being dispatched after Touch Events action
	     * @see <https://github.com/deltakosh/handjs/blob/master/src/hand.base.js>
	     * 1. Mobile browsers dispatch mouse events 300ms after touchend.
	     * 2. Chrome for Android dispatch mousedown for long-touch about 650ms
	     * Result: Blocking Mouse Events for 700ms.
	     */
	    function setTouchTimer(instance) {
	        instance._touching = true;
	        clearTimeout(instance._touchTimer);
	        instance._touchTimer = setTimeout(function () {
	            instance._touching = false;
	        }, 700);
	    }
	
	    function useTouchEvent() {
	        return env.touchEventsSupported;
	    }
	
	    var domHandlers = {
	        /**
	         * Mouse move handler
	         * @inner
	         * @param {Event} event
	         */
	        mousemove: function (event) {
	            event = normalizeEvent(this.dom, event);
	
	            this.trigger('mousemove', event);
	        },
	
	        /**
	         * Mouse out handler
	         * @inner
	         * @param {Event} event
	         */
	        mouseout: function (event) {
	            event = normalizeEvent(this.dom, event);
	
	            var element = event.toElement || event.relatedTarget;
	            if (element != this.dom) {
	                while (element && element.nodeType != 9) {
	                    // 忽略包含在root中的dom引起的mouseOut
	                    if (element === this.dom) {
	                        return;
	                    }
	
	                    element = element.parentNode;
	                }
	            }
	
	            this.trigger('mouseout', event);
	        },
	
	        /**
	         * Touch开始响应函数
	         * @inner
	         * @param {Event} event
	         */
	        touchstart: function (event) {
	            // Default mouse behaviour should not be disabled here.
	            // For example, page may needs to be slided.
	
	            event = normalizeEvent(this.dom, event);
	
	            this._lastTouchMoment = new Date();
	
	            processGesture(this, event, 'start');
	
	            // 平板补充一次findHover
	            // this._mobileFindFixed(event);
	            // Trigger mousemove and mousedown
	            domHandlers.mousemove.call(this, event);
	
	            domHandlers.mousedown.call(this, event);
	
	            setTouchTimer(this);
	        },
	
	        /**
	         * Touch移动响应函数
	         * @inner
	         * @param {Event} event
	         */
	        touchmove: function (event) {
	
	            event = normalizeEvent(this.dom, event);
	
	            processGesture(this, event, 'change');
	
	            // Mouse move should always be triggered no matter whether
	            // there is gestrue event, because mouse move and pinch may
	            // be used at the same time.
	            domHandlers.mousemove.call(this, event);
	
	            setTouchTimer(this);
	        },
	
	        /**
	         * Touch结束响应函数
	         * @inner
	         * @param {Event} event
	         */
	        touchend: function (event) {
	
	            event = normalizeEvent(this.dom, event);
	
	            processGesture(this, event, 'end');
	
	            domHandlers.mouseup.call(this, event);
	
	            // click event should always be triggered no matter whether
	            // there is gestrue event. System click can not be prevented.
	            if (+new Date() - this._lastTouchMoment < TOUCH_CLICK_DELAY) {
	                domHandlers.click.call(this, event);
	            }
	
	            setTouchTimer(this);
	        }
	    };
	
	    // Common handlers
	    zrUtil.each(['click', 'mousedown', 'mouseup', 'mousewheel', 'dblclick'], function (name) {
	        domHandlers[name] = function (event) {
	            event = normalizeEvent(this.dom, event);
	            this.trigger(name, event);
	        };
	    });
	
	    /**
	     * 为控制类实例初始化dom 事件处理函数
	     *
	     * @inner
	     * @param {module:zrender/Handler} instance 控制类实例
	     */
	    function initDomHandler(instance) {
	        for (var i = 0; i < touchHandlerNames.length; i++) {
	            var name = touchHandlerNames[i];
	            instance._handlers[name] = zrUtil.bind(domHandlers[name], instance);
	        }
	
	        for (var i = 0; i < mouseHandlerNames.length; i++) {
	            var name = mouseHandlerNames[i];
	            instance._handlers[name] = makeMouseHandler(domHandlers[name], instance);
	        }
	
	        function makeMouseHandler(fn, instance) {
	            return function () {
	                if (instance._touching) {
	                    return;
	                }
	                return fn.apply(instance, arguments);
	            };
	        }
	    }
	
	
	    function HandlerDomProxy(dom) {
	        Eventful.call(this);
	
	        this.dom = dom;
	
	        /**
	         * @private
	         * @type {boolean}
	         */
	        this._touching = false;
	
	        /**
	         * @private
	         * @type {number}
	         */
	        this._touchTimer;
	
	        /**
	         * @private
	         * @type {module:zrender/core/GestureMgr}
	         */
	        this._gestureMgr = new GestureMgr();
	
	        this._handlers = {};
	
	        initDomHandler(this);
	
	        if (useTouchEvent()) {
	            mountHandlers(touchHandlerNames, this);
	
	            // Handler of 'mouseout' event is needed in touch mode, which will be mounted below.
	            // addEventListener(root, 'mouseout', this._mouseoutHandler);
	        }
	
	        // Considering some devices that both enable touch and mouse event (like MS Surface
	        // and lenovo X240, @see #2350), we make mouse event be always listened, otherwise
	        // mouse event can not be handle in those devices.
	        mountHandlers(mouseHandlerNames, this);
	
	        function mountHandlers(handlerNames, instance) {
	            zrUtil.each(handlerNames, function (name) {
	                addEventListener(dom, eventNameFix(name), instance._handlers[name]);
	            }, instance);
	        }
	    }
	
	    var handlerDomProxyProto = HandlerDomProxy.prototype;
	    handlerDomProxyProto.dispose = function () {
	        var handlerNames = mouseHandlerNames.concat(touchHandlerNames);
	
	        for (var i = 0; i < handlerNames.length; i++) {
	            var name = handlerNames[i];
	            removeEventListener(this.dom, eventNameFix(name), this._handlers[name]);
	        }
	    };
	
	    handlerDomProxyProto.setCursor = function (cursorStyle) {
	        this.dom.style.cursor = cursorStyle || 'default';
	    };
	
	    zrUtil.mixin(HandlerDomProxy, Eventful);
	
	    module.exports = HandlerDomProxy;


/***/ },
/* 68 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	/**
	 * Only implements needed gestures for mobile.
	 */
	
	
	    var eventUtil = __webpack_require__(65);
	
	    var GestureMgr = function () {
	
	        /**
	         * @private
	         * @type {Array.<Object>}
	         */
	        this._track = [];
	    };
	
	    GestureMgr.prototype = {
	
	        constructor: GestureMgr,
	
	        recognize: function (event, target, root) {
	            this._doTrack(event, target, root);
	            return this._recognize(event);
	        },
	
	        clear: function () {
	            this._track.length = 0;
	            return this;
	        },
	
	        _doTrack: function (event, target, root) {
	            var touches = event.touches;
	
	            if (!touches) {
	                return;
	            }
	
	            var trackItem = {
	                points: [],
	                touches: [],
	                target: target,
	                event: event
	            };
	
	            for (var i = 0, len = touches.length; i < len; i++) {
	                var touch = touches[i];
	                var pos = eventUtil.clientToLocal(root, touch);
	                trackItem.points.push([pos.zrX, pos.zrY]);
	                trackItem.touches.push(touch);
	            }
	
	            this._track.push(trackItem);
	        },
	
	        _recognize: function (event) {
	            for (var eventName in recognizers) {
	                if (recognizers.hasOwnProperty(eventName)) {
	                    var gestureInfo = recognizers[eventName](this._track, event);
	                    if (gestureInfo) {
	                        return gestureInfo;
	                    }
	                }
	            }
	        }
	    };
	
	    function dist(pointPair) {
	        var dx = pointPair[1][0] - pointPair[0][0];
	        var dy = pointPair[1][1] - pointPair[0][1];
	
	        return Math.sqrt(dx * dx + dy * dy);
	    }
	
	    function center(pointPair) {
	        return [
	            (pointPair[0][0] + pointPair[1][0]) / 2,
	            (pointPair[0][1] + pointPair[1][1]) / 2
	        ];
	    }
	
	    var recognizers = {
	
	        pinch: function (track, event) {
	            var trackLen = track.length;
	
	            if (!trackLen) {
	                return;
	            }
	
	            var pinchEnd = (track[trackLen - 1] || {}).points;
	            var pinchPre = (track[trackLen - 2] || {}).points || pinchEnd;
	
	            if (pinchPre
	                && pinchPre.length > 1
	                && pinchEnd
	                && pinchEnd.length > 1
	            ) {
	                var pinchScale = dist(pinchEnd) / dist(pinchPre);
	                !isFinite(pinchScale) && (pinchScale = 1);
	
	                event.pinchScale = pinchScale;
	
	                var pinchCenter = center(pinchEnd);
	                event.pinchX = pinchCenter[0];
	                event.pinchY = pinchCenter[1];
	
	                return {
	                    type: 'pinch',
	                    target: track[0].target,
	                    event: event
	                };
	            }
	        }
	
	        // Only pinch currently.
	    };
	
	    module.exports = GestureMgr;
	


/***/ },
/* 69 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	/**
	 * Default canvas painter
	 * @module zrender/Painter
	 * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)
	 *         errorrik (errorrik@gmail.com)
	 *         pissang (https://www.github.com/pissang)
	 */
	 
	
	    var config = __webpack_require__(21);
	    var util = __webpack_require__(4);
	    var log = __webpack_require__(20);
	    var BoundingRect = __webpack_require__(24);
	    var timsort = __webpack_require__(63);
	
	    var Layer = __webpack_require__(70);
	
	    var requestAnimationFrame = __webpack_require__(66);
	
	    // PENDIGN
	    // Layer exceeds MAX_PROGRESSIVE_LAYER_NUMBER may have some problem when flush directly second time.
	    //
	    // Maximum progressive layer. When exceeding this number. All elements will be drawed in the last layer.
	    var MAX_PROGRESSIVE_LAYER_NUMBER = 5;
	
	    function parseInt10(val) {
	        return parseInt(val, 10);
	    }
	
	    function isLayerValid(layer) {
	        if (!layer) {
	            return false;
	        }
	
	        if (layer.isBuildin) {
	            return true;
	        }
	
	        if (typeof(layer.resize) !== 'function'
	            || typeof(layer.refresh) !== 'function'
	        ) {
	            return false;
	        }
	
	        return true;
	    }
	
	    function preProcessLayer(layer) {
	        layer.__unusedCount++;
	    }
	
	    function postProcessLayer(layer) {
	        if (layer.__unusedCount == 1) {
	            layer.clear();
	        }
	    }
	
	    var tmpRect = new BoundingRect(0, 0, 0, 0);
	    var viewRect = new BoundingRect(0, 0, 0, 0);
	    function isDisplayableCulled(el, width, height) {
	        tmpRect.copy(el.getBoundingRect());
	        if (el.transform) {
	            tmpRect.applyTransform(el.transform);
	        }
	        viewRect.width = width;
	        viewRect.height = height;
	        return !tmpRect.intersect(viewRect);
	    }
	
	    function isClipPathChanged(clipPaths, prevClipPaths) {
	        if (clipPaths == prevClipPaths) { // Can both be null or undefined
	            return false;
	        }
	
	        if (!clipPaths || !prevClipPaths || (clipPaths.length !== prevClipPaths.length)) {
	            return true;
	        }
	        for (var i = 0; i < clipPaths.length; i++) {
	            if (clipPaths[i] !== prevClipPaths[i]) {
	                return true;
	            }
	        }
	    }
	
	    function doClip(clipPaths, ctx) {
	        for (var i = 0; i < clipPaths.length; i++) {
	            var clipPath = clipPaths[i];
	            var path = clipPath.path;
	
	            clipPath.setTransform(ctx);
	            path.beginPath(ctx);
	            clipPath.buildPath(path, clipPath.shape);
	            ctx.clip();
	            // Transform back
	            clipPath.restoreTransform(ctx);
	        }
	    }
	
	    function createRoot(width, height) {
	        var domRoot = document.createElement('div');
	        var domRootStyle = domRoot.style;
	
	        // domRoot.onselectstart = returnFalse; // 避免页面选中的尴尬
	        domRootStyle.position = 'relative';
	        domRootStyle.overflow = 'hidden';
	        domRootStyle.width = width + 'px';
	        domRootStyle.height = height + 'px';
	        return domRoot;
	    }
	
	    /**
	     * @alias module:zrender/Painter
	     * @constructor
	     * @param {HTMLElement} root 绘图容器
	     * @param {module:zrender/Storage} storage
	     * @param {Ojbect} opts
	     */
	    var Painter = function (root, storage, opts) {
	        // In node environment using node-canvas
	        var singleCanvas = !root.nodeName // In node ?
	            || root.nodeName.toUpperCase() === 'CANVAS';
	
	        opts = opts || {};
	
	        /**
	         * @type {number}
	         */
	        this.dpr = opts.devicePixelRatio || config.devicePixelRatio;
	        /**
	         * @type {boolean}
	         * @private
	         */
	        this._singleCanvas = singleCanvas;
	        /**
	         * 绘图容器
	         * @type {HTMLElement}
	         */
	        this.root = root;
	
	        var rootStyle = root.style;
	
	        if (rootStyle) {
	            rootStyle['-webkit-tap-highlight-color'] = 'transparent';
	            rootStyle['-webkit-user-select'] =
	            rootStyle['user-select'] =
	            rootStyle['-webkit-touch-callout'] = 'none';
	
	            root.innerHTML = '';
	        }
	
	        /**
	         * @type {module:zrender/Storage}
	         */
	        this.storage = storage;
	
	        /**
	         * @type {Array.<number>}
	         * @private
	         */
	        var zlevelList = this._zlevelList = [];
	
	        /**
	         * @type {Object.<string, module:zrender/Layer>}
	         * @private
	         */
	        var layers = this._layers = {};
	
	        /**
	         * @type {Object.<string, Object>}
	         * @type {private}
	         */
	        this._layerConfig = {};
	
	        if (!singleCanvas) {
	            this._width = this._getWidth();
	            this._height = this._getHeight();
	
	            var domRoot = this._domRoot = createRoot(
	                this._width, this._height
	            );
	            root.appendChild(domRoot);
	        }
	        else {
	            // Use canvas width and height directly
	            var width = root.width;
	            var height = root.height;
	            this._width = width;
	            this._height = height;
	
	            // Create layer if only one given canvas
	            // Device pixel ratio is fixed to 1 because given canvas has its specified width and height
	            var mainLayer = new Layer(root, this, 1);
	            mainLayer.initContext();
	            // FIXME Use canvas width and height
	            // mainLayer.resize(width, height);
	            layers[0] = mainLayer;
	            zlevelList.push(0);
	        }
	
	        this.pathToImage = this._createPathToImage();
	
	        // Layers for progressive rendering
	        this._progressiveLayers = [];
	
	        /**
	         * @type {module:zrender/Layer}
	         * @private
	         */
	        this._hoverlayer;
	
	        this._hoverElements = [];
	    };
	
	    Painter.prototype = {
	
	        constructor: Painter,
	
	        /**
	         * If painter use a single canvas
	         * @return {boolean}
	         */
	        isSingleCanvas: function () {
	            return this._singleCanvas;
	        },
	        /**
	         * @return {HTMLDivElement}
	         */
	        getViewportRoot: function () {
	            return this._singleCanvas ? this._layers[0].dom : this._domRoot;
	        },
	
	        /**
	         * 刷新
	         * @param {boolean} [paintAll=false] 强制绘制所有displayable
	         */
	        refresh: function (paintAll) {
	
	            var list = this.storage.getDisplayList(true);
	
	            var zlevelList = this._zlevelList;
	
	            this._paintList(list, paintAll);
	
	            // Paint custum layers
	            for (var i = 0; i < zlevelList.length; i++) {
	                var z = zlevelList[i];
	                var layer = this._layers[z];
	                if (!layer.isBuildin && layer.refresh) {
	                    layer.refresh();
	                }
	            }
	
	            this.refreshHover();
	
	            if (this._progressiveLayers.length) {
	                this._startProgessive();
	            }
	
	            return this;
	        },
	
	        addHover: function (el, hoverStyle) {
	            if (el.__hoverMir) {
	                return;
	            }
	            var elMirror = new el.constructor({
	                style: el.style,
	                shape: el.shape
	            });
	            elMirror.__from = el;
	            el.__hoverMir = elMirror;
	            elMirror.setStyle(hoverStyle);
	            this._hoverElements.push(elMirror);
	        },
	
	        removeHover: function (el) {
	            var elMirror = el.__hoverMir;
	            var hoverElements = this._hoverElements;
	            var idx = util.indexOf(hoverElements, elMirror);
	            if (idx >= 0) {
	                hoverElements.splice(idx, 1);
	            }
	            el.__hoverMir = null;
	        },
	
	        clearHover: function (el) {
	            var hoverElements = this._hoverElements;
	            for (var i = 0; i < hoverElements.length; i++) {
	                var from = hoverElements[i].__from;
	                if (from) {
	                    from.__hoverMir = null;
	                }
	            }
	            hoverElements.length = 0;
	        },
	
	        refreshHover: function () {
	            var hoverElements = this._hoverElements;
	            var len = hoverElements.length;
	            var hoverLayer = this._hoverlayer;
	            hoverLayer && hoverLayer.clear();
	
	            if (!len) {
	                return;
	            }
	            timsort(hoverElements, this.storage.displayableSortFunc);
	
	            // Use a extream large zlevel
	            // FIXME?
	            if (!hoverLayer) {
	                hoverLayer = this._hoverlayer = this.getLayer(1e5);
	            }
	
	            var scope = {};
	            hoverLayer.ctx.save();
	            for (var i = 0; i < len;) {
	                var el = hoverElements[i];
	                var originalEl = el.__from;
	                // Original el is removed
	                // PENDING
	                if (!(originalEl && originalEl.__zr)) {
	                    hoverElements.splice(i, 1);
	                    originalEl.__hoverMir = null;
	                    len--;
	                    continue;
	                }
	                i++;
	
	                // Use transform
	                // FIXME style and shape ?
	                if (!originalEl.invisible) {
	                    el.transform = originalEl.transform;
	                    el.invTransform = originalEl.invTransform;
	                    el.__clipPaths = originalEl.__clipPaths;
	                    // el.
	                    this._doPaintEl(el, hoverLayer, true, scope);
	                }
	            }
	            hoverLayer.ctx.restore();
	        },
	
	        _startProgessive: function () {
	            var self = this;
	
	            if (!self._furtherProgressive) {
	                return;
	            }
	
	            // Use a token to stop progress steps triggered by
	            // previous zr.refresh calling.
	            var token = self._progressiveToken = +new Date();
	
	            self._progress++;
	            requestAnimationFrame(step);
	
	            function step() {
	                // In case refreshed or disposed
	                if (token === self._progressiveToken && self.storage) {
	
	                    self._doPaintList(self.storage.getDisplayList());
	
	                    if (self._furtherProgressive) {
	                        self._progress++;
	                        requestAnimationFrame(step);
	                    }
	                    else {
	                        self._progressiveToken = -1;
	                    }
	                }
	            }
	        },
	
	        _clearProgressive: function () {
	            this._progressiveToken = -1;
	            this._progress = 0;
	            util.each(this._progressiveLayers, function (layer) {
	                layer.__dirty && layer.clear();
	            });
	        },
	
	        _paintList: function (list, paintAll) {
	
	            if (paintAll == null) {
	                paintAll = false;
	            }
	
	            this._updateLayerStatus(list);
	
	            this._clearProgressive();
	
	            this.eachBuildinLayer(preProcessLayer);
	
	            this._doPaintList(list, paintAll);
	
	            this.eachBuildinLayer(postProcessLayer);
	        },
	
	        _doPaintList: function (list, paintAll) {
	            var currentLayer;
	            var currentZLevel;
	            var ctx;
	
	            // var invTransform = [];
	            var scope;
	
	            var progressiveLayerIdx = 0;
	            var currentProgressiveLayer;
	
	            var width = this._width;
	            var height = this._height;
	            var layerProgress;
	            var frame = this._progress;
	            function flushProgressiveLayer(layer) {
	                var dpr = ctx.dpr || 1;
	                ctx.save();
	                ctx.globalAlpha = 1;
	                ctx.shadowBlur = 0;
	                // Avoid layer don't clear in next progressive frame
	                currentLayer.__dirty = true;
	                ctx.setTransform(1, 0, 0, 1, 0, 0);
	                ctx.drawImage(layer.dom, 0, 0, width * dpr, height * dpr);
	                ctx.restore();
	            }
	
	            for (var i = 0, l = list.length; i < l; i++) {
	                var el = list[i];
	                var elZLevel = this._singleCanvas ? 0 : el.zlevel;
	
	                var elFrame = el.__frame;
	
	                // Flush at current context
	                // PENDING
	                if (elFrame < 0 && currentProgressiveLayer) {
	                    flushProgressiveLayer(currentProgressiveLayer);
	                    currentProgressiveLayer = null;
	                }
	
	                // Change draw layer
	                if (currentZLevel !== elZLevel) {
	                    if (ctx) {
	                        ctx.restore();
	                    }
	
	                    // Reset scope
	                    scope = {};
	
	                    // Only 0 zlevel if only has one canvas
	                    currentZLevel = elZLevel;
	                    currentLayer = this.getLayer(currentZLevel);
	
	                    if (!currentLayer.isBuildin) {
	                        log(
	                            'ZLevel ' + currentZLevel
	                            + ' has been used by unkown layer ' + currentLayer.id
	                        );
	                    }
	
	                    ctx = currentLayer.ctx;
	                    ctx.save();
	
	                    // Reset the count
	                    currentLayer.__unusedCount = 0;
	
	                    if (currentLayer.__dirty || paintAll) {
	                        currentLayer.clear();
	                    }
	                }
	
	                if (!(currentLayer.__dirty || paintAll)) {
	                    continue;
	                }
	
	                if (elFrame >= 0) {
	                    // Progressive layer changed
	                    if (!currentProgressiveLayer) {
	                        currentProgressiveLayer = this._progressiveLayers[
	                            Math.min(progressiveLayerIdx++, MAX_PROGRESSIVE_LAYER_NUMBER - 1)
	                        ];
	
	                        currentProgressiveLayer.ctx.save();
	                        currentProgressiveLayer.renderScope = {};
	
	                        if (currentProgressiveLayer
	                            && (currentProgressiveLayer.__progress > currentProgressiveLayer.__maxProgress)
	                        ) {
	                            // flushProgressiveLayer(currentProgressiveLayer);
	                            // Quick jump all progressive elements
	                            // All progressive element are not dirty, jump over and flush directly
	                            i = currentProgressiveLayer.__nextIdxNotProg - 1;
	                            // currentProgressiveLayer = null;
	                            continue;
	                        }
	
	                        layerProgress = currentProgressiveLayer.__progress;
	
	                        if (!currentProgressiveLayer.__dirty) {
	                            // Keep rendering
	                            frame = layerProgress;
	                        }
	
	                        currentProgressiveLayer.__progress = frame + 1;
	                    }
	
	                    if (elFrame === frame) {
	                        this._doPaintEl(el, currentProgressiveLayer, true, currentProgressiveLayer.renderScope);
	                    }
	                }
	                else {
	                    this._doPaintEl(el, currentLayer, paintAll, scope);
	                }
	
	                el.__dirty = false;
	            }
	
	            if (currentProgressiveLayer) {
	                flushProgressiveLayer(currentProgressiveLayer);
	            }
	
	            // Restore the lastLayer ctx
	            ctx && ctx.restore();
	            // If still has clipping state
	            // if (scope.prevElClipPaths) {
	            //     ctx.restore();
	            // }
	
	            this._furtherProgressive = false;
	            util.each(this._progressiveLayers, function (layer) {
	                if (layer.__maxProgress >= layer.__progress) {
	                    this._furtherProgressive = true;
	                }
	            }, this);
	        },
	
	        _doPaintEl: function (el, currentLayer, forcePaint, scope) {
	            var ctx = currentLayer.ctx;
	            var m = el.transform;
	            if (
	                (currentLayer.__dirty || forcePaint)
	                // Ignore invisible element
	                && !el.invisible
	                // Ignore transparent element
	                && el.style.opacity !== 0
	                // Ignore scale 0 element, in some environment like node-canvas
	                // Draw a scale 0 element can cause all following draw wrong
	                // And setTransform with scale 0 will cause set back transform failed.
	                && !(m && !m[0] && !m[3])
	                // Ignore culled element
	                && !(el.culling && isDisplayableCulled(el, this._width, this._height))
	            ) {
	
	                var clipPaths = el.__clipPaths;
	
	                // Optimize when clipping on group with several elements
	                if (scope.prevClipLayer !== currentLayer
	                    || isClipPathChanged(clipPaths, scope.prevElClipPaths)
	                ) {
	                    // If has previous clipping state, restore from it
	                    if (scope.prevElClipPaths) {
	                        scope.prevClipLayer.ctx.restore();
	                        scope.prevClipLayer = scope.prevElClipPaths = null;
	
	                        // Reset prevEl since context has been restored
	                        scope.prevEl = null;
	                    }
	                    // New clipping state
	                    if (clipPaths) {
	                        ctx.save();
	                        doClip(clipPaths, ctx);
	                        scope.prevClipLayer = currentLayer;
	                        scope.prevElClipPaths = clipPaths;
	                    }
	                }
	                el.beforeBrush && el.beforeBrush(ctx);
	
	                el.brush(ctx, scope.prevEl || null);
	                scope.prevEl = el;
	
	                el.afterBrush && el.afterBrush(ctx);
	            }
	        },
	
	        /**
	         * 获取 zlevel 所在层，如果不存在则会创建一个新的层
	         * @param {number} zlevel
	         * @return {module:zrender/Layer}
	         */
	        getLayer: function (zlevel) {
	            if (this._singleCanvas) {
	                return this._layers[0];
	            }
	
	            var layer = this._layers[zlevel];
	            if (!layer) {
	                // Create a new layer
	                layer = new Layer('zr_' + zlevel, this, this.dpr);
	                layer.isBuildin = true;
	
	                if (this._layerConfig[zlevel]) {
	                    util.merge(layer, this._layerConfig[zlevel], true);
	                }
	
	                this.insertLayer(zlevel, layer);
	
	                // Context is created after dom inserted to document
	                // Or excanvas will get 0px clientWidth and clientHeight
	                layer.initContext();
	            }
	
	            return layer;
	        },
	
	        insertLayer: function (zlevel, layer) {
	
	            var layersMap = this._layers;
	            var zlevelList = this._zlevelList;
	            var len = zlevelList.length;
	            var prevLayer = null;
	            var i = -1;
	            var domRoot = this._domRoot;
	
	            if (layersMap[zlevel]) {
	                log('ZLevel ' + zlevel + ' has been used already');
	                return;
	            }
	            // Check if is a valid layer
	            if (!isLayerValid(layer)) {
	                log('Layer of zlevel ' + zlevel + ' is not valid');
	                return;
	            }
	
	            if (len > 0 && zlevel > zlevelList[0]) {
	                for (i = 0; i < len - 1; i++) {
	                    if (
	                        zlevelList[i] < zlevel
	                        && zlevelList[i + 1] > zlevel
	                    ) {
	                        break;
	                    }
	                }
	                prevLayer = layersMap[zlevelList[i]];
	            }
	            zlevelList.splice(i + 1, 0, zlevel);
	
	            if (prevLayer) {
	                var prevDom = prevLayer.dom;
	                if (prevDom.nextSibling) {
	                    domRoot.insertBefore(
	                        layer.dom,
	                        prevDom.nextSibling
	                    );
	                }
	                else {
	                    domRoot.appendChild(layer.dom);
	                }
	            }
	            else {
	                if (domRoot.firstChild) {
	                    domRoot.insertBefore(layer.dom, domRoot.firstChild);
	                }
	                else {
	                    domRoot.appendChild(layer.dom);
	                }
	            }
	
	            layersMap[zlevel] = layer;
	        },
	
	        // Iterate each layer
	        eachLayer: function (cb, context) {
	            var zlevelList = this._zlevelList;
	            var z;
	            var i;
	            for (i = 0; i < zlevelList.length; i++) {
	                z = zlevelList[i];
	                cb.call(context, this._layers[z], z);
	            }
	        },
	
	        // Iterate each buildin layer
	        eachBuildinLayer: function (cb, context) {
	            var zlevelList = this._zlevelList;
	            var layer;
	            var z;
	            var i;
	            for (i = 0; i < zlevelList.length; i++) {
	                z = zlevelList[i];
	                layer = this._layers[z];
	                if (layer.isBuildin) {
	                    cb.call(context, layer, z);
	                }
	            }
	        },
	
	        // Iterate each other layer except buildin layer
	        eachOtherLayer: function (cb, context) {
	            var zlevelList = this._zlevelList;
	            var layer;
	            var z;
	            var i;
	            for (i = 0; i < zlevelList.length; i++) {
	                z = zlevelList[i];
	                layer = this._layers[z];
	                if (! layer.isBuildin) {
	                    cb.call(context, layer, z);
	                }
	            }
	        },
	
	        /**
	         * 获取所有已创建的层
	         * @param {Array.<module:zrender/Layer>} [prevLayer]
	         */
	        getLayers: function () {
	            return this._layers;
	        },
	
	        _updateLayerStatus: function (list) {
	
	            var layers = this._layers;
	            var progressiveLayers = this._progressiveLayers;
	
	            var elCountsLastFrame = {};
	            var progressiveElCountsLastFrame = {};
	
	            this.eachBuildinLayer(function (layer, z) {
	                elCountsLastFrame[z] = layer.elCount;
	                layer.elCount = 0;
	                layer.__dirty = false;
	            });
	
	            util.each(progressiveLayers, function (layer, idx) {
	                progressiveElCountsLastFrame[idx] = layer.elCount;
	                layer.elCount = 0;
	                layer.__dirty = false;
	            });
	
	            var progressiveLayerCount = 0;
	            var currentProgressiveLayer;
	            var lastProgressiveKey;
	            var frameCount = 0;
	            for (var i = 0, l = list.length; i < l; i++) {
	                var el = list[i];
	                var zlevel = this._singleCanvas ? 0 : el.zlevel;
	                var layer = layers[zlevel];
	                var elProgress = el.progressive;
	                if (layer) {
	                    layer.elCount++;
	                    layer.__dirty = layer.__dirty || el.__dirty;
	                }
	
	                /////// Update progressive
	                if (elProgress >= 0) {
	                    // Fix wrong progressive sequence problem.
	                    if (lastProgressiveKey !== elProgress) {
	                        lastProgressiveKey = elProgress;
	                        frameCount++;
	                    }
	                    var elFrame = el.__frame = frameCount - 1;
	                    if (!currentProgressiveLayer) {
	                        var idx = Math.min(progressiveLayerCount, MAX_PROGRESSIVE_LAYER_NUMBER - 1);
	                        currentProgressiveLayer = progressiveLayers[idx];
	                        if (!currentProgressiveLayer) {
	                            currentProgressiveLayer = progressiveLayers[idx] = new Layer(
	                                'progressive', this, this.dpr
	                            );
	                            currentProgressiveLayer.initContext();
	                        }
	                        currentProgressiveLayer.__maxProgress = 0;
	                    }
	                    currentProgressiveLayer.__dirty = currentProgressiveLayer.__dirty || el.__dirty;
	                    currentProgressiveLayer.elCount++;
	
	                    currentProgressiveLayer.__maxProgress = Math.max(
	                        currentProgressiveLayer.__maxProgress, elFrame
	                    );
	
	                    if (currentProgressiveLayer.__maxProgress >= currentProgressiveLayer.__progress) {
	                        // Should keep rendering this  layer because progressive rendering is not finished yet
	                        layer.__dirty = true;
	                    }
	                }
	                else {
	                    el.__frame = -1;
	
	                    if (currentProgressiveLayer) {
	                        currentProgressiveLayer.__nextIdxNotProg = i;
	                        progressiveLayerCount++;
	                        currentProgressiveLayer = null;
	                    }
	                }
	            }
	
	            if (currentProgressiveLayer) {
	                progressiveLayerCount++;
	                currentProgressiveLayer.__nextIdxNotProg = i;
	            }
	
	            // 层中的元素数量有发生变化
	            this.eachBuildinLayer(function (layer, z) {
	                if (elCountsLastFrame[z] !== layer.elCount) {
	                    layer.__dirty = true;
	                }
	            });
	
	            progressiveLayers.length = Math.min(progressiveLayerCount, MAX_PROGRESSIVE_LAYER_NUMBER);
	            util.each(progressiveLayers, function (layer, idx) {
	                if (progressiveElCountsLastFrame[idx] !== layer.elCount) {
	                    el.__dirty = true;
	                }
	                if (layer.__dirty) {
	                    layer.__progress = 0;
	                }
	            });
	        },
	
	        /**
	         * 清除hover层外所有内容
	         */
	        clear: function () {
	            this.eachBuildinLayer(this._clearLayer);
	            return this;
	        },
	
	        _clearLayer: function (layer) {
	            layer.clear();
	        },
	
	        /**
	         * 修改指定zlevel的绘制参数
	         *
	         * @param {string} zlevel
	         * @param {Object} config 配置对象
	         * @param {string} [config.clearColor=0] 每次清空画布的颜色
	         * @param {string} [config.motionBlur=false] 是否开启动态模糊
	         * @param {number} [config.lastFrameAlpha=0.7]
	         *                 在开启动态模糊的时候使用，与上一帧混合的alpha值，值越大尾迹越明显
	         */
	        configLayer: function (zlevel, config) {
	            if (config) {
	                var layerConfig = this._layerConfig;
	                if (!layerConfig[zlevel]) {
	                    layerConfig[zlevel] = config;
	                }
	                else {
	                    util.merge(layerConfig[zlevel], config, true);
	                }
	
	                var layer = this._layers[zlevel];
	
	                if (layer) {
	                    util.merge(layer, layerConfig[zlevel], true);
	                }
	            }
	        },
	
	        /**
	         * 删除指定层
	         * @param {number} zlevel 层所在的zlevel
	         */
	        delLayer: function (zlevel) {
	            var layers = this._layers;
	            var zlevelList = this._zlevelList;
	            var layer = layers[zlevel];
	            if (!layer) {
	                return;
	            }
	            layer.dom.parentNode.removeChild(layer.dom);
	            delete layers[zlevel];
	
	            zlevelList.splice(util.indexOf(zlevelList, zlevel), 1);
	        },
	
	        /**
	         * 区域大小变化后重绘
	         */
	        resize: function (width, height) {
	            var domRoot = this._domRoot;
	            // FIXME Why ?
	            domRoot.style.display = 'none';
	
	            width = width || this._getWidth();
	            height = height || this._getHeight();
	
	            domRoot.style.display = '';
	
	            // 优化没有实际改变的resize
	            if (this._width != width || height != this._height) {
	                domRoot.style.width = width + 'px';
	                domRoot.style.height = height + 'px';
	
	                for (var id in this._layers) {
	                    this._layers[id].resize(width, height);
	                }
	
	                this.refresh(true);
	            }
	
	            this._width = width;
	            this._height = height;
	
	            return this;
	        },
	
	        /**
	         * 清除单独的一个层
	         * @param {number} zlevel
	         */
	        clearLayer: function (zlevel) {
	            var layer = this._layers[zlevel];
	            if (layer) {
	                layer.clear();
	            }
	        },
	
	        /**
	         * 释放
	         */
	        dispose: function () {
	            this.root.innerHTML = '';
	
	            this.root =
	            this.storage =
	
	            this._domRoot =
	            this._layers = null;
	        },
	
	        /**
	         * Get canvas which has all thing rendered
	         * @param {Object} opts
	         * @param {string} [opts.backgroundColor]
	         */
	        getRenderedCanvas: function (opts) {
	            opts = opts || {};
	            if (this._singleCanvas) {
	                return this._layers[0].dom;
	            }
	
	            var imageLayer = new Layer('image', this, opts.pixelRatio || this.dpr);
	            imageLayer.initContext();
	
	            imageLayer.clearColor = opts.backgroundColor;
	            imageLayer.clear();
	
	            var displayList = this.storage.getDisplayList(true);
	
	            var scope = {};
	            for (var i = 0; i < displayList.length; i++) {
	                var el = displayList[i];
	                this._doPaintEl(el, imageLayer, true, scope);
	            }
	
	            return imageLayer.dom;
	        },
	        /**
	         * 获取绘图区域宽度
	         */
	        getWidth: function () {
	            return this._width;
	        },
	
	        /**
	         * 获取绘图区域高度
	         */
	        getHeight: function () {
	            return this._height;
	        },
	
	        _getWidth: function () {
	            var root = this.root;
	            var stl = document.defaultView.getComputedStyle(root);
	
	            // FIXME Better way to get the width and height when element has not been append to the document
	            return ((root.clientWidth || parseInt10(stl.width) || parseInt10(root.style.width))
	                    - (parseInt10(stl.paddingLeft) || 0)
	                    - (parseInt10(stl.paddingRight) || 0)) | 0;
	        },
	
	        _getHeight: function () {
	            var root = this.root;
	            var stl = document.defaultView.getComputedStyle(root);
	
	            return ((root.clientHeight || parseInt10(stl.height) || parseInt10(root.style.height))
	                    - (parseInt10(stl.paddingTop) || 0)
	                    - (parseInt10(stl.paddingBottom) || 0)) | 0;
	        },
	
	        _pathToImage: function (id, path, width, height, dpr) {
	            var canvas = document.createElement('canvas');
	            var ctx = canvas.getContext('2d');
	
	            canvas.width = width * dpr;
	            canvas.height = height * dpr;
	
	            ctx.clearRect(0, 0, width * dpr, height * dpr);
	
	            var pathTransform = {
	                position: path.position,
	                rotation: path.rotation,
	                scale: path.scale
	            };
	            path.position = [0, 0, 0];
	            path.rotation = 0;
	            path.scale = [1, 1];
	            if (path) {
	                path.brush(ctx);
	            }
	
	            var ImageShape = __webpack_require__(40);
	            var imgShape = new ImageShape({
	                id: id,
	                style: {
	                    x: 0,
	                    y: 0,
	                    image: canvas
	                }
	            });
	
	            if (pathTransform.position != null) {
	                imgShape.position = path.position = pathTransform.position;
	            }
	
	            if (pathTransform.rotation != null) {
	                imgShape.rotation = path.rotation = pathTransform.rotation;
	            }
	
	            if (pathTransform.scale != null) {
	                imgShape.scale = path.scale = pathTransform.scale;
	            }
	
	            return imgShape;
	        },
	
	        _createPathToImage: function () {
	            var me = this;
	
	            return function (id, e, width, height) {
	                return me._pathToImage(
	                    id, e, width, height, me.dpr
	                );
	            };
	        }
	    };
	
	    module.exports = Painter;
	


/***/ },
/* 70 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @module zrender/Layer
	 * @author pissang(https://www.github.com/pissang)
	 */
	
	
	    var util = __webpack_require__(4);
	    var config = __webpack_require__(21);
	    var Style = __webpack_require__(8);
	    var Pattern = __webpack_require__(35);
	
	    function returnFalse() {
	        return false;
	    }
	
	    /**
	     * 创建dom
	     *
	     * @inner
	     * @param {string} id dom id 待用
	     * @param {string} type dom type，such as canvas, div etc.
	     * @param {Painter} painter painter instance
	     * @param {number} number
	     */
	    function createDom(id, type, painter, dpr) {
	        var newDom = document.createElement(type);
	        var width = painter.getWidth();
	        var height = painter.getHeight();
	
	        var newDomStyle = newDom.style;
	        // 没append呢，请原谅我这样写，清晰~
	        newDomStyle.position = 'absolute';
	        newDomStyle.left = 0;
	        newDomStyle.top = 0;
	        newDomStyle.width = width + 'px';
	        newDomStyle.height = height + 'px';
	        newDom.width = width * dpr;
	        newDom.height = height * dpr;
	
	        // id不作为索引用，避免可能造成的重名，定义为私有属性
	        newDom.setAttribute('data-zr-dom-id', id);
	        return newDom;
	    }
	
	    /**
	     * @alias module:zrender/Layer
	     * @constructor
	     * @extends module:zrender/mixin/Transformable
	     * @param {string} id
	     * @param {module:zrender/Painter} painter
	     * @param {number} [dpr]
	     */
	    var Layer = function(id, painter, dpr) {
	        var dom;
	        dpr = dpr || config.devicePixelRatio;
	        if (typeof id === 'string') {
	            dom = createDom(id, 'canvas', painter, dpr);
	        }
	        // Not using isDom because in node it will return false
	        else if (util.isObject(id)) {
	            dom = id;
	            id = dom.id;
	        }
	        this.id = id;
	        this.dom = dom;
	
	        var domStyle = dom.style;
	        if (domStyle) { // Not in node
	            dom.onselectstart = returnFalse; // 避免页面选中的尴尬
	            domStyle['-webkit-user-select'] = 'none';
	            domStyle['user-select'] = 'none';
	            domStyle['-webkit-touch-callout'] = 'none';
	            domStyle['-webkit-tap-highlight-color'] = 'rgba(0,0,0,0)';
	        }
	
	        this.domBack = null;
	        this.ctxBack = null;
	
	        this.painter = painter;
	
	        this.config = null;
	
	        // Configs
	        /**
	         * 每次清空画布的颜色
	         * @type {string}
	         * @default 0
	         */
	        this.clearColor = 0;
	        /**
	         * 是否开启动态模糊
	         * @type {boolean}
	         * @default false
	         */
	        this.motionBlur = false;
	        /**
	         * 在开启动态模糊的时候使用，与上一帧混合的alpha值，值越大尾迹越明显
	         * @type {number}
	         * @default 0.7
	         */
	        this.lastFrameAlpha = 0.7;
	
	        /**
	         * Layer dpr
	         * @type {number}
	         */
	        this.dpr = dpr;
	    };
	
	    Layer.prototype = {
	
	        constructor: Layer,
	
	        elCount: 0,
	
	        __dirty: true,
	
	        initContext: function () {
	            this.ctx = this.dom.getContext('2d');
	
	            this.ctx.dpr = this.dpr;
	        },
	
	        createBackBuffer: function () {
	            var dpr = this.dpr;
	
	            this.domBack = createDom('back-' + this.id, 'canvas', this.painter, dpr);
	            this.ctxBack = this.domBack.getContext('2d');
	
	            if (dpr != 1) {
	                this.ctxBack.scale(dpr, dpr);
	            }
	        },
	
	        /**
	         * @param  {number} width
	         * @param  {number} height
	         */
	        resize: function (width, height) {
	            var dpr = this.dpr;
	
	            var dom = this.dom;
	            var domStyle = dom.style;
	            var domBack = this.domBack;
	
	            domStyle.width = width + 'px';
	            domStyle.height = height + 'px';
	
	            dom.width = width * dpr;
	            dom.height = height * dpr;
	
	            if (domBack) {
	                domBack.width = width * dpr;
	                domBack.height = height * dpr;
	
	                if (dpr != 1) {
	                    this.ctxBack.scale(dpr, dpr);
	                }
	            }
	        },
	
	        /**
	         * 清空该层画布
	         * @param {boolean} clearAll Clear all with out motion blur
	         */
	        clear: function (clearAll) {
	            var dom = this.dom;
	            var ctx = this.ctx;
	            var width = dom.width;
	            var height = dom.height;
	
	            var clearColor = this.clearColor;
	            var haveMotionBLur = this.motionBlur && !clearAll;
	            var lastFrameAlpha = this.lastFrameAlpha;
	
	            var dpr = this.dpr;
	
	            if (haveMotionBLur) {
	                if (!this.domBack) {
	                    this.createBackBuffer();
	                }
	
	                this.ctxBack.globalCompositeOperation = 'copy';
	                this.ctxBack.drawImage(
	                    dom, 0, 0,
	                    width / dpr,
	                    height / dpr
	                );
	            }
	
	            ctx.clearRect(0, 0, width, height);
	            if (clearColor) {
	                var clearColorGradientOrPattern;
	                // Gradient
	                if (clearColor.colorStops) {
	                    // Cache canvas gradient
	                    clearColorGradientOrPattern = clearColor.__canvasGradient || Style.getGradient(ctx, clearColor, {
	                        x: 0,
	                        y: 0,
	                        width: width,
	                        height: height
	                    });
	
	                    clearColor.__canvasGradient = clearColorGradientOrPattern;
	                }
	                // Pattern
	                else if (clearColor.image) {
	                    clearColorGradientOrPattern = Pattern.prototype.getCanvasPattern.call(clearColor, ctx);
	                }
	                ctx.save();
	                ctx.fillStyle = clearColorGradientOrPattern || clearColor;
	                ctx.fillRect(0, 0, width, height);
	                ctx.restore();
	            }
	
	            if (haveMotionBLur) {
	                var domBack = this.domBack;
	                ctx.save();
	                ctx.globalAlpha = lastFrameAlpha;
	                ctx.drawImage(domBack, 0, 0, width, height);
	                ctx.restore();
	            }
	        }
	    };
	
	    module.exports = Layer;


/***/ },
/* 71 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * 工具方法类
	 * @author wang.xiaohu
	 */
	
	    var Point = __webpack_require__(72);
	    var Line = __webpack_require__(73);
	    var graphic = __webpack_require__(3);
	    var BoundingRect = __webpack_require__(24);
	    var zrUtil = __webpack_require__(4);
	    /**
	     * 构造类继承关系
	     *
	     * @param {Function} clazz 源类
	     * @param {Function} baseClazz 基类
	     */
	    function inherits(clazz, baseClazz) {
	        var clazzPrototype = clazz.prototype;
	
	        function F() {}
	        F.prototype = baseClazz.prototype;
	        clazz.prototype = new F();
	
	        for (var prop in clazzPrototype) {
	            clazz.prototype[prop] = clazzPrototype[prop];
	        }
	        clazz.prototype.constructor = clazz;
	        clazz.superClass = baseClazz;
	    }
	
	    function getUUID() {
	        var chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split(''),
	            uuid = new Array(36),
	            rnd = 0,
	            r;
	        for (var i = 0; i < 36; i++) {
	            if (i == 8 || i == 13 || i == 18 || i == 23) {
	                uuid[i] = '-';
	            } else if (i == 14) {
	                uuid[i] = '4';
	            } else {
	                if (rnd <= 0x02) rnd = 0x2000000 + (Math.random() * 0x1000000) | 0;
	                r = rnd & 0xf;
	                rnd = rnd >> 4;
	                uuid[i] = chars[(i == 19) ? (r & 0x3) | 0x8 : r];
	            }
	        }
	        return "sid-" + uuid.join('');
	    }
	
	
	    /**
	     * 计算两点之间的距离
	     *@param {Point} p1 - first {Point}
	     *@param {Point} p2 - second {Point}
	     *@return {Number} - the distance between those 2 points. It is always positive.
	     **/
	    function distance(p1, p2) {
	        return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
	    }
	
	    /**
	     * 返回一条折线 最长的两个点
	     * @param  {[type]} points [description]
	     * @return {[type]}        [description]
	     */
	    function getMaxLineLength(points) {
	        var m = distance(points[0], points[1]);
	        var result = [points[0], points[1]];
	        for (var i = 1; i < points.length - 1; i++) {
	
	            if (m < distance(points[i], points[i + 1])) {
	                m = distance(points[i], points[i + 1])
	                result = [points[i], points[i + 1]];
	            }
	        }
	
	        return result;
	    }
	
	    /**Returns the length of a Polyline that would be created with a set of points
	     *@param {Array} v - an {Array} of {Points}
	     *@return {Number} - a positive number equal with total length*/
	    function getPolylineLength(v) {
	        var l = 0;
	        for (var i = 0; i < v.length - 1; i++) {
	            l += distance(v[i], v[i + 1]);
	        }
	
	        return l;
	    }
	
	
	    /**Returns the max of a vector
	     *@param {Array} v - vector of {Number}s
	     *@return {Number} - the maximum number from the vector or NaN if vector is empty
	     **/
	    function max(v) {
	        if (v.lenght == 0) {
	            return NaN;
	        } else {
	            var m = v[0];
	            for (var i = 0; i < v.length; i++) {
	                if (m < v[i]) {
	                    m = v[i];
	                }
	            }
	
	            return m;
	        }
	    }
	
	
	    /**Returns the min of a vector
	     *@param {Array} v - vector of {Number}s
	     *@return {Number} - the minimum number from the vector or NaN if vector is empty
	     *@author alex@scriptoid.com
	     **/
	    function min(v) {
	        if (v.lenght == 0) {
	            return NaN;
	        } else {
	            var m = v[0];
	            for (var i = 0; i < v.length; i++) {
	                if (m > v[i]) {
	                    m = v[i];
	                }
	            }
	
	            return m;
	        }
	    }
	
	    /**
	     * 判断 点数组 是否正交直线路径
	     *Tests if a vector of points is an orthogonal path (moving in multiples of 90 degrees)
	     *@param {Array} v - an {Array} of {Point}s
	     *@return {Boolean} - true if path is valid, false otherwise
	     **/
	    function orthogonalPath(v) {
	        if (v.length <= 1) {
	            return true;
	        }
	
	        for (var i = 0; i < v.length - 1; i++) {
	            if (v[i].x != v[i + 1].x && v[i].y != v[i + 1].y) {
	                return false;
	            }
	        }
	
	        return true;
	    }
	
	
	    /**
	     *Test to see if 2 {Line}s intersects. They are considered finite segments
	     *and not the infinite lines from geometry
	     *@param {Line} l1 - fist line/segment
	     *@param {Line} l2 - last line/segment
	     *@return {Boolean} true - if the lines intersect or false if not
	     **/
	    function lineIntersectsLine(l1, l2) {
	        // check for two vertical lines
	        if (l1.startPoint.x == l1.endPoint.x && l2.startPoint.x == l2.endPoint.x) {
	            return l1.startPoint.x == l2.startPoint.x ? // if 'infinite 'lines do coincide,
	                // then check segment bounds for overlapping
	                l1.contains(l2.startPoint.x, l2.startPoint.y) ||
	                l1.contains(l2.endPoint.x, l2.endPoint.y) :
	                // lines are paralel
	                false;
	        }
	        // if one line is vertical, and another line is not vertical
	        else if (l1.startPoint.x == l1.endPoint.x || l2.startPoint.x == l2.endPoint.x) {
	            // let assume l2 is vertical, otherwise exchange them
	            if (l1.startPoint.x == l1.endPoint.x) {
	                var l = l1;
	                l1 = l2;
	                l2 = l;
	            }
	            // finding intersection of 'infinite' lines
	            // equation of the first line is y = ax + b, second: x = c
	            var a = (l1.endPoint.y - l1.startPoint.y) / (l1.endPoint.x - l1.startPoint.x);
	            var b = l1.startPoint.y - a * l1.startPoint.x;
	            var x0 = l2.startPoint.x;
	            var y0 = a * x0 + b;
	            return l1.contains(x0, y0) && l2.contains(x0, y0);
	        }
	
	        // check normal case - both lines are not vertical
	        else {
	            //line equation is : y = a*x + b, b = y - a * x
	            var a1 = (l1.endPoint.y - l1.startPoint.y) / (l1.endPoint.x - l1.startPoint.x);
	            var b1 = l1.startPoint.y - a1 * l1.startPoint.x;
	
	            var a2 = (l2.endPoint.y - l2.startPoint.y) / (l2.endPoint.x - l2.startPoint.x);
	            var b2 = l2.startPoint.y - a2 * l2.startPoint.x;
	
	            if (a1 == a2) { //paralel lines
	                return b1 == b2 ?
	                    // for coincide lines, check for segment bounds overlapping
	                    l1.contains(l2.startPoint.x, l2.startPoint.y) || l1.contains(l2.endPoint.x, l2.endPoint.y) :
	                    // not coincide paralel lines have no chance to intersect
	                    false;
	            } else { //usual case - non paralel, the 'infinite' lines intersects...we only need to know if inside the segment
	
	                /*
	                 * if one of the lines are vertical, then x0 is equal to their x,
	                 * otherwise:
	                 * y1 = a1 * x + b1
	                 * y2 = a2 * x + b2
	                 * => x0 = (b2 - b1) / (a1 - a2)
	                 * => y0 = a1 * x0 + b1
	                 **/
	                x0 = (b2 - b1) / (a1 - a2);
	                y0 = a1 * x0 + b1;
	                return l1.contains(x0, y0) && l2.contains(x0, y0);
	            }
	        }
	    }
	
	    /**
	     *
	     *Tests if a a polyline defined by a set of points intersects a rectangle
	     *@param {Array} points - and {Array} of {Point}s
	     *@param {Array} bounds - the bounds of the rectangle defined by (x1, y1, x2, y2)
	     *@param {Boolean} closedPolyline - incase polyline is closed figure then true, else false
	     *
	     *@return true - if line intersects the rectangle, false - if not
	     **/
	    function polylineIntersectsRectangle(points, bounds, closedPolyline) {
	
	
	        //get the 4 lines/segments represented by the bounds
	        var lines = [];
	        lines.push(new Line(new Point(bounds[0], bounds[1]), new Point(bounds[2], bounds[1])));
	        lines.push(new Line(new Point(bounds[2], bounds[1]), new Point(bounds[2], bounds[3])));
	        lines.push(new Line(new Point(bounds[2], bounds[3]), new Point(bounds[0], bounds[3])));
	        lines.push(new Line(new Point(bounds[0], bounds[3]), new Point(bounds[0], bounds[1])));
	
	        for (var k = 0; k < points.length - 1; k++) {
	            //create a line out of each 2 consecutive points
	            var tempLine = new Line(points[k], points[k + 1]);
	
	            //see if that line intersect any of the line on bounds border
	            for (var i = 0; i < lines.length; i++) {
	                if (lineIntersectsLine(tempLine, lines[i])) {
	                    return true;
	                }
	            }
	        }
	
	        //check the closed figure - that is last point connected to the first
	        if (closedPolyline) {
	            //create a line out of each 2 consecutive points
	            var tempLine1 = new Line(points[points.length - 1], points[0]);
	
	            //see if that line intersect any of the line on bounds border
	            for (var j = 0; j < lines.length; j++) {
	                if (lineIntersectsLine(tempLine1, lines[j])) {
	                    return true;
	                }
	            }
	        }
	
	        return false;
	    }
	
	    /**
	     * 计算路径的分数
	     * Score a ortogonal path made out of Points
	     *Iterates over a set of points (minimum 3)
	     *For each 3 points (i, i+1, i+2) :
	     *  - if the 3rd one is after the 2nd on the same line we add +1
	     *  - if the 3rd is up or down related to the 2nd we do not do anything +0
	     *  - if the 3rd goes back we imediatelly return -1
	     *@param {Array} v - an array of {Point}s
	     *@return {Number} - -1 if the path is wrong (goes back) or something >= 0 if is fine
	     *  The bigger the number the smooth the path is
	     **/
	    function scorePath(v) {
	        if (v.length <= 2) {
	            return -1;
	        }
	
	        var score = 0;
	        for (var i = 1; i < v.length - 1; i++) {
	            if (v[i - 1].x == v[i].x && v[i].x == v[i + 1].x) { //on the same vertical
	                if (signum(v[i + 1].y - v[i].y) == signum(v[i].y - v[i - 1].y)) { //same direction
	                    score++;
	                } else { //going back - no good
	                    return -1;
	                }
	            } else if (v[i - 1].y == v[i].y && v[i].y == v[i + 1].y) { //on the same horizontal
	                if (signum(v[i + 1].x - v[i].x) == signum(v[i].x - v[i - 1].x)) { //same direction
	                    score++;
	                } else { //going back - no good
	                    return -1;
	                }
	            } else { //not on same vertical nor horizontal
	                score--;
	            }
	        }
	
	        return score;
	    }
	
	    /**
	     * 返回数字符号（+ -)
	     * Returns the sign of a number
	     *@param {Number} x - the number
	     *@returns {Number}
	     *@see <a href="http://en.wikipedia.org/wiki/Sign_function">http://en.wikipedia.org/wiki/Sign_function</a>
	     **/
	    function signum(x) {
	        if (x > 0)
	            return 1;
	        else if (x < 0)
	            return -1;
	        else
	            return 0;
	    }
	
	    /**
	     * 判断 点数组 是不是有效路径（没有回路）
	     *Tests if a vector of points is a valid path (not going back)
	     *There are a few problems here. If you have p1, p2, p3 and p4 and p2 = p3 you need to ignore that
	     *@param {Array} v - an {Array} of {Point}s
	     *@return {Boolean} - true if path is valid, false otherwise
	     **/
	    function forwardPath(v) {
	        if (v.length <= 2) {
	            return true;
	        }
	
	        for (var i = 0; i < v.length - 2; i++) {
	            if (v[i].x == v[i + 1].x && v[i + 1].x == v[i + 2].x) { //on the same vertical
	                if (signum(v[i + 1].y - v[i].y) != 0) { //test only we have a progressing path
	                    if (signum(v[i + 1].y - v[i].y) == -1 * signum(v[i + 2].y - v[i + 1].y)) { //going back (ignore zero)
	                        return false;
	                    }
	                }
	            } else if (v[i].y == v[i + 1].y && v[i + 1].y == v[i + 2].y) { //on the same horizontal
	                if (signum(v[i + 1].x - v[i].x) != 0) { //test only we have a progressing path
	                    if (signum(v[i + 1].x - v[i].x) == -1 * signum(v[i + 2].x - v[i + 1].x)) { //going back (ignore zero)
	                        return false;
	                    }
	                }
	            }
	        }
	
	        return true;
	    }
	
	    /**
	     * 将[x:0,y:0]转化为[0, 0]  给zrender使用
	     * @param  {[type]} points [description]
	     * @param  {[type]} isRevert [description]
	     * @return {[type]}        [description]
	     */
	    function traslatePoints(points, isRevert) {
	        var newPoints = [];
	        if (isRevert) {
	            for (var i = 0; i < points.length; i++) {
	                var point = points[i];
	                newPoints.push(new Point(point[0], point[1]));
	            }
	            return newPoints;
	        } else {
	            for (var j = 0; j < points.length; j++) {
	                var point1 = points[j];
	                newPoints.push([point1.x, point1.y]);
	            }
	            return newPoints;
	        }
	
	
	    }
	
	    function rotationMatrix(angle) {
	        var mReturn = [
	            [Math.cos(angle), -Math.sin(angle), 0],
	            [Math.sin(angle), Math.cos(angle), 0],
	            [0, 0, 1]
	        ];
	        return mReturn;
	    }
	
	    function translationMatrix(dx, dy) {
	        return [
	            [1, 0, dx],
	            [0, 1, dy],
	            [0, 0, 1]
	        ];
	    }
	
	    function scaleMatrix(sx, sy) {
	        if (sy == null) {
	            sy = sx;
	        }
	        return [
	            [sx, 0, 0],
	            [0, sy, 0],
	            [0, 0, 1]
	        ];
	    }
	
	    /** It will return the end point of a line on a given angle (clockwise).
	     * @param {Point} startPoint - the start of the line
	     * @param {Number} length - the length of the line
	     * @param {Number} angle - the angle of the line in radians
	     * @return {Point} - the endPoint of the line
	     */
	    function getEndPoint(startPoint, length, angle) {
	        var endPoint = startPoint.clone();
	        endPoint.transform(translationMatrix(-startPoint.x, -startPoint.y));
	        endPoint.y -= length;
	        endPoint.transform(rotationMatrix(angle));
	        endPoint.transform(translationMatrix(startPoint.x, startPoint.y));
	        return endPoint;
	    }
	
	    /**
	     * 获取获取两个图形的外面四个连接点
	     * @param  {[type]} node [description]
	     * @return {[type]}      [description]
	     */
	    function getConnectorPoints(node) {
	        return {
	            left: new Point(node.x, node.y + node.height / 2), //矩形 左中的位置
	            top: new Point(node.x + node.width / 2, node.y), //矩形 上中的位置
	            right: new Point(node.x + node.width, node.y + node.height / 2), //矩形 右中的位置
	            bottom: new Point(node.x + node.width / 2, node.y + node.height), //矩形 下中的位置
	            center: new Point(node.x + node.width / 2, node.y + node.height / 2) //中间位置
	
	        };
	    }
	
	    /**
	     * 获取获取两个图形的外面四个连接点
	     * @param  {[type]} node [description]
	     * @return {[type]}      [description]
	     */
	    function getSoltPoints(node) {
	        return [
	            //top
	            [Math.round(node.getRect().width / 3 /10)*10, 0 ],
	            [Math.round(2*node.getRect().width / 3 /10)*10, 0 ],
	            //right
	            [node.getRect().width, Math.round(node.getRect().height / 3 /10)*10 ],
	            [node.getRect().width, Math.round(2*node.getRect().height / 3 /10)*10 ],
	            //bottom
	            [Math.round(node.getRect().width / 3 /10)*10, node.getRect().height ],
	            [Math.round(2*node.getRect().width / 3 /10)*10, node.getRect().height ],
	            //left
	            [0, Math.round(node.getRect().height / 3 /10)*10 ],
	            [0, Math.round(2*node.getRect().height / 3 /10)*10 ]
	
	        ]
	    }
	
	    /**
	     * 计算 p1 p2两点所连接的直线的角度
	     * @param  {[type]} p1 [description]
	     * @param  {[type]} p2 [description]
	     * @return {[type]}    [description]
	     */
	    function tangentRotation(p1, p2) {
	        return -Math.PI / 2 - Math.atan2(
	            p2.y - p1.y, p2.x - p1.x
	        );
	    }
	
	    /**
	     * 判断3点是否在一条直线上
	     * Tests if 3 points are coliniar with matrix determinants.
	     * If the determinat of matrix
	     * /         \
	     * | x1 y1 1 |
	     * | x2 y2 1 |
	     * | x3 y3 1 |
	     * \         /
	     * is zero it means that the points are colinear
	     *@param {Point} p1 - first point
	     *@param {Point} p2 - second point
	     *@param {Point} p3 - third point
	     * @param {Number} precission
	     *@return {Boolean} - true if coliniar and false if not
	     *@author Alex
	     *@see http://en.wikipedia.org/wiki/Determinant
	     *@see https://people.richland.edu/james/lecture/m116/matrices/applications.html
	     **/
	    function collinearity(p1, p2, p3, precission) {
	        var determinant = (p1.x * p2.y + p1.y * p3.x + p2.x * p3.y) - (p2.y * p3.x + p1.y * p2.x + p1.x * p3.y);
	
	        if (precission) {
	            return Math.abs(determinant) <= precission;
	        } else {
	            return determinant === 0;
	        }
	    }
	
	
	    /**
	     * 四舍五入 保存decimals的小数
	     **/
	    function enhancedRound(number, decimals) {
	        return Math.round(number * Math.pow(10, decimals)) / Math.pow(10, decimals);
	    }
	
	    /**
	     * 获取两点之间的长度
	     **/
	    function getLength(startPoint, endPoint) {
	        return Math.sqrt(Math.pow(startPoint.x - endPoint.x, 2) + Math.pow(startPoint.y - endPoint.y, 2));
	    }
	
	    /**
	     * 获取角度
	     * @param  {[type]} centerPoint  [description]
	     * @param  {[type]} outsidePoint [description]
	     * @param  {[type]} round        [description]
	     * @return {[type]}              [description]
	     */
	    function getAngle(centerPoint, outsidePoint, round) {
	        centerPoint.x = enhancedRound(centerPoint.x, 5);
	        centerPoint.y = enhancedRound(centerPoint.y, 5);
	        outsidePoint.x = enhancedRound(outsidePoint.x, 5);
	        outsidePoint.y = enhancedRound(outsidePoint.y, 5);
	        var angle = Math.atan((outsidePoint.x - centerPoint.x) / (outsidePoint.y - centerPoint.y));
	        angle = -angle;
	
	        //endAngle+=90;
	        if (outsidePoint.x >= centerPoint.x && outsidePoint.y >= centerPoint.y) {
	            angle += Math.PI;
	        } else if (outsidePoint.x <= centerPoint.x && outsidePoint.y >= centerPoint.y) {
	            angle += Math.PI;
	        } else if (outsidePoint.x <= centerPoint.x && outsidePoint.y <= centerPoint.y) {
	            angle += Math.PI * 2;
	        }
	        while (angle >= Math.PI * 2) {
	            angle -= Math.PI * 2;
	        }
	        if (isNaN(angle)) { //Nan
	            angle = 0; //we are at center point;
	        }
	        if (round) {
	            angle = Math.round(angle / round) * round
	        }
	        return angle;
	    }
	
	    function getRect(node) {
	        var boundingRect = node.getBoundingRect();
	        //创建最小包围盒虚线
	        var points = [];
	        points[0] = [-boundingRect.width / 2, -boundingRect.height / 2];
	        points[1] = [boundingRect.width / 2, -boundingRect.height / 2];
	        points[2] = [boundingRect.width / 2, boundingRect.height / 2];
	        points[3] = [-boundingRect.width / 2, boundingRect.height / 2];
	        points[4] = [-boundingRect.width / 2, -boundingRect.height / 2];
	
	        var boundRect, cx, cy;
	        if (node instanceof graphic.Circle) {
	            //注: 因事件为圆形  所以 x y 为圆心的位置  包围矩形要减去宽度一半
	            boundRect = new BoundingRect(Number(node.position[0]) - Number(boundingRect.width / 2),
	                Number(node.position[1]) - Number(boundingRect.height / 2),
	                Number(boundingRect.width), Number(boundingRect.height));
	            cx = Number(node.position[0]);
	            cy = Number(node.position[1]);
	        } else {
	            boundRect = new BoundingRect(Number(node.position[0]),
	                Number(node.position[1]),
	                Number(boundingRect.width), Number(boundingRect.height));
	            cx = Number(node.position[0]) + Number(boundingRect.width) / 2;
	            cy = Number(node.position[1]) + Number(boundingRect.height) / 2;
	        }
	        return {
	            x: Number(cx),
	            y: Number(cy),
	            width: Number(boundingRect.width),
	            height: Number(boundingRect.height),
	            points: points,
	            boundingRect: boundRect
	        };
	    }
	
	    var StackedMap = {
	        createNew: function() {
	            var stack = [];
	
	            return {
	                add: function(key, value) {
	                    var arrKey = this.get(key);
	                    arrKey.push(value)
	
	                },
	                get: function(key) {
	                    for (var i = 0; i < stack.length; i++) {
	                        if (key == stack[i].key) {
	                            return stack[i].value;
	                        }
	                    }
	                    //如果没有找到的话，则创建一个新的数组
	                    var value = [];
	                    stack.push({ key: key, value: value });
	                    return value;
	                },
	                keys: function() {
	                    var keys = [];
	                    for (var i = 0; i < stack.length; i++) {
	                        keys.push(stack[i].key);
	                    }
	                    return keys;
	                },
	                top: function() {
	                    return stack[stack.length - 1];
	                },
	                remove: function(key) {
	                    var idx = -1;
	                    for (var i = 0; i < stack.length; i++) {
	                        if (key == stack[i].key) {
	                            idx = i;
	                            break;
	                        }
	                    }
	                    return stack.splice(idx, 1)[0];
	                },
	                removeItem: function(key, item) {
	                    var arrKey = this.get(key);
	                    var index = zrUtil.indexOf(arrKey, item);
	                    arrKey.splice(index, 1);
	
	                },
	                removeTop: function() {
	                    return stack.splice(stack.length - 1, 1)[0];
	                },
	                length: function() {
	                    return stack.length;
	                },
	                clear: function() {
	                    stack.splice(0, stack.length);
	                }
	            };
	        }
	    };
	
	    function randomColor() {
	        var arrHex = ["0", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d"],
	            strHex = "#",
	            index;
	        for (var i = 0; i < 6; i++) {
	            index = Math.round(Math.random() * 15);
	            strHex += arrHex[index];
	        }
	        return strHex;
	    }
	
	    function isUndefined(obj) {
	        return obj === void 0;
	    }
	
	    function collinearReduction (v) {
	        var r = [];
	
	        if(v.length < 3){
	            return Point.cloneArray(v);
	        }
	
	        r.push( v[0].clone() );
	        for(var i=1; i < v.length-1; i++){
	            if( (v[i-1].x == v[i].x && v[i].x == v[i+1].x)  ||  (v[i-1].y == v[i].y && v[i].y == v[i+1].y) )
	            {
	                continue;
	            }
	            else{
	                r.push( v[i].clone() );
	            }
	        }
	        r.push( v[v.length-1].clone() );
	
	        return r;
	    }
	
	    // By default, Underscore uses ERB-style template delimiters, change the
	    // following template settings to use alternative delimiters.
	    var templateSettings = {
	        evaluate: /<%([\s\S]+?)%>/g,
	        interpolate: /<%=([\s\S]+?)%>/g,
	        escape: /<%-([\s\S]+?)%>/g
	    };
	
	    // When customizing `templateSettings`, if you don't want to define an
	    // interpolation, evaluation or escaping regex, we need one that is
	    // guaranteed not to match.
	    var noMatch = /(.)^/;
	
	    // Certain characters need to be escaped so that they can be put into a
	    // string literal.
	    var escapes = {
	        "'": "'",
	        '\\': '\\',
	        '\r': 'r',
	        '\n': 'n',
	        '\u2028': 'u2028',
	        '\u2029': 'u2029'
	    };
	
	    var escaper = /\\|'|\r|\n|\u2028|\u2029/g;
	
	    var escapeChar = function(match) {
	        return '\\' + escapes[match];
	    };
	
	    // JavaScript micro-templating, similar to John Resig's implementation.
	    // Underscore templating handles arbitrary delimiters, preserves whitespace,
	    // and correctly escapes quotes within interpolated code.
	    // NB: `oldSettings` only exists for backwards compatibility.
	    function template(text, settings, oldSettings) {
	        if (!settings && oldSettings) settings = oldSettings;
	        settings = settings || {};
	        settings = zrUtil.defaults(settings, templateSettings, true);
	
	        // Combine delimiters into one regular expression via alternation.
	        var matcher = RegExp([
	            (settings.escape || noMatch).source,
	            (settings.interpolate || noMatch).source,
	            (settings.evaluate || noMatch).source
	        ].join('|') + '|$', 'g');
	
	        // Compile the template source, escaping string literals appropriately.
	        var index = 0;
	        var source = "__p+='";
	        text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
	            source += text.slice(index, offset).replace(escaper, escapeChar);
	            index = offset + match.length;
	
	            if (escape) {
	                source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
	            } else if (interpolate) {
	                source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
	            } else if (evaluate) {
	                source += "';\n" + evaluate + "\n__p+='";
	            }
	
	            // Adobe VMs need the match returned to produce the correct offest.
	            return match;
	        });
	        source += "';\n";
	
	        // If a variable is not specified, place data values in local scope.
	        if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';
	
	        source = "var __t,__p='',__j=Array.prototype.join," +
	            "print=function(){__p+=__j.call(arguments,'');};\n" +
	            source + 'return __p;\n';
	
	        try {
	            var render = new Function(settings.variable || 'obj', source);
	        } catch (e) {
	            e.source = source;
	            throw e;
	        }
	
	        var template = function(data) {
	            return render.call(this, data);
	        };
	
	        // Provide the compiled source as a convenience for precompilation.
	        var argument = settings.variable || 'obj';
	        template.source = 'function(' + argument + '){\n' + source + '}';
	
	        return template;
	    }
	
	    function isEmpty(obj) {
	        if (obj == null) return true;
	        if (zrUtil.isArrayLike(obj) && (zrUtil.isArray(obj) || zrUtil.isString(obj))) return obj.length === 0;
	    }
	
	    module.exports = {
	        inherits: inherits,
	        getUUID: getUUID,
	        distance: distance,
	        getPolylineLength: getPolylineLength,
	        max: max,
	        min: min,
	        isEmpty: isEmpty,
	        orthogonalPath: orthogonalPath,
	        polylineIntersectsRectangle: polylineIntersectsRectangle,
	        scorePath: scorePath,
	        forwardPath: forwardPath,
	        traslatePoints: traslatePoints,
	        getEndPoint: getEndPoint,
	        getConnectorPoints: getConnectorPoints,
	        tangentRotation: tangentRotation,
	        collinearity: collinearity,
	        translationMatrix: translationMatrix,
	        scaleMatrix: scaleMatrix,
	        round: enhancedRound,
	        getLength: getLength,
	        getAngle: getAngle,
	        getRect: getRect,
	        StackedMap: StackedMap,
	        getMaxLineLength: getMaxLineLength,
	        randomColor: randomColor,
	        template: template,
	        isUndefined: isUndefined,
	        getSoltPoints:getSoltPoints,
	        collinearReduction: collinearReduction
	    };
	


/***/ },
/* 72 */
/***/ function(module, exports) {

	
	
	    /**
	      * Creates an instance of Point
	      *
	      *
	      * @constructor
	      * @this {Point}
	      * @param {Number} x The x coordinate of point.
	      * @param {Number} y The y coordinate of point.
	      * Note: Even if it is named Point this class should be named Dot as Dot is closer
	      * then Point from math perspective.
	      **/
	    function Point(x, y){
	        /**The x coordinate of point*/
	        this.x = x;
	        
	        /**The y coordinate of point*/
	        this.y = y;
	        
	
	    }
	
	    /**Creates a {Point} out of JSON parsed object
	     *@param {JSONObject} o - the JSON parsed object
	     *@return {Point} a newly constructed Point
	     **/
	    Point.load = function(o){
	        var newPoint = new Point(Number(o.x), Number(o.y));
	        return newPoint;
	    };
	
	
	    /**Creates an array of points from an array of {JSONObject}s
	     *@param {Array} v - the array of JSONObjects
	     *@return an {Array} of {Point}s
	     **/
	    Point.loadArray = function(v){
	        var newPoints = [];
	        for(var i=0; i< v.length; i++){
	            newPoints.push(Point.load(v[i]));
	        }
	        return newPoints;
	    };
	
	
	    /**Clones an array of points
	     *@param {Array} v - the array of {Point}s
	     *@return an {Array} of {Point}s
	     **/
	    Point.cloneArray = function(v){
	        var newPoints = [];
	        for(var i=0; i< v.length; i++){
	            newPoints.push(v[i].clone());
	        }
	        return newPoints;
	    };
	
	    Point.prototype = {
	        constructor : Point,
	        
	        transform:function(matrix){
	            var oldX = this.x;
	            var oldY = this.y;
	            this.x = matrix[0][0] * oldX + matrix[0][1] * oldY + matrix[0][2];
	            this.y = matrix[1][0] * oldX + matrix[1][1] * oldY + matrix[1][2];
	        },
	        
	        /**Tests if this point is similar to other point
	         *@param {Point} anotherPoint - the other point
	         **/
	        equals:function(anotherPoint){
	            if(! (anotherPoint instanceof Point) ){
	                return false;
	            }
	            return (this.x == anotherPoint.x)
	            && (this.y == anotherPoint.y)
	        },
	
	        /**Clone current Point
	         **/
	        clone: function(){
	            var newPoint = new Point(this.x, this.y);
	            return newPoint;
	        },
	
	        /**Tests to see if a point (x, y) is within a range of current Point
	         *@param {Numeric} x - the x coordinate of tested point
	         *@param {Numeric} y - the x coordinate of tested point
	         *@param {Numeric} radius - the radius of the vicinity
	         **/
	        near:function(x, y, radius){
	            var distance = Math.sqrt(Math.pow(this.x - x, 2) + Math.pow(this.y - y, 2));
	
	            return (distance <= radius);
	        },
	
	        contains: function(x,y){
	            return this.x == x && this.y == y;
	        },
	
	        toString:function(){
	            return '[' + this.x + ',' + this.y + ']';
	        },
	
	        getPoints:function(){
	            return [this];
	        }
	    };
	    module.exports = Point;
	    

/***/ },
/* 73 */
/***/ function(module, exports) {

	
	
	    /**
	      * Creates an instance of a Line. A Line is actually a segment and not a pure
	      * geometrical Line
	      *
	      * @constructor
	      * @this {Line}
	      * @param {Point} startPoint - starting point of the line
	      * @param {Point} endPoint - the ending point of the line
	      **/
	    function Line(startPoint, endPoint){
	        /**Starting {@link Point} of the line*/
	        this.startPoint = startPoint;
	
	        /**Ending {@link Point} of the line*/
	        this.endPoint = endPoint;
	
	        /**Serialization type*/
	        this.oType = 'Line'; //object type used for JSON deserialization
	    }
	
	    /**Creates a {Line} out of JSON parsed object
	     *@param {JSONObject} o - the JSON parsed object
	     *@return {Line} a newly constructed Line
	     **/
	    Line.load = function(o){
	        var newLine = new Line(
	            Point.load(o.startPoint),
	            Point.load(o.endPoint)
	        );
	
	        return newLine;
	    };
	
	    Line.prototype = {
	        contructor: Line,
	
	
	
	        clone:function(){
	            var ret = new Line(this.startPoint.clone(), this.endPoint.clone());
	            return ret;
	        },
	
	        equals:function(anotherLine){
	            if(!anotherLine instanceof Line){
	                return false;
	            }
	            return this.startPoint.equals(anotherLine.startPoint)
	            && this.endPoint.equals(anotherLine.endPoint)
	        },
	
	        /** Tests to see if a point belongs to this line (not as infinite line but more like a segment)
	         * Algorithm: Compute line's equation and see if (x, y) verifies it.
	         * @param {Number} x - the X coordinates
	         * @param {Number} y - the Y coordinates
	         **/
	        contains: function(x, y){
	            // if the point is inside rectangle bounds of the segment
	            if (Math.min(this.startPoint.x, this.endPoint.x) <= x
	                && x <= Math.max(this.startPoint.x, this.endPoint.x)
	                && Math.min(this.startPoint.y, this.endPoint.y) <= y
	                && y <= Math.max(this.startPoint.y, this.endPoint.y)) {
	
	                // check for vertical line
	                if (this.startPoint.x == this.endPoint.x) {
	                    return x == this.startPoint.x;
	                } else { // usual (not vertical) line can be represented as y = a * x + b
	                    var a = (this.endPoint.y - this.startPoint.y) / (this.endPoint.x - this.startPoint.x);
	                    var b = this.startPoint.y - a * this.startPoint.x;
	                    return y == a * x + b;
	                }
	            } else {
	                return false;
	            }
	        },
	
	        /*
	         *See if we are near a {Line} by a certain radius (also includes the extremities into computation)
	         *@param {Number} x - the x coordinates
	         *@param {Number} y - the y coordinates
	         *@param {Number} radius - the radius to search for
	         *@see http://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line
	         *@see "Mathematics for Computer Graphics, 2nd Ed., by John Vice, page 227"
	         **/
	        near:function(x,y,radius){
	
	            if(this.endPoint.x === this.startPoint.x){ //Vertical line, so the vicinity area is a rectangle
	                return ( (this.startPoint.y-radius<=y && this.endPoint.y+radius>=y)
	                        || (this.endPoint.y-radius<=y && this.startPoint.y+radius>=y))
	                && x > this.startPoint.x - radius && x < this.startPoint.x + radius ;
	            }
	
	            if(this.startPoint.y === this.endPoint.y){ //Horizontal line, so the vicinity area is a rectangle
	                return ( (this.startPoint.x - radius<=x && this.endPoint.x+radius>=x)
	                        || (this.endPoint.x-radius<=x && this.startPoint.x+radius>=x))
	                        && y>this.startPoint.y-radius && y<this.startPoint.y+radius ;
	            }
	
	
	            var startX = Math.min(this.endPoint.x,this.startPoint.x);
	            var startY = Math.min(this.endPoint.y,this.startPoint.y);
	            var endX = Math.max(this.endPoint.x,this.startPoint.x);
	            var endY = Math.max(this.endPoint.y,this.startPoint.y);
	
	            /*We will compute the distance from point to the line
	             * by using the algorithm from
	             * http://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line
	             * */
	
	            //First we need to find a,b,c of the line equation ax + by + c = 0
	            var a = this.endPoint.y - this.startPoint.y;
	            var b = this.startPoint.x - this.endPoint.x;
	            var c = -(this.startPoint.x * this.endPoint.y - this.endPoint.x * this.startPoint.y);
	
	            //Secondly we get the distance "Mathematics for Computer Graphics, 2nd Ed., by John Vice, page 227"
	            var d = Math.abs( (a*x + b*y + c) / Math.sqrt(Math.pow(a,2) + Math.pow(b,2)) );
	
	            //Thirdly we get coordinates of closest line's point to target point
	            //http://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line#Cartesian_coordinates
	            var closestX = (b * (b*x - a*y) - a*c) / ( Math.pow(a,2) + Math.pow(b,2) );
	            var closestY = (a * (-b*x + a*y) - b*c) / ( Math.pow(a,2) + Math.pow(b,2) );
	
	            var r = ( d <= radius && endX>=closestX && closestX>=startX && endY>=closestY && closestY>=startY ) //the projection of the point falls INSIDE of the segment
	                || this.startPoint.near(x,y,radius) || this.endPoint.near(x,y,radius); //the projection of the point falls OUTSIDE of the segment
	
	            return  r;
	
	        },
	
	        /**we need to create a new array each time, or we will affect the actual shape*/
	        getPoints:function(){
	            var points = [];
	            points.push(this.startPoint);
	            points.push(this.endPoint);
	            return points;
	        },
	
	        /**Return the {Point} corresponding the t certain t value
	         * @param {Number} t the value of parameter t, where t in [0,1], t is like a percent*/
	        getPoint: function(t){
	            var Xp = t * (this.endPoint.x - this.startPoint.x) + this.startPoint.x;
	            var Yp = t * (this.endPoint.y - this.startPoint.y) + this.startPoint.y;
	
	            return new Point(Xp, Yp);
	        },
	
	        // /**
	        //  * Returns the middle of the line
	        //  * @return {Point} the middle point
	        //  * */
	        // getMiddle : function(){
	        //     return Util.getMiddle(this.startPoint, this.endPoint);
	        // },
	
	
	        // getLength : function(){
	        //     return Util.getLength(this.startPoint, this.endPoint);
	        // },
	
	        // /**
	        //  *Get bounds for this line
	        //  *@author Alex Gheorghiu <alex@scriptoid.com>
	        //  **/
	        // getBounds:function(){
	        //     return Util.getBounds(this.getPoints());
	        // },
	
	        /**String representation*/
	        toString:function(){
	            return 'line(' + this.startPoint + ',' + this.endPoint + ')';
	        }
	    };
	    module.exports = Line;
	


/***/ },
/* 74 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Network model
	 *
	 */
	
	
	    var Model = __webpack_require__(75);
	    var zrUtil = __webpack_require__(4);
	
	    var NetworkModel = Model.extend({
	        /**
	         * @type {Object}
	         * @protected
	         */
	        defaultOption: {
	        	resourceId: "",  //资源ID
	            properties: {
	                type: -1,  //类型
	                name: "", //名称
	                notes: "",  //备注
	                //no: ""
	                extProperties: {
	                },  //扩展属性
	                bounds: {
	                    upperLeft: {x: 0, y: 0},  //左上角坐标
	                    lowerRight: {x: 0, y: 0} //右下角坐标
	                }
	            },
	            stencil: {type: "NextworkNode"},
	            showTip: false
	        },
	
	        init: function (option, parentModel, extraOpt) {
	            zrUtil.merge(option, this.getDefaultOption());
	        },
	
	        getDefaultOption: function () {
	            if (!this.hasOwnProperty('__defaultOption')) {
	                var optList = [];
	                var Class = this.constructor;
	                while (Class) {
	                    var opt = Class.prototype.defaultOption;
	                    opt && optList.push(opt);
	                    Class = Class.superClass;
	                }
	
	                var defaultOption = {};
	                for (var i = optList.length - 1; i >= 0; i--) {
	                    defaultOption = zrUtil.merge(defaultOption, optList[i], true);
	                }
	                this.__defaultOption = defaultOption;
	            }
	            return this.__defaultOption;
	        }
	
	    });
	    module.exports = NetworkModel;
	


/***/ },
/* 75 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * 节点等的模型
	 * 里面存的数据用来处理序列化和反序列化
	 * @class fish.topo.model
	 */
	
	
	    var zrUtil = __webpack_require__(4);
	    var clazzUtil = __webpack_require__(76);
	
	    function Model(option, parentModel,  extraOpt) {
	        this.parentModel = parentModel;
	        this.option = option;
	
	        // Simple optimization
	        if (this.init) {
	            if (arguments.length <= 3) {
	                this.init(option, parentModel,  extraOpt);
	            }
	            else {
	                this.init.apply(this, arguments);
	            }
	        }
	    }
	
	    Model.prototype = {
	
	        constructor: Model,
	
	        /**
	         * Model 的初始化函数
	         * @private
	         * @param {Object} option
	         */
	        init: function (option) {
	            zrUtil.merge(option, this.getDefaultOption());
	        },
	
	        getDefaultOption: function () {
	            if (!this.hasOwnProperty('__defaultOption')) {
	                var optList = [];
	                var Class = this.constructor;
	                while (Class) {
	                    var opt = Class.prototype.defaultOption;
	                    opt && optList.push(opt);
	                    Class = Class.superClass;
	                }
	
	                var defaultOption = {};
	                for (var i = optList.length - 1; i >= 0; i--) {
	                    defaultOption = zrUtil.merge(defaultOption, optList[i], true);
	                }
	                this.__defaultOption = defaultOption;
	            }
	            return this.__defaultOption;
	        },
	
	        /**
	         * @private
	         */
	        mergeOption: function (option) {
	            zrUtil.merge(this.option, option, true);
	        },
	
	        /**
	         * 获取model的某个属性的值
	         * @param {string} path model中的属性
	         * @return {String}
	         *
	         * **使用范例**：
	         *
	         *      @example
	         *          node.model.get("options.text");
	         */
	        get: function (path, ignoreParent) {
	            if (!path) {
	                return this.option;
	            }
	
	            if (typeof path === 'string') {
	                path = path.split('.');
	            }
	
	            var obj = this.option;
	            var parentModel = this.parentModel;
	            for (var i = 0; i < path.length; i++) {
	                // obj could be number/string/... (like 0)
	                obj = (obj && typeof obj === 'object') ? obj[path[i]] : null;
	                if (obj == null) {
	                    break;
	                }
	            }
	            if (obj == null && parentModel && !ignoreParent) {
	                obj = parentModel.get(path);
	            }
	            return obj;
	        },
	
	        /**
	         * 设置model的某个属性的值
	         * @param {string} path model中的属性
	         * @param {String} value 所需要设置的值
	         * @return {String}
	         *
	         * **使用范例**：
	         *
	         *      @example
	         *          node.model.set("options.text","例子");
	         */
	        set: function (path, value) {
	            var obj = this.option;
	
	            if (path.indexOf(".") == -1) {
	                obj[path] = value;
	            } else {
	                var fieldArray  = path.split('.');
	                var n = fieldArray.length;
	                var currentRef = obj;
	                var fieldName;
	
	                for (var i = 0; i < n - 1; i++) {
	                    fieldName = fieldArray[i];
	                    if(currentRef[fieldName] == null) {
	                        currentRef[fieldName] = {};
	                    }
	                    currentRef = currentRef[fieldName];
	                }
	                fieldName = fieldArray[n-1];
	                currentRef[fieldName] = value;
	            }
	        },
	
	        /**
	         * @private
	         */
	        getShallow: function (key, ignoreParent) {
	            var option = this.option;
	            var val = option && option[key];
	            var parentModel = this.parentModel;
	            if (val == null && parentModel && !ignoreParent) {
	                val = parentModel.getShallow(key);
	            }
	            return val;
	        },
	
	        /**
	         * @private
	         */
	        getModel: function (path, parentModel) {
	            var obj = this.get(path, true);
	            var thisParentModel = this.parentModel;
	            var model = new Model(
	                obj, parentModel || (thisParentModel && thisParentModel.getModel(path))
	            );
	            return model;
	        },
	
	        /**
	         *清空model的option
	         * @private
	         */
	        isEmpty: function () {
	            return this.option == null;
	        },
	
	        restoreData: function () {},
	
	        /**
	         * @private
	         */
	        clone: function () {
	            var Ctor = this.constructor;
	            return new Ctor(zrUtil.clone(this.option));
	        }
	    };
	
	    // Enable Model.extend.
	    clazzUtil.enableClassExtend(Model);
	
	    module.exports = Model;
	


/***/ },
/* 76 */
/***/ function(module, exports, __webpack_require__) {

	
	
	    var zrUtil = __webpack_require__(4);
	
	    var clazz = {};
	
	    var TYPE_DELIMITER = '.';
	    var IS_CONTAINER = '___FT__COMPONENT__CONTAINER___';
	    /**
	     * @public
	     */
	    var parseClassType = clazz.parseClassType = function (componentType) {
	        var ret = {main: '', sub: ''};
	        if (componentType) {
	            componentType = componentType.split(TYPE_DELIMITER);
	            ret.main = componentType[0] || '';
	            ret.sub = componentType[1] || '';
	        }
	        return ret;
	    };
	    /**
	     * @public  相比 直接用zrUtil.inherits 好处是  可以直接调用父类的构造函数
	     */
	    clazz.enableClassExtend = function (RootClass, preConstruct) {
	        RootClass.extend = function (proto) {
	            var ExtendedClass = function () {
	                preConstruct && preConstruct.apply(this, arguments);
	                RootClass.apply(this, arguments);
	            };
	
	            zrUtil.extend(ExtendedClass.prototype, proto);
	
	            ExtendedClass.extend = this.extend;
	            ExtendedClass.superCall = superCall;
	            ExtendedClass.superApply = superApply;
	            zrUtil.inherits(ExtendedClass, this);
	            ExtendedClass.superClass = this;
	
	            return ExtendedClass;
	        };
	    };
	
	    // superCall should have class info, which can not be fetch from 'this'.
	    // Consider this case:
	    // class A has method f,
	    // class B inherits class A, overrides method f, f call superApply('f'),
	    // class C inherits class B, do not overrides method f,
	    // then when method of class C is called, dead loop occured.
	    function superCall(context, methodName) {
	        var args = zrUtil.slice(arguments, 2);
	        return this.superClass.prototype[methodName].apply(context, args);
	    }
	
	    function superApply(context, methodName, args) {
	        return this.superClass.prototype[methodName].apply(context, args);
	    }
	
	    /**
	     * @param {Object} entity
	     * @param {Object} options
	     * @param {boolean} [options.registerWhenExtend]
	     * @public
	     */
	    clazz.enableClassManagement = function (entity, options) {
	        options = options || {};
	
	        /**
	         * Component model classes
	         * key: componentType,
	         * value:
	         *     componentClass, when componentType is 'xxx'
	         *     or Object.<subKey, componentClass>, when componentType is 'xxx.yy'
	         * @type {Object}
	         */
	        var storage = {};
	
	        entity.registerClass = function (Clazz, componentType) {
	            if (componentType) {
	                componentType = parseClassType(componentType);
	
	                if (!componentType.sub) {
	                    if (storage[componentType.main]) {
	                        //已经注册过了，直接返回
	                        return;
	                    }
	                    storage[componentType.main] = Clazz;
	                }
	                else if (componentType.sub !== IS_CONTAINER) {
	                    var container = makeContainer(componentType);
	                    container[componentType.sub] = Clazz;
	                }
	            }
	            return Clazz;
	        };
	
	        entity.getClass = function (componentTypeMain, subType, throwWhenNotFound) {
	            var Clazz = storage[componentTypeMain];
	
	            if (Clazz && Clazz[IS_CONTAINER]) {
	                Clazz = subType ? Clazz[subType] : null;
	            }
	
	            if (throwWhenNotFound && !Clazz) {
	                throw new Error(
	                    'Component ' + componentTypeMain + '.' + (subType || '') + ' not exists. Load it first.'
	                );
	            }
	
	            return Clazz;
	        };
	
	        entity.getClassesByMainType = function (componentType) {
	            componentType = parseClassType(componentType);
	
	            var result = [];
	            var obj = storage[componentType.main];
	
	            if (obj && obj[IS_CONTAINER]) {
	                zrUtil.each(obj, function (o, type) {
	                    type !== IS_CONTAINER && result.push(o);
	                });
	            }
	            else {
	                result.push(obj);
	            }
	
	            return result;
	        };
	
	        entity.hasClass = function (componentType) {
	            // Just consider componentType.main.
	            componentType = parseClassType(componentType);
	            return !!storage[componentType.main];
	        };
	
	        /**
	         * @return {Array.<string>} Like ['aa', 'bb'], but can not be ['aa.xx']
	         */
	        entity.getAllClassMainTypes = function () {
	            var types = [];
	            zrUtil.each(storage, function (obj, type) {
	                types.push(type);
	            });
	            return types;
	        };
	
	        /**
	         * If a main type is container and has sub types
	         * @param  {string}  componentType
	         * @return {boolean}
	         */
	        entity.hasSubTypes = function (componentType) {
	            componentType = parseClassType(componentType);
	            var obj = storage[componentType.main];
	            return obj && obj[IS_CONTAINER];
	        };
	
	        entity.parseClassType = parseClassType;
	
	        function makeContainer(componentType) {
	            var container = storage[componentType.main];
	            if (!container || !container[IS_CONTAINER]) {
	                container = storage[componentType.main] = {};
	                container[IS_CONTAINER] = true;
	            }
	            return container;
	        }
	
	        if (options.registerWhenExtend) {
	            var originalExtend = entity.extend;
	            if (originalExtend) {
	                entity.extend = function (proto) {
	                    var ExtendedClass = originalExtend.call(this, proto);
	                    return entity.registerClass(ExtendedClass, proto.type);
	                };
	            }
	        }
	
	        return entity;
	    };
	
	    module.exports = clazz;
	


/***/ },
/* 77 */
/***/ function(module, exports, __webpack_require__) {

	
		var Node = __webpack_require__(78);
		var zrUtil = __webpack_require__(4);
		var graphic = __webpack_require__(3);
		var clazzUtil = __webpack_require__(76);
		
		//创建Node类 所有形状都继承Node  包括fromJSON toJSON
		function NetworkNode(model, api) {
			Node.call(this);
			this.model = model;		
			this.options =
			{
				outline: {
					enable: true, // 是否有外框
					radius: true, // 是否圆角
					initVisible: false
				},
				text: {
					color: '#000000', // 文本颜色
					lineHeight: 24 // 文本行高
				}
			};
			this.nextworkInfo = {type: -1, name:"NextworkNode" };    //节点信息
			this.portNodeList = [];
			this.cardNodeList = [];
			this.initEvent(api);
		};
	
	    NetworkNode.prototype.initEvent = function(api) {
	        var that = this;
	        // var MOUSE_EVENT_NAMES = ['click', 'mouseover', 'mouseout'];//'click', 'dblclick', 'mouseover', 'mouseout'
	        // zrUtil.each(MOUSE_EVENT_NAMES, function (eveName) {
	        //     that.on(eveName, function (e) {
		       //      var params = {};
		       //      params.event = e;
		       //      params.type = eveName;
		       //      params.model = that.model
		       //      api.trigger(eveName, params); 
	        //     }, this);
	        // }, this);
	    };	
	
		NetworkNode.prototype.render = function() {
	
		};
	
		/**
		 * drawText
		 * @description 画一个文本
		 * @param {string} content
		 * @param {number} x
		 * @param {number} y
		 * @param {string} color
		 */
		NetworkNode.prototype.drawText = function (content, x, y, color) {
			var text = new graphic.Text({
				style: {
					text: content,
					x: x,
					y: y + 6,
					color: color ? color : this.options.text.color,
					textFont: '12px Microsoft YaHei'
				},
				zlevel: 20
			});
			return {
				text: text,
				rect: text.getBoundingRect()
			};
		};	
	
	
		NetworkNode.prototype.toJSON = function() {
			this.model.set("resourceId", this.resourceId);
			this.model.set("properties.type", this.nextworkInfo.type);
			this.model.set("stencil.type", this.nextworkInfo.name);
			this.model.set("bounds.upperLeft.x", this.position[0]);
			this.model.set("bounds.upperLeft.y", this.position[1]);
			this.model.set("bounds.lowerRight.x", this.position[0] + this.getBoundingRect().width);
			this.model.set("bounds.lowerRight.y", this.position[1] + this.getBoundingRect().height);
			return this.model.option;
		};
		zrUtil.inherits(NetworkNode, Node);
	
		clazzUtil.enableClassManagement(NetworkNode, {
	        registerWhenExtend: true
	    });
		module.exports = NetworkNode;
	


/***/ },
/* 78 */
/***/ function(module, exports, __webpack_require__) {

	
	    var graphic = __webpack_require__(3);
	    var util = __webpack_require__(71)
	    //创建Node类 所有形状都继承Node  包括fromJSON toJSON
	    function Node() {
	        this.resourceId = util.getUUID(); // 生成节点ID
	        graphic.Group.call(this);
	    }
	
	    /**
	     * 由父类实现
	     * @return {[type]} [description]
	     */
	    Node.prototype.render = function() {};
	
	    /**
	     * 由父类实现
	     * @param  {[type]} json [description]
	     * @return {[type]}      [description]
	     */
	    Node.prototype.getRect = function(json) {};
	
	    /**
	     * drawText
	     * @description 画一个文本
	     * @param {string} name
	     * @param {string} color
	     */
	    Node.prototype.drawText = function(name,color) {
	        var textName = this.bpmnInfo.name;
	        if(name != null){
	            textName = name;
	        }
	        var text = new graphic.Text({
	            style: {
	                text: textName,
	                color: color ? color : this.options.text.color,
	                textFont: '12px Microsoft YaHei'
	            },
	            zlevel: 20
	        });
	        //文字绘制的位置  
	        //x = 中心点.x - 起始位置.x - 文字宽度的一半
	        var x = this.getRect().x - this.position[0] - text.getBoundingRect().width / 2;
	        //y = 中心点.y - 起始位置.y + 节点高度的一半 + 偏移值（6）
	        var y = this.getRect().y - this.position[1] + this.getBoundingRect().height / 2 + text.getBoundingRect().height + 6;
	        text.attr("style", { x: x, y: y });
	        return {
	            text: text,
	            rect: text.getBoundingRect()
	        };
	    };
	    /**
	     * refreshText
	     * @description 刷新文本
	     */
	    Node.prototype.refreshText = function() {
	        var text = this.childOfName("Title");
	        var x = this.getRect().x - this.position[0] - text.getBoundingRect().width / 2;
	        var y = this.getRect().y - this.position[1] + this.getBoundingRect().height / 2 + text.getBoundingRect().height + 6;
	        text.attr("style", { x: x, y: y });
	    };
	    /**
	     * 由父类实现
	     * @return {[type]} [description]
	     */
	    Node.prototype.toJSON = function() {};
	
	    graphic.Util.inherits(Node, graphic.Group);
	    module.exports = Node;
	


/***/ },
/* 79 */
/***/ function(module, exports, __webpack_require__) {

	
	    var util = __webpack_require__(71);
	    var NetworkNode = __webpack_require__(77);
	    var zrUtil = __webpack_require__(4);
	    var graphic = __webpack_require__(3);
	    var NetworkModel = __webpack_require__(74);
	    
	    function RackNode(model,api) {
	        NetworkNode.call(this, model, api);
	        this.rackkInfo = {type: -1, name: "RackNode" };    
	        this.model = model;
	        this.render(model, api);
	    };
	
	    RackNode.prototype.render = function(model,api) {
	        this.model = model;
	        var _UData = model.get("UData");
	        var _showTip = model.get("showTip");
	        var _rackName = model.get("rack");
	        var _rackId = model.get("id");
	        var _description = model.get("description");
	        //title
	        var _title = new graphic.Text({
	            style: {
	                x: 80,
	                y: -30,
	                text: _rackName + '  42U',
	                width: 80,
	                height: 20,
	                fill: '#8F8B8A',
	                textFont: '18px Microsoft Yahei',
	                textBaseline: 'top'
	            },
	            draggable: true,
	            parmDate: { operation: "detailRack", rack: _rackName, id:_rackId, description: _description}
	        });
	        this.add(_title);
	
	        var afterButtonNode = new graphic.Image({
	            position: [0, 0],
	            scale: [1, 1],
	            style: {
	                x: 40,
	                y: -27,
	                image: './frm/fish-desktop/third-party/fish-topo/fish-topo-network/src/images/delete.png',
	                width: 18,
	                height: 18
	            },
	            z: 1000,
	            draggable: false,
	            parmDate: { operation: "deleteRack", rack: _rackName, id:_rackId }
	        }); 
	        this.add(afterButtonNode);
	
	        //绑定悬浮事件
	        var MOUSE_EVENT_NAMES = ['click'];
	        zrUtil.each(MOUSE_EVENT_NAMES, function (eveName) {
	
	            _title.on(eveName, function (e) {
	                var params = {};
	                if (eveName === "click") {
	                    var _parmDate = e.target.parmDate;
	                    params.event = _parmDate;
	                }  
	                api.trigger(eveName, params); 
	            }, this);
	
	            afterButtonNode.on(eveName, function (e) {
	                var params = {};
	                if (eveName === "click") {
	                    var _parmDate = e.target.parmDate;
	                    params.event = _parmDate;
	                }  
	                api.trigger(eveName, params); 
	            }, this);
	
	
	        }, this);
	  
	        var rectOut = new graphic.Rect({
	            shape: {
	                x: 0,
	                y: 0,
	                width: model.get("width"),
	                height: model.get("height")
	            },
	            style: {
	                fill: '#FFFFFF',
	                stroke: '#B3B3B3',
	                lineWidth: '1'//,
	            }          
	        });        
	        this.add(rectOut);
	        var rectIn = new graphic.Rect({
	            shape: {
	                x: 5,
	                y: 5,
	                width: model.get("width") - 10,
	                height: model.get("height") - 10
	            },
	            style: {
	                fill: '#FFFFFF',
	                stroke: '#B3B3B3',
	                lineWidth: '1'//,
	            }          
	        });        
	        this.add(rectIn);
	
	        var j = 1;
	        var _startY =  635;
	        while( j < 43 ) { 
	            var _floorNum = 1;
	            // var _y =  5 + ((42 - j ) * 15);
	            var _y =  _startY - (j * 15);
	            var _isnullFloor = false;
	            for ( var f = 0; f < _UData.length; f++ ) {
	                if ( j === parseInt(_UData[f].floor) ) {
	                    _floorNum = parseInt(_UData[f].height);
	                    _y = _y - (_floorNum - 1) * 15;
	                    var _server = "Server";
	                    if (_UData[f].type.toUpperCase() === "SWITCH") {
	                        _server = "Switch";
	                    }
	                    var modelObj = {
	                        resourceId: util.getUUID(),  
	                        properties: {
	                            type: "Server",         
	                            extProperties: {
	                            }  
	                        },
	                        bounds: {
	                            upperLeft: {x: 5, y: _y}  
	                        },
	                        stencil: {type: _server + "Node"}
	                    };
	                    modelObj.height =  15 * _floorNum - 1;
	                    modelObj.width = model.get("width") - 10;
	                    modelObj.parmDate = _UData[f];
	                    modelObj.floor = _UData[f].floor;
	                    modelObj.status = _UData[f].status;
	                    modelObj.floorNum = _floorNum;
	                    // if () {
	
	                    // }
	                    modelObj.serverType =  (_UData[f].vendor === undefined || _UData[f].vendor === "Unknown") ? "Server": _UData[f].vendor;
	                    if( _UData[f].column !== undefined) {
	                        modelObj.column = _UData[f].column;
	                    }
	                    //判断是否band悬浮事件
	                    modelObj.showTip = _showTip;
	                    var serverModel = new NetworkModel(modelObj);
	                    this.addNodeByModel(serverModel, api);
	
	                    var rectTray = new graphic.Rect({
	                        shape: {
	                            x: 5,
	                            y: _y + (15 * _floorNum) - 1 ,
	                            width: model.get("width") - 10,
	                            height: 1
	                        },
	                        style: {
	                            fill: '#FFFFFF',
	                            stroke: '#B3B3B3',
	                            lineWidth: '0.5'//,
	                        }          
	                    });        
	                    this.add(rectTray);
	                    _isnullFloor = true;
	                }
	            }
	            if( !_isnullFloor ) {
	                //   var rectTray = new graphic.Rect({
	                //     shape: {
	                //         x: 5,
	                //         y: 5 + ((42 - j ) * 15) ,
	                //         width: model.get("width") - 10,
	                //         height: 15
	                //     },
	                //     style: {
	                //         fill: '#FFFFFF',
	                //         stroke: '#B3B3B3',
	                //         lineDash: [3],  
	                //         lineWidth: '1'//,
	                //     }          
	                // });        
	                // this.add(rectTray);
	
	                var modelObj = {
	                    resourceId: util.getUUID(),  
	                    properties: {
	                        type: "EmptyFloor",         
	                        extProperties: {
	                        }  
	                    },
	                    bounds: {
	                        upperLeft: {x: 5, y: _y}  
	                    },
	                    width: model.get("width"),
	                    height: 15,
	                    stencil: {type: "EmptyFloorNode"}
	                };
	                modelObj.showTip = _showTip;
	                modelObj.parmDate = {nodeType: 'EmptyFloorNode', floor: j};
	                var emptyFloorModel = new NetworkModel(modelObj);
	                this.addNodeByModel(emptyFloorModel, api);
	
	            }
	            j = j + _floorNum;
	        }
	        this.position = [model.get("bounds.upperLeft.x") , model.get("bounds.upperLeft.y")];
	    };
	
	    RackNode.prototype.addNodeByModel = function( p_model, api) {
	        var Shape = api.getNodeClass(p_model.get("stencil.type"));
	        var node = null;
	        if ( Shape ) {
	            node = new Shape(p_model, this.api);
	            this.add(node);
	            var MOUSE_EVENT_NAMES = ['click'];
	            if ( p_model.get("showTip") ) {
	                MOUSE_EVENT_NAMES = ['click', 'mouseover', 'mouseout'];
	            }
	
	            if ( p_model.get("properties.type") === "EmptyFloorNode" ) {
	                 MOUSE_EVENT_NAMES = ['click'];
	            }
	
	            //绑定悬浮事件
	            zrUtil.each(MOUSE_EVENT_NAMES, function (eveName) {
	                node.on(eveName, function (e) {
	                    var params = {};
	                    if ( eveName === "mouseover") {
	                        // var _h = e.target.style.height !== undefined ?  (e.target.style.height / 2) : (15 / 2);
	                        var _ew = e.target.style.width !== undefined ?  (e.target.style.width + 5) : 205;
	                        params = {};
	                        params.event = e;
	                        // params.x = node.parent.position[0] + e.target.position[0];
	                        // params.y = node.parent.position[1] + e.target.position[1] + _h;
	                        params.x = e.offsetX;
	                        params.y = e.offsetY;
	                        params.width = 150;
	                        params.height = 170;
	                        params.eWidth =  5 ;
	                        // params.eWidth = _ew ;
	                        params.parmDate = e.target.parmDate;
	                        if ( api.getHeight() - params.y > params.height ) {
	                            params.layout = "down";
	                        } else {
	                            params.layout = "up";
	                        }
	                        // api.showTipWindow(params);
	                    } else if (eveName === "mouseout") {
	                        api.hideTipWindow(e.event.target);
	                    }  else if (eveName === "click") {
	                        var _parmDate = e.target.parmDate;
	                        if ( e.target.parent.rackkInfo !== undefined ) {
	                            _parmDate.rackId = e.target.parent.model.option.id;
	                            _parmDate.rackName = e.target.parent.model.option.rack;
	                        }  
	                        params.event =_parmDate;
	                    }  else if (eveName === "dbclick") {
	                        params.event = e.target.parmDate;
	                    } 
	                    api.trigger(eveName, params); 
	                }, this);
	            }, this);
	
	        }
	    };
	
	    // RackNode.prototype.toJSON = function() {
	    //     // body...
	    //     return this.model.option;
	    // };
	    zrUtil.inherits(RackNode, NetworkNode);
	    module.exports = RackNode;


/***/ },
/* 80 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 */
	
	    var util = __webpack_require__(71);
	    var NetworkNode = __webpack_require__(77);
	    var NetworkModel = __webpack_require__(74);
	    var RackNode = __webpack_require__(79);
	    var TipWindowNode = __webpack_require__(81);
	    var ServerNode = __webpack_require__(82);
	    var SwitchNode = __webpack_require__(83);
	    var EmptyFloorNode = __webpack_require__(84);
	    
	
	    var PointNode = __webpack_require__(85);
	    var CardNode =  __webpack_require__(86);
	    var TopoDrawNode = __webpack_require__(87);
	    var ServerTopoNode = __webpack_require__(95);
	    var ServerR630Node = __webpack_require__(96);
	    var ServerR730Node = __webpack_require__(97);
	    var ServerX3550Node = __webpack_require__(99);
	    var ServerX3650Node = __webpack_require__(100);
	    var ServerRD350Node = __webpack_require__(101);
	    var ServerRD650Node = __webpack_require__(102);
	    var SwitchTopoNode = __webpack_require__(103);
	    var SwitchHalfIBNode = __webpack_require__(104);
	    var SwitchFullIBNode = __webpack_require__(105);
	    var SwitchGMNode = __webpack_require__(106);
	    var SwitchKMNode = __webpack_require__(107);
	
	    var ClusterDrawNode = __webpack_require__(108);
	    var ClusterDatabaseNode = __webpack_require__(112);
	    var ClusterAsmNode = __webpack_require__(113);
	    var ClusterAsmCellNode = __webpack_require__(114);
	    var ClusterIseNode = __webpack_require__(115);
	    var ClusterIseCellNode =  __webpack_require__(116);
	 
	    /**
	     * 根据结点数组 导出JSON格式的数据
	     *
	     * @param {Array} nodes 结点数组
	     * @return {JSON} JSON格式的数据
	     */
	    function exportJson(networkModel, nodes) {
	        var jsonArr = [];
	        for(var i = 0; i < nodes.length;i++){
	            var node = nodes[i];
	            if( node && node.toJSON) {
	                jsonArr.push(node.toJSON());
	            }
	        }
	        networkModel.set("childShapes", jsonArr)  
	
	        return networkModel.option;
	    };
	
	    /**
	     * 根据 JSON 生成节点
	     * @param  {[type]} fishTopoBpmn [description]
	     * @param  {[type]} json         [description]
	     * @return {[type]}              [description]
	     */
	    function fromJson(fishTopoNetwork, json) {
	        // 1.清空画布
	        fishTopoNetwork.clear();
	        if ( json.type === "rack" ) {
	            var _x = 50;
	            for(var i = 0; i < json.data.length; i++) {
	                var modelObj = {
	                    resourceId: util.getUUID(),
	                    properties: {
	                        type: json.data[i].rack
	                    },
	                    bounds: {
	                        upperLeft: {x: _x, y: 50} 
	                    },
	                    stencil: {type: "RackNode"}
	                };
	                modelObj.height =  json.data[i].height != undefined ? json.data[i].height: 640;
	                modelObj.width = json.data[i].width != undefined ? json.data[i].width: 200;
	                modelObj.UData = json.data[i].UData;
	                modelObj.rack = json.data[i].name;
	                modelObj.id =  json.data[i].rack;
	                modelObj.description =  json.data[i].desc;
	                modelObj.showTip = json.showTip;
	                var rackModel = new NetworkModel(modelObj);
	                fishTopoNetwork.addNodeByModel(rackModel);
	                _x += 250;
	           }
	        } else if( json.type === "topo" ) {
	            var modelObj = {
	                resourceId: util.getUUID(),
	                bounds: {
	                    upperLeft: {x: 0, y: 0} 
	                },
	                stencil: {type: "TopoDrawNode"}
	            };
	            modelObj.height =  fishTopoNetwork.height;
	            modelObj.width = fishTopoNetwork.width;
	            modelObj.nodeList = json.data;
	            modelObj.showTip = json.showTip;
	            var topoModel = new NetworkModel(modelObj);
	            fishTopoNetwork.addNodeByModel(topoModel);
	        } else if( json.type === "cluster" ) {
	            var modelObj = {
	                resourceId: util.getUUID(),
	                bounds: {
	                    upperLeft: {x: 0, y: 0} 
	                },
	                stencil: {type: "ClusterDrawNode"}
	            };
	            modelObj.height =  fishTopoNetwork.height;
	            modelObj.width = fishTopoNetwork.width;
	            modelObj.nodeList = json.data;
	            modelObj.showTip = json.showTip;
	            var clusterModel = new NetworkModel(modelObj);
	            fishTopoNetwork.addNodeByModel(clusterModel);
	        }
	        
	    }
	
	    function registerNetworkNode () {
	        NetworkNode.registerClass(RackNode, "RackNode");
	        NetworkNode.registerClass(TipWindowNode, "TipWindowNode");
	        NetworkNode.registerClass(ServerNode, "ServerNode");
	        NetworkNode.registerClass(SwitchNode, "SwitchNode");
	        NetworkNode.registerClass(EmptyFloorNode, "EmptyFloorNode");
	
	        NetworkNode.registerClass(ServerTopoNode, "ServerTopoNode");
	        NetworkNode.registerClass(TopoDrawNode, "TopoDrawNode");
	        NetworkNode.registerClass(ServerR630Node, "ServerR630Node");
	        NetworkNode.registerClass(ServerR730Node, "ServerR730Node");
	        NetworkNode.registerClass(PointNode, "PointNode"); 
	        NetworkNode.registerClass(CardNode, "CardNode"); 
	        NetworkNode.registerClass(ServerX3550Node, "ServerX3550Node"); 
	        NetworkNode.registerClass(ServerX3650Node, "ServerX3650Node"); 
	        NetworkNode.registerClass(ServerRD350Node, "ServerRD350Node");
	        NetworkNode.registerClass(ServerRD650Node, "ServerRD650Node");
	        NetworkNode.registerClass(SwitchFullIBNode, "SwitchFullIBNode");
	        NetworkNode.registerClass(SwitchHalfIBNode, "SwitchHalfIBNode");
	        NetworkNode.registerClass(SwitchKMNode, "SwitchKMNode");
	        NetworkNode.registerClass(SwitchGMNode, "SwitchGMNode"); 
	        
	        NetworkNode.registerClass(ClusterDrawNode, "ClusterDrawNode"); 
	        NetworkNode.registerClass(ClusterDatabaseNode, "ClusterDatabaseNode"); 
	        NetworkNode.registerClass(ClusterAsmNode, "ClusterAsmNode");  
	        NetworkNode.registerClass(ClusterAsmCellNode, "ClusterAsmCellNode"); 
	        NetworkNode.registerClass(ClusterIseNode, "ClusterIseNode"); 
	        NetworkNode.registerClass(ClusterIseCellNode, "ClusterIseCellNode"); 
	                     
	    }   
	
	    var NextWorkUtil = {
	        exportJson: exportJson,
	        fromJson: fromJson,
	        registerNetworkNode: registerNetworkNode
	    };
	    module.exports = NextWorkUtil;
	


/***/ },
/* 81 */
/***/ function(module, exports, __webpack_require__) {

	
		var Node = __webpack_require__(78);
		var zrUtil = __webpack_require__(4);
		var graphic = __webpack_require__(3);
		var clazzUtil = __webpack_require__(76);
		
		//创建Node类 所有形状都继承Node  包括fromJSON toJSON
		function TipWindowNode(model, api) {
			Node.call(this);
			this.model = model;		
			this.nextworkInfo = {type: -1, name:"TipWindowNodeDiagram" };    //节点信息
			this.initEvent(api);
	        this.render(model, api);
		};
	
	    TipWindowNode.prototype.initEvent = function(api) {
	        // var that = this;
	        // var MOUSE_EVENT_NAMES = ['click', 'mouseover', 'mouseout'];//'click', 'dblclick', 'mouseover', 'mouseout'
	        // zrUtil.each(MOUSE_EVENT_NAMES, function (eveName) {
	        //     that.on(eveName, function (e) {
		       //      var params = {};
		       //      params.event = e;
		       //      params.type = eveName;
		       //      params.model = that.model
		       //      api.trigger(eveName, params); 
	        //     }, this);
	        // }, this);
	    };	
	
		TipWindowNode.prototype.render = function(model, api) {
			var _x = model.x;
	        var _y = model.y;
	        var _xWidth = model.eWidth;
	        var _width = model.width;
	        var _height = model.height;
			var points = [
					[_x + _xWidth + 20, _y],
					[_x + _xWidth, _y],
					[_x + _xWidth + 20, _y + 15],	
					[_x + _xWidth + 20, _y + _height],
					[_x + _xWidth + _width, _y + _height],
					[_x + _xWidth + _width, _y]
				];
			if ( model.layout != undefined && model.layout === "up" ) {
				points = [
					[_x + _xWidth + 20, _y],
					[_x + _xWidth, _y],
					[_x + _xWidth + 20, _y - 15],	
					[_x + _xWidth + 20, _y - _height],
					[_x + _xWidth + _width, _y - _height],
					[_x + _xWidth + _width, _y]
				];
			} 
	
			if ( model.layout != undefined && model.layout === "left" ) {
				points = [
					[_x - 2 * _width - 10, _y],
					[_x - 2 * _width + 10, _y],
					[_x - 2 * _width - 10, _y + 15],	
					[_x - 2 * _width - 10, _y + _height],
					[_x - 2 * _width - _width, _y + _height],
					[_x - 2 * _width - _width, _y]
				];
			}	
			var _tipContext = "请查询数据";
			if ( model.parmDate !== undefined ) {
				if( model.parmDate.type === "switch" ) {
					_tipContext = 'hostname: '+ model.parmDate.hostname +' \n status: ' + model.parmDate.status + ' \n floor: ' + model.parmDate.floor +  '\n height: ' + model.parmDate.height + "\n vendor:" +  model.parmDate.vendor;
				
				} else if( model.parmDate.nodeType === "EmptyFloorNode" ) {
					_tipContext = 'floor: ' + model.parmDate.floor;
				
				} else {
					_tipContext = 'hostname: '+ model.parmDate.hostname +' \n status: ' + model.parmDate.status + ' \n  Ip: ' + model.parmDate.ipaddress +  '\n floor: ' + model.parmDate.floor +  '\n height: ' + model.parmDate.height + "\n vendor:" +  model.parmDate.vendor;
				}
				
				if ( model.parmDate.tipContext !== undefined ) {
					_tipContext = model.parmDate.tipContext;
				}
			}
			
			var tip = new graphic.Polygon({
	            shape: {
	                points: points
	            },
	            style: {
					stroke: 'rgba(174, 174,174, 1.0)',
					fill: 'rgba(255, 255, 255, 1.0)',
					lineWidth: 1,
					text: _tipContext,
					textAlign: 'center'//,
					//textPosition: 'left',
					//smooth: 'bezier'	
				},   
				z: 1000     
	        });        
	        this.add(tip);
		};
	
		zrUtil.inherits(TipWindowNode, Node);
	
	
		module.exports = TipWindowNode;
	


/***/ },
/* 82 */
/***/ function(module, exports, __webpack_require__) {

	
	    var NetworkNode = __webpack_require__(77);
	     var zrUtil = __webpack_require__(4);
	    var graphic = __webpack_require__(3);
	    function ServerNode(model,api) {
	        NetworkNode.call(this, model, api);
	        this.serverInfo = {type: -1, name: "ServerNode" };    //
	        this.model = model;
	        return this.render(model,api);
	    };
	
	    
	        
	    ServerNode.prototype.render = function(model, api) {
	        this.model = model;
	        var status = model.get("status");
	        var imageUrl = '../../../../fish-topo-network/src/images/' + model.get("serverType") ;
	        // if ( status !== "" && status !== null && status !== undefined) {
	        //      imageUrl += status;
	        // }
	        imageUrl += '.png';
	
	        //״̬ 
	        var cellStateNode = new graphic.Circle({
	             shape: {
	                cx: 10,
	                cy: (15 * model.get("floorNum") - 3) / 2,
	                r: 4
	            },
	            style: {
	                fill: '#077826',
	                opacity: 1,
	                stroke: '#B3B3B3',
	                lineWidth: '2'//,*/
	            },
	            z: 1000 
	        });
	        if ( status !== "" && status !== null && status === "offline") {
	            cellStateNode.style.fill = "#999999";
	        }
	        this.add(cellStateNode);
	
	        var rectServer = new graphic.Image({
	            position: [0, 0],
	            scale: [1, 1],
	            style: {
	                x: 0,
	                y: 0,
	                image: imageUrl,
	                width: model.get("width"),
	                height:  15 * model.get("floorNum") - 3
	            },
	            draggable: false,
	            parmDate: model.get("parmDate")    
	        }); 
	        //rectServer.position = [model.get("bounds.upperLeft.x"), model.get("bounds.upperLeft.y")];
	        this.add(rectServer);
	
	        this.position = [model.get("bounds.upperLeft.x") , model.get("bounds.upperLeft.y")];
	        // return rectServer;
	    };
	
	    zrUtil.inherits(ServerNode, NetworkNode);
	    module.exports = ServerNode;
	


/***/ },
/* 83 */
/***/ function(module, exports, __webpack_require__) {

	
	    var NetworkNode = __webpack_require__(77);
	    var zrUtil = __webpack_require__(4);
	    var graphic = __webpack_require__(3);
	    function SwitchNode(model,api) {
	        NetworkNode.call(this, model, api);
	        this.serverInfo = {type: -1, name: "SwitchNode" };    //
	        this.model = model;
	        return this.render(model,api);
	    };
	
	    SwitchNode.prototype.render = function(model,api) {
	        this.model = model;
	        var _px = model.get("bounds.upperLeft.x");
	        var _py = model.get("bounds.upperLeft.y");
	        var _height = model.get("height");
	        var _width = model.get("width");
	        if(model.get("column") === undefined || model.get("column") === "all" ) {
	            
	        } else {
	            _width = model.get("width") / 2 - 5;
	            if ( model.get("column") === "right" ) {
	                 _px = 5 + _width + 5;
	            }      
	        }
	        var rectSwitch = new graphic.Image({
	            position: [0, 0],
	            scale: [1, 1],
	            style: {
	                x: 0,
	                y: 0,
	                image: '../../../../fish-topo-network/src/images/IBSwitchFull.png',
	                width: _width,
	                height:  _height
	            },
	            draggable: false,
	            parmDate : model.get("parmDate")    
	            // _parmDate : "111"       
	        }); 
	        rectSwitch.position = [ _px, _py]; 
	        return rectSwitch;
	    };
	
	    zrUtil.inherits(SwitchNode, NetworkNode);
	    module.exports = SwitchNode;
	


/***/ },
/* 84 */
/***/ function(module, exports, __webpack_require__) {

	
	    var NetworkNode = __webpack_require__(77);
	    var zrUtil = __webpack_require__(4);
	    var graphic = __webpack_require__(3);
	    function EmptyFloorNode(model,api) {
	        NetworkNode.call(this, model, api);
	        this.serverInfo = {type: -1, name: "EmptyFloorNode" };    //
	        this.model = model;
	        return this.render(model,api);
	    };
	
	    EmptyFloorNode.prototype.render = function(model, api) {
	        this.model = model;
	        var rectTray = new graphic.Rect({
	                shape: {
	                    x: 0,
	                    y: 0,
	                    width: model.get("width") - 10,
	                    height: 15
	                },
	                style: {
	                    fill: '#FFFFFF',
	                    stroke: '#B3B3B3',
	                    lineDash: [3],  
	                    lineWidth: '1'//,
	                }  ,
	                draggable: false,
	                parmDate: model.get("parmDate")            
	            });        
	        this.add(rectTray);
	        rectTray.position = [model.get("bounds.upperLeft.x"), model.get("bounds.upperLeft.y")]; 
	        return rectTray;
	
	        // var rectServer = new graphic.Image({
	        //     position: [0, 0],
	        //     scale: [1, 1],
	        //     style: {
	        //         x: 0,
	        //         y: 0,
	        //         image: './frm/fish-desktop/third-party/fish-topo/fish-topo-network/src/images/lenovoRd650a.png',
	        //         width: model.get("width") - 10,
	        //         height:  15
	        //     },
	        //     draggable: false
	        // }); 
	        // rectServer.position = [model.get("bounds.upperLeft.x"), model.get("bounds.upperLeft.y")];
	        // return rectServer;
	
	    };
	    zrUtil.inherits(EmptyFloorNode, NetworkNode);
	    module.exports = EmptyFloorNode;


/***/ },
/* 85 */
/***/ function(module, exports, __webpack_require__) {

	
	    var util = __webpack_require__(71);
	    var NetworkNode = __webpack_require__(77);
	    var zrUtil = __webpack_require__(4);
	    var graphic = __webpack_require__(3);
	    var NetworkModel = __webpack_require__(74);
	    
	    function PointNode(model,api) {
	        NetworkNode.call(this, model, api);
	        this.rackkInfo = {type: -1, name: "PointNode" };    
	        this.model = model;
	        this.lineInfo = model.get('lineInfo');
	        this.render(model,api);
	    };
	
	    PointNode.prototype.render = function(model, api) {
	        this.model = model;
	        var _title = new graphic.Text({
	            style: {
	                x: model.get("width") / 2 - 10,
	                y: -20,
	                text: model.get("name"),
	                width: 200,
	                height: 20,
	                fill: '#8F8B8A',
	                textFont: '12px Microsoft Yahei',
	                textBaseline: 'top'
	            },
	            draggable: true
	        });
	        // this.add(_title);
	
	        var portNode = new graphic.Rect({
	            shape: {
	                x: 0,
	                y: 0,
	                width: model.get("width"),
	                height: model.get("height")
	            },
	            style: {
	                fill: '#E2E3D9',
	                stroke: '#B3B3B3',
	                opacity: 0.1,
	                lineWidth: '1'//,
	            }          
	        });              
	        this.add(portNode);
	
	        this.position = [model.get("bounds.upperLeft.x") , model.get("bounds.upperLeft.y")];
	    };
	
	   
	
	    zrUtil.inherits(PointNode, NetworkNode);
	    module.exports = PointNode;
	


/***/ },
/* 86 */
/***/ function(module, exports, __webpack_require__) {

	
	    var util = __webpack_require__(71);
	    var NetworkNode = __webpack_require__(77);
	    var zrUtil = __webpack_require__(4);
	    var graphic = __webpack_require__(3);
	    var NetworkModel = __webpack_require__(74);
	    
	    function CardNode(model,api) {
	        NetworkNode.call(this, model, api);
	        this.rackkInfo = {type: -1, name: "CardNode" };    
	        this.model = model;
	        this.lineInfo = model.get('lineInfo');
	        this.pointList = [];
	        this.render(model,api);
	    };
	
	    CardNode.prototype.render = function(model, api) {
	        this.model = model;
	        var _portData = model.get("portData");
	        var _type = model.get("type");
	        var _direction = model.get("direction");
	        var imgUrl = "";
	        if( _type === "1" || _type === "3" ) {
	            imgUrl = '../../../src/third-party/fish-topo/fish-topo-network/src/images/IB1.jpg';
	        }else if ( _type === "5" ) {
	            imgUrl = '../../../src/third-party/fish-topo/fish-topo-network/src/images/km2.jpg';
	        } else if( _type === "6" ) {
	            imgUrl = '../../../src/third-party/fish-topo/fish-topo-network/src/images/km4.jpg';
	        }
	
	
	         var rectServer = new graphic.Image({
	            scale: [1, 1],
	            style: {
	                x: 0,
	                y: 0,
	                image: imgUrl,
	                width: model.get("width"),
	                height: model.get("height")
	            },
	            draggable: false,
	            invisible: false,
	            parmDate: _portData
	        }); 
	        this.add(rectServer);
	        rectServer.hide();
	
	        var _resourcesName = model.get("resourcesName");
	        var _resourceNodeType = model.get("resourceNodeType");
	        var _No = model.get("No");
	        if ( _direction === "leftRight" ) {
	            var _x = 4;
	            var _y = 2;
	            var _width = 8;
	            var _height = 5; 
	            if ( _type === "1" ||  _type === "2" ||  _type === "3" ||  _type === "4" ) {
	                _width = 20;
	            }
	            for( var i = 0; i < _portData.length; i++ ) {
	                var portModel = {};
	                portModel = {
	                    resourceId: util.getUUID(),  
	                    bounds: {
	                        upperLeft: {x: _x, y: _y}  
	                    },
	                    stencil: {type: "PointNode"}
	                };
	                portModel.height = _height;
	                portModel.width = _width;
	
	                var _linInfo = {};
	                _linInfo.sourceReource = _resourcesName;
	                _linInfo.sourceCardNo = _No;
	                _linInfo.sourcePort = i;
	                _linInfo.nodetype = _resourceNodeType; 
	                _linInfo.sourceStatus =  _portData[i].status;        
	                _linInfo.targetReource = _portData[i].target.resourceName ;
	                _linInfo.targetPort = _portData[i].target.port;
	
	                portModel.lineInfo = _linInfo;
	                var pModel = new NetworkModel(portModel);
	                this.addPortByModel(pModel, api);
	                 _x = _x + _width + 2;
	            }    
	        } 
	        
	
	        this.position = [model.get("bounds.upperLeft.x") , model.get("bounds.upperLeft.y")];
	    };
	
	   CardNode.prototype.addPortByModel = function( p_model, api) {
	        var Shape = api.getNodeClass(p_model.get("stencil.type"));
	        var node = null;
	        if ( Shape ) {
	            node = new Shape(p_model, api);
	            this.pointList.push(node);
	            this.add(node);
	        }
	    };
	
	    zrUtil.inherits(CardNode, NetworkNode);
	    module.exports = CardNode;
	


/***/ },
/* 87 */
/***/ function(module, exports, __webpack_require__) {

	
	    var util = __webpack_require__(71);
	    var NetworkNode = __webpack_require__(77);
	    var NetWorkLineNode = __webpack_require__(88);
	    var zrUtil = __webpack_require__(4);
	    var graphic = __webpack_require__(3);
	    var NetworkModel = __webpack_require__(74);
	    var NetWorkLineModel = __webpack_require__(94);
	
	    function TopoDrawNode(model,api) {
	        NetworkNode.call(this, model, api);
	        this.topoInfo = {type: -1, name: "TopoDrawNode" };    
	        this.model = model;
	        this.portList = [];
	        this.render(model,api);
	    };
	
	    TopoDrawNode.prototype.render = function(model, api) {
	        var nodeList = model.get("nodeList");
	        var serverWidth = 160; //服务器宽度
	        var switchWidth = 300; //交换机宽度
	        //根据Node数量计算实际画布宽度
	        var clentWidth = this.getWidth(nodeList, serverWidth, switchWidth);
	        clentWidth = clentWidth > model.get("width") ? clentWidth : model.get("width");
	        api.resize(clentWidth, model.get("height"));
	
	        this.model = model;
	        var _showTip = model.get("showTip");
	
	        var _startX = 100,
	            _textW = 30,
	            _startY = 10,
	            _textH = 20;
	        var textKM = new graphic.Text({
	            style: {
	                x: _startX,
	                y: _startY,
	                text: '千兆',
	                width: _textW,
	                height: _textH,
	                fill: '#8F8B8A',
	                textFont: '10px Microsoft Yahei',
	                textBaseline: 'top'
	            },
	            draggable: true
	        });
	        this.add(textKM);
	
	        var lineKM = new graphic.Line({
	            shape: {
	                x1 : _startX + _textW,
	                y1 : _startY + 10,
	                x2 : _startX + _textW + 100,
	                y2 : _startY + 10,
	                lineWidth : 5,  
	                text : 'line'
	            },
	            style: {
	                stroke: '#0704EC',
	                lineType : 'solid',// default solid
	                fill: null
	            }        
	        });        
	        this.add(lineKM);
	
	        _startY = _startY + _textH;
	        var textGB = new graphic.Text({
	            style: {
	                x: _startX,
	                y: _startY,
	                text: '万兆',
	                width: _textW,
	                height: _textH,
	                fill: '#8F8B8A',
	                textFont: '10px Microsoft Yahei',
	                textBaseline: 'top'
	            },
	            draggable: true
	        });
	        this.add(textGB);
	
	        var lineGB = new graphic.Line({
	            shape: {
	                x1 : _startX + _textW,
	                y1 : _startY + 10 ,
	                x2 : _startX + _textW + 100,
	                y2 : _startY + 10,
	                lineWidth : 5,  
	                text : 'line'
	            },
	            style: {
	                stroke: '#070413',
	                lineType : 'solid',// default solid
	                fill: null
	            }        
	        });        
	        this.add(lineGB);
	
	        _startY =  _startY + _textH;
	        var textIB = new graphic.Text({
	            style: {
	                x: _startX,
	                y: _startY,
	                text: 'IB',
	                width: _textW,
	                height: _textH,
	                fill: '#8F8B8A',
	                textFont: '10px Microsoft Yahei',
	                textBaseline: 'top'
	            },
	            draggable: true
	        });
	        this.add(textIB);
	
	        var lineIB = new graphic.Line({
	            shape: {
	                x1 : _startX + _textW,
	                y1 : _startY + 10,
	                x2 : _startX + _textW + 100,
	                y2 : _startY + 10,
	                lineWidth : 5,  
	                text : 'line'
	            },
	            style: {
	                stroke: '#62A4DD',
	                lineType : 'solid',// default solid
	                fill: null
	            }        
	        });        
	        this.add(lineIB);
	
	        //主线布局
	        var lineOut = new graphic.Line({
	            shape: {
	                x1 : 50,
	                y1 : 70,
	                x2 : 50,
	                y2 : 700,
	                text : 'line'
	            },
	            style: {
	                stroke: '#000',
	                lineType : 'solid',// default solid
	                lineWidth : 3,  
	                fill: null
	            }        
	        });        
	        this.add(lineOut);
	
	        var lineUp = new graphic.Line({
	            shape: {
	                x1 : 50,
	                y1 : 250,
	                x2 : clentWidth - 50,
	                y2 : 250,
	                text : 'line'
	            },
	            style: {
	                stroke: '#000',
	                lineType : 'solid',// default solid
	                lineWidth : 3,  
	                fill: null
	            }        
	        });        
	        this.add(lineUp);
	
	        var lineDown = new graphic.Line({
	            shape: {
	                x1 : 50,
	                y1 : 450,
	                x2 : clentWidth - 50,
	                y2 : 450, 
	                text : 'line'
	            },
	            style: {
	                stroke: '#000',
	                lineType : 'solid',// default solid
	                lineWidth : 3,  
	                fill: null
	            }        
	        });        
	        this.add(lineDown);
	
	         //循环添加topo图上的节点
	        var startComputeX = 70;
	        var startStorageX = 110; 
	        var startSwitchX = 90; 
	        for ( var i = 0; i < nodeList.length; i++ ) {
	            var nodeY = 145;
	            var modelObj = {};
	            var _typeNode = "TopoDrawNode";
	            if ( nodeList[i].nodetype === "compute" ) {
	                if (nodeList[i].type  === "ServerR730" || nodeList[i].type  === "ServerX3650") {
	                    nodeY = 125;
	                }
	                _typeNode = nodeList[i].type + "Node";
	                modelObj = {
	                    resourceId: util.getUUID(),  
	                    bounds: {
	                        upperLeft: {x: startComputeX, y: nodeY}  
	                    },
	                    stencil: {type: _typeNode}
	                };
	                modelObj.name = nodeList[i].resourceName;
	                modelObj.width = serverWidth;
	                startComputeX += serverWidth + 20;
	            } else if (nodeList[i].nodetype === "storage" ) {           
	                nodeY = 550;
	                _typeNode = nodeList[i].type + "Node";
	                modelObj = {
	                    resourceId: util.getUUID(),  
	                    bounds: {
	                        upperLeft: {x: startStorageX, y: nodeY}  
	                    },
	                    stencil: {type: _typeNode}
	                };
	                modelObj.name = nodeList[i].resourceName;
	                modelObj.width = serverWidth;
	                startStorageX += serverWidth + 20;
	            } else if (nodeList[i].nodetype === "switch" ) {
	                var type = nodeList[i].type !== undefined && nodeList[i].type !== null ? nodeList[i].type : "";
	                var switchType = "SwitchHalfIB";
	                if ( type.toUpperCase() === "FULL" ) {
	                    switchType = "SwitchFullIB";
	                }
	                _typeNode = switchType + "Node";
	                nodeY = 335;
	                modelObj = {
	                    resourceId: util.getUUID(),  
	                    bounds: {
	                        upperLeft: {x: startSwitchX, y: nodeY}  
	                    },
	                    stencil: {type: _typeNode}
	                }; 
	                if ( nodeList[i].type  === "Half" ) {
	                    modelObj.width = switchWidth / 2;
	                    startSwitchX += switchWidth / 2 + 50;
	                } else {
	                    modelObj.width = switchWidth;
	                    startSwitchX += switchWidth + 50;
	                } 
	                modelObj.name = "Name: "  + nodeList[i].resourceName + ", No：" + nodeList[i].manager_ipaddr;
	                modelObj.portNum = nodeList[i].portTotal;
	            } else if (nodeList[i].nodetype === "ESwitch" ) {
	                nodeY = 335;
	                modelObj = {
	                    resourceId: util.getUUID(),  
	                    bounds: {
	                        upperLeft: {x: startSwitchX, y: nodeY}  
	                    },
	                    stencil: {type: "SwitchKMNode"}
	                }; 
	                modelObj.name = nodeList[i].resourceName;
	                modelObj.width = switchWidth;
	                startSwitchX += switchWidth + 50;       
	            }
	            if ( modelObj.stencil !== undefined && modelObj.stencil.type !== undefined ) {
	                if ( modelObj.stencil.type !== undefined &&  modelObj.stencil.type !== "ServerR730Node" &&
	                     modelObj.stencil.type !== "ServerR630Node" &&
	                     modelObj.stencil.type !== "SwitchFullIBNode" &&
	                     modelObj.stencil.type !== "SwitchHalfIBNode" &&
	                     modelObj.stencil.type !== "SwitchKMNode"
	                 ) {
	                    modelObj.stencil.type = "ServerTopoNode";
	                }
	            }
	            
	            modelObj.status =  nodeList[i].status;
	            modelObj.nodetype = nodeList[i].nodetype;
	            modelObj.type = nodeList[i].type;
	            var _parmDate = {};
	            _parmDate.hostId = nodeList[i].host_id;
	            _parmDate.name = nodeList[i].resourceName;
	            _parmDate.noteType = nodeList[i].nodetype;
	            _parmDate.status = nodeList[i].status;
	            _parmDate.type = nodeList[i].type;
	            _parmDate.key = nodeList[i].manager_ipaddr ? nodeList[i].manager_ipaddr : "";
	
	
	            modelObj.parmDate = _parmDate;
	            modelObj.height =  15;
	            if ( nodeList[i].ports != undefined ) {
	                modelObj.ports = nodeList[i].ports;
	            }
	            //判断是否band悬浮事件
	            modelObj.showTip = _showTip;
	            var serverModel = new NetworkModel(modelObj);
	            this.addNodeByModel(serverModel, api);
	        }
	
	        //连线
	        for ( var ps = 0; ps < this.portList.length; ps++ ) {
	            var startNode = this.portList[ps];
	            var endNode = null;
	            for ( var pe = 0; pe < this.portList.length; pe++ ) {
	                if (startNode.lineInfo.targetReource === this.portList[pe].lineInfo.sourceReource 
	                    && startNode.lineInfo.targetPort === this.portList[pe].lineInfo.sourcePort ) {
	                    endNode = this.portList[pe];
	                    break;
	                }
	            }
	            //连线
	            if( endNode !== null && startNode != null ) {
	                this.drawLine(startNode, endNode, api);
	            }
	
	
	        }
	        this.position = [model.get("bounds.upperLeft.x") , model.get("bounds.upperLeft.y")];
	    };
	
	    TopoDrawNode.prototype.getWidth = function( p_nodeList, p_serverW, p_switchW ) {
	        // var computeCount = 0;
	        // var storageCount = 0; 
	        // var switchCount = 0; 
	        // for ( var i = 0; i < p_nodeList.length; i++ ) {
	        //     if ( p_nodeList[i].nodetype === "1" ) {
	        //        computeCount++;
	        //     } else if (p_nodeList[i].nodetype === "2" ) {           
	        //         storageCount++;
	        //     } else if (p_nodeList[i].nodetype === "3" ) {
	        //         switchCount++;
	        //     }
	        // }
	        // var serverCount = computeCount > storageCount ? computeCount : storageCount; 
	        // var w1 = 60 + serverCount * (p_serverW + 50) + 150;
	        // var s1 = 40 + switchCount * (p_switchW + 50) + 150;
	        var computeWidth = 210;
	        var storageWidth = 210; 
	        var switchWidth = 190; 
	        for ( var i = 0; i < p_nodeList.length; i++ ) {
	            if ( p_nodeList[i].nodetype === "compute" ) {
	               computeWidth += p_serverW + 50;
	            } else if (p_nodeList[i].nodetype === "storage" ) {           
	                storageWidth += p_serverW + 50;
	            } else if (p_nodeList[i].nodetype === "switch" ) {
	                if( p_nodeList[i].portTotal > 12 ) {
	                    switchWidth += p_switchW + 50; 
	                } else {
	                    switchWidth += (p_switchW / 2) + 50; 
	                }
	            } else if (p_nodeList[i].nodetype === "ESwitch" ) {
	                switchWidth += p_switchW + 50; 
	            }
	        }
	        var serverWidth = computeWidth > storageWidth ? computeWidth : storageWidth;
	        return serverWidth > switchWidth ? serverWidth : switchWidth;
	    };
	
	    TopoDrawNode.prototype.addNodeByModel = function( p_model, api) {
	        var Shape = api.getNodeClass(p_model.get("stencil.type"));
	        var node = null;
	        if ( Shape ) {
	            node = new Shape(p_model, api);
	            this.add(node);
	            if( node.portNodeList !== undefined && node.portNodeList.length > 0 ) {
	                for (var i = 0; i < node.portNodeList.length; i++ ) {
	                    this.portList.push(node.portNodeList[i]);
	                }
	                //this.portList.concat(node.portNodeList);
	            }
	
	             //绑定事件
	            var MOUSE_EVENT_NAMES = ['click'];
	            if ( p_model.get("showTip") ) {
	                MOUSE_EVENT_NAMES = ['click', 'mouseover', 'mouseout'];
	            }
	            zrUtil.each(MOUSE_EVENT_NAMES, function (eveName) {
	                node.on(eveName, function (e) {
	                    var params = {};
	                    if ( eveName === "mouseover") {
	                        params.event = e;
	                        params.x = e.offsetX;
	                        params.y = e.offsetY;
	                        params.width = 150;
	                        params.height = 170;
	                        params.eWidth =  5 ;
	                        params.parmDate = e.target.parent.parmDate;
	                        params.type = "lineTip";
	                        if (params.parmDate !== undefined ) {
	                            var _name = params.parmDate.name;
	                            var text = "name: " + _name + "\n" +
	                                       "noteType: "+ params.parmDate.noteType + "\n";
	                            if ( params.parmDate.status !== null && params.parmDate.status !== undefined ) {
	                                text += "status: "+ params.parmDate.status + "\n";
	                            }
	                             if ( params.parmDate.type !== null && params.parmDate.type !== undefined ) {
	                                text += "type: "+ params.parmDate.type + "\n";
	                            }
	                            params.parmDate.tipContext = text; 
	                        } 
	                        
	                        if ( api.getHeight() - params.y > params.height ) {
	                            params.layout = "down";
	                        } else {
	                            params.layout = "up";
	                        }
	
	                        //api.showTipWindow(params);
	                    } else if (eveName === "mouseout") {
	                        api.hideTipWindow(e.event.target);
	                    } else if (eveName === "click") {
	                        var _parmDate = e.target.parmDate;
	                        params.event =_parmDate;
	                    } 
	                    api.trigger(eveName, params); 
	                }, this);
	             }, this);
	        }
	    };
	
	    TopoDrawNode.prototype.drawLine = function( p_startNode, p_endNode, api ) {
	        var fleftx = p_startNode.position[0] + p_startNode.parent.position[0] + p_startNode.parent.parent.position[0];
	        var flefty = p_startNode.position[1] + p_startNode.parent.position[1] + p_startNode.parent.parent.position[1];
	        var fwidth = p_startNode.model.get("width");
	        var fheight = p_startNode.model.get("height");
	
	        var torightx = p_endNode.position[0] + p_endNode.parent.position[0];
	        var torighty = p_endNode.position[1] + p_endNode.parent.position[1];
	        var towidth = p_endNode.model.get("width");
	        var toheight = p_endNode.model.get("height");
	        var moddleY = 250;
	        var nodetype = p_startNode.model.get("lineInfo").nodetype;
	        if( nodetype === "storage" ) {
	            moddleY = 450;
	        }
	        var _lindColor = "#62A4DD";
	        var _lineInfo = p_startNode.model.get("lineInfo");
	        if ( _lineInfo.portType === "1") {
	            _lindColor = "#62A4DD";
	        } else if ( _lineInfo.portType === "2")  {
	             _lindColor = "#070413";
	        } else if ( _lineInfo.portType === "3")  {
	            _lindColor = "#0704EC";
	        } 
	        if ( _lineInfo.portState.toUpperCase() !== "UP" ) {
	            _lindColor = "#FFCC00";
	        }
	        if ( p_endNode.model.get("lineInfo").sourceReourceName !== undefined && p_endNode.model.get("lineInfo").sourceReourceName !== null ) {
	            _lineInfo.sourceReourceName = p_endNode.model.get("lineInfo").sourceReourceName;
	        }
	        var _moddleX = p_startNode.lineInfo.moddleX;
	        var defaultOption = {
	            fromBounds : {x: fleftx, y: flefty, width: fwidth, height: fheight},
	            toBounds: {x: torightx, y: torighty, width: towidth, height: toheight},
	            moddleY: moddleY,
	            style : {
	                lineWidth : 1,
	                stroke: _lindColor//,
	                //fill: '#9699DD'
	            },
	            hoverStyle : {
	                lineWidth : 1,
	                stroke: '#47D930'//,
	                //fill:'#2FDE92'
	            }
	        };
	        if ( _moddleX !== undefined ) {
	            defaultOption.moddleX =  _moddleX;
	        }
	
	        defaultOption.parmData = _lineInfo;
	        var netWorkLineModel = new NetWorkLineModel(defaultOption);
	        var netWorkLineNode = new NetWorkLineNode(netWorkLineModel);
	        this.add(netWorkLineNode);
	
	
	        //绑定事件
	        var MOUSE_EVENT_NAMES = ['mouseover', 'mouseout'];
	        zrUtil.each(MOUSE_EVENT_NAMES, function (eveName) {
	            netWorkLineNode.on(eveName, function (e) {
	                var params = {};
	                if ( eveName === "mouseover") {
	                    params.event = e;
	                    params.x = e.offsetX;
	                    params.y = e.offsetY;
	                    params.width = 200;
	                    params.height = 170;
	                    params.eWidth =  5 ;
	                    params.parmDate = e.target.parent.parent.parmData;
	                    params.type = "lineTip";
	                    var text = "Status: "+  params.parmDate.portState + "\n";
	                        text += "Source Reource: "+  params.parmDate.sourceReource + "\n";
	                        text += "Source Port: "+  params.parmDate.sourcePort + "\n";
	                    if ( params.parmDate.ip !== undefined && params.parmDate.ip !== null ) {
	                        text += "IP: "+  params.parmDate.ip+ "\n";
	                    }  
	                    if ( params.parmDate.portType !== undefined && params.parmDate.portType !== null ) {
	                        if ( params.parmDate.portType === "1" ) {
	                            text += "Port Type: IB口\n";
	                        } else if ( params.parmDate.portType === "2" ) {
	                            text += "Port Type: 万兆口\n";
	                        } else if ( params.parmDate.portType === "3" ) {
	                            text += "Port Type: 千兆口\n";
	                        }
	                    }  
	                
	                    if ( params.parmDate.targetReource !== undefined && params.parmDate.targetReource !== null ) {
	                        if ( params.parmDate.sourceReourceName !== undefined && params.parmDate.sourceReourceName !== null ) {
	                            text += "Target Reource: " +  params.parmDate.sourceReourceName + "\n";
	                        } else {
	                            text += "Target Reource: " +  params.parmDate.targetReource + "\n";
	                        }   
	                    }  
	
	                    if ( params.parmDate.targetPort !== undefined && params.parmDate.targetPort !== null ) {
	                        text += "Target Port: " +  params.parmDate.targetPort + "\n";
	                    }  
	
	                    
	
	                    params.parmDate.tipContext = text;
	
	                    if ( api.getHeight() - params.y > params.height ) {
	                        params.layout = "down";
	                    } else {
	                        params.layout = "up";
	                    }
	
	
	                    api.showTipWindow(params);
	                } else if (eveName === "mouseout") {
	                    api.hideTipWindow(e.event.target);
	                }
	                //api.trigger(eveName, params); 
	            }, this);
	         }, this);
	    }
	    zrUtil.inherits(TopoDrawNode, NetworkNode);
	    module.exports = TopoDrawNode;
	


/***/ },
/* 88 */
/***/ function(module, exports, __webpack_require__) {

	
		var Node = __webpack_require__(78);
	    var NetworkNode = __webpack_require__(77);
		var Util = __webpack_require__(71);
		var graphic = __webpack_require__(3);
	    var Point = __webpack_require__(72);
	    var Connector = __webpack_require__(89);
	
		function NetWorkLineNode(model,api) {
			Node.call(this);
	        this.model = model;  // NetWorkLineModal
	        this.con = null;        
			this.render();
			this.refreshLine();
	        this.lineType = this.model.get("lineType");
	        this.parmData = this.model.get("parmData");
	        
		};
	
		NetWorkLineNode.prototype.render = function() {
	            var parmData = {};
	            if ( this.model.get("isVector") ) {
	                 parmData.symbol = {type:"arrow", size: 10, color:"#000000"};
	            } else {
	                 parmData.symbol = {type:""};
	            }
	            var _style = this.model.get("style");
	            if ( this.lineType ?  this.lineType : this.model.option.lineType) {
	                _style.lineType = this.lineType ?  this.lineType : this.model.option.lineType;
	            }
	            var _hoverStyle = this.model.get("hoverStyle");
	            parmData.style = _style;
	            parmData.hoverStyle = _hoverStyle;
	            
	            var _isEdit = this.model.get("isEdit");
	            parmData.isEdit = _isEdit;
	            this.con =  new Connector(parmData);  //"arrow"
	            this.add(this.con);
		};
	
	    NetWorkLineNode.prototype.refreshLine = function () {
	        var moddleY = this.model.get("moddleY");
	        var moddleX = this.model.get("moddleX");
	
	        var sRect = this.model.get("fromBounds");
	        var sBounds = [sRect.x, sRect.y, sRect.x + sRect.width, sRect.y + sRect.height];
	
	        var eRect = this.model.get("toBounds");
	        var eBounds = [eRect.x, eRect.y, eRect.x + eRect.width, eRect.y + eRect.height];
	
	        var sConnectorPoint = Util.getConnectorPoints(sRect);
	        var eConnectorPoint = Util.getConnectorPoints(eRect);
	
	        var startPoint = null;
	        var endPoint = null;
	        if (sRect.y < eRect.y) {
	            startPoint = sConnectorPoint.bottom;
	            endPoint = eConnectorPoint.top;
	        } else {
	            startPoint = sConnectorPoint.top;
	            endPoint = eConnectorPoint.bottom;
	        }
	
	        var solutions = this.connector2Points(startPoint, endPoint, moddleX, 
	                        moddleY, sBounds, eBounds);
	            //adjust connector
	        //  console.info("connector2Points() -> Solution: " + solutions[0][2]);
	        // var points = Util.traslatePoints(solutions[0][2]);
	
	        //this.line.attr('shape', {points: points});
	        this.con.refresh(solutions[0][2]);
	    };
	
	    NetWorkLineNode.prototype.connector2Points = function(startPoint, endPoint, moddleX, middleY, sBounds, eBounds ){
	        var solutions = [];
	        //Basic solution 最基本的解决方案   为其他解决方案做准备
	        var s = [startPoint];
	        if ( moddleX !== undefined && moddleX !== null ) {
	             s.push(new Point(startPoint.x - moddleX, startPoint.y));
	             s.push(new Point(startPoint.x - moddleX, middleY));
	             s.push(new Point(endPoint.x, middleY)); 
	        } else {
	            s.push(new Point(startPoint.x, middleY));
	            s.push(new Point(endPoint.x, middleY)); 
	        }
	        s.push(endPoint);        
	
	        //SO - no additional points     S0 解决方案 
	        var s0 = Point.cloneArray(s);
	        solutions.push(['s0', 's0', s0]);
	        return solutions;
	        
	    };
	
		Util.inherits(NetWorkLineNode, Node);
	
		module.exports = NetWorkLineNode;
	


/***/ },
/* 89 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * 连接线
	 * @author wang.xiaohu
	 */
	
	    var Util = __webpack_require__(71);
	    var zrUtil = __webpack_require__(4);
	    var graphic = __webpack_require__(3);
	    var Node = __webpack_require__(78);
	    var symbolUtil = __webpack_require__(90);
	    var Handle = __webpack_require__(91);
	    var EffectLine = __webpack_require__(92);
	    var ConnectionPoint = __webpack_require__(93);
	    var Point = __webpack_require__(72);
	    /**
	     * 构造函数
	     * @param {[type]} options [description]
	     */
	    function Connector(options) {
	        Node.call(this);
	        this.resourceId = Util.getUUID();  // 生成节点ID
	        var defaultOptions = {
	            symbol: {type:"arrow" , size: 10, color:"#000000"},  //箭头  可选值为： 'circle', 'rect', 'roundRect', 'triangle', 'diamond', 'pin', 'arrow'
	            style: {lineWidth:1, stroke:"#000000", lineType:Connector.TYPE_STRAIGHT},    //样式
	            hoverStyle: {lineWidth:2, stroke:"lime"}, //移上去的样式
	            arrowHoverStyle: {fill:"lime"},
	            shape: {points:null, smooth:false, smoothConstraint:null},//形状
	            position: [0,0],
	            isEdit: true,  //是否可编辑
	            text: {
	                text: "",
	                color: '#000000', // 文本颜色
	                textFont: '12px Microsoft YaHei'
	            },
	            z: 0
	        }
	        var opt = options || {};
	        this.options = zrUtil.merge(defaultOptions, opt, true);
	        this.model = options.model;
	        this.handles = [];
	        this.connectionPoints = [];
	        this.conPointsGroup = null;
	        this.startNode = null;
	        this.endNode = null;
	        this.line = null;
	        this.groupCurve = new graphic.Group();
	        this.icons = [];  // 用于存储线段上面的操作图标
	        this.render();
	    }
	
	    Connector.TYPE_STRAIGHT = 'straight';
	
	    Connector.TYPE_JAGGED = 'jagged';
	
	    Connector.TYPE_CURVE = 'curve';
	
	    Connector.RADIUS = 3;
	
	    Connector.START_NODE = "startNode";
	
	    Connector.END_NODE = "endNode";
	
	    Connector.LEFT = "left";
	
	    Connector.RIGHT = "right";
	
	    Connector.TOP = "top";
	
	    Connector.BOTTOM = "bottom";
	
	    Connector.BOTTOM = "bottom";
	
	    Connector.SEPERATOR = "-";
	    /**
	     * 重新画线，如果传空则根据turningPoints 重新画线
	     * @param  {[type]} points [description]
	     * @return {[type]}        [description]
	     */
	    Connector.prototype.refresh = function(points) {
	        if(points) {
	            this.turningPoints = points;
	        }
	        //将[x:0,y:0]转化为[0, 0]  给zrender使用
	        var points = Util.traslatePoints(this.turningPoints);
	
	        if((this.options.style.lineType == Connector.TYPE_CURVE) && (points.length > 2)) {
	            this.modifyCurve(this.turningPoints);
	        } else {
	            this.line.attr('shape', {points: points});
	        }
	
	        var lineText = this.childOfName('lineText');
	        //开始没有创建文本，后来传进来text了，需要先创建文本
	        if (!lineText  && this.options.text.text) {
	            var text = this.drawText("lineText", this.options.text.text,0, 0);
	            this.add(text.text);
	            lineText = this.childOfName('lineText');
	        }
	        if (lineText) {
	            lineText.setStyle("text", this.options.text.text);
	
	            var textPoint = this.getTextPostion(this.options.text);
	
	            // if (this.options.style.lineType == Connector.TYPE_STRAIGHT ) {
	            //     lineText.attr('rotation', this.getTextRotation(textPoint));
	            // }
	
	            lineText.attr("position", textPoint);
	        }
	        var symbolTo = this.childOfName('toSymbol');
	        if(symbolTo) {
	            if(this.options.effect&&this.options.effect.show){
	                new EffectLine(symbolTo,this.options,this.groupCurve,this.polyLine);
	            }else{
	                symbolTo.attr('position', points[points.length -1]);
	                symbolTo.attr('rotation', Util.tangentRotation(this.turningPoints[this.turningPoints.length-2], this.turningPoints[this.turningPoints.length-1]));
	            }
	        }
	   };
	    /**
	     * 渲染
	     * @return {[type]} [description]
	     */
	    Connector.prototype.render = function() {
	        var that = this;
	        //1.创建箭头
	        var symbolTo = this.createSymbol('toSymbol', this.options); //arrow,triangle
	        if (symbolTo) {
	            this.add(symbolTo);
	        }
	
	        //2.创建线
	        this.curveLine = new graphic.BezierCurve({
	            position: this.options.position,
	            style: this.options.style,
	            z: this.options.z
	        });
	        this.groupCurve.add(this.curveLine);
	        this.add(this.groupCurve);
	
	        this.polyLine = new graphic.Polyline({
	            position: this.options.position,
	            shape: this.options.shape,
	            style: this.options.style,
	            z: this.options.z
	        });
	        this.add(this.polyLine);
	
	        if((this.options.style.lineType == Connector.TYPE_CURVE)) {
	            this.line = this.groupCurve;
	            this.createHoverStyle(this.curveLine);
	            this.polyLine.hide();
	        }
	        else {
	            this.line = this.polyLine;
	            this.createHoverStyle(this.polyLine);
	            this.curveLine.hide();
	        }
	
	        //3.侦听线事件
	        var MOUSE_EVENT_NAMES = ['dblclick', 'click'];//'click', 'dblclick', 'mouseover', 'mouseout'
	        zrUtil.each(MOUSE_EVENT_NAMES, function (eveName) {
	            this.line.on(eveName, zrUtil.bind(function (e) {
	                e.cancelBubble = true;
	                var params = {};
	                params.event = e;
	                params.type = "Connector:" + eveName;
	                params.target = that;
	                this.trigger(params.type, params);
	                if(this.options.isEdit == false){return;}
	
	                if(this.options.isEdit && this.connectionPoints.length < 1 && this.turningPoints.length >=2) {
	                    this.createAllconnectionPoint()
	                }
	                if(this.handles.length < 1 ) {
	                    this.shapeSetHandle();
	                }
	            }, this));
	        }, this);
	
	        //3.创建调整线的连接点
	        if(this.options.isEdit) {
	            this.conPointsGroup = new graphic.Group();
	            this.add(this.conPointsGroup);
	        }
	
	        //4.创建线上文本
	        if (this.options.text.text && this.options.text.text != "") {
	            var text = this.drawText("lineText", this.options.text.text,0, 0);
	            this.add(text.text);
	        }
	
	
	    };
	
	    //设置style
	    Connector.prototype.setStyle = function(options) {
	        if(options.color){
	            if(this.options.style.lineType == Connector.TYPE_CURVE){
	                this.groupCurve.eachChild(function(curve) {
	                    curve.attr("style",{stroke:options.color});
	                    graphic.setNormalStyle(curve, {stroke:options.color});
	                });
	            }else{
	                this.polyLine.attr("style",{stroke:options.color});
	                graphic.setNormalStyle(this.polyLine, {stroke:options.color});
	            }
	            var symbolTo = this.childOfName('toSymbol');
	            if (symbolTo) {
	                symbolTo.attr("style",{fill:options.color});
	                graphic.setNormalStyle(symbolTo, {fill:options.color});
	            }
	            this.options.style.stroke = options.color;
	            this.model.set("options.style.stroke", options.color);
	            this.model.set("options.symbol.color", options.color);
	        }
	
	        if(options.text){
	             var lineText = this.childOfName('lineText');
	            //开始没有创建文本，后来传进来text了，需要先创建文本
	            if (!lineText  && options.text.text) {
	                var text = this.drawText("lineText", options.text.text,0, 0);
	                this.add(text.text);
	                lineText = this.childOfName('lineText');
	            }
	
	            if(options.text.text || options.text.text == ""){
	                lineText.setStyle("text", options.text.text);
	                this.options.text.text = options.text.text;
	            }
	            var textPoint = this.getTextPostion(options.text);
	            lineText.attr("position", textPoint);
	            if(options.text.textPos){
	                this.options.text.textPos = options.text.textPos;
	            }else{
	                this.options.text.textPos = 'center';
	            }
	            if(options.text.color){
	                lineText.attr("style",{
	                    fill: options.text.color
	                });
	                this.options.text.color = options.text.color;
	            }
	            this.model.set("options.text", options.text);
	        }
	
	    };
	
	    /**
	     * 获取线段的位置
	     * @param  {Object} text {text:'', color:'', textPos:''}
	     * @return {Object}      {x,y}
	     */
	    Connector.prototype.getTextPostion = function(text) {
	        var textPostion = [];
	        var textWidth = graphic.textContain.getWidth(text.text, text.textFont);
	        if(text&&text.textPos){
	            if(text.textPos == 'start'){
	                var xOffset = text.xOffset || 0;
	                textPostion = [this.turningPoints[0].x + xOffset,this.turningPoints[0].y];
	            }else if(text.textPos == 'end'){
	                if (this.options.style.lineType == Connector.TYPE_STRAIGHT ) {
	                    var points  = Util.getMaxLineLength(this.turningPoints);
	
	                    var angle = Util.getAngle(points[0],points[1]);
	                    var length =  Util.distance(points[0],points[1]) - textWidth;
	                    var newPoint = Util.getEndPoint(points[0], length, angle);
	                    textPostion = [newPoint.x,newPoint.y];
	                }else{
	                    textPostion = [this.turningPoints[this.turningPoints.length-1].x,this.turningPoints[this.turningPoints.length-1].y];
	                }
	            }else{
	                textPostion = this.middle(text);
	            }
	        }else{
	            var position = this.middle(text);
	            textPostion = [position[0]-textWidth/2,position[1]];
	        }
	
	        return textPostion;
	    };
	
	    /**
	     * 获取线段的旋转角度
	     * @param  {Object} textPostion {x,y}
	     * @return {Number}             角度值
	     */
	    Connector.prototype.getTextRotation = function(textPostion) {
	        //计算出极坐标的角度
	        var points  = Util.getMaxLineLength(this.turningPoints);
	        var angle = - Math.atan2(points[1].y - textPostion[1], points[1].x - textPostion[0]);  //,Math.PI/2
	        return angle;
	    };
	
	    Connector.prototype.createHoverStyle = function(el) {
	        if (this.options.hoverStyle) {
	            graphic.setElementHoverStl(el, this.options.hoverStyle);
	
	            var symbolTo = this.childOfName('toSymbol');
	            if(symbolTo){graphic.setElementHoverStl(symbolTo, this.options.arrowHoverStyle);}
	
	            el.on('mouseover', zrUtil.bind(function() {
	                graphic.doEnterHover(el);
	                if(symbolTo){graphic.doEnterHover(symbolTo);}
	
	                this.groupCurve.eachChild(function(line) {
	                    graphic.doEnterHover(line);
	                });
	            },this))
	              .on('mouseout', zrUtil.bind(function() {
	                graphic.doLeaveHover(el);
	                if(symbolTo){graphic.doLeaveHover(symbolTo);}
	                this.groupCurve.eachChild(function(line) {
	                    graphic.doLeaveHover(line);
	                });
	            },this));
	        }
	    };
	    /**
	     * 创建Node的连接点
	     * @private
	     *
	     * @return {[type]} [description]
	     */
	    Connector.prototype.createAllconnectionPoint = function() {
	        var sRect = this.startNode.getRect? this.startNode.getRect().boundingRect : Util.getRect(this.startNode).boundingRect;
	
	        var eRect = this.endNode.getRect? this.endNode.getRect().boundingRect : Util.getRect(this.endNode).boundingRect;
	
	        var sConnectorPoint = Util.getConnectorPoints(sRect);
	        var eConnectorPoint = Util.getConnectorPoints(eRect);
	
	        this.connectionPointCreate(this.startNode, sConnectorPoint.left, Connector.START_NODE + Connector.SEPERATOR + Connector.LEFT);
	        this.connectionPointCreate(this.startNode, sConnectorPoint.right, Connector.START_NODE + Connector.SEPERATOR + Connector.RIGHT);
	        this.connectionPointCreate(this.startNode, sConnectorPoint.top, Connector.START_NODE + Connector.SEPERATOR + Connector.TOP);
	        this.connectionPointCreate(this.startNode, sConnectorPoint.bottom, Connector.START_NODE + Connector.SEPERATOR + Connector.BOTTOM);
	
	        this.connectionPointCreate(this.endNode, eConnectorPoint.left, Connector.END_NODE + Connector.SEPERATOR + Connector.LEFT);
	        this.connectionPointCreate(this.endNode, eConnectorPoint.right, Connector.END_NODE + Connector.SEPERATOR + Connector.RIGHT);
	        this.connectionPointCreate(this.endNode, eConnectorPoint.top, Connector.END_NODE + Connector.SEPERATOR + Connector.TOP);
	        this.connectionPointCreate(this.endNode, eConnectorPoint.bottom, Connector.END_NODE + Connector.SEPERATOR + Connector.BOTTOM);
	
	
	        this.connectionPointCreate(this, this.turningPoints[0].clone(), ConnectionPoint.TYPE_CONNECTOR);
	
	        this.connectionPointCreate(this, this.turningPoints[this.turningPoints.length-1].clone(), ConnectionPoint.TYPE_CONNECTOR);
	    };
	
	    /**
	     * 创建连接点
	     * @private
	     * @param  {[type]} shape [description]
	     * @param  {[type]} point [description]
	     * @param  {[type]} type  [description]
	     * @return {[type]}       [description]
	     */
	    Connector.prototype.connectionPointCreate = function(shape, point, type) {
	        var conPoint = new ConnectionPoint(this, point, type, this.options);
	        this.conPointsGroup.add(conPoint.shape);
	    };
	
	    /**
	     * 清空控制点
	     * @return {[type]} [description]
	     */
	    Connector.prototype.clearHandles = function() {
	        for (var i = 0; i < this.handles.length; i++) {
	            this.remove(this.handles[i].handleShape);
	        }
	        this.handles = [];
	        if (this.conPointsGroup) {
	            this.conPointsGroup.removeAll();
	        }
	    };
	
	    /**
	     * 创建拆线 线断的控制点
	     * @return {[type]} [description]
	     */
	    Connector.prototype.shapeSetHandle = function() {
	        for(var i=1; i<this.turningPoints.length-2; i++){
	            var h;
	            var x, y;
	            //是否在一条线上
	            var isCollineaityFirst = Util.collinearity(this.turningPoints[i-1], this.turningPoints[i], this.turningPoints[i+1]);
	            var isCollineaitySecond = Util.collinearity(this.turningPoints[i], this.turningPoints[i+1], this.turningPoints[i+2]);
	            if( (!isCollineaityFirst && (!isCollineaitySecond || this.turningPoints[i+1].equals(this.turningPoints[i+2])))
	                || ( (!isCollineaityFirst || this.turningPoints[i-1].equals(this.turningPoints[i])) && !isCollineaitySecond )) {
	
	                if(this.turningPoints[i].x === this.turningPoints[i+1].x){ //same vertical
	                    x = this.turningPoints[i].x;
	                    y = (this.turningPoints[i].y + this.turningPoints[i+1].y) / 2;
	
	                    h = new Handle('h',x,y,this);
	
	
	                }
	                else if(this.turningPoints[i].y === this.turningPoints[i+1].y){ // same horizontal
	                    x = (this.turningPoints[i].x +  this.turningPoints[i+1].x) / 2;
	                    y = this.turningPoints[i].y;
	                    h =  new  Handle('v',x,y,this);
	                }
	                if (h) {
	                    this.add(h.handleShape);
	                    this.handles.push(h);
	                }
	
	            }
	        }
	    };
	
	
	    /**
	     * 创建箭头
	     * @param  {[type]} name       [description]
	     * @param  {[type]} options [description]
	     * @return {[type]}            [description]
	     */
	    Connector.prototype.createSymbol = function(name, options) {
	        var symbolType = options.symbol.type;
	        var symbolSize =this.options.symbol.size;
	        if (symbolType === 'none') {
	            return;
	        }
	
	        if (!zrUtil.isArray(symbolSize)) {
	            symbolSize = [symbolSize, symbolSize];
	        }
	        var symbolPath = symbolUtil.createSymbol(
	            symbolType, -symbolSize[0] / 2, -symbolSize[1] / 2,
	            symbolSize[0], symbolSize[1], this.options.symbol.color, this.options.z
	        );
	        symbolPath.name = name;
	
	        return symbolPath;
	    };
	
	    /**
	     * 绘制线段上的文本
	     * @param  {[type]} content [description]
	     * @param  {[type]} name [description]
	     * @param  {[type]} x       [description]
	     * @param  {[type]} y       [description]
	     * @param  {[type]} color   [description]
	     * @return {[type]}         [description]
	     */
	    Connector.prototype.drawText = function (name,content, x, y, color) {
	        var text = new graphic.Text({
	            style: {
	                text: content,
	                x: x,
	                y: y,
	                fill: color ? color : this.options.text.color,
	                textFont: this.options.text.textFont
	            },
	            zlevel: 20
	        });
	        text.name = name;
	        return {
	            text: text,
	            rect: text.getBoundingRect()
	        };
	    };
	
	    /**
	     * 获取线段的中间值
	     * @return {[type]} text
	     */
	    Connector.prototype.middle = function(text){
	
	        if(this.options.style.lineType == Connector.TYPE_STRAIGHT){
	            var points  = Util.getMaxLineLength(this.turningPoints);
	            //如果是求线段上的文字的中间值
	            // if(text) {
	            //     //取出字的长度，计算角度，
	            //     var textWidth = graphic.textContain.getWidth(text.text, text.textFont);
	            //     var angle = Util.getAngle(points[0],points[1]);
	            //     var length =  Util.distance(points[0],points[1])/2 - textWidth/2;
	            //     var newPoint = Util.getEndPoint(points[0], length, angle);
	            //     return [newPoint.x, newPoint.y];
	            // } else {
	            //     var middleX = (points[0].x + points[1].x)/2;
	            //     var middleY = (points[0].y + points[1].y) /2;
	            //     return [middleX, middleY];
	            // }
	            var middleX = (points[0].x + points[1].x)/2;
	            var middleY = (points[0].y + points[1].y) /2;
	            return [middleX, middleY];
	        }
	        else if(this.options.style.lineType == Connector.TYPE_JAGGED){
	
	            //find total distance
	            var distance = this.getLength();
	
	            //find between what turning points the half distance is
	            var index = -1;
	            var ellapsedDistance = 0;
	            for(var i=0; i<this.turningPoints.length-1; i++){
	                index = i;
	                var segment = Util.getLength(this.turningPoints[i], this.turningPoints[i+1]);
	                if(ellapsedDistance + segment < distance /2){
	                    ellapsedDistance += segment;
	                }
	                else{
	                    break;
	                }
	            }
	
	            //we have the middle distance somewhere between i(ndex) and i(ndex)+1
	            if(index != -1){
	                var missingDistance = distance / 2 - ellapsedDistance;
	                if( Util.round(this.turningPoints[index].x, 3) == Util.round(this.turningPoints[index + 1].x, 3) ){ //vertical segment (same x)
	                    return [this.turningPoints[index].x, Math.min(this.turningPoints[index].y, this.turningPoints[index + 1].y) + missingDistance];
	                } else if( Util.round(this.turningPoints[index].y, 3) == Util.round(this.turningPoints[index + 1].y, 3) ) { //horizontal segment (same y)
	                    return [Math.min(this.turningPoints[index].x, this.turningPoints[index + 1].x) + missingDistance, this.turningPoints[index].y];
	                } else{
	                    console.error("Connector:middle() - this should never happen " + this.turningPoints[index] + " " + this.turningPoints[index + 1]
	                        + " nr of points " + this.turningPoints.length
	                        );
	                }
	
	            }
	        }
	        else if(this.options.style.lineType == Connector.TYPE_CURVE){
	            var t = 0.5;
	            var l = this.getLength();
	
	            var walked = 0;
	            for(var j =0; j< this.turningPoints.length-1; j++){
	                if( walked + Util.distance(this.turningPoints[j], this.turningPoints[j+1]) > l * t ){
	                    break;
	                }
	
	                walked += Util.distance(this.turningPoints[j], this.turningPoints[j+1]);
	            }
	
	            var rest = l * t - walked;
	            var currentSegmentLength = Util.distance(this.turningPoints[j], this.turningPoints[j+1]);
	
	            //find the position/ration of the middle of Polyline on current segment
	            var segmentPercent = rest / currentSegmentLength;
	
	            var Xp = segmentPercent * (this.turningPoints[j+1].x - this.turningPoints[j].x) + this.turningPoints[j].x;
	            var Yp = segmentPercent * (this.turningPoints[j+1].y - this.turningPoints[j].y) + this.turningPoints[j].y;
	
	            return [Xp, Yp];
	
	        }
	
	        return null;
	    };
	
	    /**
	     * find total distance
	     * @return {Number} [description]
	     */
	    Connector.prototype.getLength = function() {
	            //find total distance
	        var distance = 0;
	        for(var i=0; i<this.turningPoints.length-1; i++){
	            distance += Util.getLength(this.turningPoints[i], this.turningPoints[i+1]);
	        }
	        return distance;
	    };
	
	    /**
	     * 转JSON对象
	     * @return {[type]} [description]
	     */
	    Connector.prototype.toJSON = function() {
	
	        this.model.set("resourceId", this.resourceId);
	        this.model.set("properties.type", 14);
	
	        this.model.set("bounds.upperLeft.x", this.position[0]);
	        this.model.set("bounds.upperLeft.y", this.position[1]);
	        this.model.set("bounds.lowerRight.x", this.position[0] + this.getBoundingRect().width);
	        this.model.set("bounds.lowerRight.y", this.position[1] + this.getBoundingRect().height);
	        this.model.set("style.sPos", this.sPos);
	        this.model.set("style.ePos", this.ePos);
	        this.model.set("dockers",this.turningPoints);
	        return this.model.option;
	    };
	
	     /**
	     * refreshModel
	     * @return {[type]} [description]
	     */
	    Connector.prototype.refreshModel = function() {
	        this.model.set("options.dockers",this.turningPoints);
	        var icons = [];
	        for(var i = 0;i < this.icons.length;i++){
	            var iconNode = this.icons[i];
	            var option = [iconNode.key,{
	                icon:iconNode.style.image,
	                width: iconNode.style.width,
	                height: iconNode.style.height
	            }];
	            icons.push(option);
	        }
	        this.model.set("icons",icons);
	    };
	
	    /**
	     * 调整曲线的形状
	     * @param  {array} points 点数组
	     * @return {void}
	     */
	    Connector.prototype.modifyCurve = function(points) {
	        var sol = this.getCurvePoint(points);
	
	        // 1. 如果曲线的数量 比数量的中数量要少 则删除多余的线段
	        var willDelCurves = [];
	        for (var j = sol.length, cntCurve = this.groupCurve.childCount(); j < cntCurve ; j++) {
	            willDelCurves.push(this.groupCurve.childAt(j));
	        }
	        zrUtil.each(willDelCurves, function(curve) {
	            this.groupCurve.remove(curve);
	        }, this);
	        // 2. 遍历曲线   如果存在则直接设置形状，否则创建
	        for (var i = 0; i < sol.length; i++) {
	            var line = this.groupCurve.childAt(i);
	            if (line) {
	                line.attr('shape', sol[i]);
	            } else {
	                var cure = new graphic.BezierCurve({
	                    position: this.options.position,
	                    style: this.options.style,
	                    shape: sol[i],
	                    z: this.options.z
	                });
	                this.groupCurve.add(cure);
	                this.createHoverStyle(cure);
	            }
	        }
	    };
	
	
	    /**
	     * 根据传入的点数组计算曲线的点
	     * @param  {array} P 点数组
	     * @return {object}        曲线的点数组
	     */
	    Connector.prototype.getCurvePoint = function(P) {
	        var n = P.length;
	        var sol = [];
	        if (n === 3) {
	            sol.push({x1: P[0].x,
	                   y1: P[0].y,
	                   cpx1: P[1].x,
	                   cpy1: P[1].y,
	                   x2: P[2].x,
	                   y2: P[2].y
	                });
	            return sol;
	        }
	        else if (n === 4) {
	            sol.push({x1: P[0].x,
	                   y1: P[0].y,
	                   cpx1: P[1].x,
	                   cpy1: P[1].y,
	                   cpx2: P[2].x,
	                   cpy2: P[2].y,
	                   x2: P[3].x,
	                   y2: P[3].y
	                });
	            return sol;
	        }
	
	        /**Computes factorial
	         * @param {Number} k the number
	         * */
	        function fact(k){
	            if(k===0 || k===1){
	                return 1;
	            }
	            else{
	                return k * fact(k-1);
	            }
	        }
	
	        /**Computes Bernstain*/
	        function B(i,n,u){
	            return fact(n) / (fact(i) * fact(n-i))* Math.pow(u, i) * Math.pow(1-u, n-i);
	        }
	
	        /**Computes the sum between two point
	         *@param p1 - {Point}
	         *@param p2 - {Point}
	         *@return {Point} the sum of initial points
	         **/
	        function sum(p1, p2){
	            return new Point(p1.x + p2.x, p1.y + p2.y);
	        }
	
	        /**Computes the difference between first {Point} and second {Point}
	         *@param p1 - {Point}
	         *@param p2 - {Point}
	         *@return {Point} the sum of initial points
	         **/
	        function minus(p1, p2){
	            return new Point(p1.x - p2.x, p1.y - p2.y);
	        }
	
	        /**Computes the division of a {Point} by a number
	         *@param p - {Point}
	         *@param nr - {Number}
	         *@return {Point}
	         **/
	        function divide(p, nr){
	            if(nr == 0){
	                throw "Division by zero not allowed (yet :) " + this.callee ;
	            }
	            return new Point(p.x/nr, p.y/nr);
	        }
	
	        /**Computes the multiplication of a {Point} by a number
	         *@param p - {Point}
	         *@param nr - {Number}
	         *@return {Point}
	         **/
	        function multiply(p, nr){
	            return new Point (p.x * nr, p.y * nr);
	        }
	
	
	
	
	        /*
	         *I do not get why first 4 must be 0 and last 3 of same value.....
	         *but otherwise we will get division by zero
	         */
	        var k = [0,0,0];
	
	        var j;
	        for(j=0;j<=n-3;j++){
	            k.push(j);
	        }
	
	        k.push(n-3, n-3);
	
	
	
	        for(i=1; i<=n-3; i++){
	            //q1 - compute start point
	            var q1 = divide( sum( multiply(P[i], k[i+4] - k[i+2]), multiply(P[i+1], k[i+2] - k[i+1]) ), k[i+4] - k[i+1]);
	
	            //q0 - compute 1st controll point
	            var q_01 = (k[i+3] - k[i+2]) / (k[i+3] - k[i+1]);
	            var q_02 = divide( sum( multiply(P[i-1],k[i+3] - k[i+2]), multiply(P[i], k[i+2] - k[i])), k[i+3] - k[i]);
	            var q_03 = multiply(q1, ( k[i+2] - k[i+1])/ (k[i+3] - k[i+1]) );
	            var q0 = sum(multiply(q_02, q_01), q_03);
	
	            //q2 - compute 2nd controll point
	            var q2 = divide( sum( multiply(P[i], k[i+4] - k[i+3]), multiply(P[i+1], k[i+3] - k[i+1]) ), k[i+4] - k[i+1] );
	
	            //q3 - compute end point
	            var q_31 = (k[i+3] - k[i+2]) / (k[i+4] - k[i+2]);
	            var q_32 = divide( sum( multiply(P[i+1], k[i+5] - k[i+3]), multiply(P[i+2], k[i+3] - k[i+2]) ) , k[i+5] - k[i+2]);
	            var q_33 = multiply(q2, (k[i+4] - k[i+3])/(k[i+4] - k[i+2]) );
	            var q3 = sum(multiply(q_32, q_31), q_33);
	
	            //store solution
	            //
	            sol.push({x1: q0.x,
	                   y1: q0.y,
	                   cpx1: q1.x,
	                   cpy1: q1.y,
	                   cpx2: q2.x,
	                   cpy2: q2.y,
	                   x2: q3.x,
	                   y2: q3.y
	                });
	        }
	
	        return sol;
	    };
	
	
	    Util.inherits(Connector,Node);
	
	    module.exports = Connector;
	
	


/***/ },
/* 90 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// Symbol factory
	
	
	    var graphic = __webpack_require__(3);
	    var BoundingRect = __webpack_require__(24);
	    /**
	     * Triangle shape
	     * @inner
	     */
	    var Triangle = graphic.extendShape({
	        type: 'triangle',
	        shape: {
	            cx: 0,
	            cy: 0,
	            width: 0,
	            height: 0
	        },
	        buildPath: function (path, shape) {
	            var cx = shape.cx;
	            var cy = shape.cy;
	            var width = shape.width / 2;
	            var height = shape.height / 2;
	            path.moveTo(cx, cy - height);
	            path.lineTo(cx + width, cy + height);
	            path.lineTo(cx - width, cy + height);
	            path.closePath();
	        }
	    });
	    /**
	     * Diamond shape
	     * @inner
	     */
	    var Diamond = graphic.extendShape({
	        type: 'diamond',
	        shape: {
	            cx: 0,
	            cy: 0,
	            width: 0,
	            height: 0
	        },
	        buildPath: function (path, shape) {
	            var cx = shape.cx;
	            var cy = shape.cy;
	            var width = shape.width / 2;
	            var height = shape.height / 2;
	            path.moveTo(cx, cy - height);
	            path.lineTo(cx + width, cy);
	            path.lineTo(cx, cy + height);
	            path.lineTo(cx - width, cy);
	            path.closePath();
	        }
	    });
	
	    /**
	     * Pin shape
	     * @inner
	     */
	    var Pin = graphic.extendShape({
	        type: 'pin',
	        shape: {
	            // x, y on the cusp
	            x: 0,
	            y: 0,
	            width: 0,
	            height: 0
	        },
	
	        buildPath: function (path, shape) {
	            var x = shape.x;
	            var y = shape.y;
	            var w = shape.width / 5 * 3;
	            // Height must be larger than width
	            var h = Math.max(w, shape.height);
	            var r = w / 2;
	
	            // Dist on y with tangent point and circle center
	            var dy = r * r / (h - r);
	            var cy = y - h + r + dy;
	            var angle = Math.asin(dy / r);
	            // Dist on x with tangent point and circle center
	            var dx = Math.cos(angle) * r;
	
	            var tanX = Math.sin(angle);
	            var tanY = Math.cos(angle);
	
	            path.arc(
	                x, cy, r,
	                Math.PI - angle,
	                Math.PI * 2 + angle
	            );
	
	            var cpLen = r * 0.6;
	            var cpLen2 = r * 0.7;
	            path.bezierCurveTo(
	                x + dx - tanX * cpLen, cy + dy + tanY * cpLen,
	                x, y - cpLen2,
	                x, y
	            );
	            path.bezierCurveTo(
	                x, y - cpLen2,
	                x - dx + tanX * cpLen, cy + dy + tanY * cpLen,
	                x - dx, cy + dy
	            );
	            path.closePath();
	        }
	    });
	
	    /**
	     * Arrow shape
	     * @inner
	     */
	    var Arrow = graphic.extendShape({
	
	        type: 'arrow',
	
	        shape: {
	            x: 0,
	            y: 0,
	            width: 0,
	            height: 0
	        },
	
	        buildPath: function (ctx, shape) {
	            var height = shape.height;
	            var width = shape.width;
	            var x = shape.x;
	            var y = shape.y;
	            var dx = width / 3 * 2;
	            ctx.moveTo(x, y);
	            ctx.lineTo(x + dx, y + height);
	            ctx.lineTo(x, y + height / 4 * 3);
	            ctx.lineTo(x - dx, y + height);
	            ctx.lineTo(x, y);
	            ctx.closePath();
	        }
	    });
	
	    /**
	     * Map of path contructors
	     * @type {Object.<string, module:zrender/graphic/Path>}
	     */
	    var symbolCtors = {
	        line: graphic.Line,
	
	        rect: graphic.Rect,
	
	        roundRect: graphic.Rect,
	
	        square: graphic.Rect,
	
	        circle: graphic.Circle,
	
	        diamond: Diamond,
	
	        pin: Pin,
	
	        arrow: Arrow,
	
	        triangle: Triangle
	    };
	
	    var symbolShapeMakers = {
	
	        line: function (x, y, w, h, shape) {
	            // FIXME
	            shape.x1 = x;
	            shape.y1 = y + h / 2;
	            shape.x2 = x + w;
	            shape.y2 = y + h / 2;
	        },
	
	        rect: function (x, y, w, h, shape) {
	            shape.x = x;
	            shape.y = y;
	            shape.width = w;
	            shape.height = h;
	        },
	
	        roundRect: function (x, y, w, h, shape) {
	            shape.x = x;
	            shape.y = y;
	            shape.width = w;
	            shape.height = h;
	            shape.r = Math.min(w, h) / 4;
	        },
	
	        square: function (x, y, w, h, shape) {
	            var size = Math.min(w, h);
	            shape.x = x;
	            shape.y = y;
	            shape.width = size;
	            shape.height = size;
	        },
	
	        circle: function (x, y, w, h, shape) {
	            // Put circle in the center of square
	            shape.cx = x + w / 2;
	            shape.cy = y + h / 2;
	            shape.r = Math.min(w, h) / 2;
	        },
	
	        diamond: function (x, y, w, h, shape) {
	            shape.cx = x + w / 2;
	            shape.cy = y + h / 2;
	            shape.width = w;
	            shape.height = h;
	        },
	
	        pin: function (x, y, w, h, shape) {
	            shape.x = x + w / 2;
	            shape.y = y + h / 2;
	            shape.width = w;
	            shape.height = h;
	        },
	
	        arrow: function (x, y, w, h, shape) {
	            shape.x = x + w / 2;
	            shape.y = y + h / 2;
	            shape.width = w;
	            shape.height = h;
	        },
	
	        triangle: function (x, y, w, h, shape) {
	            shape.cx = x + w / 2;
	            shape.cy = y + h / 2;
	            shape.width = w;
	            shape.height = h;
	        }
	    };
	
	    var symbolBuildProxies = {};
	    for (var name in symbolCtors) {
	        symbolBuildProxies[name] = new symbolCtors[name]();
	    }
	
	    var Symbol = graphic.extendShape({
	
	        type: 'symbol',
	
	        shape: {
	            symbolType: '',
	            x: 0,
	            y: 0,
	            width: 0,
	            height: 0
	        },
	
	        beforeBrush: function () {
	            var style = this.style;
	            var shape = this.shape;
	            // FIXME
	            if (shape.symbolType === 'pin' && style.textPosition === 'inside') {
	                style.textPosition = ['50%', '40%'];
	                style.textAlign = 'center';
	                style.textVerticalAlign = 'middle';
	            }
	        },
	
	        buildPath: function (ctx, shape) {
	            var symbolType = shape.symbolType;
	            var proxySymbol = symbolBuildProxies[symbolType];
	            if (shape.symbolType !== 'none') {
	                if (!proxySymbol) {
	                    // Default rect
	                    symbolType = 'rect';
	                    proxySymbol = symbolBuildProxies[symbolType];
	                }
	                symbolShapeMakers[symbolType](
	                    shape.x, shape.y, shape.width, shape.height, proxySymbol.shape
	                );
	                proxySymbol.buildPath(ctx, proxySymbol.shape);
	            }
	        }
	    });
	
	    // Provide setColor helper method to avoid determine if set the fill or stroke outside
	    var symbolPathSetColor = function (color) {
	        if (this.type !== 'image') {
	            var symbolStyle = this.style;
	            var symbolShape = this.shape;
	            if (symbolShape && symbolShape.symbolType === 'line') {
	                symbolStyle.stroke = color;
	            }
	            else if (this.__isEmptyBrush) {
	                symbolStyle.stroke = color;
	                symbolStyle.fill = '#fff';
	            }
	            else {
	                // FIXME 判断图形默认是填充还是描边，使用 onlyStroke ?
	                symbolStyle.fill && (symbolStyle.fill = color);
	                symbolStyle.stroke && (symbolStyle.stroke = color);
	            }
	            this.dirty();
	        }
	    };
	
	    var symbolUtil = {
	        /**
	         * Create a symbol element with given symbol configuration: shape, x, y, width, height, color
	         * @param {string} symbolType
	         * @param {number} x
	         * @param {number} y
	         * @param {number} w
	         * @param {number} h
	         * @param {number} z
	         * @param {string} color
	         */
	        createSymbol: function (symbolType, x, y, w, h, color, z) {
	            var isEmpty = symbolType.indexOf('empty') === 0;
	            if (isEmpty) {
	                symbolType = symbolType.substr(5, 1).toLowerCase() + symbolType.substr(6);
	            }
	            var symbolPath;
	
	            if (symbolType.indexOf('image://') === 0) {
	                symbolPath = new graphic.Image({
	                    style: {
	                        image: symbolType.slice(8),
	                        x: x,
	                        y: y,
	                        width: w,
	                        height: h
	                    },
	                    z: z
	                });
	            }
	            else if (symbolType.indexOf('path://') === 0) {
	                symbolPath = graphic.makePath(symbolType.slice(7), {z: z}, new BoundingRect(x, y, w, h));
	            }
	            else {
	                symbolPath = new Symbol({
	                    shape: {
	                        symbolType: symbolType,
	                        x: x,
	                        y: y,
	                        width: w,
	                        height: h
	                    },
	                    z: z
	                });
	            }
	
	            symbolPath.__isEmptyBrush = isEmpty;
	
	            symbolPath.setColor = symbolPathSetColor;
	
	            symbolPath.setColor(color);
	
	            return symbolPath;
	        }
	    };
	
	    module.exports = symbolUtil;
	


/***/ },
/* 91 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * 画句柄
	 * @author wang.xiaohu
	 */
	
	    var graphic = __webpack_require__(3);
	    var Util = __webpack_require__(71);
	    function Handle(type, x, y, connector){
	        this.type = type;
	
	        this.x = x;
	
	        this.y = y;
	
	        this.visible = true;
	
	        this.connector = connector;
	
	        this.handleShape = new graphic.Circle({
	            shape: {
	                cx: x,
	                cy: y,
	                r: Handle.RADIUS
	            },
	
	            style: {
	                fill: "rgb(0,255,0)",
	                stroke:"rgb(0,0,0)"
	            },
	            z : connector.options.z + 2,  //节点Z为1 线段为0;
	            draggable:true
	        });
	
	        var that = this;
	        this.handleShape.on("drag", function(e) {
	            that.actionConnector(e.offsetX,e.offsetY);
	        });
	       // return this.circle;
	    }
	
	    Handle.RADIUS = 4;
	
	    Handle.prototype = {
	
	        constructor : Handle,
	
	        equals : function(anotherHandle){
	            if(!anotherHandle instanceof Handle){
	                return false;
	            }
	
	            return this.type == anotherHandle.type
	            && this.x == anotherHandle.x
	            && this.y == anotherHandle.y
	            && this.visible == anotherHandle.visible;
	        },
	
	        /**
	         * 移动句柄
	         * @param  {[type]} newX [description]
	         * @param  {[type]} newY [description]
	         * @return {[type]}      [description]
	         */
	        actionConnector: function(newX, newY){
	            switch(this.type){
	                case 'v':
	                    var index;
	                    // 找出两个转折点（可移动句柄在这两个转折点中间）
	                    for(var i = 1; i < this.connector.turningPoints.length-1; i++){
	                        if(this.connector.turningPoints[i-1].y == this.connector.turningPoints[i].y
	                            && this.connector.turningPoints[i].y == this.y
	                            && Math.min(this.connector.turningPoints[i].x, this.connector.turningPoints[i-1].x) <= this.x
	                            && Math.max(this.connector.turningPoints[i].x, this.connector.turningPoints[i-1].x) >= this.x)
	                        {
	                            index = i;
	                        }
	                    }
	                    var deltaY = newY - this.y;
	                    var translationMatrix = Util.translationMatrix(0, deltaY);
	
	                    this.connector.turningPoints[index-1].transform(translationMatrix);
	                    this.connector.turningPoints[index].transform(translationMatrix);
	                    this.connector.refresh();
	                    this.y = newY;  //将句柄新的位置赋值给y
	
	                    break;
	
	                case 'h':
	                    var index;
	                    // 找出两个转折点（可移动句柄在这两个转折点中间）
	                    for(var i = 1; i < this.connector.turningPoints.length-1; i++){
	                        if(this.connector.turningPoints[i-1].x == this.connector.turningPoints[i].x
	                            && this.connector.turningPoints[i].x == this.x
	                            && Math.min(this.connector.turningPoints[i].y, this.connector.turningPoints[i-1].y) <= this.y
	                            && Math.max(this.connector.turningPoints[i].y, this.connector.turningPoints[i-1].y) >= this.y)
	                            {
	                            index = i;
	                        }
	                    }
	                    var deltaX = newX-this.x;
	                    var translationMatrix = Util.translationMatrix(deltaX, 0);
	                    this.connector.turningPoints[index-1].transform(translationMatrix);
	                    this.connector.turningPoints[index].transform(translationMatrix);
	                    this.connector.refresh();
	                    this.x = newX; //将句柄新的位置赋值给x
	
	                    break;
	            }
	           //. this.shape.updateMiddleText();
	        }
	    };
	    module.exports = Handle;
	
	
	


/***/ },
/* 92 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * 连线动态效果
	 * @author miao.cunzhi
	 */
	
	    var zrUtil = __webpack_require__(4);
	    var vec2 = __webpack_require__(14);
	    var curveUtil = __webpack_require__(26);
	    var symbolUtil = __webpack_require__(90);
	
	    function EffectLine(symbol, options, groupCurve, polyLine) {
	        this._lastFrame = 0;
	        this._lastFramePercent = 0;
	        this.symbol = symbol;
	        this.groupCurve = groupCurve;
	        this.initSymbol(options, polyLine);
	    }
	    var EffectLineProto = EffectLine.prototype;
	
	    EffectLineProto.initSymbol = function(options, polyLine) {
	        var that = this;
	        this.symbol.z2 = 100;
	        this.symbol.culling = true;
	        var period = options.effect.period * 1000;
	        this.symbol.__t = 0;
	        this.symbol.stopAnimation();
	        if ((options.style.lineType == "curve")) {
	            if (this.groupCurve) {
	                var i = 0;
	                period = period / this.groupCurve._children.length;
	                this.groupCurveAnimate(this.groupCurve._children[0], i, period);
	            }
	
	        } else {
	            this.symbol.animate('', true)
	                .when(period, {
	                    __t: 1
	                })
	                .delay(0)
	                .during(function() {
	                    that.updateSymbolPositionPolyline();
	                })
	                .start();
	            this.setAnimationPointsPolyline(polyLine.shape.points);
	        }
	
	    };
	
	    EffectLineProto.groupCurveAnimate = function(curveLine, i, period) {
	        var that = this;
	        if (curveLine == undefined) {
	            curveLine = this.groupCurve._children[0];
	            i = 0;
	        }
	        var points;
	        var pos = curveLine.shape;
	        points = [
	            [pos.x1, pos.y1],
	            [pos.x2, pos.y2],
	            [pos.cpx1, pos.cpy1],
	            [pos.cpx2, pos.cpy2]
	        ];
	        this.setAnimationPointsBezierCurve(points);
	        this.symbol.animate('')
	            .when(period, {
	                __t: 1
	            })
	            .delay(0)
	            .during(function() {
	                that.updateSymbolPositionBezierCurve();
	            })
	            .done(function() {
	                that.symbol.__t = 0;
	                that.groupCurveAnimate(that.groupCurve._children[i + 1], i + 1, period);
	            })
	            .start();
	
	    };
	
	
	    EffectLineProto.setAnimationPointsBezierCurve = function(points) {
	        this.symbol.__p1 = points[0];
	        this.symbol.__p2 = points[1];
	        this.symbol.__cp1 = points[2] || [
	            (points[0][0] + points[1][0]) / 2,
	            (points[0][1] + points[1][1]) / 2
	        ];
	        this.symbol.__cp2 = points[3];
	    };
	
	    EffectLineProto.updateSymbolPositionBezierCurve = function() {
	        var p1 = this.symbol.__p1;
	        var p2 = this.symbol.__p2;
	        var cp1 = this.symbol.__cp1;
	        var cp2 = this.symbol.__cp2;
	        var t = this.symbol.__t;
	        var pos = this.symbol.position;
	        var tx, ty;
	        if (cp2[0] != undefined) {
	            var cubicAt = curveUtil.cubicAt;
	            var cubicDerivativeAt = curveUtil.cubicDerivativeAt;
	            pos[0] = cubicAt(p1[0], cp1[0], cp2[0], p2[0], t);
	            pos[1] = cubicAt(p1[1], cp1[1], cp2[1], p2[1], t);
	            // Tangent
	            tx = cubicDerivativeAt(p1[0], cp1[0], cp2[0], p2[0], t);
	            ty = cubicDerivativeAt(p1[1], cp1[1], cp2[1], p2[1], t);
	        } else {
	            var quadraticAt = curveUtil.quadraticAt;
	            var quadraticDerivativeAt = curveUtil.quadraticDerivativeAt;
	            pos[0] = quadraticAt(p1[0], cp1[0], p2[0], t);
	            pos[1] = quadraticAt(p1[1], cp1[1], p2[1], t);
	            // Tangent
	            tx = quadraticDerivativeAt(p1[0], cp1[0], p2[0], t);
	            ty = quadraticDerivativeAt(p1[1], cp1[1], p2[1], t);
	        }
	        this.symbol.rotation = -Math.atan2(ty, tx) - Math.PI / 2;
	
	        this.symbol.ignore = false;
	    };
	
	    EffectLineProto.setAnimationPointsPolyline = function(points) {
	        this._points = points;
	        var accLenArr = [0];
	        var len = 0;
	        for (var i = 1; i < points.length; i++) {
	            var p1 = points[i - 1];
	            var p2 = points[i];
	            len += vec2.dist(p1, p2);
	            accLenArr.push(len);
	        }
	        if (len === 0) {
	            return;
	        }
	
	        for (var j = 0; j < accLenArr.length; j++) {
	            accLenArr[j] /= len;
	        }
	        this._offsets = accLenArr;
	        this._length = len;
	        this.symbol._lastFrame = 0;
	        this.symbol.__lastFramePercent = 0;
	    };
	
	    EffectLineProto.updateSymbolPositionPolyline = function() {
	        var t = this.symbol.__t;
	        var points = this._points;
	        var offsets = this._offsets;
	        var len = points.length;
	
	        if (!offsets) {
	            // Has length 0
	            return;
	        }
	
	        var lastFrame = this._lastFrame;
	        var frame;
	
	        if (t < this._lastFramePercent) {
	            // Start from the next frame
	            // PENDING start from lastFrame ?
	            var start = Math.min(lastFrame + 1, len - 1);
	            for (frame = start; frame >= 0; frame--) {
	                if (offsets[frame] <= t) {
	                    break;
	                }
	            }
	            // PENDING really need to do this ?
	            frame = Math.min(frame, len - 2);
	        } else {
	            for (var frame = lastFrame; frame < len; frame++) {
	                if (offsets[frame] > t) {
	                    break;
	                }
	            }
	            frame = Math.min(frame - 1, len - 2);
	        }
	        vec2.lerp(
	            this.symbol.position, points[frame], points[frame + 1],
	            (t - offsets[frame]) / (offsets[frame + 1] - offsets[frame])
	        );
	
	        this._lastFrame = frame;
	        this._lastFramePercent = t;
	        var angle = -Math.atan2(points[frame + 1][1] - points[frame][1], points[frame + 1][0] - points[frame][0]);
	        this.symbol.rotation = angle - Math.PI / 2;
	        this.symbol.ignore = false;
	    };
	    module.exports = EffectLine;
	


/***/ },
/* 93 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * 控制点
	 * @author wang.xiaohu
	 */
	
	    var graphic = __webpack_require__(3);
	    var Util = __webpack_require__(71);
	    function ConnectionPoint(connector, point, type, options){
	        this.connector = connector;
	
	        this.point = point.clone();
	
	        this.type = type;
	
	        this.color = ConnectionPoint.NORMAL_COLOR;
	
	        this.oType = 'ConnectionPoint';
	
	        this.shape = new graphic.Circle({
	            shape: {
	                cx: this.point.x,
	                cy: this.point.y,
	                r: ConnectionPoint.RADIUS
	            },
	
	            style: {
	                fill: this.color,
	                stroke:'#000000'
	            },
	            z : options.z + 2  //节点Z为1 线段为0;
	        });
	        this.shape.type =  this.type;
	
	        this.shape.connector = connector;
	        //return this.circle;
	    }
	
	    ConnectionPoint.NORMAL_COLOR = "#FFFF33"; //yellow.
	
	    ConnectionPoint.OVER_COLOR = "#FF9900"; //orange
	
	    ConnectionPoint.CONNECTED_COLOR = "#ff0000"; //red
	
	    ConnectionPoint.RADIUS = 4;
	
	    ConnectionPoint.TYPE_FIGURE = 'figure';
	
	    ConnectionPoint.TYPE_CONNECTOR = 'connector';
	
	    ConnectionPoint.prototype = {
	
	        constructor : ConnectionPoint,
	
	        equals : function(anotherConnectionPoint){
	            return this.point.equals(anotherConnectionPoint.point)
	            && this.connector == anotherConnectionPoint.connector
	            && this.type == anotherConnectionPoint.type
	            && this.color == anotherConnectionPoint.color
	            && this.radius == anotherConnectionPoint.radius;
	        }
	
	
	    };
	    module.exports = ConnectionPoint;
	
	
	


/***/ },
/* 94 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Network model
	 *
	 */
	
	
	    var Model = __webpack_require__(75);
	    var zrUtil = __webpack_require__(4);
	
	    var NetWorkLineModel = Model.extend({
	        /**
	         * @type {Object}
	         * @protected
	         */
	        defaultOption: {
	            fromBounds: {x:0, y:0, width:0, height:0},  // [左上角X, 左上角Y, 宽度 , 高度]
	            toBounds: {x:0, y:0, width:0, height:0},  // [左上角X, 左上角Y, 宽度 , 高度]
	            moddleX: 0,  // 中间线的Y坐标
	            moddleY: 0,  // 中间线的Y坐标
	            style: {
	                lineWidth:1,  // 线宽度
	                stroke: "#FFFFFF",  //线颜色
	            },
	            hoverStyle: {
	                lineWidth:1,  // 线宽度
	                stroke: "#FFFFFF",  //线颜色
	            },
	            isVector: false
	        },
	
	        init: function (option, parentModel, extraOpt) {
	            zrUtil.merge(option, this.getDefaultOption());
	        },
	
	        getDefaultOption: function () {
	            if (!this.hasOwnProperty('__defaultOption')) {
	                var optList = [];
	                var Class = this.constructor;
	                while (Class) {
	                    var opt = Class.prototype.defaultOption;
	                    opt && optList.push(opt);
	                    Class = Class.superClass;
	                }
	
	                var defaultOption = {};
	                for (var i = optList.length - 1; i >= 0; i--) {
	                    defaultOption = zrUtil.merge(defaultOption, optList[i], true);
	                }
	                this.__defaultOption = defaultOption;
	            }
	            return this.__defaultOption;
	        }
	
	    });
	    module.exports = NetWorkLineModel;
	


/***/ },
/* 95 */
/***/ function(module, exports, __webpack_require__) {

	
	    var util = __webpack_require__(71);
	    var NetworkNode = __webpack_require__(77);
	    var zrUtil = __webpack_require__(4);
	    var graphic = __webpack_require__(3);
	    var NetworkModel = __webpack_require__(74);
	    
	    function ServerTopoNode(model,api) {
	        NetworkNode.call(this, model, api);
	        this.rackkInfo = {type: -1, name: "ServerTopoNode" };    
	        this.model = model;
	        this.portNodeList = [];
	        this.parmDate = this.model.get("parmDate");
	        this.render(model,api);
	    };
	
	    ServerTopoNode.prototype.render = function(model, api) {
	        this.model = model;
	        var _showTip = model.get("showTip");
	        var _width = model.get("width");
	        var _height = 20;
	
	        var _title = new graphic.Text({
	            style: {
	                x: model.get("width") / 2 - 10,
	                y: -20,
	                text: model.get("name"),
	                width: 200,
	                height: _height,
	                fill: '#8F8B8A',
	                textFont: '12px Microsoft Yahei',
	                textBaseline: 'top'
	            },
	            draggable: true
	        });
	        this.add(_title);
	
	        var status = model.get("status");
	        var imageUrl = '../../../../fish-topo-network/src/images/' + model.get("type");
	        // if ( status !== "" && status !== null && status !== undefined) {
	        //      imageUrl += status;
	        // }
	        imageUrl += '.png';
	        var cellStateNode = new graphic.Circle({
	             shape: {
	                cx: 10,
	                cy: 10,
	                r: 5
	            },
	            style: {
	                fill: '#077826',
	                opacity: 1,
	                stroke: '#B3B3B3',
	                lineWidth: '2'//,*/
	            } ,
	            z: 1000
	        });
	        if ( status !== "" && status !== null && status === "offline") {
	            cellStateNode.style.fill = "#999999";
	        }
	        this.add(cellStateNode);
	        
	        var serverNodeB = new graphic.Image({
	            position: [0, 0],
	            scale: [1, 1],
	            style: {
	                x: 0,
	                y: 0,
	                image: imageUrl,
	                width: _width,
	                height:  _height
	            },
	            //z: 1000,
	            draggable: false,
	            parmDate: this.model.get("parmDate")
	        }); 
	
	        this.add(serverNodeB);
	
	        var portsList = model.get("ports");
	        if ( portsList !== undefined ) {
	            var _kmx = 10;
	            for ( var i = 0; i < portsList.length; i++ ) {
	                var portModel = {};
	                portModel = {
	                    resourceId: util.getUUID(),  
	                    bounds: {
	                        upperLeft: {x: _kmx, y: _height / 2.5}  
	                    },
	                    stencil: {type: "PointNode"}
	                };
	                portModel.height = 7;
	                portModel.width = 7;
	
	                var _linInfo = {};
	                _linInfo.sourceReource = this.model.get("name");
	                _linInfo.sourcePort = i;
	                _linInfo.sourceCardNo = 0;
	                _linInfo.portType = (portsList[i].type !== undefined && portsList[i].type !== null) ? portsList[i].type : "1"; 
	                _linInfo.portState = (portsList[i].status !== undefined && portsList[i].status !== null) ? portsList[i].status : "DOWN";   
	                _linInfo.nodetype = this.model.get("nodetype");
	                if (portsList[i].ip !== null && portsList[i].ip !== undefined ) {
	                     _linInfo.ip = portsList[i].ip;
	                }
	                if ( portsList[i].target !== null && portsList[i].target !== undefined ) {
	                    if ( portsList[i].type === "1" ) {
	                        _linInfo.targetReource = portsList[i].target.resourceName !== undefined ? portsList[i].target.resourceName : "";
	                        _linInfo.targetPort = portsList[i].target.port !== undefined ? portsList[i].target.port : "";
	                    } else {
	                        _linInfo.targetReource = portsList[i].target !== undefined ? portsList[i].target : "";
	                        _linInfo.targetPort = portsList[i].target.port !== undefined ? portsList[i].target.port : "-1";
	                    }
	                }   
	                portModel.lineInfo = _linInfo;         
	                var pModel = new NetworkModel(portModel);
	                this.addPortByModel(pModel, api);
	                _kmx = _kmx + 5;      
	            }
	        }
	       
	        var ports = model.get('ports');
	        if ( ports !== undefined && ports.card1 !== undefined && ports.card1.length < 3) {
	
	        }
	        this.position = [model.get("bounds.upperLeft.x") , model.get("bounds.upperLeft.y")];
	    };
	
	    ServerTopoNode.prototype.addPortByModel = function( p_model, api) {
	        var Shape = api.getNodeClass(p_model.get("stencil.type"));
	        var node = null;
	        if ( Shape ) {
	            node = new Shape(p_model, this._api);
	            this.portNodeList.push(node);
	            this.add(node);
	        }
	    };
	
	    zrUtil.inherits(ServerTopoNode, NetworkNode);
	    module.exports = ServerTopoNode;
	


/***/ },
/* 96 */
/***/ function(module, exports, __webpack_require__) {

	
	    var util = __webpack_require__(71);
	    var NetworkNode = __webpack_require__(77);
	    var zrUtil = __webpack_require__(4);
	    var graphic = __webpack_require__(3);
	    var NetworkModel = __webpack_require__(74);
	    var ServerTopoNode = __webpack_require__(95);
	    
	    function ServerR630Node(model,api) {
	        NetworkNode.call(this, model, api);
	        this.rackkInfo = {type: -1, name: "ServerR630Node" };    
	        this.model = model;
	        this.portNodeList = [];
	        this.cardNodeList = [];
	        this.parmDate = this.model.get("parmDate");
	        this.render(model,api);
	    };
	
	    ServerR630Node.prototype.render = function(model, api) {
	        this.model = model;
	        var _showTip = model.get("showTip");
	        var _width = model.get("width");
	        var _height = 20;
	
	        var _title = new graphic.Text({
	            style: {
	                x: model.get("width") / 2 - 10,
	                y: -20,
	                text: model.get("name"),
	                width: 200,
	                height: _height,
	                fill: '#8F8B8A',
	                textFont: '12px Microsoft Yahei',
	                textBaseline: 'top'
	            },
	            draggable: true
	        });
	        this.add(_title);
	
	        var status = model.get("status");
	        var imageUrl = '../../../../fish-topo-network/src/images/' + model.get("type");
	        // if ( status !== "" && status !== null && status !== undefined) {
	        //      imageUrl += status;
	        // }
	        imageUrl += '.png';
	
	        var cellStateNode = new graphic.Circle({
	             shape: {
	                cx: 10,
	                cy: 10,
	                r: 5
	            },
	            style: {
	                fill: '#077826',
	                opacity: 1,
	                stroke: '#B3B3B3',
	                lineWidth: '2'//,*/
	            } ,
	            z: 1000
	        });
	        if ( status !== "" && status !== null && status === "offline") {
	            cellStateNode.style.fill = "#999999";
	        }
	        this.add(cellStateNode);
	  
	        var serverNodeB = new graphic.Image({
	            position: [0, 0],
	            scale: [1, 1],
	            style: {
	                x: 0,
	                y: 0,
	                image: imageUrl,
	                width: _width,
	                height:  _height
	            },
	            //z: 1000,
	            draggable: false,
	            parmDate: this.model.get("parmDate")
	        }); 
	
	        this.add(serverNodeB);
	
	        var portsList = model.get("ports");
	        if ( portsList !== undefined ) {
	            var _kmx = 10;
	            for ( var i = 0; i < portsList.length; i++ ) {
	                var portModel = {};
	                portModel = {
	                    resourceId: util.getUUID(),  
	                    bounds: {
	                        upperLeft: {x: _kmx, y: _height / 2.5}  
	                    },
	                    stencil: {type: "PointNode"}
	                };
	                portModel.height = 7;
	                portModel.width = 7;
	
	                var _linInfo = {};
	                _linInfo.sourceReource = this.model.get("name");
	                _linInfo.sourcePort = i;
	                _linInfo.sourceCardNo = 0;
	                _linInfo.portType = (portsList[i].type !== undefined && portsList[i].type !== null) ? portsList[i].type : "1"; 
	                _linInfo.portState = (portsList[i].status !== undefined && portsList[i].status !== null) ? portsList[i].status : "DOWN";   
	                _linInfo.nodetype = this.model.get("nodetype");
	                if (portsList[i].ip !== null && portsList[i].ip !== undefined ) {
	                     _linInfo.ip = portsList[i].ip;
	                }
	                if ( portsList[i].target !== null && portsList[i].target !== undefined ) {
	                    if ( portsList[i].type === "1" ) {
	                        _linInfo.targetReource = portsList[i].target.resourceName !== undefined ? portsList[i].target.resourceName : "";
	                        _linInfo.targetPort = portsList[i].target.port !== undefined ? portsList[i].target.port : "";
	                    } else {
	                        _linInfo.targetReource = portsList[i].target !== undefined ? portsList[i].target : "";
	                        _linInfo.targetPort = portsList[i].target.port !== undefined ? portsList[i].target.port : "-1";
	                    }
	                }   
	                portModel.lineInfo = _linInfo;         
	                var pModel = new NetworkModel(portModel);
	                this.addPortByModel(pModel, api);
	                _kmx = _kmx + 5;      
	            }
	        }
	       
	        var ports = model.get('ports');
	        if ( ports !== undefined && ports.card1 !== undefined && ports.card1.length < 3) {
	
	        }
	        this.position = [model.get("bounds.upperLeft.x") , model.get("bounds.upperLeft.y")];
	    };
	
	    ServerR630Node.prototype.addPortByModel = function( p_model, api) {
	        var Shape = api.getNodeClass(p_model.get("stencil.type"));
	        var node = null;
	        if ( Shape ) {
	            node = new Shape(p_model, this._api);
	            this.portNodeList.push(node);
	            this.add(node);
	        }
	    };
	
	    zrUtil.inherits(ServerR630Node, NetworkNode);
	    module.exports = ServerR630Node;
	


/***/ },
/* 97 */
/***/ function(module, exports, __webpack_require__) {

	
	    var util = __webpack_require__(71);
	    var NetworkNode = __webpack_require__(77);
	    var zrUtil = __webpack_require__(4);
	    var graphic = __webpack_require__(3);
	    var NetworkModel = __webpack_require__(74);
	    var CardModel = __webpack_require__(98);
	    var ServerTopoNode = __webpack_require__(95);
	    
	    function ServerR730Node(model,api) {
	        NetworkNode.call(this, model, api);
	        this.rackkInfo = {type: -1, name: "ServerR730Node" };    
	        this.model = model;
	        this.portNodeList = [];
	        this.cardNodeList = [];
	        this.parmDate = this.model.get("parmDate");
	        this.render(model,api);
	    };
	
	    ServerR730Node.prototype.render = function(model, api) {
	        this.model = model;
	        var _showTip = model.get("showTip");
	        var _height = 20;
	        var me = this;
	        var _title = new graphic.Text({
	            style: {
	                x: model.get("width") / 2 - 10,
	                y: -20,
	                text: model.get("name"),
	                width: 200,
	                height: 20,
	                fill: '#8F8B8A',
	                textFont: '12px Microsoft Yahei',
	                textBaseline: 'top'
	            },
	            draggable: true
	        });
	        this.add(_title);
	
	        var status = model.get("status");
	        var imageUrl = '../../../../fish-topo-network/src/images/' + model.get("type");
	        // if ( status !== "" && status !== null && status !== undefined) {
	        //      imageUrl += status;
	        // }
	        imageUrl += '.png';
	        
	        var cellStateNode = new graphic.Circle({
	             shape: {
	                cx: 10,
	                cy: 20,
	                r: 5
	            },
	            style: {
	                fill: '#077826',
	                opacity: 1,
	                stroke: '#B3B3B3',
	                lineWidth: '2'//,*/
	            } ,
	            z: 1000
	        });
	        if ( status !== "" && status !== null && status === "offline") {
	            cellStateNode.style.fill = "#999999";
	        }
	        this.add(cellStateNode);
	
	        var serverNodeB = new graphic.Image({
	            position: [0, 0],
	            scale: [1, 1],
	            style: {
	                x: 0,
	                y: 0,
	                image: imageUrl,
	                width: model.get("width"),
	                height:  40,
	            },
	            //z: 1000,
	            draggable: false,
	            parmDate: this.model.get("parmDate")
	        }); 
	        this.add(serverNodeB);
	        
	        var portsList = model.get("ports");
	        if ( portsList !== undefined ) {
	            var _kmx = 10;
	            for ( var i = 0; i < portsList.length; i++ ) {
	                var portModel = {};
	                portModel = {
	                    resourceId: util.getUUID(),  
	                    bounds: {
	                        upperLeft: {x: _kmx, y: _height / 2.5}  
	                    },
	                    stencil: {type: "PointNode"}
	                };
	                portModel.height = 7;
	                portModel.width = 7;
	
	                var _linInfo = {};
	                _linInfo.sourceReource = this.model.get("name");
	                _linInfo.sourcePort = i;
	                _linInfo.sourceCardNo = 0;
	                _linInfo.nodetype = this.model.get("nodetype");
	                _linInfo.portType = (portsList[i].type !== undefined && portsList[i].type !== null) ? portsList[i].type : "1"; 
	                _linInfo.portState = (portsList[i].status !== undefined && portsList[i].status !== null) ? portsList[i].status : "DOWN";   
	                 if (portsList[i].ip !== null && portsList[i].ip !== undefined ) {
	                     _linInfo.ip = portsList[i].ip;
	                }
	                if ( portsList[i].target !== null && portsList[i].target !== undefined ) {
	                  
	                     if ( portsList[i].type === "1" ) {
	                        _linInfo.targetReource = portsList[i].target.resourceName !== undefined ? portsList[i].target.resourceName : "";
	                        _linInfo.targetPort = portsList[i].target.port !== undefined ? portsList[i].target.port : "";
	                    } else {
	                        _linInfo.targetReource = portsList[i].target !== undefined ? portsList[i].target : "";
	                        _linInfo.targetPort = portsList[i].target.port !== undefined ? portsList[i].target.port : "-1";
	
	                    }
	                }  
	
	                portModel.lineInfo = _linInfo;         
	                var pModel = new NetworkModel(portModel);
	                this.addPortByModel(pModel, api);
	                _kmx = _kmx + 5;      
	            }
	        }       
	        
	        this.position = [model.get("bounds.upperLeft.x") , model.get("bounds.upperLeft.y")];
	    };
	
	    ServerR730Node.prototype.addPortByModel = function( p_model, api) {
	        var Shape = api.getNodeClass(p_model.get("stencil.type"));
	        var node = null;
	        if ( Shape ) {
	            node = new Shape(p_model, this._api);
	            this.portNodeList.push(node);
	            this.add(node);
	        }
	    };
	
	    ServerR730Node.prototype.addNodeByModel = function( p_model, api) {
	        var Shape = api.getNodeClass(p_model.get("stencil.type"));
	        var node = null;
	        if ( Shape ) {
	            node = new Shape(p_model, api);
	            var pointList = node.pointList;
	            if ( pointList !== undefined && pointList.length > 0 ) {
	                for( var i = 0; i < pointList.length; i++ ) {
	                    if ( pointList[i].lineInfo.sourceCardNo === "1" ) {
	                        pointList[i].lineInfo.moddleX = 35;
	                    } else if( pointList[i].lineInfo.sourceCardNo === "2" ) {
	                        pointList[i].lineInfo.moddleX = 25;
	                    } else if( pointList[i].lineInfo.sourceCardNo === "3" ) {
	
	                    } else if( pointList[i].lineInfo.sourceCardNo === "4" ) {
	                        pointList[i].lineInfo.moddleX = 25;
	                    }else if( pointList[i].lineInfo.sourceCardNo === "5" ) {
	
	                    }
	                  this.portNodeList.push(pointList[i]);   
	                }
	            }
	            this.add(node);
	            this.cardNodeList.push(node);
	        }
	    };
	
	    zrUtil.inherits(ServerR730Node, NetworkNode);
	    module.exports = ServerR730Node;
	


/***/ },
/* 98 */
/***/ function(module, exports, __webpack_require__) {

	
	
	    var Model = __webpack_require__(75);
	    var zrUtil = __webpack_require__(4);
	    var NetworkModel = __webpack_require__(74);
	
	    var CardModel = NetworkModel.extend({
	        No: "",
	        resourcesName: "",
	        resourceNodeType : "1",
	        height: 5,
	        width: 5,
	        type: "",
	        direction: "leftRight",//updown
	        portData: []
	    });
	    module.exports = CardModel;
	


/***/ },
/* 99 */
/***/ function(module, exports, __webpack_require__) {

	
	    var util = __webpack_require__(71);
	    var NetworkNode = __webpack_require__(77);
	    var zrUtil = __webpack_require__(4);
	    var graphic = __webpack_require__(3);
	    var NetworkModel = __webpack_require__(74);
	    var ServerTopoNode = __webpack_require__(95);
	    
	    function ServerX3550Node(model,api) {
	        ServerTopoNode.call(this, model, api);
	        this.rackkInfo = {type: -1, name: "ServerX3550Node" };    
	        this.model = model;
	        this.render(model,api);
	    };
	
	    ServerX3550Node.prototype.render = function(model, api) {
	        this.model = model;
	        var _showTip = model.get("showTip");
	
	        var _title = new graphic.Text({
	            style: {
	                x: model.get("width") / 2 - 10,
	                y: -20,
	                text: model.get("name"),
	                width: 200,
	                height: 20,
	                fill: '#8F8B8A',
	                textFont: '12px Microsoft Yahei',
	                textBaseline: 'top'
	            },
	            draggable: true
	        });
	        this.add(_title);
	
	        var serverNodeB = new graphic.Image({
	            position: [0, 0],
	            scale: [1, 1],
	            style: {
	                x: 0,
	                y: 0,
	                image: '../../../../fish-topo-network/src/images/xIBMX3550b.png',
	                width: model.get("width"),
	                height:  40
	            },
	            draggable: false,
	            parmDate: this.model.get("parmDate")
	        }); 
	
	        var serverNodeA = new graphic.Image({
	            position: [0, 0],
	            scale: [1, 1],
	            style: {
	                x: 0,
	                y: 0,
	                image: '../../../../fish-topo-network/src/images/xIBMX3550a.png',
	                width: model.get("width"),
	                height:  40
	            },
	            draggable: false,
	            parmDate: this.model.get("parmDate")
	        }); 
	
	
	        serverNodeB.on("mouseover", function(params){
	            serverNodeB.attr("position" , [-1000, -1000]);
	            serverNodeA.attr("position", [0,0]);
	        });
	        serverNodeA.on("mouseout", function(params){
	            serverNodeA.attr("position" , [-1000, -1000]);
	            serverNodeB.attr("position", [0,0]);
	        });
	
	        this.add(serverNodeA);
	        this.add(serverNodeB);
	        
	        //画默认的以太网端口
	        var _kmx = 95;
	        for (var i = 0; i < 4; i++ ) {
	            var portModel = {};
	            portModel = {
	                resourceId: util.getUUID(),  
	                bounds: {
	                    upperLeft: {x: _kmx, y: 15}  
	                },
	                stencil: {type: "PointNode"}
	            };
	            portModel.height = 8;
	            portModel.width = 8;
	            var pModel = new NetworkModel(portModel);
	            this.addPortByModel(pModel, api);
	            _kmx = _kmx + 13;
	        }
	
	
	        this.position = [model.get("bounds.upperLeft.x") , model.get("bounds.upperLeft.y")];
	    };
	
	    ServerX3550Node.prototype.addPortByModel = function( p_model, api) {
	        var Shape = api.getNodeClass(p_model.get("stencil.type"));
	        var node = null;
	        if ( Shape ) {
	            node = new Shape(p_model, this._api);
	            this.add(node);
	        }
	    };
	
	    zrUtil.inherits(ServerX3550Node, NetworkNode);
	    module.exports = ServerX3550Node;
	


/***/ },
/* 100 */
/***/ function(module, exports, __webpack_require__) {

	
	    var util = __webpack_require__(71);
	    var NetworkNode = __webpack_require__(77);
	    var zrUtil = __webpack_require__(4);
	    var graphic = __webpack_require__(3);
	    var NetworkModel = __webpack_require__(74);
	    var ServerTopoNode = __webpack_require__(95);
	    
	    function ServerX3650Node(model,api) {
	        ServerTopoNode.call(this, model, api);
	        this.rackkInfo = {type: -1, name: "ServerX3650Node" };    
	        this.model = model;
	        this.render(model,api);
	    };
	
	    ServerX3650Node.prototype.render = function(model, api) {
	        this.model = model;
	        var _showTip = model.get("showTip");
	
	        var _title = new graphic.Text({
	            style: {
	                x: model.get("width") / 2 - 10,
	                y: -20,
	                text: model.get("name"),
	                width: 200,
	                height: 20,
	                fill: '#8F8B8A',
	                textFont: '12px Microsoft Yahei',
	                textBaseline: 'top'
	            },
	            draggable: true
	        });
	        this.add(_title);
	
	        var serverNodeB = new graphic.Image({
	            position: [0, 0],
	            scale: [1, 1],
	            style: {
	                x: 0,
	                y: 0,
	                image: '../../../..fish-topo-network/src/images/' + model.get("type") + '.png',
	                width: model.get("width"),
	                height:  80
	            },
	            draggable: false,
	            parmDate: this.model.get("parmDate")
	        }); 
	
	        var serverNodeA = new graphic.Image({
	            position: [0, 0],
	            scale: [1, 1],
	            style: {
	                x: 0,
	                y: 0,
	                image: '../../../../fish-topo-network/src/images/IBMX3650a.png',
	                width: model.get("width"),
	                height:  80
	            },
	            draggable: false,
	            parmDate: this.model.get("parmDate")
	        }); 
	
	
	        serverNodeB.on("mouseover", function(params){
	            serverNodeB.attr("position" , [-1000, -1000]);
	            serverNodeA.attr("position", [0,0]);
	          //  serverNodeA.show();
	        });
	        serverNodeA.on("mouseout", function(params){
	            serverNodeA.attr("position" , [-1000, -1000]);
	            serverNodeB.attr("position", [0,0]);
	        });
	
	        this.add(serverNodeA);
	        this.add(serverNodeB);
	        
	        //画默认的以太网端口
	        var _kmx = 165;
	        for (var i = 0; i < 4; i++ ) {
	            var portModel = {};
	            portModel = {
	                resourceId: util.getUUID(),  
	                bounds: {
	                    upperLeft: {x: _kmx, y: 55}  
	                },
	                stencil: {type: "PointNode"}
	            };
	            portModel.height = 10;
	            portModel.width = 10;
	            var pModel = new NetworkModel(portModel);
	            this.addPortByModel(pModel, api);
	            _kmx = _kmx + 13;
	        }
	
	        this.position = [model.get("bounds.upperLeft.x") , model.get("bounds.upperLeft.y")];
	    };
	
	    ServerX3650Node.prototype.addPortByModel = function( p_model, api) {
	        var Shape = api.getNodeClass(p_model.get("stencil.type"));
	        var node = null;
	        if ( Shape ) {
	            node = new Shape(p_model, this._api);
	            this.add(node);
	        }
	    };
	
	    zrUtil.inherits(ServerX3650Node, NetworkNode);
	    module.exports = ServerX3650Node;
	


/***/ },
/* 101 */
/***/ function(module, exports, __webpack_require__) {

	
	    var util = __webpack_require__(71);
	    var NetworkNode = __webpack_require__(77);
	    var zrUtil = __webpack_require__(4);
	    var graphic = __webpack_require__(3);
	    var NetworkModel = __webpack_require__(74);
	    var ServerTopoNode = __webpack_require__(95);
	    
	    function ServerRD350Node(model,api) {
	        ServerTopoNode.call(this, model, api);
	        this.rackkInfo = {type: -1, name: "ServerRD350Node" };    
	        this.model = model;
	        this.render(model,api);
	    };
	
	    ServerRD350Node.prototype.render = function(model, api) {
	        this.model = model;
	        var _showTip = model.get("showTip");
	
	        var _title = new graphic.Text({
	            style: {
	                x: model.get("width") / 2 - 10,
	                y: -20,
	                text: model.get("name"),
	                width: 200,
	                height: 20,
	                fill: '#8F8B8A',
	                textFont: '12px Microsoft Yahei',
	                textBaseline: 'top'
	            },
	            draggable: true
	        });
	        this.add(_title);
	
	        var serverNodeB = new graphic.Image({
	            position: [0, 0],
	            scale: [1, 1],
	            style: {
	                x: 0,
	                y: 0,
	                image: '../../../../fish-topo-network/src/images/lenovoRd350b.png',
	                width: model.get("width"),
	                height:  40
	            },
	            draggable: false
	        }); 
	
	        var serverNodeA = new graphic.Image({
	            position: [0, 0],
	            scale: [1, 1],
	            style: {
	                x: 0,
	                y: 0,
	                image: '../../../../fish-topo-network/src/images/lenovoRd350a.png',
	                width: model.get("width"),
	                height:  40
	            },
	            z: 1000,
	            draggable: false,
	            parmDate: this.model.get("parmDate")
	        }); 
	
	
	        serverNodeB.on("mouseover", function(params){
	            serverNodeB.attr("position" , [-1000, -1000]);
	            serverNodeA.attr("position", [0,0]);
	        });
	        serverNodeA.on("mouseout", function(params){
	            serverNodeA.attr("position" , [-1000, -1000]);
	            serverNodeB.attr("position", [0,0]);
	        });
	
	        this.add(serverNodeA);
	        this.add(serverNodeB);
	        
	        //画默认的以太网端口
	        var _kmx = 95;
	        for (var i = 0; i < 4; i++ ) {
	            var portModel = {};
	            portModel = {
	                resourceId: util.getUUID(),  
	                bounds: {
	                    upperLeft: {x: _kmx, y: 15}  
	                },
	                stencil: {type: "PointNode"}
	            };
	            portModel.height = 8;
	            portModel.width = 8;
	            var pModel = new NetworkModel(portModel);
	            this.addPortByModel(pModel, api);
	            _kmx = _kmx + 13;
	        }
	
	
	        this.position = [model.get("bounds.upperLeft.x") , model.get("bounds.upperLeft.y")];
	    };
	
	    ServerRD350Node.prototype.addPortByModel = function( p_model, api) {
	        var Shape = api.getNodeClass(p_model.get("stencil.type"));
	        var node = null;
	        if ( Shape ) {
	            node = new Shape(p_model, this._api);
	            this.add(node);
	        }
	    };
	
	    zrUtil.inherits(ServerRD350Node, NetworkNode);
	    module.exports = ServerRD350Node;
	


/***/ },
/* 102 */
/***/ function(module, exports, __webpack_require__) {

	
	    var util = __webpack_require__(71);
	    var NetworkNode = __webpack_require__(77);
	    var zrUtil = __webpack_require__(4);
	    var graphic = __webpack_require__(3);
	    var NetworkModel = __webpack_require__(74);
	    var ServerTopoNode = __webpack_require__(95);
	    
	    function ServerRD650Node(model,api) {
	        ServerTopoNode.call(this, model, api);
	        this.rackkInfo = {type: -1, name: "ServerRD650Node" };    
	        this.model = model;
	        this.render(model,api);
	    };
	
	    ServerRD650Node.prototype.render = function(model, api) {
	        this.model = model;
	        var _showTip = model.get("showTip");
	
	        var _title = new graphic.Text({
	            style: {
	                x: model.get("width") / 2 - 10,
	                y: -20,
	                text: model.get("name"),
	                width: 200,
	                height: 20,
	                fill: '#8F8B8A',
	                textFont: '12px Microsoft Yahei',
	                textBaseline: 'top'
	            },
	            draggable: true
	        });
	        this.add(_title);
	
	        var serverNodeB = new graphic.Image({
	            position: [0, 0],
	            scale: [1, 1],
	            style: {
	                x: 0,
	                y: 0,
	                image: '../../../../fish-topo-network/src/images/lenovoRd650b.png',
	                width: model.get("width"),
	                height:  80
	            },
	            draggable: false,
	            parmDate: this.model.get("parmDate")
	        }); 
	
	        var serverNodeA = new graphic.Image({
	            position: [0, 0],
	            scale: [1, 1],
	            style: {
	                x: 0,
	                y: 0,
	                image: '../../../../fish-topo-network/src/images/lenovoRd650a.png',
	                width: model.get("width"),
	                height:  80
	            },
	            z: 1000,
	            draggable: false
	        }); 
	
	
	        serverNodeB.on("mouseover", function(params){
	            serverNodeB.attr("position" , [-1000, -1000]);
	            serverNodeA.attr("position", [0,0]);
	          //  serverNodeA.show();
	        });
	        serverNodeA.on("mouseout", function(params){
	            serverNodeA.attr("position" , [-1000, -1000]);
	            serverNodeB.attr("position", [0,0]);
	        });
	
	        this.add(serverNodeA);
	        this.add(serverNodeB);
	        
	        //画默认的以太网端口
	        var portModel = {};
	        portModel = {
	            resourceId: util.getUUID(),  
	            bounds: {
	                upperLeft: {x: 88, y: 55}  
	            },
	            stencil: {type: "PointNode"}
	        };
	        portModel.height = 10;
	        portModel.width = 10;
	        var pModel = new NetworkModel(portModel);
	        this.addPortByModel(pModel, api);
	
	        this.position = [model.get("bounds.upperLeft.x") , model.get("bounds.upperLeft.y")];
	    };
	
	    ServerRD650Node.prototype.addPortByModel = function( p_model, api) {
	        var Shape = api.getNodeClass(p_model.get("stencil.type"));
	        var node = null;
	        if ( Shape ) {
	            node = new Shape(p_model, this._api);
	            this.add(node);
	        }
	    };
	
	    zrUtil.inherits(ServerRD650Node, NetworkNode);
	    module.exports = ServerRD650Node;
	


/***/ },
/* 103 */
/***/ function(module, exports, __webpack_require__) {

	
	    var util = __webpack_require__(71);
	    var NetworkNode = __webpack_require__(77);
	    var zrUtil = __webpack_require__(4);
	    var graphic = __webpack_require__(3);
	    
	    function SwitchTopoNode(model,api) {
	        NetworkNode.call(this, model, api);
	        this.rackkInfo = {type: -1, name: "SwitchTopoNode" };    
	        this.model = model;
	        this.render(model,api);
	    };
	
	    SwitchTopoNode.prototype.render = function(model, api) {
	        
	    };
	
	    zrUtil.inherits(SwitchTopoNode, NetworkNode);
	    module.exports = SwitchTopoNode;
	


/***/ },
/* 104 */
/***/ function(module, exports, __webpack_require__) {

	
	    var util = __webpack_require__(71);
	    var NetworkNode = __webpack_require__(77);
	    var zrUtil = __webpack_require__(4);
	    var graphic = __webpack_require__(3);
	    var NetworkModel = __webpack_require__(74);
	    var SwitchTopoNode = __webpack_require__(103);
	    
	    function SwitchHalfIBNode(model,api) {
	        SwitchTopoNode.call(this, model, api);
	        this.rackkInfo = {type: -1, name: "SwitchHalfIBNode" };    
	        this.model = model;
	        this.parmDate = this.model.get("parmDate");
	        this.portNodeList = [];
	        this.render(model,api);
	    };
	
	    SwitchHalfIBNode.prototype.render = function(model, api) {
	        this.model = model;
	        var _showTip = model.get("showTip");
	        var _portNum = model.get("portNum");
	        var imageUrl = "../../../../fish-topo-network/src/images/IBSwitchHalf" + _portNum + ".png";
	        var _title = new graphic.Text({
	            style: {
	                x: 10,
	                y: -20,
	                text: model.get("name"),
	                width: 130,
	                height: 20,
	                fill: '#8F8B8A',
	                textFont: '12px Microsoft Yahei',
	                textBaseline: 'top'
	            },
	            draggable: true
	        });
	        this.add(_title);
	
	        var switchNode = new graphic.Image({
	            position: [0, 0],
	            scale: [1, 1],
	            style: {
	                x: 0,
	                y: 0,
	                image: imageUrl,
	                width: model.get("width"),
	                height:  40
	            },
	            draggable: false,
	            parmDate: this.model.get("parmDate")
	        }); 
	        this.add(switchNode);
	
	        if ( _portNum === "12") {
	            var _y = 12;
	            var _x = 42;
	            for (var i = 1; i < 7; i++ ) {
	                var portModel = {};
	                portModel = {
	                    resourceId: util.getUUID(),  
	                    bounds: {
	                        upperLeft: {x: _x, y: _y}  
	                    },
	                    stencil: {type: "PointNode"}
	                };
	                portModel.height = 6;
	                portModel.width = 11;
	                var _linInfo = {};
	                _linInfo.sourceReource = this.model.get("name").substring(this.model.get("name").indexOf("No") + 3 , this.model.get("name").length);
	                _linInfo.sourcePort = i.toString();
	                _linInfo.sourceReourceName =  this.model.get("name").substring(6, this.model.get("name").indexOf("No") - 2);
	                portModel.lineInfo = _linInfo;
	                var pModel = new NetworkModel(portModel);
	                this.addPortByModel(pModel, api);
	                _x = _x + portModel.width + 3;
	            }
	            
	            _y = 22;
	            _x = 42;
	            for (var i = 7; i < 13; i++ ) {
	                var portModel = {};
	                portModel = {
	                    resourceId: util.getUUID(),  
	                    bounds: {
	                        upperLeft: {x: _x, y: _y}  
	                    },
	                    stencil: {type: "PointNode"}
	                };
	                portModel.height = 6;
	                portModel.width = 11;
	                var _linInfo = {};
	                _linInfo.sourceReource = this.model.get("name").substring(this.model.get("name").indexOf("No") + 3 , this.model.get("name").length);
	                _linInfo.sourcePort = i.toString();
	                _linInfo.sourceReourceName =  this.model.get("name").substring(6, this.model.get("name").indexOf("No") - 2);
	                portModel.lineInfo = _linInfo;
	                var pModel = new NetworkModel(portModel);
	                this.addPortByModel(pModel, api);
	                _x = _x + portModel.width + 3;     
	            }
	        } else if ( _portNum === "8" ) {
	            var _y = 12;
	            var _x = 70;
	            for (var i = 1; i < 5; i++ ) {
	                var portModel = {};
	                portModel = {
	                    resourceId: util.getUUID(),  
	                    bounds: {
	                        upperLeft: {x: _x, y: _y}  
	                    },
	                    stencil: {type: "PointNode"}
	                };
	                portModel.height = 6;
	                portModel.width = 11;
	                var _linInfo = {};
	                _linInfo.sourceReource = this.model.get("name").substring(this.model.get("name").indexOf("No") + 3 , this.model.get("name").length);
	                _linInfo.sourcePort = i.toString();
	                _linInfo.sourceReourceName =  this.model.get("name").substring(6, this.model.get("name").indexOf("No") - 2);
	                portModel.lineInfo = _linInfo;
	                var pModel = new NetworkModel(portModel);
	                this.addPortByModel(pModel, api);
	                _x = _x + portModel.width + 3;
	            }
	            
	            _y = 22;
	            _x = 70;
	            for (var i = 5; i < 9; i++ ) {
	                var portModel = {};
	                portModel = {
	                    resourceId: util.getUUID(),  
	                    bounds: {
	                        upperLeft: {x: _x, y: _y}  
	                    },
	                    stencil: {type: "PointNode"}
	                };
	                portModel.height = 6;
	                portModel.width = 11;
	                var _linInfo = {};
	                _linInfo.sourceReource = this.model.get("name").substring(this.model.get("name").indexOf("No") + 3 , this.model.get("name").length);
	                _linInfo.sourcePort = i.toString();
	                _linInfo.sourceReourceName =  this.model.get("name").substring(6, this.model.get("name").indexOf("No") - 2);
	                portModel.lineInfo = _linInfo;
	                var pModel = new NetworkModel(portModel);
	                this.addPortByModel(pModel, api);
	                _x = _x + portModel.width + 3;     
	            }
	
	        }
	        
	
	
	        this.position = [model.get("bounds.upperLeft.x") , model.get("bounds.upperLeft.y")];
	    };
	
	    SwitchHalfIBNode.prototype.addPortByModel = function( p_model, api) {
	        var Shape = api.getNodeClass(p_model.get("stencil.type"));
	        var node = null;
	        if ( Shape ) {
	            node = new Shape(p_model, this._api);
	            this.add(node);
	            this.portNodeList.push(node);
	        }
	    };
	
	    zrUtil.inherits(SwitchHalfIBNode, NetworkNode);
	    module.exports = SwitchHalfIBNode;
	


/***/ },
/* 105 */
/***/ function(module, exports, __webpack_require__) {

	
	    var util = __webpack_require__(71);
	    var NetworkNode = __webpack_require__(77);
	    var zrUtil = __webpack_require__(4);
	    var graphic = __webpack_require__(3);
	    var NetworkModel = __webpack_require__(74);
	    var SwitchTopoNode = __webpack_require__(103);
	    
	    function SwitchFullIBNode(model,api) {
	        SwitchTopoNode.call(this, model, api);
	        this.rackkInfo = {type: -1, name: "SwitchFullIBNode" };    
	        this.model = model;
	        this.parmDate = this.model.get("parmDate");
	        this.portNodeList = [];
	        this.render(model,api);
	    };
	
	    SwitchFullIBNode.prototype.render = function(model, api) {
	        this.model = model;
	        var _showTip = model.get("showTip");
	        var _portNum = model.get("portNum");
	        var imageUrl = "../../../../fish-topo-network/src/images/IBSwitchFull" + _portNum + ".png";
	        var _title = new graphic.Text({
	            style: {
	                x: 20,
	                y: -20,
	                text: model.get("name"),
	                width: 200,
	                height: 20,
	                fill: '#8F8B8A',
	                textFont: '12px Microsoft Yahei',
	                textBaseline: 'top'
	            },
	            draggable: true
	        });
	        this.add(_title);
	
	        var switchNode = new graphic.Image({
	            position: [0, 0],
	            scale: [1, 1],
	            style: {
	                x: 0,
	                y: 0,
	                image: imageUrl,
	                width: model.get("width"),
	                height: 40
	            },
	            draggable: false,
	            parmDate: this.model.get("parmDate")
	        }); 
	        this.add(switchNode);
	
	        var _y = 14;
	        var _x = 18;
	        for (var i = 1; i < 19; i++ ) {
	            var portModel = {};
	            portModel = {
	                resourceId: util.getUUID(),  
	                bounds: {
	                    upperLeft: {x: _x, y: _y}  
	                },
	                stencil: {type: "PointNode"}
	            };
	            portModel.height = 6;
	            portModel.width = 11;
	            var _linInfo = {};
	            _linInfo.sourceReource = this.model.get("name").substring(this.model.get("name").indexOf("No") + 3 , this.model.get("name").length);
	            _linInfo.sourcePort = i.toString();
	            _linInfo.sourceReourceName =  this.model.get("name").substring(6, this.model.get("name").indexOf("No") - 2 );
	            portModel.lineInfo = _linInfo;
	            var pModel = new NetworkModel(portModel);
	            this.addPortByModel(pModel, api);
	            if (i % 3 === 0 ) {
	                _x = _x + portModel.width + 5;
	            } else {
	                _x = _x + portModel.width + 2;
	            }       
	        }
	        
	        if ( _portNum > 18 ) {
	            _y = 24;
	            _x = 18;
	            for (var i = 19; i < 37; i++ ) {
	                var portModel = {};
	                portModel = {
	                    resourceId: util.getUUID(),  
	                    bounds: {
	                        upperLeft: {x: _x, y: _y}  
	                    },
	                    stencil: {type: "PointNode"}
	                };
	                portModel.height = 6;
	                portModel.width = 11;
	                var _linInfo = {};
	                _linInfo.sourceReource = this.model.get("name").substring(this.model.get("name").indexOf("No") + 3 , this.model.get("name").length);
	                _linInfo.sourcePort = i.toString();
	                _linInfo.sourceReourceName =  this.model.get("name").substring(6, this.model.get("name").indexOf("No") - 2 );
	                portModel.lineInfo = _linInfo;
	                var pModel = new NetworkModel(portModel);
	                this.addPortByModel(pModel, api);
	                if (i % 3 === 0 ) {
	                    _x = _x + portModel.width + 5;
	                } else {
	                    _x = _x + portModel.width + 2;
	                }       
	            }
	        }
	        
	        this.position = [model.get("bounds.upperLeft.x") , model.get("bounds.upperLeft.y")];
	    };
	
	     SwitchFullIBNode.prototype.addPortByModel = function( p_model, api) {
	        var Shape = api.getNodeClass(p_model.get("stencil.type"));
	        var node = null;
	        if ( Shape ) {
	            node = new Shape(p_model, this._api);
	            this.portNodeList.push(node);
	            this.add(node);
	        }
	    };
	
	    zrUtil.inherits(SwitchFullIBNode, NetworkNode);
	    module.exports = SwitchFullIBNode;
	


/***/ },
/* 106 */
/***/ function(module, exports, __webpack_require__) {

	
	    var util = __webpack_require__(71);
	    var NetworkNode = __webpack_require__(77);
	    var zrUtil = __webpack_require__(4);
	    var graphic = __webpack_require__(3);
	    var NetworkModel = __webpack_require__(74);
	    var SwitchTopoNode = __webpack_require__(103);
	    
	    function SwitchGMNode(model,api) {
	        SwitchTopoNode.call(this, model, api);
	        this.rackkInfo = {type: -1, name: "SwitchGMNode" };    
	        this.model = model;
	        this.render(model,api);
	    };
	
	    SwitchGMNode.prototype.render = function(model, api) {
	        this.model = model;
	        var _showTip = model.get("showTip");
	
	        var _title = new graphic.Text({
	            style: {
	                x: model.get("width") / 2 - 10,
	                y: -20,
	                text: model.get("name"),
	                width: 200,
	                height: 20,
	                fill: '#8F8B8A',
	                textFont: '12px Microsoft Yahei',
	                textBaseline: 'top'
	            },
	            draggable: true
	        });
	        this.add(_title);
	
	        var switchNode = new graphic.Image({
	            position: [0, 0],
	            scale: [1, 1],
	            style: {
	                x: 0,
	                y: 0,
	                image: '../../../../fish-topo-network/src/images/GMSwitch.png',
	                width: model.get("width"),
	                height: 40
	            },
	            draggable: false,
	            parmDate: this.model.get("parmDate")
	        }); 
	        this.add(switchNode);
	
	        this.position = [model.get("bounds.upperLeft.x") , model.get("bounds.upperLeft.y")];
	    };
	
	   
	
	    zrUtil.inherits(SwitchGMNode, NetworkNode);
	    module.exports = SwitchGMNode;
	


/***/ },
/* 107 */
/***/ function(module, exports, __webpack_require__) {

	
	    var util = __webpack_require__(71);
	    var NetworkNode = __webpack_require__(77);
	    var zrUtil = __webpack_require__(4);
	    var graphic = __webpack_require__(3);
	    var NetworkModel = __webpack_require__(74);
	    var SwitchTopoNode = __webpack_require__(103);
	    
	    function SwitchKMNode(model,api) {
	        SwitchTopoNode.call(this, model, api);
	        //this.rackkInfo = {type: -1, name: "SwitchKMNode" };    
	        this.model = model;
	        this.parmDate = this.model.get("parmDate");
	        this.portNodeList = [];
	        this.render(model,api);
	    };
	
	    SwitchKMNode.prototype.render = function(model, api) {
	        this.model = model;
	        var _showTip = model.get("showTip");
	
	        var _title = new graphic.Text({
	            style: {
	                x: model.get("width") / 2 - 10,
	                y: -20,
	                text: model.get("name"),
	                width: 200,
	                height: 20,
	                fill: '#8F8B8A',
	                textFont: '12px Microsoft Yahei',
	                textBaseline: 'top'
	            },
	            draggable: true
	        });
	        this.add(_title);
	
	        var switchNode = new graphic.Image({
	            position: [0, 0],
	            scale: [1, 1],
	            style: {
	                x: 0,
	                y: 0,
	                image: '../../../../fish-topo-network/src/images/KMSwitch.png',
	                width: model.get("width"),
	                height: 40
	            },
	            draggable: false,
	            parmDate: this.model.get("parmDate")
	        }); 
	        this.add(switchNode);
	
	
	        //�˿�
	        var portModel = {};
	        portModel = {
	            resourceId: util.getUUID(),  
	            bounds: {
	                upperLeft: {x:model.get("width") / 2, y: 10}  
	            },
	            stencil: {type: "PointNode"}
	        };
	        portModel.height = 6;
	        portModel.width = 11;
	        var _linInfo = {};
	        _linInfo.sourceReource = model.get("name");
	        _linInfo.sourcePort = "-1";
	        portModel.lineInfo = _linInfo;
	        var pModel = new NetworkModel(portModel);
	        this.addPortByModel(pModel, api);
	
	        this.position = [model.get("bounds.upperLeft.x") , model.get("bounds.upperLeft.y")];
	    };
	
	    SwitchKMNode.prototype.addPortByModel = function( p_model, api) {
	        var Shape = api.getNodeClass(p_model.get("stencil.type"));
	        var node = null;
	        if ( Shape ) {
	            node = new Shape(p_model, this._api);
	            this.portNodeList.push(node);
	            this.add(node);
	        }
	    };
	
	
	    zrUtil.inherits(SwitchKMNode, NetworkNode);
	    module.exports = SwitchKMNode;
	


/***/ },
/* 108 */
/***/ function(module, exports, __webpack_require__) {

	
	    var util = __webpack_require__(71);
	    var zrUtil = __webpack_require__(4);
	    var graphic = __webpack_require__(3);
	    var NetworkNode = __webpack_require__(77);
	    var NetWorkLineNode = __webpack_require__(88);
	    var NetworkModel = __webpack_require__(74);
	    var DatabaseModel = __webpack_require__(109);
		var AsmModel = __webpack_require__(110);
		var ISEModel = __webpack_require__(111);
	    var NetWorkLineModel = __webpack_require__(94);
	    var Connector = __webpack_require__(89);
	
	
	    function ClusterDrawNode(model, api) {
	        NetworkNode.call(this, model, api);
	        this.info = {type: -1, name: "ClusterDrawNode" };    
	        this.model = model;
	        this.databaseList = [];
	        this.dgList = [];
	        this.render(model, api);
	    };
	
	    ClusterDrawNode.prototype.render = function(model, api) {
	    	var nodeList = model.get("nodeList");
	        var _showTip = model.get("showTip");
	        var dataModelData = {};
	    	var asmModelData = {};
	    	var storageModelData = {};
	    	var _dgList = [];
	    	for( var i = 0; i < nodeList.length; i++ ) {
	    		var nodeY = 10;
	            var startX = 0;
	    		if ( nodeList[i].type === "database" ) {
	    			var dbData = nodeList[i].dbData;
	    			if ( dbData != undefined && dbData.length > 0 ) {
	                    dataModelData = {
	                        resourceId: util.getUUID(),  
	                        bounds: {
	                            upperLeft: {x: startX, y: nodeY}  
	                        },
	                        stencil: {type: "ClusterDatabaseNode"}
	                    };
	                    dataModelData.dbData = dbData;
	                    dataModelData.showTip = _showTip;
	    			}	
	    		} else if( nodeList[i].type === "asm") {
	    			var startX = 0;
	    			nodeY = 250;
	    			asmModelData = {
	                    resourceId: util.getUUID(),  
	                    bounds: {
	                        upperLeft: {x: startX, y: nodeY}  
	                    },
	                    stencil: {type: "ClusterAsmNode"}
	                };
	                asmModelData.name = nodeList[i].name;
	                asmModelData.asmData = nodeList[i].asmData;
	                asmModelData.dgData = nodeList[i].dgData;
	                asmModelData.status = nodeList[i].status;
	                asmModelData.showTip = _showTip;
	    		} else if( nodeList[i].type === "storage" ) {
	    			var startX = 0;
	    			nodeY = 550;
	    			storageModelData = {
	                    resourceId: util.getUUID(),  
	                    bounds: {
	                        upperLeft: {x: startX, y: nodeY}  
	                    },
	                    stencil: {type: "ClusterIseNode"}
	                };
	                storageModelData.childNodeList = nodeList[i].iseData;
	                storageModelData.showTip = _showTip;
	    		}
	
	    	}
	
	        var databaseModel = new DatabaseModel(dataModelData);
	        this.addNodeByModel(databaseModel, api);
	
	        
	        //画矩形
	        var mangerNode = new graphic.Rect({
	            shape: {
	                r: 20,
	                x: 50,
	                y: 300,
	                width: api.getWidth() - 100,
	                height: 300
	            },
	            style: {
	                fill: '#FFFFFF',
	                stroke: '#B3B3B3',
	                lineWidth: '1',
	                lineDash: [12]  
	            }          
	        });              
	        this.add(mangerNode);
	
	        asmModelData.database = dataModelData.dbData !== undefined ? dataModelData.dbData.length : 0;
	    	var asmModel = new AsmModel(asmModelData);
	        this.addNodeByModel(asmModel, api);
	
	        var iseModel = new ISEModel(storageModelData);
	        this.addNodeByModel(iseModel, api);
	
	
	
	        //连线
	        for (var l = 0; l < this.databaseList.length; l++ ) {
	            this.drawLine(this.databaseList[l], this.dgList[l], api);
	        }
	
	    };
	
	    ClusterDrawNode.prototype.addNodeByModel = function( p_model, api) {
	        
	        var Shape = api.getNodeClass(p_model.get("stencil.type"));
	        var node = null;
	        if ( Shape ) {
	            node = new Shape(p_model, api);
	            this.add(node);
	            var MOUSE_EVENT_NAMES = ['click'];
	            if ( p_model.get("showTip") ) {
	                MOUSE_EVENT_NAMES = ['click', 'mouseover', 'mouseout'];
	            }
	            zrUtil.each(MOUSE_EVENT_NAMES, function (eveName) {
	                 node.on(eveName, function (e) {
	                     var params = {};
	                    if ( eveName === "mouseover") {
	                        params.event = e;
	                        params.x = node.parent.position[0] +  (e.target.shape ? e.target.shape.x : 0) + (e.target.shape ? e.target.shape.width : 0);
	                        params.y = node.parent.position[1] + (e.target.shape ? e.target.shape.y : 0) + (e.target.shape ? e.target.shape.height : 0) / 2;
	                        params.width = 150;
	                        params.height = 170;
	                        params.eWidth =  5 ;
	                        params.parmDate = e.target.parmDate;
	                        if ( api.getWidth() - params.x < params.width ) {
	                            params.layout = "left";
	                        } else {
	                            params.layout = "right";
	                        }
	                        //api.showTipWindow(params);
	                    } else if (eveName === "mouseout") {
	                        //api.hideTipWindow(e.event.target);
	                    } else if (eveName === "click") {
	                        params.event = e;
	                        params.parmDate = e.target.parmDate;
	                    } 
	                    api.trigger(eveName, params);   
	                }, this);
	            });
	
	            if ( api.getWidth()  < node.clientWidth ) {
	                api.resize(node.clientWidth, api.getHeight());
	            }
	            if( node.portNodeList !== undefined && node.portNodeList.length > 0 ) {
	                if ( node.info.name === "ClusterDatabaseNode" ) {
	                    for (var i = 0; i < node.portNodeList.length; i++ ) {
	                        this.databaseList.push(node.portNodeList[i]);
	                    }
	                } else if( node.info.name === "ClusterAsmNode" ) {
	                    for (var i = 0; i < node.portNodeList.length; i++ ) {
	                        this.dgList.push(node.portNodeList[i]);
	                    }
	                } 
	            }
	        }
	
	    };
	
	    ClusterDrawNode.prototype.drawLine = function( p_startNode, p_endNode, api ) {
	        var fleftx = p_startNode.parent.position[0] + p_startNode.shape.x;
	        var flefty = p_startNode.parent.position[1] + p_startNode.shape.y;
	        var fwidth =  p_startNode.shape.width;
	        var fheight = p_startNode.shape.height;
	
	        var torightx = p_endNode.parent.position[0] + p_endNode.shape.x;
	        var torighty = p_endNode.parent.position[1] + p_endNode.shape.y;
	        var towidth =  p_endNode.shape.width;
	        var toheight = p_endNode.shape.height;
	        var moddleY = 200;    
	        var moddleX = api.getWidth() / 2; 
	        
	        var _toModdleY = moddleY;
	        if ( torightx + 25 > moddleX ) {
	            _toModdleY = moddleY - 15;
	        } else {
	            _toModdleY = moddleY + 15;
	        }
	
	        var defaultOptionDatabase = {
	            fromBounds : {x: fleftx - 15, y: flefty, width: fwidth, height: fheight},
	            toBounds: {x: torightx - 15, y: torighty, width: towidth, height: toheight},
	            moddleY: _toModdleY,
	            style : {
	                lineWidth : 3,
	                stroke: '#050505'//,
	                //fill: '#9699DD'
	            },
	            hoverStyle : {
	                lineWidth : 3,
	                stroke: '#0B8329'//,
	                //fill:'#2FDE92'
	            },
	            isEdit: false,
	            isVector: true,
	            lineType: Connector.TYPE_CURVE
	        }
	        var databaseModel = new NetWorkLineModel(defaultOptionDatabase);
	        var databaseNode = new NetWorkLineNode(databaseModel);
	        this.add(databaseNode);
	
	        var _backModdleY = moddleY;
	        if ( torightx + 25 > moddleX ) {
	            _backModdleY = moddleY + 15;
	        } else {
	            _backModdleY = moddleY - 15;
	        }
	         var defaultOptionDg = {
	            fromBounds : {x: torightx + 15, y: torighty, width: towidth, height: toheight},
	            toBounds: {x: fleftx + 15, y: flefty, width: fwidth, height: fheight},
	            moddleY: _backModdleY,
	            style : {
	                lineWidth : 3,
	                stroke: '#050505'//,
	                //fill: '#9699DD'
	            },
	            hoverStyle : {
	                lineWidth : 3,
	                stroke: '#0B8329'//,
	                //fill:'#2FDE92'
	            },
	            isEdit: false,
	            isVector: true,
	            lineType: Connector.TYPE_CURVE
	        }
	        var dgModel = new NetWorkLineModel(defaultOptionDg);
	        var dgNode = new NetWorkLineNode(dgModel);
	        this.add(dgNode);
	
	
	    };
	
	    ClusterDrawNode.prototype.bind = function( p_node, p_eventList, api) {
	        if ( p_eventList != undefined && p_eventList.length > 0 ) {
	            //绑定悬浮事件
	            zrUtil.each(p_eventList, function (eveName) {
	                p_node.on(eveName, function (e) {
	                    if ( eveName === "mouseover") {
	                        var params = {};
	                        params.event = e;
	                        params.x = p_node.position[0] + e.target.shape.width;
	                        params.y = p_node.position[1] + e.target.shape.height / 2;
	                        params.width = 150;
	                        params.height = 170;
	                        params.eWidth =  5 ;
	                        params.parmDate = e.target.parmDate;
	                        api.showTipWindow(params);
	                    } else {
	                        api.hideTipWindow(e.event.target);
	                    }    
	                }, this);
	            }, this);
	        }
	    }
	
	    zrUtil.inherits(ClusterDrawNode, NetworkNode);
	    module.exports = ClusterDrawNode;


/***/ },
/* 109 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Server DatabaseModel
	 *
	 */
	
	
	    var Model = __webpack_require__(75);
	    var zrUtil = __webpack_require__(4);
	    var NetworkModel = __webpack_require__(74);
	
	    var DatabaseModel = NetworkModel.extend({
	        name: "",
	    	height: 200,
	        width: 190,
	        status : "online",
	        instanse: {},
	        dg: []
	    });
	    module.exports = DatabaseModel;
	


/***/ },
/* 110 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Server AsmModel
	 *
	 */
	
	
	    var Model = __webpack_require__(75);
	    var zrUtil = __webpack_require__(4);
	    var NetworkModel = __webpack_require__(74);
	
	    var AsmModel = NetworkModel.extend({
	        name: "",
	    	height: 200,
	        width: 190,
	        status : "online",
	        asmData : [],
	        dg: []
	    });
	    module.exports = AsmModel;
	


/***/ },
/* 111 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * ISE Model
	 *
	 */
	
	
	    var Model = __webpack_require__(75);
	    var zrUtil = __webpack_require__(4);
	    var NetworkModel = __webpack_require__(74);
	
	    var ISEModel = NetworkModel.extend({
	        name: "",
	    	height: 200,
	        width: 250,
	        status : "online",
	        childNodeList: []
	    });
	    module.exports = ISEModel;
	


/***/ },
/* 112 */
/***/ function(module, exports, __webpack_require__) {

	
	    var util = __webpack_require__(71);
	    var NetworkNode = __webpack_require__(77);
	    var ClusterDrawNode = __webpack_require__(108);
	    var zrUtil = __webpack_require__(4);
	    var graphic = __webpack_require__(3);
	    var NetworkModel = __webpack_require__(74);
	    
	    function ClusterDatabaseNode(model, api) {
	        ClusterDrawNode.call(this, model, api);
	        this.info = {type: -1, name: "ClusterDatabaseNode" };    
	        this.model = model;
	        this.lineInfo = model.get('lineInfo');
	        this.portNodeList = [];
	        this.render(model,api);
	    };
	
	    ClusterDatabaseNode.prototype.render = function(model, api) {
	        this.model = model;
	        var dbData = model.get("dbData");
	        var _width = 280;
	        var _height = 80;
	        var _interval = 50;
	        var _x = (api.getWidth() - dbData.length * (_width + _interval)) / 2 - 140;
	        var _y = 0;
	        for ( var d = 0 ; d < dbData.length; d++ ) {
	            var parmDate = dbData[d];
	            parmDate.type = "database";
	            //实例宽度
	            var _instanseWidth = 150;
	            _width = (_instanseWidth + 10) * (dbData[d].instanse.length + 1) + 10;
	
	             //创建数据库对象
	            var portNode = new graphic.Rect({
	                shape: {
	                    r: 10,
	                    x: _x,
	                    y: _y,
	                    width: _width,
	                    height: _height
	                },
	                style: {
	                    //fill: '#E2E3D9',
	                    //stroke: '#B3B3B3',
	                    fill: '#FFFFFF',
	                    stroke: '#88888B',
	                    opacity: 1,
	                    lineWidth: '2'//,
	                },
	                parmDate: parmDate       
	            });  
	            portNode.lineInfo = this.lineInfo;            
	            this.add(portNode);
	
	            // var MOUSE_EVENT_NAMES = ['click', 'mouseover', 'mouseout'];   
	            // zrUtil.each(MOUSE_EVENT_NAMES, function (eveName) {
	            //      portNode.on(eveName, function (e) {
	            //         if ( eveName === "mouseover") {
	            //             var params = {};
	            //             params.event = e;
	            //             params.x = portNode.parent.position[0] + e.target.shape.x + e.target.shape.width;
	            //             params.y = portNode.parent.position[1] + e.target.shape.y + e.target.shape.height / 2;
	            //             params.width = 150;
	            //             params.height = 170;
	            //             params.eWidth =  5 ;
	            //             params.parmDate = e.target.parmDate;
	            //             if ( api.getWidth() - params.x < params.width ) {
	            //                 params.layout = "left";
	            //             } else {
	            //                 params.layout = "right";
	            //             }
	            //             //api.showTipWindow(params);
	            //         } else {
	            //             //api.hideTipWindow(e.event.target);
	            //         }    
	            //     }, this);
	            // });
	           
	
	            this.portNodeList.push(portNode);
	
	            var _instanse = dbData[d].instanse;
	            //创建数据库实例对象
	            if( _instanse != undefined && _instanse.length > 0 ) {
	                 var _title = new graphic.Text({
	                    style: {
	                        x: _x + 70,
	                        y: 15,
	                        text: "数据库实例: ",
	                        width: 70,
	                        height: 20,
	                        fill: '#8F8B8A',
	                        textFont: '14px Microsoft Yahei',
	                        textBaseline: 'top'
	                    },
	                    draggable: true
	                });
	                this.add(_title);
	
	                var _instanseX = _x + _instanseWidth + 10;
	                _instanseWidth = 150;
	                for (var i = 0; i < _instanse.length; i++ ) {
	
	                    var _instanseNode = new graphic.Rect({
	                        shape: {
	                            x: _instanseX,
	                            y: 10,
	                            width: _instanseWidth,
	                            height: 30
	                        },
	                        style: {
	                            fill: '#FFFFFF',
	                            stroke: '#88888B',
	                            opacity: 1,
	                            lineWidth: '2'//,
	                        }          
	                    }); 
	                    this.add(_instanseNode);
	
	                     //状态 
	                    var _instansestatusNode = new graphic.Circle({
	                         shape: {
	                            cx: _instanseX + 15,
	                            cy: 25,
	                            r: 5
	                        },
	                        style: {
	                            fill: '#077826'/*,
	                            stroke: '#B3B3B3',
	                            lineWidth: '2'//,*/
	                        } 
	                    });
	                    if ( _instanse[i].status === "offline") {
	                        _instansestatusNode.style.fill = "#999999";
	                    }
	                    this.add(_instansestatusNode);
	
	                    //文字
	                    var _instanseTitle = new graphic.Text({
	                        style: {
	                            x: _instanseX + 25,
	                            y: 15,
	                            text: _instanse[i].name,
	                            width: 200,
	                            height: 20,
	                            fill: '#8F8B8A',
	                            textFont: '14px Microsoft Yahei',
	                            textBaseline: 'top'
	                        },
	                        draggable: true
	                    });       
	                    this.add(_instanseTitle);
	                    _instanseX = _instanseWidth + _instanseX + 10;
	                }
	            }
	
	
	            // //物理状态 
	            // var _phyStatus = new graphic.Rect({
	            //     shape: {
	            //         x: _instanseX,
	            //         y: 32,
	            //         width: 280,
	            //         height: 50
	            //     },
	            //     style: {
	            //         fill: '#CCCCCC',
	            //         stroke: '#B3B3B3',
	            //         lineWidth: '2'//,
	            //     }          
	            // }); 
	            // if ( model.get("status") === "offline") {
	            //     _phyStatus.style.fill = "#CFB624";
	            // }
	            // this.add(_phyStatus);
	
	            //状态 
	            var _status = new graphic.Circle({
	                 shape: {
	                    cx: _x + _width / 2 - 30,
	                    cy: 60,
	                    r: 5
	                },
	                style: {
	                    fill: '#077826'/*,
	                    stroke: '#B3B3B3',
	                    lineWidth: '2'//,*/
	                } 
	            });
	            if ( model.get("status") === "offline") {
	                _status.style.fill = "#999999";
	            }
	            this.add(_status);
	
	            var _title = new graphic.Text({
	                style: {
	                    x: _x + _width / 2 - 20,
	                    y: 50,
	                    text: dbData[d].name,
	                    width: 200,
	                    height: 20,
	                    fill: '#020202',
	                    textFont: '18px Microsoft Yahei',
	                    textBaseline: 'top'
	                },
	                draggable: true
	            });
	            this.add(_title);
	            _x = _x + _width + _interval;
	        }
	        this.clientWidth = _x + 50;
	    
	        this.position = [model.get("bounds.upperLeft.x") , model.get("bounds.upperLeft.y")];
	    };
	
	   
	    zrUtil.inherits(ClusterDatabaseNode, NetworkNode);
	
	    module.exports = ClusterDatabaseNode;


/***/ },
/* 113 */
/***/ function(module, exports, __webpack_require__) {

	
	    var util = __webpack_require__(71);
	    var NetworkNode = __webpack_require__(77);
	    var ClusterDrawNode = __webpack_require__(108);
	    var zrUtil = __webpack_require__(4);
	    var graphic = __webpack_require__(3);
	    var NetworkModel = __webpack_require__(74);
	    
	    function ClusterAsmNode(model,api) {
	        ClusterDrawNode.call(this, model, api);
	        this.info = {type: -1, name: "ClusterAsmNode" };    
	        this.model = model;
	        this.lineInfo = model.get('lineInfo');
	        return this.render(model,api);
	    };
	
	    ClusterAsmNode.prototype.render = function(model, api) {
	        var dgList = model.get("dgData");
	        var _dgW = 150;
	        var _dgH = 30;
	        var fullDgHeight = this.getNodeHeight( dgList.length + 1, _dgH, 4 );
	        var fullDgWidth = (_dgW + 5) * 4 + 5;
	
	        var _startX = (api.getWidth() - fullDgWidth) / 2;
	        var _startY = 0;
	
	        //影藏连线点
	        var databaseList = model.get("database");
	        if ( databaseList > 0 ) {
	            var _lSpace = ( fullDgWidth - (databaseList * 30) ) / (databaseList + 1) 
	            var _lX = _startX + _lSpace;
	            var _lY = 0;
	            for ( var l = 0; l < databaseList; l++ ) {
	                var dgLineNode = new graphic.Rect({
	                    shape: {
	                        r: 10,
	                        x: _lX,
	                        y: 0,
	                        width: 5,
	                        height: 5
	                    },
	                    style: {
	                        fill: 'red',
	                        stroke: 'red',
	                        opacity: 0.001,
	                        lineWidth: '2'//,
	                    }          
	                });
	                this.add(dgLineNode);
	                this.portNodeList.push(dgLineNode); 
	                _lX += _lSpace;
	            }
	        }
	              
	        var fullDgNode = new graphic.Rect({
	            shape: {
	                r: 10,
	                x: _startX,
	                y: _startY,
	                width: fullDgWidth,
	                height: fullDgHeight
	            },
	            style: {
	                fill: '#FFFFFF',
	                stroke: '#88888B',
	                opacity: 1,
	                lineWidth: '2'//,
	            }          
	        }); 
	        this.add(fullDgNode);
	
	        //添加DG 单元
	        var _dgCellX = _startX + 5;
	        var _dgCellY = _startY + 5;
	        for ( var i = -1 ; i < dgList.length; i++ ) { 
	            if ( i === -1 ) {
	                var _title = new graphic.Text({
	                    style: {
	                        x: _dgCellX + 70,
	                        y: _dgCellY + 7,
	                        text: "DG List: ",
	                        width: _dgW,
	                        height: _dgH,
	                        fill: '#8F8B8A',
	                        textFont: '14px Microsoft Yahei',
	                        textBaseline: 'top'
	                    },
	                    draggable: true
	                });
	                this.add(_title);
	
	            } else {
	                 var cellModelData = {
	                    resourceId: util.getUUID(), 
	                    bounds: {
	                            upperLeft: {x: 0, y: 0}  
	                        }, 
	                    stencil: {type: "ClusterAsmCellNode"}
	                };
	         
	                cellModelData.bounds.upperLeft.x = _dgCellX;
	                cellModelData.bounds.upperLeft.y = _dgCellY;
	
	                cellModelData.height = _dgH;
	                cellModelData.width = _dgW;
	                cellModelData.title = dgList[i].name;
	                cellModelData.status = dgList[i].status;
	                var cellModel = new NetworkModel(cellModelData);
	                this.addNodeByModel(cellModel, api); 
	
	            }
	           
	            if ( (i + 2) % 4 !== 0 ) {
	                _dgCellX = _dgCellX + _dgW + 5;
	                _dgCellY = _dgCellY;
	            } else {
	                _dgCellX = _startX + 5;
	                _dgCellY = _dgCellY + _dgH + 5;
	            }
	
	        }
	
	        var parmDate = {};
	        parmDate.type = "asm";
	        var asmNode = new graphic.Rect({
	            shape: {
	                r: 10,
	                x: _startX,
	                y: _startY + fullDgHeight,
	                width: fullDgWidth,
	                height: 100
	            },
	            style: {
	                fill: '#FFFFFF',
	                stroke: '#88888B',
	                opacity: 1,
	                lineWidth: '2'//,
	            },
	            parmDate: parmDate             
	        });              
	        this.add(asmNode);
	
	        //遍历ASM实例对象
	        var asmData = model.get("asmData");
	        var fullAsmHeight = this.getNodeHeight(asmData.length, _dgH, 4);
	         //添加DG 单元
	        var _asmCellX = _startX + 5;
	        var _asmCellY = _startY + fullDgHeight + 5;
	
	        for ( var j = -1; j < asmData.length; j++ ) { 
	            if ( j === -1) {
	                var _title = new graphic.Text({
	                    style: {
	                        x: _asmCellX + 70,
	                        y: _asmCellY + 7,
	                        text: "ASM实例: ",
	                        width: _dgW,
	                        height: _dgH,
	                        fill: '#8F8B8A',
	                        textFont: '14px Microsoft Yahei',
	                        textBaseline: 'top'
	                    },
	                    draggable: true
	                });
	                this.add(_title);
	            } else {
	                var cellModelData = {
	                    resourceId: util.getUUID(), 
	                    bounds: {
	                            upperLeft: {x: 0, y: 0}  
	                        }, 
	                    stencil: {type: "ClusterAsmCellNode"}
	                };
	         
	                cellModelData.bounds.upperLeft.x = _asmCellX;
	                cellModelData.bounds.upperLeft.y = _asmCellY;
	
	                cellModelData.height = _dgH;
	                cellModelData.width = _dgW;
	                cellModelData.title = asmData[j].name;
	                cellModelData.status = asmData[j].status;
	                var cellModel = new NetworkModel(cellModelData);
	                this.addNodeByModel(cellModel, api); 
	
	            }
	            
	            if ( (j + 2) % 4 !== 0 ) {
	                _asmCellX = _asmCellX + _dgW + 5;
	                _asmCellY = _asmCellY;
	            } else {
	                _asmCellX = _startX + 5;
	                _asmCellY = _asmCellY + _dgH + 5;
	            }
	
	        }
	        
	        var _fullAsmX = _startX + 200;
	        var _fullAsmY = _startY + fullDgHeight + fullAsmHeight + 10;
	        
	        //状态 
	        var _asmStatusNode = new graphic.Circle({
	             shape: {
	                cx: _fullAsmX,
	                cy: _fullAsmY + 10,
	                r: 7
	            },
	            style: {
	                fill: '#077826'/*,
	                stroke: '#B3B3B3',
	                lineWidth: '2'//,*/
	            } 
	        });
	        if ( model.get("status") === "offline") {
	            _asmStatusNode.style.fill = "#999999";
	        }
	        this.add(_asmStatusNode);
	
	        var _asmTitle = new graphic.Text({
	            style: {
	                x: _fullAsmX + 20,
	                y: _fullAsmY,
	                text: "ASM",
	                width: 190,
	                height: 20,
	                fill: '#8F8B8A',
	                textFont: '18px Microsoft Yahei',
	                textBaseline: 'top'
	            },
	            draggable: true
	        });       
	        this.add(_asmTitle);
	        
	        
	        this.position = [model.get("bounds.upperLeft.x") , model.get("bounds.upperLeft.y")];
	        return _startY + fullDgHeight + 100;
	    };
	
	    ClusterAsmNode.prototype.addNodeByModel = function( p_model, api) {
	        var Shape = api.getNodeClass(p_model.get("stencil.type"));
	        var node = null;
	        if ( Shape ) {
	            node = new Shape(p_model, this.api);
	            this.add(node);
	        }
	    };
	
	
	    ClusterAsmNode.prototype.getNodeHeight  = function( p_count, p_height, p_num) {
	        var returnValue = 0;
	        if(  p_count % p_num !== 0 ) {
	            returnValue =  ( (parseInt(p_count) - parseInt(p_count) %  p_num) / p_num  + 1) * (p_height + 5) + 5;
	        } else {
	            returnValue =  ( parseInt(p_count) / p_num) * (p_height + 5)  + 5;
	        }
	        return returnValue;
	    };
	
	    zrUtil.inherits(ClusterAsmNode, NetworkNode);
	    module.exports = ClusterAsmNode;


/***/ },
/* 114 */
/***/ function(module, exports, __webpack_require__) {

	
	    var util = __webpack_require__(71);
	    var NetworkNode = __webpack_require__(77);
	    var zrUtil = __webpack_require__(4);
	    var graphic = __webpack_require__(3);
	    var NetworkModel = __webpack_require__(74);
	    
	    function ClusterAsmCellNode(model,api) {
	        NetworkNode.call(this, model, api);
	        this.rackkInfo = {type: -1, name: "ClusterAsmCellNode" };    
	        this.model = model;
	        this.lineInfo = model.get('lineInfo');
	        this.render(model,api);
	    };
	
	    ClusterAsmCellNode.prototype.render = function(model, api) {
	        var _y = model.get("bounds.upperLeft.y");
	        var _x = model.get("bounds.upperLeft.x");
	        var _width = model.get("width");
	        var _height = model.get("height");
	        var cellNode = new graphic.Rect({
	            shape: {
	                r: 10,
	                x: 0,
	                y: 0,
	                width: _width,
	                height: _height
	            },
	            style: {
	                fill: '#FFFFFF',
	                stroke: '#88888B',
	                opacity: 1,
	                lineWidth: '2'//,
	            }          
	        });              
	        this.add(cellNode);
	
	        //状态 
	        var cellStateNode = new graphic.Circle({
	             shape: {
	                cx: 10,
	                cy: 15,
	                r: _height / 2 - 10
	            },
	            style: {
	                fill: '#077826'/*,
	                stroke: '#B3B3B3',
	                lineWidth: '2'//,*/
	            } 
	        });
	        if ( model.get("status") === "offline") {
	            cellStateNode.style.fill = "#999999";
	        }
	        this.add(cellStateNode);
	
	        var cellTitle = new graphic.Text({
	            style: {
	                x: 20,
	                y: 5,
	                text: model.get("title"),
	                width: 50,
	                height: 30,
	                fill: '#8F8B8A',
	                textFont: '14px Microsoft Yahei',
	                textBaseline: 'top'
	            },
	            draggable: true
	        });       
	        this.add(cellTitle);
	
	        this.position = [model.get("bounds.upperLeft.x"), model.get("bounds.upperLeft.y")];
	    };
	
	
	    zrUtil.inherits(ClusterAsmCellNode, NetworkNode);
	    module.exports = ClusterAsmCellNode;


/***/ },
/* 115 */
/***/ function(module, exports, __webpack_require__) {

	
	    var util = __webpack_require__(71);
	    var NetworkNode = __webpack_require__(77);
	    var zrUtil = __webpack_require__(4);
	    var graphic = __webpack_require__(3);
	    var NetworkModel = __webpack_require__(74);
	    var ISEModel = __webpack_require__(111);
	    function ClusterIseNode(model,api) {
	        NetworkNode.call(this, model, api);
	        this.rackkInfo = {type: -1, name: "ClusterIseNode" };    
	        this.model = model;
	        this.lineInfo = model.get('lineInfo');
	        this.render(model,api);
	    };
	
	    ClusterIseNode.prototype.render = function(model, api) {
	        var iseList = model.get("childNodeList");
	        var startX = 0;
	        var startY = 0;
	        var nodeWidth = 0;
	        for ( var i = 0; i < iseList.length; i++ ) {
	            var isedata = {
	                resourceId: util.getUUID(),  
	                bounds: {
	                    upperLeft: {x: startX, y: startY}  
	                },
	                stencil: {type: "ClusterIseCellNode"}
	            };
	            isedata.width = 100;
	            isedata.height = 150;
	            isedata.status = iseList[i].status;
	            isedata.title = iseList[i].name;
	            isedata.childNodeList = iseList[i].disk;
	            var iseCellModel = new ISEModel(isedata);
	            this.addNodeByModel(iseCellModel, api);
	            startX = startX + 100 + 50;
	            nodeWidth = nodeWidth + 150;
	        }
	
	        var _x = (api.getWidth() - nodeWidth) / 2;
	        this.position = [_x , model.get("bounds.upperLeft.y")];
	    };
	
	    ClusterIseNode.prototype.addNodeByModel = function( p_model, api) {
	        var Shape = api.getNodeClass(p_model.get("stencil.type"));
	        var node = null;
	        if ( Shape ) {
	            node = new Shape(p_model, this.api);
	            this.add(node);
	        }
	    };
	
	
	    ClusterIseNode.prototype.getDgNodeWidth  = function( p_count, p_height, p_space) {
	        var returnValue = 0;
	       
	        return returnValue;
	    };
	
	    zrUtil.inherits(ClusterIseNode, NetworkNode);
	    module.exports = ClusterIseNode;


/***/ },
/* 116 */
/***/ function(module, exports, __webpack_require__) {

	
	    var util = __webpack_require__(71);
	    var NetworkNode = __webpack_require__(77);
	    var zrUtil = __webpack_require__(4);
	    var graphic = __webpack_require__(3);
	    var NetworkModel = __webpack_require__(74);
	    
	    function ClusterIseCellNode(model,api) {
	        NetworkNode.call(this, model, api);
	        this.rackkInfo = {type: -1, name: "ClusterIseCellNode" };    
	        this.model = model;
	        this.lineInfo = model.get('lineInfo');
	        this.render(model,api);
	    };
	
	    ClusterIseCellNode.prototype.render = function(model, api) {
	        var isecellNode = new graphic.Rect({
	            shape: {
	                r: 10,
	                x: 0,
	                y: 0,
	                width: 120,
	                height: 100
	            },
	            style: {
	                fill: '#FFFFFF',
	                stroke: '#88888B',
	                opacity: 1,
	                lineWidth: '2'//,
	            }          
	        });              
	        this.add(isecellNode);
	
	        //状态 
	        var isecellStatus = new graphic.Circle({
	             shape: {
	                cx: 15,
	                cy: 45,
	                r: 5
	            },
	            style: {
	                fill: '#077826'/*,
	                stroke: '#89898B',
	                lineWidth: '2'//,*/
	            } 
	        });
	        if ( model.get("status") === "offline") {
	            isecellStatus.style.fill = "#999999";
	        }
	        this.add(isecellStatus);
	
	        var isecellTitle = new graphic.Text({
	            style: {
	                x: 25,
	                y: 35,
	                text: "ISE: " + model.get("title"),
	                width: 50,
	                height: 30,
	                fill: '#020202',
	                textFont: '14px Microsoft Yahei',
	                textBaseline: 'top'
	            },
	            draggable: true
	        });       
	        this.add(isecellTitle);
	
	        this.position = [model.get("bounds.upperLeft.x"), model.get("bounds.upperLeft.y")];
	    };
	
	
	    zrUtil.inherits(ClusterIseCellNode, NetworkNode);
	    module.exports = ClusterIseCellNode;


/***/ },
/* 117 */
/***/ function(module, exports, __webpack_require__) {

	
	    __webpack_require__(118);
	    __webpack_require__(59).registerPainter('vml', __webpack_require__(120));


/***/ },
/* 118 */
/***/ function(module, exports, __webpack_require__) {

	// http://www.w3.org/TR/NOTE-VML
	// TODO Use proxy like svg instead of overwrite brush methods
	
	
	if (!__webpack_require__(60).canvasSupported) {
	    var vec2 = __webpack_require__(14);
	    var BoundingRect = __webpack_require__(24);
	    var CMD = __webpack_require__(25).CMD;
	    var colorTool = __webpack_require__(19);
	    var textContain = __webpack_require__(23);
	    var RectText = __webpack_require__(22);
	    var Displayable = __webpack_require__(7);
	    var ZImage = __webpack_require__(40);
	    var Text = __webpack_require__(42);
	    var Path = __webpack_require__(6);
	
	    var Gradient = __webpack_require__(37);
	
	    var vmlCore = __webpack_require__(119);
	
	    var round = Math.round;
	    var sqrt = Math.sqrt;
	    var abs = Math.abs;
	    var cos = Math.cos;
	    var sin = Math.sin;
	    var mathMax = Math.max;
	
	    var applyTransform = vec2.applyTransform;
	
	    var comma = ',';
	    var imageTransformPrefix = 'progid:DXImageTransform.Microsoft';
	
	    var Z = 21600;
	    var Z2 = Z / 2;
	
	    var ZLEVEL_BASE = 100000;
	    var Z_BASE = 1000;
	
	    var initRootElStyle = function (el) {
	        el.style.cssText = 'position:absolute;left:0;top:0;width:1px;height:1px;';
	        el.coordsize = Z + ','  + Z;
	        el.coordorigin = '0,0';
	    };
	
	    var encodeHtmlAttribute = function (s) {
	        return String(s).replace(/&/g, '&amp;').replace(/"/g, '&quot;');
	    };
	
	    var rgb2Str = function (r, g, b) {
	        return 'rgb(' + [r, g, b].join(',') + ')';
	    };
	
	    var append = function (parent, child) {
	        if (child && parent && child.parentNode !== parent) {
	            parent.appendChild(child);
	        }
	    };
	
	    var remove = function (parent, child) {
	        if (child && parent && child.parentNode === parent) {
	            parent.removeChild(child);
	        }
	    };
	
	    var getZIndex = function (zlevel, z, z2) {
	        // z 的取值范围为 [0, 1000]
	        return (parseFloat(zlevel) || 0) * ZLEVEL_BASE + (parseFloat(z) || 0) * Z_BASE + z2;
	    };
	
	    var parsePercent = function (value, maxValue) {
	        if (typeof value === 'string') {
	            if (value.lastIndexOf('%') >= 0) {
	                return parseFloat(value) / 100 * maxValue;
	            }
	            return parseFloat(value);
	        }
	        return value;
	    };
	
	    /***************************************************
	     * PATH
	     **************************************************/
	
	    var setColorAndOpacity = function (el, color, opacity) {
	        var colorArr = colorTool.parse(color);
	        opacity = +opacity;
	        if (isNaN(opacity)) {
	            opacity = 1;
	        }
	        if (colorArr) {
	            el.color = rgb2Str(colorArr[0], colorArr[1], colorArr[2]);
	            el.opacity = opacity * colorArr[3];
	        }
	    };
	
	    var getColorAndAlpha = function (color) {
	        var colorArr = colorTool.parse(color);
	        return [
	            rgb2Str(colorArr[0], colorArr[1], colorArr[2]),
	            colorArr[3]
	        ];
	    };
	
	    var updateFillNode = function (el, style, zrEl) {
	        // TODO pattern
	        var fill = style.fill;
	        if (fill != null) {
	            // Modified from excanvas
	            if (fill instanceof Gradient) {
	                var gradientType;
	                var angle = 0;
	                var focus = [0, 0];
	                // additional offset
	                var shift = 0;
	                // scale factor for offset
	                var expansion = 1;
	                var rect = zrEl.getBoundingRect();
	                var rectWidth = rect.width;
	                var rectHeight = rect.height;
	                if (fill.type === 'linear') {
	                    gradientType = 'gradient';
	                    var transform = zrEl.transform;
	                    var p0 = [fill.x * rectWidth, fill.y * rectHeight];
	                    var p1 = [fill.x2 * rectWidth, fill.y2 * rectHeight];
	                    if (transform) {
	                        applyTransform(p0, p0, transform);
	                        applyTransform(p1, p1, transform);
	                    }
	                    var dx = p1[0] - p0[0];
	                    var dy = p1[1] - p0[1];
	                    angle = Math.atan2(dx, dy) * 180 / Math.PI;
	                    // The angle should be a non-negative number.
	                    if (angle < 0) {
	                        angle += 360;
	                    }
	
	                    // Very small angles produce an unexpected result because they are
	                    // converted to a scientific notation string.
	                    if (angle < 1e-6) {
	                        angle = 0;
	                    }
	                }
	                else {
	                    gradientType = 'gradientradial';
	                    var p0 = [fill.x * rectWidth, fill.y * rectHeight];
	                    var transform = zrEl.transform;
	                    var scale = zrEl.scale;
	                    var width = rectWidth;
	                    var height = rectHeight;
	                    focus = [
	                        // Percent in bounding rect
	                        (p0[0] - rect.x) / width,
	                        (p0[1] - rect.y) / height
	                    ];
	                    if (transform) {
	                        applyTransform(p0, p0, transform);
	                    }
	
	                    width /= scale[0] * Z;
	                    height /= scale[1] * Z;
	                    var dimension = mathMax(width, height);
	                    shift = 2 * 0 / dimension;
	                    expansion = 2 * fill.r / dimension - shift;
	                }
	
	                // We need to sort the color stops in ascending order by offset,
	                // otherwise IE won't interpret it correctly.
	                var stops = fill.colorStops.slice();
	                stops.sort(function(cs1, cs2) {
	                    return cs1.offset - cs2.offset;
	                });
	
	                var length = stops.length;
	                // Color and alpha list of first and last stop
	                var colorAndAlphaList = [];
	                var colors = [];
	                for (var i = 0; i < length; i++) {
	                    var stop = stops[i];
	                    var colorAndAlpha = getColorAndAlpha(stop.color);
	                    colors.push(stop.offset * expansion + shift + ' ' + colorAndAlpha[0]);
	                    if (i === 0 || i === length - 1) {
	                        colorAndAlphaList.push(colorAndAlpha);
	                    }
	                }
	
	                if (length >= 2) {
	                    var color1 = colorAndAlphaList[0][0];
	                    var color2 = colorAndAlphaList[1][0];
	                    var opacity1 = colorAndAlphaList[0][1] * style.opacity;
	                    var opacity2 = colorAndAlphaList[1][1] * style.opacity;
	
	                    el.type = gradientType;
	                    el.method = 'none';
	                    el.focus = '100%';
	                    el.angle = angle;
	                    el.color = color1;
	                    el.color2 = color2;
	                    el.colors = colors.join(',');
	                    // When colors attribute is used, the meanings of opacity and o:opacity2
	                    // are reversed.
	                    el.opacity = opacity2;
	                    // FIXME g_o_:opacity ?
	                    el.opacity2 = opacity1;
	                }
	                if (gradientType === 'radial') {
	                    el.focusposition = focus.join(',');
	                }
	            }
	            else {
	                // FIXME Change from Gradient fill to color fill
	                setColorAndOpacity(el, fill, style.opacity);
	            }
	        }
	    };
	
	    var updateStrokeNode = function (el, style) {
	        // if (style.lineJoin != null) {
	        //     el.joinstyle = style.lineJoin;
	        // }
	        // if (style.miterLimit != null) {
	        //     el.miterlimit = style.miterLimit * Z;
	        // }
	        // if (style.lineCap != null) {
	        //     el.endcap = style.lineCap;
	        // }
	        if (style.lineDash != null) {
	            el.dashstyle = style.lineDash.join(' ');
	        }
	        if (style.stroke != null && !(style.stroke instanceof Gradient)) {
	            setColorAndOpacity(el, style.stroke, style.opacity);
	        }
	    };
	
	    var updateFillAndStroke = function (vmlEl, type, style, zrEl) {
	        var isFill = type == 'fill';
	        var el = vmlEl.getElementsByTagName(type)[0];
	        // Stroke must have lineWidth
	        if (style[type] != null && style[type] !== 'none' && (isFill || (!isFill && style.lineWidth))) {
	            vmlEl[isFill ? 'filled' : 'stroked'] = 'true';
	            // FIXME Remove before updating, or set `colors` will throw error
	            if (style[type] instanceof Gradient) {
	                remove(vmlEl, el);
	            }
	            if (!el) {
	                el = vmlCore.createNode(type);
	            }
	
	            isFill ? updateFillNode(el, style, zrEl) : updateStrokeNode(el, style);
	            append(vmlEl, el);
	        }
	        else {
	            vmlEl[isFill ? 'filled' : 'stroked'] = 'false';
	            remove(vmlEl, el);
	        }
	    };
	
	    var points = [[], [], []];
	    var pathDataToString = function (data, m) {
	        var M = CMD.M;
	        var C = CMD.C;
	        var L = CMD.L;
	        var A = CMD.A;
	        var Q = CMD.Q;
	
	        var str = [];
	        var nPoint;
	        var cmdStr;
	        var cmd;
	        var i;
	        var xi;
	        var yi;
	        for (i = 0; i < data.length;) {
	            cmd = data[i++];
	            cmdStr = '';
	            nPoint = 0;
	            switch (cmd) {
	                case M:
	                    cmdStr = ' m ';
	                    nPoint = 1;
	                    xi = data[i++];
	                    yi = data[i++];
	                    points[0][0] = xi;
	                    points[0][1] = yi;
	                    break;
	                case L:
	                    cmdStr = ' l ';
	                    nPoint = 1;
	                    xi = data[i++];
	                    yi = data[i++];
	                    points[0][0] = xi;
	                    points[0][1] = yi;
	                    break;
	                case Q:
	                case C:
	                    cmdStr = ' c ';
	                    nPoint = 3;
	                    var x1 = data[i++];
	                    var y1 = data[i++];
	                    var x2 = data[i++];
	                    var y2 = data[i++];
	                    var x3;
	                    var y3;
	                    if (cmd === Q) {
	                        // Convert quadratic to cubic using degree elevation
	                        x3 = x2;
	                        y3 = y2;
	                        x2 = (x2 + 2 * x1) / 3;
	                        y2 = (y2 + 2 * y1) / 3;
	                        x1 = (xi + 2 * x1) / 3;
	                        y1 = (yi + 2 * y1) / 3;
	                    }
	                    else {
	                        x3 = data[i++];
	                        y3 = data[i++];
	                    }
	                    points[0][0] = x1;
	                    points[0][1] = y1;
	                    points[1][0] = x2;
	                    points[1][1] = y2;
	                    points[2][0] = x3;
	                    points[2][1] = y3;
	
	                    xi = x3;
	                    yi = y3;
	                    break;
	                case A:
	                    var x = 0;
	                    var y = 0;
	                    var sx = 1;
	                    var sy = 1;
	                    var angle = 0;
	                    if (m) {
	                        // Extract SRT from matrix
	                        x = m[4];
	                        y = m[5];
	                        sx = sqrt(m[0] * m[0] + m[1] * m[1]);
	                        sy = sqrt(m[2] * m[2] + m[3] * m[3]);
	                        angle = Math.atan2(-m[1] / sy, m[0] / sx);
	                    }
	
	                    var cx = data[i++];
	                    var cy = data[i++];
	                    var rx = data[i++];
	                    var ry = data[i++];
	                    var startAngle = data[i++] + angle;
	                    var endAngle = data[i++] + startAngle + angle;
	                    // FIXME
	                    // var psi = data[i++];
	                    i++;
	                    var clockwise = data[i++];
	
	                    var x0 = cx + cos(startAngle) * rx;
	                    var y0 = cy + sin(startAngle) * ry;
	
	                    var x1 = cx + cos(endAngle) * rx;
	                    var y1 = cy + sin(endAngle) * ry;
	
	                    var type = clockwise ? ' wa ' : ' at ';
	                    if (Math.abs(x0 - x1) < 1e-10) {
	                        // IE won't render arches drawn counter clockwise if x0 == x1.
	                        if (Math.abs(endAngle - startAngle) > 1e-2) {
	                            // Offset x0 by 1/80 of a pixel. Use something
	                            // that can be represented in binary
	                            if (clockwise) {
	                                x0 += 270 / Z;
	                            }
	                        }
	                        else {
	                            // Avoid case draw full circle
	                            if (Math.abs(y0 - cy) < 1e-10) {
	                                if ((clockwise && x0 < cx) || (!clockwise && x0 > cx)) {
	                                    y1 -= 270 / Z;
	                                }
	                                else {
	                                    y1 += 270 / Z;
	                                }
	                            }
	                            else if ((clockwise && y0 < cy) || (!clockwise && y0 > cy)) {
	                                x1 += 270 / Z;
	                            }
	                            else {
	                                x1 -= 270 / Z;
	                            }
	                        }
	                    }
	                    str.push(
	                        type,
	                        round(((cx - rx) * sx + x) * Z - Z2), comma,
	                        round(((cy - ry) * sy + y) * Z - Z2), comma,
	                        round(((cx + rx) * sx + x) * Z - Z2), comma,
	                        round(((cy + ry) * sy + y) * Z - Z2), comma,
	                        round((x0 * sx + x) * Z - Z2), comma,
	                        round((y0 * sy + y) * Z - Z2), comma,
	                        round((x1 * sx + x) * Z - Z2), comma,
	                        round((y1 * sy + y) * Z - Z2)
	                    );
	
	                    xi = x1;
	                    yi = y1;
	                    break;
	                case CMD.R:
	                    var p0 = points[0];
	                    var p1 = points[1];
	                    // x0, y0
	                    p0[0] = data[i++];
	                    p0[1] = data[i++];
	                    // x1, y1
	                    p1[0] = p0[0] + data[i++];
	                    p1[1] = p0[1] + data[i++];
	
	                    if (m) {
	                        applyTransform(p0, p0, m);
	                        applyTransform(p1, p1, m);
	                    }
	
	                    p0[0] = round(p0[0] * Z - Z2);
	                    p1[0] = round(p1[0] * Z - Z2);
	                    p0[1] = round(p0[1] * Z - Z2);
	                    p1[1] = round(p1[1] * Z - Z2);
	                    str.push(
	                        // x0, y0
	                        ' m ', p0[0], comma, p0[1],
	                        // x1, y0
	                        ' l ', p1[0], comma, p0[1],
	                        // x1, y1
	                        ' l ', p1[0], comma, p1[1],
	                        // x0, y1
	                        ' l ', p0[0], comma, p1[1]
	                    );
	                    break;
	                case CMD.Z:
	                    // FIXME Update xi, yi
	                    str.push(' x ');
	            }
	
	            if (nPoint > 0) {
	                str.push(cmdStr);
	                for (var k = 0; k < nPoint; k++) {
	                    var p = points[k];
	
	                    m && applyTransform(p, p, m);
	                    // 不 round 会非常慢
	                    str.push(
	                        round(p[0] * Z - Z2), comma, round(p[1] * Z - Z2),
	                        k < nPoint - 1 ? comma : ''
	                    );
	                }
	            }
	        }
	
	        return str.join('');
	    };
	
	    // Rewrite the original path method
	    Path.prototype.brushVML = function (vmlRoot) {
	        var style = this.style;
	
	        var vmlEl = this._vmlEl;
	        if (!vmlEl) {
	            vmlEl = vmlCore.createNode('shape');
	            initRootElStyle(vmlEl);
	
	            this._vmlEl = vmlEl;
	        }
	
	        updateFillAndStroke(vmlEl, 'fill', style, this);
	        updateFillAndStroke(vmlEl, 'stroke', style, this);
	
	        var m = this.transform;
	        var needTransform = m != null;
	        var strokeEl = vmlEl.getElementsByTagName('stroke')[0];
	        if (strokeEl) {
	            var lineWidth = style.lineWidth;
	            // Get the line scale.
	            // Determinant of this.m_ means how much the area is enlarged by the
	            // transformation. So its square root can be used as a scale factor
	            // for width.
	            if (needTransform && !style.strokeNoScale) {
	                var det = m[0] * m[3] - m[1] * m[2];
	                lineWidth *= sqrt(abs(det));
	            }
	            strokeEl.weight = lineWidth + 'px';
	        }
	
	        var path = this.path;
	        if (this.__dirtyPath) {
	            path.beginPath();
	            this.buildPath(path, this.shape);
	            path.toStatic();
	            this.__dirtyPath = false;
	        }
	
	        vmlEl.path = pathDataToString(path.data, this.transform);
	
	        vmlEl.style.zIndex = getZIndex(this.zlevel, this.z, this.z2);
	
	        // Append to root
	        append(vmlRoot, vmlEl);
	
	        // Text
	        if (style.text) {
	            this.drawRectText(vmlRoot, this.getBoundingRect());
	        }
	        else {
	            this.removeRectText(vmlRoot);
	        }
	    };
	
	    Path.prototype.onRemove = function (vmlRoot) {
	        remove(vmlRoot, this._vmlEl);
	        this.removeRectText(vmlRoot);
	    };
	
	    Path.prototype.onAdd = function (vmlRoot) {
	        append(vmlRoot, this._vmlEl);
	        this.appendRectText(vmlRoot);
	    };
	
	    /***************************************************
	     * IMAGE
	     **************************************************/
	    var isImage = function (img) {
	        // FIXME img instanceof Image 如果 img 是一个字符串的时候，IE8 下会报错
	        return (typeof img === 'object') && img.tagName && img.tagName.toUpperCase() === 'IMG';
	        // return img instanceof Image;
	    };
	
	    // Rewrite the original path method
	    ZImage.prototype.brushVML = function (vmlRoot) {
	        var style = this.style;
	        var image = style.image;
	
	        // Image original width, height
	        var ow;
	        var oh;
	
	        if (isImage(image)) {
	            var src = image.src;
	            if (src === this._imageSrc) {
	                ow = this._imageWidth;
	                oh = this._imageHeight;
	            }
	            else {
	                var imageRuntimeStyle = image.runtimeStyle;
	                var oldRuntimeWidth = imageRuntimeStyle.width;
	                var oldRuntimeHeight = imageRuntimeStyle.height;
	                imageRuntimeStyle.width = 'auto';
	                imageRuntimeStyle.height = 'auto';
	
	                // get the original size
	                ow = image.width;
	                oh = image.height;
	
	                // and remove overides
	                imageRuntimeStyle.width = oldRuntimeWidth;
	                imageRuntimeStyle.height = oldRuntimeHeight;
	
	                // Caching image original width, height and src
	                this._imageSrc = src;
	                this._imageWidth = ow;
	                this._imageHeight = oh;
	            }
	            image = src;
	        }
	        else {
	            if (image === this._imageSrc) {
	                ow = this._imageWidth;
	                oh = this._imageHeight;
	            }
	        }
	        if (!image) {
	            return;
	        }
	
	        var x = style.x || 0;
	        var y = style.y || 0;
	
	        var dw = style.width;
	        var dh = style.height;
	
	        var sw = style.sWidth;
	        var sh = style.sHeight;
	        var sx = style.sx || 0;
	        var sy = style.sy || 0;
	
	        var hasCrop = sw && sh;
	
	        var vmlEl = this._vmlEl;
	        if (!vmlEl) {
	            // FIXME 使用 group 在 left, top 都不是 0 的时候就无法显示了。
	            // vmlEl = vmlCore.createNode('group');
	            vmlEl = vmlCore.doc.createElement('div');
	            initRootElStyle(vmlEl);
	
	            this._vmlEl = vmlEl;
	        }
	
	        var vmlElStyle = vmlEl.style;
	        var hasRotation = false;
	        var m;
	        var scaleX = 1;
	        var scaleY = 1;
	        if (this.transform) {
	            m = this.transform;
	            scaleX = sqrt(m[0] * m[0] + m[1] * m[1]);
	            scaleY = sqrt(m[2] * m[2] + m[3] * m[3]);
	
	            hasRotation = m[1] || m[2];
	        }
	        if (hasRotation) {
	            // If filters are necessary (rotation exists), create them
	            // filters are bog-slow, so only create them if abbsolutely necessary
	            // The following check doesn't account for skews (which don't exist
	            // in the canvas spec (yet) anyway.
	            // From excanvas
	            var p0 = [x, y];
	            var p1 = [x + dw, y];
	            var p2 = [x, y + dh];
	            var p3 = [x + dw, y + dh];
	            applyTransform(p0, p0, m);
	            applyTransform(p1, p1, m);
	            applyTransform(p2, p2, m);
	            applyTransform(p3, p3, m);
	
	            var maxX = mathMax(p0[0], p1[0], p2[0], p3[0]);
	            var maxY = mathMax(p0[1], p1[1], p2[1], p3[1]);
	
	            var transformFilter = [];
	            transformFilter.push('M11=', m[0] / scaleX, comma,
	                        'M12=', m[2] / scaleY, comma,
	                        'M21=', m[1] / scaleX, comma,
	                        'M22=', m[3] / scaleY, comma,
	                        'Dx=', round(x * scaleX + m[4]), comma,
	                        'Dy=', round(y * scaleY + m[5]));
	
	            vmlElStyle.padding = '0 ' + round(maxX) + 'px ' + round(maxY) + 'px 0';
	            // FIXME DXImageTransform 在 IE11 的兼容模式下不起作用
	            vmlElStyle.filter = imageTransformPrefix + '.Matrix('
	                + transformFilter.join('') + ', SizingMethod=clip)';
	
	        }
	        else {
	            if (m) {
	                x = x * scaleX + m[4];
	                y = y * scaleY + m[5];
	            }
	            vmlElStyle.filter = '';
	            vmlElStyle.left = round(x) + 'px';
	            vmlElStyle.top = round(y) + 'px';
	        }
	
	        var imageEl = this._imageEl;
	        var cropEl = this._cropEl;
	
	        if (!imageEl) {
	            imageEl = vmlCore.doc.createElement('div');
	            this._imageEl = imageEl;
	        }
	        var imageELStyle = imageEl.style;
	        if (hasCrop) {
	            // Needs know image original width and height
	            if (! (ow && oh)) {
	                var tmpImage = new Image();
	                var self = this;
	                tmpImage.onload = function () {
	                    tmpImage.onload = null;
	                    ow = tmpImage.width;
	                    oh = tmpImage.height;
	                    // Adjust image width and height to fit the ratio destinationSize / sourceSize
	                    imageELStyle.width = round(scaleX * ow * dw / sw) + 'px';
	                    imageELStyle.height = round(scaleY * oh * dh / sh) + 'px';
	
	                    // Caching image original width, height and src
	                    self._imageWidth = ow;
	                    self._imageHeight = oh;
	                    self._imageSrc = image;
	                };
	                tmpImage.src = image;
	            }
	            else {
	                imageELStyle.width = round(scaleX * ow * dw / sw) + 'px';
	                imageELStyle.height = round(scaleY * oh * dh / sh) + 'px';
	            }
	
	            if (! cropEl) {
	                cropEl = vmlCore.doc.createElement('div');
	                cropEl.style.overflow = 'hidden';
	                this._cropEl = cropEl;
	            }
	            var cropElStyle = cropEl.style;
	            cropElStyle.width = round((dw + sx * dw / sw) * scaleX);
	            cropElStyle.height = round((dh + sy * dh / sh) * scaleY);
	            cropElStyle.filter = imageTransformPrefix + '.Matrix(Dx='
	                    + (-sx * dw / sw * scaleX) + ',Dy=' + (-sy * dh / sh * scaleY) + ')';
	
	            if (! cropEl.parentNode) {
	                vmlEl.appendChild(cropEl);
	            }
	            if (imageEl.parentNode != cropEl) {
	                cropEl.appendChild(imageEl);
	            }
	        }
	        else {
	            imageELStyle.width = round(scaleX * dw) + 'px';
	            imageELStyle.height = round(scaleY * dh) + 'px';
	
	            vmlEl.appendChild(imageEl);
	
	            if (cropEl && cropEl.parentNode) {
	                vmlEl.removeChild(cropEl);
	                this._cropEl = null;
	            }
	        }
	
	        var filterStr = '';
	        var alpha = style.opacity;
	        if (alpha < 1) {
	            filterStr += '.Alpha(opacity=' + round(alpha * 100) + ') ';
	        }
	        filterStr += imageTransformPrefix + '.AlphaImageLoader(src=' + image + ', SizingMethod=scale)';
	
	        imageELStyle.filter = filterStr;
	
	        vmlEl.style.zIndex = getZIndex(this.zlevel, this.z, this.z2);
	
	        // Append to root
	        append(vmlRoot, vmlEl);
	
	        // Text
	        if (style.text) {
	            this.drawRectText(vmlRoot, this.getBoundingRect());
	        }
	    };
	
	    ZImage.prototype.onRemove = function (vmlRoot) {
	        remove(vmlRoot, this._vmlEl);
	
	        this._vmlEl = null;
	        this._cropEl = null;
	        this._imageEl = null;
	
	        this.removeRectText(vmlRoot);
	    };
	
	    ZImage.prototype.onAdd = function (vmlRoot) {
	        append(vmlRoot, this._vmlEl);
	        this.appendRectText(vmlRoot);
	    };
	
	
	    /***************************************************
	     * TEXT
	     **************************************************/
	
	    var DEFAULT_STYLE_NORMAL = 'normal';
	
	    var fontStyleCache = {};
	    var fontStyleCacheCount = 0;
	    var MAX_FONT_CACHE_SIZE = 100;
	    var fontEl = document.createElement('div');
	
	    var getFontStyle = function (fontString) {
	        var fontStyle = fontStyleCache[fontString];
	        if (!fontStyle) {
	            // Clear cache
	            if (fontStyleCacheCount > MAX_FONT_CACHE_SIZE) {
	                fontStyleCacheCount = 0;
	                fontStyleCache = {};
	            }
	
	            var style = fontEl.style;
	            var fontFamily;
	            try {
	                style.font = fontString;
	                fontFamily = style.fontFamily.split(',')[0];
	            }
	            catch (e) {
	            }
	
	            fontStyle = {
	                style: style.fontStyle || DEFAULT_STYLE_NORMAL,
	                variant: style.fontVariant || DEFAULT_STYLE_NORMAL,
	                weight: style.fontWeight || DEFAULT_STYLE_NORMAL,
	                size: parseFloat(style.fontSize || 12) | 0,
	                family: fontFamily || 'Microsoft YaHei'
	            };
	
	            fontStyleCache[fontString] = fontStyle;
	            fontStyleCacheCount++;
	        }
	        return fontStyle;
	    };
	
	    var textMeasureEl;
	    // Overwrite measure text method
	    textContain.measureText = function (text, textFont) {
	        var doc = vmlCore.doc;
	        if (!textMeasureEl) {
	            textMeasureEl = doc.createElement('div');
	            textMeasureEl.style.cssText = 'position:absolute;top:-20000px;left:0;'
	                + 'padding:0;margin:0;border:none;white-space:pre;';
	            vmlCore.doc.body.appendChild(textMeasureEl);
	        }
	
	        try {
	            textMeasureEl.style.font = textFont;
	        } catch (ex) {
	            // Ignore failures to set to invalid font.
	        }
	        textMeasureEl.innerHTML = '';
	        // Don't use innerHTML or innerText because they allow markup/whitespace.
	        textMeasureEl.appendChild(doc.createTextNode(text));
	        return {
	            width: textMeasureEl.offsetWidth
	        };
	    };
	
	    var tmpRect = new BoundingRect();
	
	    var drawRectText = function (vmlRoot, rect, textRect, fromTextEl) {
	
	        var style = this.style;
	        var text = style.text;
	        if (!text) {
	            return;
	        }
	
	        var x;
	        var y;
	        var align = style.textAlign;
	        var fontStyle = getFontStyle(style.textFont);
	        // FIXME encodeHtmlAttribute ?
	        var font = fontStyle.style + ' ' + fontStyle.variant + ' ' + fontStyle.weight + ' '
	            + fontStyle.size + 'px "' + fontStyle.family + '"';
	
	        var baseline = style.textBaseline;
	        var verticalAlign = style.textVerticalAlign;
	
	        textRect = textRect || textContain.getBoundingRect(text, font, align, baseline);
	
	        // Transform rect to view space
	        var m = this.transform;
	        // Ignore transform for text in other element
	        if (m && !fromTextEl) {
	            tmpRect.copy(rect);
	            tmpRect.applyTransform(m);
	            rect = tmpRect;
	        }
	
	        if (!fromTextEl) {
	            var textPosition = style.textPosition;
	            var distance = style.textDistance;
	            // Text position represented by coord
	            if (textPosition instanceof Array) {
	                x = rect.x + parsePercent(textPosition[0], rect.width);
	                y = rect.y + parsePercent(textPosition[1], rect.height);
	
	                align = align || 'left';
	                baseline = baseline || 'top';
	            }
	            else {
	                var res = textContain.adjustTextPositionOnRect(
	                    textPosition, rect, textRect, distance
	                );
	                x = res.x;
	                y = res.y;
	
	                // Default align and baseline when has textPosition
	                align = align || res.textAlign;
	                baseline = baseline || res.textBaseline;
	            }
	        }
	        else {
	            x = rect.x;
	            y = rect.y;
	        }
	        if (verticalAlign) {
	            switch (verticalAlign) {
	                case 'middle':
	                    y -= textRect.height / 2;
	                    break;
	                case 'bottom':
	                    y -= textRect.height;
	                    break;
	                // 'top'
	            }
	            // Ignore baseline
	            baseline = 'top';
	        }
	
	        var fontSize = fontStyle.size;
	        // 1.75 is an arbitrary number, as there is no info about the text baseline
	        switch (baseline) {
	            case 'hanging':
	            case 'top':
	                y += fontSize / 1.75;
	                break;
	            case 'middle':
	                break;
	            default:
	            // case null:
	            // case 'alphabetic':
	            // case 'ideographic':
	            // case 'bottom':
	                y -= fontSize / 2.25;
	                break;
	        }
	        switch (align) {
	            case 'left':
	                break;
	            case 'center':
	                x -= textRect.width / 2;
	                break;
	            case 'right':
	                x -= textRect.width;
	                break;
	            // case 'end':
	                // align = elementStyle.direction == 'ltr' ? 'right' : 'left';
	                // break;
	            // case 'start':
	                // align = elementStyle.direction == 'rtl' ? 'right' : 'left';
	                // break;
	            // default:
	            //     align = 'left';
	        }
	
	        var createNode = vmlCore.createNode;
	
	        var textVmlEl = this._textVmlEl;
	        var pathEl;
	        var textPathEl;
	        var skewEl;
	        if (!textVmlEl) {
	            textVmlEl = createNode('line');
	            pathEl = createNode('path');
	            textPathEl = createNode('textpath');
	            skewEl = createNode('skew');
	
	            // FIXME Why here is not cammel case
	            // Align 'center' seems wrong
	            textPathEl.style['v-text-align'] = 'left';
	
	            initRootElStyle(textVmlEl);
	
	            pathEl.textpathok = true;
	            textPathEl.on = true;
	
	            textVmlEl.from = '0 0';
	            textVmlEl.to = '1000 0.05';
	
	            append(textVmlEl, skewEl);
	            append(textVmlEl, pathEl);
	            append(textVmlEl, textPathEl);
	
	            this._textVmlEl = textVmlEl;
	        }
	        else {
	            // 这里是在前面 appendChild 保证顺序的前提下
	            skewEl = textVmlEl.firstChild;
	            pathEl = skewEl.nextSibling;
	            textPathEl = pathEl.nextSibling;
	        }
	
	        var coords = [x, y];
	        var textVmlElStyle = textVmlEl.style;
	        // Ignore transform for text in other element
	        if (m && fromTextEl) {
	            applyTransform(coords, coords, m);
	
	            skewEl.on = true;
	
	            skewEl.matrix = m[0].toFixed(3) + comma + m[2].toFixed(3) + comma +
	            m[1].toFixed(3) + comma + m[3].toFixed(3) + ',0,0';
	
	            // Text position
	            skewEl.offset = (round(coords[0]) || 0) + ',' + (round(coords[1]) || 0);
	            // Left top point as origin
	            skewEl.origin = '0 0';
	
	            textVmlElStyle.left = '0px';
	            textVmlElStyle.top = '0px';
	        }
	        else {
	            skewEl.on = false;
	            textVmlElStyle.left = round(x) + 'px';
	            textVmlElStyle.top = round(y) + 'px';
	        }
	
	        textPathEl.string = encodeHtmlAttribute(text);
	        // TODO
	        try {
	            textPathEl.style.font = font;
	        }
	        // Error font format
	        catch (e) {}
	
	        updateFillAndStroke(textVmlEl, 'fill', {
	            fill: fromTextEl ? style.fill : style.textFill,
	            opacity: style.opacity
	        }, this);
	        updateFillAndStroke(textVmlEl, 'stroke', {
	            stroke: fromTextEl ? style.stroke : style.textStroke,
	            opacity: style.opacity,
	            lineDash: style.lineDash
	        }, this);
	
	        textVmlEl.style.zIndex = getZIndex(this.zlevel, this.z, this.z2);
	
	        // Attached to root
	        append(vmlRoot, textVmlEl);
	    };
	
	    var removeRectText = function (vmlRoot) {
	        remove(vmlRoot, this._textVmlEl);
	        this._textVmlEl = null;
	    };
	
	    var appendRectText = function (vmlRoot) {
	        append(vmlRoot, this._textVmlEl);
	    };
	
	    var list = [RectText, Displayable, ZImage, Path, Text];
	
	    // In case Displayable has been mixed in RectText
	    for (var i = 0; i < list.length; i++) {
	        var proto = list[i].prototype;
	        proto.drawRectText = drawRectText;
	        proto.removeRectText = removeRectText;
	        proto.appendRectText = appendRectText;
	    }
	
	    Text.prototype.brushVML = function (vmlRoot) {
	        var style = this.style;
	        if (style.text) {
	            this.drawRectText(vmlRoot, {
	                x: style.x || 0, y: style.y || 0,
	                width: 0, height: 0
	            }, this.getBoundingRect(), true);
	        }
	        else {
	            this.removeRectText(vmlRoot);
	        }
	    };
	
	    Text.prototype.onRemove = function (vmlRoot) {
	        this.removeRectText(vmlRoot);
	    };
	
	    Text.prototype.onAdd = function (vmlRoot) {
	        this.appendRectText(vmlRoot);
	    };
	}


/***/ },
/* 119 */
/***/ function(module, exports, __webpack_require__) {

	
	
	if (!__webpack_require__(60).canvasSupported) {
	    var urn = 'urn:schemas-microsoft-com:vml';
	
	    var createNode;
	    var win = window;
	    var doc = win.document;
	
	    var vmlInited = false;
	
	    try {
	        !doc.namespaces.zrvml && doc.namespaces.add('zrvml', urn);
	        createNode = function (tagName) {
	            return doc.createElement('<zrvml:' + tagName + ' class="zrvml">');
	        };
	    }
	    catch (e) {
	        createNode = function (tagName) {
	            return doc.createElement('<' + tagName + ' xmlns="' + urn + '" class="zrvml">');
	        };
	    }
	
	    // From raphael
	    var initVML = function () {
	        if (vmlInited) {
	            return;
	        }
	        vmlInited = true;
	
	        var styleSheets = doc.styleSheets;
	        if (styleSheets.length < 31) {
	            doc.createStyleSheet().addRule('.zrvml', 'behavior:url(#default#VML)');
	        }
	        else {
	            // http://msdn.microsoft.com/en-us/library/ms531194%28VS.85%29.aspx
	            styleSheets[0].addRule('.zrvml', 'behavior:url(#default#VML)');
	        }
	    };
	
	    // Not useing return to avoid error when converting to CommonJS module
	    module.exports = {
	        doc: doc,
	        initVML: initVML,
	        createNode: createNode
	    };
	}


/***/ },
/* 120 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * VML Painter.
	 *
	 * @module zrender/vml/Painter
	 */
	
	
	
	    var zrLog = __webpack_require__(20);
	    var vmlCore = __webpack_require__(119);
	
	    function parseInt10(val) {
	        return parseInt(val, 10);
	    }
	
	    /**
	     * @alias module:zrender/vml/Painter
	     */
	    function VMLPainter(root, storage) {
	
	        vmlCore.initVML();
	
	        this.root = root;
	
	        this.storage = storage;
	
	        var vmlViewport = document.createElement('div');
	
	        var vmlRoot = document.createElement('div');
	
	        vmlViewport.style.cssText = 'display:inline-block;overflow:hidden;position:relative;width:300px;height:150px;';
	
	        vmlRoot.style.cssText = 'position:absolute;left:0;top:0;';
	
	        root.appendChild(vmlViewport);
	
	        this._vmlRoot = vmlRoot;
	        this._vmlViewport = vmlViewport;
	
	        this.resize();
	
	        // Modify storage
	        var oldDelFromMap = storage.delFromMap;
	        var oldAddToMap = storage.addToMap;
	        storage.delFromMap = function (elId) {
	            var el = storage.get(elId);
	
	            oldDelFromMap.call(storage, elId);
	
	            if (el) {
	                el.onRemove && el.onRemove(vmlRoot);
	            }
	        };
	
	        storage.addToMap = function (el) {
	            // Displayable already has a vml node
	            el.onAdd && el.onAdd(vmlRoot);
	
	            oldAddToMap.call(storage, el);
	        };
	
	        this._firstPaint = true;
	    }
	
	    VMLPainter.prototype = {
	
	        constructor: VMLPainter,
	
	        /**
	         * @return {HTMLDivElement}
	         */
	        getViewportRoot: function () {
	            return this._vmlViewport;
	        },
	
	        /**
	         * 刷新
	         */
	        refresh: function () {
	
	            var list = this.storage.getDisplayList(true, true);
	
	            this._paintList(list);
	        },
	
	        _paintList: function (list) {
	            var vmlRoot = this._vmlRoot;
	            for (var i = 0; i < list.length; i++) {
	                var el = list[i];
	                if (el.invisible || el.ignore) {
	                    if (!el.__alreadyNotVisible) {
	                        el.onRemove(vmlRoot);
	                    }
	                    // Set as already invisible
	                    el.__alreadyNotVisible = true;
	                }
	                else {
	                    if (el.__alreadyNotVisible) {
	                        el.onAdd(vmlRoot);
	                    }
	                    el.__alreadyNotVisible = false;
	                    if (el.__dirty) {
	                        el.beforeBrush && el.beforeBrush();
	                        (el.brushVML || el.brush).call(el, vmlRoot);
	                        el.afterBrush && el.afterBrush();
	                    }
	                }
	                el.__dirty = false;
	            }
	
	            if (this._firstPaint) {
	                // Detached from document at first time
	                // to avoid page refreshing too many times
	
	                // FIXME 如果每次都先 removeChild 可能会导致一些填充和描边的效果改变
	                this._vmlViewport.appendChild(vmlRoot);
	                this._firstPaint = false;
	            }
	        },
	
	        resize: function () {
	            var width = this._getWidth();
	            var height = this._getHeight();
	
	            if (this._width != width && this._height != height) {
	                this._width = width;
	                this._height = height;
	
	                var vmlViewportStyle = this._vmlViewport.style;
	                vmlViewportStyle.width = width + 'px';
	                vmlViewportStyle.height = height + 'px';
	            }
	        },
	
	        dispose: function () {
	            this.root.innerHTML = '';
	
	            this._vmlRoot =
	            this._vmlViewport =
	            this.storage = null;
	        },
	
	        getWidth: function () {
	            return this._width;
	        },
	
	        getHeight: function () {
	            return this._height;
	        },
	
	        clear: function () {
	            this.root.removeChild(this.vmlViewport);
	        },
	
	        _getWidth: function () {
	            var root = this.root;
	            var stl = root.currentStyle;
	
	            return ((root.clientWidth || parseInt10(stl.width))
	                    - parseInt10(stl.paddingLeft)
	                    - parseInt10(stl.paddingRight)) | 0;
	        },
	
	        _getHeight: function () {
	            var root = this.root;
	            var stl = root.currentStyle;
	
	            return ((root.clientHeight || parseInt10(stl.height))
	                    - parseInt10(stl.paddingTop)
	                    - parseInt10(stl.paddingBottom)) | 0;
	        }
	    };
	
	    // Not supported methods
	    function createMethodNotSupport(method) {
	        return function () {
	            zrLog('In IE8.0 VML mode painter not support method "' + method + '"');
	        };
	    }
	
	    var notSupportedMethods = [
	        'getLayer', 'insertLayer', 'eachLayer', 'eachBuildinLayer', 'eachOtherLayer', 'getLayers',
	        'modLayer', 'delLayer', 'clearLayer', 'toDataURL', 'pathToImage'
	    ];
	
	    for (var i = 0; i < notSupportedMethods.length; i++) {
	        var name = notSupportedMethods[i];
	        VMLPainter.prototype[name] = createMethodNotSupport(name);
	    }
	
	    module.exports = VMLPainter;


/***/ }
/******/ ])
});
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwid2VicGFjazovLy93ZWJwYWNrL2Jvb3RzdHJhcCBmYWZhYzA5ZGNkNjBlNDNhYmNhMCIsIndlYnBhY2s6Ly8vLi9pbmRleC5uZXR3b3JrLmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tbmV0d29yay9saWIvRmlzaFRvcG9OZXR3b3JrLmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tY29yZS9saWIvZ3JhcGhpYy5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2NvcmUvdXRpbC5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL3Rvb2wvcGF0aC5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvUGF0aC5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvRGlzcGxheWFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9ncmFwaGljL1N0eWxlLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvRWxlbWVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2NvcmUvZ3VpZC5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL21peGluL0V2ZW50ZnVsLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvbWl4aW4vVHJhbnNmb3JtYWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2NvcmUvbWF0cml4LmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvY29yZS92ZWN0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9taXhpbi9BbmltYXRhYmxlLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvYW5pbWF0aW9uL0FuaW1hdG9yLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvYW5pbWF0aW9uL0NsaXAuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9hbmltYXRpb24vZWFzaW5nLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvdG9vbC9jb2xvci5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2NvcmUvbG9nLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvY29uZmlnLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvZ3JhcGhpYy9taXhpbi9SZWN0VGV4dC5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2NvbnRhaW4vdGV4dC5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2NvcmUvQm91bmRpbmdSZWN0LmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvY29yZS9QYXRoUHJveHkuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9jb3JlL2N1cnZlLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvY29yZS9iYm94LmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvY29udGFpbi9wYXRoLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvY29udGFpbi9saW5lLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvY29udGFpbi9jdWJpYy5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2NvbnRhaW4vcXVhZHJhdGljLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvY29udGFpbi9hcmMuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9jb250YWluL3V0aWwuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9jb250YWluL3dpbmRpbmdMaW5lLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvZ3JhcGhpYy9QYXR0ZXJuLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvdG9vbC90cmFuc2Zvcm1QYXRoLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvZ3JhcGhpYy9HcmFkaWVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL21peGluL0RyYWdnYWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2NvbnRhaW5lci9Hcm91cC5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvSW1hZ2UuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9jb3JlL0xSVS5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvVGV4dC5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvQ2lyY2xlLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9TZWN0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL1JpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL1BvbHlnb24uanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9ncmFwaGljL2hlbHBlci9wb2x5LmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvZ3JhcGhpYy9oZWxwZXIvc21vb3RoU3BsaW5lLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvZ3JhcGhpYy9oZWxwZXIvc21vb3RoQmV6aWVyLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9Qb2x5bGluZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvUmVjdC5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvaGVscGVyL3JvdW5kUmVjdC5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvTGluZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvQmV6aWVyQ3VydmUuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL0FyYy5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvTGluZWFyR3JhZGllbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9ncmFwaGljL1JhZGlhbEdyYWRpZW50LmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tbmV0d29yay9saWIvRXh0ZW5zaW9uQVBJLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvenJlbmRlci5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2NvcmUvZW52LmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvSGFuZGxlci5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL1N0b3JhZ2UuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9jb3JlL3RpbXNvcnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9hbmltYXRpb24vQW5pbWF0aW9uLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvY29yZS9ldmVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2FuaW1hdGlvbi9yZXF1ZXN0QW5pbWF0aW9uRnJhbWUuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9kb20vSGFuZGxlclByb3h5LmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvY29yZS9HZXN0dXJlTWdyLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvUGFpbnRlci5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL0xheWVyLmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tY29yZS9saWIvdXRpbC5qcyIsIndlYnBhY2s6Ly8vLi9saWIvZmlzaC10b3BvLWNvcmUvbGliL1BvaW50LmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tY29yZS9saWIvTGluZVN0cnVjdC5qcyIsIndlYnBhY2s6Ly8vLi9saWIvZmlzaC10b3BvLW5ldHdvcmsvbGliL21vZGVsL05ldHdvcmtNb2RlbC5qcyIsIndlYnBhY2s6Ly8vLi9saWIvZmlzaC10b3BvLWNvcmUvbGliL01vZGVsLmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tY29yZS9saWIvY2xhenouanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1uZXR3b3JrL2xpYi9ub2RlL05ldHdvcmtOb2RlLmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tY29yZS9saWIvTm9kZS5qcyIsIndlYnBhY2s6Ly8vLi9saWIvZmlzaC10b3BvLW5ldHdvcmsvbGliL25vZGUvcmFjay9SYWNrTm9kZS5qcyIsIndlYnBhY2s6Ly8vLi9saWIvZmlzaC10b3BvLW5ldHdvcmsvbGliL05ldHdvcmtVdGlsLmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tbmV0d29yay9saWIvbm9kZS9UaXBXaW5kb3dOb2RlLmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tbmV0d29yay9saWIvbm9kZS9yYWNrL1NlcnZlck5vZGUuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1uZXR3b3JrL2xpYi9ub2RlL3JhY2svU3dpdGNoTm9kZS5qcyIsIndlYnBhY2s6Ly8vLi9saWIvZmlzaC10b3BvLW5ldHdvcmsvbGliL25vZGUvcmFjay9FbXB0eUZsb29yTm9kZS5qcyIsIndlYnBhY2s6Ly8vLi9saWIvZmlzaC10b3BvLW5ldHdvcmsvbGliL25vZGUvdG9wby9Qb2ludE5vZGUuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1uZXR3b3JrL2xpYi9ub2RlL3RvcG8vQ2FyZE5vZGUuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1uZXR3b3JrL2xpYi9ub2RlL3RvcG8vVG9wb0RyYXdOb2RlLmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tbmV0d29yay9saWIvbm9kZS9OZXRXb3JrTGluZU5vZGUuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1jb3JlL2xpYi9zaGFwZXMvQ29ubmVjdG9yLmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tY29yZS9saWIvc2hhcGVzL1N5bWJvbC5qcyIsIndlYnBhY2s6Ly8vLi9saWIvZmlzaC10b3BvLWNvcmUvbGliL3NoYXBlcy9IYW5kbGUuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1jb3JlL2xpYi9zaGFwZXMvRWZmZWN0TGluZS5qcyIsIndlYnBhY2s6Ly8vLi9saWIvZmlzaC10b3BvLWNvcmUvbGliL3NoYXBlcy9Db25uZWN0aW9uUG9pbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1uZXR3b3JrL2xpYi9tb2RlbC9OZXRXb3JrTGluZU1vZGVsLmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tbmV0d29yay9saWIvbm9kZS90b3BvL1NlcnZlclRvcG9Ob2RlLmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tbmV0d29yay9saWIvbm9kZS90b3BvL1NlcnZlclI2MzBOb2RlLmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tbmV0d29yay9saWIvbm9kZS90b3BvL1NlcnZlclI3MzBOb2RlLmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tbmV0d29yay9saWIvbW9kZWwvdG9wby9DYXJkTW9kZWwuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1uZXR3b3JrL2xpYi9ub2RlL3RvcG8vU2VydmVyWDM1NTBOb2RlLmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tbmV0d29yay9saWIvbm9kZS90b3BvL1NlcnZlclgzNjUwTm9kZS5qcyIsIndlYnBhY2s6Ly8vLi9saWIvZmlzaC10b3BvLW5ldHdvcmsvbGliL25vZGUvdG9wby9TZXJ2ZXJSRDM1ME5vZGUuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1uZXR3b3JrL2xpYi9ub2RlL3RvcG8vU2VydmVyUkQ2NTBOb2RlLmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tbmV0d29yay9saWIvbm9kZS90b3BvL1N3aXRjaFRvcG9Ob2RlLmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tbmV0d29yay9saWIvbm9kZS90b3BvL1N3aXRjaEhhbGZJQk5vZGUuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1uZXR3b3JrL2xpYi9ub2RlL3RvcG8vU3dpdGNoRnVsbElCTm9kZS5qcyIsIndlYnBhY2s6Ly8vLi9saWIvZmlzaC10b3BvLW5ldHdvcmsvbGliL25vZGUvdG9wby9Td2l0Y2hHTU5vZGUuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1uZXR3b3JrL2xpYi9ub2RlL3RvcG8vU3dpdGNoS01Ob2RlLmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tbmV0d29yay9saWIvbm9kZS9jbHVzdGVyL0NsdXN0ZXJEcmF3Tm9kZS5qcyIsIndlYnBhY2s6Ly8vLi9saWIvZmlzaC10b3BvLW5ldHdvcmsvbGliL21vZGVsL2NsdXN0ZXIvRGF0YWJhc2VNb2RlbC5qcyIsIndlYnBhY2s6Ly8vLi9saWIvZmlzaC10b3BvLW5ldHdvcmsvbGliL21vZGVsL2NsdXN0ZXIvQXNtTW9kZWwuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1uZXR3b3JrL2xpYi9tb2RlbC9jbHVzdGVyL0lTRU1vZGVsLmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tbmV0d29yay9saWIvbm9kZS9jbHVzdGVyL0NsdXN0ZXJEYXRhYmFzZU5vZGUuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1uZXR3b3JrL2xpYi9ub2RlL2NsdXN0ZXIvQ2x1c3RlckFzbU5vZGUuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1uZXR3b3JrL2xpYi9ub2RlL2NsdXN0ZXIvQ2x1c3RlckFzbUNlbGxOb2RlLmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tbmV0d29yay9saWIvbm9kZS9jbHVzdGVyL0NsdXN0ZXJJc2VOb2RlLmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tbmV0d29yay9saWIvbm9kZS9jbHVzdGVyL0NsdXN0ZXJJc2VDZWxsTm9kZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL3ZtbC92bWwuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi92bWwvZ3JhcGhpYy5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL3ZtbC9jb3JlLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvdm1sL1BhaW50ZXIuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELE87QUNWQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1QkFBZTtBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7OztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBLG1CQUFrQjtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxtQkFBa0I7QUFDbEI7QUFDQTtBQUNBLHFDOztBQUVBO0FBQ0E7QUFDQSwrQztBQUNBLFU7QUFDQTs7QUFFQTs7QUFFQSw4RUFBNkUsYUFBYSxlQUFlO0FBQ3pHOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7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ZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGlCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsaUJBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxTQUFTO0FBQ3hCLGlCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FB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QTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW1CLGVBQWU7QUFDbEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBbUIsZ0JBQWdCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDRCQUEyQixjQUFjO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0EscUJBQW9CLE9BQU87QUFDM0IscUJBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBMkIsU0FBUztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7OztBQ2paQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBLHlEQUF3RDs7QUFFeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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Q0Esb0JBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdDQUErQixTQUFTO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBLG9CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdDQUErQixTQUFTO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBYztBQUNkO0FBQ0E7O0FBRUE7Ozs7Ozs7O0FDdlNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZSxVQUFVO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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VDtBQUNBO0FBQ0Esb0JBQW1CLFFBQVE7QUFDM0Isb0JBQW1CLE9BQU87QUFDMUIsb0JBQW1CLE9BQU87QUFDMUIscUJBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBLG9CQUFtQixRQUFRO0FBQzNCLG9CQUFtQixRQUFRO0FBQzNCLG9CQUFtQixRQUFRO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQSxvQkFBbUIsUUFBUTtBQUMzQixvQkFBbUIsUUFBUTtBQUMzQixvQkFBbUIsUUFBUTtBQUMzQixvQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0Esb0JBQW1CLFFBQVE7QUFDM0Isb0JBQW1CLFFBQVE7QUFDM0Isb0JBQW1CLFFBQVE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBLG9CQUFtQixRQUFRO0FBQzNCLHFCQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQSxvQkFBbUIsUUFBUTtBQUMzQixxQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0Esb0JBQW1CLFFBQVE7QUFDM0Isb0JBQW1CLFFBQVE7QUFDM0Isb0JBQW1CLFFBQVE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBLG9CQUFtQixRQUFRO0FBQzNCLG9CQUFtQixRQUFRO0FBQzNCLG9CQUFtQixRQUFRO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQSxvQkFBbUIsUUFBUTtBQUMzQixvQkFBbUIsUUFBUTtBQUMzQixxQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0Esb0JBQW1CLFFBQVE7QUFDM0Isb0JBQW1CLFFBQVE7QUFDM0Isb0JBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBLG9CQUFtQixRQUFRO0FBQzNCLG9CQUFtQixRQUFRO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBLG9CQUFtQixRQUFRO0FBQzNCLG9CQUFtQixRQUFRO0FBQzNCLHFCQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQSxvQkFBbUIsUUFBUTtBQUMzQixvQkFBbUIsUUFBUTtBQUMzQixxQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQSxvQkFBbUIsUUFBUTtBQUMzQixvQkFBbUIsUUFBUTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0Esb0JBQW1CLFFBQVE7QUFDM0Isb0JBQW1CLFFBQVE7QUFDM0Isb0JBQW1CLFFBQVE7QUFDM0Isb0JBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBLG9CQUFtQixRQUFRO0FBQzNCLG9CQUFtQixRQUFRO0FBQzNCLG9CQUFtQixRQUFRO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxxQkFBb0IsUUFBUTtBQUM1QixxQkFBb0IsUUFBUTtBQUM1QixxQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxxQkFBb0IsUUFBUTtBQUM1QixxQkFBb0IsUUFBUTtBQUM1QixxQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7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QjtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQSxtQkFBa0IsT0FBTztBQUN6QixvQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0EsbUJBQWtCLE9BQU87QUFDekIsb0JBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBLG1CQUFrQixPQUFPO0FBQ3pCLG9CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQSxtQkFBa0IsT0FBTztBQUN6QixvQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0EsbUJBQWtCLE9BQU87QUFDekIsb0JBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBLG1CQUFrQixPQUFPO0FBQ3pCLG9CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQSxtQkFBa0IsT0FBTztBQUN6QixvQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0EsbUJBQWtCLE9BQU87QUFDekIsb0JBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBLG1CQUFrQixPQUFPO0FBQ3pCLG9CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQSxtQkFBa0IsT0FBTztBQUN6QixvQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0EsbUJBQWtCLE9BQU87QUFDekIsb0JBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBLG1CQUFrQixPQUFPO0FBQ3pCLG9CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQSxtQkFBa0IsT0FBTztBQUN6QixvQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRCQUEyQixzQkFBc0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOzs7Ozs7Ozs7QUM1SUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsOENBQTZDLE9BQU87QUFDcEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBZ0IsT0FBTztBQUN2QixpQkFBZ0IsT0FBTztBQUN2QixpQkFBZ0IsT0FBTztBQUN2QixpQkFBZ0IsT0FBTztBQUN2QixpQkFBZ0IsT0FBTztBQUN2QixpQkFBZ0IsT0FBTztBQUN2QixpQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0EsaUJBQWdCLE9BQU87QUFDdkIsaUJBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDZFQUE0RTtBQUM1RSx3QkFBdUIsNkNBQTZDO0FBQ3BFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxnREFBK0MsU0FBUztBQUN4RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw2QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBbUMsaUNBQWlDO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDbFJBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxtQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0EsbUJBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLG1CQUFrQjtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxvQkFBbUIsaUNBQWlDO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBLG9CQUFtQixlQUFlO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBLHFCQUFvQixpQ0FBaUM7QUFDckQscUJBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFTOztBQUVUO0FBQ0Esb0JBQW1CLDBDQUEwQztBQUM3RCxxQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQSxxQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ3hKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFrQjtBQUNsQjtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWdCO0FBQ2hCO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBLHFCQUFvQix5QkFBeUI7QUFDN0MscUJBQW9CO0FBQ3BCO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxVQUFTOztBQUVUO0FBQ0EscUJBQW9CLE9BQU87QUFDM0IscUJBQW9CLE9BQU87QUFDM0IscUJBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQSxxQkFBb0IsT0FBTztBQUMzQixxQkFBb0IsT0FBTztBQUMzQixxQkFBb0IsT0FBTztBQUMzQixxQkFBb0IsT0FBTztBQUMzQixxQkFBb0IsT0FBTztBQUMzQixxQkFBb0IsT0FBTztBQUMzQixxQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0EscUJBQW9CLE9BQU87QUFDM0IscUJBQW9CLE9BQU87QUFDM0IscUJBQW9CLE9BQU87QUFDM0IscUJBQW9CLE9BQU87QUFDM0IscUJBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQixRQUFRO0FBQzVCLHFCQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0EscUJBQW9CO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLG9CQUFtQix5QkFBeUI7QUFDNUMscUJBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBLG9CQUFtQix5QkFBeUI7QUFDNUMscUJBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxxQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxnQ0FBK0IscUJBQXFCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLHFCQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBLHFCQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw0QkFBMkIsU0FBUztBQUNwQztBQUNBOztBQUVBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0Esb0JBQW1CLG9FQUFvRTtBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTJCLFNBQVM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUEyQixTQUFTO0FBQ3BDO0FBQ0EsZ0NBQStCLDJCQUEyQjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTJCLHNCQUFzQjtBQUNqRDtBQUNBOztBQUVBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUErQixlQUFlO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0EscUJBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXVCLE9BQU87QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQWtCLGFBQWE7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0EscUJBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNEJBQTJCLGlCQUFpQjtBQUM1Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLG9CQUFtQix1QkFBdUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTJCLFNBQVM7QUFDcEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOzs7Ozs7O0FDaHdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWdCLE9BQU87QUFDdkIsaUJBQWdCLE9BQU87QUFDdkIsaUJBQWdCLE9BQU87QUFDdkIsaUJBQWdCLE9BQU87QUFDdkIsaUJBQWdCLE9BQU87QUFDdkIsaUJBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBZ0IsT0FBTztBQUN2QixpQkFBZ0IsT0FBTztBQUN2QixpQkFBZ0IsT0FBTztBQUN2QixpQkFBZ0IsT0FBTztBQUN2QixpQkFBZ0IsT0FBTztBQUN2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T0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLGVBQWU7QUFDOUIsZ0JBQWUsZUFBZTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsZUFBZTtBQUM5QixnQkFBZSxlQUFlO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsZUFBZTtBQUM5QixnQkFBZSxlQUFlO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNEJBQTJCLGtCQUFrQjtBQUM3QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7QUNwT0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUEyQixZQUFZO0FBQ3ZDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSw4QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUErQixZQUFZO0FBQzNDO0FBQ0E7O0FBRUE7QUFDQSxrQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdCQUF1QixPQUFPO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdCQUF1QixpQkFBaUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUM5WUE7QUFDQTtBQUNBO0FBQ0EscUJBQW9CLE9BQU87QUFDM0IscUJBQW9CLE9BQU87QUFDM0IscUJBQW9CLE9BQU87QUFDM0IscUJBQW9CLE9BQU87QUFDM0IscUJBQW9CLE9BQU87QUFDM0IscUJBQW9CLE9BQU87QUFDM0IscUJBQW9CLE9BQU87QUFDM0IscUJBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUN2Q0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUJBQW9CLE9BQU87QUFDM0IscUJBQW9CLE9BQU87QUFDM0IscUJBQW9CLE9BQU87QUFDM0IscUJBQW9CLE9BQU87QUFDM0IscUJBQW9CLE9BQU87QUFDM0IscUJBQW9CLE9BQU87QUFDM0IscUJBQW9CLE9BQU87QUFDM0IscUJBQW9CLE9BQU87QUFDM0IscUJBQW9CLE9BQU87QUFDM0IscUJBQW9CLE9BQU87QUFDM0IscUJBQW9CLE9BQU87QUFDM0IscUJBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUN0Q0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUJBQW9CLE9BQU87QUFDM0IscUJBQW9CLE9BQU87QUFDM0IscUJBQW9CLE9BQU87QUFDM0IscUJBQW9CLE9BQU87QUFDM0IscUJBQW9CLE9BQU87QUFDM0IscUJBQW9CLE9BQU87QUFDM0IscUJBQW9CLE9BQU87QUFDM0IscUJBQW9CLE9BQU87QUFDM0IscUJBQW9CLE9BQU87QUFDM0IscUJBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUNwQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxQkFBb0IsT0FBTztBQUMzQixxQkFBb0IsT0FBTztBQUMzQixxQkFBb0IsT0FBTztBQUMzQixxQkFBb0IsT0FBTztBQUMzQixxQkFBb0IsT0FBTztBQUMzQixxQkFBb0IsUUFBUTtBQUM1QixxQkFBb0IsT0FBTztBQUMzQixxQkFBb0IsT0FBTztBQUMzQixxQkFBb0IsT0FBTztBQUMzQixxQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FDekRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7Ozs7Ozs7OztBQ2xCQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7O0FDZEE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJCQUEwQixpQkFBaUI7QUFDM0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBdUIsWUFBWTtBQUNuQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7OztBQzVGQTtBQUNBLGdCQUFlLGVBQWU7QUFDOUI7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxjQUFhO0FBQ2I7QUFDQTs7QUFFQTs7Ozs7OztBQ3hCQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNB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QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7Ozs7OztBQ25UQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXVDLGlDQUFpQztBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7Ozs7Ozs7QUMxSkE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0EsbUJBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakIsaUJBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWdCLDhCQUE4QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFnQiw4QkFBOEI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQSxtQkFBa0I7QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsaUJBQWdCLE9BQU87QUFDdkIsa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUN4S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGdDQUErQixzQkFBc0I7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7Ozs7OztBQzVIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOzs7QUFHVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7Ozs7Ozs7O0FDN0JMO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxVQUFTOztBQUVUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFLOzs7Ozs7OztBQzFETDtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7Ozs7Ozs7QUMxQkw7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLE1BQUs7Ozs7Ozs7OztBQ3JCTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0NBQW1DLGlDQUFpQztBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1REFBc0QsT0FBTztBQUM3RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUN4Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFlLE1BQU07QUFDckIsZ0JBQWUsUUFBUTtBQUN2QixpQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBdUIsU0FBUztBQUNoQztBQUNBOztBQUVBO0FBQ0E7QUFDQSx3QkFBdUIsVUFBVTtBQUNqQztBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNwRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZSxNQUFNO0FBQ3JCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsUUFBUTtBQUN2QixnQkFBZSxNQUFNO0FBQ3JCO0FBQ0E7QUFDQSxnQkFBZSxNQUFNO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWdELFNBQVM7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNkNBQTRDLFNBQVM7QUFDckQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7OztBQ25HQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxVQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLE1BQUs7Ozs7Ozs7QUM1Qkw7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7Ozs7Ozs7OztBQ3RDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUN4RkE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0EscUJBQW9CLE9BQU87QUFDM0IscUJBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOzs7Ozs7OztBQ3pETDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWMsWUFBWTtBQUMxQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx3QkFBdUIsYUFBYTtBQUNwQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLDRCQUEyQixhQUFhO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTJCLGFBQWE7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjs7QUFFakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxvQ0FBbUMsWUFBWTtBQUMvQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxvQ0FBbUMsWUFBWTtBQUMvQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLDRCQUEyQixhQUFhO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUEyQixhQUFhO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsd0JBQXVCLGFBQWE7QUFDcEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsNEJBQTJCLGFBQWE7QUFDeEM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0NBQXFDLFFBQVE7QUFDN0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw2Q0FBNEMsUUFBUTtBQUNwRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9DQUFtQyxZQUFZO0FBQy9DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFpQjs7QUFFakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNDQUFxQyxRQUFRO0FBQzdDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUEyQixhQUFhO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNscUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxrQkFBaUIsT0FBTztBQUN4QixtQkFBa0IsU0FBUztBQUMzQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLFNBQVM7QUFDeEIsZ0JBQWUsY0FBYztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxpQkFBZ0I7QUFDaEI7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBbUIsOEJBQThCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0Esb0JBQW1CLGtDQUFrQztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUEyQixrQkFBa0I7QUFDN0M7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0Esb0JBQW1CLDhCQUE4QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQSxvQkFBbUIsa0NBQWtDO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBLDRCQUEyQixrQkFBa0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNEJBQTJCLFNBQVM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTJCLFNBQVM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTJCLFNBQVM7QUFDcEM7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EscUJBQW9CLE9BQU87QUFDM0IscUJBQW9CLE9BQU87QUFDM0IscUJBQW9CLFFBQVE7QUFDNUIscUJBQW9CLFNBQVM7QUFDN0I7QUFDQSxxQkFBb0IsU0FBUztBQUM3QjtBQUNBLHFCQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7Ozs7Ozs7O0FDelBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLHlFQUF3RTtBQUN4RTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWUsTUFBTTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUNoR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW1CLE1BQU07QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxvQkFBbUIsTUFBTTtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxvQkFBbUIsTUFBTTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0Esb0JBQW1CLE1B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QUFDQSw0QkFBMkIsMEJBQTBCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0QkFBMkIsU0FBUztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2IsVUFBUzs7QUFFVDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNkNBQTRDLE9BQU87QUFDbkQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0Esb0JBQW1CLE9BQU87QUFDMUIscUJBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFTOztBQUVUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0QkFBMkIsYUFBYTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXVCLHVCQUF1QjtBQUM5QztBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF1Qix1QkFBdUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBdUIsdUJBQXVCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBLG9CQUFtQiw2QkFBNkI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE0QyxPQUFPO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxvQkFBbUIsT0FBTztBQUMxQixvQkFBbUIsT0FBTztBQUMxQixvQkFBbUIsT0FBTztBQUMxQixvQkFBbUIsT0FBTztBQUMxQixvQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0Esb0JBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBLG9CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQSxvQkFBbUIsT0FBTztBQUMxQixvQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsNEJBQTJCLHdCQUF3QjtBQUNuRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNB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QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBLGVBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFtQixPQUFP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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQStCLFlBQVk7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFtQixpQkFBaUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0NBQStCLFlBQVk7QUFDM0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE2RCxhQUFhLE9BQU87QUFDakYsOEJBQTZCLFNBQVMsWUFBWSxnQkFBZ0I7QUFDbEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxvQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUN6aENBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQzlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsMkRBQTBELGdCQUFnQixrQkFBa0IsWUFBWSxhQUFhOztBQUVySCxvREFBbUQsT0FBTyxNQUFNOztBQUVoRTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLHFCQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0EsNEJBQTJCLGlCQUFpQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFtQixnQ0FBZ0M7QUFDbkQ7QUFDQTtBQUNBOztBQUVBIiwiZmlsZSI6ImZpc2hUb3BvTmV0d29yay5qcyIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFtdLCBmYWN0b3J5KTtcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG5cdFx0ZXhwb3J0c1tcImZpc2hUb3BvTmV0d29ya1wiXSA9IGZhY3RvcnkoKTtcblx0ZWxzZVxuXHRcdHJvb3RbXCJmaXNoVG9wb05ldHdvcmtcIl0gPSBmYWN0b3J5KCk7XG59KSh0aGlzLCBmdW5jdGlvbigpIHtcbnJldHVybiBcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiB3ZWJwYWNrL3VuaXZlcnNhbE1vZHVsZURlZmluaXRpb25cbiAqKi8iLCIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSlcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcblxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0ZXhwb3J0czoge30sXG4gXHRcdFx0aWQ6IG1vZHVsZUlkLFxuIFx0XHRcdGxvYWRlZDogZmFsc2VcbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubG9hZGVkID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIHdlYnBhY2svYm9vdHN0cmFwIGZhZmFjMDlkY2Q2MGU0M2FiY2EwXG4gKiovIiwiLyoqXHJcbiAqIEV4cG9ydCBmaXNoVG9wbyBhcyBDb21tb25KUyBtb2R1bGVcclxuICovXHJcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvZmlzaC10b3BvLW5ldHdvcmsvbGliL0Zpc2hUb3BvTmV0d29yay5qcycpO1xyXG5cclxuLy/lhbzlrrlJRTgg5byV5YWlVk1MIOWmguaenOS4jemcgOimgeWFvOWuuUlFOOivt+WIoOmZpFxyXG5yZXF1aXJlKCd6cmVuZGVyL2xpYi92bWwvdm1sJyk7XHJcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9pbmRleC5uZXR3b3JrLmpzXG4gKiogbW9kdWxlIGlkID0gMVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXHJcbiAgICB2YXIgZ3JhcGhpYyA9IHJlcXVpcmUoXCIuLi8uLi9maXNoLXRvcG8tY29yZS9saWIvZ3JhcGhpYy5qc1wiKTtcclxuICAgIHZhciBFeHRlbnNpb25BUEkgPSByZXF1aXJlKCcuL0V4dGVuc2lvbkFQSScpO1xyXG4gICAgdmFyIEV2ZW50ZnVsID0gcmVxdWlyZSgnenJlbmRlci9saWIvbWl4aW4vRXZlbnRmdWwnKTtcclxuICAgIHZhciB6cmVuZGVyID0gcmVxdWlyZSgnenJlbmRlci9saWIvenJlbmRlcicpO1xyXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xyXG4gICAgdmFyIHV0aWwgPSByZXF1aXJlKFwiLi4vLi4vZmlzaC10b3BvLWNvcmUvbGliL3V0aWwuanNcIik7XHJcbiAgICB2YXIgTmV0d29ya01vZGVsID0gcmVxdWlyZShcIi4vbW9kZWwvTmV0d29ya01vZGVsLmpzXCIpO1xyXG4gICAgdmFyIE5ldHdvcmtOb2RlID0gcmVxdWlyZShcIi4vbm9kZS9OZXR3b3JrTm9kZS5qc1wiKTtcclxuICAgIHZhciBSYWNrTm9kZSA9IHJlcXVpcmUoXCIuL25vZGUvcmFjay9SYWNrTm9kZS5qc1wiKTtcclxuICAgIHZhciBOZXR3b3JrVXRpbCA9IHJlcXVpcmUoXCIuL05ldHdvcmtVdGlsLmpzXCIpO1xyXG5cclxuICAgIGZ1bmN0aW9uIEZpc2hUb3BvTmV0d29yayAoZG9tLCBvcHRzKSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmlkO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdyb3VwIGlkXHJcbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmdyb3VwO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAdHlwZSB7SFRNTERvbUVsZW1lbnR9XHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLl9kb20gPSBkb207XHJcblxyXG4gICAgICAgIHRoaXMuYWxsTm9kZXMgPSBbXTtcclxuXHJcbiAgICAgICAgdGhpcy5fYXBpID0gbmV3IEV4dGVuc2lvbkFQSSh0aGlzKTtcclxuXHJcbiAgICAgICAgdGhpcy50aXBOb2RlID0gbnVsbDtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHR5cGUge21vZHVsZTp6cmVuZGVyL1pSZW5kZXJ9XHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLl96ciA9IGluaXQodGhpcywgb3B0cyk7IFxyXG5cclxuICAgICAgICBFdmVudGZ1bC5jYWxsKHRoaXMpO1xyXG4gICAgICAgIGlmICggIU5ldHdvcmtOb2RlLmhhc0NsYXNzKFwiUmFja05vZGVcIikpIHtcclxuICAgICAgICAgICAgTmV0d29ya1V0aWwucmVnaXN0ZXJOZXR3b3JrTm9kZSgpOyBcclxuICAgICAgICB9ICAgICBcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBpbml0KHBfdGhpcywgcF9vcHRzKSB7XHJcblxyXG4gICAgICAgIHZhciB0b3BvRGl2ID0gJzxkaXYgY2xhc3M9XCJ0b3BvRGl2XCIgaWQgPSBcInRvcG9EaXZcIiBzdHlsZT1cIndpZHRoOjEwMCU7IGhlaWdodDoxMDAlOyBvdmVyZmxvdzphdXRvO1wiPjwvZGl2Pic7XHJcbiAgICAgICAgcF90aGlzLl9kb20uaW5uZXJIVE1MID0gdG9wb0RpdjtcclxuICAgICAgICBcclxuICAgICAgICB2YXIgZG9tID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJ0b3BvRGl2XCIpO1xyXG5cclxuICAgICAgICB2YXIgelJlbmRlcmVyID0genJlbmRlci5pbml0KGRvbSwge1xyXG4gICAgICAgICAgICByZW5kZXJlcjogcF9vcHRzLnJlbmRlcmVyIHx8ICdjYW52YXMnLFxyXG4gICAgICAgICAgICBkZXZpY2VQaXhlbFJhdGlvOiBwX29wdHMuZGV2aWNlUGl4ZWxSYXRpb1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiB6UmVuZGVyZXI7ICAgIFxyXG4gICAgfTtcclxuXHJcbiAgICB2YXIgZmlzaFRvcG9Qcm90byA9IEZpc2hUb3BvTmV0d29yay5wcm90b3R5cGU7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJuIHtIVE1MRG9tRWxlbWVudH1cclxuICAgICAqL1xyXG4gICAgZmlzaFRvcG9Qcm90by5nZXREb20gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RvbTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlcn5aUmVuZGVyfVxyXG4gICAgICovXHJcbiAgICBmaXNoVG9wb1Byb3RvLmdldFpyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl96cjtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm4ge251bWJlcn1cclxuICAgICAqL1xyXG4gICAgZmlzaFRvcG9Qcm90by5nZXRXaWR0aCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fenIuZ2V0V2lkdGgoKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIGZpc2hUb3BvUHJvdG8uZ2V0SGVpZ2h0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl96ci5nZXRIZWlnaHQoKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDosIPmlbTlsLrlr7ggIOWcqOeql+WPo+Wkp+Wwj+WPkeeUn+aUueWPmOaXtumcgOimgeaJi+W3peiwg+eUqFxyXG4gICAgICovXHJcbiAgICBmaXNoVG9wb1Byb3RvLnJlc2l6ZSA9IGZ1bmN0aW9uICggcF93aWR0aCwgcF9oZWlnaHQpIHtcclxuICAgICAgICBwX3dpZHRoID0gcF93aWR0aCAhPT0gdW5kZWZpbmVkID8gcF93aWR0aCA6IHRoaXMuZ2V0V2lkdGg7XHJcbiAgICAgICAgcF9oZWlnaHQgPSBwX2hlaWdodCAhPT0gdW5kZWZpbmVkID8gcF9oZWlnaHQgOiB0aGlzLmdldEhlaWdodCgpIC0gNTA7XHJcbiAgICAgICAgdGhpcy5fenIucGFpbnRlci5yZXNpemUocF93aWR0aCwgcF9oZWlnaHQpO1xyXG4gICAgfTsgXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDmoLnmja7mqKHlnovlop7liqDoioLngrlcclxuICAgICAqIEBwYXJhbSB7W3R5cGVdfSBtb2RlbCBbZGVzY3JpcHRpb25dXHJcbiAgICAgKi9cclxuICAgIGZpc2hUb3BvUHJvdG8uYWRkTm9kZUJ5TW9kZWwgPSBmdW5jdGlvbihtb2RlbCkge1xyXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgICAgICB2YXIgU2hhcGUgPSBOZXR3b3JrTm9kZS5nZXRDbGFzcyhtb2RlbC5nZXQoXCJzdGVuY2lsLnR5cGVcIikpO1xyXG4gICAgICAgIGlmIChTaGFwZSkge1xyXG4gICAgICAgICAgICBub2RlID0gbmV3IFNoYXBlKG1vZGVsLCB0aGlzLl9hcGkpO1xyXG4gICAgICAgICAgICB0aGlzLl96ci5hZGQobm9kZSk7IFxyXG4gICAgICAgICAgICBub2RlLm9uKCdjbGljaycsZnVuY3Rpb24oZSl7XHJcbiAgICAgICAgICAgICAgICB0aGF0Ll9hcGkudHJpZ2dlcihlLCB7fSk7ICBcclxuICAgICAgICAgICAgfSk7ICAgICAgICAgXHJcbiAgICAgICAgfSAgICAgICAgIFxyXG4gICAgICAgICAgICAgXHJcbiAgICB9OyAgXHJcblxyXG4gICAgZmlzaFRvcG9Qcm90by5nZXROb2RlQ2xhc3MgPSBmdW5jdGlvbiAoY2xhc3NOYW1lKSB7XHJcbiAgICAgICAgcmV0dXJuIE5ldHdvcmtOb2RlLmdldENsYXNzKGNsYXNzTmFtZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICog6byg5qCH5oKs5YGc5o+Q56S65qGG5bGV56S6XHJcbiAgICAgKiBAcGFyYW0ge1t0eXBlXX0gbW9kZWwgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICovXHJcbiAgICBmaXNoVG9wb1Byb3RvLnNob3dUaXBXaW5kb3cgPSBmdW5jdGlvbihtb2RlbCkge1xyXG4gICAgICAgIHZhciBTaGFwZSA9IE5ldHdvcmtOb2RlLmdldENsYXNzKFwiVGlwV2luZG93Tm9kZVwiKTtcclxuICAgICAgICBpZiAoU2hhcGUpIHtcclxuICAgICAgICAgICAgdmFyIGhlaWdodCA9IHRoaXMuX3pyLmdldEhlaWdodCgpOyAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGlmKCB0aGlzLmFsbFdpZHRoICE9IHVuZGVmaW5lZCApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3pyLnBhaW50ZXIucmVzaXplKCB0aGlzLmFsbFdpZHRoICsgbW9kZWwud2lkdGgsIDczMCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHZhciBub2RlID0gbmV3IFNoYXBlKG1vZGVsLCB0aGlzLl9hcGkpO1xyXG4gICAgICAgICAgICB0aGlzLl96ci5hZGQobm9kZSk7IFxyXG4gICAgICAgICAgICB0aGlzLnRpcE5vZGUgPSBub2RlO1xyXG4gICAgICAgICAgICAvLyBub2RlLm9uKCdtb3VzZWRvd24nLGZ1bmN0aW9uKGUpe1xyXG4gICAgICAgICAgICAvLyAgICAgLy90aGF0Lm5ld0RyYWcodGhpcyxlLmV2ZW50LmNsaWVudFgsZS5ldmVudC5jbGllbnRZKTsgICBcclxuICAgICAgICAgICAgLy8gfSk7ICAgICAgICAgXHJcbiAgICAgICAgfSAgICAgICAgIFxyXG5cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDpvKDmoIfmgqzlgZzmj5DnpLrmoYblsZXnpLpcclxuICAgICAqIEBwYXJhbSB7W3R5cGVdfSBtb2RlbCBbZGVzY3JpcHRpb25dXHJcbiAgICAgKi9cclxuICAgIGZpc2hUb3BvUHJvdG8uaGlkZVRpcFdpbmRvdyA9IGZ1bmN0aW9uKG1vZGVsKSB7IFxyXG4gICAgICAgIGlmICh0aGlzLnRpcE5vZGUgJiYgdGhpcy50aXBOb2RlICE9PSBudWxsICkge1xyXG4gICAgICAgICAgICB0aGlzLl96ci5yZW1vdmUodGhpcy50aXBOb2RlKTsgICAgICBcclxuICAgICAgICB9ICAgICAgICAgXHJcbiAgICB9O1xyXG5cclxuICAgIGZpc2hUb3BvUHJvdG8uaW5pdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgaXNTZWxlY3RlZCA9IHRoaXMuaXNTZWxlY3RlZDtcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgfTtcclxuXHJcbiAgICBmaXNoVG9wb1Byb3RvLmNsZWFyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuX3pyLmNsZWFyKCk7XHJcbiAgICB9OyAgIFxyXG5cclxuICAgIGZpc2hUb3BvUHJvdG8uZXhwb3J0SnNvbiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBuZXR3b3JrTW9kZWwgPSBuZXcgTmV0d29ya01vZGVsKHt9KTtcclxuICAgICAgICBuZXR3b3JrTW9kZWwuc2V0KFwicmVzb3VyY2VJZFwiLCB1dGlsLmdldFVVSUQoKSk7XHJcbiAgICAgICAgcmV0dXJuIE5ldHdvcmtVdGlsLmV4cG9ydEpzb24obmV0d29ya01vZGVsLCB0aGlzLmFsbE5vZGVzKTtcclxuICAgIH07XHJcblxyXG4gICAgZmlzaFRvcG9Qcm90by5kcmF3RnJvbUpzb24gPSBmdW5jdGlvbihqc29uKSB7XHJcbiAgICAgICAgdmFyIHRvcG9UeXBlID0ganNvbi50eXBlO1xyXG4gICAgICAgIGlmICggdG9wb1R5cGUgPT09IFwicmFja1wiICkge1xyXG4gICAgICAgICAgICB2YXIgY2xpZW50V2lkdGggPSB0aGlzLl96ci5nZXRXaWR0aCgpO1xyXG4gICAgICAgICAgICBpZiAoICg1MCArIChqc29uLmRhdGEubGVuZ3RoICogMjUwKSkgPiBjbGllbnRXaWR0aCApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3pyLnBhaW50ZXIucmVzaXplKCA1MCArIChqc29uLmRhdGEubGVuZ3RoICogMjUwKSwgNzMwKTtcclxuICAgICAgICAgICAgICAgIGlmICggY2xpZW50V2lkdGggPCB0aGlzLl96ci5nZXRXaWR0aCgpICkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWxsV2lkdGggPSB0aGlzLl96ci5nZXRXaWR0aCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IFxyXG4gICAgICAgIH0gZWxzZSBpZiAoIHRvcG9UeXBlID09PSBcInRvcG9cIiApIHtcclxuICAgICAgICAgICAgdmFyIGNsaWVudFdpZHRoID0gdGhpcy5fenIuZ2V0V2lkdGgoKTtcclxuICAgICAgICAgICAgdmFyIGNsaWVudEhlaWdodCA9IDcwMDtcclxuICAgICAgICAgICAgdGhpcy53aWR0aCA9IGNsaWVudFdpZHRoO1xyXG4gICAgICAgICAgICB0aGlzLmhlaWdodCA9IGNsaWVudEhlaWdodDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoIHRvcG9UeXBlID09PSBcImNsdXN0ZXJcIiApIHtcclxuICAgICAgICAgICAgdmFyIGNsaWVudFdpZHRoID0gdGhpcy5fenIuZ2V0V2lkdGgoKTtcclxuICAgICAgICAgICAgdmFyIGNsaWVudEhlaWdodCA9IDYzMDtcclxuICAgICAgICAgICAgdGhpcy53aWR0aCA9IGNsaWVudFdpZHRoO1xyXG4gICAgICAgICAgICB0aGlzLmhlaWdodCA9IGNsaWVudEhlaWdodDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIE5ldHdvcmtVdGlsLmZyb21Kc29uKHRoaXMsIGpzb24pO1xyXG4gICAgfTsgIFxyXG5cclxuICAgIHpyVXRpbC5taXhpbihGaXNoVG9wb05ldHdvcmssIEV2ZW50ZnVsKTtcclxuXHJcbiAgICAvLyAtLS0tLS0tLS3lr7nlpJbmmrTpnLJmaXNoVG9wb05ldFdvcmstLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIHZhciBpZEJhc2UgPSBuZXcgRGF0ZSgpIC0gMDtcclxuICAgIHZhciBpbnN0YW5jZXMgPSB7fTtcclxuICAgIHZhciBET01fQVRUUklCVVRFX0tFWSA9ICdfZmlzaFRvcG9OZXR3b3JrX2luc3RhbmNlXyc7XHJcbiAgICB2YXIgZmlzaFRvcG9OZXRXb3JrID0ge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdmVyc2lvbjogJzEuMC4wJyxcclxuICAgICAgICBkZXBlbmRlbmNpZXM6IHtcclxuICAgICAgICAgICAgenJlbmRlcjogJzMuMC40J1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0ge0hUTUxEb21FbGVtZW50fSBkb21cclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXHJcbiAgICAgKi9cclxuICAgIGZpc2hUb3BvTmV0V29yay5pbml0ID0gZnVuY3Rpb24gKGRvbSwgb3B0cykge1xyXG4gICAgICAgIGlmICghZG9tKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW5pdGlhbGl6ZSBmYWlsZWQ6IGludmFsaWQgZG9tLicpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgb3B0cyA9IG9wdHMgfHwge307XHJcbiAgICAgICAgLy8gRGVmYXVsdCB2YWx1ZVxyXG4gICAgICAgIHpyVXRpbC5kZWZhdWx0cyhvcHRzLFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiBcImJwbW5cIixcclxuICAgICAgICAgICAgICAgIHNob3dHcmlkTGluZTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIGRldmljZVBpeGVsUmF0aW86IDEsXHJcbiAgICAgICAgICAgICAgICBncmlkTGluZVNwYWNpbmc6MTBcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICk7XHJcblxyXG4gICAgICAgIHZhciBmaXNoVG9wb05ldFdvcmsgPSBuZXcgRmlzaFRvcG9OZXR3b3JrKGRvbSwgb3B0cyk7XHJcbiAgICAgICAgZmlzaFRvcG9OZXRXb3JrLmluaXQoKTtcclxuXHJcbiAgICAgICAgZmlzaFRvcG9OZXRXb3JrLmlkID0gJ2Z0XycgKyBpZEJhc2UrKztcclxuICAgICAgICBpbnN0YW5jZXNbZmlzaFRvcG9OZXRXb3JrLmlkXSA9IGZpc2hUb3BvTmV0V29yaztcclxuXHJcbiAgICAgICAgZG9tLnNldEF0dHJpYnV0ZSAmJiBkb20uc2V0QXR0cmlidXRlKERPTV9BVFRSSUJVVEVfS0VZLCBmaXNoVG9wb05ldFdvcmsuaWQpO1xyXG5cclxuICAgICAgICByZXR1cm4gZmlzaFRvcG9OZXRXb3JrO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gIHtIVE1MRG9tRWxlbWVudH0gZG9tXHJcbiAgICAgKiBAcmV0dXJuIHtmaXNoVG9wb31cclxuICAgICAqL1xyXG4gICAgZmlzaFRvcG9OZXRXb3JrLmdldEluc3RhbmNlQnlEb20gPSBmdW5jdGlvbiAoZG9tKSB7XHJcbiAgICAgICAgdmFyIGtleSA9IGRvbS5nZXRBdHRyaWJ1dGUoRE9NX0FUVFJJQlVURV9LRVkpO1xyXG4gICAgICAgIHJldHVybiBpbnN0YW5jZXNba2V5XTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEaXNwb3NlIGEgZmlzaFRvcG8gaW5zdGFuY2VcclxuICAgICAqIEBwYXJhbSAge21vZHVsZTpmaXNoVG9wb3xIVE1MRG9tRWxlbWVudHxzdHJpbmd9IGZpc2hUb3BvXHJcbiAgICAgKi9cclxuICAgIGZpc2hUb3BvTmV0V29yay5kaXNwb3NlID0gZnVuY3Rpb24gKGNoYXJ0KSB7XHJcbiAgICAgICAgdmFyIHRvcG87XHJcbiAgICAgICAgaWYgKHpyVXRpbC5pc0RvbShjaGFydCkpIHtcclxuICAgICAgICAgICAgdG9wbyA9IGZpc2hUb3BvTmV0V29yay5nZXRJbnN0YW5jZUJ5RG9tKGNoYXJ0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGNoYXJ0ID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICB0b3BvID0gaW5zdGFuY2VzW2NoYXJ0XTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCh0b3BvIGluc3RhbmNlb2YgZmlzaFRvcG9OZXRXb3JrKSAmJiAhdG9wby5pc0Rpc3Bvc2VkKCkpIHtcclxuICAgICAgICAgICAgdG9wby5kaXNwb3NlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZpc2hUb3BvTmV0V29yaztcclxuXHJcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9saWIvZmlzaC10b3BvLW5ldHdvcmsvbGliL0Zpc2hUb3BvTmV0d29yay5qc1xuICoqIG1vZHVsZSBpZCA9IDJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxyXG5cclxuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcclxuXHJcbiAgICB2YXIgcGF0aFRvb2wgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi90b29sL3BhdGgnKTtcclxuICAgIHZhciByb3VuZCA9IE1hdGgucm91bmQ7XHJcbiAgICB2YXIgUGF0aCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2dyYXBoaWMvUGF0aCcpO1xyXG4gICAgdmFyIGNvbG9yVG9vbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL3Rvb2wvY29sb3InKTtcclxuICAgIHZhciBtYXRyaXggPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL21hdHJpeCcpO1xyXG4gICAgdmFyIHZlY3RvciA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdmVjdG9yJyk7XHJcbiAgICB2YXIgR3JhZGllbnQgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9ncmFwaGljL0dyYWRpZW50Jyk7XHJcbiAgICB2YXIgRHJhZ2dhYmxlID0gcmVxdWlyZSgnenJlbmRlci9saWIvbWl4aW4vRHJhZ2dhYmxlJyk7XHJcblxyXG4gICAgdmFyIGdyYXBoaWMgPSB7fTtcclxuICAgIGdyYXBoaWMuVXRpbCA9IHpyVXRpbDtcclxuICAgIGdyYXBoaWMuR3JvdXAgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb250YWluZXIvR3JvdXAnKTtcclxuXHJcbiAgICBncmFwaGljLkltYWdlID0gcmVxdWlyZSgnenJlbmRlci9saWIvZ3JhcGhpYy9JbWFnZScpO1xyXG5cclxuICAgIGdyYXBoaWMuVGV4dCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2dyYXBoaWMvVGV4dCcpO1xyXG5cclxuICAgIGdyYXBoaWMudGV4dENvbnRhaW4gPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb250YWluL3RleHQnKTtcclxuXHJcbiAgICBncmFwaGljLkNpcmNsZSA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvQ2lyY2xlJyk7XHJcblxyXG4gICAgZ3JhcGhpYy5TZWN0b3IgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL1NlY3RvcicpO1xyXG5cclxuICAgIGdyYXBoaWMuUmluZyA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvUmluZycpO1xyXG5cclxuICAgIGdyYXBoaWMuUG9seWdvbiA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvUG9seWdvbicpO1xyXG5cclxuICAgIGdyYXBoaWMuUG9seWxpbmUgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL1BvbHlsaW5lJyk7XHJcblxyXG4gICAgZ3JhcGhpYy5SZWN0ID0gcmVxdWlyZSgnenJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9SZWN0Jyk7XHJcblxyXG4gICAgZ3JhcGhpYy5MaW5lID0gcmVxdWlyZSgnenJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9MaW5lJyk7XHJcblxyXG4gICAgZ3JhcGhpYy5CZXppZXJDdXJ2ZSA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvQmV6aWVyQ3VydmUnKTtcclxuXHJcbiAgICBncmFwaGljLkFyYyA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvQXJjJyk7XHJcblxyXG4gICAgZ3JhcGhpYy5MaW5lYXJHcmFkaWVudCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2dyYXBoaWMvTGluZWFyR3JhZGllbnQnKTtcclxuXHJcbiAgICBncmFwaGljLlJhZGlhbEdyYWRpZW50ID0gcmVxdWlyZSgnenJlbmRlci9saWIvZ3JhcGhpYy9SYWRpYWxHcmFkaWVudCcpO1xyXG5cclxuICAgIGdyYXBoaWMuQm91bmRpbmdSZWN0ID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS9Cb3VuZGluZ1JlY3QnKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEV4dGVuZCBzaGFwZSB3aXRoIHBhcmFtZXRlcnNcclxuICAgICAqL1xyXG4gICAgZ3JhcGhpYy5leHRlbmRTaGFwZSA9IGZ1bmN0aW9uIChvcHRzKSB7XHJcbiAgICAgICAgcmV0dXJuIFBhdGguZXh0ZW5kKG9wdHMpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEV4dGVuZCBwYXRoXHJcbiAgICAgKi9cclxuICAgIGdyYXBoaWMuZXh0ZW5kUGF0aCA9IGZ1bmN0aW9uIChwYXRoRGF0YSwgb3B0cykge1xyXG4gICAgICAgIHJldHVybiBwYXRoVG9vbC5leHRlbmRGcm9tU3RyaW5nKHBhdGhEYXRhLCBvcHRzKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGUgYSBwYXRoIGVsZW1lbnQgZnJvbSBwYXRoIGRhdGEgc3RyaW5nXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aERhdGFcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXHJcbiAgICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL2NvcmUvQm91bmRpbmdSZWN0fSByZWN0XHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2xheW91dD1jb3Zlcl0gJ2NlbnRlcicgb3IgJ2NvdmVyJ1xyXG4gICAgICovXHJcbiAgICBncmFwaGljLm1ha2VQYXRoID0gZnVuY3Rpb24gKHBhdGhEYXRhLCBvcHRzLCByZWN0LCBsYXlvdXQpIHtcclxuICAgICAgICB2YXIgcGF0aCA9IHBhdGhUb29sLmNyZWF0ZUZyb21TdHJpbmcocGF0aERhdGEsIG9wdHMpO1xyXG4gICAgICAgIERyYWdnYWJsZS5jYWxsKHBhdGgpO1xyXG4gICAgICAgIHZhciBib3VuZGluZ1JlY3QgPSBwYXRoLmdldEJvdW5kaW5nUmVjdCgpO1xyXG4gICAgICAgIGlmIChyZWN0KSB7XHJcbiAgICAgICAgICAgIHZhciBhc3BlY3QgPSBib3VuZGluZ1JlY3Qud2lkdGggLyBib3VuZGluZ1JlY3QuaGVpZ2h0O1xyXG5cclxuICAgICAgICAgICAgaWYgKGxheW91dCA9PT0gJ2NlbnRlcicpIHtcclxuICAgICAgICAgICAgICAgIC8vIFNldCByZWN0IHRvIGNlbnRlciwga2VlcCB3aWR0aCAvIGhlaWdodCByYXRpby5cclxuICAgICAgICAgICAgICAgIHZhciB3aWR0aCA9IHJlY3QuaGVpZ2h0ICogYXNwZWN0O1xyXG4gICAgICAgICAgICAgICAgdmFyIGhlaWdodDtcclxuICAgICAgICAgICAgICAgIGlmICh3aWR0aCA8PSByZWN0LndpZHRoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0ID0gcmVjdC5oZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB3aWR0aCA9IHJlY3Qud2lkdGg7XHJcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0ID0gd2lkdGggLyBhc3BlY3Q7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgY3ggPSByZWN0LnggKyByZWN0LndpZHRoIC8gMjtcclxuICAgICAgICAgICAgICAgIHZhciBjeSA9IHJlY3QueSArIHJlY3QuaGVpZ2h0IC8gMjtcclxuXHJcbiAgICAgICAgICAgICAgICByZWN0LnggPSBjeCAtIHdpZHRoIC8gMjtcclxuICAgICAgICAgICAgICAgIHJlY3QueSA9IGN5IC0gaGVpZ2h0IC8gMjtcclxuICAgICAgICAgICAgICAgIHJlY3Qud2lkdGggPSB3aWR0aDtcclxuICAgICAgICAgICAgICAgIHJlY3QuaGVpZ2h0ID0gaGVpZ2h0O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0aGlzLnJlc2l6ZVBhdGgocGF0aCwgcmVjdCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB6clV0aWwuaW5oZXJpdHMocGF0aCwgRHJhZ2dhYmxlKTtcclxuICAgICAgICByZXR1cm4gcGF0aDtcclxuICAgIH07XHJcblxyXG4gICAgZ3JhcGhpYy5tZXJnZVBhdGggPSBwYXRoVG9vbC5tZXJnZVBhdGg7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXNpemUgYSBwYXRoIHRvIGZpdCB0aGUgcmVjdFxyXG4gICAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9ncmFwaGljL1BhdGh9IHBhdGhcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSByZWN0XHJcbiAgICAgKi9cclxuICAgIGdyYXBoaWMucmVzaXplUGF0aCA9IGZ1bmN0aW9uIChwYXRoLCByZWN0KSB7XHJcbiAgICAgICAgaWYgKCFwYXRoLmFwcGx5VHJhbnNmb3JtKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBwYXRoUmVjdCA9IHBhdGguZ2V0Qm91bmRpbmdSZWN0KCk7XHJcblxyXG4gICAgICAgIHZhciBtID0gcGF0aFJlY3QuY2FsY3VsYXRlVHJhbnNmb3JtKHJlY3QpO1xyXG5cclxuICAgICAgICBwYXRoLmFwcGx5VHJhbnNmb3JtKG0pO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFN1YiBwaXhlbCBvcHRpbWl6ZSBsaW5lIGZvciBjYW52YXNcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1cclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbcGFyYW0uc2hhcGVdXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3BhcmFtLnNoYXBlLngxXVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtwYXJhbS5zaGFwZS55MV1cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcGFyYW0uc2hhcGUueDJdXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3BhcmFtLnNoYXBlLnkyXVxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtwYXJhbS5zdHlsZV1cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcGFyYW0uc3R5bGUubGluZVdpZHRoXVxyXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBNb2RpZmllZCBwYXJhbVxyXG4gICAgICovXHJcbiAgICBncmFwaGljLnN1YlBpeGVsT3B0aW1pemVMaW5lID0gZnVuY3Rpb24gKHBhcmFtKSB7XHJcbiAgICAgICAgdmFyIHN1YlBpeGVsT3B0aW1pemUgPSBncmFwaGljLnN1YlBpeGVsT3B0aW1pemU7XHJcbiAgICAgICAgdmFyIHNoYXBlID0gcGFyYW0uc2hhcGU7XHJcbiAgICAgICAgdmFyIGxpbmVXaWR0aCA9IHBhcmFtLnN0eWxlLmxpbmVXaWR0aDtcclxuXHJcbiAgICAgICAgaWYgKHJvdW5kKHNoYXBlLngxICogMikgPT09IHJvdW5kKHNoYXBlLngyICogMikpIHtcclxuICAgICAgICAgICAgc2hhcGUueDEgPSBzaGFwZS54MiA9IHN1YlBpeGVsT3B0aW1pemUoc2hhcGUueDEsIGxpbmVXaWR0aCwgdHJ1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChyb3VuZChzaGFwZS55MSAqIDIpID09PSByb3VuZChzaGFwZS55MiAqIDIpKSB7XHJcbiAgICAgICAgICAgIHNoYXBlLnkxID0gc2hhcGUueTIgPSBzdWJQaXhlbE9wdGltaXplKHNoYXBlLnkxLCBsaW5lV2lkdGgsIHRydWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcGFyYW07XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU3ViIHBpeGVsIG9wdGltaXplIHJlY3QgZm9yIGNhbnZhc1xyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbVxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtwYXJhbS5zaGFwZV1cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcGFyYW0uc2hhcGUueF1cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcGFyYW0uc2hhcGUueV1cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcGFyYW0uc2hhcGUud2lkdGhdXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3BhcmFtLnNoYXBlLmhlaWdodF1cclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbcGFyYW0uc3R5bGVdXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3BhcmFtLnN0eWxlLmxpbmVXaWR0aF1cclxuICAgICAqIEByZXR1cm4ge09iamVjdH0gTW9kaWZpZWQgcGFyYW1cclxuICAgICAqL1xyXG4gICAgZ3JhcGhpYy5zdWJQaXhlbE9wdGltaXplUmVjdCA9IGZ1bmN0aW9uIChwYXJhbSkge1xyXG4gICAgICAgIHZhciBzdWJQaXhlbE9wdGltaXplID0gZ3JhcGhpYy5zdWJQaXhlbE9wdGltaXplO1xyXG4gICAgICAgIHZhciBzaGFwZSA9IHBhcmFtLnNoYXBlO1xyXG4gICAgICAgIHZhciBsaW5lV2lkdGggPSBwYXJhbS5zdHlsZS5saW5lV2lkdGg7XHJcbiAgICAgICAgdmFyIG9yaWdpblggPSBzaGFwZS54O1xyXG4gICAgICAgIHZhciBvcmlnaW5ZID0gc2hhcGUueTtcclxuICAgICAgICB2YXIgb3JpZ2luV2lkdGggPSBzaGFwZS53aWR0aDtcclxuICAgICAgICB2YXIgb3JpZ2luSGVpZ2h0ID0gc2hhcGUuaGVpZ2h0O1xyXG4gICAgICAgIHNoYXBlLnggPSBzdWJQaXhlbE9wdGltaXplKHNoYXBlLngsIGxpbmVXaWR0aCwgdHJ1ZSk7XHJcbiAgICAgICAgc2hhcGUueSA9IHN1YlBpeGVsT3B0aW1pemUoc2hhcGUueSwgbGluZVdpZHRoLCB0cnVlKTtcclxuICAgICAgICBzaGFwZS53aWR0aCA9IE1hdGgubWF4KFxyXG4gICAgICAgICAgICBzdWJQaXhlbE9wdGltaXplKG9yaWdpblggKyBvcmlnaW5XaWR0aCwgbGluZVdpZHRoLCBmYWxzZSkgLSBzaGFwZS54LFxyXG4gICAgICAgICAgICBvcmlnaW5XaWR0aCA9PT0gMCA/IDAgOiAxXHJcbiAgICAgICAgKTtcclxuICAgICAgICBzaGFwZS5oZWlnaHQgPSBNYXRoLm1heChcclxuICAgICAgICAgICAgc3ViUGl4ZWxPcHRpbWl6ZShvcmlnaW5ZICsgb3JpZ2luSGVpZ2h0LCBsaW5lV2lkdGgsIGZhbHNlKSAtIHNoYXBlLnksXHJcbiAgICAgICAgICAgIG9yaWdpbkhlaWdodCA9PT0gMCA/IDAgOiAxXHJcbiAgICAgICAgKTtcclxuICAgICAgICByZXR1cm4gcGFyYW07XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU3ViIHBpeGVsIG9wdGltaXplIGZvciBjYW52YXNcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcG9zaXRpb24gQ29vcmRpbmF0ZSwgc3VjaCBhcyB4LCB5XHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbGluZVdpZHRoIFNob3VsZCBiZSBub25uZWdhdGl2ZSBpbnRlZ2VyLlxyXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gcG9zaXRpdmVPck5lZ2F0aXZlIERlZmF1bHQgZmFsc2UgKG5lZ2F0aXZlKS5cclxuICAgICAqIEByZXR1cm4ge251bWJlcn0gT3B0aW1pemVkIHBvc2l0aW9uLlxyXG4gICAgICovXHJcbiAgICBncmFwaGljLnN1YlBpeGVsT3B0aW1pemUgPSBmdW5jdGlvbiAocG9zaXRpb24sIGxpbmVXaWR0aCwgcG9zaXRpdmVPck5lZ2F0aXZlKSB7XHJcbiAgICAgICAgLy8gQXNzdXJlIHRoYXQgKHBvc2l0aW9uICsgbGluZVdpZHRoIC8gMikgaXMgbmVhciBpbnRlZ2VyIGVkZ2UsXHJcbiAgICAgICAgLy8gb3RoZXJ3aXNlIGxpbmUgd2lsbCBiZSBmdXp6eSBpbiBjYW52YXMuXHJcbiAgICAgICAgdmFyIGRvdWJsZWRQb3NpdGlvbiA9IHJvdW5kKHBvc2l0aW9uICogMik7XHJcbiAgICAgICAgcmV0dXJuIChkb3VibGVkUG9zaXRpb24gKyByb3VuZChsaW5lV2lkdGgpKSAlIDIgPT09IDBcclxuICAgICAgICAgICAgPyBkb3VibGVkUG9zaXRpb24gLyAyXHJcbiAgICAgICAgICAgIDogKGRvdWJsZWRQb3NpdGlvbiArIChwb3NpdGl2ZU9yTmVnYXRpdmUgPyAxIDogLTEpKSAvIDI7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZG9TaW5nbGVFbnRlckhvdmVyKGVsKSB7XHJcbiAgICAgICAgaWYgKGVsLl9faXNIb3Zlcikge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChlbC5fX2hvdmVyU3RsRGlydHkpIHtcclxuICAgICAgICAgICAgdmFyIHN0cm9rZSA9IGVsLnN0eWxlLnN0cm9rZTtcclxuICAgICAgICAgICAgdmFyIGZpbGwgPSBlbC5zdHlsZS5maWxsO1xyXG5cclxuICAgICAgICAgICAgLy8gQ3JlYXRlIGhvdmVyU3R5bGUgb24gbW91c2VvdmVyXHJcbiAgICAgICAgICAgIHZhciBob3ZlclN0eWxlID0gZWwuX19ob3ZlclN0bDtcclxuICAgICAgICAgICAgdmFyIGxpZnQgPSBjb2xvclRvb2wubGlmdDtcclxuICAgICAgICAgICAgaG92ZXJTdHlsZS5maWxsID0gaG92ZXJTdHlsZS5maWxsXHJcbiAgICAgICAgICAgICAgICB8fCAoZmlsbCAmJiAoZmlsbCBpbnN0YW5jZW9mIEdyYWRpZW50ID8gZmlsbCA6IGxpZnQoZmlsbCwgLTAuMSkpKTtcclxuICAgICAgICAgICAgaG92ZXJTdHlsZS5zdHJva2UgPSBob3ZlclN0eWxlLnN0cm9rZVxyXG4gICAgICAgICAgICAgICAgfHwgKHN0cm9rZSAmJiAoc3Ryb2tlIGluc3RhbmNlb2YgR3JhZGllbnQgPyBzdHJva2UgOiBsaWZ0KHN0cm9rZSwgLTAuMSkpKTtcclxuXHJcbiAgICAgICAgICAgIHZhciBub3JtYWxTdHlsZSA9IHt9O1xyXG4gICAgICAgICAgICBmb3IgKHZhciBuYW1lIGluIGhvdmVyU3R5bGUpIHtcclxuICAgICAgICAgICAgICAgIGlmIChob3ZlclN0eWxlLmhhc093blByb3BlcnR5KG5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbm9ybWFsU3R5bGVbbmFtZV0gPSBlbC5zdHlsZVtuYW1lXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZWwuX19ub3JtYWxTdGwgPSBub3JtYWxTdHlsZTtcclxuXHJcbiAgICAgICAgICAgIGVsLl9faG92ZXJTdGxEaXJ0eSA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbC5zZXRTdHlsZShlbC5fX2hvdmVyU3RsKTtcclxuICAgICAgICBlbC56MiArPSAxO1xyXG5cclxuICAgICAgICBlbC5fX2lzSG92ZXIgPSB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGlubmVyXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGRvU2luZ2xlTGVhdmVIb3ZlcihlbCkge1xyXG4gICAgICAgIGlmICghZWwuX19pc0hvdmVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBub3JtYWxTdGwgPSBlbC5fX25vcm1hbFN0bDtcclxuICAgICAgICBub3JtYWxTdGwgJiYgZWwuc2V0U3R5bGUobm9ybWFsU3RsKTtcclxuICAgICAgICBlbC56MiAtPSAxO1xyXG5cclxuICAgICAgICBlbC5fX2lzSG92ZXIgPSBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBpbm5lclxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBkb0VudGVySG92ZXIoZWwpIHtcclxuICAgICAgICBlbC50eXBlID09PSAnZ3JvdXAnXHJcbiAgICAgICAgICAgID8gZWwudHJhdmVyc2UoZnVuY3Rpb24gKGNoaWxkKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQudHlwZSAhPT0gJ2dyb3VwJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGRvU2luZ2xlRW50ZXJIb3ZlcihjaGlsZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIDogZG9TaW5nbGVFbnRlckhvdmVyKGVsKTtcclxuICAgIH1cclxuICAgIGdyYXBoaWMuZG9FbnRlckhvdmVyID0gZG9FbnRlckhvdmVyO1xyXG4gICAgZnVuY3Rpb24gZG9MZWF2ZUhvdmVyKGVsKSB7XHJcbiAgICAgICAgZWwudHlwZSA9PT0gJ2dyb3VwJ1xyXG4gICAgICAgICAgICA/IGVsLnRyYXZlcnNlKGZ1bmN0aW9uIChjaGlsZCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkLnR5cGUgIT09ICdncm91cCcpIHtcclxuICAgICAgICAgICAgICAgICAgICBkb1NpbmdsZUxlYXZlSG92ZXIoY2hpbGQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICA6IGRvU2luZ2xlTGVhdmVIb3ZlcihlbCk7XHJcbiAgICB9XHJcbiAgICBncmFwaGljLmRvTGVhdmVIb3ZlciA9IGRvTGVhdmVIb3ZlcjtcclxuICAgIC8qKlxyXG4gICAgICogQGlubmVyXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHNldEVsZW1lbnRIb3ZlclN0bChlbCwgaG92ZXJTdGwpIHtcclxuICAgICAgICAvLyBJZiBlbGVtZW50IGhhcyBzZXBjaWZpZWQgaG92ZXJTdHlsZSwgdGhlbiB1c2UgaXQgaW5zdGVhZCBvZiBnaXZlbiBob3ZlclN0eWxlXHJcbiAgICAgICAgLy8gT2Z0ZW4gdXNlZCB3aGVuIGl0ZW0gZ3JvdXAgaGFzIGEgbGFiZWwgZWxlbWVudCBhbmQgaXQncyBob3ZlclN0eWxlIGlzIGRpZmZlcmVudFxyXG4gICAgICAgIGVsLl9faG92ZXJTdGwgPSBlbC5ob3ZlclN0eWxlIHx8IGhvdmVyU3RsIHx8IHt9O1xyXG4gICAgICAgIGVsLl9faG92ZXJTdGxEaXJ0eSA9IHRydWU7XHJcbiAgICB9XHJcbiAgICBncmFwaGljLnNldEVsZW1lbnRIb3ZlclN0bCA9IHNldEVsZW1lbnRIb3ZlclN0bDtcclxuICAgIC8qKlxyXG4gICAgICogQGlubmVyXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIG9uRWxlbWVudE1vdXNlT3ZlcigpIHtcclxuICAgICAgICAvLyBPbmx5IGlmIGVsZW1lbnQgaXMgbm90IGluIGVtcGhhc2lzIHN0YXR1c1xyXG4gICAgICAgICF0aGlzLl9faXNFbXBoYXNpcyAmJiBkb0VudGVySG92ZXIodGhpcyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAaW5uZXJcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gb25FbGVtZW50TW91c2VPdXQoKSB7XHJcbiAgICAgICAgLy8gT25seSBpZiBlbGVtZW50IGlzIG5vdCBpbiBlbXBoYXNpcyBzdGF0dXNcclxuICAgICAgICAhdGhpcy5fX2lzRW1waGFzaXMgJiYgZG9MZWF2ZUhvdmVyKHRoaXMpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGlubmVyXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGVudGVyRW1waGFzaXMoKSB7XHJcbiAgICAgICAgdGhpcy5fX2lzRW1waGFzaXMgPSB0cnVlO1xyXG4gICAgICAgIGRvRW50ZXJIb3Zlcih0aGlzKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBpbm5lclxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBsZWF2ZUVtcGhhc2lzKCkge1xyXG4gICAgICAgIHRoaXMuX19pc0VtcGhhc2lzID0gZmFsc2U7XHJcbiAgICAgICAgZG9MZWF2ZUhvdmVyKHRoaXMpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IGhvdmVyIHN0eWxlIG9mIGVsZW1lbnRcclxuICAgICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvRWxlbWVudH0gZWxcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbaG92ZXJTdHlsZV1cclxuICAgICAqL1xyXG4gICAgZ3JhcGhpYy5zZXRIb3ZlclN0eWxlID0gZnVuY3Rpb24gKGVsLCBob3ZlclN0eWxlKSB7XHJcbiAgICAgICAgZWwudHlwZSA9PT0gJ2dyb3VwJ1xyXG4gICAgICAgICAgICA/IGVsLnRyYXZlcnNlKGZ1bmN0aW9uIChjaGlsZCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkLnR5cGUgIT09ICdncm91cCcpIHtcclxuICAgICAgICAgICAgICAgICAgICBzZXRFbGVtZW50SG92ZXJTdGwoY2hpbGQsIGhvdmVyU3R5bGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICA6IHNldEVsZW1lbnRIb3ZlclN0bChlbCwgaG92ZXJTdHlsZSk7XHJcbiAgICAgICAgLy8gUmVtb3ZlIHByZXZpb3VzIGJvdW5kIGhhbmRsZXJzXHJcbiAgICAgICAgZWwub24oJ21vdXNlb3ZlcicsIG9uRWxlbWVudE1vdXNlT3ZlcilcclxuICAgICAgICAgIC5vbignbW91c2VvdXQnLCBvbkVsZW1lbnRNb3VzZU91dCk7XHJcblxyXG4gICAgICAgIC8vIEVtcGhhc2lzLCBub3JtYWwgY2FuIGJlIHRyaWdnZXJlZCBtYW51YWxseVxyXG4gICAgICAgIGVsLm9uKCdlbXBoYXNpcycsIGVudGVyRW1waGFzaXMpXHJcbiAgICAgICAgICAub24oJ25vcm1hbCcsIGxlYXZlRW1waGFzaXMpO1xyXG4gICAgfTtcclxuXHJcbiAgICBncmFwaGljLnNldE5vcm1hbFN0eWxlID0gZnVuY3Rpb24oZWwsIG9wdGlvbnMpIHtcclxuICAgICAgICBpZiAoZWwuX19ub3JtYWxTdGwpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgbmFtZSBpbiBvcHRpb25zKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZWwuX19ub3JtYWxTdGwuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBlbC5fX25vcm1hbFN0bFtuYW1lXSA9IG9wdGlvbnNbbmFtZV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IHRleHQgb3B0aW9uIGluIHRoZSBzdHlsZVxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHRleHRTdHlsZVxyXG4gICAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9Nb2RlbH0gbGFiZWxNb2RlbFxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbG9yXHJcbiAgICAgKi9cclxuICAgIGdyYXBoaWMuc2V0VGV4dCA9IGZ1bmN0aW9uICh0ZXh0U3R5bGUsIGxhYmVsTW9kZWwsIGNvbG9yKSB7XHJcbiAgICAgICAgdmFyIGxhYmVsUG9zaXRpb24gPSBsYWJlbE1vZGVsLmdldFNoYWxsb3coJ3Bvc2l0aW9uJykgfHwgJ2luc2lkZSc7XHJcbiAgICAgICAgdmFyIGxhYmVsQ29sb3IgPSBsYWJlbFBvc2l0aW9uLmluZGV4T2YoJ2luc2lkZScpID49IDAgPyAnd2hpdGUnIDogY29sb3I7XHJcbiAgICAgICAgdmFyIHRleHRTdHlsZU1vZGVsID0gbGFiZWxNb2RlbC5nZXRNb2RlbCgndGV4dFN0eWxlJyk7XHJcbiAgICAgICAgenJVdGlsLmV4dGVuZCh0ZXh0U3R5bGUsIHtcclxuICAgICAgICAgICAgdGV4dERpc3RhbmNlOiBsYWJlbE1vZGVsLmdldFNoYWxsb3coJ2Rpc3RhbmNlJykgfHwgNSxcclxuICAgICAgICAgICAgdGV4dEZvbnQ6IHRleHRTdHlsZU1vZGVsLmdldEZvbnQoKSxcclxuICAgICAgICAgICAgdGV4dFBvc2l0aW9uOiBsYWJlbFBvc2l0aW9uLFxyXG4gICAgICAgICAgICB0ZXh0RmlsbDogdGV4dFN0eWxlTW9kZWwuZ2V0VGV4dENvbG9yKCkgfHwgbGFiZWxDb2xvclxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICBmdW5jdGlvbiBhbmltYXRlT3JTZXRQcm9wcyhpc1VwZGF0ZSwgZWwsIHByb3BzLCBhbmltYXRhYmxlTW9kZWwsIGNiKSB7XHJcbiAgICAgICAgdmFyIHBvc3RmaXggPSBpc1VwZGF0ZSA/ICdVcGRhdGUnIDogJyc7XHJcbiAgICAgICAgdmFyIGR1cmF0aW9uID0gYW5pbWF0YWJsZU1vZGVsXHJcbiAgICAgICAgICAgICYmIGFuaW1hdGFibGVNb2RlbC5nZXRTaGFsbG93KCdhbmltYXRpb25EdXJhdGlvbicgKyBwb3N0Zml4KTtcclxuICAgICAgICB2YXIgYW5pbWF0aW9uRWFzaW5nID0gYW5pbWF0YWJsZU1vZGVsXHJcbiAgICAgICAgICAgICYmIGFuaW1hdGFibGVNb2RlbC5nZXRTaGFsbG93KCdhbmltYXRpb25FYXNpbmcnICsgcG9zdGZpeCk7XHJcblxyXG4gICAgICAgIGFuaW1hdGFibGVNb2RlbCAmJiBhbmltYXRhYmxlTW9kZWwuZ2V0U2hhbGxvdygnYW5pbWF0aW9uJylcclxuICAgICAgICAgICAgPyBlbC5hbmltYXRlVG8ocHJvcHMsIGR1cmF0aW9uLCBhbmltYXRpb25FYXNpbmcsIGNiKVxyXG4gICAgICAgICAgICA6IChlbC5hdHRyKHByb3BzKSwgY2IgJiYgY2IoKSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZSBncmFwaGljIGVsZW1lbnQgcHJvcGVydGllcyB3aXRoIG9yIHdpdGhvdXQgYW5pbWF0aW9uIGFjY29yZGluZyB0byB0aGUgY29uZmlndXJhdGlvbiBpbiBzZXJpZXNcclxuICAgICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvRWxlbWVudH0gZWxcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wc1xyXG4gICAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9Nb2RlbH0gW2FuaW1hdGFibGVNb2RlbF1cclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiXHJcbiAgICAgKi9cclxuICAgIGdyYXBoaWMudXBkYXRlUHJvcHMgPSB6clV0aWwuY3VycnkoYW5pbWF0ZU9yU2V0UHJvcHMsIHRydWUpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogSW5pdCBncmFwaGljIGVsZW1lbnQgcHJvcGVydGllcyB3aXRoIG9yIHdpdGhvdXQgYW5pbWF0aW9uIGFjY29yZGluZyB0byB0aGUgY29uZmlndXJhdGlvbiBpbiBzZXJpZXNcclxuICAgICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvRWxlbWVudH0gZWxcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wc1xyXG4gICAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9Nb2RlbH0gW2FuaW1hdGFibGVNb2RlbF1cclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiXHJcbiAgICAgKi9cclxuICAgIGdyYXBoaWMuaW5pdFByb3BzID0genJVdGlsLmN1cnJ5KGFuaW1hdGVPclNldFByb3BzLCBmYWxzZSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdHJhbnNmb3JtIG1hdHJpeCBvZiB0YXJnZXQgKHBhcmFtIHRhcmdldCksXHJcbiAgICAgKiBpbiBjb29yZGluYXRlIG9mIGl0cyBhbmNlc3RvciAocGFyYW0gYW5jZXN0b3IpXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9taXhpbi9UcmFuc2Zvcm1hYmxlfSB0YXJnZXRcclxuICAgICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvbWl4aW4vVHJhbnNmb3JtYWJsZX0gYW5jZXN0b3JcclxuICAgICAqL1xyXG4gICAgZ3JhcGhpYy5nZXRUcmFuc2Zvcm0gPSBmdW5jdGlvbiAodGFyZ2V0LCBhbmNlc3Rvcikge1xyXG4gICAgICAgIHZhciBtYXQgPSBtYXRyaXguaWRlbnRpdHkoW10pO1xyXG5cclxuICAgICAgICB3aGlsZSAodGFyZ2V0ICYmIHRhcmdldCAhPT0gYW5jZXN0b3IpIHtcclxuICAgICAgICAgICAgbWF0cml4Lm11bChtYXQsIHRhcmdldC5nZXRMb2NhbFRyYW5zZm9ybSgpLCBtYXQpO1xyXG4gICAgICAgICAgICB0YXJnZXQgPSB0YXJnZXQucGFyZW50O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIG1hdDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBcHBseSB0cmFuc2Zvcm0gdG8gYW4gdmVydGV4LlxyXG4gICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gdmVydGV4IFt4LCB5XVxyXG4gICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gdHJhbnNmb3JtIFRyYW5zZm9ybSBtYXRyaXg6IGxpa2UgWzEsIDAsIDAsIDEsIDAsIDBdXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBpbnZlcnQgV2hldGhlciB1c2UgaW52ZXJ0IG1hdHJpeC5cclxuICAgICAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fSBbeCwgeV1cclxuICAgICAqL1xyXG4gICAgZ3JhcGhpYy5hcHBseVRyYW5zZm9ybSA9IGZ1bmN0aW9uICh2ZXJ0ZXgsIHRyYW5zZm9ybSwgaW52ZXJ0KSB7XHJcbiAgICAgICAgaWYgKGludmVydCkge1xyXG4gICAgICAgICAgICB0cmFuc2Zvcm0gPSBtYXRyaXguaW52ZXJ0KFtdLCB0cmFuc2Zvcm0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdmVjdG9yLmFwcGx5VHJhbnNmb3JtKFtdLCB2ZXJ0ZXgsIHRyYW5zZm9ybSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGRpcmVjdGlvbiAnbGVmdCcgJ3JpZ2h0JyAndG9wJyAnYm90dG9tJ1xyXG4gICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gdHJhbnNmb3JtIFRyYW5zZm9ybSBtYXRyaXg6IGxpa2UgWzEsIDAsIDAsIDEsIDAsIDBdXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBpbnZlcnQgV2hldGhlciB1c2UgaW52ZXJ0IG1hdHJpeC5cclxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gVHJhbnNmb3JtZWQgZGlyZWN0aW9uLiAnbGVmdCcgJ3JpZ2h0JyAndG9wJyAnYm90dG9tJ1xyXG4gICAgICovXHJcbiAgICBncmFwaGljLnRyYW5zZm9ybURpcmVjdGlvbiA9IGZ1bmN0aW9uIChkaXJlY3Rpb24sIHRyYW5zZm9ybSwgaW52ZXJ0KSB7XHJcblxyXG4gICAgICAgIC8vIFBpY2sgYSBiYXNlLCBlbnN1cmUgdGhhdCB0cmFuc2Zvcm0gcmVzdWx0IHdpbGwgbm90IGJlICgwLCAwKS5cclxuICAgICAgICB2YXIgaEJhc2UgPSAodHJhbnNmb3JtWzRdID09PSAwIHx8IHRyYW5zZm9ybVs1XSA9PT0gMCB8fCB0cmFuc2Zvcm1bMF0gPT09IDApXHJcbiAgICAgICAgICAgID8gMSA6IE1hdGguYWJzKDIgKiB0cmFuc2Zvcm1bNF0gLyB0cmFuc2Zvcm1bMF0pO1xyXG4gICAgICAgIHZhciB2QmFzZSA9ICh0cmFuc2Zvcm1bNF0gPT09IDAgfHwgdHJhbnNmb3JtWzVdID09PSAwIHx8IHRyYW5zZm9ybVsyXSA9PT0gMClcclxuICAgICAgICAgICAgPyAxIDogTWF0aC5hYnMoMiAqIHRyYW5zZm9ybVs0XSAvIHRyYW5zZm9ybVsyXSk7XHJcblxyXG4gICAgICAgIHZhciB2ZXJ0ZXggPSBbXHJcbiAgICAgICAgICAgIGRpcmVjdGlvbiA9PT0gJ2xlZnQnID8gLWhCYXNlIDogZGlyZWN0aW9uID09PSAncmlnaHQnID8gaEJhc2UgOiAwLFxyXG4gICAgICAgICAgICBkaXJlY3Rpb24gPT09ICd0b3AnID8gLXZCYXNlIDogZGlyZWN0aW9uID09PSAnYm90dG9tJyA/IHZCYXNlIDogMFxyXG4gICAgICAgIF07XHJcblxyXG4gICAgICAgIHZlcnRleCA9IGdyYXBoaWMuYXBwbHlUcmFuc2Zvcm0odmVydGV4LCB0cmFuc2Zvcm0sIGludmVydCk7XHJcblxyXG4gICAgICAgIHJldHVybiBNYXRoLmFicyh2ZXJ0ZXhbMF0pID4gTWF0aC5hYnModmVydGV4WzFdKVxyXG4gICAgICAgICAgICA/ICh2ZXJ0ZXhbMF0gPiAwID8gJ3JpZ2h0JyA6ICdsZWZ0JylcclxuICAgICAgICAgICAgOiAodmVydGV4WzFdID4gMCA/ICdib3R0b20nIDogJ3RvcCcpO1xyXG4gICAgfTtcclxuXHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGdyYXBoaWM7XHJcblxyXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vbGliL2Zpc2gtdG9wby1jb3JlL2xpYi9ncmFwaGljLmpzXG4gKiogbW9kdWxlIGlkID0gM1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBAbW9kdWxlIHpyZW5kZXIvY29yZS91dGlsXG4gKi9cblxuXG4gICAgLy8g55So5LqO5aSE55CGbWVyZ2Xml7bml6Dms5XpgY3ljoZEYXRl562J5a+56LGh55qE6Zeu6aKYXG4gICAgdmFyIEJVSUxUSU5fT0JKRUNUID0ge1xuICAgICAgICAnW29iamVjdCBGdW5jdGlvbl0nOiAxLFxuICAgICAgICAnW29iamVjdCBSZWdFeHBdJzogMSxcbiAgICAgICAgJ1tvYmplY3QgRGF0ZV0nOiAxLFxuICAgICAgICAnW29iamVjdCBFcnJvcl0nOiAxLFxuICAgICAgICAnW29iamVjdCBDYW52YXNHcmFkaWVudF0nOiAxLFxuICAgICAgICAnW29iamVjdCBDYW52YXNQYXR0ZXJuXSc6IDEsXG4gICAgICAgIC8vIEluIG5vZGUtY2FudmFzIEltYWdlIGNhbiBiZSBDYW52YXMuSW1hZ2VcbiAgICAgICAgJ1tvYmplY3QgSW1hZ2VdJzogMVxuICAgIH07XG5cbiAgICB2YXIgb2JqVG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG4gICAgdmFyIGFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XG4gICAgdmFyIG5hdGl2ZUZvckVhY2ggPSBhcnJheVByb3RvLmZvckVhY2g7XG4gICAgdmFyIG5hdGl2ZUZpbHRlciA9IGFycmF5UHJvdG8uZmlsdGVyO1xuICAgIHZhciBuYXRpdmVTbGljZSA9IGFycmF5UHJvdG8uc2xpY2U7XG4gICAgdmFyIG5hdGl2ZU1hcCA9IGFycmF5UHJvdG8ubWFwO1xuICAgIHZhciBuYXRpdmVSZWR1Y2UgPSBhcnJheVByb3RvLnJlZHVjZTtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Kn0gc291cmNlXG4gICAgICogQHJldHVybiB7Kn0g5ou36LSd5ZCO55qE5paw5a+56LGhXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2xvbmUoc291cmNlKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc291cmNlID09ICdvYmplY3QnICYmIHNvdXJjZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHNvdXJjZTtcbiAgICAgICAgICAgIGlmIChzb3VyY2UgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBzb3VyY2UubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2ldID0gY2xvbmUoc291cmNlW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChcbiAgICAgICAgICAgICAgICAhaXNCdWlsZEluT2JqZWN0KHNvdXJjZSlcbiAgICAgICAgICAgICAgICAvLyDmmK/lkKbkuLogZG9tIOWvueixoVxuICAgICAgICAgICAgICAgICYmICFpc0RvbShzb3VyY2UpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB7fTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzb3VyY2UuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2tleV0gPSBjbG9uZShzb3VyY2Vba2V5XSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc291cmNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL3V0aWxcbiAgICAgKiBAcGFyYW0geyp9IHRhcmdldFxuICAgICAqIEBwYXJhbSB7Kn0gc291cmNlXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3ZlcndyaXRlPWZhbHNlXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1lcmdlKHRhcmdldCwgc291cmNlLCBvdmVyd3JpdGUpIHtcbiAgICAgICAgLy8gV2Ugc2hvdWxkIGVzY2Fwc2UgdGhhdCBzb3VyY2UgaXMgc3RyaW5nXG4gICAgICAgIC8vIGFuZCBlbnRlciBmb3IgLi4uIGluIC4uLlxuICAgICAgICBpZiAoIWlzT2JqZWN0KHNvdXJjZSkgfHwgIWlzT2JqZWN0KHRhcmdldCkpIHtcbiAgICAgICAgICAgIHJldHVybiBvdmVyd3JpdGUgPyBjbG9uZShzb3VyY2UpIDogdGFyZ2V0O1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICAgICAgaWYgKHNvdXJjZS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRhcmdldFByb3AgPSB0YXJnZXRba2V5XTtcbiAgICAgICAgICAgICAgICB2YXIgc291cmNlUHJvcCA9IHNvdXJjZVtrZXldO1xuXG4gICAgICAgICAgICAgICAgaWYgKGlzT2JqZWN0KHNvdXJjZVByb3ApXG4gICAgICAgICAgICAgICAgICAgICYmIGlzT2JqZWN0KHRhcmdldFByb3ApXG4gICAgICAgICAgICAgICAgICAgICYmICFpc0FycmF5KHNvdXJjZVByb3ApXG4gICAgICAgICAgICAgICAgICAgICYmICFpc0FycmF5KHRhcmdldFByb3ApXG4gICAgICAgICAgICAgICAgICAgICYmICFpc0RvbShzb3VyY2VQcm9wKVxuICAgICAgICAgICAgICAgICAgICAmJiAhaXNEb20odGFyZ2V0UHJvcClcbiAgICAgICAgICAgICAgICAgICAgJiYgIWlzQnVpbGRJbk9iamVjdChzb3VyY2VQcm9wKVxuICAgICAgICAgICAgICAgICAgICAmJiAhaXNCdWlsZEluT2JqZWN0KHRhcmdldFByb3ApXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIOWmguaenOmcgOimgemAkuW9kuimhueblu+8jOWwsemAkuW9kuiwg+eUqG1lcmdlXG4gICAgICAgICAgICAgICAgICAgIG1lcmdlKHRhcmdldFByb3AsIHNvdXJjZVByb3AsIG92ZXJ3cml0ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG92ZXJ3cml0ZSB8fCAhKGtleSBpbiB0YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIOWQpuWImeWPquWkhOeQhm92ZXJ3cml0ZeS4unRydWXvvIzmiJbogIXlnKjnm67moIflr7nosaHkuK3msqHmnInmraTlsZ7mgKfnmoTmg4XlhrVcbiAgICAgICAgICAgICAgICAgICAgLy8gTk9URe+8jOWcqCB0YXJnZXRba2V5XSDkuI3lrZjlnKjnmoTml7blgJnkuZ/mmK/nm7TmjqXopobnm5ZcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBjbG9uZShzb3VyY2Vba2V5XSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0FycmF5fSB0YXJnZXRBbmRTb3VyY2VzIFRoZSBmaXJzdCBpdGVtIGlzIHRhcmdldCwgYW5kIHRoZSByZXN0cyBhcmUgc291cmNlLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW292ZXJ3cml0ZT1mYWxzZV1cbiAgICAgKiBAcmV0dXJuIHsqfSB0YXJnZXRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtZXJnZUFsbCh0YXJnZXRBbmRTb3VyY2VzLCBvdmVyd3JpdGUpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRhcmdldEFuZFNvdXJjZXNbMF07XG4gICAgICAgIGZvciAodmFyIGkgPSAxLCBsZW4gPSB0YXJnZXRBbmRTb3VyY2VzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBtZXJnZShyZXN1bHQsIHRhcmdldEFuZFNvdXJjZXNbaV0sIG92ZXJ3cml0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyp9IHRhcmdldFxuICAgICAqIEBwYXJhbSB7Kn0gc291cmNlXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGV4dGVuZCh0YXJnZXQsIHNvdXJjZSkge1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgICAgICBpZiAoc291cmNlLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHsqfSB0YXJnZXRcbiAgICAgKiBAcGFyYW0geyp9IHNvdXJjZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVufSBbb3ZlcmxheT1mYWxzZV1cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gICAgICovXG4gICAgZnVuY3Rpb24gZGVmYXVsdHModGFyZ2V0LCBzb3VyY2UsIG92ZXJsYXkpIHtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICAgICAgaWYgKHNvdXJjZS5oYXNPd25Qcm9wZXJ0eShrZXkpXG4gICAgICAgICAgICAgICAgJiYgKG92ZXJsYXkgPyBzb3VyY2Vba2V5XSAhPSBudWxsIDogdGFyZ2V0W2tleV0gPT0gbnVsbClcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVDYW52YXMoKSB7XG4gICAgICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICB9XG4gICAgLy8gRklYTUVcbiAgICB2YXIgX2N0eDtcbiAgICBmdW5jdGlvbiBnZXRDb250ZXh0KCkge1xuICAgICAgICBpZiAoIV9jdHgpIHtcbiAgICAgICAgICAgIC8vIFVzZSB1dGlsLmNyZWF0ZUNhbnZhcyBpbnN0ZWFkIG9mIGNyZWF0ZUNhbnZhc1xuICAgICAgICAgICAgLy8gYmVjYXVzZSBjcmVhdGVDYW52YXMgbWF5IGJlIG92ZXJ3cml0dGVuIGluIGRpZmZlcmVudCBlbnZpcm9ubWVudFxuICAgICAgICAgICAgX2N0eCA9IHV0aWwuY3JlYXRlQ2FudmFzKCkuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX2N0eDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDmn6Xor6LmlbDnu4TkuK3lhYPntKDnmoRpbmRleFxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL3V0aWxcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbmRleE9mKGFycmF5LCB2YWx1ZSkge1xuICAgICAgICBpZiAoYXJyYXkpIHtcbiAgICAgICAgICAgIGlmIChhcnJheS5pbmRleE9mKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFycmF5LmluZGV4T2YodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGFycmF5Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFycmF5W2ldID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOaehOmAoOexu+e7p+aJv+WFs+ezu1xuICAgICAqXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNsYXp6IOa6kOexu1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGJhc2VDbGF6eiDln7rnsbtcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbmhlcml0cyhjbGF6eiwgYmFzZUNsYXp6KSB7XG4gICAgICAgIHZhciBjbGF6elByb3RvdHlwZSA9IGNsYXp6LnByb3RvdHlwZTtcbiAgICAgICAgZnVuY3Rpb24gRigpIHt9XG4gICAgICAgIEYucHJvdG90eXBlID0gYmFzZUNsYXp6LnByb3RvdHlwZTtcbiAgICAgICAgY2xhenoucHJvdG90eXBlID0gbmV3IEYoKTtcblxuICAgICAgICBmb3IgKHZhciBwcm9wIGluIGNsYXp6UHJvdG90eXBlKSB7XG4gICAgICAgICAgICBjbGF6ei5wcm90b3R5cGVbcHJvcF0gPSBjbGF6elByb3RvdHlwZVtwcm9wXTtcbiAgICAgICAgfVxuICAgICAgICBjbGF6ei5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjbGF6ejtcbiAgICAgICAgY2xhenouc3VwZXJDbGFzcyA9IGJhc2VDbGF6ejtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gICAgICogQHBhcmFtIHtPYmplY3R8RnVuY3Rpb259IHRhcmdldFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fEZ1bmN0aW9ufSBzb3JjZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gb3ZlcmxheVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1peGluKHRhcmdldCwgc291cmNlLCBvdmVybGF5KSB7XG4gICAgICAgIHRhcmdldCA9ICdwcm90b3R5cGUnIGluIHRhcmdldCA/IHRhcmdldC5wcm90b3R5cGUgOiB0YXJnZXQ7XG4gICAgICAgIHNvdXJjZSA9ICdwcm90b3R5cGUnIGluIHNvdXJjZSA/IHNvdXJjZS5wcm90b3R5cGUgOiBzb3VyY2U7XG5cbiAgICAgICAgZGVmYXVsdHModGFyZ2V0LCBzb3VyY2UsIG92ZXJsYXkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7QXJyYXl8VHlwZWRBcnJheX0gZGF0YVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzQXJyYXlMaWtlKGRhdGEpIHtcbiAgICAgICAgaWYgKCEgZGF0YSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZGF0YSA9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0eXBlb2YgZGF0YS5sZW5ndGggPT0gJ251bWJlcic7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog5pWw57uE5oiW5a+56LGh6YGN5Y6GXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fEFycmF5fSBvYmpcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYlxuICAgICAqIEBwYXJhbSB7Kn0gW2NvbnRleHRdXG4gICAgICovXG4gICAgZnVuY3Rpb24gZWFjaChvYmosIGNiLCBjb250ZXh0KSB7XG4gICAgICAgIGlmICghKG9iaiAmJiBjYikpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2JqLmZvckVhY2ggJiYgb2JqLmZvckVhY2ggPT09IG5hdGl2ZUZvckVhY2gpIHtcbiAgICAgICAgICAgIG9iai5mb3JFYWNoKGNiLCBjb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvYmoubGVuZ3RoID09PSArb2JqLmxlbmd0aCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IG9iai5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGNiLmNhbGwoY29udGV4dCwgb2JqW2ldLCBpLCBvYmopO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBjYi5jYWxsKGNvbnRleHQsIG9ialtrZXldLCBrZXksIG9iaik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog5pWw57uE5pig5bCEXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IG9ialxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiXG4gICAgICogQHBhcmFtIHsqfSBbY29udGV4dF1cbiAgICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXAob2JqLCBjYiwgY29udGV4dCkge1xuICAgICAgICBpZiAoIShvYmogJiYgY2IpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9iai5tYXAgJiYgb2JqLm1hcCA9PT0gbmF0aXZlTWFwKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqLm1hcChjYiwgY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gb2JqLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goY2IuY2FsbChjb250ZXh0LCBvYmpbaV0sIGksIG9iaikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL3V0aWxcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBvYmpcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbbWVtb11cbiAgICAgKiBAcGFyYW0geyp9IFtjb250ZXh0XVxuICAgICAqIEByZXR1cm4ge0FycmF5fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlZHVjZShvYmosIGNiLCBtZW1vLCBjb250ZXh0KSB7XG4gICAgICAgIGlmICghKG9iaiAmJiBjYikpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2JqLnJlZHVjZSAmJiBvYmoucmVkdWNlID09PSBuYXRpdmVSZWR1Y2UpIHtcbiAgICAgICAgICAgIHJldHVybiBvYmoucmVkdWNlKGNiLCBtZW1vLCBjb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBvYmoubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBtZW1vID0gY2IuY2FsbChjb250ZXh0LCBtZW1vLCBvYmpbaV0sIGksIG9iaik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWVtbztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOaVsOe7hOi/h+a7pFxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL3V0aWxcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBvYmpcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYlxuICAgICAqIEBwYXJhbSB7Kn0gW2NvbnRleHRdXG4gICAgICogQHJldHVybiB7QXJyYXl9XG4gICAgICovXG4gICAgZnVuY3Rpb24gZmlsdGVyKG9iaiwgY2IsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKCEob2JqICYmIGNiKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvYmouZmlsdGVyICYmIG9iai5maWx0ZXIgPT09IG5hdGl2ZUZpbHRlcikge1xuICAgICAgICAgICAgcmV0dXJuIG9iai5maWx0ZXIoY2IsIGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IG9iai5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChjYi5jYWxsKGNvbnRleHQsIG9ialtpXSwgaSwgb2JqKSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChvYmpbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDmlbDnu4Tpobnmn6Xmib5cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gICAgICogQHBhcmFtIHtBcnJheX0gb2JqXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcbiAgICAgKiBAcGFyYW0geyp9IFtjb250ZXh0XVxuICAgICAqIEByZXR1cm4ge0FycmF5fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZpbmQob2JqLCBjYiwgY29udGV4dCkge1xuICAgICAgICBpZiAoIShvYmogJiYgY2IpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IG9iai5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgaWYgKGNiLmNhbGwoY29udGV4dCwgb2JqW2ldLCBpLCBvYmopKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9ialtpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL3V0aWxcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jXG4gICAgICogQHBhcmFtIHsqfSBjb250ZXh0XG4gICAgICogQHJldHVybiB7RnVuY3Rpb259XG4gICAgICovXG4gICAgZnVuY3Rpb24gYmluZChmdW5jLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBhcmdzID0gbmF0aXZlU2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncy5jb25jYXQobmF0aXZlU2xpY2UuY2FsbChhcmd1bWVudHMpKSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmNcbiAgICAgKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjdXJyeShmdW5jKSB7XG4gICAgICAgIHZhciBhcmdzID0gbmF0aXZlU2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpcywgYXJncy5jb25jYXQobmF0aXZlU2xpY2UuY2FsbChhcmd1bWVudHMpKSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzQXJyYXkodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIG9ialRvU3RyaW5nLmNhbGwodmFsdWUpID09PSAnW29iamVjdCBBcnJheV0nO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL3V0aWxcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbic7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzU3RyaW5nKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBvYmpUb1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgU3RyaW5nXSc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gICAgICAgIC8vIEF2b2lkIGEgVjggSklUIGJ1ZyBpbiBDaHJvbWUgMTktMjAuXG4gICAgICAgIC8vIFNlZSBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MjI5MSBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAgICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIHR5cGUgPT09ICdmdW5jdGlvbicgfHwgKCEhdmFsdWUgJiYgdHlwZSA9PSAnb2JqZWN0Jyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzQnVpbGRJbk9iamVjdCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gISFCVUlMVElOX09CSkVDVFtvYmpUb1N0cmluZy5jYWxsKHZhbHVlKV07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzRG9tKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSAmJiB2YWx1ZS5ub2RlVHlwZSA9PT0gMVxuICAgICAgICAgICAgICAgJiYgdHlwZW9mKHZhbHVlLm5vZGVOYW1lKSA9PSAnc3RyaW5nJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJZiB2YWx1ZTEgaXMgbm90IG51bGwsIHRoZW4gcmV0dXJuIHZhbHVlMSwgb3RoZXJ3aXNlIGp1ZGdldCByZXN0IG9mIHZhbHVlcy5cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gICAgICogQHJldHVybiB7Kn0gRmluYWwgdmFsdWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZXRyaWV2ZSh2YWx1ZXMpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgaWYgKGFyZ3VtZW50c1tpXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL3V0aWxcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnRJbmRleFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBlbmRJbmRleFxuICAgICAqIEByZXR1cm4ge0FycmF5fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNsaWNlKCkge1xuICAgICAgICByZXR1cm4gRnVuY3Rpb24uY2FsbC5hcHBseShuYXRpdmVTbGljZSwgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gICAgICogQHBhcmFtIHtib29sZWFufSBjb25kaXRpb25cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFzc2VydChjb25kaXRpb24sIG1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKCFjb25kaXRpb24pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciB1dGlsID0ge1xuICAgICAgICBpbmhlcml0czogaW5oZXJpdHMsXG4gICAgICAgIG1peGluOiBtaXhpbixcbiAgICAgICAgY2xvbmU6IGNsb25lLFxuICAgICAgICBtZXJnZTogbWVyZ2UsXG4gICAgICAgIG1lcmdlQWxsOiBtZXJnZUFsbCxcbiAgICAgICAgZXh0ZW5kOiBleHRlbmQsXG4gICAgICAgIGRlZmF1bHRzOiBkZWZhdWx0cyxcbiAgICAgICAgZ2V0Q29udGV4dDogZ2V0Q29udGV4dCxcbiAgICAgICAgY3JlYXRlQ2FudmFzOiBjcmVhdGVDYW52YXMsXG4gICAgICAgIGluZGV4T2Y6IGluZGV4T2YsXG4gICAgICAgIHNsaWNlOiBzbGljZSxcbiAgICAgICAgZmluZDogZmluZCxcbiAgICAgICAgaXNBcnJheUxpa2U6IGlzQXJyYXlMaWtlLFxuICAgICAgICBlYWNoOiBlYWNoLFxuICAgICAgICBtYXA6IG1hcCxcbiAgICAgICAgcmVkdWNlOiByZWR1Y2UsXG4gICAgICAgIGZpbHRlcjogZmlsdGVyLFxuICAgICAgICBiaW5kOiBiaW5kLFxuICAgICAgICBjdXJyeTogY3VycnksXG4gICAgICAgIGlzQXJyYXk6IGlzQXJyYXksXG4gICAgICAgIGlzU3RyaW5nOiBpc1N0cmluZyxcbiAgICAgICAgaXNPYmplY3Q6IGlzT2JqZWN0LFxuICAgICAgICBpc0Z1bmN0aW9uOiBpc0Z1bmN0aW9uLFxuICAgICAgICBpc0J1aWxkSW5PYmplY3Q6IGlzQnVpbGRJbk9iamVjdCxcbiAgICAgICAgaXNEb206IGlzRG9tLFxuICAgICAgICByZXRyaWV2ZTogcmV0cmlldmUsXG4gICAgICAgIGFzc2VydDogYXNzZXJ0LFxuICAgICAgICBub29wOiBmdW5jdGlvbiAoKSB7fVxuICAgIH07XG4gICAgbW9kdWxlLmV4cG9ydHMgPSB1dGlsO1xuXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi96cmVuZGVyL2xpYi9jb3JlL3V0aWwuanNcbiAqKiBtb2R1bGUgaWQgPSA0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcblxuICAgIHZhciBQYXRoID0gcmVxdWlyZSgnLi4vZ3JhcGhpYy9QYXRoJyk7XG4gICAgdmFyIFBhdGhQcm94eSA9IHJlcXVpcmUoJy4uL2NvcmUvUGF0aFByb3h5Jyk7XG4gICAgdmFyIHRyYW5zZm9ybVBhdGggPSByZXF1aXJlKCcuL3RyYW5zZm9ybVBhdGgnKTtcbiAgICB2YXIgbWF0cml4ID0gcmVxdWlyZSgnLi4vY29yZS9tYXRyaXgnKTtcblxuICAgIC8vIGNvbW1hbmQgY2hhcnNcbiAgICB2YXIgY2MgPSBbXG4gICAgICAgICdtJywgJ00nLCAnbCcsICdMJywgJ3YnLCAnVicsICdoJywgJ0gnLCAneicsICdaJyxcbiAgICAgICAgJ2MnLCAnQycsICdxJywgJ1EnLCAndCcsICdUJywgJ3MnLCAnUycsICdhJywgJ0EnXG4gICAgXTtcblxuICAgIHZhciBtYXRoU3FydCA9IE1hdGguc3FydDtcbiAgICB2YXIgbWF0aFNpbiA9IE1hdGguc2luO1xuICAgIHZhciBtYXRoQ29zID0gTWF0aC5jb3M7XG4gICAgdmFyIFBJID0gTWF0aC5QSTtcblxuICAgIHZhciB2TWFnID0gZnVuY3Rpb24odikge1xuICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KHZbMF0gKiB2WzBdICsgdlsxXSAqIHZbMV0pO1xuICAgIH07XG4gICAgdmFyIHZSYXRpbyA9IGZ1bmN0aW9uKHUsIHYpIHtcbiAgICAgICAgcmV0dXJuICh1WzBdICogdlswXSArIHVbMV0gKiB2WzFdKSAvICh2TWFnKHUpICogdk1hZyh2KSk7XG4gICAgfTtcbiAgICB2YXIgdkFuZ2xlID0gZnVuY3Rpb24odSwgdikge1xuICAgICAgICByZXR1cm4gKHVbMF0gKiB2WzFdIDwgdVsxXSAqIHZbMF0gPyAtMSA6IDEpXG4gICAgICAgICAgICAgICAgKiBNYXRoLmFjb3ModlJhdGlvKHUsIHYpKTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gcHJvY2Vzc0FyYyh4MSwgeTEsIHgyLCB5MiwgZmEsIGZzLCByeCwgcnksIHBzaURlZywgY21kLCBwYXRoKSB7XG4gICAgICAgIHZhciBwc2kgPSBwc2lEZWcgKiAoUEkgLyAxODAuMCk7XG4gICAgICAgIHZhciB4cCA9IG1hdGhDb3MocHNpKSAqICh4MSAtIHgyKSAvIDIuMFxuICAgICAgICAgICAgICAgICArIG1hdGhTaW4ocHNpKSAqICh5MSAtIHkyKSAvIDIuMDtcbiAgICAgICAgdmFyIHlwID0gLTEgKiBtYXRoU2luKHBzaSkgKiAoeDEgLSB4MikgLyAyLjBcbiAgICAgICAgICAgICAgICAgKyBtYXRoQ29zKHBzaSkgKiAoeTEgLSB5MikgLyAyLjA7XG5cbiAgICAgICAgdmFyIGxhbWJkYSA9ICh4cCAqIHhwKSAvIChyeCAqIHJ4KSArICh5cCAqIHlwKSAvIChyeSAqIHJ5KTtcblxuICAgICAgICBpZiAobGFtYmRhID4gMSkge1xuICAgICAgICAgICAgcnggKj0gbWF0aFNxcnQobGFtYmRhKTtcbiAgICAgICAgICAgIHJ5ICo9IG1hdGhTcXJ0KGxhbWJkYSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZiA9IChmYSA9PT0gZnMgPyAtMSA6IDEpXG4gICAgICAgICAgICAqIG1hdGhTcXJ0KCgoKHJ4ICogcngpICogKHJ5ICogcnkpKVxuICAgICAgICAgICAgICAgICAgICAtICgocnggKiByeCkgKiAoeXAgKiB5cCkpXG4gICAgICAgICAgICAgICAgICAgIC0gKChyeSAqIHJ5KSAqICh4cCAqIHhwKSkpIC8gKChyeCAqIHJ4KSAqICh5cCAqIHlwKVxuICAgICAgICAgICAgICAgICAgICArIChyeSAqIHJ5KSAqICh4cCAqIHhwKSlcbiAgICAgICAgICAgICAgICApIHx8IDA7XG5cbiAgICAgICAgdmFyIGN4cCA9IGYgKiByeCAqIHlwIC8gcnk7XG4gICAgICAgIHZhciBjeXAgPSBmICogLXJ5ICogeHAgLyByeDtcblxuICAgICAgICB2YXIgY3ggPSAoeDEgKyB4MikgLyAyLjBcbiAgICAgICAgICAgICAgICAgKyBtYXRoQ29zKHBzaSkgKiBjeHBcbiAgICAgICAgICAgICAgICAgLSBtYXRoU2luKHBzaSkgKiBjeXA7XG4gICAgICAgIHZhciBjeSA9ICh5MSArIHkyKSAvIDIuMFxuICAgICAgICAgICAgICAgICsgbWF0aFNpbihwc2kpICogY3hwXG4gICAgICAgICAgICAgICAgKyBtYXRoQ29zKHBzaSkgKiBjeXA7XG5cbiAgICAgICAgdmFyIHRoZXRhID0gdkFuZ2xlKFsgMSwgMCBdLCBbICh4cCAtIGN4cCkgLyByeCwgKHlwIC0gY3lwKSAvIHJ5IF0pO1xuICAgICAgICB2YXIgdSA9IFsgKHhwIC0gY3hwKSAvIHJ4LCAoeXAgLSBjeXApIC8gcnkgXTtcbiAgICAgICAgdmFyIHYgPSBbICgtMSAqIHhwIC0gY3hwKSAvIHJ4LCAoLTEgKiB5cCAtIGN5cCkgLyByeSBdO1xuICAgICAgICB2YXIgZFRoZXRhID0gdkFuZ2xlKHUsIHYpO1xuXG4gICAgICAgIGlmICh2UmF0aW8odSwgdikgPD0gLTEpIHtcbiAgICAgICAgICAgIGRUaGV0YSA9IFBJO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2UmF0aW8odSwgdikgPj0gMSkge1xuICAgICAgICAgICAgZFRoZXRhID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZnMgPT09IDAgJiYgZFRoZXRhID4gMCkge1xuICAgICAgICAgICAgZFRoZXRhID0gZFRoZXRhIC0gMiAqIFBJO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmcyA9PT0gMSAmJiBkVGhldGEgPCAwKSB7XG4gICAgICAgICAgICBkVGhldGEgPSBkVGhldGEgKyAyICogUEk7XG4gICAgICAgIH1cblxuICAgICAgICBwYXRoLmFkZERhdGEoY21kLCBjeCwgY3ksIHJ4LCByeSwgdGhldGEsIGRUaGV0YSwgcHNpLCBmcyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlUGF0aFByb3h5RnJvbVN0cmluZyhkYXRhKSB7XG4gICAgICAgIGlmICghZGF0YSkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY29tbWFuZCBzdHJpbmdcbiAgICAgICAgdmFyIGNzID0gZGF0YS5yZXBsYWNlKC8tL2csICcgLScpXG4gICAgICAgICAgICAucmVwbGFjZSgvICAvZywgJyAnKVxuICAgICAgICAgICAgLnJlcGxhY2UoLyAvZywgJywnKVxuICAgICAgICAgICAgLnJlcGxhY2UoLywsL2csICcsJyk7XG5cbiAgICAgICAgdmFyIG47XG4gICAgICAgIC8vIGNyZWF0ZSBwaXBlcyBzbyB0aGF0IHdlIGNhbiBzcGxpdCB0aGUgZGF0YVxuICAgICAgICBmb3IgKG4gPSAwOyBuIDwgY2MubGVuZ3RoOyBuKyspIHtcbiAgICAgICAgICAgIGNzID0gY3MucmVwbGFjZShuZXcgUmVnRXhwKGNjW25dLCAnZycpLCAnfCcgKyBjY1tuXSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjcmVhdGUgYXJyYXlcbiAgICAgICAgdmFyIGFyciA9IGNzLnNwbGl0KCd8Jyk7XG4gICAgICAgIC8vIGluaXQgY29udGV4dCBwb2ludFxuICAgICAgICB2YXIgY3B4ID0gMDtcbiAgICAgICAgdmFyIGNweSA9IDA7XG5cbiAgICAgICAgdmFyIHBhdGggPSBuZXcgUGF0aFByb3h5KCk7XG4gICAgICAgIHZhciBDTUQgPSBQYXRoUHJveHkuQ01EO1xuXG4gICAgICAgIHZhciBwcmV2Q21kO1xuICAgICAgICBmb3IgKG4gPSAxOyBuIDwgYXJyLmxlbmd0aDsgbisrKSB7XG4gICAgICAgICAgICB2YXIgc3RyID0gYXJyW25dO1xuICAgICAgICAgICAgdmFyIGMgPSBzdHIuY2hhckF0KDApO1xuICAgICAgICAgICAgdmFyIG9mZiA9IDA7XG4gICAgICAgICAgICB2YXIgcCA9IHN0ci5zbGljZSgxKS5yZXBsYWNlKC9lLC0vZywgJ2UtJykuc3BsaXQoJywnKTtcbiAgICAgICAgICAgIHZhciBjbWQ7XG5cbiAgICAgICAgICAgIGlmIChwLmxlbmd0aCA+IDAgJiYgcFswXSA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICBwLnNoaWZ0KCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHBbaV0gPSBwYXJzZUZsb2F0KHBbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUgKG9mZiA8IHAubGVuZ3RoICYmICFpc05hTihwW29mZl0pKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzTmFOKHBbMF0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgY3RsUHR4O1xuICAgICAgICAgICAgICAgIHZhciBjdGxQdHk7XG5cbiAgICAgICAgICAgICAgICB2YXIgcng7XG4gICAgICAgICAgICAgICAgdmFyIHJ5O1xuICAgICAgICAgICAgICAgIHZhciBwc2k7XG4gICAgICAgICAgICAgICAgdmFyIGZhO1xuICAgICAgICAgICAgICAgIHZhciBmcztcblxuICAgICAgICAgICAgICAgIHZhciB4MSA9IGNweDtcbiAgICAgICAgICAgICAgICB2YXIgeTEgPSBjcHk7XG5cbiAgICAgICAgICAgICAgICAvLyBjb252ZXJ0IGwsIEgsIGgsIFYsIGFuZCB2IHRvIExcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGMpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnbCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHggKz0gcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHkgKz0gcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgICAgICBjbWQgPSBDTUQuTDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGguYWRkRGF0YShjbWQsIGNweCwgY3B5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdMJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweCA9IHBbb2ZmKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3B5ID0gcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgICAgICBjbWQgPSBDTUQuTDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGguYWRkRGF0YShjbWQsIGNweCwgY3B5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdtJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweCArPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweSArPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNtZCA9IENNRC5NO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aC5hZGREYXRhKGNtZCwgY3B4LCBjcHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYyA9ICdsJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdNJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweCA9IHBbb2ZmKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3B5ID0gcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgICAgICBjbWQgPSBDTUQuTTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGguYWRkRGF0YShjbWQsIGNweCwgY3B5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMgPSAnTCc7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnaCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHggKz0gcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgICAgICBjbWQgPSBDTUQuTDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGguYWRkRGF0YShjbWQsIGNweCwgY3B5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdIJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweCA9IHBbb2ZmKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY21kID0gQ01ELkw7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoLmFkZERhdGEoY21kLCBjcHgsIGNweSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAndic6XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHkgKz0gcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgICAgICBjbWQgPSBDTUQuTDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGguYWRkRGF0YShjbWQsIGNweCwgY3B5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdWJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweSA9IHBbb2ZmKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY21kID0gQ01ELkw7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoLmFkZERhdGEoY21kLCBjcHgsIGNweSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnQyc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjbWQgPSBDTUQuQztcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGguYWRkRGF0YShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbWQsIHBbb2ZmKytdLCBwW29mZisrXSwgcFtvZmYrK10sIHBbb2ZmKytdLCBwW29mZisrXSwgcFtvZmYrK11cbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHggPSBwW29mZiAtIDJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3B5ID0gcFtvZmYgLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdjJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNtZCA9IENNRC5DO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aC5hZGREYXRhKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNtZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwW29mZisrXSArIGNweCwgcFtvZmYrK10gKyBjcHksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcFtvZmYrK10gKyBjcHgsIHBbb2ZmKytdICsgY3B5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBbb2ZmKytdICsgY3B4LCBwW29mZisrXSArIGNweVxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweCArPSBwW29mZiAtIDJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3B5ICs9IHBbb2ZmIC0gMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnUyc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjdGxQdHggPSBjcHg7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdGxQdHkgPSBjcHk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGVuID0gcGF0aC5sZW4oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXRoRGF0YSA9IHBhdGguZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcmV2Q21kID09PSBDTUQuQykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0bFB0eCArPSBjcHggLSBwYXRoRGF0YVtsZW4gLSA0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdGxQdHkgKz0gY3B5IC0gcGF0aERhdGFbbGVuIC0gM107XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjbWQgPSBDTUQuQztcbiAgICAgICAgICAgICAgICAgICAgICAgIHgxID0gcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgICAgICB5MSA9IHBbb2ZmKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3B4ID0gcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHkgPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGguYWRkRGF0YShjbWQsIGN0bFB0eCwgY3RsUHR5LCB4MSwgeTEsIGNweCwgY3B5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdzJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0bFB0eCA9IGNweDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0bFB0eSA9IGNweTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsZW4gPSBwYXRoLmxlbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhdGhEYXRhID0gcGF0aC5kYXRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByZXZDbWQgPT09IENNRC5DKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3RsUHR4ICs9IGNweCAtIHBhdGhEYXRhW2xlbiAtIDRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0bFB0eSArPSBjcHkgLSBwYXRoRGF0YVtsZW4gLSAzXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNtZCA9IENNRC5DO1xuICAgICAgICAgICAgICAgICAgICAgICAgeDEgPSBjcHggKyBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHkxID0gY3B5ICsgcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHggKz0gcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHkgKz0gcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoLmFkZERhdGEoY21kLCBjdGxQdHgsIGN0bFB0eSwgeDEsIHkxLCBjcHgsIGNweSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnUSc6XG4gICAgICAgICAgICAgICAgICAgICAgICB4MSA9IHBbb2ZmKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgeTEgPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweCA9IHBbb2ZmKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3B5ID0gcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgICAgICBjbWQgPSBDTUQuUTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGguYWRkRGF0YShjbWQsIHgxLCB5MSwgY3B4LCBjcHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3EnOlxuICAgICAgICAgICAgICAgICAgICAgICAgeDEgPSBwW29mZisrXSArIGNweDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHkxID0gcFtvZmYrK10gKyBjcHk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHggKz0gcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHkgKz0gcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgICAgICBjbWQgPSBDTUQuUTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGguYWRkRGF0YShjbWQsIHgxLCB5MSwgY3B4LCBjcHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ1QnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY3RsUHR4ID0gY3B4O1xuICAgICAgICAgICAgICAgICAgICAgICAgY3RsUHR5ID0gY3B5O1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxlbiA9IHBhdGgubGVuKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGF0aERhdGEgPSBwYXRoLmRhdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJldkNtZCA9PT0gQ01ELlEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdGxQdHggKz0gY3B4IC0gcGF0aERhdGFbbGVuIC0gNF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3RsUHR5ICs9IGNweSAtIHBhdGhEYXRhW2xlbiAtIDNdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY3B4ID0gcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHkgPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNtZCA9IENNRC5RO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aC5hZGREYXRhKGNtZCwgY3RsUHR4LCBjdGxQdHksIGNweCwgY3B5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICd0JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0bFB0eCA9IGNweDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0bFB0eSA9IGNweTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsZW4gPSBwYXRoLmxlbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhdGhEYXRhID0gcGF0aC5kYXRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByZXZDbWQgPT09IENNRC5RKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3RsUHR4ICs9IGNweCAtIHBhdGhEYXRhW2xlbiAtIDRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0bFB0eSArPSBjcHkgLSBwYXRoRGF0YVtsZW4gLSAzXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNweCArPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweSArPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNtZCA9IENNRC5RO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aC5hZGREYXRhKGNtZCwgY3RsUHR4LCBjdGxQdHksIGNweCwgY3B5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdBJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ4ID0gcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgICAgICByeSA9IHBbb2ZmKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHNpID0gcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgICAgICBmYSA9IHBbb2ZmKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZnMgPSBwW29mZisrXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgeDEgPSBjcHgsIHkxID0gY3B5O1xuICAgICAgICAgICAgICAgICAgICAgICAgY3B4ID0gcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHkgPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNtZCA9IENNRC5BO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvY2Vzc0FyYyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4MSwgeTEsIGNweCwgY3B5LCBmYSwgZnMsIHJ4LCByeSwgcHNpLCBjbWQsIHBhdGhcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnYSc6XG4gICAgICAgICAgICAgICAgICAgICAgICByeCA9IHBbb2ZmKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcnkgPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBzaSA9IHBbb2ZmKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZmEgPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZzID0gcFtvZmYrK107XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHgxID0gY3B4LCB5MSA9IGNweTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweCArPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweSArPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNtZCA9IENNRC5BO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvY2Vzc0FyYyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4MSwgeTEsIGNweCwgY3B5LCBmYSwgZnMsIHJ4LCByeSwgcHNpLCBjbWQsIHBhdGhcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChjID09PSAneicgfHwgYyA9PT0gJ1onKSB7XG4gICAgICAgICAgICAgICAgY21kID0gQ01ELlo7XG4gICAgICAgICAgICAgICAgcGF0aC5hZGREYXRhKGNtZCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHByZXZDbWQgPSBjbWQ7XG4gICAgICAgIH1cblxuICAgICAgICBwYXRoLnRvU3RhdGljKCk7XG5cbiAgICAgICAgcmV0dXJuIHBhdGg7XG4gICAgfVxuXG4gICAgLy8gVE9ETyBPcHRpbWl6ZSBkb3VibGUgbWVtb3J5IGNvc3QgcHJvYmxlbVxuICAgIGZ1bmN0aW9uIGNyZWF0ZVBhdGhPcHRpb25zKHN0ciwgb3B0cykge1xuICAgICAgICB2YXIgcGF0aFByb3h5ID0gY3JlYXRlUGF0aFByb3h5RnJvbVN0cmluZyhzdHIpO1xuICAgICAgICB2YXIgdHJhbnNmb3JtO1xuICAgICAgICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgICAgICAgb3B0cy5idWlsZFBhdGggPSBmdW5jdGlvbiAocGF0aCkge1xuICAgICAgICAgICAgcGF0aC5zZXREYXRhKHBhdGhQcm94eS5kYXRhKTtcbiAgICAgICAgICAgIHRyYW5zZm9ybSAmJiB0cmFuc2Zvcm1QYXRoKHBhdGgsIHRyYW5zZm9ybSk7XG4gICAgICAgICAgICAvLyBTdmcgYW5kIHZtbCByZW5kZXJlciBkb24ndCBoYXZlIGNvbnRleHRcbiAgICAgICAgICAgIHZhciBjdHggPSBwYXRoLmdldENvbnRleHQoKTtcbiAgICAgICAgICAgIGlmIChjdHgpIHtcbiAgICAgICAgICAgICAgICBwYXRoLnJlYnVpbGRQYXRoKGN0eCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgb3B0cy5hcHBseVRyYW5zZm9ybSA9IGZ1bmN0aW9uIChtKSB7XG4gICAgICAgICAgICBpZiAoIXRyYW5zZm9ybSkge1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybSA9IG1hdHJpeC5jcmVhdGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1hdHJpeC5tdWwodHJhbnNmb3JtLCBtLCB0cmFuc2Zvcm0pO1xuICAgICAgICAgICAgdGhpcy5kaXJ0eSh0cnVlKTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gb3B0cztcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZSBhIFBhdGggb2JqZWN0IGZyb20gcGF0aCBzdHJpbmcgZGF0YVxuICAgICAgICAgKiBodHRwOi8vd3d3LnczLm9yZy9UUi9TVkcvcGF0aHMuaHRtbCNQYXRoRGF0YVxuICAgICAgICAgKiBAcGFyYW0gIHtPYmplY3R9IG9wdHMgT3RoZXIgb3B0aW9uc1xuICAgICAgICAgKi9cbiAgICAgICAgY3JlYXRlRnJvbVN0cmluZzogZnVuY3Rpb24gKHN0ciwgb3B0cykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQYXRoKGNyZWF0ZVBhdGhPcHRpb25zKHN0ciwgb3B0cykpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGUgYSBQYXRoIGNsYXNzIGZyb20gcGF0aCBzdHJpbmcgZGF0YVxuICAgICAgICAgKiBAcGFyYW0gIHtzdHJpbmd9IHN0clxuICAgICAgICAgKiBAcGFyYW0gIHtPYmplY3R9IG9wdHMgT3RoZXIgb3B0aW9uc1xuICAgICAgICAgKi9cbiAgICAgICAgZXh0ZW5kRnJvbVN0cmluZzogZnVuY3Rpb24gKHN0ciwgb3B0cykge1xuICAgICAgICAgICAgcmV0dXJuIFBhdGguZXh0ZW5kKGNyZWF0ZVBhdGhPcHRpb25zKHN0ciwgb3B0cykpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNZXJnZSBtdWx0aXBsZSBwYXRoc1xuICAgICAgICAgKi9cbiAgICAgICAgLy8gVE9ETyBBcHBseSB0cmFuc2Zvcm1cbiAgICAgICAgLy8gVE9ETyBzdHJva2UgZGFzaFxuICAgICAgICAvLyBUT0RPIE9wdGltaXplIGRvdWJsZSBtZW1vcnkgY29zdCBwcm9ibGVtXG4gICAgICAgIG1lcmdlUGF0aDogZnVuY3Rpb24gKHBhdGhFbHMsIG9wdHMpIHtcbiAgICAgICAgICAgIHZhciBwYXRoTGlzdCA9IFtdO1xuICAgICAgICAgICAgdmFyIGxlbiA9IHBhdGhFbHMubGVuZ3RoO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBwYXRoRWwgPSBwYXRoRWxzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChwYXRoRWwuX19kaXJ0eSkge1xuICAgICAgICAgICAgICAgICAgICBwYXRoRWwuYnVpbGRQYXRoKHBhdGhFbC5wYXRoLCBwYXRoRWwuc2hhcGUsIHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwYXRoTGlzdC5wdXNoKHBhdGhFbC5wYXRoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHBhdGhCdW5kbGUgPSBuZXcgUGF0aChvcHRzKTtcbiAgICAgICAgICAgIHBhdGhCdW5kbGUuYnVpbGRQYXRoID0gZnVuY3Rpb24gKHBhdGgpIHtcbiAgICAgICAgICAgICAgICBwYXRoLmFwcGVuZFBhdGgocGF0aExpc3QpO1xuICAgICAgICAgICAgICAgIC8vIFN2ZyBhbmQgdm1sIHJlbmRlcmVyIGRvbid0IGhhdmUgY29udGV4dFxuICAgICAgICAgICAgICAgIHZhciBjdHggPSBwYXRoLmdldENvbnRleHQoKTtcbiAgICAgICAgICAgICAgICBpZiAoY3R4KSB7XG4gICAgICAgICAgICAgICAgICAgIHBhdGgucmVidWlsZFBhdGgoY3R4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICByZXR1cm4gcGF0aEJ1bmRsZTtcbiAgICAgICAgfVxuICAgIH07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi96cmVuZGVyL2xpYi90b29sL3BhdGguanNcbiAqKiBtb2R1bGUgaWQgPSA1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIFBhdGggZWxlbWVudFxuICogQG1vZHVsZSB6cmVuZGVyL2dyYXBoaWMvUGF0aFxuICovXG5cblxuXG4gICAgdmFyIERpc3BsYXlhYmxlID0gcmVxdWlyZSgnLi9EaXNwbGF5YWJsZScpO1xuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCcuLi9jb3JlL3V0aWwnKTtcbiAgICB2YXIgUGF0aFByb3h5ID0gcmVxdWlyZSgnLi4vY29yZS9QYXRoUHJveHknKTtcbiAgICB2YXIgcGF0aENvbnRhaW4gPSByZXF1aXJlKCcuLi9jb250YWluL3BhdGgnKTtcblxuICAgIHZhciBQYXR0ZXJuID0gcmVxdWlyZSgnLi9QYXR0ZXJuJyk7XG4gICAgdmFyIGdldENhbnZhc1BhdHRlcm4gPSBQYXR0ZXJuLnByb3RvdHlwZS5nZXRDYW52YXNQYXR0ZXJuO1xuXG4gICAgdmFyIGFicyA9IE1hdGguYWJzO1xuXG4gICAgLyoqXG4gICAgICogQGFsaWFzIG1vZHVsZTp6cmVuZGVyL2dyYXBoaWMvUGF0aFxuICAgICAqIEBleHRlbmRzIG1vZHVsZTp6cmVuZGVyL2dyYXBoaWMvRGlzcGxheWFibGVcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIFBhdGgob3B0cykge1xuICAgICAgICBEaXNwbGF5YWJsZS5jYWxsKHRoaXMsIG9wdHMpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7bW9kdWxlOnpyZW5kZXIvY29yZS9QYXRoUHJveHl9XG4gICAgICAgICAqIEByZWFkT25seVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wYXRoID0gbmV3IFBhdGhQcm94eSgpO1xuICAgIH1cblxuICAgIFBhdGgucHJvdG90eXBlID0ge1xuXG4gICAgICAgIGNvbnN0cnVjdG9yOiBQYXRoLFxuXG4gICAgICAgIHR5cGU6ICdwYXRoJyxcblxuICAgICAgICBfX2RpcnR5UGF0aDogdHJ1ZSxcblxuICAgICAgICBzdHJva2VDb250YWluVGhyZXNob2xkOiA1LFxuXG4gICAgICAgIGJydXNoOiBmdW5jdGlvbiAoY3R4LCBwcmV2RWwpIHtcbiAgICAgICAgICAgIHZhciBzdHlsZSA9IHRoaXMuc3R5bGU7XG4gICAgICAgICAgICB2YXIgcGF0aCA9IHRoaXMucGF0aDtcbiAgICAgICAgICAgIHZhciBoYXNTdHJva2UgPSBzdHlsZS5oYXNTdHJva2UoKTtcbiAgICAgICAgICAgIHZhciBoYXNGaWxsID0gc3R5bGUuaGFzRmlsbCgpO1xuICAgICAgICAgICAgdmFyIGZpbGwgPSBzdHlsZS5maWxsO1xuICAgICAgICAgICAgdmFyIHN0cm9rZSA9IHN0eWxlLnN0cm9rZTtcbiAgICAgICAgICAgIHZhciBoYXNGaWxsR3JhZGllbnQgPSBoYXNGaWxsICYmICEhKGZpbGwuY29sb3JTdG9wcyk7XG4gICAgICAgICAgICB2YXIgaGFzU3Ryb2tlR3JhZGllbnQgPSBoYXNTdHJva2UgJiYgISEoc3Ryb2tlLmNvbG9yU3RvcHMpO1xuICAgICAgICAgICAgdmFyIGhhc0ZpbGxQYXR0ZXJuID0gaGFzRmlsbCAmJiAhIShmaWxsLmltYWdlKTtcbiAgICAgICAgICAgIHZhciBoYXNTdHJva2VQYXR0ZXJuID0gaGFzU3Ryb2tlICYmICEhKHN0cm9rZS5pbWFnZSk7XG5cbiAgICAgICAgICAgIHN0eWxlLmJpbmQoY3R4LCB0aGlzLCBwcmV2RWwpO1xuICAgICAgICAgICAgdGhpcy5zZXRUcmFuc2Zvcm0oY3R4KTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuX19kaXJ0eSkge1xuICAgICAgICAgICAgICAgIHZhciByZWN0ID0gdGhpcy5nZXRCb3VuZGluZ1JlY3QoKTtcbiAgICAgICAgICAgICAgICAvLyBVcGRhdGUgZ3JhZGllbnQgYmVjYXVzZSBib3VuZGluZyByZWN0IG1heSBjaGFuZ2VkXG4gICAgICAgICAgICAgICAgaWYgKGhhc0ZpbGxHcmFkaWVudCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9maWxsR3JhZGllbnQgPSBzdHlsZS5nZXRHcmFkaWVudChjdHgsIGZpbGwsIHJlY3QpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaGFzU3Ryb2tlR3JhZGllbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3Ryb2tlR3JhZGllbnQgPSBzdHlsZS5nZXRHcmFkaWVudChjdHgsIHN0cm9rZSwgcmVjdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVXNlIHRoZSBncmFkaWVudCBvciBwYXR0ZXJuXG4gICAgICAgICAgICBpZiAoaGFzRmlsbEdyYWRpZW50KSB7XG4gICAgICAgICAgICAgICAgLy8gUEVORElORyBJZiBtYXkgaGF2ZSBhZmZlY3QgdGhlIHN0YXRlXG4gICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHRoaXMuX2ZpbGxHcmFkaWVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGhhc0ZpbGxQYXR0ZXJuKSB7XG4gICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGdldENhbnZhc1BhdHRlcm4uY2FsbChmaWxsLCBjdHgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGhhc1N0cm9rZUdyYWRpZW50KSB7XG4gICAgICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gdGhpcy5fc3Ryb2tlR3JhZGllbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChoYXNTdHJva2VQYXR0ZXJuKSB7XG4gICAgICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gZ2V0Q2FudmFzUGF0dGVybi5jYWxsKHN0cm9rZSwgY3R4KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGxpbmVEYXNoID0gc3R5bGUubGluZURhc2g7XG4gICAgICAgICAgICB2YXIgbGluZURhc2hPZmZzZXQgPSBzdHlsZS5saW5lRGFzaE9mZnNldDtcblxuICAgICAgICAgICAgdmFyIGN0eExpbmVEYXNoID0gISFjdHguc2V0TGluZURhc2g7XG5cbiAgICAgICAgICAgIC8vIFVwZGF0ZSBwYXRoIHN4LCBzeVxuICAgICAgICAgICAgdmFyIHNjYWxlID0gdGhpcy5nZXRHbG9iYWxTY2FsZSgpO1xuICAgICAgICAgICAgcGF0aC5zZXRTY2FsZShzY2FsZVswXSwgc2NhbGVbMV0pO1xuXG4gICAgICAgICAgICAvLyBQcm94eSBjb250ZXh0XG4gICAgICAgICAgICAvLyBSZWJ1aWxkIHBhdGggaW4gZm9sbG93aW5nIDIgY2FzZXNcbiAgICAgICAgICAgIC8vIDEuIFBhdGggaXMgZGlydHlcbiAgICAgICAgICAgIC8vIDIuIFBhdGggbmVlZHMgamF2YXNjcmlwdCBpbXBsZW1lbnRlZCBsaW5lRGFzaCBzdHJva2luZy5cbiAgICAgICAgICAgIC8vICAgIEluIHRoaXMgY2FzZSwgbGluZURhc2ggaW5mb3JtYXRpb24gd2lsbCBub3QgYmUgc2F2ZWQgaW4gUGF0aFByb3h5XG4gICAgICAgICAgICBpZiAodGhpcy5fX2RpcnR5UGF0aCB8fCAoXG4gICAgICAgICAgICAgICAgbGluZURhc2ggJiYgIWN0eExpbmVEYXNoICYmIGhhc1N0cm9rZVxuICAgICAgICAgICAgKSkge1xuICAgICAgICAgICAgICAgIHBhdGggPSB0aGlzLnBhdGguYmVnaW5QYXRoKGN0eCk7XG5cbiAgICAgICAgICAgICAgICAvLyBTZXR0aW5nIGxpbmUgZGFzaCBiZWZvcmUgYnVpbGQgcGF0aFxuICAgICAgICAgICAgICAgIGlmIChsaW5lRGFzaCAmJiAhY3R4TGluZURhc2gpIHtcbiAgICAgICAgICAgICAgICAgICAgcGF0aC5zZXRMaW5lRGFzaChsaW5lRGFzaCk7XG4gICAgICAgICAgICAgICAgICAgIHBhdGguc2V0TGluZURhc2hPZmZzZXQobGluZURhc2hPZmZzZXQpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuYnVpbGRQYXRoKHBhdGgsIHRoaXMuc2hhcGUsIGZhbHNlKTtcblxuICAgICAgICAgICAgICAgIC8vIENsZWFyIHBhdGggZGlydHkgZmxhZ1xuICAgICAgICAgICAgICAgIHRoaXMuX19kaXJ0eVBhdGggPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFJlcGxheSBwYXRoIGJ1aWxkaW5nXG4gICAgICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgIHRoaXMucGF0aC5yZWJ1aWxkUGF0aChjdHgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBoYXNGaWxsICYmIHBhdGguZmlsbChjdHgpO1xuXG4gICAgICAgICAgICBpZiAobGluZURhc2ggJiYgY3R4TGluZURhc2gpIHtcbiAgICAgICAgICAgICAgICBjdHguc2V0TGluZURhc2gobGluZURhc2gpO1xuICAgICAgICAgICAgICAgIGN0eC5saW5lRGFzaE9mZnNldCA9IGxpbmVEYXNoT2Zmc2V0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBoYXNTdHJva2UgJiYgcGF0aC5zdHJva2UoY3R4KTtcblxuICAgICAgICAgICAgaWYgKGxpbmVEYXNoICYmIGN0eExpbmVEYXNoKSB7XG4gICAgICAgICAgICAgICAgLy8gUEVORElOR1xuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBsaW5lRGFzaFxuICAgICAgICAgICAgICAgIGN0eC5zZXRMaW5lRGFzaChbXSk7XG4gICAgICAgICAgICB9XG5cblxuICAgICAgICAgICAgdGhpcy5yZXN0b3JlVHJhbnNmb3JtKGN0eCk7XG5cbiAgICAgICAgICAgIC8vIERyYXcgcmVjdCB0ZXh0XG4gICAgICAgICAgICBpZiAoc3R5bGUudGV4dCB8fCBzdHlsZS50ZXh0ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gdmFyIHJlY3QgPSB0aGlzLmdldEJvdW5kaW5nUmVjdCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuZHJhd1JlY3RUZXh0KGN0eCwgdGhpcy5nZXRCb3VuZGluZ1JlY3QoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gV2hlbiBidW5kbGluZyBwYXRoLCBzb21lIHNoYXBlIG1heSBkZWNpZGUgaWYgdXNlIG1vdmVUbyB0byBiZWdpbiBhIG5ldyBzdWJwYXRoIG9yIGNsb3NlUGF0aFxuICAgICAgICAvLyBMaWtlIGluIGNpcmNsZVxuICAgICAgICBidWlsZFBhdGg6IGZ1bmN0aW9uIChjdHgsIHNoYXBlQ2ZnLCBpbkJ1bmRsZSkge30sXG5cbiAgICAgICAgZ2V0Qm91bmRpbmdSZWN0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcmVjdCA9IHRoaXMuX3JlY3Q7XG4gICAgICAgICAgICB2YXIgc3R5bGUgPSB0aGlzLnN0eWxlO1xuICAgICAgICAgICAgdmFyIG5lZWRzVXBkYXRlUmVjdCA9ICFyZWN0O1xuICAgICAgICAgICAgaWYgKG5lZWRzVXBkYXRlUmVjdCkge1xuICAgICAgICAgICAgICAgIHZhciBwYXRoID0gdGhpcy5wYXRoO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9fZGlydHlQYXRoKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhdGguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYnVpbGRQYXRoKHBhdGgsIHRoaXMuc2hhcGUsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVjdCA9IHBhdGguZ2V0Qm91bmRpbmdSZWN0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9yZWN0ID0gcmVjdDtcblxuICAgICAgICAgICAgaWYgKHN0eWxlLmhhc1N0cm9rZSgpKSB7XG4gICAgICAgICAgICAgICAgLy8gTmVlZHMgdXBkYXRlIHJlY3Qgd2l0aCBzdHJva2UgbGluZVdpZHRoIHdoZW5cbiAgICAgICAgICAgICAgICAvLyAxLiBFbGVtZW50IGNoYW5nZXMgc2NhbGUgb3IgbGluZVdpZHRoXG4gICAgICAgICAgICAgICAgLy8gMi4gU2hhcGUgaXMgY2hhbmdlZFxuICAgICAgICAgICAgICAgIHZhciByZWN0V2l0aFN0cm9rZSA9IHRoaXMuX3JlY3RXaXRoU3Ryb2tlIHx8ICh0aGlzLl9yZWN0V2l0aFN0cm9rZSA9IHJlY3QuY2xvbmUoKSk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX19kaXJ0eSB8fCBuZWVkc1VwZGF0ZVJlY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVjdFdpdGhTdHJva2UuY29weShyZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gRklYTUUgTXVzdCBhZnRlciB1cGRhdGVUcmFuc2Zvcm1cbiAgICAgICAgICAgICAgICAgICAgdmFyIHcgPSBzdHlsZS5saW5lV2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIC8vIFBFTkRJTkcsIE1pbiBsaW5lIHdpZHRoIGlzIG5lZWRlZCB3aGVuIGxpbmUgaXMgaG9yaXpvbnRhbCBvciB2ZXJ0aWNhbFxuICAgICAgICAgICAgICAgICAgICB2YXIgbGluZVNjYWxlID0gc3R5bGUuc3Ryb2tlTm9TY2FsZSA/IHRoaXMuZ2V0TGluZVNjYWxlKCkgOiAxO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIE9ubHkgYWRkIGV4dHJhIGhvdmVyIGxpbmVXaWR0aCB3aGVuIHRoZXJlIGFyZSBubyBmaWxsXG4gICAgICAgICAgICAgICAgICAgIGlmICghc3R5bGUuaGFzRmlsbCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3ID0gTWF0aC5tYXgodywgdGhpcy5zdHJva2VDb250YWluVGhyZXNob2xkIHx8IDQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIENvbnNpZGVyIGxpbmUgd2lkdGhcbiAgICAgICAgICAgICAgICAgICAgLy8gTGluZSBzY2FsZSBjYW4ndCBiZSAwO1xuICAgICAgICAgICAgICAgICAgICBpZiAobGluZVNjYWxlID4gMWUtMTApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY3RXaXRoU3Ryb2tlLndpZHRoICs9IHcgLyBsaW5lU2NhbGU7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWN0V2l0aFN0cm9rZS5oZWlnaHQgKz0gdyAvIGxpbmVTY2FsZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY3RXaXRoU3Ryb2tlLnggLT0gdyAvIGxpbmVTY2FsZSAvIDI7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWN0V2l0aFN0cm9rZS55IC09IHcgLyBsaW5lU2NhbGUgLyAyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gUmV0dXJuIHJlY3Qgd2l0aCBzdHJva2VcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVjdFdpdGhTdHJva2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZWN0O1xuICAgICAgICB9LFxuXG4gICAgICAgIGNvbnRhaW46IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgICAgICB2YXIgbG9jYWxQb3MgPSB0aGlzLnRyYW5zZm9ybUNvb3JkVG9Mb2NhbCh4LCB5KTtcbiAgICAgICAgICAgIHZhciByZWN0ID0gdGhpcy5nZXRCb3VuZGluZ1JlY3QoKTtcbiAgICAgICAgICAgIHZhciBzdHlsZSA9IHRoaXMuc3R5bGU7XG4gICAgICAgICAgICB4ID0gbG9jYWxQb3NbMF07XG4gICAgICAgICAgICB5ID0gbG9jYWxQb3NbMV07XG5cbiAgICAgICAgICAgIGlmIChyZWN0LmNvbnRhaW4oeCwgeSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgcGF0aERhdGEgPSB0aGlzLnBhdGguZGF0YTtcbiAgICAgICAgICAgICAgICBpZiAoc3R5bGUuaGFzU3Ryb2tlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxpbmVXaWR0aCA9IHN0eWxlLmxpbmVXaWR0aDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxpbmVTY2FsZSA9IHN0eWxlLnN0cm9rZU5vU2NhbGUgPyB0aGlzLmdldExpbmVTY2FsZSgpIDogMTtcbiAgICAgICAgICAgICAgICAgICAgLy8gTGluZSBzY2FsZSBjYW4ndCBiZSAwO1xuICAgICAgICAgICAgICAgICAgICBpZiAobGluZVNjYWxlID4gMWUtMTApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9ubHkgYWRkIGV4dHJhIGhvdmVyIGxpbmVXaWR0aCB3aGVuIHRoZXJlIGFyZSBubyBmaWxsXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXN0eWxlLmhhc0ZpbGwoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVXaWR0aCA9IE1hdGgubWF4KGxpbmVXaWR0aCwgdGhpcy5zdHJva2VDb250YWluVGhyZXNob2xkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXRoQ29udGFpbi5jb250YWluU3Ryb2tlKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdGhEYXRhLCBsaW5lV2lkdGggLyBsaW5lU2NhbGUsIHgsIHlcbiAgICAgICAgICAgICAgICAgICAgICAgICkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc3R5bGUuaGFzRmlsbCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXRoQ29udGFpbi5jb250YWluKHBhdGhEYXRhLCB4LCB5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSAge2Jvb2xlYW59IGRpcnR5UGF0aFxuICAgICAgICAgKi9cbiAgICAgICAgZGlydHk6IGZ1bmN0aW9uIChkaXJ0eVBhdGgpIHtcbiAgICAgICAgICAgIGlmIChkaXJ0eVBhdGggPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGRpcnR5UGF0aCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBPbmx5IG1hcmsgZGlydHksIG5vdCBtYXJrIGNsZWFuXG4gICAgICAgICAgICBpZiAoZGlydHlQYXRoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fX2RpcnR5UGF0aCA9IGRpcnR5UGF0aDtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZWN0ID0gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5fX2RpcnR5ID0gdHJ1ZTtcblxuICAgICAgICAgICAgdGhpcy5fX3pyICYmIHRoaXMuX196ci5yZWZyZXNoKCk7XG5cbiAgICAgICAgICAgIC8vIFVzZWQgYXMgYSBjbGlwcGluZyBwYXRoXG4gICAgICAgICAgICBpZiAodGhpcy5fX2NsaXBUYXJnZXQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9fY2xpcFRhcmdldC5kaXJ0eSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbGlhcyBmb3IgYW5pbWF0ZSgnc2hhcGUnKVxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGxvb3BcbiAgICAgICAgICovXG4gICAgICAgIGFuaW1hdGVTaGFwZTogZnVuY3Rpb24gKGxvb3ApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFuaW1hdGUoJ3NoYXBlJywgbG9vcCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gT3ZlcndyaXRlIGF0dHJLVlxuICAgICAgICBhdHRyS1Y6IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICAgICAgICAvLyBGSVhNRVxuICAgICAgICAgICAgaWYgKGtleSA9PT0gJ3NoYXBlJykge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0U2hhcGUodmFsdWUpO1xuICAgICAgICAgICAgICAgIHRoaXMuX19kaXJ0eVBhdGggPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlY3QgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgRGlzcGxheWFibGUucHJvdG90eXBlLmF0dHJLVi5jYWxsKHRoaXMsIGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdHxzdHJpbmd9IGtleVxuICAgICAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICAgICAqL1xuICAgICAgICBzZXRTaGFwZTogZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBzaGFwZSA9IHRoaXMuc2hhcGU7XG4gICAgICAgICAgICAvLyBQYXRoIGZyb20gc3RyaW5nIG1heSBub3QgaGF2ZSBzaGFwZVxuICAgICAgICAgICAgaWYgKHNoYXBlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHpyVXRpbC5pc09iamVjdChrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIG5hbWUgaW4ga2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaGFwZVtuYW1lXSA9IGtleVtuYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2hhcGVba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmRpcnR5KHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0TGluZVNjYWxlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbSA9IHRoaXMudHJhbnNmb3JtO1xuICAgICAgICAgICAgLy8gR2V0IHRoZSBsaW5lIHNjYWxlLlxuICAgICAgICAgICAgLy8gRGV0ZXJtaW5hbnQgb2YgYG1gIG1lYW5zIGhvdyBtdWNoIHRoZSBhcmVhIGlzIGVubGFyZ2VkIGJ5IHRoZVxuICAgICAgICAgICAgLy8gdHJhbnNmb3JtYXRpb24uIFNvIGl0cyBzcXVhcmUgcm9vdCBjYW4gYmUgdXNlZCBhcyBhIHNjYWxlIGZhY3RvclxuICAgICAgICAgICAgLy8gZm9yIHdpZHRoLlxuICAgICAgICAgICAgcmV0dXJuIG0gJiYgYWJzKG1bMF0gLSAxKSA+IDFlLTEwICYmIGFicyhtWzNdIC0gMSkgPiAxZS0xMFxuICAgICAgICAgICAgICAgID8gTWF0aC5zcXJ0KGFicyhtWzBdICogbVszXSAtIG1bMl0gKiBtWzFdKSlcbiAgICAgICAgICAgICAgICA6IDE7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICog5omp5bGV5LiA5LiqIFBhdGggZWxlbWVudCwg5q+U5aaC5pif5b2i77yM5ZyG562J44CCXG4gICAgICogRXh0ZW5kIGEgcGF0aCBlbGVtZW50XG4gICAgICogQHBhcmFtIHtPYmplY3R9IHByb3BzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BzLnR5cGUgUGF0aCB0eXBlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJvcHMuaW5pdCBJbml0aWFsaXplXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJvcHMuYnVpbGRQYXRoIE92ZXJ3cml0ZSBidWlsZFBhdGggbWV0aG9kXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5zdHlsZV0gRXh0ZW5kZWQgZGVmYXVsdCBzdHlsZSBjb25maWdcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3Byb3BzLnNoYXBlXSBFeHRlbmRlZCBkZWZhdWx0IHNoYXBlIGNvbmZpZ1xuICAgICAqL1xuICAgIFBhdGguZXh0ZW5kID0gZnVuY3Rpb24gKGRlZmF1bHRzKSB7XG4gICAgICAgIHZhciBTdWIgPSBmdW5jdGlvbiAob3B0cykge1xuICAgICAgICAgICAgUGF0aC5jYWxsKHRoaXMsIG9wdHMpO1xuXG4gICAgICAgICAgICBpZiAoZGVmYXVsdHMuc3R5bGUpIHtcbiAgICAgICAgICAgICAgICAvLyBFeHRlbmQgZGVmYXVsdCBzdHlsZVxuICAgICAgICAgICAgICAgIHRoaXMuc3R5bGUuZXh0ZW5kRnJvbShkZWZhdWx0cy5zdHlsZSwgZmFsc2UpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBFeHRlbmQgZGVmYXVsdCBzaGFwZVxuICAgICAgICAgICAgdmFyIGRlZmF1bHRTaGFwZSA9IGRlZmF1bHRzLnNoYXBlO1xuICAgICAgICAgICAgaWYgKGRlZmF1bHRTaGFwZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2hhcGUgPSB0aGlzLnNoYXBlIHx8IHt9O1xuICAgICAgICAgICAgICAgIHZhciB0aGlzU2hhcGUgPSB0aGlzLnNoYXBlO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIG5hbWUgaW4gZGVmYXVsdFNoYXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgICEgdGhpc1NoYXBlLmhhc093blByb3BlcnR5KG5hbWUpXG4gICAgICAgICAgICAgICAgICAgICAgICAmJiBkZWZhdWx0U2hhcGUuaGFzT3duUHJvcGVydHkobmFtZSlcbiAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzU2hhcGVbbmFtZV0gPSBkZWZhdWx0U2hhcGVbbmFtZV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRlZmF1bHRzLmluaXQgJiYgZGVmYXVsdHMuaW5pdC5jYWxsKHRoaXMsIG9wdHMpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHpyVXRpbC5pbmhlcml0cyhTdWIsIFBhdGgpO1xuXG4gICAgICAgIC8vIEZJWE1FIOS4jeiDvSBleHRlbmQgcG9zaXRpb24sIHJvdGF0aW9uIOetieW8leeUqOWvueixoVxuICAgICAgICBmb3IgKHZhciBuYW1lIGluIGRlZmF1bHRzKSB7XG4gICAgICAgICAgICAvLyBFeHRlbmRpbmcgcHJvdG90eXBlIHZhbHVlcyBhbmQgbWV0aG9kc1xuICAgICAgICAgICAgaWYgKG5hbWUgIT09ICdzdHlsZScgJiYgbmFtZSAhPT0gJ3NoYXBlJykge1xuICAgICAgICAgICAgICAgIFN1Yi5wcm90b3R5cGVbbmFtZV0gPSBkZWZhdWx0c1tuYW1lXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBTdWI7XG4gICAgfTtcblxuICAgIHpyVXRpbC5pbmhlcml0cyhQYXRoLCBEaXNwbGF5YWJsZSk7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IFBhdGg7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi96cmVuZGVyL2xpYi9ncmFwaGljL1BhdGguanNcbiAqKiBtb2R1bGUgaWQgPSA2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIOWPr+e7mOWItueahOWbvuW9ouWfuuexu1xuICogQmFzZSBjbGFzcyBvZiBhbGwgZGlzcGxheWFibGUgZ3JhcGhpYyBvYmplY3RzXG4gKiBAbW9kdWxlIHpyZW5kZXIvZ3JhcGhpYy9EaXNwbGF5YWJsZVxuICovXG5cblxuXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJy4uL2NvcmUvdXRpbCcpO1xuXG4gICAgdmFyIFN0eWxlID0gcmVxdWlyZSgnLi9TdHlsZScpO1xuXG4gICAgdmFyIEVsZW1lbnQgPSByZXF1aXJlKCcuLi9FbGVtZW50Jyk7XG4gICAgdmFyIFJlY3RUZXh0ID0gcmVxdWlyZSgnLi9taXhpbi9SZWN0VGV4dCcpO1xuICAgIC8vIHZhciBTdGF0ZWZ1bCA9IHJlcXVpcmUoJy4vbWl4aW4vU3RhdGVmdWwnKTtcblxuICAgIC8qKlxuICAgICAqIEBhbGlhcyBtb2R1bGU6enJlbmRlci9ncmFwaGljL0Rpc3BsYXlhYmxlXG4gICAgICogQGV4dGVuZHMgbW9kdWxlOnpyZW5kZXIvRWxlbWVudFxuICAgICAqIEBleHRlbmRzIG1vZHVsZTp6cmVuZGVyL2dyYXBoaWMvbWl4aW4vUmVjdFRleHRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBEaXNwbGF5YWJsZShvcHRzKSB7XG5cbiAgICAgICAgb3B0cyA9IG9wdHMgfHwge307XG5cbiAgICAgICAgRWxlbWVudC5jYWxsKHRoaXMsIG9wdHMpO1xuXG4gICAgICAgIC8vIEV4dGVuZCBwcm9wZXJ0aWVzXG4gICAgICAgIGZvciAodmFyIG5hbWUgaW4gb3B0cykge1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIG9wdHMuaGFzT3duUHJvcGVydHkobmFtZSkgJiZcbiAgICAgICAgICAgICAgICBuYW1lICE9PSAnc3R5bGUnXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICB0aGlzW25hbWVdID0gb3B0c1tuYW1lXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7bW9kdWxlOnpyZW5kZXIvZ3JhcGhpYy9TdHlsZX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3R5bGUgPSBuZXcgU3R5bGUob3B0cy5zdHlsZSk7XG5cbiAgICAgICAgdGhpcy5fcmVjdCA9IG51bGw7XG4gICAgICAgIC8vIFNoYXBlcyBmb3IgY2FzY2FkZSBjbGlwcGluZy5cbiAgICAgICAgdGhpcy5fX2NsaXBQYXRocyA9IFtdO1xuXG4gICAgICAgIC8vIEZJWE1FIFN0YXRlZnVsIG11c3QgYmUgbWl4aW5lZCBhZnRlciBzdHlsZSBpcyBzZXR0ZWRcbiAgICAgICAgLy8gU3RhdGVmdWwuY2FsbCh0aGlzLCBvcHRzKTtcbiAgICB9XG5cbiAgICBEaXNwbGF5YWJsZS5wcm90b3R5cGUgPSB7XG5cbiAgICAgICAgY29uc3RydWN0b3I6IERpc3BsYXlhYmxlLFxuXG4gICAgICAgIHR5cGU6ICdkaXNwbGF5YWJsZScsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERpc3BsYXlhYmxlIOaYr+WQpuS4uuiEj++8jFBhaW50ZXIg5Lit5Lya5qC55o2u6K+l5qCH6K6w5Yik5pat5piv5ZCm6ZyA6KaB5piv5ZCm6ZyA6KaB6YeN5paw57uY5Yi2XG4gICAgICAgICAqIERpcnR5IGZsYWcuIEZyb20gd2hpY2ggcGFpbnRlciB3aWxsIGRldGVybWluZSBpZiB0aGlzIGRpc3BsYXlhYmxlIG9iamVjdCBuZWVkcyBicnVzaFxuICAgICAgICAgKiBAbmFtZSBtb2R1bGU6enJlbmRlci9ncmFwaGljL0Rpc3BsYXlhYmxlI19fZGlydHlcbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICBfX2RpcnR5OiB0cnVlLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlm77lvaLmmK/lkKblj6/op4HvvIzkuLp0cnVl5pe25LiN57uY5Yi25Zu+5b2i77yM5L2G5piv5LuN6IO96Kem5Y+R6byg5qCH5LqL5Lu2XG4gICAgICAgICAqIElmIGlnbm9yZSBkcmF3aW5nIG9mIHRoZSBkaXNwbGF5YWJsZSBvYmplY3QuIE1vdXNlIGV2ZW50IHdpbGwgc3RpbGwgYmUgdHJpZ2dlcmVkXG4gICAgICAgICAqIEBuYW1lIG1vZHVsZTovenJlbmRlci9ncmFwaGljL0Rpc3BsYXlhYmxlI2ludmlzaWJsZVxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIGludmlzaWJsZTogZmFsc2UsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBuYW1lIG1vZHVsZTovenJlbmRlci9ncmFwaGljL0Rpc3BsYXlhYmxlI3pcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICogQGRlZmF1bHQgMFxuICAgICAgICAgKi9cbiAgICAgICAgejogMCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQG5hbWUgbW9kdWxlOi96cmVuZGVyL2dyYXBoaWMvRGlzcGxheWFibGUjelxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKiBAZGVmYXVsdCAwXG4gICAgICAgICAqL1xuICAgICAgICB6MjogMCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogeuWxgmxldmVs77yM5Yaz5a6a57uY55S75Zyo5ZOq5bGCY2FudmFz5LitXG4gICAgICAgICAqIEBuYW1lIG1vZHVsZTovenJlbmRlci9ncmFwaGljL0Rpc3BsYXlhYmxlI3psZXZlbFxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKiBAZGVmYXVsdCAwXG4gICAgICAgICAqL1xuICAgICAgICB6bGV2ZWw6IDAsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOaYr+WQpuWPr+aLluaLvVxuICAgICAgICAgKiBAbmFtZSBtb2R1bGU6L3pyZW5kZXIvZ3JhcGhpYy9EaXNwbGF5YWJsZSNkcmFnZ2FibGVcbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICBkcmFnZ2FibGU6IGZhbHNlLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmmK/lkKbmraPlnKjmi5bmi71cbiAgICAgICAgICogQG5hbWUgbW9kdWxlOi96cmVuZGVyL2dyYXBoaWMvRGlzcGxheWFibGUjZHJhZ2dhYmxlXG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgZHJhZ2dpbmc6IGZhbHNlLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmmK/lkKbnm7jlupTpvKDmoIfkuovku7ZcbiAgICAgICAgICogQG5hbWUgbW9kdWxlOi96cmVuZGVyL2dyYXBoaWMvRGlzcGxheWFibGUjc2lsZW50XG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgc2lsZW50OiBmYWxzZSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgZW5hYmxlIGN1bGxpbmdcbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICBjdWxsaW5nOiBmYWxzZSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogTW91c2UgY3Vyc29yIHdoZW4gaG92ZXJlZFxuICAgICAgICAgKiBAbmFtZSBtb2R1bGU6L3pyZW5kZXIvZ3JhcGhpYy9EaXNwbGF5YWJsZSNjdXJzb3JcbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIGN1cnNvcjogJ3BvaW50ZXInLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiBob3ZlciBhcmVhIGlzIGJvdW5kaW5nIHJlY3RcbiAgICAgICAgICogQG5hbWUgbW9kdWxlOi96cmVuZGVyL2dyYXBoaWMvRGlzcGxheWFibGUjcmVjdEhvdmVyXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICByZWN0SG92ZXI6IGZhbHNlLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW5kZXIgdGhlIGVsZW1lbnQgcHJvZ3Jlc3NpdmVseSB3aGVuIHRoZSB2YWx1ZSA+PSAwLFxuICAgICAgICAgKiB1c2VmdWxsIGZvciBsYXJnZSBkYXRhLlxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgcHJvZ3Jlc3NpdmU6IC0xLFxuXG4gICAgICAgIGJlZm9yZUJydXNoOiBmdW5jdGlvbiAoY3R4KSB7fSxcblxuICAgICAgICBhZnRlckJydXNoOiBmdW5jdGlvbiAoY3R4KSB7fSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5Zu+5b2i57uY5Yi25pa55rOVXG4gICAgICAgICAqIEBwYXJhbSB7Q2FudmFzMkRSZW5kZXJpbmdDb250ZXh0fSBjdHhcbiAgICAgICAgICovXG4gICAgICAgIC8vIEludGVyZmFjZVxuICAgICAgICBicnVzaDogZnVuY3Rpb24gKGN0eCwgcHJldkVsKSB7fSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog6I635Y+W5pyA5bCP5YyF5Zu055uSXG4gICAgICAgICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2NvcmUvQm91bmRpbmdSZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgLy8gSW50ZXJmYWNlXG4gICAgICAgIGdldEJvdW5kaW5nUmVjdDogZnVuY3Rpb24gKCkge30sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWIpOaWreWdkOaghyB4LCB5IOaYr+WQpuWcqOWbvuW9ouS4ilxuICAgICAgICAgKiBJZiBkaXNwbGF5YWJsZSBlbGVtZW50IGNvbnRhaW4gY29vcmQgeCwgeVxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHhcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSB5XG4gICAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICBjb250YWluOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVjdENvbnRhaW4oeCwgeSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBjYlxuICAgICAgICAgKiBAcGFyYW0gIHt9ICAgY29udGV4dFxuICAgICAgICAgKi9cbiAgICAgICAgdHJhdmVyc2U6IGZ1bmN0aW9uIChjYiwgY29udGV4dCkge1xuICAgICAgICAgICAgY2IuY2FsbChjb250ZXh0LCB0aGlzKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5Yik5pat5Z2Q5qCHIHgsIHkg5piv5ZCm5Zyo5Zu+5b2i55qE5YyF5Zu055uS5LiKXG4gICAgICAgICAqIElmIGJvdW5kaW5nIHJlY3Qgb2YgZWxlbWVudCBjb250YWluIGNvb3JkIHgsIHlcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSB4XG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0geVxuICAgICAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgcmVjdENvbnRhaW46IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgICAgICB2YXIgY29vcmQgPSB0aGlzLnRyYW5zZm9ybUNvb3JkVG9Mb2NhbCh4LCB5KTtcbiAgICAgICAgICAgIHZhciByZWN0ID0gdGhpcy5nZXRCb3VuZGluZ1JlY3QoKTtcbiAgICAgICAgICAgIHJldHVybiByZWN0LmNvbnRhaW4oY29vcmRbMF0sIGNvb3JkWzFdKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5qCH6K6w5Zu+5b2i5YWD57Sg5Li66ISP77yM5bm25LiU5Zyo5LiL5LiA5bin6YeN57uYXG4gICAgICAgICAqIE1hcmsgZGlzcGxheWFibGUgZWxlbWVudCBkaXJ0eSBhbmQgcmVmcmVzaCBuZXh0IGZyYW1lXG4gICAgICAgICAqL1xuICAgICAgICBkaXJ0eTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5fX2RpcnR5ID0gdHJ1ZTtcblxuICAgICAgICAgICAgdGhpcy5fcmVjdCA9IG51bGw7XG5cbiAgICAgICAgICAgIHRoaXMuX196ciAmJiB0aGlzLl9fenIucmVmcmVzaCgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlm77lvaLmmK/lkKbkvJrop6blj5Hkuovku7ZcbiAgICAgICAgICogSWYgZGlzcGxheWFibGUgb2JqZWN0IGJpbmRlZCBhbnkgZXZlbnRcbiAgICAgICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIC8vIFRPRE8sIOmAmui/hyBiaW5kIOe7keWumueahOS6i+S7tlxuICAgICAgICAvLyBpc1NpbGVudDogZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyAgICAgcmV0dXJuICEoXG4gICAgICAgIC8vICAgICAgICAgdGhpcy5ob3ZlcmFibGUgfHwgdGhpcy5kcmFnZ2FibGVcbiAgICAgICAgLy8gICAgICAgICB8fCB0aGlzLm9ubW91c2Vtb3ZlIHx8IHRoaXMub25tb3VzZW92ZXIgfHwgdGhpcy5vbm1vdXNlb3V0XG4gICAgICAgIC8vICAgICAgICAgfHwgdGhpcy5vbm1vdXNlZG93biB8fCB0aGlzLm9ubW91c2V1cCB8fCB0aGlzLm9uY2xpY2tcbiAgICAgICAgLy8gICAgICAgICB8fCB0aGlzLm9uZHJhZ2VudGVyIHx8IHRoaXMub25kcmFnb3ZlciB8fCB0aGlzLm9uZHJhZ2xlYXZlXG4gICAgICAgIC8vICAgICAgICAgfHwgdGhpcy5vbmRyb3BcbiAgICAgICAgLy8gICAgICk7XG4gICAgICAgIC8vIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbGlhcyBmb3IgYW5pbWF0ZSgnc3R5bGUnKVxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGxvb3BcbiAgICAgICAgICovXG4gICAgICAgIGFuaW1hdGVTdHlsZTogZnVuY3Rpb24gKGxvb3ApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFuaW1hdGUoJ3N0eWxlJywgbG9vcCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgYXR0cktWOiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKGtleSAhPT0gJ3N0eWxlJykge1xuICAgICAgICAgICAgICAgIEVsZW1lbnQucHJvdG90eXBlLmF0dHJLVi5jYWxsKHRoaXMsIGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdHlsZS5zZXQodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdHxzdHJpbmd9IGtleVxuICAgICAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICAgICAqL1xuICAgICAgICBzZXRTdHlsZTogZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuc3R5bGUuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgdGhpcy5kaXJ0eShmYWxzZSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVXNlIGdpdmVuIHN0eWxlIG9iamVjdFxuICAgICAgICAgKiBAcGFyYW0gIHtPYmplY3R9IG9ialxuICAgICAgICAgKi9cbiAgICAgICAgdXNlU3R5bGU6IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgIHRoaXMuc3R5bGUgPSBuZXcgU3R5bGUob2JqKTtcbiAgICAgICAgICAgIHRoaXMuZGlydHkoZmFsc2UpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgenJVdGlsLmluaGVyaXRzKERpc3BsYXlhYmxlLCBFbGVtZW50KTtcblxuICAgIHpyVXRpbC5taXhpbihEaXNwbGF5YWJsZSwgUmVjdFRleHQpO1xuICAgIC8vIHpyVXRpbC5taXhpbihEaXNwbGF5YWJsZSwgU3RhdGVmdWwpO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBEaXNwbGF5YWJsZTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvRGlzcGxheWFibGUuanNcbiAqKiBtb2R1bGUgaWQgPSA3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIEBtb2R1bGUgenJlbmRlci9ncmFwaGljL1N0eWxlXG4gKi9cblxuXG4gICAgdmFyIFNUWUxFX0NPTU1PTl9QUk9QUyA9IFtcbiAgICAgICAgWydzaGFkb3dCbHVyJywgMF0sIFsnc2hhZG93T2Zmc2V0WCcsIDBdLCBbJ3NoYWRvd09mZnNldFknLCAwXSwgWydzaGFkb3dDb2xvcicsICcjMDAwJ10sXG4gICAgICAgIFsnbGluZUNhcCcsICdidXR0J10sIFsnbGluZUpvaW4nLCAnbWl0ZXInXSwgWydtaXRlckxpbWl0JywgMTBdXG4gICAgXTtcblxuICAgIC8vIHZhciBTSEFET1dfUFJPUFMgPSBTVFlMRV9DT01NT05fUFJPUFMuc2xpY2UoMCwgNCk7XG4gICAgLy8gdmFyIExJTkVfUFJPUFMgPSBTVFlMRV9DT01NT05fUFJPUFMuc2xpY2UoNCk7XG5cbiAgICB2YXIgU3R5bGUgPSBmdW5jdGlvbiAob3B0cykge1xuICAgICAgICB0aGlzLmV4dGVuZEZyb20ob3B0cyk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUxpbmVhckdyYWRpZW50KGN0eCwgb2JqLCByZWN0KSB7XG4gICAgICAgIC8vIHZhciBzaXplID1cbiAgICAgICAgdmFyIHggPSBvYmoueDtcbiAgICAgICAgdmFyIHgyID0gb2JqLngyO1xuICAgICAgICB2YXIgeSA9IG9iai55O1xuICAgICAgICB2YXIgeTIgPSBvYmoueTI7XG5cbiAgICAgICAgaWYgKCFvYmouZ2xvYmFsKSB7XG4gICAgICAgICAgICB4ID0geCAqIHJlY3Qud2lkdGggKyByZWN0Lng7XG4gICAgICAgICAgICB4MiA9IHgyICogcmVjdC53aWR0aCArIHJlY3QueDtcbiAgICAgICAgICAgIHkgPSB5ICogcmVjdC5oZWlnaHQgKyByZWN0Lnk7XG4gICAgICAgICAgICB5MiA9IHkyICogcmVjdC5oZWlnaHQgKyByZWN0Lnk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY2FudmFzR3JhZGllbnQgPSBjdHguY3JlYXRlTGluZWFyR3JhZGllbnQoeCwgeSwgeDIsIHkyKTtcblxuICAgICAgICByZXR1cm4gY2FudmFzR3JhZGllbnQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlUmFkaWFsR3JhZGllbnQoY3R4LCBvYmosIHJlY3QpIHtcbiAgICAgICAgdmFyIHdpZHRoID0gcmVjdC53aWR0aDtcbiAgICAgICAgdmFyIGhlaWdodCA9IHJlY3QuaGVpZ2h0O1xuICAgICAgICB2YXIgbWluID0gTWF0aC5taW4od2lkdGgsIGhlaWdodCk7XG5cbiAgICAgICAgdmFyIHggPSBvYmoueDtcbiAgICAgICAgdmFyIHkgPSBvYmoueTtcbiAgICAgICAgdmFyIHIgPSBvYmoucjtcbiAgICAgICAgaWYgKCFvYmouZ2xvYmFsKSB7XG4gICAgICAgICAgICB4ID0geCAqIHdpZHRoICsgcmVjdC54O1xuICAgICAgICAgICAgeSA9IHkgKiBoZWlnaHQgKyByZWN0Lnk7XG4gICAgICAgICAgICByID0gciAqIG1pbjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjYW52YXNHcmFkaWVudCA9IGN0eC5jcmVhdGVSYWRpYWxHcmFkaWVudCh4LCB5LCAwLCB4LCB5LCByKTtcblxuICAgICAgICByZXR1cm4gY2FudmFzR3JhZGllbnQ7XG4gICAgfVxuXG5cbiAgICBTdHlsZS5wcm90b3R5cGUgPSB7XG5cbiAgICAgICAgY29uc3RydWN0b3I6IFN0eWxlLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgZmlsbDogJyMwMDAwMDAnLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgc3Ryb2tlOiBudWxsLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgb3BhY2l0eTogMSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge0FycmF5LjxudW1iZXI+fVxuICAgICAgICAgKi9cbiAgICAgICAgbGluZURhc2g6IG51bGwsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBsaW5lRGFzaE9mZnNldDogMCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHNoYWRvd0JsdXI6IDAsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBzaGFkb3dPZmZzZXRYOiAwLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgc2hhZG93T2Zmc2V0WTogMCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIGxpbmVXaWR0aDogMSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgc3Ryb2tlIGlnbm9yZSBzY2FsZVxuICAgICAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIHN0cm9rZU5vU2NhbGU6IGZhbHNlLFxuXG4gICAgICAgIC8vIEJvdW5kaW5nIHJlY3QgdGV4dCBjb25maWd1cmF0aW9uXG4gICAgICAgIC8vIE5vdCBhZmZlY3RlZCBieSBlbGVtZW50IHRyYW5zZm9ybVxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIHRleHQ6IG51bGwsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICB0ZXh0RmlsbDogJyMwMDAnLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgdGV4dFN0cm9rZTogbnVsbCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogJ2luc2lkZScsICdsZWZ0JywgJ3JpZ2h0JywgJ3RvcCcsICdib3R0b20nXG4gICAgICAgICAqIFt4LCB5XVxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfEFycmF5LjxudW1iZXI+fVxuICAgICAgICAgKiBAZGVmYXVsdCAnaW5zaWRlJ1xuICAgICAgICAgKi9cbiAgICAgICAgdGV4dFBvc2l0aW9uOiAnaW5zaWRlJyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIHRleHRCYXNlbGluZTogbnVsbCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIHRleHRBbGlnbjogbnVsbCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIHRleHRWZXJ0aWNhbEFsaWduOiBudWxsLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBPbmx5IHVzZWZ1bCBpbiBQYXRoIGFuZCBJbWFnZSBlbGVtZW50XG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0ZXh0RGlzdGFuY2U6IDUsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE9ubHkgdXNlZnVsIGluIFBhdGggYW5kIEltYWdlIGVsZW1lbnRcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRleHRTaGFkb3dCbHVyOiAwLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBPbmx5IHVzZWZ1bCBpbiBQYXRoIGFuZCBJbWFnZSBlbGVtZW50XG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0ZXh0U2hhZG93T2Zmc2V0WDogMCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogT25seSB1c2VmdWwgaW4gUGF0aCBhbmQgSW1hZ2UgZWxlbWVudFxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGV4dFNoYWRvd09mZnNldFk6IDAsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHRyYW5zZm9ybSB0ZXh0XG4gICAgICAgICAqIE9ubHkgdXNlZnVsIGluIFBhdGggYW5kIEltYWdlIGVsZW1lbnRcbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICB0ZXh0VHJhbnNmb3JtOiBmYWxzZSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGV4dCByb3RhdGUgYXJvdW5kIHBvc2l0aW9uIG9mIFBhdGggb3IgSW1hZ2VcbiAgICAgICAgICogT25seSB1c2VmdWwgaW4gUGF0aCBhbmQgSW1hZ2UgZWxlbWVudCBhbmQgdGV4dFRyYW5zZm9ybSBpcyBmYWxzZS5cbiAgICAgICAgICovXG4gICAgICAgIHRleHRSb3RhdGlvbjogMCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC9nbG9iYWxDb21wb3NpdGVPcGVyYXRpb25cbiAgICAgICAgICovXG4gICAgICAgIGJsZW5kOiBudWxsLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICAgICAqL1xuICAgICAgICBiaW5kOiBmdW5jdGlvbiAoY3R4LCBlbCwgcHJldkVsKSB7XG4gICAgICAgICAgICB2YXIgc3R5bGUgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIHByZXZTdHlsZSA9IHByZXZFbCAmJiBwcmV2RWwuc3R5bGU7XG4gICAgICAgICAgICB2YXIgZmlyc3REcmF3ID0gIXByZXZTdHlsZTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBTVFlMRV9DT01NT05fUFJPUFMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgcHJvcCA9IFNUWUxFX0NPTU1PTl9QUk9QU1tpXTtcbiAgICAgICAgICAgICAgICB2YXIgc3R5bGVOYW1lID0gcHJvcFswXTtcblxuICAgICAgICAgICAgICAgIGlmIChmaXJzdERyYXcgfHwgc3R5bGVbc3R5bGVOYW1lXSAhPT0gcHJldlN0eWxlW3N0eWxlTmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRklYTUUgSW52YWxpZCBwcm9wZXJ0eSB2YWx1ZSB3aWxsIGNhdXNlIHN0eWxlIGxlYWsgZnJvbSBwcmV2aW91cyBlbGVtZW50LlxuICAgICAgICAgICAgICAgICAgICBjdHhbc3R5bGVOYW1lXSA9IHN0eWxlW3N0eWxlTmFtZV0gfHwgcHJvcFsxXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICgoZmlyc3REcmF3IHx8IHN0eWxlLmZpbGwgIT09IHByZXZTdHlsZS5maWxsKSkge1xuICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBzdHlsZS5maWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChmaXJzdERyYXcgfHwgc3R5bGUuc3Ryb2tlICE9PSBwcmV2U3R5bGUuc3Ryb2tlKSkge1xuICAgICAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHN0eWxlLnN0cm9rZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgoZmlyc3REcmF3IHx8IHN0eWxlLm9wYWNpdHkgIT09IHByZXZTdHlsZS5vcGFjaXR5KSkge1xuICAgICAgICAgICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IHN0eWxlLm9wYWNpdHkgPT0gbnVsbCA/IDEgOiBzdHlsZS5vcGFjaXR5O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoKGZpcnN0RHJhdyB8fCBzdHlsZS5ibGVuZCAhPT0gcHJldlN0eWxlLmJsZW5kKSkge1xuICAgICAgICAgICAgICAgIGN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBzdHlsZS5ibGVuZCB8fCAnc291cmNlLW92ZXInO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuaGFzU3Ryb2tlKCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgbGluZVdpZHRoID0gc3R5bGUubGluZVdpZHRoO1xuICAgICAgICAgICAgICAgIGN0eC5saW5lV2lkdGggPSBsaW5lV2lkdGggLyAoXG4gICAgICAgICAgICAgICAgICAgICh0aGlzLnN0cm9rZU5vU2NhbGUgJiYgZWwgJiYgZWwuZ2V0TGluZVNjYWxlKSA/IGVsLmdldExpbmVTY2FsZSgpIDogMVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGFzRmlsbDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGZpbGwgPSB0aGlzLmZpbGw7XG4gICAgICAgICAgICByZXR1cm4gZmlsbCAhPSBudWxsICYmIGZpbGwgIT09ICdub25lJztcbiAgICAgICAgfSxcblxuICAgICAgICBoYXNTdHJva2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBzdHJva2UgPSB0aGlzLnN0cm9rZTtcbiAgICAgICAgICAgIHJldHVybiBzdHJva2UgIT0gbnVsbCAmJiBzdHJva2UgIT09ICdub25lJyAmJiB0aGlzLmxpbmVXaWR0aCA+IDA7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEV4dGVuZCBmcm9tIG90aGVyIHN0eWxlXG4gICAgICAgICAqIEBwYXJhbSB7enJlbmRlci9ncmFwaGljL1N0eWxlfSBvdGhlclN0eWxlXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gb3ZlcndyaXRlXG4gICAgICAgICAqL1xuICAgICAgICBleHRlbmRGcm9tOiBmdW5jdGlvbiAob3RoZXJTdHlsZSwgb3ZlcndyaXRlKSB7XG4gICAgICAgICAgICBpZiAob3RoZXJTdHlsZSkge1xuICAgICAgICAgICAgICAgIHZhciB0YXJnZXQgPSB0aGlzO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIG5hbWUgaW4gb3RoZXJTdHlsZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAob3RoZXJTdHlsZS5oYXNPd25Qcm9wZXJ0eShuYW1lKVxuICAgICAgICAgICAgICAgICAgICAgICAgJiYgKG92ZXJ3cml0ZSB8fCAhIHRhcmdldC5oYXNPd25Qcm9wZXJ0eShuYW1lKSlcbiAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRbbmFtZV0gPSBvdGhlclN0eWxlW25hbWVdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBCYXRjaCBzZXR0aW5nIHN0eWxlIHdpdGggYSBnaXZlbiBvYmplY3RcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R8c3RyaW5nfSBvYmpcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb2JqXVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAob2JqLCB2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvYmogPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdGhpc1tvYmpdID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmV4dGVuZEZyb20ob2JqLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2xvbmVcbiAgICAgICAgICogQHJldHVybiB7enJlbmRlci9ncmFwaGljL1N0eWxlfSBbZGVzY3JpcHRpb25dXG4gICAgICAgICAqL1xuICAgICAgICBjbG9uZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG5ld1N0eWxlID0gbmV3IHRoaXMuY29uc3RydWN0b3IoKTtcbiAgICAgICAgICAgIG5ld1N0eWxlLmV4dGVuZEZyb20odGhpcywgdHJ1ZSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3U3R5bGU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0R3JhZGllbnQ6IGZ1bmN0aW9uIChjdHgsIG9iaiwgcmVjdCkge1xuICAgICAgICAgICAgdmFyIG1ldGhvZCA9IG9iai50eXBlID09PSAncmFkaWFsJyA/IGNyZWF0ZVJhZGlhbEdyYWRpZW50IDogY3JlYXRlTGluZWFyR3JhZGllbnQ7XG4gICAgICAgICAgICB2YXIgY2FudmFzR3JhZGllbnQgPSBtZXRob2QoY3R4LCBvYmosIHJlY3QpO1xuICAgICAgICAgICAgdmFyIGNvbG9yU3RvcHMgPSBvYmouY29sb3JTdG9wcztcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29sb3JTdG9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNhbnZhc0dyYWRpZW50LmFkZENvbG9yU3RvcChcbiAgICAgICAgICAgICAgICAgICAgY29sb3JTdG9wc1tpXS5vZmZzZXQsIGNvbG9yU3RvcHNbaV0uY29sb3JcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNhbnZhc0dyYWRpZW50O1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciBzdHlsZVByb3RvID0gU3R5bGUucHJvdG90eXBlO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgU1RZTEVfQ09NTU9OX1BST1BTLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBwcm9wID0gU1RZTEVfQ09NTU9OX1BST1BTW2ldO1xuICAgICAgICBpZiAoIShwcm9wWzBdIGluIHN0eWxlUHJvdG8pKSB7XG4gICAgICAgICAgICBzdHlsZVByb3RvW3Byb3BbMF1dID0gcHJvcFsxXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFByb3ZpZGUgZm9yIG90aGVyc1xuICAgIFN0eWxlLmdldEdyYWRpZW50ID0gc3R5bGVQcm90by5nZXRHcmFkaWVudDtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gU3R5bGU7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi96cmVuZGVyL2xpYi9ncmFwaGljL1N0eWxlLmpzXG4gKiogbW9kdWxlIGlkID0gOFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuLyoqXG4gKiBAbW9kdWxlIHpyZW5kZXIvRWxlbWVudFxuICovXG5cblxuICAgIHZhciBndWlkID0gcmVxdWlyZSgnLi9jb3JlL2d1aWQnKTtcbiAgICB2YXIgRXZlbnRmdWwgPSByZXF1aXJlKCcuL21peGluL0V2ZW50ZnVsJyk7XG4gICAgdmFyIFRyYW5zZm9ybWFibGUgPSByZXF1aXJlKCcuL21peGluL1RyYW5zZm9ybWFibGUnKTtcbiAgICB2YXIgQW5pbWF0YWJsZSA9IHJlcXVpcmUoJy4vbWl4aW4vQW5pbWF0YWJsZScpO1xuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCcuL2NvcmUvdXRpbCcpO1xuXG4gICAgLyoqXG4gICAgICogQGFsaWFzIG1vZHVsZTp6cmVuZGVyL0VsZW1lbnRcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAZXh0ZW5kcyB7bW9kdWxlOnpyZW5kZXIvbWl4aW4vQW5pbWF0YWJsZX1cbiAgICAgKiBAZXh0ZW5kcyB7bW9kdWxlOnpyZW5kZXIvbWl4aW4vVHJhbnNmb3JtYWJsZX1cbiAgICAgKiBAZXh0ZW5kcyB7bW9kdWxlOnpyZW5kZXIvbWl4aW4vRXZlbnRmdWx9XG4gICAgICovXG4gICAgdmFyIEVsZW1lbnQgPSBmdW5jdGlvbiAob3B0cykge1xuXG4gICAgICAgIFRyYW5zZm9ybWFibGUuY2FsbCh0aGlzLCBvcHRzKTtcbiAgICAgICAgRXZlbnRmdWwuY2FsbCh0aGlzLCBvcHRzKTtcbiAgICAgICAgQW5pbWF0YWJsZS5jYWxsKHRoaXMsIG9wdHMpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDnlLvluIPlhYPntKBJRFxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pZCA9IG9wdHMuaWQgfHwgZ3VpZCgpO1xuICAgIH07XG5cbiAgICBFbGVtZW50LnByb3RvdHlwZSA9IHtcblxuICAgICAgICAvKipcbiAgICAgICAgICog5YWD57Sg57G75Z6LXG4gICAgICAgICAqIEVsZW1lbnQgdHlwZVxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgdHlwZTogJ2VsZW1lbnQnLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlhYPntKDlkI3lrZdcbiAgICAgICAgICogRWxlbWVudCBuYW1lXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICBuYW1lOiAnJyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogWlJlbmRlciDlrp7kvovlr7nosaHvvIzkvJrlnKggZWxlbWVudCDmt7vliqDliLAgenJlbmRlciDlrp7kvovkuK3lkI7oh6rliqjotYvlgLxcbiAgICAgICAgICogWlJlbmRlciBpbnN0YW5jZSB3aWxsIGJlIGFzc2lnbmVkIHdoZW4gZWxlbWVudCBpcyBhc3NvY2lhdGVkIHdpdGggenJlbmRlclxuICAgICAgICAgKiBAbmFtZSBtb2R1bGU6L3pyZW5kZXIvRWxlbWVudCNfX3pyXG4gICAgICAgICAqIEB0eXBlIHttb2R1bGU6enJlbmRlci9aUmVuZGVyfVxuICAgICAgICAgKi9cbiAgICAgICAgX196cjogbnVsbCxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5Zu+5b2i5piv5ZCm5b+955Wl77yM5Li6dHJ1ZeaXtuW/veeVpeWbvuW9oueahOe7mOWItuS7peWPiuS6i+S7tuinpuWPkVxuICAgICAgICAgKiBJZiBpZ25vcmUgZHJhd2luZyBhbmQgZXZlbnRzIG9mIHRoZSBlbGVtZW50IG9iamVjdFxuICAgICAgICAgKiBAbmFtZSBtb2R1bGU6L3pyZW5kZXIvRWxlbWVudCNpZ25vcmVcbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICBpZ25vcmU6IGZhbHNlLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDnlKjkuo7oo4HliarnmoTot6/lvoQoc2hhcGUp77yM5omA5pyJIEdyb3VwIOWGheeahOi3r+W+hOWcqOe7mOWItuaXtumDveS8muiiq+i/meS4qui3r+W+hOijgeWJqlxuICAgICAgICAgKiDor6Xot6/lvoTkvJrnu6fmib/ooqvoo4Hlh4/lr7nosaHnmoTlj5jmjaJcbiAgICAgICAgICogQHR5cGUge21vZHVsZTp6cmVuZGVyL2dyYXBoaWMvUGF0aH1cbiAgICAgICAgICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi8yZGNvbnRleHQvI2NsaXBwaW5nLXJlZ2lvblxuICAgICAgICAgKiBAcmVhZE9ubHlcbiAgICAgICAgICovXG4gICAgICAgIGNsaXBQYXRoOiBudWxsLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEcmlmdCBlbGVtZW50XG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gZHggZHggb24gdGhlIGdsb2JhbCBzcGFjZVxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IGR5IGR5IG9uIHRoZSBnbG9iYWwgc3BhY2VcbiAgICAgICAgICovXG4gICAgICAgIGRyaWZ0OiBmdW5jdGlvbiAoZHgsIGR5KSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMuZHJhZ2dhYmxlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnaG9yaXpvbnRhbCc6XG4gICAgICAgICAgICAgICAgICAgIGR5ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAndmVydGljYWwnOlxuICAgICAgICAgICAgICAgICAgICBkeCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgbSA9IHRoaXMudHJhbnNmb3JtO1xuICAgICAgICAgICAgaWYgKCFtKSB7XG4gICAgICAgICAgICAgICAgbSA9IHRoaXMudHJhbnNmb3JtID0gWzEsIDAsIDAsIDEsIDAsIDBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbVs0XSArPSBkeDtcbiAgICAgICAgICAgIG1bNV0gKz0gZHk7XG5cbiAgICAgICAgICAgIHRoaXMuZGVjb21wb3NlVHJhbnNmb3JtKCk7XG4gICAgICAgICAgICB0aGlzLmRpcnR5KGZhbHNlKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogSG9vayBiZWZvcmUgdXBkYXRlXG4gICAgICAgICAqL1xuICAgICAgICBiZWZvcmVVcGRhdGU6IGZ1bmN0aW9uICgpIHt9LFxuICAgICAgICAvKipcbiAgICAgICAgICogSG9vayBhZnRlciB1cGRhdGVcbiAgICAgICAgICovXG4gICAgICAgIGFmdGVyVXBkYXRlOiBmdW5jdGlvbiAoKSB7fSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVwZGF0ZSBlYWNoIGZyYW1lXG4gICAgICAgICAqL1xuICAgICAgICB1cGRhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlVHJhbnNmb3JtKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBjYlxuICAgICAgICAgKiBAcGFyYW0gIHt9ICAgY29udGV4dFxuICAgICAgICAgKi9cbiAgICAgICAgdHJhdmVyc2U6IGZ1bmN0aW9uIChjYiwgY29udGV4dCkge30sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGF0dHJLVjogZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChrZXkgPT09ICdwb3NpdGlvbicgfHwga2V5ID09PSAnc2NhbGUnIHx8IGtleSA9PT0gJ29yaWdpbicpIHtcbiAgICAgICAgICAgICAgICAvLyBDb3B5IHRoZSBhcnJheVxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0ID0gdGhpc1trZXldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRhcmdldCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0ID0gdGhpc1trZXldID0gW107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0WzBdID0gdmFsdWVbMF07XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFsxXSA9IHZhbHVlWzFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXNba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBIaWRlIHRoZSBlbGVtZW50XG4gICAgICAgICAqL1xuICAgICAgICBoaWRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLmlnbm9yZSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9fenIgJiYgdGhpcy5fX3pyLnJlZnJlc2goKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogU2hvdyB0aGUgZWxlbWVudFxuICAgICAgICAgKi9cbiAgICAgICAgc2hvdzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5pZ25vcmUgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX196ciAmJiB0aGlzLl9fenIucmVmcmVzaCgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ3xPYmplY3R9IGtleVxuICAgICAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICAgICAqL1xuICAgICAgICBhdHRyOiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hdHRyS1Yoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh6clV0aWwuaXNPYmplY3Qoa2V5KSkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIG5hbWUgaW4ga2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChrZXkuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXR0cktWKG5hbWUsIGtleVtuYW1lXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuZGlydHkoZmFsc2UpO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9ncmFwaGljL1BhdGh9IGNsaXBQYXRoXG4gICAgICAgICAqL1xuICAgICAgICBzZXRDbGlwUGF0aDogZnVuY3Rpb24gKGNsaXBQYXRoKSB7XG4gICAgICAgICAgICB2YXIgenIgPSB0aGlzLl9fenI7XG4gICAgICAgICAgICBpZiAoenIpIHtcbiAgICAgICAgICAgICAgICBjbGlwUGF0aC5hZGRTZWxmVG9acih6cik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFJlbW92ZSBwcmV2aW91cyBjbGlwIHBhdGhcbiAgICAgICAgICAgIGlmICh0aGlzLmNsaXBQYXRoICYmIHRoaXMuY2xpcFBhdGggIT09IGNsaXBQYXRoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVDbGlwUGF0aCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmNsaXBQYXRoID0gY2xpcFBhdGg7XG4gICAgICAgICAgICBjbGlwUGF0aC5fX3pyID0genI7XG4gICAgICAgICAgICBjbGlwUGF0aC5fX2NsaXBUYXJnZXQgPSB0aGlzO1xuXG4gICAgICAgICAgICB0aGlzLmRpcnR5KGZhbHNlKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICovXG4gICAgICAgIHJlbW92ZUNsaXBQYXRoOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgY2xpcFBhdGggPSB0aGlzLmNsaXBQYXRoO1xuICAgICAgICAgICAgaWYgKGNsaXBQYXRoKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNsaXBQYXRoLl9fenIpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xpcFBhdGgucmVtb3ZlU2VsZkZyb21acihjbGlwUGF0aC5fX3pyKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjbGlwUGF0aC5fX3pyID0gbnVsbDtcbiAgICAgICAgICAgICAgICBjbGlwUGF0aC5fX2NsaXBUYXJnZXQgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMuY2xpcFBhdGggPSBudWxsO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5kaXJ0eShmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFkZCBzZWxmIGZyb20genJlbmRlciBpbnN0YW5jZS5cbiAgICAgICAgICogTm90IHJlY3Vyc2l2ZWx5IGJlY2F1c2UgaXQgd2lsbCBiZSBpbnZva2VkIHdoZW4gZWxlbWVudCBhZGRlZCB0byBzdG9yYWdlLlxuICAgICAgICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL1pSZW5kZXJ9IHpyXG4gICAgICAgICAqL1xuICAgICAgICBhZGRTZWxmVG9acjogZnVuY3Rpb24gKHpyKSB7XG4gICAgICAgICAgICB0aGlzLl9fenIgPSB6cjtcbiAgICAgICAgICAgIC8vIOa3u+WKoOWKqOeUu1xuICAgICAgICAgICAgdmFyIGFuaW1hdG9ycyA9IHRoaXMuYW5pbWF0b3JzO1xuICAgICAgICAgICAgaWYgKGFuaW1hdG9ycykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYW5pbWF0b3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHpyLmFuaW1hdGlvbi5hZGRBbmltYXRvcihhbmltYXRvcnNbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMuY2xpcFBhdGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNsaXBQYXRoLmFkZFNlbGZUb1pyKHpyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmVtb3ZlIHNlbGYgZnJvbSB6cmVuZGVyIGluc3RhbmNlLlxuICAgICAgICAgKiBOb3QgcmVjdXJzaXZlbHkgYmVjYXVzZSBpdCB3aWxsIGJlIGludm9rZWQgd2hlbiBlbGVtZW50IGFkZGVkIHRvIHN0b3JhZ2UuXG4gICAgICAgICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvWlJlbmRlcn0genJcbiAgICAgICAgICovXG4gICAgICAgIHJlbW92ZVNlbGZGcm9tWnI6IGZ1bmN0aW9uICh6cikge1xuICAgICAgICAgICAgdGhpcy5fX3pyID0gbnVsbDtcbiAgICAgICAgICAgIC8vIOenu+mZpOWKqOeUu1xuICAgICAgICAgICAgdmFyIGFuaW1hdG9ycyA9IHRoaXMuYW5pbWF0b3JzO1xuICAgICAgICAgICAgaWYgKGFuaW1hdG9ycykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYW5pbWF0b3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHpyLmFuaW1hdGlvbi5yZW1vdmVBbmltYXRvcihhbmltYXRvcnNbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMuY2xpcFBhdGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNsaXBQYXRoLnJlbW92ZVNlbGZGcm9tWnIoenIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIHpyVXRpbC5taXhpbihFbGVtZW50LCBBbmltYXRhYmxlKTtcbiAgICB6clV0aWwubWl4aW4oRWxlbWVudCwgVHJhbnNmb3JtYWJsZSk7XG4gICAgenJVdGlsLm1peGluKEVsZW1lbnQsIEV2ZW50ZnVsKTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gRWxlbWVudDtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3pyZW5kZXIvbGliL0VsZW1lbnQuanNcbiAqKiBtb2R1bGUgaWQgPSA5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIHpyZW5kZXI6IOeUn+aIkOWUr+S4gGlkXG4gKlxuICogQGF1dGhvciBlcnJvcnJpayAoZXJyb3JyaWtAZ21haWwuY29tKVxuICovXG5cblxuICAgIHZhciBpZFN0YXJ0ID0gMHgwOTA3O1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBpZFN0YXJ0Kys7XG4gICAgfTtcblxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34venJlbmRlci9saWIvY29yZS9ndWlkLmpzXG4gKiogbW9kdWxlIGlkID0gMTBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICog5LqL5Lu25omp5bGVXG4gKiBAbW9kdWxlIHpyZW5kZXIvbWl4aW4vRXZlbnRmdWxcbiAqIEBhdXRob3IgS2VuZXIgKEBLZW5lci3mnpfls7AsIGtlbmVyLmxpbmZlbmdAZ21haWwuY29tKVxuICogICAgICAgICBwaXNzYW5nIChodHRwczovL3d3dy5naXRodWIuY29tL3Bpc3NhbmcpXG4gKi9cblxuXG4gICAgdmFyIGFycnlTbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcblxuICAgIC8qKlxuICAgICAqIOS6i+S7tuWIhuWPkeWZqFxuICAgICAqIEBhbGlhcyBtb2R1bGU6enJlbmRlci9taXhpbi9FdmVudGZ1bFxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIHZhciBFdmVudGZ1bCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fJGhhbmRsZXJzID0ge307XG4gICAgfTtcblxuICAgIEV2ZW50ZnVsLnByb3RvdHlwZSA9IHtcblxuICAgICAgICBjb25zdHJ1Y3RvcjogRXZlbnRmdWwsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWNleasoeinpuWPkee7keWumu+8jHRyaWdnZXLlkI7plIDmr4FcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50IOS6i+S7tuWQjVxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyIOWTjeW6lOWHveaVsFxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY29udGV4dFxuICAgICAgICAgKi9cbiAgICAgICAgb25lOiBmdW5jdGlvbiAoZXZlbnQsIGhhbmRsZXIsIGNvbnRleHQpIHtcbiAgICAgICAgICAgIHZhciBfaCA9IHRoaXMuXyRoYW5kbGVycztcblxuICAgICAgICAgICAgaWYgKCFoYW5kbGVyIHx8ICFldmVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIV9oW2V2ZW50XSkge1xuICAgICAgICAgICAgICAgIF9oW2V2ZW50XSA9IFtdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IF9oW2V2ZW50XS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChfaFtldmVudF1baV0uaCA9PT0gaGFuZGxlcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9oW2V2ZW50XS5wdXNoKHtcbiAgICAgICAgICAgICAgICBoOiBoYW5kbGVyLFxuICAgICAgICAgICAgICAgIG9uZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBjdHg6IGNvbnRleHQgfHwgdGhpc1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDnu5Hlrprkuovku7ZcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50IOS6i+S7tuWQjVxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyIOS6i+S7tuWkhOeQhuWHveaVsFxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbnRleHRdXG4gICAgICAgICAqL1xuICAgICAgICBvbjogZnVuY3Rpb24gKGV2ZW50LCBoYW5kbGVyLCBjb250ZXh0KSB7XG4gICAgICAgICAgICB2YXIgX2ggPSB0aGlzLl8kaGFuZGxlcnM7XG5cbiAgICAgICAgICAgIGlmICghaGFuZGxlciB8fCAhZXZlbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFfaFtldmVudF0pIHtcbiAgICAgICAgICAgICAgICBfaFtldmVudF0gPSBbXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBfaFtldmVudF0ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoX2hbZXZlbnRdW2ldLmggPT09IGhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfaFtldmVudF0ucHVzaCh7XG4gICAgICAgICAgICAgICAgaDogaGFuZGxlcixcbiAgICAgICAgICAgICAgICBvbmU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGN0eDogY29udGV4dCB8fCB0aGlzXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOaYr+WQpue7keWumuS6huS6i+S7tlxuICAgICAgICAgKiBAcGFyYW0gIHtzdHJpbmd9ICBldmVudFxuICAgICAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgaXNTaWxlbnQ6IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgdmFyIF9oID0gdGhpcy5fJGhhbmRsZXJzO1xuICAgICAgICAgICAgcmV0dXJuIF9oW2V2ZW50XSAmJiBfaFtldmVudF0ubGVuZ3RoO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDop6Pnu5Hkuovku7ZcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50IOS6i+S7tuWQjVxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaGFuZGxlcl0g5LqL5Lu25aSE55CG5Ye95pWwXG4gICAgICAgICAqL1xuICAgICAgICBvZmY6IGZ1bmN0aW9uIChldmVudCwgaGFuZGxlcikge1xuICAgICAgICAgICAgdmFyIF9oID0gdGhpcy5fJGhhbmRsZXJzO1xuXG4gICAgICAgICAgICBpZiAoIWV2ZW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fJGhhbmRsZXJzID0ge307XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChoYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgaWYgKF9oW2V2ZW50XSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmV3TGlzdCA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IF9oW2V2ZW50XS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfaFtldmVudF1baV1bJ2gnXSAhPSBoYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3TGlzdC5wdXNoKF9oW2V2ZW50XVtpXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgX2hbZXZlbnRdID0gbmV3TGlzdDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoX2hbZXZlbnRdICYmIF9oW2V2ZW50XS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIF9oW2V2ZW50XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgX2hbZXZlbnRdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5LqL5Lu25YiG5Y+RXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIOS6i+S7tuexu+Wei1xuICAgICAgICAgKi9cbiAgICAgICAgdHJpZ2dlcjogZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl8kaGFuZGxlcnNbdHlwZV0pIHtcbiAgICAgICAgICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgICAgICAgICB2YXIgYXJnTGVuID0gYXJncy5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgICBpZiAoYXJnTGVuID4gMykge1xuICAgICAgICAgICAgICAgICAgICBhcmdzID0gYXJyeVNsaWNlLmNhbGwoYXJncywgMSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIF9oID0gdGhpcy5fJGhhbmRsZXJzW3R5cGVdO1xuICAgICAgICAgICAgICAgIHZhciBsZW4gPSBfaC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE9wdGltaXplIGFkdmlzZSBmcm9tIGJhY2tib25lXG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoYXJnTGVuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2hbaV1bJ2gnXS5jYWxsKF9oW2ldWydjdHgnXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2hbaV1bJ2gnXS5jYWxsKF9oW2ldWydjdHgnXSwgYXJnc1sxXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2hbaV1bJ2gnXS5jYWxsKF9oW2ldWydjdHgnXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGhhdmUgbW9yZSB0aGFuIDIgZ2l2ZW4gYXJndW1lbnRzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2hbaV1bJ2gnXS5hcHBseShfaFtpXVsnY3R4J10sIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKF9oW2ldWydvbmUnXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX2guc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVuLS07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDluKbmnIljb250ZXh055qE5LqL5Lu25YiG5Y+RLCDmnIDlkI7kuIDkuKrlj4LmlbDmmK/kuovku7blm57osIPnmoRjb250ZXh0XG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIOS6i+S7tuexu+Wei1xuICAgICAgICAgKi9cbiAgICAgICAgdHJpZ2dlcldpdGhDb250ZXh0OiBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuXyRoYW5kbGVyc1t0eXBlXSkge1xuICAgICAgICAgICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgICAgICAgICAgIHZhciBhcmdMZW4gPSBhcmdzLmxlbmd0aDtcblxuICAgICAgICAgICAgICAgIGlmIChhcmdMZW4gPiA0KSB7XG4gICAgICAgICAgICAgICAgICAgIGFyZ3MgPSBhcnJ5U2xpY2UuY2FsbChhcmdzLCAxLCBhcmdzLmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgY3R4ID0gYXJnc1thcmdzLmxlbmd0aCAtIDFdO1xuXG4gICAgICAgICAgICAgICAgdmFyIF9oID0gdGhpcy5fJGhhbmRsZXJzW3R5cGVdO1xuICAgICAgICAgICAgICAgIHZhciBsZW4gPSBfaC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE9wdGltaXplIGFkdmlzZSBmcm9tIGJhY2tib25lXG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoYXJnTGVuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2hbaV1bJ2gnXS5jYWxsKGN0eCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2hbaV1bJ2gnXS5jYWxsKGN0eCwgYXJnc1sxXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2hbaV1bJ2gnXS5jYWxsKGN0eCwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGhhdmUgbW9yZSB0aGFuIDIgZ2l2ZW4gYXJndW1lbnRzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2hbaV1bJ2gnXS5hcHBseShjdHgsIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKF9oW2ldWydvbmUnXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX2guc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVuLS07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vIOWvueixoeWPr+S7pemAmui/hyBvbnh4eHgg57uR5a6a5LqL5Lu2XG4gICAgLyoqXG4gICAgICogQGV2ZW50IG1vZHVsZTp6cmVuZGVyL21peGluL0V2ZW50ZnVsI29uY2xpY2tcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICogQGRlZmF1bHQgbnVsbFxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIEBldmVudCBtb2R1bGU6enJlbmRlci9taXhpbi9FdmVudGZ1bCNvbm1vdXNlb3ZlclxuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICovXG4gICAgLyoqXG4gICAgICogQGV2ZW50IG1vZHVsZTp6cmVuZGVyL21peGluL0V2ZW50ZnVsI29ubW91c2VvdXRcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICogQGRlZmF1bHQgbnVsbFxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIEBldmVudCBtb2R1bGU6enJlbmRlci9taXhpbi9FdmVudGZ1bCNvbm1vdXNlbW92ZVxuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICovXG4gICAgLyoqXG4gICAgICogQGV2ZW50IG1vZHVsZTp6cmVuZGVyL21peGluL0V2ZW50ZnVsI29ubW91c2V3aGVlbFxuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICovXG4gICAgLyoqXG4gICAgICogQGV2ZW50IG1vZHVsZTp6cmVuZGVyL21peGluL0V2ZW50ZnVsI29ubW91c2Vkb3duXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAqIEBkZWZhdWx0IG51bGxcbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBAZXZlbnQgbW9kdWxlOnpyZW5kZXIvbWl4aW4vRXZlbnRmdWwjb25tb3VzZXVwXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAqIEBkZWZhdWx0IG51bGxcbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBAZXZlbnQgbW9kdWxlOnpyZW5kZXIvbWl4aW4vRXZlbnRmdWwjb25kcmFnc3RhcnRcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICogQGRlZmF1bHQgbnVsbFxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIEBldmVudCBtb2R1bGU6enJlbmRlci9taXhpbi9FdmVudGZ1bCNvbmRyYWdlbmRcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICogQGRlZmF1bHQgbnVsbFxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIEBldmVudCBtb2R1bGU6enJlbmRlci9taXhpbi9FdmVudGZ1bCNvbmRyYWdlbnRlclxuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICovXG4gICAgLyoqXG4gICAgICogQGV2ZW50IG1vZHVsZTp6cmVuZGVyL21peGluL0V2ZW50ZnVsI29uZHJhZ2xlYXZlXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAqIEBkZWZhdWx0IG51bGxcbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBAZXZlbnQgbW9kdWxlOnpyZW5kZXIvbWl4aW4vRXZlbnRmdWwjb25kcmFnb3ZlclxuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICovXG4gICAgLyoqXG4gICAgICogQGV2ZW50IG1vZHVsZTp6cmVuZGVyL21peGluL0V2ZW50ZnVsI29uZHJvcFxuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICovXG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IEV2ZW50ZnVsO1xuXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi96cmVuZGVyL2xpYi9taXhpbi9FdmVudGZ1bC5qc1xuICoqIG1vZHVsZSBpZCA9IDExXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG4vKipcbiAqIOaPkOS+m+WPmOaNouaJqeWxlVxuICogQG1vZHVsZSB6cmVuZGVyL21peGluL1RyYW5zZm9ybWFibGVcbiAqIEBhdXRob3IgcGlzc2FuZyAoaHR0cHM6Ly93d3cuZ2l0aHViLmNvbS9waXNzYW5nKVxuICovXG5cblxuICAgIHZhciBtYXRyaXggPSByZXF1aXJlKCcuLi9jb3JlL21hdHJpeCcpO1xuICAgIHZhciB2ZWN0b3IgPSByZXF1aXJlKCcuLi9jb3JlL3ZlY3RvcicpO1xuICAgIHZhciBtSWRlbnRpdHkgPSBtYXRyaXguaWRlbnRpdHk7XG5cbiAgICB2YXIgRVBTSUxPTiA9IDVlLTU7XG5cbiAgICBmdW5jdGlvbiBpc05vdEFyb3VuZFplcm8odmFsKSB7XG4gICAgICAgIHJldHVybiB2YWwgPiBFUFNJTE9OIHx8IHZhbCA8IC1FUFNJTE9OO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBhbGlhcyBtb2R1bGU6enJlbmRlci9taXhpbi9UcmFuc2Zvcm1hYmxlXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICovXG4gICAgdmFyIFRyYW5zZm9ybWFibGUgPSBmdW5jdGlvbiAob3B0cykge1xuICAgICAgICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgICAgICAgLy8gSWYgdGhlcmUgYXJlIG5vIGdpdmVuIHBvc2l0aW9uLCByb3RhdGlvbiwgc2NhbGVcbiAgICAgICAgaWYgKCFvcHRzLnBvc2l0aW9uKSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIOW5s+enu1xuICAgICAgICAgICAgICogQHR5cGUge0FycmF5LjxudW1iZXI+fVxuICAgICAgICAgICAgICogQGRlZmF1bHQgWzAsIDBdXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMucG9zaXRpb24gPSBbMCwgMF07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdHMucm90YXRpb24gPT0gbnVsbCkge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiDml4vovaxcbiAgICAgICAgICAgICAqIEB0eXBlIHtBcnJheS48bnVtYmVyPn1cbiAgICAgICAgICAgICAqIEBkZWZhdWx0IDBcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5yb3RhdGlvbiA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFvcHRzLnNjYWxlKSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIOe8qeaUvlxuICAgICAgICAgICAgICogQHR5cGUge0FycmF5LjxudW1iZXI+fVxuICAgICAgICAgICAgICogQGRlZmF1bHQgWzEsIDFdXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuc2NhbGUgPSBbMSwgMV07XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOaXi+i9rOWSjOe8qeaUvueahOWOn+eCuVxuICAgICAgICAgKiBAdHlwZSB7QXJyYXkuPG51bWJlcj59XG4gICAgICAgICAqIEBkZWZhdWx0IG51bGxcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMub3JpZ2luID0gdGhpcy5vcmlnaW4gfHwgbnVsbDtcbiAgICB9O1xuXG4gICAgdmFyIHRyYW5zZm9ybWFibGVQcm90byA9IFRyYW5zZm9ybWFibGUucHJvdG90eXBlO1xuICAgIHRyYW5zZm9ybWFibGVQcm90by50cmFuc2Zvcm0gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICog5Yik5pat5piv5ZCm6ZyA6KaB5pyJ5Z2Q5qCH5Y+Y5o2iXG4gICAgICog5aaC5p6c5pyJ5Z2Q5qCH5Y+Y5o2iLCDliJnku45wb3NpdGlvbiwgcm90YXRpb24sIHNjYWxl5Lul5Y+K54i26IqC54K555qEdHJhbnNmb3Jt6K6h566X5Ye66Ieq6Lqr55qEdHJhbnNmb3Jt55+p6Zi1XG4gICAgICovXG4gICAgdHJhbnNmb3JtYWJsZVByb3RvLm5lZWRMb2NhbFRyYW5zZm9ybSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGlzTm90QXJvdW5kWmVybyh0aGlzLnJvdGF0aW9uKVxuICAgICAgICAgICAgfHwgaXNOb3RBcm91bmRaZXJvKHRoaXMucG9zaXRpb25bMF0pXG4gICAgICAgICAgICB8fCBpc05vdEFyb3VuZFplcm8odGhpcy5wb3NpdGlvblsxXSlcbiAgICAgICAgICAgIHx8IGlzTm90QXJvdW5kWmVybyh0aGlzLnNjYWxlWzBdIC0gMSlcbiAgICAgICAgICAgIHx8IGlzTm90QXJvdW5kWmVybyh0aGlzLnNjYWxlWzFdIC0gMSk7XG4gICAgfTtcblxuICAgIHRyYW5zZm9ybWFibGVQcm90by51cGRhdGVUcmFuc2Zvcm0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBwYXJlbnQgPSB0aGlzLnBhcmVudDtcbiAgICAgICAgdmFyIHBhcmVudEhhc1RyYW5zZm9ybSA9IHBhcmVudCAmJiBwYXJlbnQudHJhbnNmb3JtO1xuICAgICAgICB2YXIgbmVlZExvY2FsVHJhbnNmb3JtID0gdGhpcy5uZWVkTG9jYWxUcmFuc2Zvcm0oKTtcblxuICAgICAgICB2YXIgbSA9IHRoaXMudHJhbnNmb3JtO1xuICAgICAgICBpZiAoIShuZWVkTG9jYWxUcmFuc2Zvcm0gfHwgcGFyZW50SGFzVHJhbnNmb3JtKSkge1xuICAgICAgICAgICAgbSAmJiBtSWRlbnRpdHkobSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBtID0gbSB8fCBtYXRyaXguY3JlYXRlKCk7XG5cbiAgICAgICAgaWYgKG5lZWRMb2NhbFRyYW5zZm9ybSkge1xuICAgICAgICAgICAgdGhpcy5nZXRMb2NhbFRyYW5zZm9ybShtKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1JZGVudGl0eShtKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIOW6lOeUqOeItuiKgueCueWPmOaNolxuICAgICAgICBpZiAocGFyZW50SGFzVHJhbnNmb3JtKSB7XG4gICAgICAgICAgICBpZiAobmVlZExvY2FsVHJhbnNmb3JtKSB7XG4gICAgICAgICAgICAgICAgbWF0cml4Lm11bChtLCBwYXJlbnQudHJhbnNmb3JtLCBtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG1hdHJpeC5jb3B5KG0sIHBhcmVudC50cmFuc2Zvcm0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIOS/neWtmOi/meS4quWPmOaNouefqemYtVxuICAgICAgICB0aGlzLnRyYW5zZm9ybSA9IG07XG5cbiAgICAgICAgdGhpcy5pbnZUcmFuc2Zvcm0gPSB0aGlzLmludlRyYW5zZm9ybSB8fCBtYXRyaXguY3JlYXRlKCk7XG4gICAgICAgIG1hdHJpeC5pbnZlcnQodGhpcy5pbnZUcmFuc2Zvcm0sIG0pO1xuICAgIH07XG5cbiAgICB0cmFuc2Zvcm1hYmxlUHJvdG8uZ2V0TG9jYWxUcmFuc2Zvcm0gPSBmdW5jdGlvbiAobSkge1xuICAgICAgICBtID0gbSB8fCBbXTtcbiAgICAgICAgbUlkZW50aXR5KG0pO1xuXG4gICAgICAgIHZhciBvcmlnaW4gPSB0aGlzLm9yaWdpbjtcblxuICAgICAgICB2YXIgc2NhbGUgPSB0aGlzLnNjYWxlO1xuICAgICAgICB2YXIgcm90YXRpb24gPSB0aGlzLnJvdGF0aW9uO1xuICAgICAgICB2YXIgcG9zaXRpb24gPSB0aGlzLnBvc2l0aW9uO1xuICAgICAgICBpZiAob3JpZ2luKSB7XG4gICAgICAgICAgICAvLyBUcmFuc2xhdGUgdG8gb3JpZ2luXG4gICAgICAgICAgICBtWzRdIC09IG9yaWdpblswXTtcbiAgICAgICAgICAgIG1bNV0gLT0gb3JpZ2luWzFdO1xuICAgICAgICB9XG4gICAgICAgIG1hdHJpeC5zY2FsZShtLCBtLCBzY2FsZSk7XG4gICAgICAgIGlmIChyb3RhdGlvbikge1xuICAgICAgICAgICAgbWF0cml4LnJvdGF0ZShtLCBtLCByb3RhdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9yaWdpbikge1xuICAgICAgICAgICAgLy8gVHJhbnNsYXRlIGJhY2sgZnJvbSBvcmlnaW5cbiAgICAgICAgICAgIG1bNF0gKz0gb3JpZ2luWzBdO1xuICAgICAgICAgICAgbVs1XSArPSBvcmlnaW5bMV07XG4gICAgICAgIH1cblxuICAgICAgICBtWzRdICs9IHBvc2l0aW9uWzBdO1xuICAgICAgICBtWzVdICs9IHBvc2l0aW9uWzFdO1xuXG4gICAgICAgIHJldHVybiBtO1xuICAgIH07XG4gICAgLyoqXG4gICAgICog5bCG6Ieq5bex55qEdHJhbnNmb3Jt5bqU55So5YiwY29udGV4dOS4ilxuICAgICAqIEBwYXJhbSB7Q29udGV4dDJEfSBjdHhcbiAgICAgKi9cbiAgICB0cmFuc2Zvcm1hYmxlUHJvdG8uc2V0VHJhbnNmb3JtID0gZnVuY3Rpb24gKGN0eCkge1xuICAgICAgICB2YXIgbSA9IHRoaXMudHJhbnNmb3JtO1xuICAgICAgICB2YXIgZHByID0gY3R4LmRwciB8fCAxO1xuICAgICAgICBpZiAobSkge1xuICAgICAgICAgICAgY3R4LnNldFRyYW5zZm9ybShkcHIgKiBtWzBdLCBkcHIgKiBtWzFdLCBkcHIgKiBtWzJdLCBkcHIgKiBtWzNdLCBkcHIgKiBtWzRdLCBkcHIgKiBtWzVdKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGN0eC5zZXRUcmFuc2Zvcm0oZHByLCAwLCAwLCBkcHIsIDAsIDApO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHRyYW5zZm9ybWFibGVQcm90by5yZXN0b3JlVHJhbnNmb3JtID0gZnVuY3Rpb24gKGN0eCkge1xuICAgICAgICB2YXIgbSA9IHRoaXMudHJhbnNmb3JtO1xuICAgICAgICB2YXIgZHByID0gY3R4LmRwciB8fCAxO1xuICAgICAgICBjdHguc2V0VHJhbnNmb3JtKGRwciwgMCwgMCwgZHByLCAwLCAwKTtcbiAgICB9XG5cbiAgICB2YXIgdG1wVHJhbnNmb3JtID0gW107XG5cbiAgICAvKipcbiAgICAgKiDliIbop6NgdHJhbnNmb3JtYOefqemYteWIsGBwb3NpdGlvbmAsIGByb3RhdGlvbmAsIGBzY2FsZWBcbiAgICAgKi9cbiAgICB0cmFuc2Zvcm1hYmxlUHJvdG8uZGVjb21wb3NlVHJhbnNmb3JtID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMudHJhbnNmb3JtKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBhcmVudCA9IHRoaXMucGFyZW50O1xuICAgICAgICB2YXIgbSA9IHRoaXMudHJhbnNmb3JtO1xuICAgICAgICBpZiAocGFyZW50ICYmIHBhcmVudC50cmFuc2Zvcm0pIHtcbiAgICAgICAgICAgIC8vIEdldCBsb2NhbCB0cmFuc2Zvcm0gYW5kIGRlY29tcG9zZSB0aGVtIHRvIHBvc2l0aW9uLCBzY2FsZSwgcm90YXRpb25cbiAgICAgICAgICAgIG1hdHJpeC5tdWwodG1wVHJhbnNmb3JtLCBwYXJlbnQuaW52VHJhbnNmb3JtLCBtKTtcbiAgICAgICAgICAgIG0gPSB0bXBUcmFuc2Zvcm07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN4ID0gbVswXSAqIG1bMF0gKyBtWzFdICogbVsxXTtcbiAgICAgICAgdmFyIHN5ID0gbVsyXSAqIG1bMl0gKyBtWzNdICogbVszXTtcbiAgICAgICAgdmFyIHBvc2l0aW9uID0gdGhpcy5wb3NpdGlvbjtcbiAgICAgICAgdmFyIHNjYWxlID0gdGhpcy5zY2FsZTtcbiAgICAgICAgaWYgKGlzTm90QXJvdW5kWmVybyhzeCAtIDEpKSB7XG4gICAgICAgICAgICBzeCA9IE1hdGguc3FydChzeCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzTm90QXJvdW5kWmVybyhzeSAtIDEpKSB7XG4gICAgICAgICAgICBzeSA9IE1hdGguc3FydChzeSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1bMF0gPCAwKSB7XG4gICAgICAgICAgICBzeCA9IC1zeDtcbiAgICAgICAgfVxuICAgICAgICBpZiAobVszXSA8IDApIHtcbiAgICAgICAgICAgIHN5ID0gLXN5O1xuICAgICAgICB9XG4gICAgICAgIHBvc2l0aW9uWzBdID0gbVs0XTtcbiAgICAgICAgcG9zaXRpb25bMV0gPSBtWzVdO1xuICAgICAgICBzY2FsZVswXSA9IHN4O1xuICAgICAgICBzY2FsZVsxXSA9IHN5O1xuICAgICAgICB0aGlzLnJvdGF0aW9uID0gTWF0aC5hdGFuMigtbVsxXSAvIHN5LCBtWzBdIC8gc3gpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgZ2xvYmFsIHNjYWxlXG4gICAgICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59XG4gICAgICovXG4gICAgdHJhbnNmb3JtYWJsZVByb3RvLmdldEdsb2JhbFNjYWxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbSA9IHRoaXMudHJhbnNmb3JtO1xuICAgICAgICBpZiAoIW0pIHtcbiAgICAgICAgICAgIHJldHVybiBbMSwgMV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN4ID0gTWF0aC5zcXJ0KG1bMF0gKiBtWzBdICsgbVsxXSAqIG1bMV0pO1xuICAgICAgICB2YXIgc3kgPSBNYXRoLnNxcnQobVsyXSAqIG1bMl0gKyBtWzNdICogbVszXSk7XG4gICAgICAgIGlmIChtWzBdIDwgMCkge1xuICAgICAgICAgICAgc3ggPSAtc3g7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1bM10gPCAwKSB7XG4gICAgICAgICAgICBzeSA9IC1zeTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW3N4LCBzeV07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiDlj5jmjaLlnZDmoIfkvY3nva7liLAgc2hhcGUg55qE5bGA6YOo5Z2Q5qCH56m66Ze0XG4gICAgICogQG1ldGhvZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHlcbiAgICAgKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn1cbiAgICAgKi9cbiAgICB0cmFuc2Zvcm1hYmxlUHJvdG8udHJhbnNmb3JtQ29vcmRUb0xvY2FsID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgdmFyIHYyID0gW3gsIHldO1xuICAgICAgICB2YXIgaW52VHJhbnNmb3JtID0gdGhpcy5pbnZUcmFuc2Zvcm07XG4gICAgICAgIGlmIChpbnZUcmFuc2Zvcm0pIHtcbiAgICAgICAgICAgIHZlY3Rvci5hcHBseVRyYW5zZm9ybSh2MiwgdjIsIGludlRyYW5zZm9ybSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHYyO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiDlj5jmjaLlsYDpg6jlnZDmoIfkvY3nva7liLDlhajlsYDlnZDmoIfnqbrpl7RcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geVxuICAgICAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fVxuICAgICAqL1xuICAgIHRyYW5zZm9ybWFibGVQcm90by50cmFuc2Zvcm1Db29yZFRvR2xvYmFsID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgdmFyIHYyID0gW3gsIHldO1xuICAgICAgICB2YXIgdHJhbnNmb3JtID0gdGhpcy50cmFuc2Zvcm07XG4gICAgICAgIGlmICh0cmFuc2Zvcm0pIHtcbiAgICAgICAgICAgIHZlY3Rvci5hcHBseVRyYW5zZm9ybSh2MiwgdjIsIHRyYW5zZm9ybSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHYyO1xuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IFRyYW5zZm9ybWFibGU7XG5cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3pyZW5kZXIvbGliL21peGluL1RyYW5zZm9ybWFibGUuanNcbiAqKiBtb2R1bGUgaWQgPSAxMlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXG4gICAgdmFyIEFycmF5Q3RvciA9IHR5cGVvZiBGbG9hdDMyQXJyYXkgPT09ICd1bmRlZmluZWQnXG4gICAgICAgID8gQXJyYXlcbiAgICAgICAgOiBGbG9hdDMyQXJyYXk7XG4gICAgLyoqXG4gICAgICogM3gy55+p6Zi15pON5L2c57G7XG4gICAgICogQGV4cG9ydHMgenJlbmRlci90b29sL21hdHJpeFxuICAgICAqL1xuICAgIHZhciBtYXRyaXggPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiDliJvlu7rkuIDkuKrljZXkvY3nn6npmLVcbiAgICAgICAgICogQHJldHVybiB7RmxvYXQzMkFycmF5fEFycmF5LjxudW1iZXI+fVxuICAgICAgICAgKi9cbiAgICAgICAgY3JlYXRlIDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgb3V0ID0gbmV3IEFycmF5Q3Rvcig2KTtcbiAgICAgICAgICAgIG1hdHJpeC5pZGVudGl0eShvdXQpO1xuXG4gICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICog6K6+572u55+p6Zi15Li65Y2V5L2N55+p6Zi1XG4gICAgICAgICAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fEFycmF5LjxudW1iZXI+fSBvdXRcbiAgICAgICAgICovXG4gICAgICAgIGlkZW50aXR5IDogZnVuY3Rpb24ob3V0KSB7XG4gICAgICAgICAgICBvdXRbMF0gPSAxO1xuICAgICAgICAgICAgb3V0WzFdID0gMDtcbiAgICAgICAgICAgIG91dFsyXSA9IDA7XG4gICAgICAgICAgICBvdXRbM10gPSAxO1xuICAgICAgICAgICAgb3V0WzRdID0gMDtcbiAgICAgICAgICAgIG91dFs1XSA9IDA7XG4gICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICog5aSN5Yi255+p6Zi1XG4gICAgICAgICAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fEFycmF5LjxudW1iZXI+fSBvdXRcbiAgICAgICAgICogQHBhcmFtIHtGbG9hdDMyQXJyYXl8QXJyYXkuPG51bWJlcj59IG1cbiAgICAgICAgICovXG4gICAgICAgIGNvcHk6IGZ1bmN0aW9uKG91dCwgbSkge1xuICAgICAgICAgICAgb3V0WzBdID0gbVswXTtcbiAgICAgICAgICAgIG91dFsxXSA9IG1bMV07XG4gICAgICAgICAgICBvdXRbMl0gPSBtWzJdO1xuICAgICAgICAgICAgb3V0WzNdID0gbVszXTtcbiAgICAgICAgICAgIG91dFs0XSA9IG1bNF07XG4gICAgICAgICAgICBvdXRbNV0gPSBtWzVdO1xuICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOefqemYteebuOS5mFxuICAgICAgICAgKiBAcGFyYW0ge0Zsb2F0MzJBcnJheXxBcnJheS48bnVtYmVyPn0gb3V0XG4gICAgICAgICAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fEFycmF5LjxudW1iZXI+fSBtMVxuICAgICAgICAgKiBAcGFyYW0ge0Zsb2F0MzJBcnJheXxBcnJheS48bnVtYmVyPn0gbTJcbiAgICAgICAgICovXG4gICAgICAgIG11bCA6IGZ1bmN0aW9uIChvdXQsIG0xLCBtMikge1xuICAgICAgICAgICAgLy8gQ29uc2lkZXIgbWF0cml4Lm11bChtLCBtMiwgbSk7XG4gICAgICAgICAgICAvLyB3aGVyZSBvdXQgaXMgdGhlIHNhbWUgYXMgbTIuXG4gICAgICAgICAgICAvLyBTbyB1c2UgdGVtcCB2YXJpYWJsZSB0byBlc2NhcGUgZXJyb3IuXG4gICAgICAgICAgICB2YXIgb3V0MCA9IG0xWzBdICogbTJbMF0gKyBtMVsyXSAqIG0yWzFdO1xuICAgICAgICAgICAgdmFyIG91dDEgPSBtMVsxXSAqIG0yWzBdICsgbTFbM10gKiBtMlsxXTtcbiAgICAgICAgICAgIHZhciBvdXQyID0gbTFbMF0gKiBtMlsyXSArIG0xWzJdICogbTJbM107XG4gICAgICAgICAgICB2YXIgb3V0MyA9IG0xWzFdICogbTJbMl0gKyBtMVszXSAqIG0yWzNdO1xuICAgICAgICAgICAgdmFyIG91dDQgPSBtMVswXSAqIG0yWzRdICsgbTFbMl0gKiBtMls1XSArIG0xWzRdO1xuICAgICAgICAgICAgdmFyIG91dDUgPSBtMVsxXSAqIG0yWzRdICsgbTFbM10gKiBtMls1XSArIG0xWzVdO1xuICAgICAgICAgICAgb3V0WzBdID0gb3V0MDtcbiAgICAgICAgICAgIG91dFsxXSA9IG91dDE7XG4gICAgICAgICAgICBvdXRbMl0gPSBvdXQyO1xuICAgICAgICAgICAgb3V0WzNdID0gb3V0MztcbiAgICAgICAgICAgIG91dFs0XSA9IG91dDQ7XG4gICAgICAgICAgICBvdXRbNV0gPSBvdXQ1O1xuICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOW5s+enu+WPmOaNolxuICAgICAgICAgKiBAcGFyYW0ge0Zsb2F0MzJBcnJheXxBcnJheS48bnVtYmVyPn0gb3V0XG4gICAgICAgICAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fEFycmF5LjxudW1iZXI+fSBhXG4gICAgICAgICAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fEFycmF5LjxudW1iZXI+fSB2XG4gICAgICAgICAqL1xuICAgICAgICB0cmFuc2xhdGUgOiBmdW5jdGlvbihvdXQsIGEsIHYpIHtcbiAgICAgICAgICAgIG91dFswXSA9IGFbMF07XG4gICAgICAgICAgICBvdXRbMV0gPSBhWzFdO1xuICAgICAgICAgICAgb3V0WzJdID0gYVsyXTtcbiAgICAgICAgICAgIG91dFszXSA9IGFbM107XG4gICAgICAgICAgICBvdXRbNF0gPSBhWzRdICsgdlswXTtcbiAgICAgICAgICAgIG91dFs1XSA9IGFbNV0gKyB2WzFdO1xuICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOaXi+i9rOWPmOaNolxuICAgICAgICAgKiBAcGFyYW0ge0Zsb2F0MzJBcnJheXxBcnJheS48bnVtYmVyPn0gb3V0XG4gICAgICAgICAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fEFycmF5LjxudW1iZXI+fSBhXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSByYWRcbiAgICAgICAgICovXG4gICAgICAgIHJvdGF0ZSA6IGZ1bmN0aW9uKG91dCwgYSwgcmFkKSB7XG4gICAgICAgICAgICB2YXIgYWEgPSBhWzBdO1xuICAgICAgICAgICAgdmFyIGFjID0gYVsyXTtcbiAgICAgICAgICAgIHZhciBhdHggPSBhWzRdO1xuICAgICAgICAgICAgdmFyIGFiID0gYVsxXTtcbiAgICAgICAgICAgIHZhciBhZCA9IGFbM107XG4gICAgICAgICAgICB2YXIgYXR5ID0gYVs1XTtcbiAgICAgICAgICAgIHZhciBzdCA9IE1hdGguc2luKHJhZCk7XG4gICAgICAgICAgICB2YXIgY3QgPSBNYXRoLmNvcyhyYWQpO1xuXG4gICAgICAgICAgICBvdXRbMF0gPSBhYSAqIGN0ICsgYWIgKiBzdDtcbiAgICAgICAgICAgIG91dFsxXSA9IC1hYSAqIHN0ICsgYWIgKiBjdDtcbiAgICAgICAgICAgIG91dFsyXSA9IGFjICogY3QgKyBhZCAqIHN0O1xuICAgICAgICAgICAgb3V0WzNdID0gLWFjICogc3QgKyBjdCAqIGFkO1xuICAgICAgICAgICAgb3V0WzRdID0gY3QgKiBhdHggKyBzdCAqIGF0eTtcbiAgICAgICAgICAgIG91dFs1XSA9IGN0ICogYXR5IC0gc3QgKiBhdHg7XG4gICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICog57yp5pS+5Y+Y5o2iXG4gICAgICAgICAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fEFycmF5LjxudW1iZXI+fSBvdXRcbiAgICAgICAgICogQHBhcmFtIHtGbG9hdDMyQXJyYXl8QXJyYXkuPG51bWJlcj59IGFcbiAgICAgICAgICogQHBhcmFtIHtGbG9hdDMyQXJyYXl8QXJyYXkuPG51bWJlcj59IHZcbiAgICAgICAgICovXG4gICAgICAgIHNjYWxlIDogZnVuY3Rpb24ob3V0LCBhLCB2KSB7XG4gICAgICAgICAgICB2YXIgdnggPSB2WzBdO1xuICAgICAgICAgICAgdmFyIHZ5ID0gdlsxXTtcbiAgICAgICAgICAgIG91dFswXSA9IGFbMF0gKiB2eDtcbiAgICAgICAgICAgIG91dFsxXSA9IGFbMV0gKiB2eTtcbiAgICAgICAgICAgIG91dFsyXSA9IGFbMl0gKiB2eDtcbiAgICAgICAgICAgIG91dFszXSA9IGFbM10gKiB2eTtcbiAgICAgICAgICAgIG91dFs0XSA9IGFbNF0gKiB2eDtcbiAgICAgICAgICAgIG91dFs1XSA9IGFbNV0gKiB2eTtcbiAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmsYLpgIbnn6npmLVcbiAgICAgICAgICogQHBhcmFtIHtGbG9hdDMyQXJyYXl8QXJyYXkuPG51bWJlcj59IG91dFxuICAgICAgICAgKiBAcGFyYW0ge0Zsb2F0MzJBcnJheXxBcnJheS48bnVtYmVyPn0gYVxuICAgICAgICAgKi9cbiAgICAgICAgaW52ZXJ0IDogZnVuY3Rpb24ob3V0LCBhKSB7XG5cbiAgICAgICAgICAgIHZhciBhYSA9IGFbMF07XG4gICAgICAgICAgICB2YXIgYWMgPSBhWzJdO1xuICAgICAgICAgICAgdmFyIGF0eCA9IGFbNF07XG4gICAgICAgICAgICB2YXIgYWIgPSBhWzFdO1xuICAgICAgICAgICAgdmFyIGFkID0gYVszXTtcbiAgICAgICAgICAgIHZhciBhdHkgPSBhWzVdO1xuXG4gICAgICAgICAgICB2YXIgZGV0ID0gYWEgKiBhZCAtIGFiICogYWM7XG4gICAgICAgICAgICBpZiAoIWRldCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGV0ID0gMS4wIC8gZGV0O1xuXG4gICAgICAgICAgICBvdXRbMF0gPSBhZCAqIGRldDtcbiAgICAgICAgICAgIG91dFsxXSA9IC1hYiAqIGRldDtcbiAgICAgICAgICAgIG91dFsyXSA9IC1hYyAqIGRldDtcbiAgICAgICAgICAgIG91dFszXSA9IGFhICogZGV0O1xuICAgICAgICAgICAgb3V0WzRdID0gKGFjICogYXR5IC0gYWQgKiBhdHgpICogZGV0O1xuICAgICAgICAgICAgb3V0WzVdID0gKGFiICogYXR4IC0gYWEgKiBhdHkpICogZGV0O1xuICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IG1hdHJpeDtcblxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34venJlbmRlci9saWIvY29yZS9tYXRyaXguanNcbiAqKiBtb2R1bGUgaWQgPSAxM1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXG4gICAgdmFyIEFycmF5Q3RvciA9IHR5cGVvZiBGbG9hdDMyQXJyYXkgPT09ICd1bmRlZmluZWQnXG4gICAgICAgID8gQXJyYXlcbiAgICAgICAgOiBGbG9hdDMyQXJyYXk7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZWRlZiB7RmxvYXQzMkFycmF5fEFycmF5LjxudW1iZXI+fSBWZWN0b3IyXG4gICAgICovXG4gICAgLyoqXG4gICAgICog5LqM57u05ZCR6YeP57G7XG4gICAgICogQGV4cG9ydHMgenJlbmRlci90b29sL3ZlY3RvclxuICAgICAqL1xuICAgIHZhciB2ZWN0b3IgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiDliJvlu7rkuIDkuKrlkJHph49cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFt4PTBdXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbeT0wXVxuICAgICAgICAgKiBAcmV0dXJuIHtWZWN0b3IyfVxuICAgICAgICAgKi9cbiAgICAgICAgY3JlYXRlOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICAgICAgdmFyIG91dCA9IG5ldyBBcnJheUN0b3IoMik7XG4gICAgICAgICAgICBpZiAoeCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgeCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoeSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgeSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvdXRbMF0gPSB4O1xuICAgICAgICAgICAgb3V0WzFdID0geTtcbiAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWkjeWItuWQkemHj+aVsOaNrlxuICAgICAgICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IG91dFxuICAgICAgICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IHZcbiAgICAgICAgICogQHJldHVybiB7VmVjdG9yMn1cbiAgICAgICAgICovXG4gICAgICAgIGNvcHk6IGZ1bmN0aW9uIChvdXQsIHYpIHtcbiAgICAgICAgICAgIG91dFswXSA9IHZbMF07XG4gICAgICAgICAgICBvdXRbMV0gPSB2WzFdO1xuICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5YWL6ZqG5LiA5Liq5ZCR6YePXG4gICAgICAgICAqIEBwYXJhbSB7VmVjdG9yMn0gdlxuICAgICAgICAgKiBAcmV0dXJuIHtWZWN0b3IyfVxuICAgICAgICAgKi9cbiAgICAgICAgY2xvbmU6IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICB2YXIgb3V0ID0gbmV3IEFycmF5Q3RvcigyKTtcbiAgICAgICAgICAgIG91dFswXSA9IHZbMF07XG4gICAgICAgICAgICBvdXRbMV0gPSB2WzFdO1xuICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog6K6+572u5ZCR6YeP55qE5Lik5Liq6aG5XG4gICAgICAgICAqIEBwYXJhbSB7VmVjdG9yMn0gb3V0XG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiXG4gICAgICAgICAqIEByZXR1cm4ge1ZlY3RvcjJ9IOe7k+aenFxuICAgICAgICAgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAob3V0LCBhLCBiKSB7XG4gICAgICAgICAgICBvdXRbMF0gPSBhO1xuICAgICAgICAgICAgb3V0WzFdID0gYjtcbiAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWQkemHj+ebuOWKoFxuICAgICAgICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IG91dFxuICAgICAgICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IHYxXG4gICAgICAgICAqIEBwYXJhbSB7VmVjdG9yMn0gdjJcbiAgICAgICAgICovXG4gICAgICAgIGFkZDogZnVuY3Rpb24gKG91dCwgdjEsIHYyKSB7XG4gICAgICAgICAgICBvdXRbMF0gPSB2MVswXSArIHYyWzBdO1xuICAgICAgICAgICAgb3V0WzFdID0gdjFbMV0gKyB2MlsxXTtcbiAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWQkemHj+e8qeaUvuWQjuebuOWKoFxuICAgICAgICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IG91dFxuICAgICAgICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IHYxXG4gICAgICAgICAqIEBwYXJhbSB7VmVjdG9yMn0gdjJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGFcbiAgICAgICAgICovXG4gICAgICAgIHNjYWxlQW5kQWRkOiBmdW5jdGlvbiAob3V0LCB2MSwgdjIsIGEpIHtcbiAgICAgICAgICAgIG91dFswXSA9IHYxWzBdICsgdjJbMF0gKiBhO1xuICAgICAgICAgICAgb3V0WzFdID0gdjFbMV0gKyB2MlsxXSAqIGE7XG4gICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlkJHph4/nm7jlh49cbiAgICAgICAgICogQHBhcmFtIHtWZWN0b3IyfSBvdXRcbiAgICAgICAgICogQHBhcmFtIHtWZWN0b3IyfSB2MVxuICAgICAgICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IHYyXG4gICAgICAgICAqL1xuICAgICAgICBzdWI6IGZ1bmN0aW9uIChvdXQsIHYxLCB2Mikge1xuICAgICAgICAgICAgb3V0WzBdID0gdjFbMF0gLSB2MlswXTtcbiAgICAgICAgICAgIG91dFsxXSA9IHYxWzFdIC0gdjJbMV07XG4gICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlkJHph4/plb/luqZcbiAgICAgICAgICogQHBhcmFtIHtWZWN0b3IyfSB2XG4gICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIGxlbjogZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLnNxcnQodGhpcy5sZW5TcXVhcmUodikpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlkJHph4/plb/luqblubPmlrlcbiAgICAgICAgICogQHBhcmFtIHtWZWN0b3IyfSB2XG4gICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIGxlblNxdWFyZTogZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgIHJldHVybiB2WzBdICogdlswXSArIHZbMV0gKiB2WzFdO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlkJHph4/kuZjms5VcbiAgICAgICAgICogQHBhcmFtIHtWZWN0b3IyfSBvdXRcbiAgICAgICAgICogQHBhcmFtIHtWZWN0b3IyfSB2MVxuICAgICAgICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IHYyXG4gICAgICAgICAqL1xuICAgICAgICBtdWw6IGZ1bmN0aW9uIChvdXQsIHYxLCB2Mikge1xuICAgICAgICAgICAgb3V0WzBdID0gdjFbMF0gKiB2MlswXTtcbiAgICAgICAgICAgIG91dFsxXSA9IHYxWzFdICogdjJbMV07XG4gICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlkJHph4/pmaTms5VcbiAgICAgICAgICogQHBhcmFtIHtWZWN0b3IyfSBvdXRcbiAgICAgICAgICogQHBhcmFtIHtWZWN0b3IyfSB2MVxuICAgICAgICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IHYyXG4gICAgICAgICAqL1xuICAgICAgICBkaXY6IGZ1bmN0aW9uIChvdXQsIHYxLCB2Mikge1xuICAgICAgICAgICAgb3V0WzBdID0gdjFbMF0gLyB2MlswXTtcbiAgICAgICAgICAgIG91dFsxXSA9IHYxWzFdIC8gdjJbMV07XG4gICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlkJHph4/ngrnkuZhcbiAgICAgICAgICogQHBhcmFtIHtWZWN0b3IyfSB2MVxuICAgICAgICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IHYyXG4gICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIGRvdDogZnVuY3Rpb24gKHYxLCB2Mikge1xuICAgICAgICAgICAgcmV0dXJuIHYxWzBdICogdjJbMF0gKyB2MVsxXSAqIHYyWzFdO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlkJHph4/nvKnmlL5cbiAgICAgICAgICogQHBhcmFtIHtWZWN0b3IyfSBvdXRcbiAgICAgICAgICogQHBhcmFtIHtWZWN0b3IyfSB2XG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzXG4gICAgICAgICAqL1xuICAgICAgICBzY2FsZTogZnVuY3Rpb24gKG91dCwgdiwgcykge1xuICAgICAgICAgICAgb3V0WzBdID0gdlswXSAqIHM7XG4gICAgICAgICAgICBvdXRbMV0gPSB2WzFdICogcztcbiAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWQkemHj+W9kuS4gOWMllxuICAgICAgICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IG91dFxuICAgICAgICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IHZcbiAgICAgICAgICovXG4gICAgICAgIG5vcm1hbGl6ZTogZnVuY3Rpb24gKG91dCwgdikge1xuICAgICAgICAgICAgdmFyIGQgPSB2ZWN0b3IubGVuKHYpO1xuICAgICAgICAgICAgaWYgKGQgPT09IDApIHtcbiAgICAgICAgICAgICAgICBvdXRbMF0gPSAwO1xuICAgICAgICAgICAgICAgIG91dFsxXSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBvdXRbMF0gPSB2WzBdIC8gZDtcbiAgICAgICAgICAgICAgICBvdXRbMV0gPSB2WzFdIC8gZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOiuoeeul+WQkemHj+mXtOi3neemu1xuICAgICAgICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IHYxXG4gICAgICAgICAqIEBwYXJhbSB7VmVjdG9yMn0gdjJcbiAgICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgZGlzdGFuY2U6IGZ1bmN0aW9uICh2MSwgdjIpIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLnNxcnQoXG4gICAgICAgICAgICAgICAgKHYxWzBdIC0gdjJbMF0pICogKHYxWzBdIC0gdjJbMF0pXG4gICAgICAgICAgICAgICAgKyAodjFbMV0gLSB2MlsxXSkgKiAodjFbMV0gLSB2MlsxXSlcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWQkemHj+i3neemu+W5s+aWuVxuICAgICAgICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IHYxXG4gICAgICAgICAqIEBwYXJhbSB7VmVjdG9yMn0gdjJcbiAgICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgZGlzdGFuY2VTcXVhcmU6IGZ1bmN0aW9uICh2MSwgdjIpIHtcbiAgICAgICAgICAgIHJldHVybiAodjFbMF0gLSB2MlswXSkgKiAodjFbMF0gLSB2MlswXSlcbiAgICAgICAgICAgICAgICArICh2MVsxXSAtIHYyWzFdKSAqICh2MVsxXSAtIHYyWzFdKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5rGC6LSf5ZCR6YePXG4gICAgICAgICAqIEBwYXJhbSB7VmVjdG9yMn0gb3V0XG4gICAgICAgICAqIEBwYXJhbSB7VmVjdG9yMn0gdlxuICAgICAgICAgKi9cbiAgICAgICAgbmVnYXRlOiBmdW5jdGlvbiAob3V0LCB2KSB7XG4gICAgICAgICAgICBvdXRbMF0gPSAtdlswXTtcbiAgICAgICAgICAgIG91dFsxXSA9IC12WzFdO1xuICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5o+S5YC85Lik5Liq54K5XG4gICAgICAgICAqIEBwYXJhbSB7VmVjdG9yMn0gb3V0XG4gICAgICAgICAqIEBwYXJhbSB7VmVjdG9yMn0gdjFcbiAgICAgICAgICogQHBhcmFtIHtWZWN0b3IyfSB2MlxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gdFxuICAgICAgICAgKi9cbiAgICAgICAgbGVycDogZnVuY3Rpb24gKG91dCwgdjEsIHYyLCB0KSB7XG4gICAgICAgICAgICBvdXRbMF0gPSB2MVswXSArIHQgKiAodjJbMF0gLSB2MVswXSk7XG4gICAgICAgICAgICBvdXRbMV0gPSB2MVsxXSArIHQgKiAodjJbMV0gLSB2MVsxXSk7XG4gICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDnn6npmLXlt6bkuZjlkJHph49cbiAgICAgICAgICogQHBhcmFtIHtWZWN0b3IyfSBvdXRcbiAgICAgICAgICogQHBhcmFtIHtWZWN0b3IyfSB2XG4gICAgICAgICAqIEBwYXJhbSB7VmVjdG9yMn0gbVxuICAgICAgICAgKi9cbiAgICAgICAgYXBwbHlUcmFuc2Zvcm06IGZ1bmN0aW9uIChvdXQsIHYsIG0pIHtcbiAgICAgICAgICAgIHZhciB4ID0gdlswXTtcbiAgICAgICAgICAgIHZhciB5ID0gdlsxXTtcbiAgICAgICAgICAgIG91dFswXSA9IG1bMF0gKiB4ICsgbVsyXSAqIHkgKyBtWzRdO1xuICAgICAgICAgICAgb3V0WzFdID0gbVsxXSAqIHggKyBtWzNdICogeSArIG1bNV07XG4gICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICog5rGC5Lik5Liq5ZCR6YeP5pyA5bCP5YC8XG4gICAgICAgICAqIEBwYXJhbSAge1ZlY3RvcjJ9IG91dFxuICAgICAgICAgKiBAcGFyYW0gIHtWZWN0b3IyfSB2MVxuICAgICAgICAgKiBAcGFyYW0gIHtWZWN0b3IyfSB2MlxuICAgICAgICAgKi9cbiAgICAgICAgbWluOiBmdW5jdGlvbiAob3V0LCB2MSwgdjIpIHtcbiAgICAgICAgICAgIG91dFswXSA9IE1hdGgubWluKHYxWzBdLCB2MlswXSk7XG4gICAgICAgICAgICBvdXRbMV0gPSBNYXRoLm1pbih2MVsxXSwgdjJbMV0pO1xuICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOaxguS4pOS4quWQkemHj+acgOWkp+WAvFxuICAgICAgICAgKiBAcGFyYW0gIHtWZWN0b3IyfSBvdXRcbiAgICAgICAgICogQHBhcmFtICB7VmVjdG9yMn0gdjFcbiAgICAgICAgICogQHBhcmFtICB7VmVjdG9yMn0gdjJcbiAgICAgICAgICovXG4gICAgICAgIG1heDogZnVuY3Rpb24gKG91dCwgdjEsIHYyKSB7XG4gICAgICAgICAgICBvdXRbMF0gPSBNYXRoLm1heCh2MVswXSwgdjJbMF0pO1xuICAgICAgICAgICAgb3V0WzFdID0gTWF0aC5tYXgodjFbMV0sIHYyWzFdKTtcbiAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmVjdG9yLmxlbmd0aCA9IHZlY3Rvci5sZW47XG4gICAgdmVjdG9yLmxlbmd0aFNxdWFyZSA9IHZlY3Rvci5sZW5TcXVhcmU7XG4gICAgdmVjdG9yLmRpc3QgPSB2ZWN0b3IuZGlzdGFuY2U7XG4gICAgdmVjdG9yLmRpc3RTcXVhcmUgPSB2ZWN0b3IuZGlzdGFuY2VTcXVhcmU7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHZlY3RvcjtcblxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34venJlbmRlci9saWIvY29yZS92ZWN0b3IuanNcbiAqKiBtb2R1bGUgaWQgPSAxNFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuLyoqXG4gKiBAbW9kdWxlIHpyZW5kZXIvbWl4aW4vQW5pbWF0YWJsZVxuICovXG5cblxuICAgIHZhciBBbmltYXRvciA9IHJlcXVpcmUoJy4uL2FuaW1hdGlvbi9BbmltYXRvcicpO1xuICAgIHZhciB1dGlsID0gcmVxdWlyZSgnLi4vY29yZS91dGlsJyk7XG4gICAgdmFyIGlzU3RyaW5nID0gdXRpbC5pc1N0cmluZztcbiAgICB2YXIgaXNGdW5jdGlvbiA9IHV0aWwuaXNGdW5jdGlvbjtcbiAgICB2YXIgaXNPYmplY3QgPSB1dGlsLmlzT2JqZWN0O1xuICAgIHZhciBsb2cgPSByZXF1aXJlKCcuLi9jb3JlL2xvZycpO1xuXG4gICAgLyoqXG4gICAgICogQGFsaWFzIG1vZHVlOnpyZW5kZXIvbWl4aW4vQW5pbWF0YWJsZVxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIHZhciBBbmltYXRhYmxlID0gZnVuY3Rpb24gKCkge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7QXJyYXkuPG1vZHVsZTp6cmVuZGVyL2FuaW1hdGlvbi9BbmltYXRvcj59XG4gICAgICAgICAqIEByZWFkT25seVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5hbmltYXRvcnMgPSBbXTtcbiAgICB9O1xuXG4gICAgQW5pbWF0YWJsZS5wcm90b3R5cGUgPSB7XG5cbiAgICAgICAgY29uc3RydWN0b3I6IEFuaW1hdGFibGUsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWKqOeUu1xuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aCDpnIDopoHmt7vliqDliqjnlLvnmoTlsZ7mgKfojrflj5bot6/lvoTvvIzlj6/ku6XpgJrov4dhLmIuY+adpeiOt+WPlua3seWxgueahOWxnuaAp1xuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtsb29wXSDliqjnlLvmmK/lkKblvqrnjq9cbiAgICAgICAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvYW5pbWF0aW9uL0FuaW1hdG9yfVxuICAgICAgICAgKiBAZXhhbXBsZTpcbiAgICAgICAgICogICAgIGVsLmFuaW1hdGUoJ3N0eWxlJywgZmFsc2UpXG4gICAgICAgICAqICAgICAgICAgLndoZW4oMTAwMCwge3g6IDEwfSApXG4gICAgICAgICAqICAgICAgICAgLmRvbmUoZnVuY3Rpb24oKXsgLy8gQW5pbWF0aW9uIGRvbmUgfSlcbiAgICAgICAgICogICAgICAgICAuc3RhcnQoKVxuICAgICAgICAgKi9cbiAgICAgICAgYW5pbWF0ZTogZnVuY3Rpb24gKHBhdGgsIGxvb3ApIHtcbiAgICAgICAgICAgIHZhciB0YXJnZXQ7XG4gICAgICAgICAgICB2YXIgYW5pbWF0aW5nU2hhcGUgPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciBlbCA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgenIgPSB0aGlzLl9fenI7XG4gICAgICAgICAgICBpZiAocGF0aCkge1xuICAgICAgICAgICAgICAgIHZhciBwYXRoU3BsaXR0ZWQgPSBwYXRoLnNwbGl0KCcuJyk7XG4gICAgICAgICAgICAgICAgdmFyIHByb3AgPSBlbDtcbiAgICAgICAgICAgICAgICAvLyBJZiBhbmltYXRpbmcgc2hhcGVcbiAgICAgICAgICAgICAgICBhbmltYXRpbmdTaGFwZSA9IHBhdGhTcGxpdHRlZFswXSA9PT0gJ3NoYXBlJztcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHBhdGhTcGxpdHRlZC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFwcm9wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwcm9wID0gcHJvcFtwYXRoU3BsaXR0ZWRbaV1dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocHJvcCkge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXQgPSBwcm9wO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRhcmdldCA9IGVsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIXRhcmdldCkge1xuICAgICAgICAgICAgICAgIGxvZyhcbiAgICAgICAgICAgICAgICAgICAgJ1Byb3BlcnR5IFwiJ1xuICAgICAgICAgICAgICAgICAgICArIHBhdGhcbiAgICAgICAgICAgICAgICAgICAgKyAnXCIgaXMgbm90IGV4aXN0ZWQgaW4gZWxlbWVudCAnXG4gICAgICAgICAgICAgICAgICAgICsgZWwuaWRcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGFuaW1hdG9ycyA9IGVsLmFuaW1hdG9ycztcblxuICAgICAgICAgICAgdmFyIGFuaW1hdG9yID0gbmV3IEFuaW1hdG9yKHRhcmdldCwgbG9vcCk7XG5cbiAgICAgICAgICAgIGFuaW1hdG9yLmR1cmluZyhmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgZWwuZGlydHkoYW5pbWF0aW5nU2hhcGUpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5kb25lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAvLyBGSVhNRSBBbmltYXRvciB3aWxsIG5vdCBiZSByZW1vdmVkIGlmIHVzZSBgQW5pbWF0b3Ijc3RvcGAgdG8gc3RvcCBhbmltYXRpb25cbiAgICAgICAgICAgICAgICBhbmltYXRvcnMuc3BsaWNlKHV0aWwuaW5kZXhPZihhbmltYXRvcnMsIGFuaW1hdG9yKSwgMSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgYW5pbWF0b3JzLnB1c2goYW5pbWF0b3IpO1xuXG4gICAgICAgICAgICAvLyBJZiBhbmltYXRlIGFmdGVyIGFkZGVkIHRvIHRoZSB6cmVuZGVyXG4gICAgICAgICAgICBpZiAoenIpIHtcbiAgICAgICAgICAgICAgICB6ci5hbmltYXRpb24uYWRkQW5pbWF0b3IoYW5pbWF0b3IpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gYW5pbWF0b3I7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWBnOatouWKqOeUu1xuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGZvcndhcmRUb0xhc3QgSWYgbW92ZSB0byBsYXN0IGZyYW1lIGJlZm9yZSBzdG9wXG4gICAgICAgICAqL1xuICAgICAgICBzdG9wQW5pbWF0aW9uOiBmdW5jdGlvbiAoZm9yd2FyZFRvTGFzdCkge1xuICAgICAgICAgICAgdmFyIGFuaW1hdG9ycyA9IHRoaXMuYW5pbWF0b3JzO1xuICAgICAgICAgICAgdmFyIGxlbiA9IGFuaW1hdG9ycy5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgYW5pbWF0b3JzW2ldLnN0b3AoZm9yd2FyZFRvTGFzdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhbmltYXRvcnMubGVuZ3RoID0gMDtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXRcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFt0aW1lPTUwMF0gVGltZSBpbiBtc1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2Vhc2luZz0nbGluZWFyJ11cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtkZWxheT0wXVxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqICAvLyBBbmltYXRlIHBvc2l0aW9uXG4gICAgICAgICAqICBlbC5hbmltYXRlVG8oe1xuICAgICAgICAgKiAgICAgIHBvc2l0aW9uOiBbMTAsIDEwXVxuICAgICAgICAgKiAgfSwgZnVuY3Rpb24gKCkgeyAvLyBkb25lIH0pXG4gICAgICAgICAqXG4gICAgICAgICAqICAvLyBBbmltYXRlIHNoYXBlLCBzdHlsZSBhbmQgcG9zaXRpb24gaW4gMTAwbXMsIGRlbGF5ZWQgMTAwbXMsIHdpdGggY3ViaWNPdXQgZWFzaW5nXG4gICAgICAgICAqICBlbC5hbmltYXRlVG8oe1xuICAgICAgICAgKiAgICAgIHNoYXBlOiB7XG4gICAgICAgICAqICAgICAgICAgIHdpZHRoOiA1MDBcbiAgICAgICAgICogICAgICB9LFxuICAgICAgICAgKiAgICAgIHN0eWxlOiB7XG4gICAgICAgICAqICAgICAgICAgIGZpbGw6ICdyZWQnXG4gICAgICAgICAqICAgICAgfVxuICAgICAgICAgKiAgICAgIHBvc2l0aW9uOiBbMTAsIDEwXVxuICAgICAgICAgKiAgfSwgMTAwLCAxMDAsICdjdWJpY091dCcsIGZ1bmN0aW9uICgpIHsgLy8gZG9uZSB9KVxuICAgICAgICAgKi9cbiAgICAgICAgIC8vIFRPRE8gUmV0dXJuIGFuaW1hdGlvbiBrZXlcbiAgICAgICAgYW5pbWF0ZVRvOiBmdW5jdGlvbiAodGFyZ2V0LCB0aW1lLCBkZWxheSwgZWFzaW5nLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgLy8gYW5pbWF0ZVRvKHRhcmdldCwgdGltZSwgZWFzaW5nLCBjYWxsYmFjayk7XG4gICAgICAgICAgICBpZiAoaXNTdHJpbmcoZGVsYXkpKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sgPSBlYXNpbmc7XG4gICAgICAgICAgICAgICAgZWFzaW5nID0gZGVsYXk7XG4gICAgICAgICAgICAgICAgZGVsYXkgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gYW5pbWF0ZVRvKHRhcmdldCwgdGltZSwgZGVsYXksIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzRnVuY3Rpb24oZWFzaW5nKSkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gZWFzaW5nO1xuICAgICAgICAgICAgICAgIGVhc2luZyA9ICdsaW5lYXInO1xuICAgICAgICAgICAgICAgIGRlbGF5ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGFuaW1hdGVUbyh0YXJnZXQsIHRpbWUsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzRnVuY3Rpb24oZGVsYXkpKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sgPSBkZWxheTtcbiAgICAgICAgICAgICAgICBkZWxheSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBhbmltYXRlVG8odGFyZ2V0LCBjYWxsYmFjaylcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzRnVuY3Rpb24odGltZSkpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayA9IHRpbWU7XG4gICAgICAgICAgICAgICAgdGltZSA9IDUwMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGFuaW1hdGVUbyh0YXJnZXQpXG4gICAgICAgICAgICBlbHNlIGlmICghdGltZSkge1xuICAgICAgICAgICAgICAgIHRpbWUgPSA1MDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTdG9wIGFsbCBwcmV2aW91cyBhbmltYXRpb25zXG4gICAgICAgICAgICB0aGlzLnN0b3BBbmltYXRpb24oKTtcbiAgICAgICAgICAgIHRoaXMuX2FuaW1hdGVUb1NoYWxsb3coJycsIHRoaXMsIHRhcmdldCwgdGltZSwgZGVsYXksIGVhc2luZywgY2FsbGJhY2spO1xuXG4gICAgICAgICAgICAvLyBBbmltYXRvcnMgbWF5IGJlIHJlbW92ZWQgaW1tZWRpYXRlbHkgYWZ0ZXIgc3RhcnRcbiAgICAgICAgICAgIC8vIGlmIHRoZXJlIGlzIG5vdGhpbmcgdG8gYW5pbWF0ZVxuICAgICAgICAgICAgdmFyIGFuaW1hdG9ycyA9IHRoaXMuYW5pbWF0b3JzLnNsaWNlKCk7XG4gICAgICAgICAgICB2YXIgY291bnQgPSBhbmltYXRvcnMubGVuZ3RoO1xuICAgICAgICAgICAgZnVuY3Rpb24gZG9uZSgpIHtcbiAgICAgICAgICAgICAgICBjb3VudC0tO1xuICAgICAgICAgICAgICAgIGlmICghY291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIE5vIGFuaW1hdG9ycy4gVGhpcyBzaG91bGQgYmUgY2hlY2tlZCBiZWZvcmUgYW5pbWF0b3JzW2ldLnN0YXJ0KCksXG4gICAgICAgICAgICAvLyBiZWNhdXNlICdkb25lJyBtYXkgYmUgZXhlY3V0ZWQgaW1tZWRpYXRlbHkgaWYgbm8gbmVlZCB0byBhbmltYXRlLlxuICAgICAgICAgICAgaWYgKCFjb3VudCkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTdGFydCBhZnRlciBhbGwgYW5pbWF0b3JzIGNyZWF0ZWRcbiAgICAgICAgICAgIC8vIEluY2FzZSBhbnkgYW5pbWF0b3IgaXMgZG9uZSBpbW1lZGlhdGVseSB3aGVuIGFsbCBhbmltYXRpb24gcHJvcGVydGllcyBhcmUgbm90IGNoYW5nZWRcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYW5pbWF0b3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgYW5pbWF0b3JzW2ldXG4gICAgICAgICAgICAgICAgICAgIC5kb25lKGRvbmUpXG4gICAgICAgICAgICAgICAgICAgIC5zdGFydChlYXNpbmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aD0nJ1xuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlPXRoaXNcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHRhcmdldFxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW3RpbWU9NTAwXVxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2RlbGF5PTBdXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqICAvLyBBbmltYXRlIHBvc2l0aW9uXG4gICAgICAgICAqICBlbC5fYW5pbWF0ZVRvU2hhbGxvdyh7XG4gICAgICAgICAqICAgICAgcG9zaXRpb246IFsxMCwgMTBdXG4gICAgICAgICAqICB9KVxuICAgICAgICAgKlxuICAgICAgICAgKiAgLy8gQW5pbWF0ZSBzaGFwZSwgc3R5bGUgYW5kIHBvc2l0aW9uIGluIDEwMG1zLCBkZWxheWVkIDEwMG1zXG4gICAgICAgICAqICBlbC5fYW5pbWF0ZVRvU2hhbGxvdyh7XG4gICAgICAgICAqICAgICAgc2hhcGU6IHtcbiAgICAgICAgICogICAgICAgICAgd2lkdGg6IDUwMFxuICAgICAgICAgKiAgICAgIH0sXG4gICAgICAgICAqICAgICAgc3R5bGU6IHtcbiAgICAgICAgICogICAgICAgICAgZmlsbDogJ3JlZCdcbiAgICAgICAgICogICAgICB9XG4gICAgICAgICAqICAgICAgcG9zaXRpb246IFsxMCwgMTBdXG4gICAgICAgICAqICB9LCAxMDAsIDEwMClcbiAgICAgICAgICovXG4gICAgICAgIF9hbmltYXRlVG9TaGFsbG93OiBmdW5jdGlvbiAocGF0aCwgc291cmNlLCB0YXJnZXQsIHRpbWUsIGRlbGF5KSB7XG4gICAgICAgICAgICB2YXIgb2JqU2hhbGxvdyA9IHt9O1xuICAgICAgICAgICAgdmFyIHByb3BlcnR5Q291bnQgPSAwO1xuICAgICAgICAgICAgZm9yICh2YXIgbmFtZSBpbiB0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICBpZiAoc291cmNlW25hbWVdICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzT2JqZWN0KHRhcmdldFtuYW1lXSkgJiYgIXV0aWwuaXNBcnJheUxpa2UodGFyZ2V0W25hbWVdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYW5pbWF0ZVRvU2hhbGxvdyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRoID8gcGF0aCArICcuJyArIG5hbWUgOiBuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZVtuYW1lXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRbbmFtZV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxheVxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9ialNoYWxsb3dbbmFtZV0gPSB0YXJnZXRbbmFtZV07XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eUNvdW50Kys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodGFyZ2V0W25hbWVdICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQXR0ciBkaXJlY3RseSBpZiBub3QgaGFzIHByb3BlcnR5XG4gICAgICAgICAgICAgICAgICAgIC8vIEZJWE1FLCBpZiBzb21lIHByb3BlcnR5IG5vdCBuZWVkZWQgZm9yIGVsZW1lbnQgP1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXBhdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXR0cihuYW1lLCB0YXJnZXRbbmFtZV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgeyAgLy8gU2hhcGUgb3Igc3R5bGVcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwcm9wcyA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcHNbcGF0aF0gPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BzW3BhdGhdW25hbWVdID0gdGFyZ2V0W25hbWVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hdHRyKHByb3BzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHByb3BlcnR5Q291bnQgPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hbmltYXRlKHBhdGgsIGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAud2hlbih0aW1lID09IG51bGwgPyA1MDAgOiB0aW1lLCBvYmpTaGFsbG93KVxuICAgICAgICAgICAgICAgICAgICAuZGVsYXkoZGVsYXkgfHwgMCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gQW5pbWF0YWJsZTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3pyZW5kZXIvbGliL21peGluL0FuaW1hdGFibGUuanNcbiAqKiBtb2R1bGUgaWQgPSAxNVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBAbW9kdWxlIGVjaGFydHMvYW5pbWF0aW9uL0FuaW1hdG9yXG4gKi9cblxuXG4gICAgdmFyIENsaXAgPSByZXF1aXJlKCcuL0NsaXAnKTtcbiAgICB2YXIgY29sb3IgPSByZXF1aXJlKCcuLi90b29sL2NvbG9yJyk7XG4gICAgdmFyIHV0aWwgPSByZXF1aXJlKCcuLi9jb3JlL3V0aWwnKTtcbiAgICB2YXIgaXNBcnJheUxpa2UgPSB1dGlsLmlzQXJyYXlMaWtlO1xuXG4gICAgdmFyIGFycmF5U2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG5cbiAgICBmdW5jdGlvbiBkZWZhdWx0R2V0dGVyKHRhcmdldCwga2V5KSB7XG4gICAgICAgIHJldHVybiB0YXJnZXRba2V5XTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkZWZhdWx0U2V0dGVyKHRhcmdldCwga2V5LCB2YWx1ZSkge1xuICAgICAgICB0YXJnZXRba2V5XSA9IHZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcDBcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHAxXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBwZXJjZW50XG4gICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGludGVycG9sYXRlTnVtYmVyKHAwLCBwMSwgcGVyY2VudCkge1xuICAgICAgICByZXR1cm4gKHAxIC0gcDApICogcGVyY2VudCArIHAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSAge3N0cmluZ30gcDBcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9IHAxXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBwZXJjZW50XG4gICAgICogQHJldHVybiB7c3RyaW5nfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGludGVycG9sYXRlU3RyaW5nKHAwLCBwMSwgcGVyY2VudCkge1xuICAgICAgICByZXR1cm4gcGVyY2VudCA+IDAuNSA/IHAxIDogcDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtICB7QXJyYXl9IHAwXG4gICAgICogQHBhcmFtICB7QXJyYXl9IHAxXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBwZXJjZW50XG4gICAgICogQHBhcmFtICB7QXJyYXl9IG91dFxuICAgICAqIEBwYXJhbSAge251bWJlcn0gYXJyRGltXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW50ZXJwb2xhdGVBcnJheShwMCwgcDEsIHBlcmNlbnQsIG91dCwgYXJyRGltKSB7XG4gICAgICAgIHZhciBsZW4gPSBwMC5sZW5ndGg7XG4gICAgICAgIGlmIChhcnJEaW0gPT0gMSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIG91dFtpXSA9IGludGVycG9sYXRlTnVtYmVyKHAwW2ldLCBwMVtpXSwgcGVyY2VudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgbGVuMiA9IHAwWzBdLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGxlbjI7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBvdXRbaV1bal0gPSBpbnRlcnBvbGF0ZU51bWJlcihcbiAgICAgICAgICAgICAgICAgICAgICAgIHAwW2ldW2pdLCBwMVtpXVtqXSwgcGVyY2VudFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGFycjAgaXMgc291cmNlIGFycmF5LCBhcnIxIGlzIHRhcmdldCBhcnJheS5cbiAgICAvLyBEbyBzb21lIHByZXByb2Nlc3MgdG8gYXZvaWQgZXJyb3IgaGFwcGVuZWQgd2hlbiBpbnRlcnBvbGF0aW5nIGZyb20gYXJyMCB0byBhcnIxXG4gICAgZnVuY3Rpb24gZmlsbEFycihhcnIwLCBhcnIxLCBhcnJEaW0pIHtcbiAgICAgICAgdmFyIGFycjBMZW4gPSBhcnIwLmxlbmd0aDtcbiAgICAgICAgdmFyIGFycjFMZW4gPSBhcnIxLmxlbmd0aDtcbiAgICAgICAgaWYgKGFycjBMZW4gIT09IGFycjFMZW4pIHtcbiAgICAgICAgICAgIC8vIEZJWE1FIE5vdCB3b3JrIGZvciBUeXBlZEFycmF5XG4gICAgICAgICAgICB2YXIgaXNQcmV2aW91c0xhcmdlciA9IGFycjBMZW4gPiBhcnIxTGVuO1xuICAgICAgICAgICAgaWYgKGlzUHJldmlvdXNMYXJnZXIpIHtcbiAgICAgICAgICAgICAgICAvLyBDdXQgdGhlIHByZXZpb3VzXG4gICAgICAgICAgICAgICAgYXJyMC5sZW5ndGggPSBhcnIxTGVuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gRmlsbCB0aGUgcHJldmlvdXNcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gYXJyMExlbjsgaSA8IGFycjFMZW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBhcnIwLnB1c2goXG4gICAgICAgICAgICAgICAgICAgICAgICBhcnJEaW0gPT09IDEgPyBhcnIxW2ldIDogYXJyYXlTbGljZS5jYWxsKGFycjFbaV0pXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEhhbmRsaW5nIE5hTiB2YWx1ZVxuICAgICAgICB2YXIgbGVuMiA9IGFycjBbMF0gJiYgYXJyMFswXS5sZW5ndGg7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyMC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGFyckRpbSA9PT0gMSkge1xuICAgICAgICAgICAgICAgIGlmIChpc05hTihhcnIwW2ldKSkge1xuICAgICAgICAgICAgICAgICAgICBhcnIwW2ldID0gYXJyMVtpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGxlbjI7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNOYU4oYXJyMFtpXVtqXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFycjBbaV1bal0gPSBhcnIxW2ldW2pdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtICB7QXJyYXl9IGFycjBcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gYXJyMVxuICAgICAqIEBwYXJhbSAge251bWJlcn0gYXJyRGltXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0FycmF5U2FtZShhcnIwLCBhcnIxLCBhcnJEaW0pIHtcbiAgICAgICAgaWYgKGFycjAgPT09IGFycjEpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsZW4gPSBhcnIwLmxlbmd0aDtcbiAgICAgICAgaWYgKGxlbiAhPT0gYXJyMS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXJyRGltID09PSAxKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFycjBbaV0gIT09IGFycjFbaV0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBsZW4yID0gYXJyMFswXS5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBsZW4yOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFycjBbaV1bal0gIT09IGFycjFbaV1bal0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYXRtdWxsIFJvbSBpbnRlcnBvbGF0ZSBhcnJheVxuICAgICAqIEBwYXJhbSAge0FycmF5fSBwMFxuICAgICAqIEBwYXJhbSAge0FycmF5fSBwMVxuICAgICAqIEBwYXJhbSAge0FycmF5fSBwMlxuICAgICAqIEBwYXJhbSAge0FycmF5fSBwM1xuICAgICAqIEBwYXJhbSAge251bWJlcn0gdFxuICAgICAqIEBwYXJhbSAge251bWJlcn0gdDJcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHQzXG4gICAgICogQHBhcmFtICB7QXJyYXl9IG91dFxuICAgICAqIEBwYXJhbSAge251bWJlcn0gYXJyRGltXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2F0bXVsbFJvbUludGVycG9sYXRlQXJyYXkoXG4gICAgICAgIHAwLCBwMSwgcDIsIHAzLCB0LCB0MiwgdDMsIG91dCwgYXJyRGltXG4gICAgKSB7XG4gICAgICAgIHZhciBsZW4gPSBwMC5sZW5ndGg7XG4gICAgICAgIGlmIChhcnJEaW0gPT0gMSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIG91dFtpXSA9IGNhdG11bGxSb21JbnRlcnBvbGF0ZShcbiAgICAgICAgICAgICAgICAgICAgcDBbaV0sIHAxW2ldLCBwMltpXSwgcDNbaV0sIHQsIHQyLCB0M1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgbGVuMiA9IHAwWzBdLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGxlbjI7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBvdXRbaV1bal0gPSBjYXRtdWxsUm9tSW50ZXJwb2xhdGUoXG4gICAgICAgICAgICAgICAgICAgICAgICBwMFtpXVtqXSwgcDFbaV1bal0sIHAyW2ldW2pdLCBwM1tpXVtqXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHQsIHQyLCB0M1xuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhdG11bGwgUm9tIGludGVycG9sYXRlIG51bWJlclxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcDBcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHAxXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBwMlxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcDNcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHRcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHQyXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSB0M1xuICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjYXRtdWxsUm9tSW50ZXJwb2xhdGUocDAsIHAxLCBwMiwgcDMsIHQsIHQyLCB0Mykge1xuICAgICAgICB2YXIgdjAgPSAocDIgLSBwMCkgKiAwLjU7XG4gICAgICAgIHZhciB2MSA9IChwMyAtIHAxKSAqIDAuNTtcbiAgICAgICAgcmV0dXJuICgyICogKHAxIC0gcDIpICsgdjAgKyB2MSkgKiB0M1xuICAgICAgICAgICAgICAgICsgKC0zICogKHAxIC0gcDIpIC0gMiAqIHYwIC0gdjEpICogdDJcbiAgICAgICAgICAgICAgICArIHYwICogdCArIHAxO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsb25lVmFsdWUodmFsdWUpIHtcbiAgICAgICAgaWYgKGlzQXJyYXlMaWtlKHZhbHVlKSkge1xuICAgICAgICAgICAgdmFyIGxlbiA9IHZhbHVlLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChpc0FycmF5TGlrZSh2YWx1ZVswXSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmV0ID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICByZXQucHVzaChhcnJheVNsaWNlLmNhbGwodmFsdWVbaV0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGFycmF5U2xpY2UuY2FsbCh2YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmdiYTJTdHJpbmcocmdiYSkge1xuICAgICAgICByZ2JhWzBdID0gTWF0aC5mbG9vcihyZ2JhWzBdKTtcbiAgICAgICAgcmdiYVsxXSA9IE1hdGguZmxvb3IocmdiYVsxXSk7XG4gICAgICAgIHJnYmFbMl0gPSBNYXRoLmZsb29yKHJnYmFbMl0pO1xuXG4gICAgICAgIHJldHVybiAncmdiYSgnICsgcmdiYS5qb2luKCcsJykgKyAnKSc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlVHJhY2tDbGlwIChhbmltYXRvciwgZWFzaW5nLCBvbmVUcmFja0RvbmUsIGtleWZyYW1lcywgcHJvcE5hbWUpIHtcbiAgICAgICAgdmFyIGdldHRlciA9IGFuaW1hdG9yLl9nZXR0ZXI7XG4gICAgICAgIHZhciBzZXR0ZXIgPSBhbmltYXRvci5fc2V0dGVyO1xuICAgICAgICB2YXIgdXNlU3BsaW5lID0gZWFzaW5nID09PSAnc3BsaW5lJztcblxuICAgICAgICB2YXIgdHJhY2tMZW4gPSBrZXlmcmFtZXMubGVuZ3RoO1xuICAgICAgICBpZiAoIXRyYWNrTGVuKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gR3Vlc3MgZGF0YSB0eXBlXG4gICAgICAgIHZhciBmaXJzdFZhbCA9IGtleWZyYW1lc1swXS52YWx1ZTtcbiAgICAgICAgdmFyIGlzVmFsdWVBcnJheSA9IGlzQXJyYXlMaWtlKGZpcnN0VmFsKTtcbiAgICAgICAgdmFyIGlzVmFsdWVDb2xvciA9IGZhbHNlO1xuICAgICAgICB2YXIgaXNWYWx1ZVN0cmluZyA9IGZhbHNlO1xuXG4gICAgICAgIC8vIEZvciB2ZXJ0aWNlcyBtb3JwaGluZ1xuICAgICAgICB2YXIgYXJyRGltID0gKFxuICAgICAgICAgICAgICAgIGlzVmFsdWVBcnJheVxuICAgICAgICAgICAgICAgICYmIGlzQXJyYXlMaWtlKGZpcnN0VmFsWzBdKVxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgPyAyIDogMTtcbiAgICAgICAgdmFyIHRyYWNrTWF4VGltZTtcbiAgICAgICAgLy8gU29ydCBrZXlmcmFtZSBhcyBhc2NlbmRpbmdcbiAgICAgICAga2V5ZnJhbWVzLnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIGEudGltZSAtIGIudGltZTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdHJhY2tNYXhUaW1lID0ga2V5ZnJhbWVzW3RyYWNrTGVuIC0gMV0udGltZTtcbiAgICAgICAgLy8gUGVyY2VudHMgb2YgZWFjaCBrZXlmcmFtZVxuICAgICAgICB2YXIga2ZQZXJjZW50cyA9IFtdO1xuICAgICAgICAvLyBWYWx1ZSBvZiBlYWNoIGtleWZyYW1lXG4gICAgICAgIHZhciBrZlZhbHVlcyA9IFtdO1xuICAgICAgICB2YXIgcHJldlZhbHVlID0ga2V5ZnJhbWVzWzBdLnZhbHVlO1xuICAgICAgICB2YXIgaXNBbGxWYWx1ZUVxdWFsID0gdHJ1ZTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmFja0xlbjsgaSsrKSB7XG4gICAgICAgICAgICBrZlBlcmNlbnRzLnB1c2goa2V5ZnJhbWVzW2ldLnRpbWUgLyB0cmFja01heFRpbWUpO1xuICAgICAgICAgICAgLy8gQXNzdW1lIHZhbHVlIGlzIGEgY29sb3Igd2hlbiBpdCBpcyBhIHN0cmluZ1xuICAgICAgICAgICAgdmFyIHZhbHVlID0ga2V5ZnJhbWVzW2ldLnZhbHVlO1xuXG4gICAgICAgICAgICAvLyBDaGVjayBpZiB2YWx1ZSBpcyBlcXVhbCwgZGVlcCBjaGVjayBpZiB2YWx1ZSBpcyBhcnJheVxuICAgICAgICAgICAgaWYgKCEoKGlzVmFsdWVBcnJheSAmJiBpc0FycmF5U2FtZSh2YWx1ZSwgcHJldlZhbHVlLCBhcnJEaW0pKVxuICAgICAgICAgICAgICAgIHx8ICghaXNWYWx1ZUFycmF5ICYmIHZhbHVlID09PSBwcmV2VmFsdWUpKSkge1xuICAgICAgICAgICAgICAgIGlzQWxsVmFsdWVFcXVhbCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJldlZhbHVlID0gdmFsdWU7XG5cbiAgICAgICAgICAgIC8vIFRyeSBjb252ZXJ0aW5nIGEgc3RyaW5nIHRvIGEgY29sb3IgYXJyYXlcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29sb3JBcnJheSA9IGNvbG9yLnBhcnNlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICBpZiAoY29sb3JBcnJheSkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGNvbG9yQXJyYXk7XG4gICAgICAgICAgICAgICAgICAgIGlzVmFsdWVDb2xvciA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpc1ZhbHVlU3RyaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBrZlZhbHVlcy5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNBbGxWYWx1ZUVxdWFsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbGFzdFZhbHVlID0ga2ZWYWx1ZXNbdHJhY2tMZW4gLSAxXTtcbiAgICAgICAgLy8gUG9seWZpbGwgYXJyYXkgYW5kIE5hTiB2YWx1ZVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyYWNrTGVuIC0gMTsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoaXNWYWx1ZUFycmF5KSB7XG4gICAgICAgICAgICAgICAgZmlsbEFycihrZlZhbHVlc1tpXSwgbGFzdFZhbHVlLCBhcnJEaW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzTmFOKGtmVmFsdWVzW2ldKSAmJiAhaXNOYU4obGFzdFZhbHVlKSAmJiAhaXNWYWx1ZVN0cmluZyAmJiAhaXNWYWx1ZUNvbG9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGtmVmFsdWVzW2ldID0gbGFzdFZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpc1ZhbHVlQXJyYXkgJiYgZmlsbEFycihnZXR0ZXIoYW5pbWF0b3IuX3RhcmdldCwgcHJvcE5hbWUpLCBsYXN0VmFsdWUsIGFyckRpbSk7XG5cbiAgICAgICAgLy8gQ2FjaGUgdGhlIGtleSBvZiBsYXN0IGZyYW1lIHRvIHNwZWVkIHVwIHdoZW5cbiAgICAgICAgLy8gYW5pbWF0aW9uIHBsYXliYWNrIGlzIHNlcXVlbmN5XG4gICAgICAgIHZhciBsYXN0RnJhbWUgPSAwO1xuICAgICAgICB2YXIgbGFzdEZyYW1lUGVyY2VudCA9IDA7XG4gICAgICAgIHZhciBzdGFydDtcbiAgICAgICAgdmFyIHc7XG4gICAgICAgIHZhciBwMDtcbiAgICAgICAgdmFyIHAxO1xuICAgICAgICB2YXIgcDI7XG4gICAgICAgIHZhciBwMztcblxuICAgICAgICBpZiAoaXNWYWx1ZUNvbG9yKSB7XG4gICAgICAgICAgICB2YXIgcmdiYSA9IFswLCAwLCAwLCAwXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBvbmZyYW1lID0gZnVuY3Rpb24gKHRhcmdldCwgcGVyY2VudCkge1xuICAgICAgICAgICAgLy8gRmluZCB0aGUgcmFuZ2Uga2V5ZnJhbWVzXG4gICAgICAgICAgICAvLyBrZjEtLS0tLWtmMi0tLS0tLS0tLWN1cnJlbnQtLS0tLS0tLWtmM1xuICAgICAgICAgICAgLy8gZmluZCBrZjIgYW5kIGtmMyBhbmQgZG8gaW50ZXJwb2xhdGlvblxuICAgICAgICAgICAgdmFyIGZyYW1lO1xuICAgICAgICAgICAgLy8gSW4gdGhlIGVhc2luZyBmdW5jdGlvbiBsaWtlIGVsYXN0aWNPdXQsIHBlcmNlbnQgbWF5IGxlc3MgdGhhbiAwXG4gICAgICAgICAgICBpZiAocGVyY2VudCA8IDApIHtcbiAgICAgICAgICAgICAgICBmcmFtZSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwZXJjZW50IDwgbGFzdEZyYW1lUGVyY2VudCkge1xuICAgICAgICAgICAgICAgIC8vIFN0YXJ0IGZyb20gbmV4dCBrZXlcbiAgICAgICAgICAgICAgICAvLyBQRU5ESU5HIHN0YXJ0IGZyb20gbGFzdEZyYW1lID9cbiAgICAgICAgICAgICAgICBzdGFydCA9IE1hdGgubWluKGxhc3RGcmFtZSArIDEsIHRyYWNrTGVuIC0gMSk7XG4gICAgICAgICAgICAgICAgZm9yIChmcmFtZSA9IHN0YXJ0OyBmcmFtZSA+PSAwOyBmcmFtZS0tKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChrZlBlcmNlbnRzW2ZyYW1lXSA8PSBwZXJjZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBQRU5ESU5HIHJlYWxseSBuZWVkIHRvIGRvIHRoaXMgP1xuICAgICAgICAgICAgICAgIGZyYW1lID0gTWF0aC5taW4oZnJhbWUsIHRyYWNrTGVuIC0gMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKGZyYW1lID0gbGFzdEZyYW1lOyBmcmFtZSA8IHRyYWNrTGVuOyBmcmFtZSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChrZlBlcmNlbnRzW2ZyYW1lXSA+IHBlcmNlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZyYW1lID0gTWF0aC5taW4oZnJhbWUgLSAxLCB0cmFja0xlbiAtIDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGFzdEZyYW1lID0gZnJhbWU7XG4gICAgICAgICAgICBsYXN0RnJhbWVQZXJjZW50ID0gcGVyY2VudDtcblxuICAgICAgICAgICAgdmFyIHJhbmdlID0gKGtmUGVyY2VudHNbZnJhbWUgKyAxXSAtIGtmUGVyY2VudHNbZnJhbWVdKTtcbiAgICAgICAgICAgIGlmIChyYW5nZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHcgPSAocGVyY2VudCAtIGtmUGVyY2VudHNbZnJhbWVdKSAvIHJhbmdlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHVzZVNwbGluZSkge1xuICAgICAgICAgICAgICAgIHAxID0ga2ZWYWx1ZXNbZnJhbWVdO1xuICAgICAgICAgICAgICAgIHAwID0ga2ZWYWx1ZXNbZnJhbWUgPT09IDAgPyBmcmFtZSA6IGZyYW1lIC0gMV07XG4gICAgICAgICAgICAgICAgcDIgPSBrZlZhbHVlc1tmcmFtZSA+IHRyYWNrTGVuIC0gMiA/IHRyYWNrTGVuIC0gMSA6IGZyYW1lICsgMV07XG4gICAgICAgICAgICAgICAgcDMgPSBrZlZhbHVlc1tmcmFtZSA+IHRyYWNrTGVuIC0gMyA/IHRyYWNrTGVuIC0gMSA6IGZyYW1lICsgMl07XG4gICAgICAgICAgICAgICAgaWYgKGlzVmFsdWVBcnJheSkge1xuICAgICAgICAgICAgICAgICAgICBjYXRtdWxsUm9tSW50ZXJwb2xhdGVBcnJheShcbiAgICAgICAgICAgICAgICAgICAgICAgIHAwLCBwMSwgcDIsIHAzLCB3LCB3ICogdywgdyAqIHcgKiB3LFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0dGVyKHRhcmdldCwgcHJvcE5hbWUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXJyRGltXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1ZhbHVlQ29sb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gY2F0bXVsbFJvbUludGVycG9sYXRlQXJyYXkoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcDAsIHAxLCBwMiwgcDMsIHcsIHcgKiB3LCB3ICogdyAqIHcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmdiYSwgMVxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gcmdiYTJTdHJpbmcocmdiYSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNWYWx1ZVN0cmluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3RyaW5nIGlzIHN0ZXAoMC41KVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGludGVycG9sYXRlU3RyaW5nKHAxLCBwMiwgdyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGNhdG11bGxSb21JbnRlcnBvbGF0ZShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwMCwgcDEsIHAyLCBwMywgdywgdyAqIHcsIHcgKiB3ICogd1xuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzZXR0ZXIoXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzVmFsdWVBcnJheSkge1xuICAgICAgICAgICAgICAgICAgICBpbnRlcnBvbGF0ZUFycmF5KFxuICAgICAgICAgICAgICAgICAgICAgICAga2ZWYWx1ZXNbZnJhbWVdLCBrZlZhbHVlc1tmcmFtZSArIDFdLCB3LFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0dGVyKHRhcmdldCwgcHJvcE5hbWUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXJyRGltXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1ZhbHVlQ29sb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGludGVycG9sYXRlQXJyYXkoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2ZWYWx1ZXNbZnJhbWVdLCBrZlZhbHVlc1tmcmFtZSArIDFdLCB3LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJnYmEsIDFcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHJnYmEyU3RyaW5nKHJnYmEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzVmFsdWVTdHJpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN0cmluZyBpcyBzdGVwKDAuNSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpbnRlcnBvbGF0ZVN0cmluZyhrZlZhbHVlc1tmcmFtZV0sIGtmVmFsdWVzW2ZyYW1lICsgMV0sIHcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBpbnRlcnBvbGF0ZU51bWJlcihrZlZhbHVlc1tmcmFtZV0sIGtmVmFsdWVzW2ZyYW1lICsgMV0sIHcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHNldHRlcihcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BOYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGNsaXAgPSBuZXcgQ2xpcCh7XG4gICAgICAgICAgICB0YXJnZXQ6IGFuaW1hdG9yLl90YXJnZXQsXG4gICAgICAgICAgICBsaWZlOiB0cmFja01heFRpbWUsXG4gICAgICAgICAgICBsb29wOiBhbmltYXRvci5fbG9vcCxcbiAgICAgICAgICAgIGRlbGF5OiBhbmltYXRvci5fZGVsYXksXG4gICAgICAgICAgICBvbmZyYW1lOiBvbmZyYW1lLFxuICAgICAgICAgICAgb25kZXN0cm95OiBvbmVUcmFja0RvbmVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGVhc2luZyAmJiBlYXNpbmcgIT09ICdzcGxpbmUnKSB7XG4gICAgICAgICAgICBjbGlwLmVhc2luZyA9IGVhc2luZztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjbGlwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBhbGlhcyBtb2R1bGU6enJlbmRlci9hbmltYXRpb24vQW5pbWF0b3JcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0XG4gICAgICogQHBhcmFtIHtib29sZWFufSBsb29wXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZ2V0dGVyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gc2V0dGVyXG4gICAgICovXG4gICAgdmFyIEFuaW1hdG9yID0gZnVuY3Rpb24odGFyZ2V0LCBsb29wLCBnZXR0ZXIsIHNldHRlcikge1xuICAgICAgICB0aGlzLl90cmFja3MgPSB7fTtcbiAgICAgICAgdGhpcy5fdGFyZ2V0ID0gdGFyZ2V0O1xuXG4gICAgICAgIHRoaXMuX2xvb3AgPSBsb29wIHx8IGZhbHNlO1xuXG4gICAgICAgIHRoaXMuX2dldHRlciA9IGdldHRlciB8fCBkZWZhdWx0R2V0dGVyO1xuICAgICAgICB0aGlzLl9zZXR0ZXIgPSBzZXR0ZXIgfHwgZGVmYXVsdFNldHRlcjtcblxuICAgICAgICB0aGlzLl9jbGlwQ291bnQgPSAwO1xuXG4gICAgICAgIHRoaXMuX2RlbGF5ID0gMDtcblxuICAgICAgICB0aGlzLl9kb25lTGlzdCA9IFtdO1xuXG4gICAgICAgIHRoaXMuX29uZnJhbWVMaXN0ID0gW107XG5cbiAgICAgICAgdGhpcy5fY2xpcExpc3QgPSBbXTtcbiAgICB9O1xuXG4gICAgQW5pbWF0b3IucHJvdG90eXBlID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICog6K6+572u5Yqo55S75YWz6ZSu5binXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gdGltZSDlhbPplK7luKfml7bpl7TvvIzljZXkvY3mmK9tc1xuICAgICAgICAgKiBAcGFyYW0gIHtPYmplY3R9IHByb3BzIOWFs+mUruW4p+eahOWxnuaAp+WAvO+8jGtleS12YWx1ZeihqOekulxuICAgICAgICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9hbmltYXRpb24vQW5pbWF0b3J9XG4gICAgICAgICAqL1xuICAgICAgICB3aGVuOiBmdW5jdGlvbih0aW1lIC8qIG1zICovLCBwcm9wcykge1xuICAgICAgICAgICAgdmFyIHRyYWNrcyA9IHRoaXMuX3RyYWNrcztcbiAgICAgICAgICAgIGZvciAodmFyIHByb3BOYW1lIGluIHByb3BzKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0cmFja3NbcHJvcE5hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyYWNrc1twcm9wTmFtZV0gPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgLy8gSW52YWxpZCB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLl9nZXR0ZXIodGhpcy5fdGFyZ2V0LCBwcm9wTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB6ckxvZygnSW52YWxpZCBwcm9wZXJ0eSAnICsgcHJvcE5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGltZSBpcyAwXG4gICAgICAgICAgICAgICAgICAgIC8vICBUaGVuIHByb3BzIGlzIGdpdmVuIGluaXRpYWxpemUgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgLy8gRWxzZVxuICAgICAgICAgICAgICAgICAgICAvLyAgSW5pdGlhbGl6ZSB2YWx1ZSBmcm9tIGN1cnJlbnQgcHJvcCB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICBpZiAodGltZSAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJhY2tzW3Byb3BOYW1lXS5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBjbG9uZVZhbHVlKHZhbHVlKVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdHJhY2tzW3Byb3BOYW1lXS5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgdGltZTogdGltZSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHByb3BzW3Byb3BOYW1lXVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmt7vliqDliqjnlLvmr4/kuIDluKfnmoTlm57osIPlh73mlbBcbiAgICAgICAgICogQHBhcmFtICB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAgICAgICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2FuaW1hdGlvbi9BbmltYXRvcn1cbiAgICAgICAgICovXG4gICAgICAgIGR1cmluZzogZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICB0aGlzLl9vbmZyYW1lTGlzdC5wdXNoKGNhbGxiYWNrKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9kb25lQ2FsbGJhY2s6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIENsZWFyIGFsbCB0cmFja3NcbiAgICAgICAgICAgIHRoaXMuX3RyYWNrcyA9IHt9O1xuICAgICAgICAgICAgLy8gQ2xlYXIgYWxsIGNsaXBzXG4gICAgICAgICAgICB0aGlzLl9jbGlwTGlzdC5sZW5ndGggPSAwO1xuXG4gICAgICAgICAgICB2YXIgZG9uZUxpc3QgPSB0aGlzLl9kb25lTGlzdDtcbiAgICAgICAgICAgIHZhciBsZW4gPSBkb25lTGlzdC5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZG9uZUxpc3RbaV0uY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOW8gOWni+aJp+ihjOWKqOeUu1xuICAgICAgICAgKiBAcGFyYW0gIHtzdHJpbmd8RnVuY3Rpb259IGVhc2luZ1xuICAgICAgICAgKiAgICAgICAgIOWKqOeUu+e8k+WKqOWHveaVsO+8jOivpuingXtAbGluayBtb2R1bGU6enJlbmRlci9hbmltYXRpb24vZWFzaW5nfVxuICAgICAgICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9hbmltYXRpb24vQW5pbWF0b3J9XG4gICAgICAgICAqL1xuICAgICAgICBzdGFydDogZnVuY3Rpb24gKGVhc2luZykge1xuXG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgY2xpcENvdW50ID0gMDtcblxuICAgICAgICAgICAgdmFyIG9uZVRyYWNrRG9uZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGNsaXBDb3VudC0tO1xuICAgICAgICAgICAgICAgIGlmICghY2xpcENvdW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuX2RvbmVDYWxsYmFjaygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHZhciBsYXN0Q2xpcDtcbiAgICAgICAgICAgIGZvciAodmFyIHByb3BOYW1lIGluIHRoaXMuX3RyYWNrcykge1xuICAgICAgICAgICAgICAgIHZhciBjbGlwID0gY3JlYXRlVHJhY2tDbGlwKFxuICAgICAgICAgICAgICAgICAgICB0aGlzLCBlYXNpbmcsIG9uZVRyYWNrRG9uZSxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdHJhY2tzW3Byb3BOYW1lXSwgcHJvcE5hbWVcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGlmIChjbGlwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NsaXBMaXN0LnB1c2goY2xpcCk7XG4gICAgICAgICAgICAgICAgICAgIGNsaXBDb3VudCsrO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHN0YXJ0IGFmdGVyIGFkZGVkIHRvIGFuaW1hdGlvblxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5hbmltYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYW5pbWF0aW9uLmFkZENsaXAoY2xpcCk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBsYXN0Q2xpcCA9IGNsaXA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBBZGQgZHVyaW5nIGNhbGxiYWNrIG9uIHRoZSBsYXN0IGNsaXBcbiAgICAgICAgICAgIGlmIChsYXN0Q2xpcCkge1xuICAgICAgICAgICAgICAgIHZhciBvbGRPbkZyYW1lID0gbGFzdENsaXAub25mcmFtZTtcbiAgICAgICAgICAgICAgICBsYXN0Q2xpcC5vbmZyYW1lID0gZnVuY3Rpb24gKHRhcmdldCwgcGVyY2VudCkge1xuICAgICAgICAgICAgICAgICAgICBvbGRPbkZyYW1lKHRhcmdldCwgcGVyY2VudCk7XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWxmLl9vbmZyYW1lTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5fb25mcmFtZUxpc3RbaV0odGFyZ2V0LCBwZXJjZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghY2xpcENvdW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZG9uZUNhbGxiYWNrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWBnOatouWKqOeUu1xuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGZvcndhcmRUb0xhc3QgSWYgbW92ZSB0byBsYXN0IGZyYW1lIGJlZm9yZSBzdG9wXG4gICAgICAgICAqL1xuICAgICAgICBzdG9wOiBmdW5jdGlvbiAoZm9yd2FyZFRvTGFzdCkge1xuICAgICAgICAgICAgdmFyIGNsaXBMaXN0ID0gdGhpcy5fY2xpcExpc3Q7XG4gICAgICAgICAgICB2YXIgYW5pbWF0aW9uID0gdGhpcy5hbmltYXRpb247XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNsaXBMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNsaXAgPSBjbGlwTGlzdFtpXTtcbiAgICAgICAgICAgICAgICBpZiAoZm9yd2FyZFRvTGFzdCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBNb3ZlIHRvIGxhc3QgZnJhbWUgYmVmb3JlIHN0b3BcbiAgICAgICAgICAgICAgICAgICAgY2xpcC5vbmZyYW1lKHRoaXMuX3RhcmdldCwgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFuaW1hdGlvbiAmJiBhbmltYXRpb24ucmVtb3ZlQ2xpcChjbGlwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNsaXBMaXN0Lmxlbmd0aCA9IDA7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDorr7nva7liqjnlLvlu7bov5/lvIDlp4vnmoTml7bpl7RcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSB0aW1lIOWNleS9jW1zXG4gICAgICAgICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2FuaW1hdGlvbi9BbmltYXRvcn1cbiAgICAgICAgICovXG4gICAgICAgIGRlbGF5OiBmdW5jdGlvbiAodGltZSkge1xuICAgICAgICAgICAgdGhpcy5fZGVsYXkgPSB0aW1lO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmt7vliqDliqjnlLvnu5PmnZ/nmoTlm57osINcbiAgICAgICAgICogQHBhcmFtICB7RnVuY3Rpb259IGNiXG4gICAgICAgICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2FuaW1hdGlvbi9BbmltYXRvcn1cbiAgICAgICAgICovXG4gICAgICAgIGRvbmU6IGZ1bmN0aW9uKGNiKSB7XG4gICAgICAgICAgICBpZiAoY2IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9kb25lTGlzdC5wdXNoKGNiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHtBcnJheS48bW9kdWxlOnpyZW5kZXIvYW5pbWF0aW9uL0NsaXA+fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0Q2xpcHM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jbGlwTGlzdDtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IEFuaW1hdG9yO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34venJlbmRlci9saWIvYW5pbWF0aW9uL0FuaW1hdG9yLmpzXG4gKiogbW9kdWxlIGlkID0gMTZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICog5Yqo55S75Li75o6n5Yi25ZmoXG4gKiBAY29uZmlnIHRhcmdldCDliqjnlLvlr7nosaHvvIzlj6/ku6XmmK/mlbDnu4TvvIzlpoLmnpzmmK/mlbDnu4TnmoTor53kvJrmibnph4/liIblj5FvbmZyYW1l562J5LqL5Lu2XG4gKiBAY29uZmlnIGxpZmUoMTAwMCkg5Yqo55S75pe26ZW/XG4gKiBAY29uZmlnIGRlbGF5KDApIOWKqOeUu+W7tui/n+aXtumXtFxuICogQGNvbmZpZyBsb29wKHRydWUpXG4gKiBAY29uZmlnIGdhcCgwKSDlvqrnjq/nmoTpl7TpmpTml7bpl7RcbiAqIEBjb25maWcgb25mcmFtZVxuICogQGNvbmZpZyBlYXNpbmcob3B0aW9uYWwpXG4gKiBAY29uZmlnIG9uZGVzdHJveShvcHRpb25hbClcbiAqIEBjb25maWcgb25yZXN0YXJ0KG9wdGlvbmFsKVxuICpcbiAqIFRPRE8gcGF1c2VcbiAqL1xuXG5cbiAgICB2YXIgZWFzaW5nRnVuY3MgPSByZXF1aXJlKCcuL2Vhc2luZycpO1xuXG4gICAgZnVuY3Rpb24gQ2xpcChvcHRpb25zKSB7XG5cbiAgICAgICAgdGhpcy5fdGFyZ2V0ID0gb3B0aW9ucy50YXJnZXQ7XG5cbiAgICAgICAgLy8g55Sf5ZG95ZGo5pyfXG4gICAgICAgIHRoaXMuX2xpZmUgPSBvcHRpb25zLmxpZmUgfHwgMTAwMDtcbiAgICAgICAgLy8g5bu25pe2XG4gICAgICAgIHRoaXMuX2RlbGF5ID0gb3B0aW9ucy5kZWxheSB8fCAwO1xuICAgICAgICAvLyDlvIDlp4vml7bpl7RcbiAgICAgICAgLy8gdGhpcy5fc3RhcnRUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCkgKyB0aGlzLl9kZWxheTsvLyDljZXkvY3mr6vnp5JcbiAgICAgICAgdGhpcy5faW5pdGlhbGl6ZWQgPSBmYWxzZTtcblxuICAgICAgICAvLyDmmK/lkKblvqrnjq9cbiAgICAgICAgdGhpcy5sb29wID0gb3B0aW9ucy5sb29wID09IG51bGwgPyBmYWxzZSA6IG9wdGlvbnMubG9vcDtcblxuICAgICAgICB0aGlzLmdhcCA9IG9wdGlvbnMuZ2FwIHx8IDA7XG5cbiAgICAgICAgdGhpcy5lYXNpbmcgPSBvcHRpb25zLmVhc2luZyB8fCAnTGluZWFyJztcblxuICAgICAgICB0aGlzLm9uZnJhbWUgPSBvcHRpb25zLm9uZnJhbWU7XG4gICAgICAgIHRoaXMub25kZXN0cm95ID0gb3B0aW9ucy5vbmRlc3Ryb3k7XG4gICAgICAgIHRoaXMub25yZXN0YXJ0ID0gb3B0aW9ucy5vbnJlc3RhcnQ7XG4gICAgfVxuXG4gICAgQ2xpcC5wcm90b3R5cGUgPSB7XG5cbiAgICAgICAgY29uc3RydWN0b3I6IENsaXAsXG5cbiAgICAgICAgc3RlcDogZnVuY3Rpb24gKGdsb2JhbFRpbWUpIHtcbiAgICAgICAgICAgIC8vIFNldCBzdGFydFRpbWUgb24gZmlyc3Qgc3RlcCwgb3IgX3N0YXJ0VGltZSBtYXkgaGFzIG1pbGxlc2Vjb25kcyBkaWZmZXJlbnQgYmV0d2VlbiBjbGlwc1xuICAgICAgICAgICAgLy8gUEVORElOR1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9pbml0aWFsaXplZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0VGltZSA9IGdsb2JhbFRpbWUgKyB0aGlzLl9kZWxheTtcbiAgICAgICAgICAgICAgICB0aGlzLl9pbml0aWFsaXplZCA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBwZXJjZW50ID0gKGdsb2JhbFRpbWUgLSB0aGlzLl9zdGFydFRpbWUpIC8gdGhpcy5fbGlmZTtcblxuICAgICAgICAgICAgLy8g6L+Y5rKh5byA5aeLXG4gICAgICAgICAgICBpZiAocGVyY2VudCA8IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHBlcmNlbnQgPSBNYXRoLm1pbihwZXJjZW50LCAxKTtcblxuICAgICAgICAgICAgdmFyIGVhc2luZyA9IHRoaXMuZWFzaW5nO1xuICAgICAgICAgICAgdmFyIGVhc2luZ0Z1bmMgPSB0eXBlb2YgZWFzaW5nID09ICdzdHJpbmcnID8gZWFzaW5nRnVuY3NbZWFzaW5nXSA6IGVhc2luZztcbiAgICAgICAgICAgIHZhciBzY2hlZHVsZSA9IHR5cGVvZiBlYXNpbmdGdW5jID09PSAnZnVuY3Rpb24nXG4gICAgICAgICAgICAgICAgPyBlYXNpbmdGdW5jKHBlcmNlbnQpXG4gICAgICAgICAgICAgICAgOiBwZXJjZW50O1xuXG4gICAgICAgICAgICB0aGlzLmZpcmUoJ2ZyYW1lJywgc2NoZWR1bGUpO1xuXG4gICAgICAgICAgICAvLyDnu5PmnZ9cbiAgICAgICAgICAgIGlmIChwZXJjZW50ID09IDEpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5sb29wKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVzdGFydCAoZ2xvYmFsVGltZSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIOmHjeaWsOW8gOWni+WRqOacn1xuICAgICAgICAgICAgICAgICAgICAvLyDmipvlh7rogIzkuI3mmK/nm7TmjqXosIPnlKjkuovku7bnm7TliLAgc3RhZ2UudXBkYXRlIOWQjuWGjee7n+S4gOiwg+eUqOi/meS6m+S6i+S7tlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ3Jlc3RhcnQnO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIOWKqOeUu+WujOaIkOWwhui/meS4quaOp+WItuWZqOagh+ivhuS4uuW+heWIoOmZpFxuICAgICAgICAgICAgICAgIC8vIOWcqEFuaW1hdGlvbi51cGRhdGXkuK3ov5vooYzmibnph4/liKDpmaRcbiAgICAgICAgICAgICAgICB0aGlzLl9uZWVkc1JlbW92ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdkZXN0cm95JztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVzdGFydDogZnVuY3Rpb24gKGdsb2JhbFRpbWUpIHtcbiAgICAgICAgICAgIHZhciByZW1haW5kZXIgPSAoZ2xvYmFsVGltZSAtIHRoaXMuX3N0YXJ0VGltZSkgJSB0aGlzLl9saWZlO1xuICAgICAgICAgICAgdGhpcy5fc3RhcnRUaW1lID0gZ2xvYmFsVGltZSAtIHJlbWFpbmRlciArIHRoaXMuZ2FwO1xuXG4gICAgICAgICAgICB0aGlzLl9uZWVkc1JlbW92ZSA9IGZhbHNlO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpcmU6IGZ1bmN0aW9uKGV2ZW50VHlwZSwgYXJnKSB7XG4gICAgICAgICAgICBldmVudFR5cGUgPSAnb24nICsgZXZlbnRUeXBlO1xuICAgICAgICAgICAgaWYgKHRoaXNbZXZlbnRUeXBlXSkge1xuICAgICAgICAgICAgICAgIHRoaXNbZXZlbnRUeXBlXSh0aGlzLl90YXJnZXQsIGFyZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBDbGlwO1xuXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi96cmVuZGVyL2xpYi9hbmltYXRpb24vQ2xpcC5qc1xuICoqIG1vZHVsZSBpZCA9IDE3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIOe8k+WKqOS7o+eggeadpeiHqiBodHRwczovL2dpdGh1Yi5jb20vc29sZS90d2Vlbi5qcy9ibG9iL21hc3Rlci9zcmMvVHdlZW4uanNcbiAqIEBzZWUgaHR0cDovL3NvbGUuZ2l0aHViLmlvL3R3ZWVuLmpzL2V4YW1wbGVzLzAzX2dyYXBocy5odG1sXG4gKiBAZXhwb3J0cyB6cmVuZGVyL2FuaW1hdGlvbi9lYXNpbmdcbiAqL1xuXG4gICAgdmFyIGVhc2luZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICovXG4gICAgICAgIGxpbmVhcjogZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgIHJldHVybiBrO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAqL1xuICAgICAgICBxdWFkcmF0aWNJbjogZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgIHJldHVybiBrICogaztcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICovXG4gICAgICAgIHF1YWRyYXRpY091dDogZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgIHJldHVybiBrICogKDIgLSBrKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICovXG4gICAgICAgIHF1YWRyYXRpY0luT3V0OiBmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgaWYgKChrICo9IDIpIDwgMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAwLjUgKiBrICogaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAtMC41ICogKC0tayAqIChrIC0gMikgLSAxKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyDkuInmrKHmlrnnmoTnvJPliqjvvIh0XjPvvIlcbiAgICAgICAgLyoqXG4gICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICovXG4gICAgICAgIGN1YmljSW46IGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICByZXR1cm4gayAqIGsgKiBrO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgKi9cbiAgICAgICAgY3ViaWNPdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICByZXR1cm4gLS1rICogayAqIGsgKyAxO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgKi9cbiAgICAgICAgY3ViaWNJbk91dDogZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgIGlmICgoayAqPSAyKSA8IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMC41ICogayAqIGsgKiBrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIDAuNSAqICgoayAtPSAyKSAqIGsgKiBrICsgMik7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8g5Zub5qyh5pa555qE57yT5Yqo77yIdF4077yJXG4gICAgICAgIC8qKlxuICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAqL1xuICAgICAgICBxdWFydGljSW46IGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICByZXR1cm4gayAqIGsgKiBrICogaztcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICovXG4gICAgICAgIHF1YXJ0aWNPdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICByZXR1cm4gMSAtICgtLWsgKiBrICogayAqIGspO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgKi9cbiAgICAgICAgcXVhcnRpY0luT3V0OiBmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgaWYgKChrICo9IDIpIDwgMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAwLjUgKiBrICogayAqIGsgKiBrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIC0wLjUgKiAoKGsgLT0gMikgKiBrICogayAqIGsgLSAyKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyDkupTmrKHmlrnnmoTnvJPliqjvvIh0XjXvvIlcbiAgICAgICAgLyoqXG4gICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICovXG4gICAgICAgIHF1aW50aWNJbjogZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgIHJldHVybiBrICogayAqIGsgKiBrICogaztcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICovXG4gICAgICAgIHF1aW50aWNPdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICByZXR1cm4gLS1rICogayAqIGsgKiBrICogayArIDE7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAqL1xuICAgICAgICBxdWludGljSW5PdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICBpZiAoKGsgKj0gMikgPCAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDAuNSAqIGsgKiBrICogayAqIGsgKiBrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIDAuNSAqICgoayAtPSAyKSAqIGsgKiBrICogayAqIGsgKyAyKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyDmraPlvKbmm7Lnur/nmoTnvJPliqjvvIhzaW4odCnvvIlcbiAgICAgICAgLyoqXG4gICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICovXG4gICAgICAgIHNpbnVzb2lkYWxJbjogZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgIHJldHVybiAxIC0gTWF0aC5jb3MoayAqIE1hdGguUEkgLyAyKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICovXG4gICAgICAgIHNpbnVzb2lkYWxPdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5zaW4oayAqIE1hdGguUEkgLyAyKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICovXG4gICAgICAgIHNpbnVzb2lkYWxJbk91dDogZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgIHJldHVybiAwLjUgKiAoMSAtIE1hdGguY29zKE1hdGguUEkgKiBrKSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8g5oyH5pWw5puy57q/55qE57yT5Yqo77yIMl5077yJXG4gICAgICAgIC8qKlxuICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAqL1xuICAgICAgICBleHBvbmVudGlhbEluOiBmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgcmV0dXJuIGsgPT09IDAgPyAwIDogTWF0aC5wb3coMTAyNCwgayAtIDEpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgKi9cbiAgICAgICAgZXhwb25lbnRpYWxPdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICByZXR1cm4gayA9PT0gMSA/IDEgOiAxIC0gTWF0aC5wb3coMiwgLTEwICogayk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAqL1xuICAgICAgICBleHBvbmVudGlhbEluT3V0OiBmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgaWYgKGsgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChrID09PSAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKGsgKj0gMikgPCAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDAuNSAqIE1hdGgucG93KDEwMjQsIGsgLSAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAwLjUgKiAoLU1hdGgucG93KDIsIC0xMCAqIChrIC0gMSkpICsgMik7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8g5ZyG5b2i5puy57q/55qE57yT5Yqo77yIc3FydCgxLXReMinvvIlcbiAgICAgICAgLyoqXG4gICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICovXG4gICAgICAgIGNpcmN1bGFySW46IGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICByZXR1cm4gMSAtIE1hdGguc3FydCgxIC0gayAqIGspO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgKi9cbiAgICAgICAgY2lyY3VsYXJPdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KDEgLSAoLS1rICogaykpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgKi9cbiAgICAgICAgY2lyY3VsYXJJbk91dDogZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgIGlmICgoayAqPSAyKSA8IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gLTAuNSAqIChNYXRoLnNxcnQoMSAtIGsgKiBrKSAtIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIDAuNSAqIChNYXRoLnNxcnQoMSAtIChrIC09IDIpICogaykgKyAxKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyDliJvlu7rnsbvkvLzkuo7lvLnnsKflnKjlgZzmraLliY3mnaXlm57mjK/ojaHnmoTliqjnlLtcbiAgICAgICAgLyoqXG4gICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICovXG4gICAgICAgIGVsYXN0aWNJbjogZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgIHZhciBzO1xuICAgICAgICAgICAgdmFyIGEgPSAwLjE7XG4gICAgICAgICAgICB2YXIgcCA9IDAuNDtcbiAgICAgICAgICAgIGlmIChrID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoayA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFhIHx8IGEgPCAxKSB7XG4gICAgICAgICAgICAgICAgYSA9IDE7IHMgPSBwIC8gNDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHMgPSBwICogTWF0aC5hc2luKDEgLyBhKSAvICgyICogTWF0aC5QSSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gLShhICogTWF0aC5wb3coMiwgMTAgKiAoayAtPSAxKSkgKlxuICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5zaW4oKGsgLSBzKSAqICgyICogTWF0aC5QSSkgLyBwKSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAqL1xuICAgICAgICBlbGFzdGljT3V0OiBmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgdmFyIHM7XG4gICAgICAgICAgICB2YXIgYSA9IDAuMTtcbiAgICAgICAgICAgIHZhciBwID0gMC40O1xuICAgICAgICAgICAgaWYgKGsgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChrID09PSAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWEgfHwgYSA8IDEpIHtcbiAgICAgICAgICAgICAgICBhID0gMTsgcyA9IHAgLyA0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcyA9IHAgKiBNYXRoLmFzaW4oMSAvIGEpIC8gKDIgKiBNYXRoLlBJKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAoYSAqIE1hdGgucG93KDIsIC0xMCAqIGspICpcbiAgICAgICAgICAgICAgICAgICAgTWF0aC5zaW4oKGsgLSBzKSAqICgyICogTWF0aC5QSSkgLyBwKSArIDEpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgKi9cbiAgICAgICAgZWxhc3RpY0luT3V0OiBmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgdmFyIHM7XG4gICAgICAgICAgICB2YXIgYSA9IDAuMTtcbiAgICAgICAgICAgIHZhciBwID0gMC40O1xuICAgICAgICAgICAgaWYgKGsgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChrID09PSAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWEgfHwgYSA8IDEpIHtcbiAgICAgICAgICAgICAgICBhID0gMTsgcyA9IHAgLyA0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcyA9IHAgKiBNYXRoLmFzaW4oMSAvIGEpIC8gKDIgKiBNYXRoLlBJKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgoayAqPSAyKSA8IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gLTAuNSAqIChhICogTWF0aC5wb3coMiwgMTAgKiAoayAtPSAxKSlcbiAgICAgICAgICAgICAgICAgICAgKiBNYXRoLnNpbigoayAtIHMpICogKDIgKiBNYXRoLlBJKSAvIHApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhICogTWF0aC5wb3coMiwgLTEwICogKGsgLT0gMSkpXG4gICAgICAgICAgICAgICAgICAgICogTWF0aC5zaW4oKGsgLSBzKSAqICgyICogTWF0aC5QSSkgLyBwKSAqIDAuNSArIDE7XG5cbiAgICAgICAgfSxcblxuICAgICAgICAvLyDlnKjmn5DkuIDliqjnlLvlvIDlp4vmsr/mjIfnpLrnmoTot6/lvoTov5vooYzliqjnlLvlpITnkIbliY3nqI3nqI3mlLblm57or6XliqjnlLvnmoTnp7vliqhcbiAgICAgICAgLyoqXG4gICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICovXG4gICAgICAgIGJhY2tJbjogZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgIHZhciBzID0gMS43MDE1ODtcbiAgICAgICAgICAgIHJldHVybiBrICogayAqICgocyArIDEpICogayAtIHMpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgKi9cbiAgICAgICAgYmFja091dDogZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgIHZhciBzID0gMS43MDE1ODtcbiAgICAgICAgICAgIHJldHVybiAtLWsgKiBrICogKChzICsgMSkgKiBrICsgcykgKyAxO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgKi9cbiAgICAgICAgYmFja0luT3V0OiBmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgdmFyIHMgPSAxLjcwMTU4ICogMS41MjU7XG4gICAgICAgICAgICBpZiAoKGsgKj0gMikgPCAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDAuNSAqIChrICogayAqICgocyArIDEpICogayAtIHMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAwLjUgKiAoKGsgLT0gMikgKiBrICogKChzICsgMSkgKiBrICsgcykgKyAyKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyDliJvlu7rlvLnot7PmlYjmnpxcbiAgICAgICAgLyoqXG4gICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICovXG4gICAgICAgIGJvdW5jZUluOiBmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgcmV0dXJuIDEgLSBlYXNpbmcuYm91bmNlT3V0KDEgLSBrKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICovXG4gICAgICAgIGJvdW5jZU91dDogZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgIGlmIChrIDwgKDEgLyAyLjc1KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiA3LjU2MjUgKiBrICogaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGsgPCAoMiAvIDIuNzUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDcuNTYyNSAqIChrIC09ICgxLjUgLyAyLjc1KSkgKiBrICsgMC43NTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGsgPCAoMi41IC8gMi43NSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gNy41NjI1ICogKGsgLT0gKDIuMjUgLyAyLjc1KSkgKiBrICsgMC45Mzc1O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDcuNTYyNSAqIChrIC09ICgyLjYyNSAvIDIuNzUpKSAqIGsgKyAwLjk4NDM3NTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICovXG4gICAgICAgIGJvdW5jZUluT3V0OiBmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgaWYgKGsgPCAwLjUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZWFzaW5nLmJvdW5jZUluKGsgKiAyKSAqIDAuNTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBlYXNpbmcuYm91bmNlT3V0KGsgKiAyIC0gMSkgKiAwLjUgKyAwLjU7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBlYXNpbmc7XG5cblxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34venJlbmRlci9saWIvYW5pbWF0aW9uL2Vhc2luZy5qc1xuICoqIG1vZHVsZSBpZCA9IDE4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIEBtb2R1bGUgenJlbmRlci90b29sL2NvbG9yXG4gKi9cblxuXG4gICAgdmFyIGtDU1NDb2xvclRhYmxlID0ge1xuICAgICAgICAndHJhbnNwYXJlbnQnOiBbMCwwLDAsMF0sICdhbGljZWJsdWUnOiBbMjQwLDI0OCwyNTUsMV0sXG4gICAgICAgICdhbnRpcXVld2hpdGUnOiBbMjUwLDIzNSwyMTUsMV0sICdhcXVhJzogWzAsMjU1LDI1NSwxXSxcbiAgICAgICAgJ2FxdWFtYXJpbmUnOiBbMTI3LDI1NSwyMTIsMV0sICdhenVyZSc6IFsyNDAsMjU1LDI1NSwxXSxcbiAgICAgICAgJ2JlaWdlJzogWzI0NSwyNDUsMjIwLDFdLCAnYmlzcXVlJzogWzI1NSwyMjgsMTk2LDFdLFxuICAgICAgICAnYmxhY2snOiBbMCwwLDAsMV0sICdibGFuY2hlZGFsbW9uZCc6IFsyNTUsMjM1LDIwNSwxXSxcbiAgICAgICAgJ2JsdWUnOiBbMCwwLDI1NSwxXSwgJ2JsdWV2aW9sZXQnOiBbMTM4LDQzLDIyNiwxXSxcbiAgICAgICAgJ2Jyb3duJzogWzE2NSw0Miw0MiwxXSwgJ2J1cmx5d29vZCc6IFsyMjIsMTg0LDEzNSwxXSxcbiAgICAgICAgJ2NhZGV0Ymx1ZSc6IFs5NSwxNTgsMTYwLDFdLCAnY2hhcnRyZXVzZSc6IFsxMjcsMjU1LDAsMV0sXG4gICAgICAgICdjaG9jb2xhdGUnOiBbMjEwLDEwNSwzMCwxXSwgJ2NvcmFsJzogWzI1NSwxMjcsODAsMV0sXG4gICAgICAgICdjb3JuZmxvd2VyYmx1ZSc6IFsxMDAsMTQ5LDIzNywxXSwgJ2Nvcm5zaWxrJzogWzI1NSwyNDgsMjIwLDFdLFxuICAgICAgICAnY3JpbXNvbic6IFsyMjAsMjAsNjAsMV0sICdjeWFuJzogWzAsMjU1LDI1NSwxXSxcbiAgICAgICAgJ2RhcmtibHVlJzogWzAsMCwxMzksMV0sICdkYXJrY3lhbic6IFswLDEzOSwxMzksMV0sXG4gICAgICAgICdkYXJrZ29sZGVucm9kJzogWzE4NCwxMzQsMTEsMV0sICdkYXJrZ3JheSc6IFsxNjksMTY5LDE2OSwxXSxcbiAgICAgICAgJ2RhcmtncmVlbic6IFswLDEwMCwwLDFdLCAnZGFya2dyZXknOiBbMTY5LDE2OSwxNjksMV0sXG4gICAgICAgICdkYXJra2hha2knOiBbMTg5LDE4MywxMDcsMV0sICdkYXJrbWFnZW50YSc6IFsxMzksMCwxMzksMV0sXG4gICAgICAgICdkYXJrb2xpdmVncmVlbic6IFs4NSwxMDcsNDcsMV0sICdkYXJrb3JhbmdlJzogWzI1NSwxNDAsMCwxXSxcbiAgICAgICAgJ2RhcmtvcmNoaWQnOiBbMTUzLDUwLDIwNCwxXSwgJ2RhcmtyZWQnOiBbMTM5LDAsMCwxXSxcbiAgICAgICAgJ2RhcmtzYWxtb24nOiBbMjMzLDE1MCwxMjIsMV0sICdkYXJrc2VhZ3JlZW4nOiBbMTQzLDE4OCwxNDMsMV0sXG4gICAgICAgICdkYXJrc2xhdGVibHVlJzogWzcyLDYxLDEzOSwxXSwgJ2RhcmtzbGF0ZWdyYXknOiBbNDcsNzksNzksMV0sXG4gICAgICAgICdkYXJrc2xhdGVncmV5JzogWzQ3LDc5LDc5LDFdLCAnZGFya3R1cnF1b2lzZSc6IFswLDIwNiwyMDksMV0sXG4gICAgICAgICdkYXJrdmlvbGV0JzogWzE0OCwwLDIxMSwxXSwgJ2RlZXBwaW5rJzogWzI1NSwyMCwxNDcsMV0sXG4gICAgICAgICdkZWVwc2t5Ymx1ZSc6IFswLDE5MSwyNTUsMV0sICdkaW1ncmF5JzogWzEwNSwxMDUsMTA1LDFdLFxuICAgICAgICAnZGltZ3JleSc6IFsxMDUsMTA1LDEwNSwxXSwgJ2RvZGdlcmJsdWUnOiBbMzAsMTQ0LDI1NSwxXSxcbiAgICAgICAgJ2ZpcmVicmljayc6IFsxNzgsMzQsMzQsMV0sICdmbG9yYWx3aGl0ZSc6IFsyNTUsMjUwLDI0MCwxXSxcbiAgICAgICAgJ2ZvcmVzdGdyZWVuJzogWzM0LDEzOSwzNCwxXSwgJ2Z1Y2hzaWEnOiBbMjU1LDAsMjU1LDFdLFxuICAgICAgICAnZ2FpbnNib3JvJzogWzIyMCwyMjAsMjIwLDFdLCAnZ2hvc3R3aGl0ZSc6IFsyNDgsMjQ4LDI1NSwxXSxcbiAgICAgICAgJ2dvbGQnOiBbMjU1LDIxNSwwLDFdLCAnZ29sZGVucm9kJzogWzIxOCwxNjUsMzIsMV0sXG4gICAgICAgICdncmF5JzogWzEyOCwxMjgsMTI4LDFdLCAnZ3JlZW4nOiBbMCwxMjgsMCwxXSxcbiAgICAgICAgJ2dyZWVueWVsbG93JzogWzE3MywyNTUsNDcsMV0sICdncmV5JzogWzEyOCwxMjgsMTI4LDFdLFxuICAgICAgICAnaG9uZXlkZXcnOiBbMjQwLDI1NSwyNDAsMV0sICdob3RwaW5rJzogWzI1NSwxMDUsMTgwLDFdLFxuICAgICAgICAnaW5kaWFucmVkJzogWzIwNSw5Miw5MiwxXSwgJ2luZGlnbyc6IFs3NSwwLDEzMCwxXSxcbiAgICAgICAgJ2l2b3J5JzogWzI1NSwyNTUsMjQwLDFdLCAna2hha2knOiBbMjQwLDIzMCwxNDAsMV0sXG4gICAgICAgICdsYXZlbmRlcic6IFsyMzAsMjMwLDI1MCwxXSwgJ2xhdmVuZGVyYmx1c2gnOiBbMjU1LDI0MCwyNDUsMV0sXG4gICAgICAgICdsYXduZ3JlZW4nOiBbMTI0LDI1MiwwLDFdLCAnbGVtb25jaGlmZm9uJzogWzI1NSwyNTAsMjA1LDFdLFxuICAgICAgICAnbGlnaHRibHVlJzogWzE3MywyMTYsMjMwLDFdLCAnbGlnaHRjb3JhbCc6IFsyNDAsMTI4LDEyOCwxXSxcbiAgICAgICAgJ2xpZ2h0Y3lhbic6IFsyMjQsMjU1LDI1NSwxXSwgJ2xpZ2h0Z29sZGVucm9keWVsbG93JzogWzI1MCwyNTAsMjEwLDFdLFxuICAgICAgICAnbGlnaHRncmF5JzogWzIxMSwyMTEsMjExLDFdLCAnbGlnaHRncmVlbic6IFsxNDQsMjM4LDE0NCwxXSxcbiAgICAgICAgJ2xpZ2h0Z3JleSc6IFsyMTEsMjExLDIxMSwxXSwgJ2xpZ2h0cGluayc6IFsyNTUsMTgyLDE5MywxXSxcbiAgICAgICAgJ2xpZ2h0c2FsbW9uJzogWzI1NSwxNjAsMTIyLDFdLCAnbGlnaHRzZWFncmVlbic6IFszMiwxNzgsMTcwLDFdLFxuICAgICAgICAnbGlnaHRza3libHVlJzogWzEzNSwyMDYsMjUwLDFdLCAnbGlnaHRzbGF0ZWdyYXknOiBbMTE5LDEzNiwxNTMsMV0sXG4gICAgICAgICdsaWdodHNsYXRlZ3JleSc6IFsxMTksMTM2LDE1MywxXSwgJ2xpZ2h0c3RlZWxibHVlJzogWzE3NiwxOTYsMjIyLDFdLFxuICAgICAgICAnbGlnaHR5ZWxsb3cnOiBbMjU1LDI1NSwyMjQsMV0sICdsaW1lJzogWzAsMjU1LDAsMV0sXG4gICAgICAgICdsaW1lZ3JlZW4nOiBbNTAsMjA1LDUwLDFdLCAnbGluZW4nOiBbMjUwLDI0MCwyMzAsMV0sXG4gICAgICAgICdtYWdlbnRhJzogWzI1NSwwLDI1NSwxXSwgJ21hcm9vbic6IFsxMjgsMCwwLDFdLFxuICAgICAgICAnbWVkaXVtYXF1YW1hcmluZSc6IFsxMDIsMjA1LDE3MCwxXSwgJ21lZGl1bWJsdWUnOiBbMCwwLDIwNSwxXSxcbiAgICAgICAgJ21lZGl1bW9yY2hpZCc6IFsxODYsODUsMjExLDFdLCAnbWVkaXVtcHVycGxlJzogWzE0NywxMTIsMjE5LDFdLFxuICAgICAgICAnbWVkaXVtc2VhZ3JlZW4nOiBbNjAsMTc5LDExMywxXSwgJ21lZGl1bXNsYXRlYmx1ZSc6IFsxMjMsMTA0LDIzOCwxXSxcbiAgICAgICAgJ21lZGl1bXNwcmluZ2dyZWVuJzogWzAsMjUwLDE1NCwxXSwgJ21lZGl1bXR1cnF1b2lzZSc6IFs3MiwyMDksMjA0LDFdLFxuICAgICAgICAnbWVkaXVtdmlvbGV0cmVkJzogWzE5OSwyMSwxMzMsMV0sICdtaWRuaWdodGJsdWUnOiBbMjUsMjUsMTEyLDFdLFxuICAgICAgICAnbWludGNyZWFtJzogWzI0NSwyNTUsMjUwLDFdLCAnbWlzdHlyb3NlJzogWzI1NSwyMjgsMjI1LDFdLFxuICAgICAgICAnbW9jY2FzaW4nOiBbMjU1LDIyOCwxODEsMV0sICduYXZham93aGl0ZSc6IFsyNTUsMjIyLDE3MywxXSxcbiAgICAgICAgJ25hdnknOiBbMCwwLDEyOCwxXSwgJ29sZGxhY2UnOiBbMjUzLDI0NSwyMzAsMV0sXG4gICAgICAgICdvbGl2ZSc6IFsxMjgsMTI4LDAsMV0sICdvbGl2ZWRyYWInOiBbMTA3LDE0MiwzNSwxXSxcbiAgICAgICAgJ29yYW5nZSc6IFsyNTUsMTY1LDAsMV0sICdvcmFuZ2VyZWQnOiBbMjU1LDY5LDAsMV0sXG4gICAgICAgICdvcmNoaWQnOiBbMjE4LDExMiwyMTQsMV0sICdwYWxlZ29sZGVucm9kJzogWzIzOCwyMzIsMTcwLDFdLFxuICAgICAgICAncGFsZWdyZWVuJzogWzE1MiwyNTEsMTUyLDFdLCAncGFsZXR1cnF1b2lzZSc6IFsxNzUsMjM4LDIzOCwxXSxcbiAgICAgICAgJ3BhbGV2aW9sZXRyZWQnOiBbMjE5LDExMiwxNDcsMV0sICdwYXBheWF3aGlwJzogWzI1NSwyMzksMjEzLDFdLFxuICAgICAgICAncGVhY2hwdWZmJzogWzI1NSwyMTgsMTg1LDFdLCAncGVydSc6IFsyMDUsMTMzLDYzLDFdLFxuICAgICAgICAncGluayc6IFsyNTUsMTkyLDIwMywxXSwgJ3BsdW0nOiBbMjIxLDE2MCwyMjEsMV0sXG4gICAgICAgICdwb3dkZXJibHVlJzogWzE3NiwyMjQsMjMwLDFdLCAncHVycGxlJzogWzEyOCwwLDEyOCwxXSxcbiAgICAgICAgJ3JlZCc6IFsyNTUsMCwwLDFdLCAncm9zeWJyb3duJzogWzE4OCwxNDMsMTQzLDFdLFxuICAgICAgICAncm95YWxibHVlJzogWzY1LDEwNSwyMjUsMV0sICdzYWRkbGVicm93bic6IFsxMzksNjksMTksMV0sXG4gICAgICAgICdzYWxtb24nOiBbMjUwLDEyOCwxMTQsMV0sICdzYW5keWJyb3duJzogWzI0NCwxNjQsOTYsMV0sXG4gICAgICAgICdzZWFncmVlbic6IFs0NiwxMzksODcsMV0sICdzZWFzaGVsbCc6IFsyNTUsMjQ1LDIzOCwxXSxcbiAgICAgICAgJ3NpZW5uYSc6IFsxNjAsODIsNDUsMV0sICdzaWx2ZXInOiBbMTkyLDE5MiwxOTIsMV0sXG4gICAgICAgICdza3libHVlJzogWzEzNSwyMDYsMjM1LDFdLCAnc2xhdGVibHVlJzogWzEwNiw5MCwyMDUsMV0sXG4gICAgICAgICdzbGF0ZWdyYXknOiBbMTEyLDEyOCwxNDQsMV0sICdzbGF0ZWdyZXknOiBbMTEyLDEyOCwxNDQsMV0sXG4gICAgICAgICdzbm93JzogWzI1NSwyNTAsMjUwLDFdLCAnc3ByaW5nZ3JlZW4nOiBbMCwyNTUsMTI3LDFdLFxuICAgICAgICAnc3RlZWxibHVlJzogWzcwLDEzMCwxODAsMV0sICd0YW4nOiBbMjEwLDE4MCwxNDAsMV0sXG4gICAgICAgICd0ZWFsJzogWzAsMTI4LDEyOCwxXSwgJ3RoaXN0bGUnOiBbMjE2LDE5MSwyMTYsMV0sXG4gICAgICAgICd0b21hdG8nOiBbMjU1LDk5LDcxLDFdLCAndHVycXVvaXNlJzogWzY0LDIyNCwyMDgsMV0sXG4gICAgICAgICd2aW9sZXQnOiBbMjM4LDEzMCwyMzgsMV0sICd3aGVhdCc6IFsyNDUsMjIyLDE3OSwxXSxcbiAgICAgICAgJ3doaXRlJzogWzI1NSwyNTUsMjU1LDFdLCAnd2hpdGVzbW9rZSc6IFsyNDUsMjQ1LDI0NSwxXSxcbiAgICAgICAgJ3llbGxvdyc6IFsyNTUsMjU1LDAsMV0sICd5ZWxsb3dncmVlbic6IFsxNTQsMjA1LDUwLDFdXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGNsYW1wQ3NzQnl0ZShpKSB7ICAvLyBDbGFtcCB0byBpbnRlZ2VyIDAgLi4gMjU1LlxuICAgICAgICBpID0gTWF0aC5yb3VuZChpKTsgIC8vIFNlZW1zIHRvIGJlIHdoYXQgQ2hyb21lIGRvZXMgKHZzIHRydW5jYXRpb24pLlxuICAgICAgICByZXR1cm4gaSA8IDAgPyAwIDogaSA+IDI1NSA/IDI1NSA6IGk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xhbXBDc3NBbmdsZShpKSB7ICAvLyBDbGFtcCB0byBpbnRlZ2VyIDAgLi4gMzYwLlxuICAgICAgICBpID0gTWF0aC5yb3VuZChpKTsgIC8vIFNlZW1zIHRvIGJlIHdoYXQgQ2hyb21lIGRvZXMgKHZzIHRydW5jYXRpb24pLlxuICAgICAgICByZXR1cm4gaSA8IDAgPyAwIDogaSA+IDM2MCA/IDM2MCA6IGk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xhbXBDc3NGbG9hdChmKSB7ICAvLyBDbGFtcCB0byBmbG9hdCAwLjAgLi4gMS4wLlxuICAgICAgICByZXR1cm4gZiA8IDAgPyAwIDogZiA+IDEgPyAxIDogZjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZUNzc0ludChzdHIpIHsgIC8vIGludCBvciBwZXJjZW50YWdlLlxuICAgICAgICBpZiAoc3RyLmxlbmd0aCAmJiBzdHIuY2hhckF0KHN0ci5sZW5ndGggLSAxKSA9PT0gJyUnKSB7XG4gICAgICAgICAgICByZXR1cm4gY2xhbXBDc3NCeXRlKHBhcnNlRmxvYXQoc3RyKSAvIDEwMCAqIDI1NSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNsYW1wQ3NzQnl0ZShwYXJzZUludChzdHIsIDEwKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VDc3NGbG9hdChzdHIpIHsgIC8vIGZsb2F0IG9yIHBlcmNlbnRhZ2UuXG4gICAgICAgIGlmIChzdHIubGVuZ3RoICYmIHN0ci5jaGFyQXQoc3RyLmxlbmd0aCAtIDEpID09PSAnJScpIHtcbiAgICAgICAgICAgIHJldHVybiBjbGFtcENzc0Zsb2F0KHBhcnNlRmxvYXQoc3RyKSAvIDEwMCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNsYW1wQ3NzRmxvYXQocGFyc2VGbG9hdChzdHIpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjc3NIdWVUb1JnYihtMSwgbTIsIGgpIHtcbiAgICAgICAgaWYgKGggPCAwKSB7XG4gICAgICAgICAgICBoICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaCA+IDEpIHtcbiAgICAgICAgICAgIGggLT0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoICogNiA8IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBtMSArIChtMiAtIG0xKSAqIGggKiA2O1xuICAgICAgICB9XG4gICAgICAgIGlmIChoICogMiA8IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBtMjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaCAqIDMgPCAyKSB7XG4gICAgICAgICAgICByZXR1cm4gbTEgKyAobTIgLSBtMSkgKiAoMi8zIC0gaCkgKiA2O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtMTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsZXJwKGEsIGIsIHApIHtcbiAgICAgICAgcmV0dXJuIGEgKyAoYiAtIGEpICogcDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29sb3JTdHJcbiAgICAgKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn1cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvdXRpbC9jb2xvclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHBhcnNlKGNvbG9yU3RyKSB7XG4gICAgICAgIGlmICghY29sb3JTdHIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBjb2xvclN0ciBtYXkgYmUgbm90IHN0cmluZ1xuICAgICAgICBjb2xvclN0ciA9IGNvbG9yU3RyICsgJyc7XG4gICAgICAgIC8vIFJlbW92ZSBhbGwgd2hpdGVzcGFjZSwgbm90IGNvbXBsaWFudCwgYnV0IHNob3VsZCBqdXN0IGJlIG1vcmUgYWNjZXB0aW5nLlxuICAgICAgICB2YXIgc3RyID0gY29sb3JTdHIucmVwbGFjZSgvIC9nLCAnJykudG9Mb3dlckNhc2UoKTtcblxuICAgICAgICAvLyBDb2xvciBrZXl3b3JkcyAoYW5kIHRyYW5zcGFyZW50KSBsb29rdXAuXG4gICAgICAgIGlmIChzdHIgaW4ga0NTU0NvbG9yVGFibGUpIHtcbiAgICAgICAgICAgIHJldHVybiBrQ1NTQ29sb3JUYWJsZVtzdHJdLnNsaWNlKCk7ICAvLyBkdXAuXG4gICAgICAgIH1cblxuICAgICAgICAvLyAjYWJjIGFuZCAjYWJjMTIzIHN5bnRheC5cbiAgICAgICAgaWYgKHN0ci5jaGFyQXQoMCkgPT09ICcjJykge1xuICAgICAgICAgICAgaWYgKHN0ci5sZW5ndGggPT09IDQpIHtcbiAgICAgICAgICAgICAgICB2YXIgaXYgPSBwYXJzZUludChzdHIuc3Vic3RyKDEpLCAxNik7ICAvLyBUT0RPKGRlYW5tKTogU3RyaWN0ZXIgcGFyc2luZy5cbiAgICAgICAgICAgICAgICBpZiAoIShpdiA+PSAwICYmIGl2IDw9IDB4ZmZmKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47ICAvLyBDb3ZlcnMgTmFOLlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAoKGl2ICYgMHhmMDApID4+IDQpIHwgKChpdiAmIDB4ZjAwKSA+PiA4KSxcbiAgICAgICAgICAgICAgICAgICAgKGl2ICYgMHhmMCkgfCAoKGl2ICYgMHhmMCkgPj4gNCksXG4gICAgICAgICAgICAgICAgICAgIChpdiAmIDB4ZikgfCAoKGl2ICYgMHhmKSA8PCA0KSxcbiAgICAgICAgICAgICAgICAgICAgMVxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzdHIubGVuZ3RoID09PSA3KSB7XG4gICAgICAgICAgICAgICAgdmFyIGl2ID0gcGFyc2VJbnQoc3RyLnN1YnN0cigxKSwgMTYpOyAgLy8gVE9ETyhkZWFubSk6IFN0cmljdGVyIHBhcnNpbmcuXG4gICAgICAgICAgICAgICAgaWYgKCEoaXYgPj0gMCAmJiBpdiA8PSAweGZmZmZmZikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuOyAgLy8gQ292ZXJzIE5hTi5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgKGl2ICYgMHhmZjAwMDApID4+IDE2LFxuICAgICAgICAgICAgICAgICAgICAoaXYgJiAweGZmMDApID4+IDgsXG4gICAgICAgICAgICAgICAgICAgIGl2ICYgMHhmZixcbiAgICAgICAgICAgICAgICAgICAgMVxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgb3AgPSBzdHIuaW5kZXhPZignKCcpLCBlcCA9IHN0ci5pbmRleE9mKCcpJyk7XG4gICAgICAgIGlmIChvcCAhPT0gLTEgJiYgZXAgKyAxID09PSBzdHIubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgZm5hbWUgPSBzdHIuc3Vic3RyKDAsIG9wKTtcbiAgICAgICAgICAgIHZhciBwYXJhbXMgPSBzdHIuc3Vic3RyKG9wICsgMSwgZXAgLSAob3AgKyAxKSkuc3BsaXQoJywnKTtcbiAgICAgICAgICAgIHZhciBhbHBoYSA9IDE7ICAvLyBUbyBhbGxvdyBjYXNlIGZhbGx0aHJvdWdoLlxuICAgICAgICAgICAgc3dpdGNoIChmbmFtZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3JnYmEnOlxuICAgICAgICAgICAgICAgICAgICBpZiAocGFyYW1zLmxlbmd0aCAhPT0gNCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGFscGhhID0gcGFyc2VDc3NGbG9hdChwYXJhbXMucG9wKCkpOyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcbiAgICAgICAgICAgICAgICAvLyBGYWxsIHRocm91Z2guXG4gICAgICAgICAgICAgICAgY2FzZSAncmdiJzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmFtcy5sZW5ndGggIT09IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VDc3NJbnQocGFyYW1zWzBdKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlQ3NzSW50KHBhcmFtc1sxXSksXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZUNzc0ludChwYXJhbXNbMl0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWxwaGFcbiAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICBjYXNlICdoc2xhJzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmFtcy5sZW5ndGggIT09IDQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwYXJhbXNbM10gPSBwYXJzZUNzc0Zsb2F0KHBhcmFtc1szXSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBoc2xhMnJnYmEocGFyYW1zKTtcbiAgICAgICAgICAgICAgICBjYXNlICdoc2wnOlxuICAgICAgICAgICAgICAgICAgICBpZiAocGFyYW1zLmxlbmd0aCAhPT0gMykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBoc2xhMnJnYmEocGFyYW1zKTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gaHNsYVxuICAgICAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fSByZ2JhXG4gICAgICovXG4gICAgZnVuY3Rpb24gaHNsYTJyZ2JhKGhzbGEpIHtcbiAgICAgICAgdmFyIGggPSAoKChwYXJzZUZsb2F0KGhzbGFbMF0pICUgMzYwKSArIDM2MCkgJSAzNjApIC8gMzYwOyAgLy8gMCAuLiAxXG4gICAgICAgIC8vIE5PVEUoZGVhbm0pOiBBY2NvcmRpbmcgdG8gdGhlIENTUyBzcGVjIHMvbCBzaG91bGQgb25seSBiZVxuICAgICAgICAvLyBwZXJjZW50YWdlcywgYnV0IHdlIGRvbid0IGJvdGhlciBhbmQgbGV0IGZsb2F0IG9yIHBlcmNlbnRhZ2UuXG4gICAgICAgIHZhciBzID0gcGFyc2VDc3NGbG9hdChoc2xhWzFdKTtcbiAgICAgICAgdmFyIGwgPSBwYXJzZUNzc0Zsb2F0KGhzbGFbMl0pO1xuICAgICAgICB2YXIgbTIgPSBsIDw9IDAuNSA/IGwgKiAocyArIDEpIDogbCArIHMgLSBsICogcztcbiAgICAgICAgdmFyIG0xID0gbCAqIDIgLSBtMjtcblxuICAgICAgICB2YXIgcmdiYSA9IFtcbiAgICAgICAgICAgIGNsYW1wQ3NzQnl0ZShjc3NIdWVUb1JnYihtMSwgbTIsIGggKyAxIC8gMykgKiAyNTUpLFxuICAgICAgICAgICAgY2xhbXBDc3NCeXRlKGNzc0h1ZVRvUmdiKG0xLCBtMiwgaCkgKiAyNTUpLFxuICAgICAgICAgICAgY2xhbXBDc3NCeXRlKGNzc0h1ZVRvUmdiKG0xLCBtMiwgaCAtIDEgLyAzKSAqIDI1NSlcbiAgICAgICAgXTtcblxuICAgICAgICBpZiAoaHNsYS5sZW5ndGggPT09IDQpIHtcbiAgICAgICAgICAgIHJnYmFbM10gPSBoc2xhWzNdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJnYmE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gcmdiYVxuICAgICAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fSBoc2xhXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmdiYTJoc2xhKHJnYmEpIHtcbiAgICAgICAgaWYgKCFyZ2JhKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSR0IgZnJvbSAwIHRvIDI1NVxuICAgICAgICB2YXIgUiA9IHJnYmFbMF0gLyAyNTU7XG4gICAgICAgIHZhciBHID0gcmdiYVsxXSAvIDI1NTtcbiAgICAgICAgdmFyIEIgPSByZ2JhWzJdIC8gMjU1O1xuXG4gICAgICAgIHZhciB2TWluID0gTWF0aC5taW4oUiwgRywgQik7IC8vIE1pbi4gdmFsdWUgb2YgUkdCXG4gICAgICAgIHZhciB2TWF4ID0gTWF0aC5tYXgoUiwgRywgQik7IC8vIE1heC4gdmFsdWUgb2YgUkdCXG4gICAgICAgIHZhciBkZWx0YSA9IHZNYXggLSB2TWluOyAvLyBEZWx0YSBSR0IgdmFsdWVcblxuICAgICAgICB2YXIgTCA9ICh2TWF4ICsgdk1pbikgLyAyO1xuICAgICAgICB2YXIgSDtcbiAgICAgICAgdmFyIFM7XG4gICAgICAgIC8vIEhTTCByZXN1bHRzIGZyb20gMCB0byAxXG4gICAgICAgIGlmIChkZWx0YSA9PT0gMCkge1xuICAgICAgICAgICAgSCA9IDA7XG4gICAgICAgICAgICBTID0gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChMIDwgMC41KSB7XG4gICAgICAgICAgICAgICAgUyA9IGRlbHRhIC8gKHZNYXggKyB2TWluKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIFMgPSBkZWx0YSAvICgyIC0gdk1heCAtIHZNaW4pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgZGVsdGFSID0gKCgodk1heCAtIFIpIC8gNikgKyAoZGVsdGEgLyAyKSkgLyBkZWx0YTtcbiAgICAgICAgICAgIHZhciBkZWx0YUcgPSAoKCh2TWF4IC0gRykgLyA2KSArIChkZWx0YSAvIDIpKSAvIGRlbHRhO1xuICAgICAgICAgICAgdmFyIGRlbHRhQiA9ICgoKHZNYXggLSBCKSAvIDYpICsgKGRlbHRhIC8gMikpIC8gZGVsdGE7XG5cbiAgICAgICAgICAgIGlmIChSID09PSB2TWF4KSB7XG4gICAgICAgICAgICAgICAgSCA9IGRlbHRhQiAtIGRlbHRhRztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKEcgPT09IHZNYXgpIHtcbiAgICAgICAgICAgICAgICBIID0gKDEgLyAzKSArIGRlbHRhUiAtIGRlbHRhQjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKEIgPT09IHZNYXgpIHtcbiAgICAgICAgICAgICAgICBIID0gKDIgLyAzKSArIGRlbHRhRyAtIGRlbHRhUjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKEggPCAwKSB7XG4gICAgICAgICAgICAgICAgSCArPSAxO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoSCA+IDEpIHtcbiAgICAgICAgICAgICAgICBIIC09IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaHNsYSA9IFtIICogMzYwLCBTLCBMXTtcblxuICAgICAgICBpZiAocmdiYVszXSAhPSBudWxsKSB7XG4gICAgICAgICAgICBoc2xhLnB1c2gocmdiYVszXSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaHNsYTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29sb3JcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbGV2ZWxcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL3V0aWwvY29sb3JcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsaWZ0KGNvbG9yLCBsZXZlbCkge1xuICAgICAgICB2YXIgY29sb3JBcnIgPSBwYXJzZShjb2xvcik7XG4gICAgICAgIGlmIChjb2xvckFycikge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAzOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAobGV2ZWwgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbG9yQXJyW2ldID0gY29sb3JBcnJbaV0gKiAoMSAtIGxldmVsKSB8IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb2xvckFycltpXSA9ICgoMjU1IC0gY29sb3JBcnJbaV0pICogbGV2ZWwgKyBjb2xvckFycltpXSkgfCAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzdHJpbmdpZnkoY29sb3JBcnIsIGNvbG9yQXJyLmxlbmd0aCA9PT0gNCA/ICdyZ2JhJyA6ICdyZ2InKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb2xvclxuICAgICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvdXRpbC9jb2xvclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvSGV4KGNvbG9yLCBsZXZlbCkge1xuICAgICAgICB2YXIgY29sb3JBcnIgPSBwYXJzZShjb2xvcik7XG4gICAgICAgIGlmIChjb2xvckFycikge1xuICAgICAgICAgICAgcmV0dXJuICgoMSA8PCAyNCkgKyAoY29sb3JBcnJbMF0gPDwgMTYpICsgKGNvbG9yQXJyWzFdIDw8IDgpICsgKCtjb2xvckFyclsyXSkpLnRvU3RyaW5nKDE2KS5zbGljZSgxKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1hcCB2YWx1ZSB0byBjb2xvci4gRmFzdGVyIHRoYW4gbWFwVG9Db2xvciBtZXRob2RzIGJlY2F1c2UgY29sb3IgaXMgcmVwcmVzZW50ZWQgYnkgcmdiYSBhcnJheVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBub3JtYWxpemVkVmFsdWUgQSBmbG9hdCBiZXR3ZWVuIDAgYW5kIDEuXG4gICAgICogQHBhcmFtIHtBcnJheS48QXJyYXkuPG51bWJlcj4+fSBjb2xvcnMgTGlzdCBvZiByZ2JhIGNvbG9yIGFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gW291dF0gTWFwcGVkIGdiYSBjb2xvciBhcnJheVxuICAgICAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZhc3RNYXBUb0NvbG9yKG5vcm1hbGl6ZWRWYWx1ZSwgY29sb3JzLCBvdXQpIHtcbiAgICAgICAgaWYgKCEoY29sb3JzICYmIGNvbG9ycy5sZW5ndGgpXG4gICAgICAgICAgICB8fCAhKG5vcm1hbGl6ZWRWYWx1ZSA+PSAwICYmIG5vcm1hbGl6ZWRWYWx1ZSA8PSAxKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBvdXQgPSBvdXQgfHwgWzAsIDAsIDAsIDBdO1xuICAgICAgICB2YXIgdmFsdWUgPSBub3JtYWxpemVkVmFsdWUgKiAoY29sb3JzLmxlbmd0aCAtIDEpO1xuICAgICAgICB2YXIgbGVmdEluZGV4ID0gTWF0aC5mbG9vcih2YWx1ZSk7XG4gICAgICAgIHZhciByaWdodEluZGV4ID0gTWF0aC5jZWlsKHZhbHVlKTtcbiAgICAgICAgdmFyIGxlZnRDb2xvciA9IGNvbG9yc1tsZWZ0SW5kZXhdO1xuICAgICAgICB2YXIgcmlnaHRDb2xvciA9IGNvbG9yc1tyaWdodEluZGV4XTtcbiAgICAgICAgdmFyIGR2ID0gdmFsdWUgLSBsZWZ0SW5kZXg7XG4gICAgICAgIG91dFswXSA9IGNsYW1wQ3NzQnl0ZShsZXJwKGxlZnRDb2xvclswXSwgcmlnaHRDb2xvclswXSwgZHYpKTtcbiAgICAgICAgb3V0WzFdID0gY2xhbXBDc3NCeXRlKGxlcnAobGVmdENvbG9yWzFdLCByaWdodENvbG9yWzFdLCBkdikpO1xuICAgICAgICBvdXRbMl0gPSBjbGFtcENzc0J5dGUobGVycChsZWZ0Q29sb3JbMl0sIHJpZ2h0Q29sb3JbMl0sIGR2KSk7XG4gICAgICAgIG91dFszXSA9IGNsYW1wQ3NzQnl0ZShsZXJwKGxlZnRDb2xvclszXSwgcmlnaHRDb2xvclszXSwgZHYpKTtcbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG5vcm1hbGl6ZWRWYWx1ZSBBIGZsb2F0IGJldHdlZW4gMCBhbmQgMS5cbiAgICAgKiBAcGFyYW0ge0FycmF5LjxzdHJpbmc+fSBjb2xvcnMgQ29sb3IgbGlzdC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBmdWxsT3V0cHV0IERlZmF1bHQgZmFsc2UuXG4gICAgICogQHJldHVybiB7KHN0cmluZ3xPYmplY3QpfSBSZXN1bHQgY29sb3IuIElmIGZ1bGxPdXRwdXQsXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge2NvbG9yOiAuLi4sIGxlZnRJbmRleDogLi4uLCByaWdodEluZGV4OiAuLi4sIHZhbHVlOiAuLi59LFxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci91dGlsL2NvbG9yXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWFwVG9Db2xvcihub3JtYWxpemVkVmFsdWUsIGNvbG9ycywgZnVsbE91dHB1dCkge1xuICAgICAgICBpZiAoIShjb2xvcnMgJiYgY29sb3JzLmxlbmd0aClcbiAgICAgICAgICAgIHx8ICEobm9ybWFsaXplZFZhbHVlID49IDAgJiYgbm9ybWFsaXplZFZhbHVlIDw9IDEpXG4gICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHZhbHVlID0gbm9ybWFsaXplZFZhbHVlICogKGNvbG9ycy5sZW5ndGggLSAxKTtcbiAgICAgICAgdmFyIGxlZnRJbmRleCA9IE1hdGguZmxvb3IodmFsdWUpO1xuICAgICAgICB2YXIgcmlnaHRJbmRleCA9IE1hdGguY2VpbCh2YWx1ZSk7XG4gICAgICAgIHZhciBsZWZ0Q29sb3IgPSBwYXJzZShjb2xvcnNbbGVmdEluZGV4XSk7XG4gICAgICAgIHZhciByaWdodENvbG9yID0gcGFyc2UoY29sb3JzW3JpZ2h0SW5kZXhdKTtcbiAgICAgICAgdmFyIGR2ID0gdmFsdWUgLSBsZWZ0SW5kZXg7XG5cbiAgICAgICAgdmFyIGNvbG9yID0gc3RyaW5naWZ5KFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIGNsYW1wQ3NzQnl0ZShsZXJwKGxlZnRDb2xvclswXSwgcmlnaHRDb2xvclswXSwgZHYpKSxcbiAgICAgICAgICAgICAgICBjbGFtcENzc0J5dGUobGVycChsZWZ0Q29sb3JbMV0sIHJpZ2h0Q29sb3JbMV0sIGR2KSksXG4gICAgICAgICAgICAgICAgY2xhbXBDc3NCeXRlKGxlcnAobGVmdENvbG9yWzJdLCByaWdodENvbG9yWzJdLCBkdikpLFxuICAgICAgICAgICAgICAgIGNsYW1wQ3NzRmxvYXQobGVycChsZWZ0Q29sb3JbM10sIHJpZ2h0Q29sb3JbM10sIGR2KSlcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAncmdiYSdcbiAgICAgICAgKTtcblxuICAgICAgICByZXR1cm4gZnVsbE91dHB1dFxuICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgY29sb3I6IGNvbG9yLFxuICAgICAgICAgICAgICAgIGxlZnRJbmRleDogbGVmdEluZGV4LFxuICAgICAgICAgICAgICAgIHJpZ2h0SW5kZXg6IHJpZ2h0SW5kZXgsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICA6IGNvbG9yO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb2xvclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gaCAwIH4gMzYwLCBpZ25vcmUgd2hlbiBudWxsLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gcyAwIH4gMSwgaWdub3JlIHdoZW4gbnVsbC5cbiAgICAgKiBAcGFyYW0ge251bWJlcj19IGwgMCB+IDEsIGlnbm9yZSB3aGVuIG51bGwuXG4gICAgICogQHJldHVybiB7c3RyaW5nfSBDb2xvciBzdHJpbmcgaW4gcmdiYSBmb3JtYXQuXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL3V0aWwvY29sb3JcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtb2RpZnlIU0woY29sb3IsIGgsIHMsIGwpIHtcbiAgICAgICAgY29sb3IgPSBwYXJzZShjb2xvcik7XG5cbiAgICAgICAgaWYgKGNvbG9yKSB7XG4gICAgICAgICAgICBjb2xvciA9IHJnYmEyaHNsYShjb2xvcik7XG4gICAgICAgICAgICBoICE9IG51bGwgJiYgKGNvbG9yWzBdID0gY2xhbXBDc3NBbmdsZShoKSk7XG4gICAgICAgICAgICBzICE9IG51bGwgJiYgKGNvbG9yWzFdID0gcGFyc2VDc3NGbG9hdChzKSk7XG4gICAgICAgICAgICBsICE9IG51bGwgJiYgKGNvbG9yWzJdID0gcGFyc2VDc3NGbG9hdChsKSk7XG5cbiAgICAgICAgICAgIHJldHVybiBzdHJpbmdpZnkoaHNsYTJyZ2JhKGNvbG9yKSwgJ3JnYmEnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb2xvclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gYWxwaGEgMCB+IDFcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IENvbG9yIHN0cmluZyBpbiByZ2JhIGZvcm1hdC5cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvdXRpbC9jb2xvclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1vZGlmeUFscGhhKGNvbG9yLCBhbHBoYSkge1xuICAgICAgICBjb2xvciA9IHBhcnNlKGNvbG9yKTtcblxuICAgICAgICBpZiAoY29sb3IgJiYgYWxwaGEgIT0gbnVsbCkge1xuICAgICAgICAgICAgY29sb3JbM10gPSBjbGFtcENzc0Zsb2F0KGFscGhhKTtcbiAgICAgICAgICAgIHJldHVybiBzdHJpbmdpZnkoY29sb3IsICdyZ2JhJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxzdHJpbmc+fSBjb2xvcnMgQ29sb3IgbGlzdC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSAncmdiYScsICdoc3ZhJywgLi4uXG4gICAgICogQHJldHVybiB7c3RyaW5nfSBSZXN1bHQgY29sb3IuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3RyaW5naWZ5KGFyckNvbG9yLCB0eXBlKSB7XG4gICAgICAgIHZhciBjb2xvclN0ciA9IGFyckNvbG9yWzBdICsgJywnICsgYXJyQ29sb3JbMV0gKyAnLCcgKyBhcnJDb2xvclsyXTtcbiAgICAgICAgaWYgKHR5cGUgPT09ICdyZ2JhJyB8fCB0eXBlID09PSAnaHN2YScgfHwgdHlwZSA9PT0gJ2hzbGEnKSB7XG4gICAgICAgICAgICBjb2xvclN0ciArPSAnLCcgKyBhcnJDb2xvclszXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHlwZSArICcoJyArIGNvbG9yU3RyICsgJyknO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0ge1xuICAgICAgICBwYXJzZTogcGFyc2UsXG4gICAgICAgIGxpZnQ6IGxpZnQsXG4gICAgICAgIHRvSGV4OiB0b0hleCxcbiAgICAgICAgZmFzdE1hcFRvQ29sb3I6IGZhc3RNYXBUb0NvbG9yLFxuICAgICAgICBtYXBUb0NvbG9yOiBtYXBUb0NvbG9yLFxuICAgICAgICBtb2RpZnlIU0w6IG1vZGlmeUhTTCxcbiAgICAgICAgbW9kaWZ5QWxwaGE6IG1vZGlmeUFscGhhLFxuICAgICAgICBzdHJpbmdpZnk6IHN0cmluZ2lmeVxuICAgIH07XG5cblxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34venJlbmRlci9saWIvdG9vbC9jb2xvci5qc1xuICoqIG1vZHVsZSBpZCA9IDE5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcbiAgICAgICAgdmFyIGNvbmZpZyA9IHJlcXVpcmUoJy4uL2NvbmZpZycpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAZXhwb3J0cyB6cmVuZGVyL3Rvb2wvbG9nXG4gICAgICAgICAqIEBhdXRob3IgS2VuZXIgKEBLZW5lci3mnpfls7AsIGtlbmVyLmxpbmZlbmdAZ21haWwuY29tKVxuICAgICAgICAgKi9cbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmIChjb25maWcuZGVidWdNb2RlID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY29uZmlnLmRlYnVnTW9kZSA9PSAxKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgayBpbiBhcmd1bWVudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGFyZ3VtZW50c1trXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY29uZmlnLmRlYnVnTW9kZSA+IDEpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrIGluIGFyZ3VtZW50cykge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhhcmd1bWVudHNba10pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvKiBmb3IgZGVidWdcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKG1lcykge1xuICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3dyb25nLW1lc3NhZ2UnKS5pbm5lckhUTUwgPVxuICAgICAgICAgICAgICAgIG1lcyArICcgJyArIChuZXcgRGF0ZSgpIC0gMClcbiAgICAgICAgICAgICAgICArICc8YnIvPicgXG4gICAgICAgICAgICAgICAgKyBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnd3JvbmctbWVzc2FnZScpLmlubmVySFRNTDtcbiAgICAgICAgfTtcbiAgICAgICAgKi9cbiAgICBcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3pyZW5kZXIvbGliL2NvcmUvbG9nLmpzXG4gKiogbW9kdWxlIGlkID0gMjBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlxuICAgIHZhciBkcHIgPSAxO1xuICAgIC8vIElmIGluIGJyb3dzZXIgZW52aXJvbm1lbnRcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgZHByID0gTWF0aC5tYXgod2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMSwgMSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGNvbmZpZ+m7mOiupOmFjee9rumhuVxuICAgICAqIEBleHBvcnRzIHpyZW5kZXIvY29uZmlnXG4gICAgICogQGF1dGhvciBLZW5lciAoQEtlbmVyLeael+WzsCwga2VuZXIubGluZmVuZ0BnbWFpbC5jb20pXG4gICAgICovXG4gICAgdmFyIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGRlYnVn5pel5b+X6YCJ6aG577yaY2F0Y2hCcnVzaEV4Y2VwdGlvbuS4unRydWXkuIvmnInmlYhcbiAgICAgICAgICogMCA6IOS4jeeUn+aIkGRlYnVn5pWw5o2u77yM5Y+R5biD55SoXG4gICAgICAgICAqIDEgOiDlvILluLjmipvlh7rvvIzosIPor5XnlKhcbiAgICAgICAgICogMiA6IOaOp+WItuWPsOi+k+WHuu+8jOiwg+ivleeUqFxuICAgICAgICAgKi9cbiAgICAgICAgZGVidWdNb2RlOiAwLFxuXG4gICAgICAgIC8vIHJldGluYSDlsY/luZXkvJjljJZcbiAgICAgICAgZGV2aWNlUGl4ZWxSYXRpbzogZHByXG4gICAgfTtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGNvbmZpZztcblxuXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi96cmVuZGVyL2xpYi9jb25maWcuanNcbiAqKiBtb2R1bGUgaWQgPSAyMVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBNaXhpbiBmb3IgZHJhd2luZyB0ZXh0IGluIGEgZWxlbWVudCBib3VuZGluZyByZWN0XG4gKiBAbW9kdWxlIHpyZW5kZXIvbWl4aW4vUmVjdFRleHRcbiAqL1xuXG5cblxuICAgIHZhciB0ZXh0Q29udGFpbiA9IHJlcXVpcmUoJy4uLy4uL2NvbnRhaW4vdGV4dCcpO1xuICAgIHZhciBCb3VuZGluZ1JlY3QgPSByZXF1aXJlKCcuLi8uLi9jb3JlL0JvdW5kaW5nUmVjdCcpO1xuXG4gICAgdmFyIHRtcFJlY3QgPSBuZXcgQm91bmRpbmdSZWN0KCk7XG5cbiAgICB2YXIgUmVjdFRleHQgPSBmdW5jdGlvbiAoKSB7fTtcblxuICAgIGZ1bmN0aW9uIHBhcnNlUGVyY2VudCh2YWx1ZSwgbWF4VmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZS5sYXN0SW5kZXhPZignJScpID49IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VGbG9hdCh2YWx1ZSkgLyAxMDAgKiBtYXhWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwYXJzZUZsb2F0KHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgUmVjdFRleHQucHJvdG90eXBlID0ge1xuXG4gICAgICAgIGNvbnN0cnVjdG9yOiBSZWN0VGV4dCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogRHJhdyB0ZXh0IGluIGEgcmVjdCB3aXRoIHNwZWNpZmllZCBwb3NpdGlvbi5cbiAgICAgICAgICogQHBhcmFtICB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dH0gY3R4XG4gICAgICAgICAqIEBwYXJhbSAge09iamVjdH0gcmVjdCBEaXNwbGF5YWJsZSByZWN0XG4gICAgICAgICAqIEByZXR1cm4ge09iamVjdH0gdGV4dFJlY3QgQWx0ZXJuYXRpdmUgcHJlY2FsY3VsYXRlZCB0ZXh0IGJvdW5kaW5nIHJlY3RcbiAgICAgICAgICovXG4gICAgICAgIGRyYXdSZWN0VGV4dDogZnVuY3Rpb24gKGN0eCwgcmVjdCwgdGV4dFJlY3QpIHtcbiAgICAgICAgICAgIHZhciBzdHlsZSA9IHRoaXMuc3R5bGU7XG4gICAgICAgICAgICB2YXIgdGV4dCA9IHN0eWxlLnRleHQ7XG4gICAgICAgICAgICAvLyBDb252ZXJ0IHRvIHN0cmluZ1xuICAgICAgICAgICAgdGV4dCAhPSBudWxsICYmICh0ZXh0ICs9ICcnKTtcbiAgICAgICAgICAgIGlmICghdGV4dCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRklYTUVcbiAgICAgICAgICAgIGN0eC5zYXZlKCk7XG5cbiAgICAgICAgICAgIHZhciB4O1xuICAgICAgICAgICAgdmFyIHk7XG4gICAgICAgICAgICB2YXIgdGV4dFBvc2l0aW9uID0gc3R5bGUudGV4dFBvc2l0aW9uO1xuICAgICAgICAgICAgdmFyIGRpc3RhbmNlID0gc3R5bGUudGV4dERpc3RhbmNlO1xuICAgICAgICAgICAgdmFyIGFsaWduID0gc3R5bGUudGV4dEFsaWduO1xuICAgICAgICAgICAgdmFyIGZvbnQgPSBzdHlsZS50ZXh0Rm9udCB8fCBzdHlsZS5mb250O1xuICAgICAgICAgICAgdmFyIGJhc2VsaW5lID0gc3R5bGUudGV4dEJhc2VsaW5lO1xuICAgICAgICAgICAgdmFyIHZlcnRpY2FsQWxpZ24gPSBzdHlsZS50ZXh0VmVydGljYWxBbGlnbjtcblxuICAgICAgICAgICAgdGV4dFJlY3QgPSB0ZXh0UmVjdCB8fCB0ZXh0Q29udGFpbi5nZXRCb3VuZGluZ1JlY3QodGV4dCwgZm9udCwgYWxpZ24sIGJhc2VsaW5lKTtcblxuICAgICAgICAgICAgLy8gVHJhbnNmb3JtIHJlY3QgdG8gdmlldyBzcGFjZVxuICAgICAgICAgICAgdmFyIHRyYW5zZm9ybSA9IHRoaXMudHJhbnNmb3JtO1xuICAgICAgICAgICAgaWYgKCFzdHlsZS50ZXh0VHJhbnNmb3JtKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRyYW5zZm9ybSkge1xuICAgICAgICAgICAgICAgICAgICB0bXBSZWN0LmNvcHkocmVjdCk7XG4gICAgICAgICAgICAgICAgICAgIHRtcFJlY3QuYXBwbHlUcmFuc2Zvcm0odHJhbnNmb3JtKTtcbiAgICAgICAgICAgICAgICAgICAgcmVjdCA9IHRtcFJlY3Q7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRUcmFuc2Zvcm0oY3R4KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gVGV4dCBwb3NpdGlvbiByZXByZXNlbnRlZCBieSBjb29yZFxuICAgICAgICAgICAgaWYgKHRleHRQb3NpdGlvbiBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICAgICAgLy8gUGVyY2VudFxuICAgICAgICAgICAgICAgIHggPSByZWN0LnggKyBwYXJzZVBlcmNlbnQodGV4dFBvc2l0aW9uWzBdLCByZWN0LndpZHRoKTtcbiAgICAgICAgICAgICAgICB5ID0gcmVjdC55ICsgcGFyc2VQZXJjZW50KHRleHRQb3NpdGlvblsxXSwgcmVjdC5oZWlnaHQpO1xuICAgICAgICAgICAgICAgIGFsaWduID0gYWxpZ24gfHwgJ2xlZnQnO1xuICAgICAgICAgICAgICAgIGJhc2VsaW5lID0gYmFzZWxpbmUgfHwgJ3RvcCc7XG5cbiAgICAgICAgICAgICAgICBpZiAodmVydGljYWxBbGlnbikge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHZlcnRpY2FsQWxpZ24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ21pZGRsZSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeSAtPSB0ZXh0UmVjdC5oZWlnaHQgLyAyIC0gdGV4dFJlY3QubGluZUhlaWdodCAvIDI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdib3R0b20nOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkgLT0gdGV4dFJlY3QuaGVpZ2h0IC0gdGV4dFJlY3QubGluZUhlaWdodCAvIDI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkgKz0gdGV4dFJlY3QubGluZUhlaWdodCAvIDI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gRm9yY2UgYnNlbGluZSB0byBiZSBtaWRkbGVcbiAgICAgICAgICAgICAgICAgICAgYmFzZWxpbmUgPSAnbWlkZGxlJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzID0gdGV4dENvbnRhaW4uYWRqdXN0VGV4dFBvc2l0aW9uT25SZWN0KFxuICAgICAgICAgICAgICAgICAgICB0ZXh0UG9zaXRpb24sIHJlY3QsIHRleHRSZWN0LCBkaXN0YW5jZVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgeCA9IHJlcy54O1xuICAgICAgICAgICAgICAgIHkgPSByZXMueTtcbiAgICAgICAgICAgICAgICAvLyBEZWZhdWx0IGFsaWduIGFuZCBiYXNlbGluZSB3aGVuIGhhcyB0ZXh0UG9zaXRpb25cbiAgICAgICAgICAgICAgICBhbGlnbiA9IGFsaWduIHx8IHJlcy50ZXh0QWxpZ247XG4gICAgICAgICAgICAgICAgYmFzZWxpbmUgPSBiYXNlbGluZSB8fCByZXMudGV4dEJhc2VsaW5lO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBVc2UgY2FudmFzIGRlZmF1bHQgbGVmdCB0ZXh0QWxpZ24uIEdpdmluZyBpbnZhbGlkIHZhbHVlIHdpbGwgY2F1c2Ugc3RhdGUgbm90IGNoYW5nZVxuICAgICAgICAgICAgY3R4LnRleHRBbGlnbiA9IGFsaWduIHx8ICdsZWZ0JztcbiAgICAgICAgICAgIC8vIFVzZSBjYW52YXMgZGVmYXVsdCBhbHBoYWJldGljIGJhc2VsaW5lXG4gICAgICAgICAgICBjdHgudGV4dEJhc2VsaW5lID0gYmFzZWxpbmUgfHwgJ2FscGhhYmV0aWMnO1xuXG4gICAgICAgICAgICB2YXIgdGV4dEZpbGwgPSBzdHlsZS50ZXh0RmlsbDtcbiAgICAgICAgICAgIHZhciB0ZXh0U3Ryb2tlID0gc3R5bGUudGV4dFN0cm9rZTtcbiAgICAgICAgICAgIHRleHRGaWxsICYmIChjdHguZmlsbFN0eWxlID0gdGV4dEZpbGwpO1xuICAgICAgICAgICAgdGV4dFN0cm9rZSAmJiAoY3R4LnN0cm9rZVN0eWxlID0gdGV4dFN0cm9rZSk7XG5cbiAgICAgICAgICAgIC8vIFRPRE8gSW52YWxpZCBmb250XG4gICAgICAgICAgICBjdHguZm9udCA9IGZvbnQgfHwgJzEycHggc2Fucy1zZXJpZic7XG5cbiAgICAgICAgICAgIC8vIFRleHQgc2hhZG93XG4gICAgICAgICAgICAvLyBBbHdheXMgc2V0IHNoYWRvd0JsdXIgYW5kIHNoYWRvd09mZnNldCB0byBhdm9pZCBsZWFrIGZyb20gZGlzcGxheWFibGVcbiAgICAgICAgICAgIGN0eC5zaGFkb3dCbHVyID0gc3R5bGUudGV4dFNoYWRvd0JsdXI7XG4gICAgICAgICAgICBjdHguc2hhZG93Q29sb3IgPSBzdHlsZS50ZXh0U2hhZG93Q29sb3IgfHwgJ3RyYW5zcGFyZW50JztcbiAgICAgICAgICAgIGN0eC5zaGFkb3dPZmZzZXRYID0gc3R5bGUudGV4dFNoYWRvd09mZnNldFg7XG4gICAgICAgICAgICBjdHguc2hhZG93T2Zmc2V0WSA9IHN0eWxlLnRleHRTaGFkb3dPZmZzZXRZO1xuXG4gICAgICAgICAgICB2YXIgdGV4dExpbmVzID0gdGV4dC5zcGxpdCgnXFxuJyk7XG5cbiAgICAgICAgICAgIGlmIChzdHlsZS50ZXh0Um90YXRpb24pIHtcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm0gJiYgY3R4LnRyYW5zbGF0ZSh0cmFuc2Zvcm1bNF0sIHRyYW5zZm9ybVs1XSk7XG4gICAgICAgICAgICAgICAgY3R4LnJvdGF0ZShzdHlsZS50ZXh0Um90YXRpb24pO1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybSAmJiBjdHgudHJhbnNsYXRlKC10cmFuc2Zvcm1bNF0sIC10cmFuc2Zvcm1bNV0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRleHRMaW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHRleHRGaWxsICYmIGN0eC5maWxsVGV4dCh0ZXh0TGluZXNbaV0sIHgsIHkpO1xuICAgICAgICAgICAgICAgIHRleHRTdHJva2UgJiYgY3R4LnN0cm9rZVRleHQodGV4dExpbmVzW2ldLCB4LCB5KTtcbiAgICAgICAgICAgICAgICB5ICs9IHRleHRSZWN0LmxpbmVIZWlnaHQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBSZWN0VGV4dDtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvbWl4aW4vUmVjdFRleHQuanNcbiAqKiBtb2R1bGUgaWQgPSAyMlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXG5cbiAgICB2YXIgdGV4dFdpZHRoQ2FjaGUgPSB7fTtcbiAgICB2YXIgdGV4dFdpZHRoQ2FjaGVDb3VudGVyID0gMDtcbiAgICB2YXIgVEVYVF9DQUNIRV9NQVggPSA1MDAwO1xuXG4gICAgdmFyIHV0aWwgPSByZXF1aXJlKCcuLi9jb3JlL3V0aWwnKTtcbiAgICB2YXIgQm91bmRpbmdSZWN0ID0gcmVxdWlyZSgnLi4vY29yZS9Cb3VuZGluZ1JlY3QnKTtcbiAgICB2YXIgcmV0cmlldmUgPSB1dGlsLnJldHJpZXZlO1xuXG4gICAgZnVuY3Rpb24gZ2V0VGV4dFdpZHRoKHRleHQsIHRleHRGb250KSB7XG4gICAgICAgIHZhciBrZXkgPSB0ZXh0ICsgJzonICsgdGV4dEZvbnQ7XG4gICAgICAgIGlmICh0ZXh0V2lkdGhDYWNoZVtrZXldKSB7XG4gICAgICAgICAgICByZXR1cm4gdGV4dFdpZHRoQ2FjaGVba2V5XTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0ZXh0TGluZXMgPSAodGV4dCArICcnKS5zcGxpdCgnXFxuJyk7XG4gICAgICAgIHZhciB3aWR0aCA9IDA7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSB0ZXh0TGluZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAvLyBtZWFzdXJlVGV4dCDlj6/ku6Xooqvopobnm5bku6XlhbzlrrnkuI3mlK/mjIEgQ2FudmFzIOeahOeOr+Wig1xuICAgICAgICAgICAgd2lkdGggPSBNYXRoLm1heCh0ZXh0Q29udGFpbi5tZWFzdXJlVGV4dCh0ZXh0TGluZXNbaV0sIHRleHRGb250KS53aWR0aCwgd2lkdGgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRleHRXaWR0aENhY2hlQ291bnRlciA+IFRFWFRfQ0FDSEVfTUFYKSB7XG4gICAgICAgICAgICB0ZXh0V2lkdGhDYWNoZUNvdW50ZXIgPSAwO1xuICAgICAgICAgICAgdGV4dFdpZHRoQ2FjaGUgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICB0ZXh0V2lkdGhDYWNoZUNvdW50ZXIrKztcbiAgICAgICAgdGV4dFdpZHRoQ2FjaGVba2V5XSA9IHdpZHRoO1xuXG4gICAgICAgIHJldHVybiB3aWR0aDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRUZXh0UmVjdCh0ZXh0LCB0ZXh0Rm9udCwgdGV4dEFsaWduLCB0ZXh0QmFzZWxpbmUpIHtcbiAgICAgICAgdmFyIHRleHRMaW5lTGVuID0gKCh0ZXh0IHx8ICcnKSArICcnKS5zcGxpdCgnXFxuJykubGVuZ3RoO1xuXG4gICAgICAgIHZhciB3aWR0aCA9IGdldFRleHRXaWR0aCh0ZXh0LCB0ZXh0Rm9udCk7XG4gICAgICAgIC8vIEZJWE1FIOmrmOW6puiuoeeul+avlOi+g+eyl+aatFxuICAgICAgICB2YXIgbGluZUhlaWdodCA9IGdldFRleHRXaWR0aCgn5Zu9JywgdGV4dEZvbnQpO1xuICAgICAgICB2YXIgaGVpZ2h0ID0gdGV4dExpbmVMZW4gKiBsaW5lSGVpZ2h0O1xuXG4gICAgICAgIHZhciByZWN0ID0gbmV3IEJvdW5kaW5nUmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgLy8gVGV4dCBoYXMgYSBzcGVjaWFsIGxpbmUgaGVpZ2h0IHByb3BlcnR5XG4gICAgICAgIHJlY3QubGluZUhlaWdodCA9IGxpbmVIZWlnaHQ7XG5cbiAgICAgICAgc3dpdGNoICh0ZXh0QmFzZWxpbmUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICAgICAgICBjYXNlICdhbHBoYWJldGljJzpcbiAgICAgICAgICAgICAgICByZWN0LnkgLT0gbGluZUhlaWdodDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ21pZGRsZSc6XG4gICAgICAgICAgICAgICAgcmVjdC55IC09IGxpbmVIZWlnaHQgLyAyO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgLy8gY2FzZSAnaGFuZ2luZyc6XG4gICAgICAgICAgICAvLyBjYXNlICd0b3AnOlxuICAgICAgICB9XG5cbiAgICAgICAgLy8gRklYTUUgUmlnaHQgdG8gbGVmdCBsYW5ndWFnZVxuICAgICAgICBzd2l0Y2ggKHRleHRBbGlnbikge1xuICAgICAgICAgICAgY2FzZSAnZW5kJzpcbiAgICAgICAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgICAgICAgICByZWN0LnggLT0gcmVjdC53aWR0aDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2NlbnRlcic6XG4gICAgICAgICAgICAgICAgcmVjdC54IC09IHJlY3Qud2lkdGggLyAyO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgLy8gY2FzZSAnc3RhcnQnOlxuICAgICAgICAgICAgLy8gY2FzZSAnbGVmdCc6XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVjdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGp1c3RUZXh0UG9zaXRpb25PblJlY3QodGV4dFBvc2l0aW9uLCByZWN0LCB0ZXh0UmVjdCwgZGlzdGFuY2UpIHtcblxuICAgICAgICB2YXIgeCA9IHJlY3QueDtcbiAgICAgICAgdmFyIHkgPSByZWN0Lnk7XG5cbiAgICAgICAgdmFyIGhlaWdodCA9IHJlY3QuaGVpZ2h0O1xuICAgICAgICB2YXIgd2lkdGggPSByZWN0LndpZHRoO1xuXG4gICAgICAgIHZhciB0ZXh0SGVpZ2h0ID0gdGV4dFJlY3QuaGVpZ2h0O1xuXG4gICAgICAgIHZhciBoYWxmSGVpZ2h0ID0gaGVpZ2h0IC8gMiAtIHRleHRIZWlnaHQgLyAyO1xuXG4gICAgICAgIHZhciB0ZXh0QWxpZ24gPSAnbGVmdCc7XG5cbiAgICAgICAgc3dpdGNoICh0ZXh0UG9zaXRpb24pIHtcbiAgICAgICAgICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgICAgICAgICAgIHggLT0gZGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgeSArPSBoYWxmSGVpZ2h0O1xuICAgICAgICAgICAgICAgIHRleHRBbGlnbiA9ICdyaWdodCc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgICAgICAgICAgeCArPSBkaXN0YW5jZSArIHdpZHRoO1xuICAgICAgICAgICAgICAgIHkgKz0gaGFsZkhlaWdodDtcbiAgICAgICAgICAgICAgICB0ZXh0QWxpZ24gPSAnbGVmdCc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICd0b3AnOlxuICAgICAgICAgICAgICAgIHggKz0gd2lkdGggLyAyO1xuICAgICAgICAgICAgICAgIHkgLT0gZGlzdGFuY2UgKyB0ZXh0SGVpZ2h0O1xuICAgICAgICAgICAgICAgIHRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnYm90dG9tJzpcbiAgICAgICAgICAgICAgICB4ICs9IHdpZHRoIC8gMjtcbiAgICAgICAgICAgICAgICB5ICs9IGhlaWdodCArIGRpc3RhbmNlO1xuICAgICAgICAgICAgICAgIHRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnaW5zaWRlJzpcbiAgICAgICAgICAgICAgICB4ICs9IHdpZHRoIC8gMjtcbiAgICAgICAgICAgICAgICB5ICs9IGhhbGZIZWlnaHQ7XG4gICAgICAgICAgICAgICAgdGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdpbnNpZGVMZWZ0JzpcbiAgICAgICAgICAgICAgICB4ICs9IGRpc3RhbmNlO1xuICAgICAgICAgICAgICAgIHkgKz0gaGFsZkhlaWdodDtcbiAgICAgICAgICAgICAgICB0ZXh0QWxpZ24gPSAnbGVmdCc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdpbnNpZGVSaWdodCc6XG4gICAgICAgICAgICAgICAgeCArPSB3aWR0aCAtIGRpc3RhbmNlO1xuICAgICAgICAgICAgICAgIHkgKz0gaGFsZkhlaWdodDtcbiAgICAgICAgICAgICAgICB0ZXh0QWxpZ24gPSAncmlnaHQnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnaW5zaWRlVG9wJzpcbiAgICAgICAgICAgICAgICB4ICs9IHdpZHRoIC8gMjtcbiAgICAgICAgICAgICAgICB5ICs9IGRpc3RhbmNlO1xuICAgICAgICAgICAgICAgIHRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnaW5zaWRlQm90dG9tJzpcbiAgICAgICAgICAgICAgICB4ICs9IHdpZHRoIC8gMjtcbiAgICAgICAgICAgICAgICB5ICs9IGhlaWdodCAtIHRleHRIZWlnaHQgLSBkaXN0YW5jZTtcbiAgICAgICAgICAgICAgICB0ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2luc2lkZVRvcExlZnQnOlxuICAgICAgICAgICAgICAgIHggKz0gZGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgeSArPSBkaXN0YW5jZTtcbiAgICAgICAgICAgICAgICB0ZXh0QWxpZ24gPSAnbGVmdCc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdpbnNpZGVUb3BSaWdodCc6XG4gICAgICAgICAgICAgICAgeCArPSB3aWR0aCAtIGRpc3RhbmNlO1xuICAgICAgICAgICAgICAgIHkgKz0gZGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgdGV4dEFsaWduID0gJ3JpZ2h0JztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2luc2lkZUJvdHRvbUxlZnQnOlxuICAgICAgICAgICAgICAgIHggKz0gZGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgeSArPSBoZWlnaHQgLSB0ZXh0SGVpZ2h0IC0gZGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdpbnNpZGVCb3R0b21SaWdodCc6XG4gICAgICAgICAgICAgICAgeCArPSB3aWR0aCAtIGRpc3RhbmNlO1xuICAgICAgICAgICAgICAgIHkgKz0gaGVpZ2h0IC0gdGV4dEhlaWdodCAtIGRpc3RhbmNlO1xuICAgICAgICAgICAgICAgIHRleHRBbGlnbiA9ICdyaWdodCc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeDogeCxcbiAgICAgICAgICAgIHk6IHksXG4gICAgICAgICAgICB0ZXh0QWxpZ246IHRleHRBbGlnbixcbiAgICAgICAgICAgIHRleHRCYXNlbGluZTogJ3RvcCdcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTaG93IGVsbGlwc2lzIGlmIG92ZXJmbG93LlxuICAgICAqXG4gICAgICogQHBhcmFtICB7c3RyaW5nfSB0ZXh0XG4gICAgICogQHBhcmFtICB7c3RyaW5nfSBjb250YWluZXJXaWR0aFxuICAgICAqIEBwYXJhbSAge3N0cmluZ30gdGV4dEZvbnRcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IFtlbGxpcHNpcz0nLi4uJ11cbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXVxuICAgICAqIEBwYXJhbSAge251bWJlcn0gW29wdGlvbnMubWF4SXRlcmF0aW9ucz0zXVxuICAgICAqIEBwYXJhbSAge251bWJlcn0gW29wdGlvbnMubWluQ2hhcj0wXSBJZiB0cnVuY2F0ZSByZXN1bHQgYXJlIGxlc3NcbiAgICAgKiAgICAgICAgICAgICAgICAgIHRoZW4gbWluQ2hhciwgZWxsaXBzaXMgd2lsbCBub3Qgc2hvdywgd2hpY2ggaXNcbiAgICAgKiAgICAgICAgICAgICAgICAgIGJldHRlciBmb3IgdXNlciBoaW50IGluIHNvbWUgY2FzZXMuXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBbb3B0aW9ucy5wbGFjZWhvbGRlcj0nJ10gV2hlbiBhbGwgdHJ1bmNhdGVkLCB1c2UgdGhlIHBsYWNlaG9sZGVyLlxuICAgICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0cnVuY2F0ZVRleHQodGV4dCwgY29udGFpbmVyV2lkdGgsIHRleHRGb250LCBlbGxpcHNpcywgb3B0aW9ucykge1xuICAgICAgICBpZiAoIWNvbnRhaW5lcldpZHRoKSB7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cblxuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgICAgICBlbGxpcHNpcyA9IHJldHJpZXZlKGVsbGlwc2lzLCAnLi4uJyk7XG4gICAgICAgIHZhciBtYXhJdGVyYXRpb25zID0gcmV0cmlldmUob3B0aW9ucy5tYXhJdGVyYXRpb25zLCAyKTtcbiAgICAgICAgdmFyIG1pbkNoYXIgPSByZXRyaWV2ZShvcHRpb25zLm1pbkNoYXIsIDApO1xuICAgICAgICAvLyBGSVhNRVxuICAgICAgICAvLyBPdGhlciBsYW5ndWFnZXM/XG4gICAgICAgIHZhciBjbkNoYXJXaWR0aCA9IGdldFRleHRXaWR0aCgn5Zu9JywgdGV4dEZvbnQpO1xuICAgICAgICAvLyBGSVhNRVxuICAgICAgICAvLyBDb25zaWRlciBwcm9wb3J0aW9uYWwgZm9udD9cbiAgICAgICAgdmFyIGFzY0NoYXJXaWR0aCA9IGdldFRleHRXaWR0aCgnYScsIHRleHRGb250KTtcbiAgICAgICAgdmFyIHBsYWNlaG9sZGVyID0gcmV0cmlldmUob3B0aW9ucy5wbGFjZWhvbGRlciwgJycpO1xuXG4gICAgICAgIC8vIEV4YW1wbGUgMTogbWluQ2hhcjogMywgdGV4dDogJ2FzZGZ6eGN2JywgdHJ1bmNhdGUgcmVzdWx0OiAnYXNkZicsIGJ1dCBub3Q6ICdhLi4uJy5cbiAgICAgICAgLy8gRXhhbXBsZSAyOiBtaW5DaGFyOiAzLCB0ZXh0OiAn57u05bqmJywgdHJ1bmNhdGUgcmVzdWx0OiAn57u0JywgYnV0IG5vdDogJy4uLicuXG4gICAgICAgIHZhciBjb250ZW50V2lkdGggPSBjb250YWluZXJXaWR0aCA9IE1hdGgubWF4KDAsIGNvbnRhaW5lcldpZHRoIC0gMSk7IC8vIFJlc2VydmUgc29tZSBnYXAuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWluQ2hhciAmJiBjb250ZW50V2lkdGggPj0gYXNjQ2hhcldpZHRoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnRlbnRXaWR0aCAtPSBhc2NDaGFyV2lkdGg7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZWxsaXBzaXNXaWR0aCA9IGdldFRleHRXaWR0aChlbGxpcHNpcyk7XG4gICAgICAgIGlmIChlbGxpcHNpc1dpZHRoID4gY29udGVudFdpZHRoKSB7XG4gICAgICAgICAgICBlbGxpcHNpcyA9ICcnO1xuICAgICAgICAgICAgZWxsaXBzaXNXaWR0aCA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBjb250ZW50V2lkdGggPSBjb250YWluZXJXaWR0aCAtIGVsbGlwc2lzV2lkdGg7XG5cbiAgICAgICAgdmFyIHRleHRMaW5lcyA9ICh0ZXh0ICsgJycpLnNwbGl0KCdcXG4nKTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGV4dExpbmVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgdGV4dExpbmUgPSB0ZXh0TGluZXNbaV07XG4gICAgICAgICAgICB2YXIgbGluZVdpZHRoID0gZ2V0VGV4dFdpZHRoKHRleHRMaW5lLCB0ZXh0Rm9udCk7XG5cbiAgICAgICAgICAgIGlmIChsaW5lV2lkdGggPD0gY29udGFpbmVyV2lkdGgpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7OyBqKyspIHtcbiAgICAgICAgICAgICAgICBpZiAobGluZVdpZHRoIDw9IGNvbnRlbnRXaWR0aCB8fCBqID49IG1heEl0ZXJhdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dExpbmUgKz0gZWxsaXBzaXM7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBzdWJMZW5ndGggPSBqID09PSAwXG4gICAgICAgICAgICAgICAgICAgID8gZXN0aW1hdGVMZW5ndGgodGV4dExpbmUsIGNvbnRlbnRXaWR0aCwgYXNjQ2hhcldpZHRoLCBjbkNoYXJXaWR0aClcbiAgICAgICAgICAgICAgICAgICAgOiBsaW5lV2lkdGggPiAwXG4gICAgICAgICAgICAgICAgICAgID8gTWF0aC5mbG9vcih0ZXh0TGluZS5sZW5ndGggKiBjb250ZW50V2lkdGggLyBsaW5lV2lkdGgpXG4gICAgICAgICAgICAgICAgICAgIDogMDtcblxuICAgICAgICAgICAgICAgIHRleHRMaW5lID0gdGV4dExpbmUuc3Vic3RyKDAsIHN1Ykxlbmd0aCk7XG4gICAgICAgICAgICAgICAgbGluZVdpZHRoID0gZ2V0VGV4dFdpZHRoKHRleHRMaW5lLCB0ZXh0Rm9udCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0ZXh0TGluZSA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICB0ZXh0TGluZSA9IHBsYWNlaG9sZGVyO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0ZXh0TGluZXNbaV0gPSB0ZXh0TGluZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0ZXh0TGluZXMuam9pbignXFxuJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXN0aW1hdGVMZW5ndGgodGV4dCwgY29udGVudFdpZHRoLCBhc2NDaGFyV2lkdGgsIGNuQ2hhcldpZHRoKSB7XG4gICAgICAgIHZhciB3aWR0aCA9IDA7XG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgZm9yICh2YXIgbGVuID0gdGV4dC5sZW5ndGg7IGkgPCBsZW4gJiYgd2lkdGggPCBjb250ZW50V2lkdGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGNoYXJDb2RlID0gdGV4dC5jaGFyQ29kZUF0KGkpO1xuICAgICAgICAgICAgd2lkdGggKz0gKDAgPD0gY2hhckNvZGUgJiYgY2hhckNvZGUgPD0gMTI3KSA/IGFzY0NoYXJXaWR0aCA6IGNuQ2hhcldpZHRoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpO1xuICAgIH1cblxuICAgIHZhciB0ZXh0Q29udGFpbiA9IHtcblxuICAgICAgICBnZXRXaWR0aDogZ2V0VGV4dFdpZHRoLFxuXG4gICAgICAgIGdldEJvdW5kaW5nUmVjdDogZ2V0VGV4dFJlY3QsXG5cbiAgICAgICAgYWRqdXN0VGV4dFBvc2l0aW9uT25SZWN0OiBhZGp1c3RUZXh0UG9zaXRpb25PblJlY3QsXG5cbiAgICAgICAgdHJ1bmNhdGVUZXh0OiB0cnVuY2F0ZVRleHQsXG5cbiAgICAgICAgbWVhc3VyZVRleHQ6IGZ1bmN0aW9uICh0ZXh0LCB0ZXh0Rm9udCkge1xuICAgICAgICAgICAgdmFyIGN0eCA9IHV0aWwuZ2V0Q29udGV4dCgpO1xuICAgICAgICAgICAgY3R4LmZvbnQgPSB0ZXh0Rm9udCB8fCAnMTJweCBzYW5zLXNlcmlmJztcbiAgICAgICAgICAgIHJldHVybiBjdHgubWVhc3VyZVRleHQodGV4dCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB0ZXh0Q29udGFpbjtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3pyZW5kZXIvbGliL2NvbnRhaW4vdGV4dC5qc1xuICoqIG1vZHVsZSBpZCA9IDIzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG4vKipcbiAqIEBtb2R1bGUgZWNoYXJ0cy9jb3JlL0JvdW5kaW5nUmVjdFxuICovXG5cblxuICAgIHZhciB2ZWMyID0gcmVxdWlyZSgnLi92ZWN0b3InKTtcbiAgICB2YXIgbWF0cml4ID0gcmVxdWlyZSgnLi9tYXRyaXgnKTtcblxuICAgIHZhciB2MkFwcGx5VHJhbnNmb3JtID0gdmVjMi5hcHBseVRyYW5zZm9ybTtcbiAgICB2YXIgbWF0aE1pbiA9IE1hdGgubWluO1xuICAgIHZhciBtYXRoQWJzID0gTWF0aC5hYnM7XG4gICAgdmFyIG1hdGhNYXggPSBNYXRoLm1heDtcbiAgICAvKipcbiAgICAgKiBAYWxpYXMgbW9kdWxlOmVjaGFydHMvY29yZS9Cb3VuZGluZ1JlY3RcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBCb3VuZGluZ1JlY3QoeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMueCA9IHg7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy55ID0geTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgfVxuXG4gICAgQm91bmRpbmdSZWN0LnByb3RvdHlwZSA9IHtcblxuICAgICAgICBjb25zdHJ1Y3RvcjogQm91bmRpbmdSZWN0LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL2NvcmUvQm91bmRpbmdSZWN0fSBvdGhlclxuICAgICAgICAgKi9cbiAgICAgICAgdW5pb246IGZ1bmN0aW9uIChvdGhlcikge1xuICAgICAgICAgICAgdmFyIHggPSBtYXRoTWluKG90aGVyLngsIHRoaXMueCk7XG4gICAgICAgICAgICB2YXIgeSA9IG1hdGhNaW4ob3RoZXIueSwgdGhpcy55KTtcblxuICAgICAgICAgICAgdGhpcy53aWR0aCA9IG1hdGhNYXgoXG4gICAgICAgICAgICAgICAgICAgIG90aGVyLnggKyBvdGhlci53aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy54ICsgdGhpcy53aWR0aFxuICAgICAgICAgICAgICAgICkgLSB4O1xuICAgICAgICAgICAgdGhpcy5oZWlnaHQgPSBtYXRoTWF4KFxuICAgICAgICAgICAgICAgICAgICBvdGhlci55ICsgb3RoZXIuaGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnkgKyB0aGlzLmhlaWdodFxuICAgICAgICAgICAgICAgICkgLSB5O1xuICAgICAgICAgICAgdGhpcy54ID0geDtcbiAgICAgICAgICAgIHRoaXMueSA9IHk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IG1cbiAgICAgICAgICogQG1ldGhvZHNcbiAgICAgICAgICovXG4gICAgICAgIGFwcGx5VHJhbnNmb3JtOiAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG1pbiA9IFtdO1xuICAgICAgICAgICAgdmFyIG1heCA9IFtdO1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChtKSB7XG4gICAgICAgICAgICAgICAgLy8gSW4gY2FzZSB1c2FnZSBsaWtlIHRoaXNcbiAgICAgICAgICAgICAgICAvLyBlbC5nZXRCb3VuZGluZ1JlY3QoKS5hcHBseVRyYW5zZm9ybShlbC50cmFuc2Zvcm0pXG4gICAgICAgICAgICAgICAgLy8gQW5kIGVsZW1lbnQgaGFzIG5vIHRyYW5zZm9ybVxuICAgICAgICAgICAgICAgIGlmICghbSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG1pblswXSA9IHRoaXMueDtcbiAgICAgICAgICAgICAgICBtaW5bMV0gPSB0aGlzLnk7XG4gICAgICAgICAgICAgICAgbWF4WzBdID0gdGhpcy54ICsgdGhpcy53aWR0aDtcbiAgICAgICAgICAgICAgICBtYXhbMV0gPSB0aGlzLnkgKyB0aGlzLmhlaWdodDtcblxuICAgICAgICAgICAgICAgIHYyQXBwbHlUcmFuc2Zvcm0obWluLCBtaW4sIG0pO1xuICAgICAgICAgICAgICAgIHYyQXBwbHlUcmFuc2Zvcm0obWF4LCBtYXgsIG0pO1xuXG4gICAgICAgICAgICAgICAgdGhpcy54ID0gbWF0aE1pbihtaW5bMF0sIG1heFswXSk7XG4gICAgICAgICAgICAgICAgdGhpcy55ID0gbWF0aE1pbihtaW5bMV0sIG1heFsxXSk7XG4gICAgICAgICAgICAgICAgdGhpcy53aWR0aCA9IG1hdGhBYnMobWF4WzBdIC0gbWluWzBdKTtcbiAgICAgICAgICAgICAgICB0aGlzLmhlaWdodCA9IG1hdGhBYnMobWF4WzFdIC0gbWluWzFdKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pKCksXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhbGN1bGF0ZSBtYXRyaXggb2YgdHJhbnNmb3JtaW5nIGZyb20gc2VsZiB0byB0YXJnZXQgcmVjdFxuICAgICAgICAgKiBAcGFyYW0gIHttb2R1bGU6enJlbmRlci9jb3JlL0JvdW5kaW5nUmVjdH0gYlxuICAgICAgICAgKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn1cbiAgICAgICAgICovXG4gICAgICAgIGNhbGN1bGF0ZVRyYW5zZm9ybTogZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgICAgIHZhciBhID0gdGhpcztcbiAgICAgICAgICAgIHZhciBzeCA9IGIud2lkdGggLyBhLndpZHRoO1xuICAgICAgICAgICAgdmFyIHN5ID0gYi5oZWlnaHQgLyBhLmhlaWdodDtcblxuICAgICAgICAgICAgdmFyIG0gPSBtYXRyaXguY3JlYXRlKCk7XG5cbiAgICAgICAgICAgIC8vIOefqemYteWPs+S5mFxuICAgICAgICAgICAgbWF0cml4LnRyYW5zbGF0ZShtLCBtLCBbLWEueCwgLWEueV0pO1xuICAgICAgICAgICAgbWF0cml4LnNjYWxlKG0sIG0sIFtzeCwgc3ldKTtcbiAgICAgICAgICAgIG1hdHJpeC50cmFuc2xhdGUobSwgbSwgW2IueCwgYi55XSk7XG5cbiAgICAgICAgICAgIHJldHVybiBtO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0geyhtb2R1bGU6ZWNoYXJ0cy9jb3JlL0JvdW5kaW5nUmVjdHxPYmplY3QpfSBiXG4gICAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICBpbnRlcnNlY3Q6IGZ1bmN0aW9uIChiKSB7XG4gICAgICAgICAgICB2YXIgYSA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgYXgwID0gYS54O1xuICAgICAgICAgICAgdmFyIGF4MSA9IGEueCArIGEud2lkdGg7XG4gICAgICAgICAgICB2YXIgYXkwID0gYS55O1xuICAgICAgICAgICAgdmFyIGF5MSA9IGEueSArIGEuaGVpZ2h0O1xuXG4gICAgICAgICAgICB2YXIgYngwID0gYi54O1xuICAgICAgICAgICAgdmFyIGJ4MSA9IGIueCArIGIud2lkdGg7XG4gICAgICAgICAgICB2YXIgYnkwID0gYi55O1xuICAgICAgICAgICAgdmFyIGJ5MSA9IGIueSArIGIuaGVpZ2h0O1xuXG4gICAgICAgICAgICByZXR1cm4gISAoYXgxIDwgYngwIHx8IGJ4MSA8IGF4MCB8fCBheTEgPCBieTAgfHwgYnkxIDwgYXkwKTtcbiAgICAgICAgfSxcblxuICAgICAgICBjb250YWluOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICAgICAgdmFyIHJlY3QgPSB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIHggPj0gcmVjdC54XG4gICAgICAgICAgICAgICAgJiYgeCA8PSAocmVjdC54ICsgcmVjdC53aWR0aClcbiAgICAgICAgICAgICAgICAmJiB5ID49IHJlY3QueVxuICAgICAgICAgICAgICAgICYmIHkgPD0gKHJlY3QueSArIHJlY3QuaGVpZ2h0KTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7bW9kdWxlOmVjaGFydHMvY29yZS9Cb3VuZGluZ1JlY3R9XG4gICAgICAgICAqL1xuICAgICAgICBjbG9uZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBCb3VuZGluZ1JlY3QodGhpcy54LCB0aGlzLnksIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29weSBmcm9tIGFub3RoZXIgcmVjdFxuICAgICAgICAgKi9cbiAgICAgICAgY29weTogZnVuY3Rpb24gKG90aGVyKSB7XG4gICAgICAgICAgICB0aGlzLnggPSBvdGhlci54O1xuICAgICAgICAgICAgdGhpcy55ID0gb3RoZXIueTtcbiAgICAgICAgICAgIHRoaXMud2lkdGggPSBvdGhlci53aWR0aDtcbiAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gb3RoZXIuaGVpZ2h0O1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gQm91bmRpbmdSZWN0O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34venJlbmRlci9saWIvY29yZS9Cb3VuZGluZ1JlY3QuanNcbiAqKiBtb2R1bGUgaWQgPSAyNFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuLyoqXG4gKiBQYXRoIOS7o+eQhu+8jOWPr+S7peWcqGBidWlsZFBhdGhg5Lit55So5LqO5pu/5LujYGN0eGAsIOS8muS/neWtmOavj+S4qnBhdGjmk43kvZznmoTlkb3ku6TliLBwYXRoQ29tbWFuZHPlsZ7mgKfkuK1cbiAqIOWPr+S7peeUqOS6jiBpc0luc2lkZVBhdGgg5Yik5pat5Lul5Y+K6I635Y+WYm91bmRpbmdSZWN0XG4gKlxuICogQG1vZHVsZSB6cmVuZGVyL2NvcmUvUGF0aFByb3h5XG4gKiBAYXV0aG9yIFlpIFNoZW4gKGh0dHA6Ly93d3cuZ2l0aHViLmNvbS9waXNzYW5nKVxuICovXG5cbiAvLyBUT0RPIGdldFRvdGFsTGVuZ3RoLCBnZXRQb2ludEF0TGVuZ3RoXG5cblxuICAgIHZhciBjdXJ2ZSA9IHJlcXVpcmUoJy4vY3VydmUnKTtcbiAgICB2YXIgdmVjMiA9IHJlcXVpcmUoJy4vdmVjdG9yJyk7XG4gICAgdmFyIGJib3ggPSByZXF1aXJlKCcuL2Jib3gnKTtcbiAgICB2YXIgQm91bmRpbmdSZWN0ID0gcmVxdWlyZSgnLi9Cb3VuZGluZ1JlY3QnKTtcbiAgICB2YXIgZHByID0gcmVxdWlyZSgnLi4vY29uZmlnJykuZGV2aWNlUGl4ZWxSYXRpbztcblxuICAgIHZhciBDTUQgPSB7XG4gICAgICAgIE06IDEsXG4gICAgICAgIEw6IDIsXG4gICAgICAgIEM6IDMsXG4gICAgICAgIFE6IDQsXG4gICAgICAgIEE6IDUsXG4gICAgICAgIFo6IDYsXG4gICAgICAgIC8vIFJlY3RcbiAgICAgICAgUjogN1xuICAgIH07XG5cbiAgICB2YXIgbWluID0gW107XG4gICAgdmFyIG1heCA9IFtdO1xuICAgIHZhciBtaW4yID0gW107XG4gICAgdmFyIG1heDIgPSBbXTtcbiAgICB2YXIgbWF0aE1pbiA9IE1hdGgubWluO1xuICAgIHZhciBtYXRoTWF4ID0gTWF0aC5tYXg7XG4gICAgdmFyIG1hdGhDb3MgPSBNYXRoLmNvcztcbiAgICB2YXIgbWF0aFNpbiA9IE1hdGguc2luO1xuICAgIHZhciBtYXRoU3FydCA9IE1hdGguc3FydDtcbiAgICB2YXIgbWF0aEFicyA9IE1hdGguYWJzO1xuXG4gICAgdmFyIGhhc1R5cGVkQXJyYXkgPSB0eXBlb2YgRmxvYXQzMkFycmF5ICE9ICd1bmRlZmluZWQnO1xuXG4gICAgLyoqXG4gICAgICogQGFsaWFzIG1vZHVsZTp6cmVuZGVyL2NvcmUvUGF0aFByb3h5XG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICovXG4gICAgdmFyIFBhdGhQcm94eSA9IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogUGF0aCBkYXRhLiBTdG9yZWQgYXMgZmxhdCBhcnJheVxuICAgICAgICAgKiBAdHlwZSB7QXJyYXkuPE9iamVjdD59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRhdGEgPSBbXTtcblxuICAgICAgICB0aGlzLl9sZW4gPSAwO1xuXG4gICAgICAgIHRoaXMuX2N0eCA9IG51bGw7XG5cbiAgICAgICAgdGhpcy5feGkgPSAwO1xuICAgICAgICB0aGlzLl95aSA9IDA7XG5cbiAgICAgICAgdGhpcy5feDAgPSAwO1xuICAgICAgICB0aGlzLl95MCA9IDA7XG5cbiAgICAgICAgLy8gVW5pdCB4LCBVbml0IHkuIFByb3ZpZGUgZm9yIGF2b2lkaW5nIGRyYXdpbmcgdGhhdCB0b28gc2hvcnQgbGluZSBzZWdtZW50XG4gICAgICAgIHRoaXMuX3V4ID0gMDtcbiAgICAgICAgdGhpcy5fdXkgPSAwO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiDlv6vpgJ/orqHnrpdQYXRo5YyF5Zu055uS77yI5bm25LiN5piv5pyA5bCP5YyF5Zu055uS77yJXG4gICAgICogQHJldHVybiB7T2JqZWN0fVxuICAgICAqL1xuICAgIFBhdGhQcm94eS5wcm90b3R5cGUgPSB7XG5cbiAgICAgICAgY29uc3RydWN0b3I6IFBhdGhQcm94eSxcblxuICAgICAgICBfbGluZURhc2g6IG51bGwsXG5cbiAgICAgICAgX2Rhc2hPZmZzZXQ6IDAsXG5cbiAgICAgICAgX2Rhc2hJZHg6IDAsXG5cbiAgICAgICAgX2Rhc2hTdW06IDAsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZWFkT25seVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0U2NhbGU6IGZ1bmN0aW9uIChzeCwgc3kpIHtcbiAgICAgICAgICAgIHRoaXMuX3V4ID0gbWF0aEFicygxIC8gZHByIC8gc3gpIHx8IDA7XG4gICAgICAgICAgICB0aGlzLl91eSA9IG1hdGhBYnMoMSAvIGRwciAvIHN5KSB8fCAwO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldENvbnRleHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jdHg7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSAge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICAgICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2NvcmUvUGF0aFByb3h5fVxuICAgICAgICAgKi9cbiAgICAgICAgYmVnaW5QYXRoOiBmdW5jdGlvbiAoY3R4KSB7XG5cbiAgICAgICAgICAgIHRoaXMuX2N0eCA9IGN0eDtcblxuICAgICAgICAgICAgY3R4ICYmIGN0eC5iZWdpblBhdGgoKTtcblxuICAgICAgICAgICAgY3R4ICYmICh0aGlzLmRwciA9IGN0eC5kcHIpO1xuXG4gICAgICAgICAgICAvLyBSZXNldFxuICAgICAgICAgICAgdGhpcy5fbGVuID0gMDtcblxuICAgICAgICAgICAgaWYgKHRoaXMuX2xpbmVEYXNoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbGluZURhc2ggPSBudWxsO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5fZGFzaE9mZnNldCA9IDA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHhcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSB5XG4gICAgICAgICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2NvcmUvUGF0aFByb3h5fVxuICAgICAgICAgKi9cbiAgICAgICAgbW92ZVRvOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICAgICAgdGhpcy5hZGREYXRhKENNRC5NLCB4LCB5KTtcbiAgICAgICAgICAgIHRoaXMuX2N0eCAmJiB0aGlzLl9jdHgubW92ZVRvKHgsIHkpO1xuXG4gICAgICAgICAgICAvLyB4MCwgeTAsIHhpLCB5aSDmmK/orrDlvZXlnKggX2Rhc2hlZFhYWFhUbyDmlrnms5XkuK3kvb/nlKhcbiAgICAgICAgICAgIC8vIHhpLCB5aSDorrDlvZXlvZPliY3ngrksIHgwLCB5MCDlnKggY2xvc2VQYXRoIOeahOaXtuWAmeWbnuWIsOi1t+Wni+eCueOAglxuICAgICAgICAgICAgLy8g5pyJ5Y+v6IO95ZyoIGJlZ2luUGF0aCDkuYvlkI7nm7TmjqXosIPnlKggbGluZVRv77yM6L+Z5pe25YCZIHgwLCB5MCDpnIDopoFcbiAgICAgICAgICAgIC8vIOWcqCBsaW5lVG8g5pa55rOV5Lit6K6w5b2V77yM6L+Z6YeM5YWI5LiN6ICD6JmR6L+Z56eN5oOF5Ya177yMZGFzaGVkIGxpbmUg5Lmf5Y+q5ZyoIElFMTAtIOS4reS4jeaUr+aMgVxuICAgICAgICAgICAgdGhpcy5feDAgPSB4O1xuICAgICAgICAgICAgdGhpcy5feTAgPSB5O1xuXG4gICAgICAgICAgICB0aGlzLl94aSA9IHg7XG4gICAgICAgICAgICB0aGlzLl95aSA9IHk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHhcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSB5XG4gICAgICAgICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2NvcmUvUGF0aFByb3h5fVxuICAgICAgICAgKi9cbiAgICAgICAgbGluZVRvOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICAgICAgdmFyIGV4Y2VlZFVuaXQgPSBtYXRoQWJzKHggLSB0aGlzLl94aSkgPiB0aGlzLl91eFxuICAgICAgICAgICAgICAgIHx8IG1hdGhBYnMoeSAtIHRoaXMuX3lpKSA+IHRoaXMuX3V5XG4gICAgICAgICAgICAgICAgLy8gRm9yY2UgZHJhdyB0aGUgZmlyc3Qgc2VnbWVudFxuICAgICAgICAgICAgICAgIHx8IHRoaXMuX2xlbiA8IDU7XG5cbiAgICAgICAgICAgIHRoaXMuYWRkRGF0YShDTUQuTCwgeCwgeSk7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl9jdHggJiYgZXhjZWVkVW5pdCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX25lZWRzRGFzaCgpID8gdGhpcy5fZGFzaGVkTGluZVRvKHgsIHkpXG4gICAgICAgICAgICAgICAgICAgIDogdGhpcy5fY3R4LmxpbmVUbyh4LCB5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChleGNlZWRVbml0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5feGkgPSB4O1xuICAgICAgICAgICAgICAgIHRoaXMuX3lpID0geTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0geDFcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSB5MVxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHgyXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0geTJcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSB4M1xuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHkzXG4gICAgICAgICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2NvcmUvUGF0aFByb3h5fVxuICAgICAgICAgKi9cbiAgICAgICAgYmV6aWVyQ3VydmVUbzogZnVuY3Rpb24gKHgxLCB5MSwgeDIsIHkyLCB4MywgeTMpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkRGF0YShDTUQuQywgeDEsIHkxLCB4MiwgeTIsIHgzLCB5Myk7XG4gICAgICAgICAgICBpZiAodGhpcy5fY3R4KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbmVlZHNEYXNoKCkgPyB0aGlzLl9kYXNoZWRCZXppZXJUbyh4MSwgeTEsIHgyLCB5MiwgeDMsIHkzKVxuICAgICAgICAgICAgICAgICAgICA6IHRoaXMuX2N0eC5iZXppZXJDdXJ2ZVRvKHgxLCB5MSwgeDIsIHkyLCB4MywgeTMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5feGkgPSB4MztcbiAgICAgICAgICAgIHRoaXMuX3lpID0geTM7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSB4MVxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHkxXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0geDJcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSB5MlxuICAgICAgICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9jb3JlL1BhdGhQcm94eX1cbiAgICAgICAgICovXG4gICAgICAgIHF1YWRyYXRpY0N1cnZlVG86IGZ1bmN0aW9uICh4MSwgeTEsIHgyLCB5Mikge1xuICAgICAgICAgICAgdGhpcy5hZGREYXRhKENNRC5RLCB4MSwgeTEsIHgyLCB5Mik7XG4gICAgICAgICAgICBpZiAodGhpcy5fY3R4KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbmVlZHNEYXNoKCkgPyB0aGlzLl9kYXNoZWRRdWFkcmF0aWNUbyh4MSwgeTEsIHgyLCB5MilcbiAgICAgICAgICAgICAgICAgICAgOiB0aGlzLl9jdHgucXVhZHJhdGljQ3VydmVUbyh4MSwgeTEsIHgyLCB5Mik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl94aSA9IHgyO1xuICAgICAgICAgICAgdGhpcy5feWkgPSB5MjtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IGN4XG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gY3lcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSByXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gc3RhcnRBbmdsZVxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IGVuZEFuZ2xlXG4gICAgICAgICAqIEBwYXJhbSAge2Jvb2xlYW59IGFudGljbG9ja3dpc2VcbiAgICAgICAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvY29yZS9QYXRoUHJveHl9XG4gICAgICAgICAqL1xuICAgICAgICBhcmM6IGZ1bmN0aW9uIChjeCwgY3ksIHIsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBhbnRpY2xvY2t3aXNlKSB7XG4gICAgICAgICAgICB0aGlzLmFkZERhdGEoXG4gICAgICAgICAgICAgICAgQ01ELkEsIGN4LCBjeSwgciwgciwgc3RhcnRBbmdsZSwgZW5kQW5nbGUgLSBzdGFydEFuZ2xlLCAwLCBhbnRpY2xvY2t3aXNlID8gMCA6IDFcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB0aGlzLl9jdHggJiYgdGhpcy5fY3R4LmFyYyhjeCwgY3ksIHIsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBhbnRpY2xvY2t3aXNlKTtcblxuICAgICAgICAgICAgdGhpcy5feGkgPSBtYXRoQ29zKGVuZEFuZ2xlKSAqIHIgKyBjeDtcbiAgICAgICAgICAgIHRoaXMuX3hpID0gbWF0aFNpbihlbmRBbmdsZSkgKiByICsgY3g7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBUT0RPXG4gICAgICAgIGFyY1RvOiBmdW5jdGlvbiAoeDEsIHkxLCB4MiwgeTIsIHJhZGl1cykge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2N0eCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2N0eC5hcmNUbyh4MSwgeTEsIHgyLCB5MiwgcmFkaXVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIFRPRE9cbiAgICAgICAgcmVjdDogZnVuY3Rpb24gKHgsIHksIHcsIGgpIHtcbiAgICAgICAgICAgIHRoaXMuX2N0eCAmJiB0aGlzLl9jdHgucmVjdCh4LCB5LCB3LCBoKTtcbiAgICAgICAgICAgIHRoaXMuYWRkRGF0YShDTUQuUiwgeCwgeSwgdywgaCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvY29yZS9QYXRoUHJveHl9XG4gICAgICAgICAqL1xuICAgICAgICBjbG9zZVBhdGg6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkRGF0YShDTUQuWik7XG5cbiAgICAgICAgICAgIHZhciBjdHggPSB0aGlzLl9jdHg7XG4gICAgICAgICAgICB2YXIgeDAgPSB0aGlzLl94MDtcbiAgICAgICAgICAgIHZhciB5MCA9IHRoaXMuX3kwO1xuICAgICAgICAgICAgaWYgKGN0eCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX25lZWRzRGFzaCgpICYmIHRoaXMuX2Rhc2hlZExpbmVUbyh4MCwgeTApO1xuICAgICAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5feGkgPSB4MDtcbiAgICAgICAgICAgIHRoaXMuX3lpID0geTA7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29udGV4dCDku47lpJbpg6jkvKDlhaXvvIzlm6DkuLrmnInlj6/og73mmK8gcmVidWlsZFBhdGgg5a6M5LmL5ZCO5YaNIGZpbGzjgIJcbiAgICAgICAgICogc3Ryb2tlIOWQjOagt1xuICAgICAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICAgICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2NvcmUvUGF0aFByb3h5fVxuICAgICAgICAgKi9cbiAgICAgICAgZmlsbDogZnVuY3Rpb24gKGN0eCkge1xuICAgICAgICAgICAgY3R4ICYmIGN0eC5maWxsKCk7XG4gICAgICAgICAgICB0aGlzLnRvU3RhdGljKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgICAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvY29yZS9QYXRoUHJveHl9XG4gICAgICAgICAqL1xuICAgICAgICBzdHJva2U6IGZ1bmN0aW9uIChjdHgpIHtcbiAgICAgICAgICAgIGN0eCAmJiBjdHguc3Ryb2tlKCk7XG4gICAgICAgICAgICB0aGlzLnRvU3RhdGljKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOW/hemhu+WcqOWFtuWug+e7mOWItuWRveS7pOWJjeiwg+eUqFxuICAgICAgICAgKiBNdXN0IGJlIGludm9rZWQgYmVmb3JlIGFsbCBvdGhlciBwYXRoIGRyYXdpbmcgbWV0aG9kc1xuICAgICAgICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9jb3JlL1BhdGhQcm94eX1cbiAgICAgICAgICovXG4gICAgICAgIHNldExpbmVEYXNoOiBmdW5jdGlvbiAobGluZURhc2gpIHtcbiAgICAgICAgICAgIGlmIChsaW5lRGFzaCBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbGluZURhc2ggPSBsaW5lRGFzaDtcblxuICAgICAgICAgICAgICAgIHRoaXMuX2Rhc2hJZHggPSAwO1xuXG4gICAgICAgICAgICAgICAgdmFyIGxpbmVEYXNoU3VtID0gMDtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVEYXNoLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpbmVEYXNoU3VtICs9IGxpbmVEYXNoW2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9kYXNoU3VtID0gbGluZURhc2hTdW07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5b+F6aG75Zyo5YW25a6D57uY5Yi25ZG95Luk5YmN6LCD55SoXG4gICAgICAgICAqIE11c3QgYmUgaW52b2tlZCBiZWZvcmUgYWxsIG90aGVyIHBhdGggZHJhd2luZyBtZXRob2RzXG4gICAgICAgICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2NvcmUvUGF0aFByb3h5fVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0TGluZURhc2hPZmZzZXQ6IGZ1bmN0aW9uIChvZmZzZXQpIHtcbiAgICAgICAgICAgIHRoaXMuX2Rhc2hPZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIGxlbjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xlbjtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog55u05o6l6K6+572uIFBhdGgg5pWw5o2uXG4gICAgICAgICAqL1xuICAgICAgICBzZXREYXRhOiBmdW5jdGlvbiAoZGF0YSkge1xuXG4gICAgICAgICAgICB2YXIgbGVuID0gZGF0YS5sZW5ndGg7XG5cbiAgICAgICAgICAgIGlmICghICh0aGlzLmRhdGEgJiYgdGhpcy5kYXRhLmxlbmd0aCA9PSBsZW4pICYmIGhhc1R5cGVkQXJyYXkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRhdGEgPSBuZXcgRmxvYXQzMkFycmF5KGxlbik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRhdGFbaV0gPSBkYXRhW2ldO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl9sZW4gPSBsZW47XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOa3u+WKoOWtkOi3r+W+hFxuICAgICAgICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL2NvcmUvUGF0aFByb3h5fEFycmF5Ljxtb2R1bGU6enJlbmRlci9jb3JlL1BhdGhQcm94eT59IHBhdGhcbiAgICAgICAgICovXG4gICAgICAgIGFwcGVuZFBhdGg6IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgICAgICAgICBpZiAoIShwYXRoIGluc3RhbmNlb2YgQXJyYXkpKSB7XG4gICAgICAgICAgICAgICAgcGF0aCA9IFtwYXRoXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBsZW4gPSBwYXRoLmxlbmd0aDtcbiAgICAgICAgICAgIHZhciBhcHBlbmRTaXplID0gMDtcbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSB0aGlzLl9sZW47XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgYXBwZW5kU2l6ZSArPSBwYXRoW2ldLmxlbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGhhc1R5cGVkQXJyYXkgJiYgKHRoaXMuZGF0YSBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRhdGEgPSBuZXcgRmxvYXQzMkFycmF5KG9mZnNldCArIGFwcGVuZFNpemUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBhcHBlbmRQYXRoRGF0YSA9IHBhdGhbaV0uZGF0YTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IGFwcGVuZFBhdGhEYXRhLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGF0YVtvZmZzZXQrK10gPSBhcHBlbmRQYXRoRGF0YVtrXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9sZW4gPSBvZmZzZXQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWhq+WFhSBQYXRoIOaVsOaNruOAglxuICAgICAgICAgKiDlsL3ph4/lpI3nlKjogIzkuI3nlLPmmI7mlrDnmoTmlbDnu4TjgILlpKfpg6jliIblm77lvaLph43nu5jnmoTmjIfku6TmlbDmja7plb/luqbpg73mmK/kuI3lj5jnmoTjgIJcbiAgICAgICAgICovXG4gICAgICAgIGFkZERhdGE6IGZ1bmN0aW9uIChjbWQpIHtcbiAgICAgICAgICAgIHZhciBkYXRhID0gdGhpcy5kYXRhO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2xlbiArIGFyZ3VtZW50cy5sZW5ndGggPiBkYXRhLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIC8vIOWboOS4uuS5i+WJjeeahOaVsOe7hOW3sue7j+i9rOaNouaIkOmdmeaAgeeahCBGbG9hdDMyQXJyYXlcbiAgICAgICAgICAgICAgICAvLyDmiYDku6XkuI3lpJ/nlKjml7bpnIDopoHmianlsZXkuIDkuKrmlrDnmoTliqjmgIHmlbDnu4RcbiAgICAgICAgICAgICAgICB0aGlzLl9leHBhbmREYXRhKCk7XG4gICAgICAgICAgICAgICAgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZGF0YVt0aGlzLl9sZW4rK10gPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX3ByZXZDbWQgPSBjbWQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2V4cGFuZERhdGE6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIE9ubHkgaWYgZGF0YSBpcyBGbG9hdDMyQXJyYXlcbiAgICAgICAgICAgIGlmICghKHRoaXMuZGF0YSBpbnN0YW5jZW9mIEFycmF5KSkge1xuICAgICAgICAgICAgICAgIHZhciBuZXdEYXRhID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9sZW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBuZXdEYXRhW2ldID0gdGhpcy5kYXRhW2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmRhdGEgPSBuZXdEYXRhO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiBuZWVkcyBqcyBpbXBsZW1lbnRlZCBkYXNoZWQgbGluZVxuICAgICAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgX25lZWRzRGFzaDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xpbmVEYXNoO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9kYXNoZWRMaW5lVG86IGZ1bmN0aW9uICh4MSwgeTEpIHtcbiAgICAgICAgICAgIHZhciBkYXNoU3VtID0gdGhpcy5fZGFzaFN1bTtcbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSB0aGlzLl9kYXNoT2Zmc2V0O1xuICAgICAgICAgICAgdmFyIGxpbmVEYXNoID0gdGhpcy5fbGluZURhc2g7XG4gICAgICAgICAgICB2YXIgY3R4ID0gdGhpcy5fY3R4O1xuXG4gICAgICAgICAgICB2YXIgeDAgPSB0aGlzLl94aTtcbiAgICAgICAgICAgIHZhciB5MCA9IHRoaXMuX3lpO1xuICAgICAgICAgICAgdmFyIGR4ID0geDEgLSB4MDtcbiAgICAgICAgICAgIHZhciBkeSA9IHkxIC0geTA7XG4gICAgICAgICAgICB2YXIgZGlzdCA9IG1hdGhTcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcbiAgICAgICAgICAgIHZhciB4ID0geDA7XG4gICAgICAgICAgICB2YXIgeSA9IHkwO1xuICAgICAgICAgICAgdmFyIGRhc2g7XG4gICAgICAgICAgICB2YXIgbkRhc2ggPSBsaW5lRGFzaC5sZW5ndGg7XG4gICAgICAgICAgICB2YXIgaWR4O1xuICAgICAgICAgICAgZHggLz0gZGlzdDtcbiAgICAgICAgICAgIGR5IC89IGRpc3Q7XG5cbiAgICAgICAgICAgIGlmIChvZmZzZXQgPCAwKSB7XG4gICAgICAgICAgICAgICAgLy8gQ29udmVydCB0byBwb3NpdGl2ZSBvZmZzZXRcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSBkYXNoU3VtICsgb2Zmc2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2Zmc2V0ICU9IGRhc2hTdW07XG4gICAgICAgICAgICB4IC09IG9mZnNldCAqIGR4O1xuICAgICAgICAgICAgeSAtPSBvZmZzZXQgKiBkeTtcblxuICAgICAgICAgICAgd2hpbGUgKChkeCA+IDAgJiYgeCA8PSB4MSkgfHwgKGR4IDwgMCAmJiB4ID49IHgxKVxuICAgICAgICAgICAgfHwgKGR4ID09IDAgJiYgKChkeSA+IDAgJiYgeSA8PSB5MSkgfHwgKGR5IDwgMCAmJiB5ID49IHkxKSkpKSB7XG4gICAgICAgICAgICAgICAgaWR4ID0gdGhpcy5fZGFzaElkeDtcbiAgICAgICAgICAgICAgICBkYXNoID0gbGluZURhc2hbaWR4XTtcbiAgICAgICAgICAgICAgICB4ICs9IGR4ICogZGFzaDtcbiAgICAgICAgICAgICAgICB5ICs9IGR5ICogZGFzaDtcbiAgICAgICAgICAgICAgICB0aGlzLl9kYXNoSWR4ID0gKGlkeCArIDEpICUgbkRhc2g7XG4gICAgICAgICAgICAgICAgLy8gU2tpcCBwb3NpdGl2ZSBvZmZzZXRcbiAgICAgICAgICAgICAgICBpZiAoKGR4ID4gMCAmJiB4IDwgeDApIHx8IChkeCA8IDAgJiYgeCA+IHgwKSB8fCAoZHkgPiAwICYmIHkgPCB5MCkgfHwgKGR5IDwgMCAmJiB5ID4geTApKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjdHhbaWR4ICUgMiA/ICdtb3ZlVG8nIDogJ2xpbmVUbyddKFxuICAgICAgICAgICAgICAgICAgICBkeCA+PSAwID8gbWF0aE1pbih4LCB4MSkgOiBtYXRoTWF4KHgsIHgxKSxcbiAgICAgICAgICAgICAgICAgICAgZHkgPj0gMCA/IG1hdGhNaW4oeSwgeTEpIDogbWF0aE1heCh5LCB5MSlcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gT2Zmc2V0IGZvciBuZXh0IGxpbmVUb1xuICAgICAgICAgICAgZHggPSB4IC0geDE7XG4gICAgICAgICAgICBkeSA9IHkgLSB5MTtcbiAgICAgICAgICAgIHRoaXMuX2Rhc2hPZmZzZXQgPSAtbWF0aFNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIE5vdCBhY2N1cmF0ZSBkYXNoZWQgbGluZSB0b1xuICAgICAgICBfZGFzaGVkQmV6aWVyVG86IGZ1bmN0aW9uICh4MSwgeTEsIHgyLCB5MiwgeDMsIHkzKSB7XG4gICAgICAgICAgICB2YXIgZGFzaFN1bSA9IHRoaXMuX2Rhc2hTdW07XG4gICAgICAgICAgICB2YXIgb2Zmc2V0ID0gdGhpcy5fZGFzaE9mZnNldDtcbiAgICAgICAgICAgIHZhciBsaW5lRGFzaCA9IHRoaXMuX2xpbmVEYXNoO1xuICAgICAgICAgICAgdmFyIGN0eCA9IHRoaXMuX2N0eDtcblxuICAgICAgICAgICAgdmFyIHgwID0gdGhpcy5feGk7XG4gICAgICAgICAgICB2YXIgeTAgPSB0aGlzLl95aTtcbiAgICAgICAgICAgIHZhciB0O1xuICAgICAgICAgICAgdmFyIGR4O1xuICAgICAgICAgICAgdmFyIGR5O1xuICAgICAgICAgICAgdmFyIGN1YmljQXQgPSBjdXJ2ZS5jdWJpY0F0O1xuICAgICAgICAgICAgdmFyIGJlemllckxlbiA9IDA7XG4gICAgICAgICAgICB2YXIgaWR4ID0gdGhpcy5fZGFzaElkeDtcbiAgICAgICAgICAgIHZhciBuRGFzaCA9IGxpbmVEYXNoLmxlbmd0aDtcblxuICAgICAgICAgICAgdmFyIHg7XG4gICAgICAgICAgICB2YXIgeTtcblxuICAgICAgICAgICAgdmFyIHRtcExlbiA9IDA7XG5cbiAgICAgICAgICAgIGlmIChvZmZzZXQgPCAwKSB7XG4gICAgICAgICAgICAgICAgLy8gQ29udmVydCB0byBwb3NpdGl2ZSBvZmZzZXRcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSBkYXNoU3VtICsgb2Zmc2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2Zmc2V0ICU9IGRhc2hTdW07XG4gICAgICAgICAgICAvLyBCZXppZXIgYXBwcm94IGxlbmd0aFxuICAgICAgICAgICAgZm9yICh0ID0gMDsgdCA8IDE7IHQgKz0gMC4xKSB7XG4gICAgICAgICAgICAgICAgZHggPSBjdWJpY0F0KHgwLCB4MSwgeDIsIHgzLCB0ICsgMC4xKVxuICAgICAgICAgICAgICAgICAgICAtIGN1YmljQXQoeDAsIHgxLCB4MiwgeDMsIHQpO1xuICAgICAgICAgICAgICAgIGR5ID0gY3ViaWNBdCh5MCwgeTEsIHkyLCB5MywgdCArIDAuMSlcbiAgICAgICAgICAgICAgICAgICAgLSBjdWJpY0F0KHkwLCB5MSwgeTIsIHkzLCB0KTtcbiAgICAgICAgICAgICAgICBiZXppZXJMZW4gKz0gbWF0aFNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBGaW5kIGlkeCBhZnRlciBhZGQgb2Zmc2V0XG4gICAgICAgICAgICBmb3IgKDsgaWR4IDwgbkRhc2g7IGlkeCsrKSB7XG4gICAgICAgICAgICAgICAgdG1wTGVuICs9IGxpbmVEYXNoW2lkeF07XG4gICAgICAgICAgICAgICAgaWYgKHRtcExlbiA+IG9mZnNldCkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0ID0gKHRtcExlbiAtIG9mZnNldCkgLyBiZXppZXJMZW47XG5cbiAgICAgICAgICAgIHdoaWxlICh0IDw9IDEpIHtcblxuICAgICAgICAgICAgICAgIHggPSBjdWJpY0F0KHgwLCB4MSwgeDIsIHgzLCB0KTtcbiAgICAgICAgICAgICAgICB5ID0gY3ViaWNBdCh5MCwgeTEsIHkyLCB5MywgdCk7XG5cbiAgICAgICAgICAgICAgICAvLyBVc2UgbGluZSB0byBhcHByb3hpbWF0ZSBkYXNoZWQgYmV6aWVyXG4gICAgICAgICAgICAgICAgLy8gQmFkIHJlc3VsdCBpZiBkYXNoIGlzIGxvbmdcbiAgICAgICAgICAgICAgICBpZHggJSAyID8gY3R4Lm1vdmVUbyh4LCB5KVxuICAgICAgICAgICAgICAgICAgICA6IGN0eC5saW5lVG8oeCwgeSk7XG5cbiAgICAgICAgICAgICAgICB0ICs9IGxpbmVEYXNoW2lkeF0gLyBiZXppZXJMZW47XG5cbiAgICAgICAgICAgICAgICBpZHggPSAoaWR4ICsgMSkgJSBuRGFzaDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRmluaXNoIHRoZSBsYXN0IHNlZ21lbnQgYW5kIGNhbGN1bGF0ZSB0aGUgbmV3IG9mZnNldFxuICAgICAgICAgICAgKGlkeCAlIDIgIT09IDApICYmIGN0eC5saW5lVG8oeDMsIHkzKTtcbiAgICAgICAgICAgIGR4ID0geDMgLSB4O1xuICAgICAgICAgICAgZHkgPSB5MyAtIHk7XG4gICAgICAgICAgICB0aGlzLl9kYXNoT2Zmc2V0ID0gLW1hdGhTcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcbiAgICAgICAgfSxcblxuICAgICAgICBfZGFzaGVkUXVhZHJhdGljVG86IGZ1bmN0aW9uICh4MSwgeTEsIHgyLCB5Mikge1xuICAgICAgICAgICAgLy8gQ29udmVydCBxdWFkcmF0aWMgdG8gY3ViaWMgdXNpbmcgZGVncmVlIGVsZXZhdGlvblxuICAgICAgICAgICAgdmFyIHgzID0geDI7XG4gICAgICAgICAgICB2YXIgeTMgPSB5MjtcbiAgICAgICAgICAgIHgyID0gKHgyICsgMiAqIHgxKSAvIDM7XG4gICAgICAgICAgICB5MiA9ICh5MiArIDIgKiB5MSkgLyAzO1xuICAgICAgICAgICAgeDEgPSAodGhpcy5feGkgKyAyICogeDEpIC8gMztcbiAgICAgICAgICAgIHkxID0gKHRoaXMuX3lpICsgMiAqIHkxKSAvIDM7XG5cbiAgICAgICAgICAgIHRoaXMuX2Rhc2hlZEJlemllclRvKHgxLCB5MSwgeDIsIHkyLCB4MywgeTMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDovazmiJDpnZnmgIHnmoQgRmxvYXQzMkFycmF5IOWHj+WwkeWghuWGheWtmOWNoOeUqFxuICAgICAgICAgKiBDb252ZXJ0IGR5bmFtaWMgYXJyYXkgdG8gc3RhdGljIEZsb2F0MzJBcnJheVxuICAgICAgICAgKi9cbiAgICAgICAgdG9TdGF0aWM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBkYXRhID0gdGhpcy5kYXRhO1xuICAgICAgICAgICAgaWYgKGRhdGEgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgICAgIGRhdGEubGVuZ3RoID0gdGhpcy5fbGVuO1xuICAgICAgICAgICAgICAgIGlmIChoYXNUeXBlZEFycmF5KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkoZGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9jb3JlL0JvdW5kaW5nUmVjdH1cbiAgICAgICAgICovXG4gICAgICAgIGdldEJvdW5kaW5nUmVjdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgbWluWzBdID0gbWluWzFdID0gbWluMlswXSA9IG1pbjJbMV0gPSBOdW1iZXIuTUFYX1ZBTFVFO1xuICAgICAgICAgICAgbWF4WzBdID0gbWF4WzFdID0gbWF4MlswXSA9IG1heDJbMV0gPSAtTnVtYmVyLk1BWF9WQUxVRTtcblxuICAgICAgICAgICAgdmFyIGRhdGEgPSB0aGlzLmRhdGE7XG4gICAgICAgICAgICB2YXIgeGkgPSAwO1xuICAgICAgICAgICAgdmFyIHlpID0gMDtcbiAgICAgICAgICAgIHZhciB4MCA9IDA7XG4gICAgICAgICAgICB2YXIgeTAgPSAwO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOykge1xuICAgICAgICAgICAgICAgIHZhciBjbWQgPSBkYXRhW2krK107XG5cbiAgICAgICAgICAgICAgICBpZiAoaSA9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIOWmguaenOesrOS4gOS4quWRveS7pOaYryBMLCBDLCBRXG4gICAgICAgICAgICAgICAgICAgIC8vIOWImSBwcmV2aW91cyBwb2ludCDlkIznu5jliLblkb3ku6TnmoTnrKzkuIDkuKogcG9pbnRcbiAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgLy8g56ys5LiA5Liq5ZG95Luk5Li6IEFyYyDnmoTmg4XlhrXkuIvkvJrlnKjlkI7pnaLnibnmrorlpITnkIZcbiAgICAgICAgICAgICAgICAgICAgeGkgPSBkYXRhW2ldO1xuICAgICAgICAgICAgICAgICAgICB5aSA9IGRhdGFbaSArIDFdO1xuXG4gICAgICAgICAgICAgICAgICAgIHgwID0geGk7XG4gICAgICAgICAgICAgICAgICAgIHkwID0geWk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgc3dpdGNoIChjbWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBDTUQuTTpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1vdmVUbyDlkb3ku6Tph43mlrDliJvlu7rkuIDkuKrmlrDnmoQgc3VicGF0aCwg5bm25LiU5pu05paw5paw55qE6LW354K5XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyDlnKggY2xvc2VQYXRoIOeahOaXtuWAmeS9v+eUqFxuICAgICAgICAgICAgICAgICAgICAgICAgeDAgPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgICAgICB5MCA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHhpID0geDA7XG4gICAgICAgICAgICAgICAgICAgICAgICB5aSA9IHkwO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWluMlswXSA9IHgwO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWluMlsxXSA9IHkwO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF4MlswXSA9IHgwO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF4MlsxXSA9IHkwO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgQ01ELkw6XG4gICAgICAgICAgICAgICAgICAgICAgICBiYm94LmZyb21MaW5lKHhpLCB5aSwgZGF0YVtpXSwgZGF0YVtpICsgMV0sIG1pbjIsIG1heDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgeGkgPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgICAgICB5aSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIENNRC5DOlxuICAgICAgICAgICAgICAgICAgICAgICAgYmJveC5mcm9tQ3ViaWMoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeGksIHlpLCBkYXRhW2krK10sIGRhdGFbaSsrXSwgZGF0YVtpKytdLCBkYXRhW2krK10sIGRhdGFbaV0sIGRhdGFbaSArIDFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pbjIsIG1heDJcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB4aSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHlpID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgQ01ELlE6XG4gICAgICAgICAgICAgICAgICAgICAgICBiYm94LmZyb21RdWFkcmF0aWMoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeGksIHlpLCBkYXRhW2krK10sIGRhdGFbaSsrXSwgZGF0YVtpXSwgZGF0YVtpICsgMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWluMiwgbWF4MlxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHhpID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgeWkgPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBDTUQuQTpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gQXJjIOWIpOaWreeahOW8gOmUgOavlOi+g+Wkp1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGN4ID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGN5ID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJ4ID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJ5ID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXJ0QW5nbGUgPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZW5kQW5nbGUgPSBkYXRhW2krK10gKyBzdGFydEFuZ2xlO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyBBcmMg5peL6L2sXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHNpID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFudGljbG9ja3dpc2UgPSAxIC0gZGF0YVtpKytdO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaSA9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8g55u05o6l5L2/55SoIGFyYyDlkb3ku6RcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyDnrKzkuIDkuKrlkb3ku6Totbfngrnov5jmnKrlrprkuYlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4MCA9IG1hdGhDb3Moc3RhcnRBbmdsZSkgKiByeCArIGN4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkwID0gbWF0aFNpbihzdGFydEFuZ2xlKSAqIHJ5ICsgY3k7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGJib3guZnJvbUFyYyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjeCwgY3ksIHJ4LCByeSwgc3RhcnRBbmdsZSwgZW5kQW5nbGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYW50aWNsb2Nrd2lzZSwgbWluMiwgbWF4MlxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgeGkgPSBtYXRoQ29zKGVuZEFuZ2xlKSAqIHJ4ICsgY3g7XG4gICAgICAgICAgICAgICAgICAgICAgICB5aSA9IG1hdGhTaW4oZW5kQW5nbGUpICogcnkgKyBjeTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIENNRC5SOlxuICAgICAgICAgICAgICAgICAgICAgICAgeDAgPSB4aSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHkwID0geWkgPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgd2lkdGggPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaGVpZ2h0ID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVXNlIGZyb21MaW5lXG4gICAgICAgICAgICAgICAgICAgICAgICBiYm94LmZyb21MaW5lKHgwLCB5MCwgeDAgKyB3aWR0aCwgeTAgKyBoZWlnaHQsIG1pbjIsIG1heDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgQ01ELlo6XG4gICAgICAgICAgICAgICAgICAgICAgICB4aSA9IHgwO1xuICAgICAgICAgICAgICAgICAgICAgICAgeWkgPSB5MDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFVuaW9uXG4gICAgICAgICAgICAgICAgdmVjMi5taW4obWluLCBtaW4sIG1pbjIpO1xuICAgICAgICAgICAgICAgIHZlYzIubWF4KG1heCwgbWF4LCBtYXgyKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gTm8gZGF0YVxuICAgICAgICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgICAgICAgICBtaW5bMF0gPSBtaW5bMV0gPSBtYXhbMF0gPSBtYXhbMV0gPSAwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbmV3IEJvdW5kaW5nUmVjdChcbiAgICAgICAgICAgICAgICBtaW5bMF0sIG1pblsxXSwgbWF4WzBdIC0gbWluWzBdLCBtYXhbMV0gLSBtaW5bMV1cbiAgICAgICAgICAgICk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlYnVpbGQgcGF0aCBmcm9tIGN1cnJlbnQgZGF0YVxuICAgICAgICAgKiBSZWJ1aWxkIHBhdGggd2lsbCBub3QgY29uc2lkZXIgamF2YXNjcmlwdCBpbXBsZW1lbnRlZCBsaW5lIGRhc2guXG4gICAgICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dH0gY3R4XG4gICAgICAgICAqL1xuICAgICAgICByZWJ1aWxkUGF0aDogZnVuY3Rpb24gKGN0eCkge1xuICAgICAgICAgICAgdmFyIGQgPSB0aGlzLmRhdGE7XG4gICAgICAgICAgICB2YXIgeDAsIHkwO1xuICAgICAgICAgICAgdmFyIHhpLCB5aTtcbiAgICAgICAgICAgIHZhciB4LCB5O1xuICAgICAgICAgICAgdmFyIHV4ID0gdGhpcy5fdXg7XG4gICAgICAgICAgICB2YXIgdXkgPSB0aGlzLl91eTtcbiAgICAgICAgICAgIHZhciBsZW4gPSB0aGlzLl9sZW47XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjspIHtcbiAgICAgICAgICAgICAgICB2YXIgY21kID0gZFtpKytdO1xuXG4gICAgICAgICAgICAgICAgaWYgKGkgPT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAvLyDlpoLmnpznrKzkuIDkuKrlkb3ku6TmmK8gTCwgQywgUVxuICAgICAgICAgICAgICAgICAgICAvLyDliJkgcHJldmlvdXMgcG9pbnQg5ZCM57uY5Yi25ZG95Luk55qE56ys5LiA5LiqIHBvaW50XG4gICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgIC8vIOesrOS4gOS4quWRveS7pOS4uiBBcmMg55qE5oOF5Ya15LiL5Lya5Zyo5ZCO6Z2i54m55q6K5aSE55CGXG4gICAgICAgICAgICAgICAgICAgIHhpID0gZFtpXTtcbiAgICAgICAgICAgICAgICAgICAgeWkgPSBkW2kgKyAxXTtcblxuICAgICAgICAgICAgICAgICAgICB4MCA9IHhpO1xuICAgICAgICAgICAgICAgICAgICB5MCA9IHlpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGNtZCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIENNRC5NOlxuICAgICAgICAgICAgICAgICAgICAgICAgeDAgPSB4aSA9IGRbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHkwID0geWkgPSBkW2krK107XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHgubW92ZVRvKHhpLCB5aSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBDTUQuTDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHggPSBkW2krK107XG4gICAgICAgICAgICAgICAgICAgICAgICB5ID0gZFtpKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm90IGRyYXcgdG9vIHNtYWxsIHNlZyBiZXR3ZWVuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWF0aEFicyh4IC0geGkpID4gdXggfHwgbWF0aEFicyh5IC0geWkpID4gdXkgfHwgaSA9PT0gbGVuIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5saW5lVG8oeCwgeSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeGkgPSB4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHlpID0geTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIENNRC5DOlxuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmJlemllckN1cnZlVG8oXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZFtpKytdLCBkW2krK10sIGRbaSsrXSwgZFtpKytdLCBkW2krK10sIGRbaSsrXVxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHhpID0gZFtpIC0gMl07XG4gICAgICAgICAgICAgICAgICAgICAgICB5aSA9IGRbaSAtIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgQ01ELlE6XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHgucXVhZHJhdGljQ3VydmVUbyhkW2krK10sIGRbaSsrXSwgZFtpKytdLCBkW2krK10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgeGkgPSBkW2kgLSAyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHlpID0gZFtpIC0gMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBDTUQuQTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjeCA9IGRbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjeSA9IGRbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByeCA9IGRbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByeSA9IGRbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0aGV0YSA9IGRbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkVGhldGEgPSBkW2krK107XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHNpID0gZFtpKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZzID0gZFtpKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHIgPSAocnggPiByeSkgPyByeCA6IHJ5O1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNjYWxlWCA9IChyeCA+IHJ5KSA/IDEgOiByeCAvIHJ5O1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNjYWxlWSA9IChyeCA+IHJ5KSA/IHJ5IC8gcnggOiAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlzRWxsaXBzZSA9IE1hdGguYWJzKHJ4IC0gcnkpID4gMWUtMztcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbmRBbmdsZSA9IHRoZXRhICsgZFRoZXRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzRWxsaXBzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0eC50cmFuc2xhdGUoY3gsIGN5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHgucm90YXRlKHBzaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnNjYWxlKHNjYWxlWCwgc2NhbGVZKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHguYXJjKDAsIDAsIHIsIHRoZXRhLCBlbmRBbmdsZSwgMSAtIGZzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHguc2NhbGUoMSAvIHNjYWxlWCwgMSAvIHNjYWxlWSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnJvdGF0ZSgtcHNpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHgudHJhbnNsYXRlKC1jeCwgLWN5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5hcmMoY3gsIGN5LCByLCB0aGV0YSwgZW5kQW5nbGUsIDEgLSBmcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpID09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyDnm7TmjqXkvb/nlKggYXJjIOWRveS7pFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIOesrOS4gOS4quWRveS7pOi1t+eCuei/mOacquWumuS5iVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHgwID0gbWF0aENvcyh0aGV0YSkgKiByeCArIGN4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkwID0gbWF0aFNpbih0aGV0YSkgKiByeSArIGN5O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgeGkgPSBtYXRoQ29zKGVuZEFuZ2xlKSAqIHJ4ICsgY3g7XG4gICAgICAgICAgICAgICAgICAgICAgICB5aSA9IG1hdGhTaW4oZW5kQW5nbGUpICogcnkgKyBjeTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIENNRC5SOlxuICAgICAgICAgICAgICAgICAgICAgICAgeDAgPSB4aSA9IGRbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICB5MCA9IHlpID0gZFtpICsgMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHgucmVjdChkW2krK10sIGRbaSsrXSwgZFtpKytdLCBkW2krK10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgQ01ELlo6XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB4aSA9IHgwO1xuICAgICAgICAgICAgICAgICAgICAgICAgeWkgPSB5MDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgUGF0aFByb3h5LkNNRCA9IENNRDtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gUGF0aFByb3h5O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34venJlbmRlci9saWIvY29yZS9QYXRoUHJveHkuanNcbiAqKiBtb2R1bGUgaWQgPSAyNVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuLyoqXG4gKiDmm7Lnur/ovoXliqnmqKHlnZdcbiAqIEBtb2R1bGUgenJlbmRlci9jb3JlL2N1cnZlXG4gKiBAYXV0aG9yIHBpc3NhbmcoaHR0cHM6Ly93d3cuZ2l0aHViLmNvbS9waXNzYW5nKVxuICovXG5cblxuICAgIHZhciB2ZWMyID0gcmVxdWlyZSgnLi92ZWN0b3InKTtcbiAgICB2YXIgdjJDcmVhdGUgPSB2ZWMyLmNyZWF0ZTtcbiAgICB2YXIgdjJEaXN0U3F1YXJlID0gdmVjMi5kaXN0U3F1YXJlO1xuICAgIHZhciBtYXRoUG93ID0gTWF0aC5wb3c7XG4gICAgdmFyIG1hdGhTcXJ0ID0gTWF0aC5zcXJ0O1xuXG4gICAgdmFyIEVQU0lMT04gPSAxZS04O1xuICAgIHZhciBFUFNJTE9OX05VTUVSSUMgPSAxZS00O1xuXG4gICAgdmFyIFRIUkVFX1NRUlQgPSBtYXRoU3FydCgzKTtcbiAgICB2YXIgT05FX1RISVJEID0gMSAvIDM7XG5cbiAgICAvLyDkuLTml7blj5jph49cbiAgICB2YXIgX3YwID0gdjJDcmVhdGUoKTtcbiAgICB2YXIgX3YxID0gdjJDcmVhdGUoKTtcbiAgICB2YXIgX3YyID0gdjJDcmVhdGUoKTtcbiAgICAvLyB2YXIgX3YzID0gdmVjMi5jcmVhdGUoKTtcblxuICAgIGZ1bmN0aW9uIGlzQXJvdW5kWmVybyh2YWwpIHtcbiAgICAgICAgcmV0dXJuIHZhbCA+IC1FUFNJTE9OICYmIHZhbCA8IEVQU0lMT047XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzTm90QXJvdW5kWmVybyh2YWwpIHtcbiAgICAgICAgcmV0dXJuIHZhbCA+IEVQU0lMT04gfHwgdmFsIDwgLUVQU0lMT047XG4gICAgfVxuICAgIC8qKlxuICAgICAqIOiuoeeul+S4ieasoei0neWhnuWwlOWAvFxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL2N1cnZlXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBwMFxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcDFcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHAyXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBwM1xuICAgICAqIEBwYXJhbSAge251bWJlcn0gdFxuICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjdWJpY0F0KHAwLCBwMSwgcDIsIHAzLCB0KSB7XG4gICAgICAgIHZhciBvbmV0ID0gMSAtIHQ7XG4gICAgICAgIHJldHVybiBvbmV0ICogb25ldCAqIChvbmV0ICogcDAgKyAzICogdCAqIHAxKVxuICAgICAgICAgICAgICsgdCAqIHQgKiAodCAqIHAzICsgMyAqIG9uZXQgKiBwMik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog6K6h566X5LiJ5qyh6LSd5aGe5bCU5a+85pWw5YC8XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvY3VydmVcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHAwXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBwMVxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcDJcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHAzXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSB0XG4gICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGN1YmljRGVyaXZhdGl2ZUF0KHAwLCBwMSwgcDIsIHAzLCB0KSB7XG4gICAgICAgIHZhciBvbmV0ID0gMSAtIHQ7XG4gICAgICAgIHJldHVybiAzICogKFxuICAgICAgICAgICAgKChwMSAtIHAwKSAqIG9uZXQgKyAyICogKHAyIC0gcDEpICogdCkgKiBvbmV0XG4gICAgICAgICAgICArIChwMyAtIHAyKSAqIHQgKiB0XG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog6K6h566X5LiJ5qyh6LSd5aGe5bCU5pa556iL5qC577yM5L2/55So55ub6YeR5YWs5byPXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvY3VydmVcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHAwXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBwMVxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcDJcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHAzXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSB2YWxcbiAgICAgKiBAcGFyYW0gIHtBcnJheS48bnVtYmVyPn0gcm9vdHNcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IOacieaViOagueaVsOebrlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGN1YmljUm9vdEF0KHAwLCBwMSwgcDIsIHAzLCB2YWwsIHJvb3RzKSB7XG4gICAgICAgIC8vIEV2YWx1YXRlIHJvb3RzIG9mIGN1YmljIGZ1bmN0aW9uc1xuICAgICAgICB2YXIgYSA9IHAzICsgMyAqIChwMSAtIHAyKSAtIHAwO1xuICAgICAgICB2YXIgYiA9IDMgKiAocDIgLSBwMSAqIDIgKyBwMCk7XG4gICAgICAgIHZhciBjID0gMyAqIChwMSAgLSBwMCk7XG4gICAgICAgIHZhciBkID0gcDAgLSB2YWw7XG5cbiAgICAgICAgdmFyIEEgPSBiICogYiAtIDMgKiBhICogYztcbiAgICAgICAgdmFyIEIgPSBiICogYyAtIDkgKiBhICogZDtcbiAgICAgICAgdmFyIEMgPSBjICogYyAtIDMgKiBiICogZDtcblxuICAgICAgICB2YXIgbiA9IDA7XG5cbiAgICAgICAgaWYgKGlzQXJvdW5kWmVybyhBKSAmJiBpc0Fyb3VuZFplcm8oQikpIHtcbiAgICAgICAgICAgIGlmIChpc0Fyb3VuZFplcm8oYikpIHtcbiAgICAgICAgICAgICAgICByb290c1swXSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgdDEgPSAtYyAvIGI7ICAvL3QxLCB0MiwgdDMsIGIgaXMgbm90IHplcm9cbiAgICAgICAgICAgICAgICBpZiAodDEgPj0gMCAmJiB0MSA8PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvb3RzW24rK10gPSB0MTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgZGlzYyA9IEIgKiBCIC0gNCAqIEEgKiBDO1xuXG4gICAgICAgICAgICBpZiAoaXNBcm91bmRaZXJvKGRpc2MpKSB7XG4gICAgICAgICAgICAgICAgdmFyIEsgPSBCIC8gQTtcbiAgICAgICAgICAgICAgICB2YXIgdDEgPSAtYiAvIGEgKyBLOyAgLy8gdDEsIGEgaXMgbm90IHplcm9cbiAgICAgICAgICAgICAgICB2YXIgdDIgPSAtSyAvIDI7ICAvLyB0MiwgdDNcbiAgICAgICAgICAgICAgICBpZiAodDEgPj0gMCAmJiB0MSA8PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvb3RzW24rK10gPSB0MTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHQyID49IDAgJiYgdDIgPD0gMSkge1xuICAgICAgICAgICAgICAgICAgICByb290c1tuKytdID0gdDI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZGlzYyA+IDApIHtcbiAgICAgICAgICAgICAgICB2YXIgZGlzY1NxcnQgPSBtYXRoU3FydChkaXNjKTtcbiAgICAgICAgICAgICAgICB2YXIgWTEgPSBBICogYiArIDEuNSAqIGEgKiAoLUIgKyBkaXNjU3FydCk7XG4gICAgICAgICAgICAgICAgdmFyIFkyID0gQSAqIGIgKyAxLjUgKiBhICogKC1CIC0gZGlzY1NxcnQpO1xuICAgICAgICAgICAgICAgIGlmIChZMSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgWTEgPSAtbWF0aFBvdygtWTEsIE9ORV9USElSRCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBZMSA9IG1hdGhQb3coWTEsIE9ORV9USElSRCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChZMiA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgWTIgPSAtbWF0aFBvdygtWTIsIE9ORV9USElSRCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBZMiA9IG1hdGhQb3coWTIsIE9ORV9USElSRCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciB0MSA9ICgtYiAtIChZMSArIFkyKSkgLyAoMyAqIGEpO1xuICAgICAgICAgICAgICAgIGlmICh0MSA+PSAwICYmIHQxIDw9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcm9vdHNbbisrXSA9IHQxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBUID0gKDIgKiBBICogYiAtIDMgKiBhICogQikgLyAoMiAqIG1hdGhTcXJ0KEEgKiBBICogQSkpO1xuICAgICAgICAgICAgICAgIHZhciB0aGV0YSA9IE1hdGguYWNvcyhUKSAvIDM7XG4gICAgICAgICAgICAgICAgdmFyIEFTcXJ0ID0gbWF0aFNxcnQoQSk7XG4gICAgICAgICAgICAgICAgdmFyIHRtcCA9IE1hdGguY29zKHRoZXRhKTtcblxuICAgICAgICAgICAgICAgIHZhciB0MSA9ICgtYiAtIDIgKiBBU3FydCAqIHRtcCkgLyAoMyAqIGEpO1xuICAgICAgICAgICAgICAgIHZhciB0MiA9ICgtYiArIEFTcXJ0ICogKHRtcCArIFRIUkVFX1NRUlQgKiBNYXRoLnNpbih0aGV0YSkpKSAvICgzICogYSk7XG4gICAgICAgICAgICAgICAgdmFyIHQzID0gKC1iICsgQVNxcnQgKiAodG1wIC0gVEhSRUVfU1FSVCAqIE1hdGguc2luKHRoZXRhKSkpIC8gKDMgKiBhKTtcbiAgICAgICAgICAgICAgICBpZiAodDEgPj0gMCAmJiB0MSA8PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvb3RzW24rK10gPSB0MTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHQyID49IDAgJiYgdDIgPD0gMSkge1xuICAgICAgICAgICAgICAgICAgICByb290c1tuKytdID0gdDI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0MyA+PSAwICYmIHQzIDw9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcm9vdHNbbisrXSA9IHQzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDorqHnrpfkuInmrKHotJ3loZ7lsJTmlrnnqIvmnoHpmZDlgLznmoTkvY3nva5cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS9jdXJ2ZVxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcDBcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHAxXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBwMlxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcDNcbiAgICAgKiBAcGFyYW0gIHtBcnJheS48bnVtYmVyPn0gZXh0cmVtYVxuICAgICAqIEByZXR1cm4ge251bWJlcn0g5pyJ5pWI5pWw55uuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3ViaWNFeHRyZW1hKHAwLCBwMSwgcDIsIHAzLCBleHRyZW1hKSB7XG4gICAgICAgIHZhciBiID0gNiAqIHAyIC0gMTIgKiBwMSArIDYgKiBwMDtcbiAgICAgICAgdmFyIGEgPSA5ICogcDEgKyAzICogcDMgLSAzICogcDAgLSA5ICogcDI7XG4gICAgICAgIHZhciBjID0gMyAqIHAxIC0gMyAqIHAwO1xuXG4gICAgICAgIHZhciBuID0gMDtcbiAgICAgICAgaWYgKGlzQXJvdW5kWmVybyhhKSkge1xuICAgICAgICAgICAgaWYgKGlzTm90QXJvdW5kWmVybyhiKSkge1xuICAgICAgICAgICAgICAgIHZhciB0MSA9IC1jIC8gYjtcbiAgICAgICAgICAgICAgICBpZiAodDEgPj0gMCAmJiB0MSA8PTEpIHtcbiAgICAgICAgICAgICAgICAgICAgZXh0cmVtYVtuKytdID0gdDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGRpc2MgPSBiICogYiAtIDQgKiBhICogYztcbiAgICAgICAgICAgIGlmIChpc0Fyb3VuZFplcm8oZGlzYykpIHtcbiAgICAgICAgICAgICAgICBleHRyZW1hWzBdID0gLWIgLyAoMiAqIGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZGlzYyA+IDApIHtcbiAgICAgICAgICAgICAgICB2YXIgZGlzY1NxcnQgPSBtYXRoU3FydChkaXNjKTtcbiAgICAgICAgICAgICAgICB2YXIgdDEgPSAoLWIgKyBkaXNjU3FydCkgLyAoMiAqIGEpO1xuICAgICAgICAgICAgICAgIHZhciB0MiA9ICgtYiAtIGRpc2NTcXJ0KSAvICgyICogYSk7XG4gICAgICAgICAgICAgICAgaWYgKHQxID49IDAgJiYgdDEgPD0gMSkge1xuICAgICAgICAgICAgICAgICAgICBleHRyZW1hW24rK10gPSB0MTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHQyID49IDAgJiYgdDIgPD0gMSkge1xuICAgICAgICAgICAgICAgICAgICBleHRyZW1hW24rK10gPSB0MjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG47XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog57uG5YiG5LiJ5qyh6LSd5aGe5bCU5puy57q/XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvY3VydmVcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHAwXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBwMVxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcDJcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHAzXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSB0XG4gICAgICogQHBhcmFtICB7QXJyYXkuPG51bWJlcj59IG91dFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGN1YmljU3ViZGl2aWRlKHAwLCBwMSwgcDIsIHAzLCB0LCBvdXQpIHtcbiAgICAgICAgdmFyIHAwMSA9IChwMSAtIHAwKSAqIHQgKyBwMDtcbiAgICAgICAgdmFyIHAxMiA9IChwMiAtIHAxKSAqIHQgKyBwMTtcbiAgICAgICAgdmFyIHAyMyA9IChwMyAtIHAyKSAqIHQgKyBwMjtcblxuICAgICAgICB2YXIgcDAxMiA9IChwMTIgLSBwMDEpICogdCArIHAwMTtcbiAgICAgICAgdmFyIHAxMjMgPSAocDIzIC0gcDEyKSAqIHQgKyBwMTI7XG5cbiAgICAgICAgdmFyIHAwMTIzID0gKHAxMjMgLSBwMDEyKSAqIHQgKyBwMDEyO1xuICAgICAgICAvLyBTZWcwXG4gICAgICAgIG91dFswXSA9IHAwO1xuICAgICAgICBvdXRbMV0gPSBwMDE7XG4gICAgICAgIG91dFsyXSA9IHAwMTI7XG4gICAgICAgIG91dFszXSA9IHAwMTIzO1xuICAgICAgICAvLyBTZWcxXG4gICAgICAgIG91dFs0XSA9IHAwMTIzO1xuICAgICAgICBvdXRbNV0gPSBwMTIzO1xuICAgICAgICBvdXRbNl0gPSBwMjM7XG4gICAgICAgIG91dFs3XSA9IHAzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOaKleWwhOeCueWIsOS4ieasoei0neWhnuWwlOabsue6v+S4iu+8jOi/lOWbnuaKleWwhOi3neemu+OAglxuICAgICAqIOaKleWwhOeCueacieWPr+iDveS8muacieS4gOS4quaIluiAheWkmuS4qu+8jOi/memHjOWPqui/lOWbnuWFtuS4rei3neemu+acgOefreeahOS4gOS4quOAglxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4MFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5MFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4MVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5MVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4MlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5MlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4M1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5M1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHlcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBbb3V0XSDmipXlsITngrlcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICovXG4gICAgZnVuY3Rpb24gY3ViaWNQcm9qZWN0UG9pbnQoXG4gICAgICAgIHgwLCB5MCwgeDEsIHkxLCB4MiwgeTIsIHgzLCB5MyxcbiAgICAgICAgeCwgeSwgb3V0XG4gICAgKSB7XG4gICAgICAgIC8vIGh0dHA6Ly9wb21heC5naXRodWIuaW8vYmV6aWVyaW5mby8jcHJvamVjdGlvbnNcbiAgICAgICAgdmFyIHQ7XG4gICAgICAgIHZhciBpbnRlcnZhbCA9IDAuMDA1O1xuICAgICAgICB2YXIgZCA9IEluZmluaXR5O1xuICAgICAgICB2YXIgcHJldjtcbiAgICAgICAgdmFyIG5leHQ7XG4gICAgICAgIHZhciBkMTtcbiAgICAgICAgdmFyIGQyO1xuXG4gICAgICAgIF92MFswXSA9IHg7XG4gICAgICAgIF92MFsxXSA9IHk7XG5cbiAgICAgICAgLy8g5YWI57KX55Wl5Lyw6K6h5LiA5LiL5Y+v6IO955qE5pyA5bCP6Led56a755qEIHQg5YC8XG4gICAgICAgIC8vIFBFTkRJTkdcbiAgICAgICAgZm9yICh2YXIgX3QgPSAwOyBfdCA8IDE7IF90ICs9IDAuMDUpIHtcbiAgICAgICAgICAgIF92MVswXSA9IGN1YmljQXQoeDAsIHgxLCB4MiwgeDMsIF90KTtcbiAgICAgICAgICAgIF92MVsxXSA9IGN1YmljQXQoeTAsIHkxLCB5MiwgeTMsIF90KTtcbiAgICAgICAgICAgIGQxID0gdjJEaXN0U3F1YXJlKF92MCwgX3YxKTtcbiAgICAgICAgICAgIGlmIChkMSA8IGQpIHtcbiAgICAgICAgICAgICAgICB0ID0gX3Q7XG4gICAgICAgICAgICAgICAgZCA9IGQxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGQgPSBJbmZpbml0eTtcblxuICAgICAgICAvLyBBdCBtb3N0IDMyIGl0ZXJhdGlvblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDMyOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChpbnRlcnZhbCA8IEVQU0lMT05fTlVNRVJJQykge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJldiA9IHQgLSBpbnRlcnZhbDtcbiAgICAgICAgICAgIG5leHQgPSB0ICsgaW50ZXJ2YWw7XG4gICAgICAgICAgICAvLyB0IC0gaW50ZXJ2YWxcbiAgICAgICAgICAgIF92MVswXSA9IGN1YmljQXQoeDAsIHgxLCB4MiwgeDMsIHByZXYpO1xuICAgICAgICAgICAgX3YxWzFdID0gY3ViaWNBdCh5MCwgeTEsIHkyLCB5MywgcHJldik7XG5cbiAgICAgICAgICAgIGQxID0gdjJEaXN0U3F1YXJlKF92MSwgX3YwKTtcblxuICAgICAgICAgICAgaWYgKHByZXYgPj0gMCAmJiBkMSA8IGQpIHtcbiAgICAgICAgICAgICAgICB0ID0gcHJldjtcbiAgICAgICAgICAgICAgICBkID0gZDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyB0ICsgaW50ZXJ2YWxcbiAgICAgICAgICAgICAgICBfdjJbMF0gPSBjdWJpY0F0KHgwLCB4MSwgeDIsIHgzLCBuZXh0KTtcbiAgICAgICAgICAgICAgICBfdjJbMV0gPSBjdWJpY0F0KHkwLCB5MSwgeTIsIHkzLCBuZXh0KTtcbiAgICAgICAgICAgICAgICBkMiA9IHYyRGlzdFNxdWFyZShfdjIsIF92MCk7XG5cbiAgICAgICAgICAgICAgICBpZiAobmV4dCA8PSAxICYmIGQyIDwgZCkge1xuICAgICAgICAgICAgICAgICAgICB0ID0gbmV4dDtcbiAgICAgICAgICAgICAgICAgICAgZCA9IGQyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaW50ZXJ2YWwgKj0gMC41O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyB0XG4gICAgICAgIGlmIChvdXQpIHtcbiAgICAgICAgICAgIG91dFswXSA9IGN1YmljQXQoeDAsIHgxLCB4MiwgeDMsIHQpO1xuICAgICAgICAgICAgb3V0WzFdID0gY3ViaWNBdCh5MCwgeTEsIHkyLCB5MywgdCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY29uc29sZS5sb2coaW50ZXJ2YWwsIGkpO1xuICAgICAgICByZXR1cm4gbWF0aFNxcnQoZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog6K6h566X5LqM5qyh5pa56LSd5aGe5bCU5YC8XG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBwMFxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcDFcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHAyXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSB0XG4gICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHF1YWRyYXRpY0F0KHAwLCBwMSwgcDIsIHQpIHtcbiAgICAgICAgdmFyIG9uZXQgPSAxIC0gdDtcbiAgICAgICAgcmV0dXJuIG9uZXQgKiAob25ldCAqIHAwICsgMiAqIHQgKiBwMSkgKyB0ICogdCAqIHAyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOiuoeeul+S6jOasoeaWuei0neWhnuWwlOWvvOaVsOWAvFxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcDBcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHAxXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBwMlxuICAgICAqIEBwYXJhbSAge251bWJlcn0gdFxuICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBxdWFkcmF0aWNEZXJpdmF0aXZlQXQocDAsIHAxLCBwMiwgdCkge1xuICAgICAgICByZXR1cm4gMiAqICgoMSAtIHQpICogKHAxIC0gcDApICsgdCAqIChwMiAtIHAxKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog6K6h566X5LqM5qyh5pa56LSd5aGe5bCU5pa556iL5qC5XG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBwMFxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcDFcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHAyXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSB0XG4gICAgICogQHBhcmFtICB7QXJyYXkuPG51bWJlcj59IHJvb3RzXG4gICAgICogQHJldHVybiB7bnVtYmVyfSDmnInmlYjmoLnmlbDnm65cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBxdWFkcmF0aWNSb290QXQocDAsIHAxLCBwMiwgdmFsLCByb290cykge1xuICAgICAgICB2YXIgYSA9IHAwIC0gMiAqIHAxICsgcDI7XG4gICAgICAgIHZhciBiID0gMiAqIChwMSAtIHAwKTtcbiAgICAgICAgdmFyIGMgPSBwMCAtIHZhbDtcblxuICAgICAgICB2YXIgbiA9IDA7XG4gICAgICAgIGlmIChpc0Fyb3VuZFplcm8oYSkpIHtcbiAgICAgICAgICAgIGlmIChpc05vdEFyb3VuZFplcm8oYikpIHtcbiAgICAgICAgICAgICAgICB2YXIgdDEgPSAtYyAvIGI7XG4gICAgICAgICAgICAgICAgaWYgKHQxID49IDAgJiYgdDEgPD0gMSkge1xuICAgICAgICAgICAgICAgICAgICByb290c1tuKytdID0gdDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGRpc2MgPSBiICogYiAtIDQgKiBhICogYztcbiAgICAgICAgICAgIGlmIChpc0Fyb3VuZFplcm8oZGlzYykpIHtcbiAgICAgICAgICAgICAgICB2YXIgdDEgPSAtYiAvICgyICogYSk7XG4gICAgICAgICAgICAgICAgaWYgKHQxID49IDAgJiYgdDEgPD0gMSkge1xuICAgICAgICAgICAgICAgICAgICByb290c1tuKytdID0gdDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZGlzYyA+IDApIHtcbiAgICAgICAgICAgICAgICB2YXIgZGlzY1NxcnQgPSBtYXRoU3FydChkaXNjKTtcbiAgICAgICAgICAgICAgICB2YXIgdDEgPSAoLWIgKyBkaXNjU3FydCkgLyAoMiAqIGEpO1xuICAgICAgICAgICAgICAgIHZhciB0MiA9ICgtYiAtIGRpc2NTcXJ0KSAvICgyICogYSk7XG4gICAgICAgICAgICAgICAgaWYgKHQxID49IDAgJiYgdDEgPD0gMSkge1xuICAgICAgICAgICAgICAgICAgICByb290c1tuKytdID0gdDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0MiA+PSAwICYmIHQyIDw9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcm9vdHNbbisrXSA9IHQyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDorqHnrpfkuozmrKHotJ3loZ7lsJTmlrnnqIvmnoHpmZDlgLxcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS9jdXJ2ZVxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcDBcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHAxXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBwMlxuICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBxdWFkcmF0aWNFeHRyZW11bShwMCwgcDEsIHAyKSB7XG4gICAgICAgIHZhciBkaXZpZGVyID0gcDAgKyBwMiAtIDIgKiBwMTtcbiAgICAgICAgaWYgKGRpdmlkZXIgPT09IDApIHtcbiAgICAgICAgICAgIC8vIHAxIGlzIGNlbnRlciBvZiBwMCBhbmQgcDJcbiAgICAgICAgICAgIHJldHVybiAwLjU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gKHAwIC0gcDEpIC8gZGl2aWRlcjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOe7huWIhuS6jOasoei0neWhnuWwlOabsue6v1xuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL2N1cnZlXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBwMFxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcDFcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHAyXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSB0XG4gICAgICogQHBhcmFtICB7QXJyYXkuPG51bWJlcj59IG91dFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHF1YWRyYXRpY1N1YmRpdmlkZShwMCwgcDEsIHAyLCB0LCBvdXQpIHtcbiAgICAgICAgdmFyIHAwMSA9IChwMSAtIHAwKSAqIHQgKyBwMDtcbiAgICAgICAgdmFyIHAxMiA9IChwMiAtIHAxKSAqIHQgKyBwMTtcbiAgICAgICAgdmFyIHAwMTIgPSAocDEyIC0gcDAxKSAqIHQgKyBwMDE7XG5cbiAgICAgICAgLy8gU2VnMFxuICAgICAgICBvdXRbMF0gPSBwMDtcbiAgICAgICAgb3V0WzFdID0gcDAxO1xuICAgICAgICBvdXRbMl0gPSBwMDEyO1xuXG4gICAgICAgIC8vIFNlZzFcbiAgICAgICAgb3V0WzNdID0gcDAxMjtcbiAgICAgICAgb3V0WzRdID0gcDEyO1xuICAgICAgICBvdXRbNV0gPSBwMjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDmipXlsITngrnliLDkuozmrKHotJ3loZ7lsJTmm7Lnur/kuIrvvIzov5Tlm57mipXlsITot53nprvjgIJcbiAgICAgKiDmipXlsITngrnmnInlj6/og73kvJrmnInkuIDkuKrmiJbogIXlpJrkuKrvvIzov5nph4zlj6rov5Tlm57lhbbkuK3ot53nprvmnIDnn63nmoTkuIDkuKrjgIJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geDBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geTBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geDFcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geTFcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geDJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geTJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gb3V0IOaKleWwhOeCuVxuICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBxdWFkcmF0aWNQcm9qZWN0UG9pbnQoXG4gICAgICAgIHgwLCB5MCwgeDEsIHkxLCB4MiwgeTIsXG4gICAgICAgIHgsIHksIG91dFxuICAgICkge1xuICAgICAgICAvLyBodHRwOi8vcG9tYXguZ2l0aHViLmlvL2JlemllcmluZm8vI3Byb2plY3Rpb25zXG4gICAgICAgIHZhciB0O1xuICAgICAgICB2YXIgaW50ZXJ2YWwgPSAwLjAwNTtcbiAgICAgICAgdmFyIGQgPSBJbmZpbml0eTtcblxuICAgICAgICBfdjBbMF0gPSB4O1xuICAgICAgICBfdjBbMV0gPSB5O1xuXG4gICAgICAgIC8vIOWFiOeyl+eVpeS8sOiuoeS4gOS4i+WPr+iDveeahOacgOWwj+i3neemu+eahCB0IOWAvFxuICAgICAgICAvLyBQRU5ESU5HXG4gICAgICAgIGZvciAodmFyIF90ID0gMDsgX3QgPCAxOyBfdCArPSAwLjA1KSB7XG4gICAgICAgICAgICBfdjFbMF0gPSBxdWFkcmF0aWNBdCh4MCwgeDEsIHgyLCBfdCk7XG4gICAgICAgICAgICBfdjFbMV0gPSBxdWFkcmF0aWNBdCh5MCwgeTEsIHkyLCBfdCk7XG4gICAgICAgICAgICB2YXIgZDEgPSB2MkRpc3RTcXVhcmUoX3YwLCBfdjEpO1xuICAgICAgICAgICAgaWYgKGQxIDwgZCkge1xuICAgICAgICAgICAgICAgIHQgPSBfdDtcbiAgICAgICAgICAgICAgICBkID0gZDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZCA9IEluZmluaXR5O1xuXG4gICAgICAgIC8vIEF0IG1vc3QgMzIgaXRlcmF0aW9uXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMzI7IGkrKykge1xuICAgICAgICAgICAgaWYgKGludGVydmFsIDwgRVBTSUxPTl9OVU1FUklDKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcHJldiA9IHQgLSBpbnRlcnZhbDtcbiAgICAgICAgICAgIHZhciBuZXh0ID0gdCArIGludGVydmFsO1xuICAgICAgICAgICAgLy8gdCAtIGludGVydmFsXG4gICAgICAgICAgICBfdjFbMF0gPSBxdWFkcmF0aWNBdCh4MCwgeDEsIHgyLCBwcmV2KTtcbiAgICAgICAgICAgIF92MVsxXSA9IHF1YWRyYXRpY0F0KHkwLCB5MSwgeTIsIHByZXYpO1xuXG4gICAgICAgICAgICB2YXIgZDEgPSB2MkRpc3RTcXVhcmUoX3YxLCBfdjApO1xuXG4gICAgICAgICAgICBpZiAocHJldiA+PSAwICYmIGQxIDwgZCkge1xuICAgICAgICAgICAgICAgIHQgPSBwcmV2O1xuICAgICAgICAgICAgICAgIGQgPSBkMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHQgKyBpbnRlcnZhbFxuICAgICAgICAgICAgICAgIF92MlswXSA9IHF1YWRyYXRpY0F0KHgwLCB4MSwgeDIsIG5leHQpO1xuICAgICAgICAgICAgICAgIF92MlsxXSA9IHF1YWRyYXRpY0F0KHkwLCB5MSwgeTIsIG5leHQpO1xuICAgICAgICAgICAgICAgIHZhciBkMiA9IHYyRGlzdFNxdWFyZShfdjIsIF92MCk7XG4gICAgICAgICAgICAgICAgaWYgKG5leHQgPD0gMSAmJiBkMiA8IGQpIHtcbiAgICAgICAgICAgICAgICAgICAgdCA9IG5leHQ7XG4gICAgICAgICAgICAgICAgICAgIGQgPSBkMjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGludGVydmFsICo9IDAuNTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gdFxuICAgICAgICBpZiAob3V0KSB7XG4gICAgICAgICAgICBvdXRbMF0gPSBxdWFkcmF0aWNBdCh4MCwgeDEsIHgyLCB0KTtcbiAgICAgICAgICAgIG91dFsxXSA9IHF1YWRyYXRpY0F0KHkwLCB5MSwgeTIsIHQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKGludGVydmFsLCBpKTtcbiAgICAgICAgcmV0dXJuIG1hdGhTcXJ0KGQpO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0ge1xuXG4gICAgICAgIGN1YmljQXQ6IGN1YmljQXQsXG5cbiAgICAgICAgY3ViaWNEZXJpdmF0aXZlQXQ6IGN1YmljRGVyaXZhdGl2ZUF0LFxuXG4gICAgICAgIGN1YmljUm9vdEF0OiBjdWJpY1Jvb3RBdCxcblxuICAgICAgICBjdWJpY0V4dHJlbWE6IGN1YmljRXh0cmVtYSxcblxuICAgICAgICBjdWJpY1N1YmRpdmlkZTogY3ViaWNTdWJkaXZpZGUsXG5cbiAgICAgICAgY3ViaWNQcm9qZWN0UG9pbnQ6IGN1YmljUHJvamVjdFBvaW50LFxuXG4gICAgICAgIHF1YWRyYXRpY0F0OiBxdWFkcmF0aWNBdCxcblxuICAgICAgICBxdWFkcmF0aWNEZXJpdmF0aXZlQXQ6IHF1YWRyYXRpY0Rlcml2YXRpdmVBdCxcblxuICAgICAgICBxdWFkcmF0aWNSb290QXQ6IHF1YWRyYXRpY1Jvb3RBdCxcblxuICAgICAgICBxdWFkcmF0aWNFeHRyZW11bTogcXVhZHJhdGljRXh0cmVtdW0sXG5cbiAgICAgICAgcXVhZHJhdGljU3ViZGl2aWRlOiBxdWFkcmF0aWNTdWJkaXZpZGUsXG5cbiAgICAgICAgcXVhZHJhdGljUHJvamVjdFBvaW50OiBxdWFkcmF0aWNQcm9qZWN0UG9pbnRcbiAgICB9O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34venJlbmRlci9saWIvY29yZS9jdXJ2ZS5qc1xuICoqIG1vZHVsZSBpZCA9IDI2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIEBhdXRob3IgWWkgU2hlbihodHRwczovL2dpdGh1Yi5jb20vcGlzc2FuZylcbiAqL1xuXG5cbiAgICB2YXIgdmVjMiA9IHJlcXVpcmUoJy4vdmVjdG9yJyk7XG4gICAgdmFyIGN1cnZlID0gcmVxdWlyZSgnLi9jdXJ2ZScpO1xuXG4gICAgdmFyIGJib3ggPSB7fTtcbiAgICB2YXIgbWF0aE1pbiA9IE1hdGgubWluO1xuICAgIHZhciBtYXRoTWF4ID0gTWF0aC5tYXg7XG4gICAgdmFyIG1hdGhTaW4gPSBNYXRoLnNpbjtcbiAgICB2YXIgbWF0aENvcyA9IE1hdGguY29zO1xuXG4gICAgdmFyIHN0YXJ0ID0gdmVjMi5jcmVhdGUoKTtcbiAgICB2YXIgZW5kID0gdmVjMi5jcmVhdGUoKTtcbiAgICB2YXIgZXh0cmVtaXR5ID0gdmVjMi5jcmVhdGUoKTtcblxuICAgIHZhciBQSTIgPSBNYXRoLlBJICogMjtcbiAgICAvKipcbiAgICAgKiDku47pobbngrnmlbDnu4TkuK3orqHnrpflh7rmnIDlsI/ljIXlm7Tnm5LvvIzlhpnlhaVgbWluYOWSjGBtYXhg5LitXG4gICAgICogQG1vZHVsZSB6cmVuZGVyL2NvcmUvYmJveFxuICAgICAqIEBwYXJhbSB7QXJyYXk8T2JqZWN0Pn0gcG9pbnRzIOmhtueCueaVsOe7hFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtaW5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbWF4XG4gICAgICovXG4gICAgYmJveC5mcm9tUG9pbnRzID0gZnVuY3Rpb24ocG9pbnRzLCBtaW4sIG1heCkge1xuICAgICAgICBpZiAocG9pbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwID0gcG9pbnRzWzBdO1xuICAgICAgICB2YXIgbGVmdCA9IHBbMF07XG4gICAgICAgIHZhciByaWdodCA9IHBbMF07XG4gICAgICAgIHZhciB0b3AgPSBwWzFdO1xuICAgICAgICB2YXIgYm90dG9tID0gcFsxXTtcbiAgICAgICAgdmFyIGk7XG5cbiAgICAgICAgZm9yIChpID0gMTsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcCA9IHBvaW50c1tpXTtcbiAgICAgICAgICAgIGxlZnQgPSBtYXRoTWluKGxlZnQsIHBbMF0pO1xuICAgICAgICAgICAgcmlnaHQgPSBtYXRoTWF4KHJpZ2h0LCBwWzBdKTtcbiAgICAgICAgICAgIHRvcCA9IG1hdGhNaW4odG9wLCBwWzFdKTtcbiAgICAgICAgICAgIGJvdHRvbSA9IG1hdGhNYXgoYm90dG9tLCBwWzFdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG1pblswXSA9IGxlZnQ7XG4gICAgICAgIG1pblsxXSA9IHRvcDtcbiAgICAgICAgbWF4WzBdID0gcmlnaHQ7XG4gICAgICAgIG1heFsxXSA9IGJvdHRvbTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvYmJveFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4MFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5MFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4MVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5MVxuICAgICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IG1pblxuICAgICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IG1heFxuICAgICAqL1xuICAgIGJib3guZnJvbUxpbmUgPSBmdW5jdGlvbiAoeDAsIHkwLCB4MSwgeTEsIG1pbiwgbWF4KSB7XG4gICAgICAgIG1pblswXSA9IG1hdGhNaW4oeDAsIHgxKTtcbiAgICAgICAgbWluWzFdID0gbWF0aE1pbih5MCwgeTEpO1xuICAgICAgICBtYXhbMF0gPSBtYXRoTWF4KHgwLCB4MSk7XG4gICAgICAgIG1heFsxXSA9IG1hdGhNYXgoeTAsIHkxKTtcbiAgICB9O1xuXG4gICAgdmFyIHhEaW0gPSBbXTtcbiAgICB2YXIgeURpbSA9IFtdO1xuICAgIC8qKlxuICAgICAqIOS7juS4iemYtui0neWhnuWwlOabsue6vyhwMCwgcDEsIHAyLCBwMynkuK3orqHnrpflh7rmnIDlsI/ljIXlm7Tnm5LvvIzlhpnlhaVgbWluYOWSjGBtYXhg5LitXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvYmJveFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4MFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5MFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4MVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5MVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4MlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5MlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4M1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5M1xuICAgICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IG1pblxuICAgICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IG1heFxuICAgICAqL1xuICAgIGJib3guZnJvbUN1YmljID0gZnVuY3Rpb24oXG4gICAgICAgIHgwLCB5MCwgeDEsIHkxLCB4MiwgeTIsIHgzLCB5MywgbWluLCBtYXhcbiAgICApIHtcbiAgICAgICAgdmFyIGN1YmljRXh0cmVtYSA9IGN1cnZlLmN1YmljRXh0cmVtYTtcbiAgICAgICAgdmFyIGN1YmljQXQgPSBjdXJ2ZS5jdWJpY0F0O1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgdmFyIG4gPSBjdWJpY0V4dHJlbWEoeDAsIHgxLCB4MiwgeDMsIHhEaW0pO1xuICAgICAgICBtaW5bMF0gPSBJbmZpbml0eTtcbiAgICAgICAgbWluWzFdID0gSW5maW5pdHk7XG4gICAgICAgIG1heFswXSA9IC1JbmZpbml0eTtcbiAgICAgICAgbWF4WzFdID0gLUluZmluaXR5O1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHZhciB4ID0gY3ViaWNBdCh4MCwgeDEsIHgyLCB4MywgeERpbVtpXSk7XG4gICAgICAgICAgICBtaW5bMF0gPSBtYXRoTWluKHgsIG1pblswXSk7XG4gICAgICAgICAgICBtYXhbMF0gPSBtYXRoTWF4KHgsIG1heFswXSk7XG4gICAgICAgIH1cbiAgICAgICAgbiA9IGN1YmljRXh0cmVtYSh5MCwgeTEsIHkyLCB5MywgeURpbSk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHZhciB5ID0gY3ViaWNBdCh5MCwgeTEsIHkyLCB5MywgeURpbVtpXSk7XG4gICAgICAgICAgICBtaW5bMV0gPSBtYXRoTWluKHksIG1pblsxXSk7XG4gICAgICAgICAgICBtYXhbMV0gPSBtYXRoTWF4KHksIG1heFsxXSk7XG4gICAgICAgIH1cblxuICAgICAgICBtaW5bMF0gPSBtYXRoTWluKHgwLCBtaW5bMF0pO1xuICAgICAgICBtYXhbMF0gPSBtYXRoTWF4KHgwLCBtYXhbMF0pO1xuICAgICAgICBtaW5bMF0gPSBtYXRoTWluKHgzLCBtaW5bMF0pO1xuICAgICAgICBtYXhbMF0gPSBtYXRoTWF4KHgzLCBtYXhbMF0pO1xuXG4gICAgICAgIG1pblsxXSA9IG1hdGhNaW4oeTAsIG1pblsxXSk7XG4gICAgICAgIG1heFsxXSA9IG1hdGhNYXgoeTAsIG1heFsxXSk7XG4gICAgICAgIG1pblsxXSA9IG1hdGhNaW4oeTMsIG1pblsxXSk7XG4gICAgICAgIG1heFsxXSA9IG1hdGhNYXgoeTMsIG1heFsxXSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIOS7juS6jOmYtui0neWhnuWwlOabsue6vyhwMCwgcDEsIHAyKeS4reiuoeeul+WHuuacgOWwj+WMheWbtOebku+8jOWGmeWFpWBtaW5g5ZKMYG1heGDkuK1cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS9iYm94XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHgwXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkwXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHgxXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkxXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHgyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkyXG4gICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gbWluXG4gICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gbWF4XG4gICAgICovXG4gICAgYmJveC5mcm9tUXVhZHJhdGljID0gZnVuY3Rpb24oeDAsIHkwLCB4MSwgeTEsIHgyLCB5MiwgbWluLCBtYXgpIHtcbiAgICAgICAgdmFyIHF1YWRyYXRpY0V4dHJlbXVtID0gY3VydmUucXVhZHJhdGljRXh0cmVtdW07XG4gICAgICAgIHZhciBxdWFkcmF0aWNBdCA9IGN1cnZlLnF1YWRyYXRpY0F0O1xuICAgICAgICAvLyBGaW5kIGV4dHJlbWl0aWVzLCB3aGVyZSBkZXJpdmF0aXZlIGluIHggZGltIG9yIHkgZGltIGlzIHplcm9cbiAgICAgICAgdmFyIHR4ID1cbiAgICAgICAgICAgIG1hdGhNYXgoXG4gICAgICAgICAgICAgICAgbWF0aE1pbihxdWFkcmF0aWNFeHRyZW11bSh4MCwgeDEsIHgyKSwgMSksIDBcbiAgICAgICAgICAgICk7XG4gICAgICAgIHZhciB0eSA9XG4gICAgICAgICAgICBtYXRoTWF4KFxuICAgICAgICAgICAgICAgIG1hdGhNaW4ocXVhZHJhdGljRXh0cmVtdW0oeTAsIHkxLCB5MiksIDEpLCAwXG4gICAgICAgICAgICApO1xuXG4gICAgICAgIHZhciB4ID0gcXVhZHJhdGljQXQoeDAsIHgxLCB4MiwgdHgpO1xuICAgICAgICB2YXIgeSA9IHF1YWRyYXRpY0F0KHkwLCB5MSwgeTIsIHR5KTtcblxuICAgICAgICBtaW5bMF0gPSBtYXRoTWluKHgwLCB4MiwgeCk7XG4gICAgICAgIG1pblsxXSA9IG1hdGhNaW4oeTAsIHkyLCB5KTtcbiAgICAgICAgbWF4WzBdID0gbWF0aE1heCh4MCwgeDIsIHgpO1xuICAgICAgICBtYXhbMV0gPSBtYXRoTWF4KHkwLCB5MiwgeSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIOS7juWchuW8p+S4reiuoeeul+WHuuacgOWwj+WMheWbtOebku+8jOWGmeWFpWBtaW5g5ZKMYG1heGDkuK1cbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvYmJveFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHlcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcnhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcnlcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnRBbmdsZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBlbmRBbmdsZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhbnRpY2xvY2t3aXNlXG4gICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gbWluXG4gICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gbWF4XG4gICAgICovXG4gICAgYmJveC5mcm9tQXJjID0gZnVuY3Rpb24gKFxuICAgICAgICB4LCB5LCByeCwgcnksIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBhbnRpY2xvY2t3aXNlLCBtaW4sIG1heFxuICAgICkge1xuICAgICAgICB2YXIgdmVjMk1pbiA9IHZlYzIubWluO1xuICAgICAgICB2YXIgdmVjMk1heCA9IHZlYzIubWF4O1xuXG4gICAgICAgIHZhciBkaWZmID0gTWF0aC5hYnMoc3RhcnRBbmdsZSAtIGVuZEFuZ2xlKTtcblxuXG4gICAgICAgIGlmIChkaWZmICUgUEkyIDwgMWUtNCAmJiBkaWZmID4gMWUtNCkge1xuICAgICAgICAgICAgLy8gSXMgYSBjaXJjbGVcbiAgICAgICAgICAgIG1pblswXSA9IHggLSByeDtcbiAgICAgICAgICAgIG1pblsxXSA9IHkgLSByeTtcbiAgICAgICAgICAgIG1heFswXSA9IHggKyByeDtcbiAgICAgICAgICAgIG1heFsxXSA9IHkgKyByeTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXJ0WzBdID0gbWF0aENvcyhzdGFydEFuZ2xlKSAqIHJ4ICsgeDtcbiAgICAgICAgc3RhcnRbMV0gPSBtYXRoU2luKHN0YXJ0QW5nbGUpICogcnkgKyB5O1xuXG4gICAgICAgIGVuZFswXSA9IG1hdGhDb3MoZW5kQW5nbGUpICogcnggKyB4O1xuICAgICAgICBlbmRbMV0gPSBtYXRoU2luKGVuZEFuZ2xlKSAqIHJ5ICsgeTtcblxuICAgICAgICB2ZWMyTWluKG1pbiwgc3RhcnQsIGVuZCk7XG4gICAgICAgIHZlYzJNYXgobWF4LCBzdGFydCwgZW5kKTtcblxuICAgICAgICAvLyBUaHJlc2ggdG8gWzAsIE1hdGguUEkgKiAyXVxuICAgICAgICBzdGFydEFuZ2xlID0gc3RhcnRBbmdsZSAlIChQSTIpO1xuICAgICAgICBpZiAoc3RhcnRBbmdsZSA8IDApIHtcbiAgICAgICAgICAgIHN0YXJ0QW5nbGUgPSBzdGFydEFuZ2xlICsgUEkyO1xuICAgICAgICB9XG4gICAgICAgIGVuZEFuZ2xlID0gZW5kQW5nbGUgJSAoUEkyKTtcbiAgICAgICAgaWYgKGVuZEFuZ2xlIDwgMCkge1xuICAgICAgICAgICAgZW5kQW5nbGUgPSBlbmRBbmdsZSArIFBJMjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdGFydEFuZ2xlID4gZW5kQW5nbGUgJiYgIWFudGljbG9ja3dpc2UpIHtcbiAgICAgICAgICAgIGVuZEFuZ2xlICs9IFBJMjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzdGFydEFuZ2xlIDwgZW5kQW5nbGUgJiYgYW50aWNsb2Nrd2lzZSkge1xuICAgICAgICAgICAgc3RhcnRBbmdsZSArPSBQSTI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFudGljbG9ja3dpc2UpIHtcbiAgICAgICAgICAgIHZhciB0bXAgPSBlbmRBbmdsZTtcbiAgICAgICAgICAgIGVuZEFuZ2xlID0gc3RhcnRBbmdsZTtcbiAgICAgICAgICAgIHN0YXJ0QW5nbGUgPSB0bXA7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB2YXIgbnVtYmVyID0gMDtcbiAgICAgICAgLy8gdmFyIHN0ZXAgPSAoYW50aWNsb2Nrd2lzZSA/IC1NYXRoLlBJIDogTWF0aC5QSSkgLyAyO1xuICAgICAgICBmb3IgKHZhciBhbmdsZSA9IDA7IGFuZ2xlIDwgZW5kQW5nbGU7IGFuZ2xlICs9IE1hdGguUEkgLyAyKSB7XG4gICAgICAgICAgICBpZiAoYW5nbGUgPiBzdGFydEFuZ2xlKSB7XG4gICAgICAgICAgICAgICAgZXh0cmVtaXR5WzBdID0gbWF0aENvcyhhbmdsZSkgKiByeCArIHg7XG4gICAgICAgICAgICAgICAgZXh0cmVtaXR5WzFdID0gbWF0aFNpbihhbmdsZSkgKiByeSArIHk7XG5cbiAgICAgICAgICAgICAgICB2ZWMyTWluKG1pbiwgZXh0cmVtaXR5LCBtaW4pO1xuICAgICAgICAgICAgICAgIHZlYzJNYXgobWF4LCBleHRyZW1pdHksIG1heCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBiYm94O1xuXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi96cmVuZGVyL2xpYi9jb3JlL2Jib3guanNcbiAqKiBtb2R1bGUgaWQgPSAyN1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5cbiAgICB2YXIgQ01EID0gcmVxdWlyZSgnLi4vY29yZS9QYXRoUHJveHknKS5DTUQ7XG4gICAgdmFyIGxpbmUgPSByZXF1aXJlKCcuL2xpbmUnKTtcbiAgICB2YXIgY3ViaWMgPSByZXF1aXJlKCcuL2N1YmljJyk7XG4gICAgdmFyIHF1YWRyYXRpYyA9IHJlcXVpcmUoJy4vcXVhZHJhdGljJyk7XG4gICAgdmFyIGFyYyA9IHJlcXVpcmUoJy4vYXJjJyk7XG4gICAgdmFyIG5vcm1hbGl6ZVJhZGlhbiA9IHJlcXVpcmUoJy4vdXRpbCcpLm5vcm1hbGl6ZVJhZGlhbjtcbiAgICB2YXIgY3VydmUgPSByZXF1aXJlKCcuLi9jb3JlL2N1cnZlJyk7XG5cbiAgICB2YXIgd2luZGluZ0xpbmUgPSByZXF1aXJlKCcuL3dpbmRpbmdMaW5lJyk7XG5cbiAgICB2YXIgY29udGFpblN0cm9rZSA9IGxpbmUuY29udGFpblN0cm9rZTtcblxuICAgIHZhciBQSTIgPSBNYXRoLlBJICogMjtcblxuICAgIHZhciBFUFNJTE9OID0gMWUtNDtcblxuICAgIGZ1bmN0aW9uIGlzQXJvdW5kRXF1YWwoYSwgYikge1xuICAgICAgICByZXR1cm4gTWF0aC5hYnMoYSAtIGIpIDwgRVBTSUxPTjtcbiAgICB9XG5cbiAgICAvLyDkuLTml7bmlbDnu4RcbiAgICB2YXIgcm9vdHMgPSBbLTEsIC0xLCAtMV07XG4gICAgdmFyIGV4dHJlbWEgPSBbLTEsIC0xXTtcblxuICAgIGZ1bmN0aW9uIHN3YXBFeHRyZW1hKCkge1xuICAgICAgICB2YXIgdG1wID0gZXh0cmVtYVswXTtcbiAgICAgICAgZXh0cmVtYVswXSA9IGV4dHJlbWFbMV07XG4gICAgICAgIGV4dHJlbWFbMV0gPSB0bXA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gd2luZGluZ0N1YmljKHgwLCB5MCwgeDEsIHkxLCB4MiwgeTIsIHgzLCB5MywgeCwgeSkge1xuICAgICAgICAvLyBRdWljayByZWplY3RcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgKHkgPiB5MCAmJiB5ID4geTEgJiYgeSA+IHkyICYmIHkgPiB5MylcbiAgICAgICAgICAgIHx8ICh5IDwgeTAgJiYgeSA8IHkxICYmIHkgPCB5MiAmJiB5IDwgeTMpXG4gICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5Sb290cyA9IGN1cnZlLmN1YmljUm9vdEF0KHkwLCB5MSwgeTIsIHkzLCB5LCByb290cyk7XG4gICAgICAgIGlmIChuUm9vdHMgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIHcgPSAwO1xuICAgICAgICAgICAgdmFyIG5FeHRyZW1hID0gLTE7XG4gICAgICAgICAgICB2YXIgeTBfLCB5MV87XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5Sb290czsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHQgPSByb290c1tpXTtcblxuICAgICAgICAgICAgICAgIC8vIEF2b2lkIHdpbmRpbmcgZXJyb3Igd2hlbiBpbnRlcnNlY3Rpb24gcG9pbnQgaXMgdGhlIGNvbm5lY3QgcG9pbnQgb2YgdHdvIGxpbmUgb2YgcG9seWdvblxuICAgICAgICAgICAgICAgIHZhciB1bml0ID0gKHQgPT09IDAgfHwgdCA9PT0gMSkgPyAwLjUgOiAxO1xuXG4gICAgICAgICAgICAgICAgdmFyIHhfID0gY3VydmUuY3ViaWNBdCh4MCwgeDEsIHgyLCB4MywgdCk7XG4gICAgICAgICAgICAgICAgaWYgKHhfIDwgeCkgeyAvLyBRdWljayByZWplY3RcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChuRXh0cmVtYSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbkV4dHJlbWEgPSBjdXJ2ZS5jdWJpY0V4dHJlbWEoeTAsIHkxLCB5MiwgeTMsIGV4dHJlbWEpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXh0cmVtYVsxXSA8IGV4dHJlbWFbMF0gJiYgbkV4dHJlbWEgPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzd2FwRXh0cmVtYSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHkwXyA9IGN1cnZlLmN1YmljQXQoeTAsIHkxLCB5MiwgeTMsIGV4dHJlbWFbMF0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAobkV4dHJlbWEgPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB5MV8gPSBjdXJ2ZS5jdWJpY0F0KHkwLCB5MSwgeTIsIHkzLCBleHRyZW1hWzFdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobkV4dHJlbWEgPT0gMikge1xuICAgICAgICAgICAgICAgICAgICAvLyDliIbmiJDkuInmrrXljZXosIPlh73mlbBcbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgPCBleHRyZW1hWzBdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3ICs9IHkwXyA8IHkwID8gdW5pdCA6IC11bml0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHQgPCBleHRyZW1hWzFdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3ICs9IHkxXyA8IHkwXyA/IHVuaXQgOiAtdW5pdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHcgKz0geTMgPCB5MV8gPyB1bml0IDogLXVuaXQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIOWIhuaIkOS4pOauteWNleiwg+WHveaVsFxuICAgICAgICAgICAgICAgICAgICBpZiAodCA8IGV4dHJlbWFbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHcgKz0geTBfIDwgeTAgPyB1bml0IDogLXVuaXQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3ICs9IHkzIDwgeTBfID8gdW5pdCA6IC11bml0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHc7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB3aW5kaW5nUXVhZHJhdGljKHgwLCB5MCwgeDEsIHkxLCB4MiwgeTIsIHgsIHkpIHtcbiAgICAgICAgLy8gUXVpY2sgcmVqZWN0XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgICh5ID4geTAgJiYgeSA+IHkxICYmIHkgPiB5MilcbiAgICAgICAgICAgIHx8ICh5IDwgeTAgJiYgeSA8IHkxICYmIHkgPCB5MilcbiAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgblJvb3RzID0gY3VydmUucXVhZHJhdGljUm9vdEF0KHkwLCB5MSwgeTIsIHksIHJvb3RzKTtcbiAgICAgICAgaWYgKG5Sb290cyA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgdCA9IGN1cnZlLnF1YWRyYXRpY0V4dHJlbXVtKHkwLCB5MSwgeTIpO1xuICAgICAgICAgICAgaWYgKHQgPj0gMCAmJiB0IDw9IDEpIHtcbiAgICAgICAgICAgICAgICB2YXIgdyA9IDA7XG4gICAgICAgICAgICAgICAgdmFyIHlfID0gY3VydmUucXVhZHJhdGljQXQoeTAsIHkxLCB5MiwgdCk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuUm9vdHM7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAvLyBSZW1vdmUgb25lIGVuZHBvaW50LlxuICAgICAgICAgICAgICAgICAgICB2YXIgdW5pdCA9IChyb290c1tpXSA9PT0gMCB8fCByb290c1tpXSA9PT0gMSkgPyAwLjUgOiAxO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciB4XyA9IGN1cnZlLnF1YWRyYXRpY0F0KHgwLCB4MSwgeDIsIHJvb3RzW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHhfIDwgeCkgeyAgIC8vIFF1aWNrIHJlamVjdFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHJvb3RzW2ldIDwgdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdyArPSB5XyA8IHkwID8gdW5pdCA6IC11bml0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdyArPSB5MiA8IHlfID8gdW5pdCA6IC11bml0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB3O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIG9uZSBlbmRwb2ludC5cbiAgICAgICAgICAgICAgICB2YXIgdW5pdCA9IChyb290c1swXSA9PT0gMCB8fCByb290c1swXSA9PT0gMSkgPyAwLjUgOiAxO1xuXG4gICAgICAgICAgICAgICAgdmFyIHhfID0gY3VydmUucXVhZHJhdGljQXQoeDAsIHgxLCB4Miwgcm9vdHNbMF0pO1xuICAgICAgICAgICAgICAgIGlmICh4XyA8IHgpIHsgICAvLyBRdWljayByZWplY3RcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB5MiA8IHkwID8gdW5pdCA6IC11bml0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gVE9ET1xuICAgIC8vIEFyYyDml4vovaxcbiAgICBmdW5jdGlvbiB3aW5kaW5nQXJjKFxuICAgICAgICBjeCwgY3ksIHIsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBhbnRpY2xvY2t3aXNlLCB4LCB5XG4gICAgKSB7XG4gICAgICAgIHkgLT0gY3k7XG4gICAgICAgIGlmICh5ID4gciB8fCB5IDwgLXIpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0bXAgPSBNYXRoLnNxcnQociAqIHIgLSB5ICogeSk7XG4gICAgICAgIHJvb3RzWzBdID0gLXRtcDtcbiAgICAgICAgcm9vdHNbMV0gPSB0bXA7XG5cbiAgICAgICAgdmFyIGRpZmYgPSBNYXRoLmFicyhzdGFydEFuZ2xlIC0gZW5kQW5nbGUpO1xuICAgICAgICBpZiAoZGlmZiA8IDFlLTQpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkaWZmICUgUEkyIDwgMWUtNCkge1xuICAgICAgICAgICAgLy8gSXMgYSBjaXJjbGVcbiAgICAgICAgICAgIHN0YXJ0QW5nbGUgPSAwO1xuICAgICAgICAgICAgZW5kQW5nbGUgPSBQSTI7XG4gICAgICAgICAgICB2YXIgZGlyID0gYW50aWNsb2Nrd2lzZSA/IDEgOiAtMTtcbiAgICAgICAgICAgIGlmICh4ID49IHJvb3RzWzBdICsgY3ggJiYgeCA8PSByb290c1sxXSArIGN4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRpcjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYW50aWNsb2Nrd2lzZSkge1xuICAgICAgICAgICAgdmFyIHRtcCA9IHN0YXJ0QW5nbGU7XG4gICAgICAgICAgICBzdGFydEFuZ2xlID0gbm9ybWFsaXplUmFkaWFuKGVuZEFuZ2xlKTtcbiAgICAgICAgICAgIGVuZEFuZ2xlID0gbm9ybWFsaXplUmFkaWFuKHRtcCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdGFydEFuZ2xlID0gbm9ybWFsaXplUmFkaWFuKHN0YXJ0QW5nbGUpO1xuICAgICAgICAgICAgZW5kQW5nbGUgPSBub3JtYWxpemVSYWRpYW4oZW5kQW5nbGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGFydEFuZ2xlID4gZW5kQW5nbGUpIHtcbiAgICAgICAgICAgIGVuZEFuZ2xlICs9IFBJMjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB3ID0gMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAyOyBpKyspIHtcbiAgICAgICAgICAgIHZhciB4XyA9IHJvb3RzW2ldO1xuICAgICAgICAgICAgaWYgKHhfICsgY3ggPiB4KSB7XG4gICAgICAgICAgICAgICAgdmFyIGFuZ2xlID0gTWF0aC5hdGFuMih5LCB4Xyk7XG4gICAgICAgICAgICAgICAgdmFyIGRpciA9IGFudGljbG9ja3dpc2UgPyAxIDogLTE7XG4gICAgICAgICAgICAgICAgaWYgKGFuZ2xlIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBhbmdsZSA9IFBJMiArIGFuZ2xlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgIChhbmdsZSA+PSBzdGFydEFuZ2xlICYmIGFuZ2xlIDw9IGVuZEFuZ2xlKVxuICAgICAgICAgICAgICAgICAgICB8fCAoYW5nbGUgKyBQSTIgPj0gc3RhcnRBbmdsZSAmJiBhbmdsZSArIFBJMiA8PSBlbmRBbmdsZSlcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFuZ2xlID4gTWF0aC5QSSAvIDIgJiYgYW5nbGUgPCBNYXRoLlBJICogMS41KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaXIgPSAtZGlyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHcgKz0gZGlyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb250YWluUGF0aChkYXRhLCBsaW5lV2lkdGgsIGlzU3Ryb2tlLCB4LCB5KSB7XG4gICAgICAgIHZhciB3ID0gMDtcbiAgICAgICAgdmFyIHhpID0gMDtcbiAgICAgICAgdmFyIHlpID0gMDtcbiAgICAgICAgdmFyIHgwID0gMDtcbiAgICAgICAgdmFyIHkwID0gMDtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOykge1xuICAgICAgICAgICAgdmFyIGNtZCA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgIC8vIEJlZ2luIGEgbmV3IHN1YnBhdGhcbiAgICAgICAgICAgIGlmIChjbWQgPT09IENNRC5NICYmIGkgPiAxKSB7XG4gICAgICAgICAgICAgICAgLy8gQ2xvc2UgcHJldmlvdXMgc3VicGF0aFxuICAgICAgICAgICAgICAgIGlmICghaXNTdHJva2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdyArPSB3aW5kaW5nTGluZSh4aSwgeWksIHgwLCB5MCwgeCwgeSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIOWmguaenOiiq+S7u+S9leS4gOS4qiBzdWJwYXRoIOWMheWQq1xuICAgICAgICAgICAgICAgIC8vIGlmICh3ICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGkgPT0gMSkge1xuICAgICAgICAgICAgICAgIC8vIOWmguaenOesrOS4gOS4quWRveS7pOaYryBMLCBDLCBRXG4gICAgICAgICAgICAgICAgLy8g5YiZIHByZXZpb3VzIHBvaW50IOWQjOe7mOWItuWRveS7pOeahOesrOS4gOS4qiBwb2ludFxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8g56ys5LiA5Liq5ZG95Luk5Li6IEFyYyDnmoTmg4XlhrXkuIvkvJrlnKjlkI7pnaLnibnmrorlpITnkIZcbiAgICAgICAgICAgICAgICB4aSA9IGRhdGFbaV07XG4gICAgICAgICAgICAgICAgeWkgPSBkYXRhW2kgKyAxXTtcblxuICAgICAgICAgICAgICAgIHgwID0geGk7XG4gICAgICAgICAgICAgICAgeTAgPSB5aTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc3dpdGNoIChjbWQpIHtcbiAgICAgICAgICAgICAgICBjYXNlIENNRC5NOlxuICAgICAgICAgICAgICAgICAgICAvLyBtb3ZlVG8g5ZG95Luk6YeN5paw5Yib5bu65LiA5Liq5paw55qEIHN1YnBhdGgsIOW5tuS4lOabtOaWsOaWsOeahOi1t+eCuVxuICAgICAgICAgICAgICAgICAgICAvLyDlnKggY2xvc2VQYXRoIOeahOaXtuWAmeS9v+eUqFxuICAgICAgICAgICAgICAgICAgICB4MCA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgeTAgPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgIHhpID0geDA7XG4gICAgICAgICAgICAgICAgICAgIHlpID0geTA7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgQ01ELkw6XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1N0cm9rZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRhaW5TdHJva2UoeGksIHlpLCBkYXRhW2ldLCBkYXRhW2kgKyAxXSwgbGluZVdpZHRoLCB4LCB5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTk9URSDlnKjnrKzkuIDkuKrlkb3ku6TkuLogTCwgQywgUSDnmoTml7blgJnkvJrorqHnrpflh7ogTmFOXG4gICAgICAgICAgICAgICAgICAgICAgICB3ICs9IHdpbmRpbmdMaW5lKHhpLCB5aSwgZGF0YVtpXSwgZGF0YVtpICsgMV0sIHgsIHkpIHx8IDA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgeGkgPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgIHlpID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIENNRC5DOlxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNTdHJva2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdWJpYy5jb250YWluU3Ryb2tlKHhpLCB5aSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhW2krK10sIGRhdGFbaSsrXSwgZGF0YVtpKytdLCBkYXRhW2krK10sIGRhdGFbaV0sIGRhdGFbaSArIDFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVXaWR0aCwgeCwgeVxuICAgICAgICAgICAgICAgICAgICAgICAgKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdyArPSB3aW5kaW5nQ3ViaWMoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeGksIHlpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFbaSsrXSwgZGF0YVtpKytdLCBkYXRhW2krK10sIGRhdGFbaSsrXSwgZGF0YVtpXSwgZGF0YVtpICsgMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeCwgeVxuICAgICAgICAgICAgICAgICAgICAgICAgKSB8fCAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHhpID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICB5aSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBDTUQuUTpcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzU3Ryb2tlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocXVhZHJhdGljLmNvbnRhaW5TdHJva2UoeGksIHlpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFbaSsrXSwgZGF0YVtpKytdLCBkYXRhW2ldLCBkYXRhW2kgKyAxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lV2lkdGgsIHgsIHlcbiAgICAgICAgICAgICAgICAgICAgICAgICkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHcgKz0gd2luZGluZ1F1YWRyYXRpYyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4aSwgeWksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVtpKytdLCBkYXRhW2krK10sIGRhdGFbaV0sIGRhdGFbaSArIDFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHgsIHlcbiAgICAgICAgICAgICAgICAgICAgICAgICkgfHwgMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB4aSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgeWkgPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgQ01ELkE6XG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gQXJjIOWIpOaWreeahOW8gOmUgOavlOi+g+Wkp1xuICAgICAgICAgICAgICAgICAgICB2YXIgY3ggPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgIHZhciBjeSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJ4ID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcnkgPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgIHZhciB0aGV0YSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRUaGV0YSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyBBcmMg5peL6L2sXG4gICAgICAgICAgICAgICAgICAgIHZhciBwc2kgPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgIHZhciBhbnRpY2xvY2t3aXNlID0gMSAtIGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHgxID0gTWF0aC5jb3ModGhldGEpICogcnggKyBjeDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHkxID0gTWF0aC5zaW4odGhldGEpICogcnkgKyBjeTtcbiAgICAgICAgICAgICAgICAgICAgLy8g5LiN5piv55u05o6l5L2/55SoIGFyYyDlkb3ku6RcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3ICs9IHdpbmRpbmdMaW5lKHhpLCB5aSwgeDEsIHkxLCB4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIOesrOS4gOS4quWRveS7pOi1t+eCuei/mOacquWumuS5iVxuICAgICAgICAgICAgICAgICAgICAgICAgeDAgPSB4MTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHkwID0geTE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8genIg5L2/55Soc2NhbGXmnaXmqKHmi5/mpK3lnIYsIOi/memHjOS5n+WvuXjlgZrkuIDlrprnmoTnvKnmlL5cbiAgICAgICAgICAgICAgICAgICAgdmFyIF94ID0gKHggLSBjeCkgKiByeSAvIHJ4ICsgY3g7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1N0cm9rZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFyYy5jb250YWluU3Ryb2tlKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN4LCBjeSwgcnksIHRoZXRhLCB0aGV0YSArIGRUaGV0YSwgYW50aWNsb2Nrd2lzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lV2lkdGgsIF94LCB5XG4gICAgICAgICAgICAgICAgICAgICAgICApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3ICs9IHdpbmRpbmdBcmMoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3gsIGN5LCByeSwgdGhldGEsIHRoZXRhICsgZFRoZXRhLCBhbnRpY2xvY2t3aXNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF94LCB5XG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHhpID0gTWF0aC5jb3ModGhldGEgKyBkVGhldGEpICogcnggKyBjeDtcbiAgICAgICAgICAgICAgICAgICAgeWkgPSBNYXRoLnNpbih0aGV0YSArIGRUaGV0YSkgKiByeSArIGN5O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIENNRC5SOlxuICAgICAgICAgICAgICAgICAgICB4MCA9IHhpID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICB5MCA9IHlpID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgd2lkdGggPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgIHZhciBoZWlnaHQgPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgIHZhciB4MSA9IHgwICsgd2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIHZhciB5MSA9IHkwICsgaGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNTdHJva2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb250YWluU3Ryb2tlKHgwLCB5MCwgeDEsIHkwLCBsaW5lV2lkdGgsIHgsIHkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHx8IGNvbnRhaW5TdHJva2UoeDEsIHkwLCB4MSwgeTEsIGxpbmVXaWR0aCwgeCwgeSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfHwgY29udGFpblN0cm9rZSh4MSwgeTEsIHgwLCB5MSwgbGluZVdpZHRoLCB4LCB5KVxuICAgICAgICAgICAgICAgICAgICAgICAgICB8fCBjb250YWluU3Ryb2tlKHgwLCB5MSwgeDAsIHkwLCBsaW5lV2lkdGgsIHgsIHkpXG4gICAgICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZJWE1FIENsb2Nrd2lzZSA/XG4gICAgICAgICAgICAgICAgICAgICAgICB3ICs9IHdpbmRpbmdMaW5lKHgxLCB5MCwgeDEsIHkxLCB4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHcgKz0gd2luZGluZ0xpbmUoeDAsIHkxLCB4MCwgeTAsIHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgQ01ELlo6XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1N0cm9rZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRhaW5TdHJva2UoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeGksIHlpLCB4MCwgeTAsIGxpbmVXaWR0aCwgeCwgeVxuICAgICAgICAgICAgICAgICAgICAgICAgKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2xvc2UgYSBzdWJwYXRoXG4gICAgICAgICAgICAgICAgICAgICAgICB3ICs9IHdpbmRpbmdMaW5lKHhpLCB5aSwgeDAsIHkwLCB4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIOWmguaenOiiq+S7u+S9leS4gOS4qiBzdWJwYXRoIOWMheWQq1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRklYTUUgc3VicGF0aHMgbWF5IG92ZXJsYXBcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmICh3ICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgeGkgPSB4MDtcbiAgICAgICAgICAgICAgICAgICAgeWkgPSB5MDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1N0cm9rZSAmJiAhaXNBcm91bmRFcXVhbCh5aSwgeTApKSB7XG4gICAgICAgICAgICB3ICs9IHdpbmRpbmdMaW5lKHhpLCB5aSwgeDAsIHkwLCB4LCB5KSB8fCAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3ICE9PSAwO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0ge1xuICAgICAgICBjb250YWluOiBmdW5jdGlvbiAocGF0aERhdGEsIHgsIHkpIHtcbiAgICAgICAgICAgIHJldHVybiBjb250YWluUGF0aChwYXRoRGF0YSwgMCwgZmFsc2UsIHgsIHkpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNvbnRhaW5TdHJva2U6IGZ1bmN0aW9uIChwYXRoRGF0YSwgbGluZVdpZHRoLCB4LCB5KSB7XG4gICAgICAgICAgICByZXR1cm4gY29udGFpblBhdGgocGF0aERhdGEsIGxpbmVXaWR0aCwgdHJ1ZSwgeCwgeSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34venJlbmRlci9saWIvY29udGFpbi9wYXRoLmpzXG4gKiogbW9kdWxlIGlkID0gMjhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlxuICAgIG1vZHVsZS5leHBvcnRzID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICog57q/5q615YyF5ZCr5Yik5patXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gIHgwXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gIHkwXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gIHgxXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gIHkxXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gIGxpbmVXaWR0aFxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9ICB4XG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gIHlcbiAgICAgICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIGNvbnRhaW5TdHJva2U6IGZ1bmN0aW9uICh4MCwgeTAsIHgxLCB5MSwgbGluZVdpZHRoLCB4LCB5KSB7XG4gICAgICAgICAgICBpZiAobGluZVdpZHRoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIF9sID0gbGluZVdpZHRoO1xuICAgICAgICAgICAgdmFyIF9hID0gMDtcbiAgICAgICAgICAgIHZhciBfYiA9IHgwO1xuICAgICAgICAgICAgLy8gUXVpY2sgcmVqZWN0XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgKHkgPiB5MCArIF9sICYmIHkgPiB5MSArIF9sKVxuICAgICAgICAgICAgICAgIHx8ICh5IDwgeTAgLSBfbCAmJiB5IDwgeTEgLSBfbClcbiAgICAgICAgICAgICAgICB8fCAoeCA+IHgwICsgX2wgJiYgeCA+IHgxICsgX2wpXG4gICAgICAgICAgICAgICAgfHwgKHggPCB4MCAtIF9sICYmIHggPCB4MSAtIF9sKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoeDAgIT09IHgxKSB7XG4gICAgICAgICAgICAgICAgX2EgPSAoeTAgLSB5MSkgLyAoeDAgLSB4MSk7XG4gICAgICAgICAgICAgICAgX2IgPSAoeDAgKiB5MSAtIHgxICogeTApIC8gKHgwIC0geDEpIDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLmFicyh4IC0geDApIDw9IF9sIC8gMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB0bXAgPSBfYSAqIHggLSB5ICsgX2I7XG4gICAgICAgICAgICB2YXIgX3MgPSB0bXAgKiB0bXAgLyAoX2EgKiBfYSArIDEpO1xuICAgICAgICAgICAgcmV0dXJuIF9zIDw9IF9sIC8gMiAqIF9sIC8gMjtcbiAgICAgICAgfVxuICAgIH07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi96cmVuZGVyL2xpYi9jb250YWluL2xpbmUuanNcbiAqKiBtb2R1bGUgaWQgPSAyOVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXG5cbiAgICB2YXIgY3VydmUgPSByZXF1aXJlKCcuLi9jb3JlL2N1cnZlJyk7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOS4ieasoei0neWhnuWwlOabsue6v+aPj+i+ueWMheWQq+WIpOaWrVxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9ICB4MFxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9ICB5MFxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9ICB4MVxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9ICB5MVxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9ICB4MlxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9ICB5MlxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9ICB4M1xuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9ICB5M1xuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9ICBsaW5lV2lkdGhcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSAgeFxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9ICB5XG4gICAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICBjb250YWluU3Ryb2tlOiBmdW5jdGlvbih4MCwgeTAsIHgxLCB5MSwgeDIsIHkyLCB4MywgeTMsIGxpbmVXaWR0aCwgeCwgeSkge1xuICAgICAgICAgICAgaWYgKGxpbmVXaWR0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBfbCA9IGxpbmVXaWR0aDtcbiAgICAgICAgICAgIC8vIFF1aWNrIHJlamVjdFxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICh5ID4geTAgKyBfbCAmJiB5ID4geTEgKyBfbCAmJiB5ID4geTIgKyBfbCAmJiB5ID4geTMgKyBfbClcbiAgICAgICAgICAgICAgICB8fCAoeSA8IHkwIC0gX2wgJiYgeSA8IHkxIC0gX2wgJiYgeSA8IHkyIC0gX2wgJiYgeSA8IHkzIC0gX2wpXG4gICAgICAgICAgICAgICAgfHwgKHggPiB4MCArIF9sICYmIHggPiB4MSArIF9sICYmIHggPiB4MiArIF9sICYmIHggPiB4MyArIF9sKVxuICAgICAgICAgICAgICAgIHx8ICh4IDwgeDAgLSBfbCAmJiB4IDwgeDEgLSBfbCAmJiB4IDwgeDIgLSBfbCAmJiB4IDwgeDMgLSBfbClcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBkID0gY3VydmUuY3ViaWNQcm9qZWN0UG9pbnQoXG4gICAgICAgICAgICAgICAgeDAsIHkwLCB4MSwgeTEsIHgyLCB5MiwgeDMsIHkzLFxuICAgICAgICAgICAgICAgIHgsIHksIG51bGxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICByZXR1cm4gZCA8PSBfbCAvIDI7XG4gICAgICAgIH1cbiAgICB9O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34venJlbmRlci9saWIvY29udGFpbi9jdWJpYy5qc1xuICoqIG1vZHVsZSBpZCA9IDMwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcblxuICAgIHZhciBjdXJ2ZSA9IHJlcXVpcmUoJy4uL2NvcmUvY3VydmUnKTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICog5LqM5qyh6LSd5aGe5bCU5puy57q/5o+P6L655YyF5ZCr5Yik5patXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gIHgwXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gIHkwXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gIHgxXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gIHkxXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gIHgyXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gIHkyXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gIGxpbmVXaWR0aFxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9ICB4XG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gIHlcbiAgICAgICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIGNvbnRhaW5TdHJva2U6IGZ1bmN0aW9uICh4MCwgeTAsIHgxLCB5MSwgeDIsIHkyLCBsaW5lV2lkdGgsIHgsIHkpIHtcbiAgICAgICAgICAgIGlmIChsaW5lV2lkdGggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgX2wgPSBsaW5lV2lkdGg7XG4gICAgICAgICAgICAvLyBRdWljayByZWplY3RcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAoeSA+IHkwICsgX2wgJiYgeSA+IHkxICsgX2wgJiYgeSA+IHkyICsgX2wpXG4gICAgICAgICAgICAgICAgfHwgKHkgPCB5MCAtIF9sICYmIHkgPCB5MSAtIF9sICYmIHkgPCB5MiAtIF9sKVxuICAgICAgICAgICAgICAgIHx8ICh4ID4geDAgKyBfbCAmJiB4ID4geDEgKyBfbCAmJiB4ID4geDIgKyBfbClcbiAgICAgICAgICAgICAgICB8fCAoeCA8IHgwIC0gX2wgJiYgeCA8IHgxIC0gX2wgJiYgeCA8IHgyIC0gX2wpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZCA9IGN1cnZlLnF1YWRyYXRpY1Byb2plY3RQb2ludChcbiAgICAgICAgICAgICAgICB4MCwgeTAsIHgxLCB5MSwgeDIsIHkyLFxuICAgICAgICAgICAgICAgIHgsIHksIG51bGxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICByZXR1cm4gZCA8PSBfbCAvIDI7XG4gICAgICAgIH1cbiAgICB9O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34venJlbmRlci9saWIvY29udGFpbi9xdWFkcmF0aWMuanNcbiAqKiBtb2R1bGUgaWQgPSAzMVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXG5cbiAgICB2YXIgbm9ybWFsaXplUmFkaWFuID0gcmVxdWlyZSgnLi91dGlsJykubm9ybWFsaXplUmFkaWFuO1xuICAgIHZhciBQSTIgPSBNYXRoLlBJICogMjtcblxuICAgIG1vZHVsZS5leHBvcnRzID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICog5ZyG5byn5o+P6L655YyF5ZCr5Yik5patXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gIGN4XG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gIGN5XG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gIHJcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSAgc3RhcnRBbmdsZVxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9ICBlbmRBbmdsZVxuICAgICAgICAgKiBAcGFyYW0gIHtib29sZWFufSAgYW50aWNsb2Nrd2lzZVxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IGxpbmVXaWR0aFxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9ICB4XG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gIHlcbiAgICAgICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIGNvbnRhaW5TdHJva2U6IGZ1bmN0aW9uIChcbiAgICAgICAgICAgIGN4LCBjeSwgciwgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGFudGljbG9ja3dpc2UsXG4gICAgICAgICAgICBsaW5lV2lkdGgsIHgsIHlcbiAgICAgICAgKSB7XG5cbiAgICAgICAgICAgIGlmIChsaW5lV2lkdGggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgX2wgPSBsaW5lV2lkdGg7XG5cbiAgICAgICAgICAgIHggLT0gY3g7XG4gICAgICAgICAgICB5IC09IGN5O1xuICAgICAgICAgICAgdmFyIGQgPSBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSk7XG5cbiAgICAgICAgICAgIGlmICgoZCAtIF9sID4gcikgfHwgKGQgKyBfbCA8IHIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKE1hdGguYWJzKHN0YXJ0QW5nbGUgLSBlbmRBbmdsZSkgJSBQSTIgPCAxZS00KSB7XG4gICAgICAgICAgICAgICAgLy8gSXMgYSBjaXJjbGVcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhbnRpY2xvY2t3aXNlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRtcCA9IHN0YXJ0QW5nbGU7XG4gICAgICAgICAgICAgICAgc3RhcnRBbmdsZSA9IG5vcm1hbGl6ZVJhZGlhbihlbmRBbmdsZSk7XG4gICAgICAgICAgICAgICAgZW5kQW5nbGUgPSBub3JtYWxpemVSYWRpYW4odG1wKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc3RhcnRBbmdsZSA9IG5vcm1hbGl6ZVJhZGlhbihzdGFydEFuZ2xlKTtcbiAgICAgICAgICAgICAgICBlbmRBbmdsZSA9IG5vcm1hbGl6ZVJhZGlhbihlbmRBbmdsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RhcnRBbmdsZSA+IGVuZEFuZ2xlKSB7XG4gICAgICAgICAgICAgICAgZW5kQW5nbGUgKz0gUEkyO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgYW5nbGUgPSBNYXRoLmF0YW4yKHksIHgpO1xuICAgICAgICAgICAgaWYgKGFuZ2xlIDwgMCkge1xuICAgICAgICAgICAgICAgIGFuZ2xlICs9IFBJMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAoYW5nbGUgPj0gc3RhcnRBbmdsZSAmJiBhbmdsZSA8PSBlbmRBbmdsZSlcbiAgICAgICAgICAgICAgICB8fCAoYW5nbGUgKyBQSTIgPj0gc3RhcnRBbmdsZSAmJiBhbmdsZSArIFBJMiA8PSBlbmRBbmdsZSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34venJlbmRlci9saWIvY29udGFpbi9hcmMuanNcbiAqKiBtb2R1bGUgaWQgPSAzMlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXG5cbiAgICB2YXIgUEkyID0gTWF0aC5QSSAqIDI7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgICAgIG5vcm1hbGl6ZVJhZGlhbjogZnVuY3Rpb24oYW5nbGUpIHtcbiAgICAgICAgICAgIGFuZ2xlICU9IFBJMjtcbiAgICAgICAgICAgIGlmIChhbmdsZSA8IDApIHtcbiAgICAgICAgICAgICAgICBhbmdsZSArPSBQSTI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYW5nbGU7XG4gICAgICAgIH1cbiAgICB9O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34venJlbmRlci9saWIvY29udGFpbi91dGlsLmpzXG4gKiogbW9kdWxlIGlkID0gMzNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlxuICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gd2luZGluZ0xpbmUoeDAsIHkwLCB4MSwgeTEsIHgsIHkpIHtcbiAgICAgICAgaWYgKCh5ID4geTAgJiYgeSA+IHkxKSB8fCAoeSA8IHkwICYmIHkgPCB5MSkpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIElnbm9yZSBob3Jpem9udGFsIGxpbmVcbiAgICAgICAgaWYgKHkxID09PSB5MCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRpciA9IHkxIDwgeTAgPyAxIDogLTE7XG4gICAgICAgIHZhciB0ID0gKHkgLSB5MCkgLyAoeTEgLSB5MCk7XG5cbiAgICAgICAgLy8gQXZvaWQgd2luZGluZyBlcnJvciB3aGVuIGludGVyc2VjdGlvbiBwb2ludCBpcyB0aGUgY29ubmVjdCBwb2ludCBvZiB0d28gbGluZSBvZiBwb2x5Z29uXG4gICAgICAgIGlmICh0ID09PSAxIHx8IHQgPT09IDApIHtcbiAgICAgICAgICAgIGRpciA9IHkxIDwgeTAgPyAwLjUgOiAtMC41O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHhfID0gdCAqICh4MSAtIHgwKSArIHgwO1xuXG4gICAgICAgIHJldHVybiB4XyA+IHggPyBkaXIgOiAwO1xuICAgIH07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi96cmVuZGVyL2xpYi9jb250YWluL3dpbmRpbmdMaW5lLmpzXG4gKiogbW9kdWxlIGlkID0gMzRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlxuXG4gICAgdmFyIFBhdHRlcm4gPSBmdW5jdGlvbiAoaW1hZ2UsIHJlcGVhdCkge1xuICAgICAgICB0aGlzLmltYWdlID0gaW1hZ2U7XG4gICAgICAgIHRoaXMucmVwZWF0ID0gcmVwZWF0O1xuXG4gICAgICAgIC8vIENhbiBiZSBjbG9uZWRcbiAgICAgICAgdGhpcy50eXBlID0gJ3BhdHRlcm4nO1xuICAgIH07XG5cbiAgICBQYXR0ZXJuLnByb3RvdHlwZS5nZXRDYW52YXNQYXR0ZXJuID0gZnVuY3Rpb24gKGN0eCkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLl9jYW52YXNQYXR0ZXJuXG4gICAgICAgICAgICB8fCAodGhpcy5fY2FudmFzUGF0dGVybiA9IGN0eC5jcmVhdGVQYXR0ZXJuKHRoaXMuaW1hZ2UsIHRoaXMucmVwZWF0KSk7XG4gICAgfTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gUGF0dGVybjtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvUGF0dGVybi5qc1xuICoqIG1vZHVsZSBpZCA9IDM1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcblxuICAgIHZhciBDTUQgPSByZXF1aXJlKCcuLi9jb3JlL1BhdGhQcm94eScpLkNNRDtcbiAgICB2YXIgdmVjMiA9IHJlcXVpcmUoJy4uL2NvcmUvdmVjdG9yJyk7XG4gICAgdmFyIHYyQXBwbHlUcmFuc2Zvcm0gPSB2ZWMyLmFwcGx5VHJhbnNmb3JtO1xuXG4gICAgdmFyIHBvaW50cyA9IFtbXSwgW10sIFtdXTtcbiAgICB2YXIgbWF0aFNxcnQgPSBNYXRoLnNxcnQ7XG4gICAgdmFyIG1hdGhBdGFuMiA9IE1hdGguYXRhbjI7XG4gICAgZnVuY3Rpb24gdHJhbnNmb3JtUGF0aChwYXRoLCBtKSB7XG4gICAgICAgIHZhciBkYXRhID0gcGF0aC5kYXRhO1xuICAgICAgICB2YXIgY21kO1xuICAgICAgICB2YXIgblBvaW50O1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgdmFyIGo7XG4gICAgICAgIHZhciBrO1xuICAgICAgICB2YXIgcDtcblxuICAgICAgICB2YXIgTSA9IENNRC5NO1xuICAgICAgICB2YXIgQyA9IENNRC5DO1xuICAgICAgICB2YXIgTCA9IENNRC5MO1xuICAgICAgICB2YXIgUiA9IENNRC5SO1xuICAgICAgICB2YXIgQSA9IENNRC5BO1xuICAgICAgICB2YXIgUSA9IENNRC5RO1xuXG4gICAgICAgIGZvciAoaSA9IDAsIGogPSAwOyBpIDwgZGF0YS5sZW5ndGg7KSB7XG4gICAgICAgICAgICBjbWQgPSBkYXRhW2krK107XG4gICAgICAgICAgICBqID0gaTtcbiAgICAgICAgICAgIG5Qb2ludCA9IDA7XG5cbiAgICAgICAgICAgIHN3aXRjaCAoY21kKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBNOlxuICAgICAgICAgICAgICAgICAgICBuUG9pbnQgPSAxO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIEw6XG4gICAgICAgICAgICAgICAgICAgIG5Qb2ludCA9IDE7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgQzpcbiAgICAgICAgICAgICAgICAgICAgblBvaW50ID0gMztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBROlxuICAgICAgICAgICAgICAgICAgICBuUG9pbnQgPSAyO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIEE6XG4gICAgICAgICAgICAgICAgICAgIHZhciB4ID0gbVs0XTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHkgPSBtWzVdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3ggPSBtYXRoU3FydChtWzBdICogbVswXSArIG1bMV0gKiBtWzFdKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN5ID0gbWF0aFNxcnQobVsyXSAqIG1bMl0gKyBtWzNdICogbVszXSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhbmdsZSA9IG1hdGhBdGFuMigtbVsxXSAvIHN5LCBtWzBdIC8gc3gpO1xuICAgICAgICAgICAgICAgICAgICAvLyBjeFxuICAgICAgICAgICAgICAgICAgICBkYXRhW2krK10gKz0geDtcbiAgICAgICAgICAgICAgICAgICAgLy8gY3lcbiAgICAgICAgICAgICAgICAgICAgZGF0YVtpKytdICs9IHk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNjYWxlIHJ4IGFuZCByeVxuICAgICAgICAgICAgICAgICAgICAvLyBGSVhNRSBBc3N1bWUgcHNpIGlzIDAgaGVyZVxuICAgICAgICAgICAgICAgICAgICBkYXRhW2krK10gKj0gc3g7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFbaSsrXSAqPSBzeTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBTdGFydCBhbmdsZVxuICAgICAgICAgICAgICAgICAgICBkYXRhW2krK10gKz0gYW5nbGU7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVuZCBhbmdsZVxuICAgICAgICAgICAgICAgICAgICBkYXRhW2krK10gKz0gYW5nbGU7XG4gICAgICAgICAgICAgICAgICAgIC8vIEZJWE1FIHBzaVxuICAgICAgICAgICAgICAgICAgICBpICs9IDI7XG4gICAgICAgICAgICAgICAgICAgIGogPSBpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFI6XG4gICAgICAgICAgICAgICAgICAgIC8vIHgwLCB5MFxuICAgICAgICAgICAgICAgICAgICBwWzBdID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICBwWzFdID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICB2MkFwcGx5VHJhbnNmb3JtKHAsIHAsIG0pO1xuICAgICAgICAgICAgICAgICAgICBkYXRhW2orK10gPSBwWzBdO1xuICAgICAgICAgICAgICAgICAgICBkYXRhW2orK10gPSBwWzFdO1xuICAgICAgICAgICAgICAgICAgICAvLyB4MSwgeTFcbiAgICAgICAgICAgICAgICAgICAgcFswXSArPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgIHBbMV0gKz0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICB2MkFwcGx5VHJhbnNmb3JtKHAsIHAsIG0pO1xuICAgICAgICAgICAgICAgICAgICBkYXRhW2orK10gPSBwWzBdO1xuICAgICAgICAgICAgICAgICAgICBkYXRhW2orK10gPSBwWzFdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKGsgPSAwOyBrIDwgblBvaW50OyBrKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgcCA9IHBvaW50c1trXTtcbiAgICAgICAgICAgICAgICBwWzBdID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgIHBbMV0gPSBkYXRhW2krK107XG5cbiAgICAgICAgICAgICAgICB2MkFwcGx5VHJhbnNmb3JtKHAsIHAsIG0pO1xuICAgICAgICAgICAgICAgIC8vIFdyaXRlIGJhY2tcbiAgICAgICAgICAgICAgICBkYXRhW2orK10gPSBwWzBdO1xuICAgICAgICAgICAgICAgIGRhdGFbaisrXSA9IHBbMV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHRyYW5zZm9ybVBhdGg7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi96cmVuZGVyL2xpYi90b29sL3RyYW5zZm9ybVBhdGguanNcbiAqKiBtb2R1bGUgaWQgPSAzNlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxPYmplY3Q+fSBjb2xvclN0b3BzXG4gICAgICovXG4gICAgdmFyIEdyYWRpZW50ID0gZnVuY3Rpb24gKGNvbG9yU3RvcHMpIHtcblxuICAgICAgICB0aGlzLmNvbG9yU3RvcHMgPSBjb2xvclN0b3BzIHx8IFtdO1xuICAgIH07XG5cbiAgICBHcmFkaWVudC5wcm90b3R5cGUgPSB7XG5cbiAgICAgICAgY29uc3RydWN0b3I6IEdyYWRpZW50LFxuXG4gICAgICAgIGFkZENvbG9yU3RvcDogZnVuY3Rpb24gKG9mZnNldCwgY29sb3IpIHtcbiAgICAgICAgICAgIHRoaXMuY29sb3JTdG9wcy5wdXNoKHtcblxuICAgICAgICAgICAgICAgIG9mZnNldDogb2Zmc2V0LFxuXG4gICAgICAgICAgICAgICAgY29sb3I6IGNvbG9yXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IEdyYWRpZW50O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34venJlbmRlci9saWIvZ3JhcGhpYy9HcmFkaWVudC5qc1xuICoqIG1vZHVsZSBpZCA9IDM3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBUT0RPIERyYWdnYWJsZSBmb3IgZ3JvdXBcbi8vIEZJWE1FIERyYWdnYWJsZSBvbiBlbGVtZW50IHdoaWNoIGhhcyBwYXJlbnQgcm90YXRpb24gb3Igc2NhbGVcblxuICAgIGZ1bmN0aW9uIERyYWdnYWJsZSgpIHtcblxuICAgICAgICB0aGlzLm9uKCdtb3VzZWRvd24nLCB0aGlzLl9kcmFnU3RhcnQsIHRoaXMpO1xuICAgICAgICB0aGlzLm9uKCdtb3VzZW1vdmUnLCB0aGlzLl9kcmFnLCB0aGlzKTtcbiAgICAgICAgdGhpcy5vbignbW91c2V1cCcsIHRoaXMuX2RyYWdFbmQsIHRoaXMpO1xuICAgICAgICB0aGlzLm9uKCdnbG9iYWxvdXQnLCB0aGlzLl9kcmFnRW5kLCB0aGlzKTtcbiAgICAgICAgLy8gdGhpcy5fZHJvcFRhcmdldCA9IG51bGw7XG4gICAgICAgIC8vIHRoaXMuX2RyYWdnaW5nVGFyZ2V0ID0gbnVsbDtcblxuICAgICAgICAvLyB0aGlzLl94ID0gMDtcbiAgICAgICAgLy8gdGhpcy5feSA9IDA7XG4gICAgfVxuXG4gICAgRHJhZ2dhYmxlLnByb3RvdHlwZSA9IHtcblxuICAgICAgICBjb25zdHJ1Y3RvcjogRHJhZ2dhYmxlLFxuXG4gICAgICAgIF9kcmFnU3RhcnQ6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICB2YXIgZHJhZ2dpbmdUYXJnZXQgPSBlLnRhcmdldDtcbiAgICAgICAgICAgIGlmIChkcmFnZ2luZ1RhcmdldCAmJiBkcmFnZ2luZ1RhcmdldC5kcmFnZ2FibGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9kcmFnZ2luZ1RhcmdldCA9IGRyYWdnaW5nVGFyZ2V0O1xuICAgICAgICAgICAgICAgIGRyYWdnaW5nVGFyZ2V0LmRyYWdnaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLl94ID0gZS5vZmZzZXRYO1xuICAgICAgICAgICAgICAgIHRoaXMuX3kgPSBlLm9mZnNldFk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoVG9FbGVtZW50KGRyYWdnaW5nVGFyZ2V0LCAnZHJhZ3N0YXJ0JywgZS5ldmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2RyYWc6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICB2YXIgZHJhZ2dpbmdUYXJnZXQgPSB0aGlzLl9kcmFnZ2luZ1RhcmdldDtcbiAgICAgICAgICAgIGlmIChkcmFnZ2luZ1RhcmdldCkge1xuXG4gICAgICAgICAgICAgICAgdmFyIHggPSBlLm9mZnNldFg7XG4gICAgICAgICAgICAgICAgdmFyIHkgPSBlLm9mZnNldFk7XG5cbiAgICAgICAgICAgICAgICB2YXIgZHggPSB4IC0gdGhpcy5feDtcbiAgICAgICAgICAgICAgICB2YXIgZHkgPSB5IC0gdGhpcy5feTtcbiAgICAgICAgICAgICAgICB0aGlzLl94ID0geDtcbiAgICAgICAgICAgICAgICB0aGlzLl95ID0geTtcblxuICAgICAgICAgICAgICAgIGRyYWdnaW5nVGFyZ2V0LmRyaWZ0KGR4LCBkeSwgZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaFRvRWxlbWVudChkcmFnZ2luZ1RhcmdldCwgJ2RyYWcnLCBlLmV2ZW50KTtcblxuICAgICAgICAgICAgICAgIHZhciBkcm9wVGFyZ2V0ID0gdGhpcy5maW5kSG92ZXIoeCwgeSwgZHJhZ2dpbmdUYXJnZXQpO1xuICAgICAgICAgICAgICAgIHZhciBsYXN0RHJvcFRhcmdldCA9IHRoaXMuX2Ryb3BUYXJnZXQ7XG4gICAgICAgICAgICAgICAgdGhpcy5fZHJvcFRhcmdldCA9IGRyb3BUYXJnZXQ7XG5cbiAgICAgICAgICAgICAgICBpZiAoZHJhZ2dpbmdUYXJnZXQgIT09IGRyb3BUYXJnZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxhc3REcm9wVGFyZ2V0ICYmIGRyb3BUYXJnZXQgIT09IGxhc3REcm9wVGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoVG9FbGVtZW50KGxhc3REcm9wVGFyZ2V0LCAnZHJhZ2xlYXZlJywgZS5ldmVudCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGRyb3BUYXJnZXQgJiYgZHJvcFRhcmdldCAhPT0gbGFzdERyb3BUYXJnZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hUb0VsZW1lbnQoZHJvcFRhcmdldCwgJ2RyYWdlbnRlcicsIGUuZXZlbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIF9kcmFnRW5kOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgdmFyIGRyYWdnaW5nVGFyZ2V0ID0gdGhpcy5fZHJhZ2dpbmdUYXJnZXQ7XG5cbiAgICAgICAgICAgIGlmIChkcmFnZ2luZ1RhcmdldCkge1xuICAgICAgICAgICAgICAgIGRyYWdnaW5nVGFyZ2V0LmRyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hUb0VsZW1lbnQoZHJhZ2dpbmdUYXJnZXQsICdkcmFnZW5kJywgZS5ldmVudCk7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl9kcm9wVGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaFRvRWxlbWVudCh0aGlzLl9kcm9wVGFyZ2V0LCAnZHJvcCcsIGUuZXZlbnQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl9kcmFnZ2luZ1RhcmdldCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLl9kcm9wVGFyZ2V0ID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgfTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gRHJhZ2dhYmxlO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34venJlbmRlci9saWIvbWl4aW4vRHJhZ2dhYmxlLmpzXG4gKiogbW9kdWxlIGlkID0gMzhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogR3JvdXDmmK/kuIDkuKrlrrnlmajvvIzlj6/ku6Xmj5LlhaXlrZDoioLngrnvvIxHcm91cOeahOWPmOaNouS5n+S8muiiq+W6lOeUqOWIsOWtkOiKgueCueS4ilxuICogQG1vZHVsZSB6cmVuZGVyL2dyYXBoaWMvR3JvdXBcbiAqIEBleGFtcGxlXG4gKiAgICAgdmFyIEdyb3VwID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29udGFpbmVyL0dyb3VwJyk7XG4gKiAgICAgdmFyIENpcmNsZSA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvQ2lyY2xlJyk7XG4gKiAgICAgdmFyIGcgPSBuZXcgR3JvdXAoKTtcbiAqICAgICBnLnBvc2l0aW9uWzBdID0gMTAwO1xuICogICAgIGcucG9zaXRpb25bMV0gPSAxMDA7XG4gKiAgICAgZy5hZGQobmV3IENpcmNsZSh7XG4gKiAgICAgICAgIHN0eWxlOiB7XG4gKiAgICAgICAgICAgICB4OiAxMDAsXG4gKiAgICAgICAgICAgICB5OiAxMDAsXG4gKiAgICAgICAgICAgICByOiAyMCxcbiAqICAgICAgICAgfVxuICogICAgIH0pKTtcbiAqICAgICB6ci5hZGQoZyk7XG4gKi9cblxuXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJy4uL2NvcmUvdXRpbCcpO1xuICAgIHZhciBFbGVtZW50ID0gcmVxdWlyZSgnLi4vRWxlbWVudCcpO1xuICAgIHZhciBCb3VuZGluZ1JlY3QgPSByZXF1aXJlKCcuLi9jb3JlL0JvdW5kaW5nUmVjdCcpO1xuXG4gICAgLyoqXG4gICAgICogQGFsaWFzIG1vZHVsZTp6cmVuZGVyL2dyYXBoaWMvR3JvdXBcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAZXh0ZW5kcyBtb2R1bGU6enJlbmRlci9taXhpbi9UcmFuc2Zvcm1hYmxlXG4gICAgICogQGV4dGVuZHMgbW9kdWxlOnpyZW5kZXIvbWl4aW4vRXZlbnRmdWxcbiAgICAgKi9cbiAgICB2YXIgR3JvdXAgPSBmdW5jdGlvbiAob3B0cykge1xuXG4gICAgICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xuXG4gICAgICAgIEVsZW1lbnQuY2FsbCh0aGlzLCBvcHRzKTtcblxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gb3B0cykge1xuICAgICAgICAgICAgdGhpc1trZXldID0gb3B0c1trZXldO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fY2hpbGRyZW4gPSBbXTtcblxuICAgICAgICB0aGlzLl9fc3RvcmFnZSA9IG51bGw7XG5cbiAgICAgICAgdGhpcy5fX2RpcnR5ID0gdHJ1ZTtcbiAgICB9O1xuXG4gICAgR3JvdXAucHJvdG90eXBlID0ge1xuXG4gICAgICAgIGNvbnN0cnVjdG9yOiBHcm91cCxcblxuICAgICAgICBpc0dyb3VwOiB0cnVlLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgdHlwZTogJ2dyb3VwJyxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5omA5pyJ5a2Q5a2Z5YWD57Sg5piv5ZCm5ZON5bqU6byg5qCH5LqL5Lu2XG4gICAgICAgICAqIEBuYW1lIG1vZHVsZTovenJlbmRlci9jb250YWluZXIvR3JvdXAjc2lsZW50XG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgc2lsZW50OiBmYWxzZSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7QXJyYXkuPG1vZHVsZTp6cmVuZGVyL0VsZW1lbnQ+fVxuICAgICAgICAgKi9cbiAgICAgICAgY2hpbGRyZW46IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jaGlsZHJlbi5zbGljZSgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDojrflj5bmjIflrpogaW5kZXgg55qE5YS/5a2Q6IqC54K5XG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gaWR4XG4gICAgICAgICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL0VsZW1lbnR9XG4gICAgICAgICAqL1xuICAgICAgICBjaGlsZEF0OiBmdW5jdGlvbiAoaWR4KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY2hpbGRyZW5baWR4XTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog6I635Y+W5oyH5a6a5ZCN5a2X55qE5YS/5a2Q6IqC54K5XG4gICAgICAgICAqIEBwYXJhbSAge3N0cmluZ30gbmFtZVxuICAgICAgICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9FbGVtZW50fVxuICAgICAgICAgKi9cbiAgICAgICAgY2hpbGRPZk5hbWU6IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbjtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGRyZW5baV0ubmFtZSA9PT0gbmFtZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgY2hpbGRDb3VudDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5re75Yqg5a2Q6IqC54K55Yiw5pyA5ZCOXG4gICAgICAgICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvRWxlbWVudH0gY2hpbGRcbiAgICAgICAgICovXG4gICAgICAgIGFkZDogZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgICAgICBpZiAoY2hpbGQgJiYgY2hpbGQgIT09IHRoaXMgJiYgY2hpbGQucGFyZW50ICE9PSB0aGlzKSB7XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9jaGlsZHJlbi5wdXNoKGNoaWxkKTtcblxuICAgICAgICAgICAgICAgIHRoaXMuX2RvQWRkKGNoaWxkKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOa3u+WKoOWtkOiKgueCueWcqCBuZXh0U2libGluZyDkuYvliY1cbiAgICAgICAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9FbGVtZW50fSBjaGlsZFxuICAgICAgICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL0VsZW1lbnR9IG5leHRTaWJsaW5nXG4gICAgICAgICAqL1xuICAgICAgICBhZGRCZWZvcmU6IGZ1bmN0aW9uIChjaGlsZCwgbmV4dFNpYmxpbmcpIHtcbiAgICAgICAgICAgIGlmIChjaGlsZCAmJiBjaGlsZCAhPT0gdGhpcyAmJiBjaGlsZC5wYXJlbnQgIT09IHRoaXNcbiAgICAgICAgICAgICAgICAmJiBuZXh0U2libGluZyAmJiBuZXh0U2libGluZy5wYXJlbnQgPT09IHRoaXMpIHtcblxuICAgICAgICAgICAgICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuO1xuICAgICAgICAgICAgICAgIHZhciBpZHggPSBjaGlsZHJlbi5pbmRleE9mKG5leHRTaWJsaW5nKTtcblxuICAgICAgICAgICAgICAgIGlmIChpZHggPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbi5zcGxpY2UoaWR4LCAwLCBjaGlsZCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RvQWRkKGNoaWxkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9kb0FkZDogZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgICAgICBpZiAoY2hpbGQucGFyZW50KSB7XG4gICAgICAgICAgICAgICAgY2hpbGQucGFyZW50LnJlbW92ZShjaGlsZCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNoaWxkLnBhcmVudCA9IHRoaXM7XG5cbiAgICAgICAgICAgIHZhciBzdG9yYWdlID0gdGhpcy5fX3N0b3JhZ2U7XG4gICAgICAgICAgICB2YXIgenIgPSB0aGlzLl9fenI7XG4gICAgICAgICAgICBpZiAoc3RvcmFnZSAmJiBzdG9yYWdlICE9PSBjaGlsZC5fX3N0b3JhZ2UpIHtcblxuICAgICAgICAgICAgICAgIHN0b3JhZ2UuYWRkVG9NYXAoY2hpbGQpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgR3JvdXApIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQuYWRkQ2hpbGRyZW5Ub1N0b3JhZ2Uoc3RvcmFnZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB6ciAmJiB6ci5yZWZyZXNoKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOenu+mZpOWtkOiKgueCuVxuICAgICAgICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL0VsZW1lbnR9IGNoaWxkXG4gICAgICAgICAqL1xuICAgICAgICByZW1vdmU6IGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICAgICAgdmFyIHpyID0gdGhpcy5fX3pyO1xuICAgICAgICAgICAgdmFyIHN0b3JhZ2UgPSB0aGlzLl9fc3RvcmFnZTtcbiAgICAgICAgICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuO1xuXG4gICAgICAgICAgICB2YXIgaWR4ID0genJVdGlsLmluZGV4T2YoY2hpbGRyZW4sIGNoaWxkKTtcbiAgICAgICAgICAgIGlmIChpZHggPCAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjaGlsZHJlbi5zcGxpY2UoaWR4LCAxKTtcblxuICAgICAgICAgICAgY2hpbGQucGFyZW50ID0gbnVsbDtcblxuICAgICAgICAgICAgaWYgKHN0b3JhZ2UpIHtcblxuICAgICAgICAgICAgICAgIHN0b3JhZ2UuZGVsRnJvbU1hcChjaGlsZC5pZCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBHcm91cCkge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZC5kZWxDaGlsZHJlbkZyb21TdG9yYWdlKHN0b3JhZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgenIgJiYgenIucmVmcmVzaCgpO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog56e76Zmk5omA5pyJ5a2Q6IqC54K5XG4gICAgICAgICAqL1xuICAgICAgICByZW1vdmVBbGw6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuO1xuICAgICAgICAgICAgdmFyIHN0b3JhZ2UgPSB0aGlzLl9fc3RvcmFnZTtcbiAgICAgICAgICAgIHZhciBjaGlsZDtcbiAgICAgICAgICAgIHZhciBpO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgICBpZiAoc3RvcmFnZSkge1xuICAgICAgICAgICAgICAgICAgICBzdG9yYWdlLmRlbEZyb21NYXAoY2hpbGQuaWQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBHcm91cCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGQuZGVsQ2hpbGRyZW5Gcm9tU3RvcmFnZShzdG9yYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjaGlsZC5wYXJlbnQgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2hpbGRyZW4ubGVuZ3RoID0gMDtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOmBjeWOhuaJgOacieWtkOiKgueCuVxuICAgICAgICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gY2JcbiAgICAgICAgICogQHBhcmFtICB7fSAgIGNvbnRleHRcbiAgICAgICAgICovXG4gICAgICAgIGVhY2hDaGlsZDogZnVuY3Rpb24gKGNiLCBjb250ZXh0KSB7XG4gICAgICAgICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbjtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgICBjYi5jYWxsKGNvbnRleHQsIGNoaWxkLCBpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmt7HluqbkvJjlhYjpgY3ljobmiYDmnInlrZDlrZnoioLngrlcbiAgICAgICAgICogQHBhcmFtICB7RnVuY3Rpb259IGNiXG4gICAgICAgICAqIEBwYXJhbSAge30gICBjb250ZXh0XG4gICAgICAgICAqL1xuICAgICAgICB0cmF2ZXJzZTogZnVuY3Rpb24gKGNiLCBjb250ZXh0KSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2NoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkID0gdGhpcy5fY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgY2IuY2FsbChjb250ZXh0LCBjaGlsZCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQudHlwZSA9PT0gJ2dyb3VwJykge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZC50cmF2ZXJzZShjYiwgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgYWRkQ2hpbGRyZW5Ub1N0b3JhZ2U6IGZ1bmN0aW9uIChzdG9yYWdlKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2NoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkID0gdGhpcy5fY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgc3RvcmFnZS5hZGRUb01hcChjaGlsZCk7XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgR3JvdXApIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQuYWRkQ2hpbGRyZW5Ub1N0b3JhZ2Uoc3RvcmFnZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGRlbENoaWxkcmVuRnJvbVN0b3JhZ2U6IGZ1bmN0aW9uIChzdG9yYWdlKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2NoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkID0gdGhpcy5fY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgc3RvcmFnZS5kZWxGcm9tTWFwKGNoaWxkLmlkKTtcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBHcm91cCkge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZC5kZWxDaGlsZHJlbkZyb21TdG9yYWdlKHN0b3JhZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBkaXJ0eTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5fX2RpcnR5ID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX196ciAmJiB0aGlzLl9fenIucmVmcmVzaCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2NvcmUvQm91bmRpbmdSZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0Qm91bmRpbmdSZWN0OiBmdW5jdGlvbiAoaW5jbHVkZUNoaWxkcmVuKSB7XG4gICAgICAgICAgICAvLyBUT0RPIENhY2hpbmdcbiAgICAgICAgICAgIC8vIFRPRE8gVHJhbnNmb3JtXG4gICAgICAgICAgICB2YXIgcmVjdCA9IG51bGw7XG4gICAgICAgICAgICB2YXIgdG1wUmVjdCA9IG5ldyBCb3VuZGluZ1JlY3QoMCwgMCwgMCwgMCk7XG4gICAgICAgICAgICB2YXIgY2hpbGRyZW4gPSBpbmNsdWRlQ2hpbGRyZW4gfHwgdGhpcy5fY2hpbGRyZW47XG4gICAgICAgICAgICB2YXIgdG1wTWF0ID0gW107XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQuaWdub3JlIHx8IGNoaWxkLmludmlzaWJsZSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgY2hpbGRSZWN0ID0gY2hpbGQuZ2V0Qm91bmRpbmdSZWN0KCk7XG4gICAgICAgICAgICAgICAgdmFyIHRyYW5zZm9ybSA9IGNoaWxkLmdldExvY2FsVHJhbnNmb3JtKHRtcE1hdCk7XG4gICAgICAgICAgICAgICAgaWYgKHRyYW5zZm9ybSkge1xuICAgICAgICAgICAgICAgICAgICB0bXBSZWN0LmNvcHkoY2hpbGRSZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgdG1wUmVjdC5hcHBseVRyYW5zZm9ybSh0cmFuc2Zvcm0pO1xuICAgICAgICAgICAgICAgICAgICByZWN0ID0gcmVjdCB8fCB0bXBSZWN0LmNsb25lKCk7XG4gICAgICAgICAgICAgICAgICAgIHJlY3QudW5pb24odG1wUmVjdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZWN0ID0gcmVjdCB8fCBjaGlsZFJlY3QuY2xvbmUoKTtcbiAgICAgICAgICAgICAgICAgICAgcmVjdC51bmlvbihjaGlsZFJlY3QpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZWN0IHx8IHRtcFJlY3Q7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgenJVdGlsLmluaGVyaXRzKEdyb3VwLCBFbGVtZW50KTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gR3JvdXA7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi96cmVuZGVyL2xpYi9jb250YWluZXIvR3JvdXAuanNcbiAqKiBtb2R1bGUgaWQgPSAzOVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBJbWFnZSBlbGVtZW50XG4gKiBAbW9kdWxlIHpyZW5kZXIvZ3JhcGhpYy9JbWFnZVxuICovXG5cblxuXG4gICAgdmFyIERpc3BsYXlhYmxlID0gcmVxdWlyZSgnLi9EaXNwbGF5YWJsZScpO1xuICAgIHZhciBCb3VuZGluZ1JlY3QgPSByZXF1aXJlKCcuLi9jb3JlL0JvdW5kaW5nUmVjdCcpO1xuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCcuLi9jb3JlL3V0aWwnKTtcblxuICAgIHZhciBMUlUgPSByZXF1aXJlKCcuLi9jb3JlL0xSVScpO1xuICAgIHZhciBnbG9iYWxJbWFnZUNhY2hlID0gbmV3IExSVSg1MCk7XG4gICAgLyoqXG4gICAgICogQGFsaWFzIHpyZW5kZXIvZ3JhcGhpYy9JbWFnZVxuICAgICAqIEBleHRlbmRzIG1vZHVsZTp6cmVuZGVyL2dyYXBoaWMvRGlzcGxheWFibGVcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIFpJbWFnZShvcHRzKSB7XG4gICAgICAgIERpc3BsYXlhYmxlLmNhbGwodGhpcywgb3B0cyk7XG4gICAgfVxuXG4gICAgWkltYWdlLnByb3RvdHlwZSA9IHtcblxuICAgICAgICBjb25zdHJ1Y3RvcjogWkltYWdlLFxuXG4gICAgICAgIHR5cGU6ICdpbWFnZScsXG5cbiAgICAgICAgYnJ1c2g6IGZ1bmN0aW9uIChjdHgsIHByZXZFbCkge1xuICAgICAgICAgICAgdmFyIHN0eWxlID0gdGhpcy5zdHlsZTtcbiAgICAgICAgICAgIHZhciBzcmMgPSBzdHlsZS5pbWFnZTtcbiAgICAgICAgICAgIHZhciBpbWFnZTtcblxuICAgICAgICAgICAgLy8gTXVzdCBiaW5kIGVhY2ggdGltZVxuICAgICAgICAgICAgc3R5bGUuYmluZChjdHgsIHRoaXMsIHByZXZFbCk7XG4gICAgICAgICAgICAvLyBzdHlsZS5pbWFnZSBpcyBhIHVybCBzdHJpbmdcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc3JjID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGltYWdlID0gdGhpcy5faW1hZ2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBzdHlsZS5pbWFnZSBpcyBhbiBIVE1MSW1hZ2VFbGVtZW50IG9yIEhUTUxDYW52YXNFbGVtZW50IG9yIENhbnZhc1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaW1hZ2UgPSBzcmM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBGSVhNRSBDYXNlIGNyZWF0ZSBtYW55IGltYWdlcyB3aXRoIHNyY1xuICAgICAgICAgICAgaWYgKCFpbWFnZSAmJiBzcmMpIHtcbiAgICAgICAgICAgICAgICAvLyBUcnkgZ2V0IGZyb20gZ2xvYmFsIGltYWdlIGNhY2hlXG4gICAgICAgICAgICAgICAgdmFyIGNhY2hlZEltZ09iaiA9IGdsb2JhbEltYWdlQ2FjaGUuZ2V0KHNyYyk7XG4gICAgICAgICAgICAgICAgaWYgKCFjYWNoZWRJbWdPYmopIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ3JlYXRlIGEgbmV3IGltYWdlXG4gICAgICAgICAgICAgICAgICAgIGltYWdlID0gbmV3IEltYWdlKCk7XG4gICAgICAgICAgICAgICAgICAgIGltYWdlLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlLm9ubG9hZCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNhY2hlZEltZ09iai5wZW5kaW5nLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGVkSW1nT2JqLnBlbmRpbmdbaV0uZGlydHkoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgY2FjaGVkSW1nT2JqID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2U6IGltYWdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGVuZGluZzogW3RoaXNdXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGltYWdlLnNyYyA9IHNyYztcbiAgICAgICAgICAgICAgICAgICAgZ2xvYmFsSW1hZ2VDYWNoZS5wdXQoc3JjLCBjYWNoZWRJbWdPYmopO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbWFnZSA9IGltYWdlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpbWFnZSA9IGNhY2hlZEltZ09iai5pbWFnZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faW1hZ2UgPSBpbWFnZTtcbiAgICAgICAgICAgICAgICAgICAgLy8gSW1hZ2UgaXMgbm90IGNvbXBsZXRlIGZpbmlzaCwgYWRkIHRvIHBlbmRpbmcgbGlzdFxuICAgICAgICAgICAgICAgICAgICBpZiAoIWltYWdlLndpZHRoIHx8ICFpbWFnZS5oZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlZEltZ09iai5wZW5kaW5nLnB1c2godGhpcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChpbWFnZSkge1xuICAgICAgICAgICAgICAgIC8vIOWbvueJh+W3sue7j+WKoOi9veWujOaIkFxuICAgICAgICAgICAgICAgIC8vIGlmIChpbWFnZS5ub2RlTmFtZS50b1VwcGVyQ2FzZSgpID09ICdJTUcnKSB7XG4gICAgICAgICAgICAgICAgLy8gICAgIGlmICghaW1hZ2UuY29tcGxldGUpIHtcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAvLyAgICAgfVxuICAgICAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgICAgICAvLyBFbHNlIGlzIGNhbnZhc1xuXG4gICAgICAgICAgICAgICAgdmFyIHdpZHRoID0gc3R5bGUud2lkdGggfHwgaW1hZ2Uud2lkdGg7XG4gICAgICAgICAgICAgICAgdmFyIGhlaWdodCA9IHN0eWxlLmhlaWdodCB8fCBpbWFnZS5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgdmFyIHggPSBzdHlsZS54IHx8IDA7XG4gICAgICAgICAgICAgICAgdmFyIHkgPSBzdHlsZS55IHx8IDA7XG4gICAgICAgICAgICAgICAgLy8g5Zu+54mH5Yqg6L295aSx6LSlXG4gICAgICAgICAgICAgICAgaWYgKCFpbWFnZS53aWR0aCB8fCAhaW1hZ2UuaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyDorr7nva50cmFuc2Zvcm1cbiAgICAgICAgICAgICAgICB0aGlzLnNldFRyYW5zZm9ybShjdHgpO1xuXG5cbiAgICAgICAgICAgICAgICBpZiAoc3R5bGUuc1dpZHRoICYmIHN0eWxlLnNIZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN4ID0gc3R5bGUuc3ggfHwgMDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN5ID0gc3R5bGUuc3kgfHwgMDtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmRyYXdJbWFnZShcbiAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3gsIHN5LCBzdHlsZS5zV2lkdGgsIHN0eWxlLnNIZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgICAgICB4LCB5LCB3aWR0aCwgaGVpZ2h0XG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHN0eWxlLnN4ICYmIHN0eWxlLnN5KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzeCA9IHN0eWxlLnN4O1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3kgPSBzdHlsZS5zeTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNXaWR0aCA9IHdpZHRoIC0gc3g7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzSGVpZ2h0ID0gaGVpZ2h0IC0gc3k7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5kcmF3SW1hZ2UoXG4gICAgICAgICAgICAgICAgICAgICAgICBpbWFnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN4LCBzeSwgc1dpZHRoLCBzSGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgeCwgeSwgd2lkdGgsIGhlaWdodFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmRyYXdJbWFnZShpbWFnZSwgeCwgeSwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8g5aaC5p6c5rKh6K6+572u5a695ZKM6auY55qE6K+d6Ieq5Yqo5qC55o2u5Zu+54mH5a696auY6K6+572uXG4gICAgICAgICAgICAgICAgaWYgKHN0eWxlLndpZHRoID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgc3R5bGUud2lkdGggPSB3aWR0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHN0eWxlLmhlaWdodCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLnJlc3RvcmVUcmFuc2Zvcm0oY3R4KTtcblxuICAgICAgICAgICAgICAgIC8vIERyYXcgcmVjdCB0ZXh0XG4gICAgICAgICAgICAgICAgaWYgKHN0eWxlLnRleHQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdSZWN0VGV4dChjdHgsIHRoaXMuZ2V0Qm91bmRpbmdSZWN0KCkpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGdldEJvdW5kaW5nUmVjdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHN0eWxlID0gdGhpcy5zdHlsZTtcbiAgICAgICAgICAgIGlmICghIHRoaXMuX3JlY3QpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZWN0ID0gbmV3IEJvdW5kaW5nUmVjdChcbiAgICAgICAgICAgICAgICAgICAgc3R5bGUueCB8fCAwLCBzdHlsZS55IHx8IDAsIHN0eWxlLndpZHRoIHx8IDAsIHN0eWxlLmhlaWdodCB8fCAwXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZWN0O1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHpyVXRpbC5pbmhlcml0cyhaSW1hZ2UsIERpc3BsYXlhYmxlKTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gWkltYWdlO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34venJlbmRlci9saWIvZ3JhcGhpYy9JbWFnZS5qc1xuICoqIG1vZHVsZSBpZCA9IDQwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBTaW1wbGUgTFJVIGNhY2hlIHVzZSBkb3VibHkgbGlua2VkIGxpc3Rcbi8vIEBtb2R1bGUgenJlbmRlci9jb3JlL0xSVVxuXG5cbiAgICAvKipcbiAgICAgKiBTaW1wbGUgZG91YmxlIGxpbmtlZCBsaXN0LiBDb21wYXJlZCB3aXRoIGFycmF5LCBpdCBoYXMgTygxKSByZW1vdmUgb3BlcmF0aW9uLlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIHZhciBMaW5rZWRMaXN0ID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHttb2R1bGU6enJlbmRlci9jb3JlL0xSVX5FbnRyeX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaGVhZCA9IG51bGw7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHttb2R1bGU6enJlbmRlci9jb3JlL0xSVX5FbnRyeX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudGFpbCA9IG51bGw7XG5cbiAgICAgICAgdGhpcy5fbGVuID0gMDtcbiAgICB9O1xuXG4gICAgdmFyIGxpbmtlZExpc3RQcm90byA9IExpbmtlZExpc3QucHJvdG90eXBlO1xuICAgIC8qKlxuICAgICAqIEluc2VydCBhIG5ldyB2YWx1ZSBhdCB0aGUgdGFpbFxuICAgICAqIEBwYXJhbSAge30gdmFsXG4gICAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvY29yZS9MUlV+RW50cnl9XG4gICAgICovXG4gICAgbGlua2VkTGlzdFByb3RvLmluc2VydCA9IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICB2YXIgZW50cnkgPSBuZXcgRW50cnkodmFsKTtcbiAgICAgICAgdGhpcy5pbnNlcnRFbnRyeShlbnRyeSk7XG4gICAgICAgIHJldHVybiBlbnRyeTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogSW5zZXJ0IGFuIGVudHJ5IGF0IHRoZSB0YWlsXG4gICAgICogQHBhcmFtICB7bW9kdWxlOnpyZW5kZXIvY29yZS9MUlV+RW50cnl9IGVudHJ5XG4gICAgICovXG4gICAgbGlua2VkTGlzdFByb3RvLmluc2VydEVudHJ5ID0gZnVuY3Rpb24oZW50cnkpIHtcbiAgICAgICAgaWYgKCF0aGlzLmhlYWQpIHtcbiAgICAgICAgICAgIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IGVudHJ5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy50YWlsLm5leHQgPSBlbnRyeTtcbiAgICAgICAgICAgIGVudHJ5LnByZXYgPSB0aGlzLnRhaWw7XG4gICAgICAgICAgICB0aGlzLnRhaWwgPSBlbnRyeTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9sZW4rKztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGVudHJ5LlxuICAgICAqIEBwYXJhbSAge21vZHVsZTp6cmVuZGVyL2NvcmUvTFJVfkVudHJ5fSBlbnRyeVxuICAgICAqL1xuICAgIGxpbmtlZExpc3RQcm90by5yZW1vdmUgPSBmdW5jdGlvbihlbnRyeSkge1xuICAgICAgICB2YXIgcHJldiA9IGVudHJ5LnByZXY7XG4gICAgICAgIHZhciBuZXh0ID0gZW50cnkubmV4dDtcbiAgICAgICAgaWYgKHByZXYpIHtcbiAgICAgICAgICAgIHByZXYubmV4dCA9IG5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBJcyBoZWFkXG4gICAgICAgICAgICB0aGlzLmhlYWQgPSBuZXh0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChuZXh0KSB7XG4gICAgICAgICAgICBuZXh0LnByZXYgPSBwcmV2O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gSXMgdGFpbFxuICAgICAgICAgICAgdGhpcy50YWlsID0gcHJldjtcbiAgICAgICAgfVxuICAgICAgICBlbnRyeS5uZXh0ID0gZW50cnkucHJldiA9IG51bGw7XG4gICAgICAgIHRoaXMuX2xlbi0tO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICovXG4gICAgbGlua2VkTGlzdFByb3RvLmxlbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbGVuO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge30gdmFsXG4gICAgICovXG4gICAgdmFyIEVudHJ5ID0gZnVuY3Rpb24odmFsKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge21vZHVsZTp6cmVuZGVyL2NvcmUvTFJVfkVudHJ5fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5uZXh0O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7bW9kdWxlOnpyZW5kZXIvY29yZS9MUlV+RW50cnl9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnByZXY7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIExSVSBDYWNoZVxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBhbGlhcyBtb2R1bGU6enJlbmRlci9jb3JlL0xSVVxuICAgICAqL1xuICAgIHZhciBMUlUgPSBmdW5jdGlvbihtYXhTaXplKSB7XG5cbiAgICAgICAgdGhpcy5fbGlzdCA9IG5ldyBMaW5rZWRMaXN0KCk7XG5cbiAgICAgICAgdGhpcy5fbWFwID0ge307XG5cbiAgICAgICAgdGhpcy5fbWF4U2l6ZSA9IG1heFNpemUgfHwgMTA7XG4gICAgfTtcblxuICAgIHZhciBMUlVQcm90byA9IExSVS5wcm90b3R5cGU7XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9IGtleVxuICAgICAqIEBwYXJhbSAge30gdmFsdWVcbiAgICAgKi9cbiAgICBMUlVQcm90by5wdXQgPSBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICAgIHZhciBsaXN0ID0gdGhpcy5fbGlzdDtcbiAgICAgICAgdmFyIG1hcCA9IHRoaXMuX21hcDtcbiAgICAgICAgaWYgKG1hcFtrZXldID09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBsZW4gPSBsaXN0LmxlbigpO1xuICAgICAgICAgICAgaWYgKGxlbiA+PSB0aGlzLl9tYXhTaXplICYmIGxlbiA+IDApIHtcbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgdGhlIGxlYXN0IHJlY2VudGx5IHVzZWRcbiAgICAgICAgICAgICAgICB2YXIgbGVhc3RVc2VkRW50cnkgPSBsaXN0LmhlYWQ7XG4gICAgICAgICAgICAgICAgbGlzdC5yZW1vdmUobGVhc3RVc2VkRW50cnkpO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBtYXBbbGVhc3RVc2VkRW50cnkua2V5XTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGVudHJ5ID0gbGlzdC5pbnNlcnQodmFsdWUpO1xuICAgICAgICAgICAgZW50cnkua2V5ID0ga2V5O1xuICAgICAgICAgICAgbWFwW2tleV0gPSBlbnRyeTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9IGtleVxuICAgICAqIEByZXR1cm4ge31cbiAgICAgKi9cbiAgICBMUlVQcm90by5nZXQgPSBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy5fbWFwW2tleV07XG4gICAgICAgIHZhciBsaXN0ID0gdGhpcy5fbGlzdDtcbiAgICAgICAgaWYgKGVudHJ5ICE9IG51bGwpIHtcbiAgICAgICAgICAgIC8vIFB1dCB0aGUgbGF0ZXN0IHVzZWQgZW50cnkgaW4gdGhlIHRhaWxcbiAgICAgICAgICAgIGlmIChlbnRyeSAhPT0gbGlzdC50YWlsKSB7XG4gICAgICAgICAgICAgICAgbGlzdC5yZW1vdmUoZW50cnkpO1xuICAgICAgICAgICAgICAgIGxpc3QuaW5zZXJ0RW50cnkoZW50cnkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZW50cnkudmFsdWU7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2xlYXIgdGhlIGNhY2hlXG4gICAgICovXG4gICAgTFJVUHJvdG8uY2xlYXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5fbGlzdC5jbGVhcigpO1xuICAgICAgICB0aGlzLl9tYXAgPSB7fTtcbiAgICB9O1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBMUlU7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi96cmVuZGVyL2xpYi9jb3JlL0xSVS5qc1xuICoqIG1vZHVsZSBpZCA9IDQxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIFRleHQgZWxlbWVudFxuICogQG1vZHVsZSB6cmVuZGVyL2dyYXBoaWMvVGV4dFxuICpcbiAqIFRPRE8gV3JhcHBpbmdcbiAqXG4gKiBUZXh0IG5vdCBzdXBwb3J0IGdyYWRpZW50XG4gKi9cblxuXG5cbiAgICB2YXIgRGlzcGxheWFibGUgPSByZXF1aXJlKCcuL0Rpc3BsYXlhYmxlJyk7XG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJy4uL2NvcmUvdXRpbCcpO1xuICAgIHZhciB0ZXh0Q29udGFpbiA9IHJlcXVpcmUoJy4uL2NvbnRhaW4vdGV4dCcpO1xuXG4gICAgLyoqXG4gICAgICogQGFsaWFzIHpyZW5kZXIvZ3JhcGhpYy9UZXh0XG4gICAgICogQGV4dGVuZHMgbW9kdWxlOnpyZW5kZXIvZ3JhcGhpYy9EaXNwbGF5YWJsZVxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gICAgICovXG4gICAgdmFyIFRleHQgPSBmdW5jdGlvbiAob3B0cykge1xuICAgICAgICBEaXNwbGF5YWJsZS5jYWxsKHRoaXMsIG9wdHMpO1xuICAgIH07XG5cbiAgICBUZXh0LnByb3RvdHlwZSA9IHtcblxuICAgICAgICBjb25zdHJ1Y3RvcjogVGV4dCxcblxuICAgICAgICB0eXBlOiAndGV4dCcsXG5cbiAgICAgICAgYnJ1c2g6IGZ1bmN0aW9uIChjdHgsIHByZXZFbCkge1xuICAgICAgICAgICAgdmFyIHN0eWxlID0gdGhpcy5zdHlsZTtcbiAgICAgICAgICAgIHZhciB4ID0gc3R5bGUueCB8fCAwO1xuICAgICAgICAgICAgdmFyIHkgPSBzdHlsZS55IHx8IDA7XG4gICAgICAgICAgICAvLyBDb252ZXJ0IHRvIHN0cmluZ1xuICAgICAgICAgICAgdmFyIHRleHQgPSBzdHlsZS50ZXh0O1xuXG4gICAgICAgICAgICAvLyBDb252ZXJ0IHRvIHN0cmluZ1xuICAgICAgICAgICAgdGV4dCAhPSBudWxsICYmICh0ZXh0ICs9ICcnKTtcblxuICAgICAgICAgICAgLy8gQWx3YXlzIGJpbmQgc3R5bGVcbiAgICAgICAgICAgIHN0eWxlLmJpbmQoY3R4LCB0aGlzLCBwcmV2RWwpO1xuXG4gICAgICAgICAgICBpZiAodGV4dCkge1xuXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRUcmFuc2Zvcm0oY3R4KTtcblxuICAgICAgICAgICAgICAgIHZhciB0ZXh0QmFzZWxpbmU7XG4gICAgICAgICAgICAgICAgdmFyIHRleHRBbGlnbiA9IHN0eWxlLnRleHRBbGlnbjtcbiAgICAgICAgICAgICAgICB2YXIgZm9udCA9IHN0eWxlLnRleHRGb250IHx8IHN0eWxlLmZvbnQ7XG4gICAgICAgICAgICAgICAgaWYgKHN0eWxlLnRleHRWZXJ0aWNhbEFsaWduKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZWN0ID0gdGV4dENvbnRhaW4uZ2V0Qm91bmRpbmdSZWN0KFxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dCwgZm9udCwgc3R5bGUudGV4dEFsaWduLCAndG9wJ1xuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAvLyBJZ25vcmUgdGV4dEJhc2VsaW5lXG4gICAgICAgICAgICAgICAgICAgIHRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHN0eWxlLnRleHRWZXJ0aWNhbEFsaWduKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdtaWRkbGUnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkgLT0gcmVjdC5oZWlnaHQgLyAyIC0gcmVjdC5saW5lSGVpZ2h0IC8gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeSAtPSByZWN0LmhlaWdodCAtIHJlY3QubGluZUhlaWdodCAvIDI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkgKz0gcmVjdC5saW5lSGVpZ2h0IC8gMjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dEJhc2VsaW5lID0gc3R5bGUudGV4dEJhc2VsaW5lO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFRPRE8gSW52YWxpZCBmb250XG4gICAgICAgICAgICAgICAgY3R4LmZvbnQgPSBmb250IHx8ICcxMnB4IHNhbnMtc2VyaWYnO1xuICAgICAgICAgICAgICAgIGN0eC50ZXh0QWxpZ24gPSB0ZXh0QWxpZ24gfHwgJ2xlZnQnO1xuICAgICAgICAgICAgICAgIC8vIFVzZSBjYW52YXMgZGVmYXVsdCBsZWZ0IHRleHRBbGlnbi4gR2l2aW5nIGludmFsaWQgdmFsdWUgd2lsbCBjYXVzZSBzdGF0ZSBub3QgY2hhbmdlXG4gICAgICAgICAgICAgICAgaWYgKGN0eC50ZXh0QWxpZ24gIT09IHRleHRBbGlnbikge1xuICAgICAgICAgICAgICAgICAgICBjdHgudGV4dEFsaWduID0gJ2xlZnQnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjdHgudGV4dEJhc2VsaW5lID0gdGV4dEJhc2VsaW5lIHx8ICdhbHBoYWJldGljJztcbiAgICAgICAgICAgICAgICAvLyBVc2UgY2FudmFzIGRlZmF1bHQgYWxwaGFiZXRpYyBiYXNlbGluZVxuICAgICAgICAgICAgICAgIGlmIChjdHgudGV4dEJhc2VsaW5lICE9PSB0ZXh0QmFzZWxpbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4LnRleHRCYXNlbGluZSA9ICdhbHBoYWJldGljJztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgbGluZUhlaWdodCA9IHRleHRDb250YWluLm1lYXN1cmVUZXh0KCflm70nLCBjdHguZm9udCkud2lkdGg7XG5cbiAgICAgICAgICAgICAgICB2YXIgdGV4dExpbmVzID0gdGV4dC5zcGxpdCgnXFxuJyk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0ZXh0TGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgc3R5bGUuaGFzRmlsbCgpICYmIGN0eC5maWxsVGV4dCh0ZXh0TGluZXNbaV0sIHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICBzdHlsZS5oYXNTdHJva2UoKSAmJiBjdHguc3Ryb2tlVGV4dCh0ZXh0TGluZXNbaV0sIHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICB5ICs9IGxpbmVIZWlnaHQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5yZXN0b3JlVHJhbnNmb3JtKGN0eCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0Qm91bmRpbmdSZWN0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX3JlY3QpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3R5bGUgPSB0aGlzLnN0eWxlO1xuICAgICAgICAgICAgICAgIHZhciB0ZXh0VmVydGljYWxBbGlnbiA9IHN0eWxlLnRleHRWZXJ0aWNhbEFsaWduO1xuICAgICAgICAgICAgICAgIHZhciByZWN0ID0gdGV4dENvbnRhaW4uZ2V0Qm91bmRpbmdSZWN0KFxuICAgICAgICAgICAgICAgICAgICBzdHlsZS50ZXh0ICsgJycsIHN0eWxlLnRleHRGb250IHx8IHN0eWxlLmZvbnQsIHN0eWxlLnRleHRBbGlnbixcbiAgICAgICAgICAgICAgICAgICAgdGV4dFZlcnRpY2FsQWxpZ24gPyAndG9wJyA6IHN0eWxlLnRleHRCYXNlbGluZVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgc3dpdGNoICh0ZXh0VmVydGljYWxBbGlnbikge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdtaWRkbGUnOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVjdC55IC09IHJlY3QuaGVpZ2h0IC8gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdib3R0b20nOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVjdC55IC09IHJlY3QuaGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlY3QueCArPSBzdHlsZS54IHx8IDA7XG4gICAgICAgICAgICAgICAgcmVjdC55ICs9IHN0eWxlLnkgfHwgMDtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZWN0ID0gcmVjdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZWN0O1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHpyVXRpbC5pbmhlcml0cyhUZXh0LCBEaXNwbGF5YWJsZSk7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IFRleHQ7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi96cmVuZGVyL2xpYi9ncmFwaGljL1RleHQuanNcbiAqKiBtb2R1bGUgaWQgPSA0MlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuLyoqXG4gKiDlnIblvaJcbiAqIEBtb2R1bGUgenJlbmRlci9zaGFwZS9DaXJjbGVcbiAqL1xuXG5cblxuICAgIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vUGF0aCcpLmV4dGVuZCh7XG5cbiAgICAgICAgdHlwZTogJ2NpcmNsZScsXG5cbiAgICAgICAgc2hhcGU6IHtcbiAgICAgICAgICAgIGN4OiAwLFxuICAgICAgICAgICAgY3k6IDAsXG4gICAgICAgICAgICByOiAwXG4gICAgICAgIH0sXG5cblxuICAgICAgICBidWlsZFBhdGggOiBmdW5jdGlvbiAoY3R4LCBzaGFwZSwgaW5CdW5kbGUpIHtcbiAgICAgICAgICAgIC8vIEJldHRlciBzdHJva2luZyBpbiBTaGFwZUJ1bmRsZVxuICAgICAgICAgICAgLy8gQWx3YXlzIGRvIGl0IG1heSBoYXZlIHBlcmZvcm1lbmNlIGlzc3VlICggZmlsbCBtYXkgYmUgMnggbW9yZSBjb3N0KVxuICAgICAgICAgICAgaWYgKGluQnVuZGxlKSB7XG4gICAgICAgICAgICAgICAgY3R4Lm1vdmVUbyhzaGFwZS5jeCArIHNoYXBlLnIsIHNoYXBlLmN5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEJldHRlciBzdHJva2luZyBpbiBTaGFwZUJ1bmRsZVxuICAgICAgICAgICAgLy8gY3R4Lm1vdmVUbyhzaGFwZS5jeCArIHNoYXBlLnIsIHNoYXBlLmN5KTtcbiAgICAgICAgICAgIGN0eC5hcmMoc2hhcGUuY3gsIHNoYXBlLmN5LCBzaGFwZS5yLCAwLCBNYXRoLlBJICogMiwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34venJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9DaXJjbGUuanNcbiAqKiBtb2R1bGUgaWQgPSA0M1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiDmiYflvaJcbiAqIEBtb2R1bGUgenJlbmRlci9ncmFwaGljL3NoYXBlL1NlY3RvclxuICovXG5cblxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi9QYXRoJykuZXh0ZW5kKHtcblxuICAgICAgICB0eXBlOiAnc2VjdG9yJyxcblxuICAgICAgICBzaGFwZToge1xuXG4gICAgICAgICAgICBjeDogMCxcblxuICAgICAgICAgICAgY3k6IDAsXG5cbiAgICAgICAgICAgIHIwOiAwLFxuXG4gICAgICAgICAgICByOiAwLFxuXG4gICAgICAgICAgICBzdGFydEFuZ2xlOiAwLFxuXG4gICAgICAgICAgICBlbmRBbmdsZTogTWF0aC5QSSAqIDIsXG5cbiAgICAgICAgICAgIGNsb2Nrd2lzZTogdHJ1ZVxuICAgICAgICB9LFxuXG4gICAgICAgIGJ1aWxkUGF0aDogZnVuY3Rpb24gKGN0eCwgc2hhcGUpIHtcblxuICAgICAgICAgICAgdmFyIHggPSBzaGFwZS5jeDtcbiAgICAgICAgICAgIHZhciB5ID0gc2hhcGUuY3k7XG4gICAgICAgICAgICB2YXIgcjAgPSBNYXRoLm1heChzaGFwZS5yMCB8fCAwLCAwKTtcbiAgICAgICAgICAgIHZhciByID0gTWF0aC5tYXgoc2hhcGUuciwgMCk7XG4gICAgICAgICAgICB2YXIgc3RhcnRBbmdsZSA9IHNoYXBlLnN0YXJ0QW5nbGU7XG4gICAgICAgICAgICB2YXIgZW5kQW5nbGUgPSBzaGFwZS5lbmRBbmdsZTtcbiAgICAgICAgICAgIHZhciBjbG9ja3dpc2UgPSBzaGFwZS5jbG9ja3dpc2U7XG5cbiAgICAgICAgICAgIHZhciB1bml0WCA9IE1hdGguY29zKHN0YXJ0QW5nbGUpO1xuICAgICAgICAgICAgdmFyIHVuaXRZID0gTWF0aC5zaW4oc3RhcnRBbmdsZSk7XG5cbiAgICAgICAgICAgIGN0eC5tb3ZlVG8odW5pdFggKiByMCArIHgsIHVuaXRZICogcjAgKyB5KTtcblxuICAgICAgICAgICAgY3R4LmxpbmVUbyh1bml0WCAqIHIgKyB4LCB1bml0WSAqIHIgKyB5KTtcblxuICAgICAgICAgICAgY3R4LmFyYyh4LCB5LCByLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgIWNsb2Nrd2lzZSk7XG5cbiAgICAgICAgICAgIGN0eC5saW5lVG8oXG4gICAgICAgICAgICAgICAgTWF0aC5jb3MoZW5kQW5nbGUpICogcjAgKyB4LFxuICAgICAgICAgICAgICAgIE1hdGguc2luKGVuZEFuZ2xlKSAqIHIwICsgeVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgaWYgKHIwICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgY3R4LmFyYyh4LCB5LCByMCwgZW5kQW5nbGUsIHN0YXJ0QW5nbGUsIGNsb2Nrd2lzZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi96cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL1NlY3Rvci5qc1xuICoqIG1vZHVsZSBpZCA9IDQ0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIOWchueOr1xuICogQG1vZHVsZSB6cmVuZGVyL2dyYXBoaWMvc2hhcGUvUmluZ1xuICovXG5cblxuICAgIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vUGF0aCcpLmV4dGVuZCh7XG5cbiAgICAgICAgdHlwZTogJ3JpbmcnLFxuXG4gICAgICAgIHNoYXBlOiB7XG4gICAgICAgICAgICBjeDogMCxcbiAgICAgICAgICAgIGN5OiAwLFxuICAgICAgICAgICAgcjogMCxcbiAgICAgICAgICAgIHIwOiAwXG4gICAgICAgIH0sXG5cbiAgICAgICAgYnVpbGRQYXRoOiBmdW5jdGlvbiAoY3R4LCBzaGFwZSkge1xuICAgICAgICAgICAgdmFyIHggPSBzaGFwZS5jeDtcbiAgICAgICAgICAgIHZhciB5ID0gc2hhcGUuY3k7XG4gICAgICAgICAgICB2YXIgUEkyID0gTWF0aC5QSSAqIDI7XG4gICAgICAgICAgICBjdHgubW92ZVRvKHggKyBzaGFwZS5yLCB5KTtcbiAgICAgICAgICAgIGN0eC5hcmMoeCwgeSwgc2hhcGUuciwgMCwgUEkyLCBmYWxzZSk7XG4gICAgICAgICAgICBjdHgubW92ZVRvKHggKyBzaGFwZS5yMCwgeSk7XG4gICAgICAgICAgICBjdHguYXJjKHgsIHksIHNoYXBlLnIwLCAwLCBQSTIsIHRydWUpO1xuICAgICAgICB9XG4gICAgfSk7XG5cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvUmluZy5qc1xuICoqIG1vZHVsZSBpZCA9IDQ1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIOWkmui+ueW9olxuICogQG1vZHVsZSB6cmVuZGVyL3NoYXBlL1BvbHlnb25cbiAqL1xuXG5cbiAgICB2YXIgcG9seUhlbHBlciA9IHJlcXVpcmUoJy4uL2hlbHBlci9wb2x5Jyk7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uL1BhdGgnKS5leHRlbmQoe1xuICAgICAgICBcbiAgICAgICAgdHlwZTogJ3BvbHlnb24nLFxuXG4gICAgICAgIHNoYXBlOiB7XG4gICAgICAgICAgICBwb2ludHM6IG51bGwsXG5cbiAgICAgICAgICAgIHNtb290aDogZmFsc2UsXG5cbiAgICAgICAgICAgIHNtb290aENvbnN0cmFpbnQ6IG51bGxcbiAgICAgICAgfSxcblxuICAgICAgICBidWlsZFBhdGg6IGZ1bmN0aW9uIChjdHgsIHNoYXBlKSB7XG4gICAgICAgICAgICBwb2x5SGVscGVyLmJ1aWxkUGF0aChjdHgsIHNoYXBlLCB0cnVlKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34venJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9Qb2x5Z29uLmpzXG4gKiogbW9kdWxlIGlkID0gNDZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlxuXG4gICAgdmFyIHNtb290aFNwbGluZSA9IHJlcXVpcmUoJy4vc21vb3RoU3BsaW5lJyk7XG4gICAgdmFyIHNtb290aEJlemllciA9IHJlcXVpcmUoJy4vc21vb3RoQmV6aWVyJyk7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAgICAgYnVpbGRQYXRoOiBmdW5jdGlvbiAoY3R4LCBzaGFwZSwgY2xvc2VQYXRoKSB7XG4gICAgICAgICAgICB2YXIgcG9pbnRzID0gc2hhcGUucG9pbnRzO1xuICAgICAgICAgICAgdmFyIHNtb290aCA9IHNoYXBlLnNtb290aDtcbiAgICAgICAgICAgIGlmIChwb2ludHMgJiYgcG9pbnRzLmxlbmd0aCA+PSAyKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNtb290aCAmJiBzbW9vdGggIT09ICdzcGxpbmUnKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb250cm9sUG9pbnRzID0gc21vb3RoQmV6aWVyKFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzLCBzbW9vdGgsIGNsb3NlUGF0aCwgc2hhcGUuc21vb3RoQ29uc3RyYWludFxuICAgICAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgICAgIGN0eC5tb3ZlVG8ocG9pbnRzWzBdWzBdLCBwb2ludHNbMF1bMV0pO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGVuID0gcG9pbnRzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAoY2xvc2VQYXRoID8gbGVuIDogbGVuIC0gMSk7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNwMSA9IGNvbnRyb2xQb2ludHNbaSAqIDJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNwMiA9IGNvbnRyb2xQb2ludHNbaSAqIDIgKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwID0gcG9pbnRzWyhpICsgMSkgJSBsZW5dO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmJlemllckN1cnZlVG8oXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3AxWzBdLCBjcDFbMV0sIGNwMlswXSwgY3AyWzFdLCBwWzBdLCBwWzFdXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc21vb3RoID09PSAnc3BsaW5lJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzID0gc21vb3RoU3BsaW5lKHBvaW50cywgY2xvc2VQYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGN0eC5tb3ZlVG8ocG9pbnRzWzBdWzBdLCBwb2ludHNbMF1bMV0pO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMSwgbCA9IHBvaW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5saW5lVG8ocG9pbnRzW2ldWzBdLCBwb2ludHNbaV1bMV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY2xvc2VQYXRoICYmIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi96cmVuZGVyL2xpYi9ncmFwaGljL2hlbHBlci9wb2x5LmpzXG4gKiogbW9kdWxlIGlkID0gNDdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ2F0bXVsbC1Sb20gc3BsaW5lIOaPkuWAvOaKmOe6v1xuICogQG1vZHVsZSB6cmVuZGVyL3NoYXBlL3V0aWwvc21vb3RoU3BsaW5lXG4gKiBAYXV0aG9yIHBpc3NhbmcgKGh0dHBzOi8vd3d3LmdpdGh1Yi5jb20vcGlzc2FuZylcbiAqICAgICAgICAgS2VuZXIgKEBLZW5lci3mnpfls7AsIGtlbmVyLmxpbmZlbmdAZ21haWwuY29tKVxuICogICAgICAgICBlcnJvcnJpayAoZXJyb3JyaWtAZ21haWwuY29tKVxuICovXG5cbiAgICB2YXIgdmVjMiA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvdmVjdG9yJyk7XG5cbiAgICAvKipcbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbnRlcnBvbGF0ZShwMCwgcDEsIHAyLCBwMywgdCwgdDIsIHQzKSB7XG4gICAgICAgIHZhciB2MCA9IChwMiAtIHAwKSAqIDAuNTtcbiAgICAgICAgdmFyIHYxID0gKHAzIC0gcDEpICogMC41O1xuICAgICAgICByZXR1cm4gKDIgKiAocDEgLSBwMikgKyB2MCArIHYxKSAqIHQzXG4gICAgICAgICAgICAgICAgKyAoLTMgKiAocDEgLSBwMikgLSAyICogdjAgLSB2MSkgKiB0MlxuICAgICAgICAgICAgICAgICsgdjAgKiB0ICsgcDE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGFsaWFzIG1vZHVsZTp6cmVuZGVyL3NoYXBlL3V0aWwvc21vb3RoU3BsaW5lXG4gICAgICogQHBhcmFtIHtBcnJheX0gcG9pbnRzIOe6v+autemhtueCueaVsOe7hFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNMb29wXG4gICAgICogQHJldHVybiB7QXJyYXl9XG4gICAgICovXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAocG9pbnRzLCBpc0xvb3ApIHtcbiAgICAgICAgdmFyIGxlbiA9IHBvaW50cy5sZW5ndGg7XG4gICAgICAgIHZhciByZXQgPSBbXTtcblxuICAgICAgICB2YXIgZGlzdGFuY2UgPSAwO1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBkaXN0YW5jZSArPSB2ZWMyLmRpc3RhbmNlKHBvaW50c1tpIC0gMV0sIHBvaW50c1tpXSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc2VncyA9IGRpc3RhbmNlIC8gMjtcbiAgICAgICAgc2VncyA9IHNlZ3MgPCBsZW4gPyBsZW4gOiBzZWdzO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlZ3M7IGkrKykge1xuICAgICAgICAgICAgdmFyIHBvcyA9IGkgLyAoc2VncyAtIDEpICogKGlzTG9vcCA/IGxlbiA6IGxlbiAtIDEpO1xuICAgICAgICAgICAgdmFyIGlkeCA9IE1hdGguZmxvb3IocG9zKTtcblxuICAgICAgICAgICAgdmFyIHcgPSBwb3MgLSBpZHg7XG5cbiAgICAgICAgICAgIHZhciBwMDtcbiAgICAgICAgICAgIHZhciBwMSA9IHBvaW50c1tpZHggJSBsZW5dO1xuICAgICAgICAgICAgdmFyIHAyO1xuICAgICAgICAgICAgdmFyIHAzO1xuICAgICAgICAgICAgaWYgKCFpc0xvb3ApIHtcbiAgICAgICAgICAgICAgICBwMCA9IHBvaW50c1tpZHggPT09IDAgPyBpZHggOiBpZHggLSAxXTtcbiAgICAgICAgICAgICAgICBwMiA9IHBvaW50c1tpZHggPiBsZW4gLSAyID8gbGVuIC0gMSA6IGlkeCArIDFdO1xuICAgICAgICAgICAgICAgIHAzID0gcG9pbnRzW2lkeCA+IGxlbiAtIDMgPyBsZW4gLSAxIDogaWR4ICsgMl07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwMCA9IHBvaW50c1soaWR4IC0gMSArIGxlbikgJSBsZW5dO1xuICAgICAgICAgICAgICAgIHAyID0gcG9pbnRzWyhpZHggKyAxKSAlIGxlbl07XG4gICAgICAgICAgICAgICAgcDMgPSBwb2ludHNbKGlkeCArIDIpICUgbGVuXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHcyID0gdyAqIHc7XG4gICAgICAgICAgICB2YXIgdzMgPSB3ICogdzI7XG5cbiAgICAgICAgICAgIHJldC5wdXNoKFtcbiAgICAgICAgICAgICAgICBpbnRlcnBvbGF0ZShwMFswXSwgcDFbMF0sIHAyWzBdLCBwM1swXSwgdywgdzIsIHczKSxcbiAgICAgICAgICAgICAgICBpbnRlcnBvbGF0ZShwMFsxXSwgcDFbMV0sIHAyWzFdLCBwM1sxXSwgdywgdzIsIHczKVxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi96cmVuZGVyL2xpYi9ncmFwaGljL2hlbHBlci9zbW9vdGhTcGxpbmUuanNcbiAqKiBtb2R1bGUgaWQgPSA0OFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiDotJ3loZ7lsJTlubPmu5Hmm7Lnur9cbiAqIEBtb2R1bGUgenJlbmRlci9zaGFwZS91dGlsL3Ntb290aEJlemllclxuICogQGF1dGhvciBwaXNzYW5nIChodHRwczovL3d3dy5naXRodWIuY29tL3Bpc3NhbmcpXG4gKiAgICAgICAgIEtlbmVyIChAS2VuZXIt5p6X5bOwLCBrZW5lci5saW5mZW5nQGdtYWlsLmNvbSlcbiAqICAgICAgICAgZXJyb3JyaWsgKGVycm9ycmlrQGdtYWlsLmNvbSlcbiAqL1xuXG5cbiAgICB2YXIgdmVjMiA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvdmVjdG9yJyk7XG4gICAgdmFyIHYyTWluID0gdmVjMi5taW47XG4gICAgdmFyIHYyTWF4ID0gdmVjMi5tYXg7XG4gICAgdmFyIHYyU2NhbGUgPSB2ZWMyLnNjYWxlO1xuICAgIHZhciB2MkRpc3RhbmNlID0gdmVjMi5kaXN0YW5jZTtcbiAgICB2YXIgdjJBZGQgPSB2ZWMyLmFkZDtcblxuICAgIC8qKlxuICAgICAqIOi0neWhnuWwlOW5s+a7keabsue6v1xuICAgICAqIEBhbGlhcyBtb2R1bGU6enJlbmRlci9zaGFwZS91dGlsL3Ntb290aEJlemllclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBvaW50cyDnur/mrrXpobbngrnmlbDnu4RcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc21vb3RoIOW5s+a7keetiee6pywgMC0xXG4gICAgICogQHBhcmFtIHtib29sZWFufSBpc0xvb3BcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBjb25zdHJhaW50IOWwhuiuoeeul+WHuuadpeeahOaOp+WItueCuee6puadn+WcqOS4gOS4quWMheWbtOebkuWGhVxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAg5q+U5aaCIFtbMCwgMF0sIFsxMDAsIDEwMF1dLCDov5nkuKrljIXlm7Tnm5LkvJrkuI5cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIOaVtOS4quaKmOe6v+eahOWMheWbtOebkuWBmuS4gOS4quW5tumbhueUqOadpee6puadn+aOp+WItueCueOAglxuICAgICAqIEBwYXJhbSB7QXJyYXl9IOiuoeeul+WHuuadpeeahOaOp+WItueCueaVsOe7hFxuICAgICAqL1xuICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHBvaW50cywgc21vb3RoLCBpc0xvb3AsIGNvbnN0cmFpbnQpIHtcbiAgICAgICAgdmFyIGNwcyA9IFtdO1xuXG4gICAgICAgIHZhciB2ID0gW107XG4gICAgICAgIHZhciB2MSA9IFtdO1xuICAgICAgICB2YXIgdjIgPSBbXTtcbiAgICAgICAgdmFyIHByZXZQb2ludDtcbiAgICAgICAgdmFyIG5leHRQb2ludDtcblxuICAgICAgICB2YXIgbWluLCBtYXg7XG4gICAgICAgIGlmIChjb25zdHJhaW50KSB7XG4gICAgICAgICAgICBtaW4gPSBbSW5maW5pdHksIEluZmluaXR5XTtcbiAgICAgICAgICAgIG1heCA9IFstSW5maW5pdHksIC1JbmZpbml0eV07XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gcG9pbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdjJNaW4obWluLCBtaW4sIHBvaW50c1tpXSk7XG4gICAgICAgICAgICAgICAgdjJNYXgobWF4LCBtYXgsIHBvaW50c1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyDkuI7mjIflrprnmoTljIXlm7Tnm5LlgZrlubbpm4ZcbiAgICAgICAgICAgIHYyTWluKG1pbiwgbWluLCBjb25zdHJhaW50WzBdKTtcbiAgICAgICAgICAgIHYyTWF4KG1heCwgbWF4LCBjb25zdHJhaW50WzFdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBwb2ludHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBwb2ludCA9IHBvaW50c1tpXTtcblxuICAgICAgICAgICAgaWYgKGlzTG9vcCkge1xuICAgICAgICAgICAgICAgIHByZXZQb2ludCA9IHBvaW50c1tpID8gaSAtIDEgOiBsZW4gLSAxXTtcbiAgICAgICAgICAgICAgICBuZXh0UG9pbnQgPSBwb2ludHNbKGkgKyAxKSAlIGxlbl07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoaSA9PT0gMCB8fCBpID09PSBsZW4gLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGNwcy5wdXNoKHZlYzIuY2xvbmUocG9pbnRzW2ldKSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcHJldlBvaW50ID0gcG9pbnRzW2kgLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgbmV4dFBvaW50ID0gcG9pbnRzW2kgKyAxXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZlYzIuc3ViKHYsIG5leHRQb2ludCwgcHJldlBvaW50KTtcblxuICAgICAgICAgICAgLy8gdXNlIGRlZ3JlZSB0byBzY2FsZSB0aGUgaGFuZGxlIGxlbmd0aFxuICAgICAgICAgICAgdjJTY2FsZSh2LCB2LCBzbW9vdGgpO1xuXG4gICAgICAgICAgICB2YXIgZDAgPSB2MkRpc3RhbmNlKHBvaW50LCBwcmV2UG9pbnQpO1xuICAgICAgICAgICAgdmFyIGQxID0gdjJEaXN0YW5jZShwb2ludCwgbmV4dFBvaW50KTtcbiAgICAgICAgICAgIHZhciBzdW0gPSBkMCArIGQxO1xuICAgICAgICAgICAgaWYgKHN1bSAhPT0gMCkge1xuICAgICAgICAgICAgICAgIGQwIC89IHN1bTtcbiAgICAgICAgICAgICAgICBkMSAvPSBzdW07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHYyU2NhbGUodjEsIHYsIC1kMCk7XG4gICAgICAgICAgICB2MlNjYWxlKHYyLCB2LCBkMSk7XG4gICAgICAgICAgICB2YXIgY3AwID0gdjJBZGQoW10sIHBvaW50LCB2MSk7XG4gICAgICAgICAgICB2YXIgY3AxID0gdjJBZGQoW10sIHBvaW50LCB2Mik7XG4gICAgICAgICAgICBpZiAoY29uc3RyYWludCkge1xuICAgICAgICAgICAgICAgIHYyTWF4KGNwMCwgY3AwLCBtaW4pO1xuICAgICAgICAgICAgICAgIHYyTWluKGNwMCwgY3AwLCBtYXgpO1xuICAgICAgICAgICAgICAgIHYyTWF4KGNwMSwgY3AxLCBtaW4pO1xuICAgICAgICAgICAgICAgIHYyTWluKGNwMSwgY3AxLCBtYXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3BzLnB1c2goY3AwKTtcbiAgICAgICAgICAgIGNwcy5wdXNoKGNwMSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNMb29wKSB7XG4gICAgICAgICAgICBjcHMucHVzaChjcHMuc2hpZnQoKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY3BzO1xuICAgIH07XG5cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvaGVscGVyL3Ntb290aEJlemllci5qc1xuICoqIG1vZHVsZSBpZCA9IDQ5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIEBtb2R1bGUgenJlbmRlci9ncmFwaGljL3NoYXBlL1BvbHlsaW5lXG4gKi9cblxuXG4gICAgdmFyIHBvbHlIZWxwZXIgPSByZXF1aXJlKCcuLi9oZWxwZXIvcG9seScpO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi9QYXRoJykuZXh0ZW5kKHtcbiAgICAgICAgXG4gICAgICAgIHR5cGU6ICdwb2x5bGluZScsXG5cbiAgICAgICAgc2hhcGU6IHtcbiAgICAgICAgICAgIHBvaW50czogbnVsbCxcblxuICAgICAgICAgICAgc21vb3RoOiBmYWxzZSxcblxuICAgICAgICAgICAgc21vb3RoQ29uc3RyYWludDogbnVsbFxuICAgICAgICB9LFxuXG4gICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICBzdHJva2U6ICcjMDAwJyxcblxuICAgICAgICAgICAgZmlsbDogbnVsbFxuICAgICAgICB9LFxuXG4gICAgICAgIGJ1aWxkUGF0aDogZnVuY3Rpb24gKGN0eCwgc2hhcGUpIHtcbiAgICAgICAgICAgIHBvbHlIZWxwZXIuYnVpbGRQYXRoKGN0eCwgc2hhcGUsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34venJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9Qb2x5bGluZS5qc1xuICoqIG1vZHVsZSBpZCA9IDUwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIOefqeW9olxuICogQG1vZHVsZSB6cmVuZGVyL2dyYXBoaWMvc2hhcGUvUmVjdFxuICovXG5cblxuICAgIHZhciByb3VuZFJlY3RIZWxwZXIgPSByZXF1aXJlKCcuLi9oZWxwZXIvcm91bmRSZWN0Jyk7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uL1BhdGgnKS5leHRlbmQoe1xuXG4gICAgICAgIHR5cGU6ICdyZWN0JyxcblxuICAgICAgICBzaGFwZToge1xuICAgICAgICAgICAgLy8g5bem5LiK44CB5Y+z5LiK44CB5Y+z5LiL44CB5bem5LiL6KeS55qE5Y2K5b6E5L6d5qyh5Li6cjHjgIFyMuOAgXIz44CBcjRcbiAgICAgICAgICAgIC8vIHLnvKnlhpnkuLoxICAgICAgICAg55u45b2T5LqOIFsxLCAxLCAxLCAxXVxuICAgICAgICAgICAgLy8gcue8qeWGmeS4ulsxXSAgICAgICDnm7jlvZPkuo4gWzEsIDEsIDEsIDFdXG4gICAgICAgICAgICAvLyBy57yp5YaZ5Li6WzEsIDJdICAgIOebuOW9k+S6jiBbMSwgMiwgMSwgMl1cbiAgICAgICAgICAgIC8vIHLnvKnlhpnkuLpbMSwgMiwgM10g55u45b2T5LqOIFsxLCAyLCAzLCAyXVxuICAgICAgICAgICAgcjogMCxcblxuICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgIHk6IDAsXG4gICAgICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgICAgIGhlaWdodDogMFxuICAgICAgICB9LFxuXG4gICAgICAgIGJ1aWxkUGF0aDogZnVuY3Rpb24gKGN0eCwgc2hhcGUpIHtcbiAgICAgICAgICAgIHZhciB4ID0gc2hhcGUueDtcbiAgICAgICAgICAgIHZhciB5ID0gc2hhcGUueTtcbiAgICAgICAgICAgIHZhciB3aWR0aCA9IHNoYXBlLndpZHRoO1xuICAgICAgICAgICAgdmFyIGhlaWdodCA9IHNoYXBlLmhlaWdodDtcbiAgICAgICAgICAgIGlmICghc2hhcGUucikge1xuICAgICAgICAgICAgICAgIGN0eC5yZWN0KHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcm91bmRSZWN0SGVscGVyLmJ1aWxkUGF0aChjdHgsIHNoYXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH0pO1xuXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi96cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL1JlY3QuanNcbiAqKiBtb2R1bGUgaWQgPSA1MVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAgICAgYnVpbGRQYXRoOiBmdW5jdGlvbiAoY3R4LCBzaGFwZSkge1xuICAgICAgICAgICAgdmFyIHggPSBzaGFwZS54O1xuICAgICAgICAgICAgdmFyIHkgPSBzaGFwZS55O1xuICAgICAgICAgICAgdmFyIHdpZHRoID0gc2hhcGUud2lkdGg7XG4gICAgICAgICAgICB2YXIgaGVpZ2h0ID0gc2hhcGUuaGVpZ2h0O1xuICAgICAgICAgICAgdmFyIHIgPSBzaGFwZS5yO1xuICAgICAgICAgICAgdmFyIHIxO1xuICAgICAgICAgICAgdmFyIHIyO1xuICAgICAgICAgICAgdmFyIHIzO1xuICAgICAgICAgICAgdmFyIHI0O1xuXG4gICAgICAgICAgICAvLyBDb252ZXJ0IHdpZHRoIGFuZCBoZWlnaHQgdG8gcG9zaXRpdmUgZm9yIGJldHRlciBib3JkZXJSYWRpdXNcbiAgICAgICAgICAgIGlmICh3aWR0aCA8IDApIHtcbiAgICAgICAgICAgICAgICB4ID0geCArIHdpZHRoO1xuICAgICAgICAgICAgICAgIHdpZHRoID0gLXdpZHRoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGhlaWdodCA8IDApIHtcbiAgICAgICAgICAgICAgICB5ID0geSArIGhlaWdodDtcbiAgICAgICAgICAgICAgICBoZWlnaHQgPSAtaGVpZ2h0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodHlwZW9mIHIgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgcjEgPSByMiA9IHIzID0gcjQgPSByO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAociBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICAgICAgaWYgKHIubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHIxID0gcjIgPSByMyA9IHI0ID0gclswXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoci5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgcjEgPSByMyA9IHJbMF07XG4gICAgICAgICAgICAgICAgICAgIHIyID0gcjQgPSByWzFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChyLmxlbmd0aCA9PT0gMykge1xuICAgICAgICAgICAgICAgICAgICByMSA9IHJbMF07XG4gICAgICAgICAgICAgICAgICAgIHIyID0gcjQgPSByWzFdO1xuICAgICAgICAgICAgICAgICAgICByMyA9IHJbMl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByMSA9IHJbMF07XG4gICAgICAgICAgICAgICAgICAgIHIyID0gclsxXTtcbiAgICAgICAgICAgICAgICAgICAgcjMgPSByWzJdO1xuICAgICAgICAgICAgICAgICAgICByNCA9IHJbM107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcjEgPSByMiA9IHIzID0gcjQgPSAwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgdG90YWw7XG4gICAgICAgICAgICBpZiAocjEgKyByMiA+IHdpZHRoKSB7XG4gICAgICAgICAgICAgICAgdG90YWwgPSByMSArIHIyO1xuICAgICAgICAgICAgICAgIHIxICo9IHdpZHRoIC8gdG90YWw7XG4gICAgICAgICAgICAgICAgcjIgKj0gd2lkdGggLyB0b3RhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyMyArIHI0ID4gd2lkdGgpIHtcbiAgICAgICAgICAgICAgICB0b3RhbCA9IHIzICsgcjQ7XG4gICAgICAgICAgICAgICAgcjMgKj0gd2lkdGggLyB0b3RhbDtcbiAgICAgICAgICAgICAgICByNCAqPSB3aWR0aCAvIHRvdGFsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHIyICsgcjMgPiBoZWlnaHQpIHtcbiAgICAgICAgICAgICAgICB0b3RhbCA9IHIyICsgcjM7XG4gICAgICAgICAgICAgICAgcjIgKj0gaGVpZ2h0IC8gdG90YWw7XG4gICAgICAgICAgICAgICAgcjMgKj0gaGVpZ2h0IC8gdG90YWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocjEgKyByNCA+IGhlaWdodCkge1xuICAgICAgICAgICAgICAgIHRvdGFsID0gcjEgKyByNDtcbiAgICAgICAgICAgICAgICByMSAqPSBoZWlnaHQgLyB0b3RhbDtcbiAgICAgICAgICAgICAgICByNCAqPSBoZWlnaHQgLyB0b3RhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN0eC5tb3ZlVG8oeCArIHIxLCB5KTtcbiAgICAgICAgICAgIGN0eC5saW5lVG8oeCArIHdpZHRoIC0gcjIsIHkpO1xuICAgICAgICAgICAgcjIgIT09IDAgJiYgY3R4LnF1YWRyYXRpY0N1cnZlVG8oXG4gICAgICAgICAgICAgICAgeCArIHdpZHRoLCB5LCB4ICsgd2lkdGgsIHkgKyByMlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGN0eC5saW5lVG8oeCArIHdpZHRoLCB5ICsgaGVpZ2h0IC0gcjMpO1xuICAgICAgICAgICAgcjMgIT09IDAgJiYgY3R4LnF1YWRyYXRpY0N1cnZlVG8oXG4gICAgICAgICAgICAgICAgeCArIHdpZHRoLCB5ICsgaGVpZ2h0LCB4ICsgd2lkdGggLSByMywgeSArIGhlaWdodFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGN0eC5saW5lVG8oeCArIHI0LCB5ICsgaGVpZ2h0KTtcbiAgICAgICAgICAgIHI0ICE9PSAwICYmIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKFxuICAgICAgICAgICAgICAgIHgsIHkgKyBoZWlnaHQsIHgsIHkgKyBoZWlnaHQgLSByNFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGN0eC5saW5lVG8oeCwgeSArIHIxKTtcbiAgICAgICAgICAgIHIxICE9PSAwICYmIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHgsIHksIHggKyByMSwgeSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34venJlbmRlci9saWIvZ3JhcGhpYy9oZWxwZXIvcm91bmRSZWN0LmpzXG4gKiogbW9kdWxlIGlkID0gNTJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICog55u057q/XG4gKiBAbW9kdWxlIHpyZW5kZXIvZ3JhcGhpYy9zaGFwZS9MaW5lXG4gKi9cblxuICAgIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vUGF0aCcpLmV4dGVuZCh7XG5cbiAgICAgICAgdHlwZTogJ2xpbmUnLFxuXG4gICAgICAgIHNoYXBlOiB7XG4gICAgICAgICAgICAvLyBTdGFydCBwb2ludFxuICAgICAgICAgICAgeDE6IDAsXG4gICAgICAgICAgICB5MTogMCxcbiAgICAgICAgICAgIC8vIEVuZCBwb2ludFxuICAgICAgICAgICAgeDI6IDAsXG4gICAgICAgICAgICB5MjogMCxcblxuICAgICAgICAgICAgcGVyY2VudDogMVxuICAgICAgICB9LFxuXG4gICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICBzdHJva2U6ICcjMDAwJyxcbiAgICAgICAgICAgIGZpbGw6IG51bGxcbiAgICAgICAgfSxcblxuICAgICAgICBidWlsZFBhdGg6IGZ1bmN0aW9uIChjdHgsIHNoYXBlKSB7XG4gICAgICAgICAgICB2YXIgeDEgPSBzaGFwZS54MTtcbiAgICAgICAgICAgIHZhciB5MSA9IHNoYXBlLnkxO1xuICAgICAgICAgICAgdmFyIHgyID0gc2hhcGUueDI7XG4gICAgICAgICAgICB2YXIgeTIgPSBzaGFwZS55MjtcbiAgICAgICAgICAgIHZhciBwZXJjZW50ID0gc2hhcGUucGVyY2VudDtcblxuICAgICAgICAgICAgaWYgKHBlcmNlbnQgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGN0eC5tb3ZlVG8oeDEsIHkxKTtcblxuICAgICAgICAgICAgaWYgKHBlcmNlbnQgPCAxKSB7XG4gICAgICAgICAgICAgICAgeDIgPSB4MSAqICgxIC0gcGVyY2VudCkgKyB4MiAqIHBlcmNlbnQ7XG4gICAgICAgICAgICAgICAgeTIgPSB5MSAqICgxIC0gcGVyY2VudCkgKyB5MiAqIHBlcmNlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdHgubGluZVRvKHgyLCB5Mik7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCBwb2ludCBhdCBwZXJjZW50XG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gcGVyY2VudFxuICAgICAgICAgKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn1cbiAgICAgICAgICovXG4gICAgICAgIHBvaW50QXQ6IGZ1bmN0aW9uIChwKSB7XG4gICAgICAgICAgICB2YXIgc2hhcGUgPSB0aGlzLnNoYXBlO1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICBzaGFwZS54MSAqICgxIC0gcCkgKyBzaGFwZS54MiAqIHAsXG4gICAgICAgICAgICAgICAgc2hhcGUueTEgKiAoMSAtIHApICsgc2hhcGUueTIgKiBwXG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG4gICAgfSk7XG5cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvTGluZS5qc1xuICoqIG1vZHVsZSBpZCA9IDUzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG4vKipcbiAqIOi0neWhnuWwlOabsue6v1xuICogQG1vZHVsZSB6cmVuZGVyL3NoYXBlL0JlemllckN1cnZlXG4gKi9cblxuXG4gICAgdmFyIGN1cnZlVG9vbCA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvY3VydmUnKTtcbiAgICB2YXIgdmVjMiA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvdmVjdG9yJyk7XG4gICAgdmFyIHF1YWRyYXRpY1N1YmRpdmlkZSA9IGN1cnZlVG9vbC5xdWFkcmF0aWNTdWJkaXZpZGU7XG4gICAgdmFyIGN1YmljU3ViZGl2aWRlID0gY3VydmVUb29sLmN1YmljU3ViZGl2aWRlO1xuICAgIHZhciBxdWFkcmF0aWNBdCA9IGN1cnZlVG9vbC5xdWFkcmF0aWNBdDtcbiAgICB2YXIgY3ViaWNBdCA9IGN1cnZlVG9vbC5jdWJpY0F0O1xuICAgIHZhciBxdWFkcmF0aWNEZXJpdmF0aXZlQXQgPSBjdXJ2ZVRvb2wucXVhZHJhdGljRGVyaXZhdGl2ZUF0O1xuICAgIHZhciBjdWJpY0Rlcml2YXRpdmVBdCA9IGN1cnZlVG9vbC5jdWJpY0Rlcml2YXRpdmVBdDtcblxuICAgIHZhciBvdXQgPSBbXTtcblxuICAgIGZ1bmN0aW9uIHNvbWVWZWN0b3JBdChzaGFwZSwgdCwgaXNUYW5nZW50KSB7XG4gICAgICAgIHZhciBjcHgyID0gc2hhcGUuY3B4MjtcbiAgICAgICAgdmFyIGNweTIgPSBzaGFwZS5jcHkyO1xuICAgICAgICBpZiAoY3B4MiA9PT0gbnVsbCB8fCBjcHkyID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIChpc1RhbmdlbnQgPyBjdWJpY0Rlcml2YXRpdmVBdCA6IGN1YmljQXQpKHNoYXBlLngxLCBzaGFwZS5jcHgxLCBzaGFwZS5jcHgyLCBzaGFwZS54MiwgdCksXG4gICAgICAgICAgICAgICAgKGlzVGFuZ2VudCA/IGN1YmljRGVyaXZhdGl2ZUF0IDogY3ViaWNBdCkoc2hhcGUueTEsIHNoYXBlLmNweTEsIHNoYXBlLmNweTIsIHNoYXBlLnkyLCB0KVxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgKGlzVGFuZ2VudCA/IHF1YWRyYXRpY0Rlcml2YXRpdmVBdCA6IHF1YWRyYXRpY0F0KShzaGFwZS54MSwgc2hhcGUuY3B4MSwgc2hhcGUueDIsIHQpLFxuICAgICAgICAgICAgICAgIChpc1RhbmdlbnQgPyBxdWFkcmF0aWNEZXJpdmF0aXZlQXQgOiBxdWFkcmF0aWNBdCkoc2hhcGUueTEsIHNoYXBlLmNweTEsIHNoYXBlLnkyLCB0KVxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uL1BhdGgnKS5leHRlbmQoe1xuXG4gICAgICAgIHR5cGU6ICdiZXppZXItY3VydmUnLFxuXG4gICAgICAgIHNoYXBlOiB7XG4gICAgICAgICAgICB4MTogMCxcbiAgICAgICAgICAgIHkxOiAwLFxuICAgICAgICAgICAgeDI6IDAsXG4gICAgICAgICAgICB5MjogMCxcbiAgICAgICAgICAgIGNweDE6IDAsXG4gICAgICAgICAgICBjcHkxOiAwLFxuICAgICAgICAgICAgLy8gY3B4MjogMCxcbiAgICAgICAgICAgIC8vIGNweTI6IDBcblxuICAgICAgICAgICAgLy8gQ3VydmUgc2hvdyBwZXJjZW50LCBmb3IgYW5pbWF0aW5nXG4gICAgICAgICAgICBwZXJjZW50OiAxXG4gICAgICAgIH0sXG5cbiAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgIHN0cm9rZTogJyMwMDAnLFxuICAgICAgICAgICAgZmlsbDogbnVsbFxuICAgICAgICB9LFxuXG4gICAgICAgIGJ1aWxkUGF0aDogZnVuY3Rpb24gKGN0eCwgc2hhcGUpIHtcbiAgICAgICAgICAgIHZhciB4MSA9IHNoYXBlLngxO1xuICAgICAgICAgICAgdmFyIHkxID0gc2hhcGUueTE7XG4gICAgICAgICAgICB2YXIgeDIgPSBzaGFwZS54MjtcbiAgICAgICAgICAgIHZhciB5MiA9IHNoYXBlLnkyO1xuICAgICAgICAgICAgdmFyIGNweDEgPSBzaGFwZS5jcHgxO1xuICAgICAgICAgICAgdmFyIGNweTEgPSBzaGFwZS5jcHkxO1xuICAgICAgICAgICAgdmFyIGNweDIgPSBzaGFwZS5jcHgyO1xuICAgICAgICAgICAgdmFyIGNweTIgPSBzaGFwZS5jcHkyO1xuICAgICAgICAgICAgdmFyIHBlcmNlbnQgPSBzaGFwZS5wZXJjZW50O1xuICAgICAgICAgICAgaWYgKHBlcmNlbnQgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGN0eC5tb3ZlVG8oeDEsIHkxKTtcblxuICAgICAgICAgICAgaWYgKGNweDIgPT0gbnVsbCB8fCBjcHkyID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAocGVyY2VudCA8IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcXVhZHJhdGljU3ViZGl2aWRlKFxuICAgICAgICAgICAgICAgICAgICAgICAgeDEsIGNweDEsIHgyLCBwZXJjZW50LCBvdXRcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgY3B4MSA9IG91dFsxXTtcbiAgICAgICAgICAgICAgICAgICAgeDIgPSBvdXRbMl07XG4gICAgICAgICAgICAgICAgICAgIHF1YWRyYXRpY1N1YmRpdmlkZShcbiAgICAgICAgICAgICAgICAgICAgICAgIHkxLCBjcHkxLCB5MiwgcGVyY2VudCwgb3V0XG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIGNweTEgPSBvdXRbMV07XG4gICAgICAgICAgICAgICAgICAgIHkyID0gb3V0WzJdO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKFxuICAgICAgICAgICAgICAgICAgICBjcHgxLCBjcHkxLFxuICAgICAgICAgICAgICAgICAgICB4MiwgeTJcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHBlcmNlbnQgPCAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1YmljU3ViZGl2aWRlKFxuICAgICAgICAgICAgICAgICAgICAgICAgeDEsIGNweDEsIGNweDIsIHgyLCBwZXJjZW50LCBvdXRcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgY3B4MSA9IG91dFsxXTtcbiAgICAgICAgICAgICAgICAgICAgY3B4MiA9IG91dFsyXTtcbiAgICAgICAgICAgICAgICAgICAgeDIgPSBvdXRbM107XG4gICAgICAgICAgICAgICAgICAgIGN1YmljU3ViZGl2aWRlKFxuICAgICAgICAgICAgICAgICAgICAgICAgeTEsIGNweTEsIGNweTIsIHkyLCBwZXJjZW50LCBvdXRcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgY3B5MSA9IG91dFsxXTtcbiAgICAgICAgICAgICAgICAgICAgY3B5MiA9IG91dFsyXTtcbiAgICAgICAgICAgICAgICAgICAgeTIgPSBvdXRbM107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKFxuICAgICAgICAgICAgICAgICAgICBjcHgxLCBjcHkxLFxuICAgICAgICAgICAgICAgICAgICBjcHgyLCBjcHkyLFxuICAgICAgICAgICAgICAgICAgICB4MiwgeTJcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgcG9pbnQgYXQgcGVyY2VudFxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHRcbiAgICAgICAgICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59XG4gICAgICAgICAqL1xuICAgICAgICBwb2ludEF0OiBmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgcmV0dXJuIHNvbWVWZWN0b3JBdCh0aGlzLnNoYXBlLCB0LCBmYWxzZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0YW5nZW50IGF0IHBlcmNlbnRcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSB0XG4gICAgICAgICAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fVxuICAgICAgICAgKi9cbiAgICAgICAgdGFuZ2VudEF0OiBmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgdmFyIHAgPSBzb21lVmVjdG9yQXQodGhpcy5zaGFwZSwgdCwgdHJ1ZSk7XG4gICAgICAgICAgICByZXR1cm4gdmVjMi5ub3JtYWxpemUocCwgcCk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34venJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9CZXppZXJDdXJ2ZS5qc1xuICoqIG1vZHVsZSBpZCA9IDU0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIOWchuW8p1xuICogQG1vZHVsZSB6cmVuZGVyL2dyYXBoaWMvc2hhcGUvQXJjXG4gKi9cbiBcblxuICAgIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vUGF0aCcpLmV4dGVuZCh7XG5cbiAgICAgICAgdHlwZTogJ2FyYycsXG5cbiAgICAgICAgc2hhcGU6IHtcblxuICAgICAgICAgICAgY3g6IDAsXG5cbiAgICAgICAgICAgIGN5OiAwLFxuXG4gICAgICAgICAgICByOiAwLFxuXG4gICAgICAgICAgICBzdGFydEFuZ2xlOiAwLFxuXG4gICAgICAgICAgICBlbmRBbmdsZTogTWF0aC5QSSAqIDIsXG5cbiAgICAgICAgICAgIGNsb2Nrd2lzZTogdHJ1ZVxuICAgICAgICB9LFxuXG4gICAgICAgIHN0eWxlOiB7XG5cbiAgICAgICAgICAgIHN0cm9rZTogJyMwMDAnLFxuXG4gICAgICAgICAgICBmaWxsOiBudWxsXG4gICAgICAgIH0sXG5cbiAgICAgICAgYnVpbGRQYXRoOiBmdW5jdGlvbiAoY3R4LCBzaGFwZSkge1xuXG4gICAgICAgICAgICB2YXIgeCA9IHNoYXBlLmN4O1xuICAgICAgICAgICAgdmFyIHkgPSBzaGFwZS5jeTtcbiAgICAgICAgICAgIHZhciByID0gTWF0aC5tYXgoc2hhcGUuciwgMCk7XG4gICAgICAgICAgICB2YXIgc3RhcnRBbmdsZSA9IHNoYXBlLnN0YXJ0QW5nbGU7XG4gICAgICAgICAgICB2YXIgZW5kQW5nbGUgPSBzaGFwZS5lbmRBbmdsZTtcbiAgICAgICAgICAgIHZhciBjbG9ja3dpc2UgPSBzaGFwZS5jbG9ja3dpc2U7XG5cbiAgICAgICAgICAgIHZhciB1bml0WCA9IE1hdGguY29zKHN0YXJ0QW5nbGUpO1xuICAgICAgICAgICAgdmFyIHVuaXRZID0gTWF0aC5zaW4oc3RhcnRBbmdsZSk7XG5cbiAgICAgICAgICAgIGN0eC5tb3ZlVG8odW5pdFggKiByICsgeCwgdW5pdFkgKiByICsgeSk7XG4gICAgICAgICAgICBjdHguYXJjKHgsIHksIHIsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCAhY2xvY2t3aXNlKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34venJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9BcmMuanNcbiAqKiBtb2R1bGUgaWQgPSA1NVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5cbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnLi4vY29yZS91dGlsJyk7XG5cbiAgICB2YXIgR3JhZGllbnQgPSByZXF1aXJlKCcuL0dyYWRpZW50Jyk7XG5cbiAgICAvKipcbiAgICAgKiB4LCB5LCB4MiwgeTIgYXJlIGFsbCBwZXJjZW50IGZyb20gMCB0byAxXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFt4PTBdXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFt5PTBdXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFt4Mj0xXVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbeTI9MF1cbiAgICAgKiBAcGFyYW0ge0FycmF5LjxPYmplY3Q+fSBjb2xvclN0b3BzXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbZ2xvYmFsQ29vcmQ9ZmFsc2VdXG4gICAgICovXG4gICAgdmFyIExpbmVhckdyYWRpZW50ID0gZnVuY3Rpb24gKHgsIHksIHgyLCB5MiwgY29sb3JTdG9wcywgZ2xvYmFsQ29vcmQpIHtcbiAgICAgICAgdGhpcy54ID0geCA9PSBudWxsID8gMCA6IHg7XG5cbiAgICAgICAgdGhpcy55ID0geSA9PSBudWxsID8gMCA6IHk7XG5cbiAgICAgICAgdGhpcy54MiA9IHgyID09IG51bGwgPyAxIDogeDI7XG5cbiAgICAgICAgdGhpcy55MiA9IHkyID09IG51bGwgPyAwIDogeTI7XG5cbiAgICAgICAgLy8gQ2FuIGJlIGNsb25lZFxuICAgICAgICB0aGlzLnR5cGUgPSAnbGluZWFyJztcblxuICAgICAgICAvLyBJZiB1c2UgZ2xvYmFsIGNvb3JkXG4gICAgICAgIHRoaXMuZ2xvYmFsID0gZ2xvYmFsQ29vcmQgfHwgZmFsc2U7XG5cbiAgICAgICAgR3JhZGllbnQuY2FsbCh0aGlzLCBjb2xvclN0b3BzKTtcbiAgICB9O1xuXG4gICAgTGluZWFyR3JhZGllbnQucHJvdG90eXBlID0ge1xuXG4gICAgICAgIGNvbnN0cnVjdG9yOiBMaW5lYXJHcmFkaWVudFxuICAgIH07XG5cbiAgICB6clV0aWwuaW5oZXJpdHMoTGluZWFyR3JhZGllbnQsIEdyYWRpZW50KTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gTGluZWFyR3JhZGllbnQ7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi96cmVuZGVyL2xpYi9ncmFwaGljL0xpbmVhckdyYWRpZW50LmpzXG4gKiogbW9kdWxlIGlkID0gNTZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJy4uL2NvcmUvdXRpbCcpO1xuXG4gICAgdmFyIEdyYWRpZW50ID0gcmVxdWlyZSgnLi9HcmFkaWVudCcpO1xuXG4gICAgLyoqXG4gICAgICogeCwgeSwgciBhcmUgYWxsIHBlcmNlbnQgZnJvbSAwIHRvIDFcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3g9MC41XVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbeT0wLjVdXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtyPTAuNV1cbiAgICAgKiBAcGFyYW0ge0FycmF5LjxPYmplY3Q+fSBbY29sb3JTdG9wc11cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtnbG9iYWxDb29yZD1mYWxzZV1cbiAgICAgKi9cbiAgICB2YXIgUmFkaWFsR3JhZGllbnQgPSBmdW5jdGlvbiAoeCwgeSwgciwgY29sb3JTdG9wcywgZ2xvYmFsQ29vcmQpIHtcbiAgICAgICAgdGhpcy54ID0geCA9PSBudWxsID8gMC41IDogeDtcblxuICAgICAgICB0aGlzLnkgPSB5ID09IG51bGwgPyAwLjUgOiB5O1xuXG4gICAgICAgIHRoaXMuciA9IHIgPT0gbnVsbCA/IDAuNSA6IHI7XG5cbiAgICAgICAgLy8gQ2FuIGJlIGNsb25lZFxuICAgICAgICB0aGlzLnR5cGUgPSAncmFkaWFsJztcblxuICAgICAgICAvLyBJZiB1c2UgZ2xvYmFsIGNvb3JkXG4gICAgICAgIHRoaXMuZ2xvYmFsID0gZ2xvYmFsQ29vcmQgfHwgZmFsc2U7XG5cbiAgICAgICAgR3JhZGllbnQuY2FsbCh0aGlzLCBjb2xvclN0b3BzKTtcbiAgICB9O1xuXG4gICAgUmFkaWFsR3JhZGllbnQucHJvdG90eXBlID0ge1xuXG4gICAgICAgIGNvbnN0cnVjdG9yOiBSYWRpYWxHcmFkaWVudFxuICAgIH07XG5cbiAgICB6clV0aWwuaW5oZXJpdHMoUmFkaWFsR3JhZGllbnQsIEdyYWRpZW50KTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gUmFkaWFsR3JhZGllbnQ7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi96cmVuZGVyL2xpYi9ncmFwaGljL1JhZGlhbEdyYWRpZW50LmpzXG4gKiogbW9kdWxlIGlkID0gNTdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxyXG5cclxuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcclxuXHJcbiAgICB2YXIgYXBpTGlzdCA9IFtcclxuICAgICAgICAnZ2V0RG9tJywgJ2dldFpyJywgJ2dldFdpZHRoJywgJ2dldEhlaWdodCcsICdkaXNwYXRjaEFjdGlvbicsXHJcbiAgICAgICAgJ29uJywgJ29mZicsICd0cmlnZ2VyJywgJ2dldERhdGFVUkwnLCAnZ2V0Q29ubmVjdGVkRGF0YVVSTCcsICdnZXRNb2RlbCcsICdnZXRPcHRpb24nLCAnZ2V0Tm9kZUNsYXNzJywgJ3Nob3dUaXBXaW5kb3cnLCAnaGlkZVRpcFdpbmRvdycsICdyZXNpemUnLCAnY2xlYXInXHJcbiAgICBdO1xyXG5cclxuICAgIGZ1bmN0aW9uIEV4dGVuc2lvbkFQSShpbnN0YW5jZSkge1xyXG4gICAgICAgIHpyVXRpbC5lYWNoKGFwaUxpc3QsIGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICAgICAgICAgIHRoaXNbbmFtZV0gPSB6clV0aWwuYmluZChpbnN0YW5jZVtuYW1lXSwgaW5zdGFuY2UpO1xyXG4gICAgICAgIH0sIHRoaXMpO1xyXG4gICAgfVxyXG5cclxuICAgIG1vZHVsZS5leHBvcnRzID0gRXh0ZW5zaW9uQVBJO1xyXG5cclxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2xpYi9maXNoLXRvcG8tbmV0d29yay9saWIvRXh0ZW5zaW9uQVBJLmpzXG4gKiogbW9kdWxlIGlkID0gNThcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qIVxuICogWlJlbmRlciwgYSBoaWdoIHBlcmZvcm1hbmNlIDJkIGRyYXdpbmcgbGlicmFyeS5cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMsIEJhaWR1IEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTElDRU5TRVxuICogaHR0cHM6Ly9naXRodWIuY29tL2Vjb21mZS96cmVuZGVyL2Jsb2IvbWFzdGVyL0xJQ0VOU0UudHh0XG4gKi9cbi8vIEdsb2JhbCBkZWZpbmVzXG5cbiAgICB2YXIgZ3VpZCA9IHJlcXVpcmUoJy4vY29yZS9ndWlkJyk7XG4gICAgdmFyIGVudiA9IHJlcXVpcmUoJy4vY29yZS9lbnYnKTtcblxuICAgIHZhciBIYW5kbGVyID0gcmVxdWlyZSgnLi9IYW5kbGVyJyk7XG4gICAgdmFyIFN0b3JhZ2UgPSByZXF1aXJlKCcuL1N0b3JhZ2UnKTtcbiAgICB2YXIgQW5pbWF0aW9uID0gcmVxdWlyZSgnLi9hbmltYXRpb24vQW5pbWF0aW9uJyk7XG4gICAgdmFyIEhhbmRsZXJQcm94eSA9IHJlcXVpcmUoJy4vZG9tL0hhbmRsZXJQcm94eScpO1xuXG4gICAgdmFyIHVzZVZNTCA9ICFlbnYuY2FudmFzU3VwcG9ydGVkO1xuXG4gICAgdmFyIHBhaW50ZXJDdG9ycyA9IHtcbiAgICAgICAgY2FudmFzOiByZXF1aXJlKCcuL1BhaW50ZXInKVxuICAgIH07XG5cbiAgICB2YXIgaW5zdGFuY2VzID0ge307ICAgIC8vIFpSZW5kZXLlrp7kvottYXDntKLlvJVcblxuICAgIHZhciB6cmVuZGVyID0ge307XG4gICAgLyoqXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB6cmVuZGVyLnZlcnNpb24gPSAnMy4xLjMnO1xuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6aW5nIGEgenJlbmRlciBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGRvbVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLnJlbmRlcmVyPSdjYW52YXMnXSAnY2FudmFzJyBvciAnc3ZnJ1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0cy5kZXZpY2VQaXhlbFJhdGlvXVxuICAgICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL1pSZW5kZXJ9XG4gICAgICovXG4gICAgenJlbmRlci5pbml0ID0gZnVuY3Rpb24oZG9tLCBvcHRzKSB7XG4gICAgICAgIHZhciB6ciA9IG5ldyBaUmVuZGVyKGd1aWQoKSwgZG9tLCBvcHRzKTtcbiAgICAgICAgaW5zdGFuY2VzW3pyLmlkXSA9IHpyO1xuICAgICAgICByZXR1cm4genI7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIERpc3Bvc2UgenJlbmRlciBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvWlJlbmRlcn0genJcbiAgICAgKi9cbiAgICB6cmVuZGVyLmRpc3Bvc2UgPSBmdW5jdGlvbiAoenIpIHtcbiAgICAgICAgaWYgKHpyKSB7XG4gICAgICAgICAgICB6ci5kaXNwb3NlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gaW5zdGFuY2VzKSB7XG4gICAgICAgICAgICAgICAgaW5zdGFuY2VzW2tleV0uZGlzcG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW5zdGFuY2VzID0ge307XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4genJlbmRlcjtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IHpyZW5kZXIgaW5zdGFuY2UgYnkgaWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgenJlbmRlciBpbnN0YW5jZSBpZFxuICAgICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL1pSZW5kZXJ9XG4gICAgICovXG4gICAgenJlbmRlci5nZXRJbnN0YW5jZSA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICByZXR1cm4gaW5zdGFuY2VzW2lkXTtcbiAgICB9O1xuXG4gICAgenJlbmRlci5yZWdpc3RlclBhaW50ZXIgPSBmdW5jdGlvbiAobmFtZSwgQ3Rvcikge1xuICAgICAgICBwYWludGVyQ3RvcnNbbmFtZV0gPSBDdG9yO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBkZWxJbnN0YW5jZShpZCkge1xuICAgICAgICBkZWxldGUgaW5zdGFuY2VzW2lkXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbW9kdWxlIHpyZW5kZXIvWlJlbmRlclxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBhbGlhcyBtb2R1bGU6enJlbmRlci9aUmVuZGVyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGlkXG4gICAgICogQHBhcmFtIHtIVE1MRG9tRWxlbWVudH0gZG9tXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMucmVuZGVyZXI9J2NhbnZhcyddICdjYW52YXMnIG9yICdzdmcnXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRzLmRldmljZVBpeGVsUmF0aW9dXG4gICAgICovXG4gICAgdmFyIFpSZW5kZXIgPSBmdW5jdGlvbihpZCwgZG9tLCBvcHRzKSB7XG5cbiAgICAgICAgb3B0cyA9IG9wdHMgfHwge307XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtIVE1MRG9tRWxlbWVudH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZG9tID0gZG9tO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pZCA9IGlkO1xuXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIHN0b3JhZ2UgPSBuZXcgU3RvcmFnZSgpO1xuXG4gICAgICAgIHZhciByZW5kZXJlclR5cGUgPSBvcHRzLnJlbmRlcmVyO1xuICAgICAgICBpZiAodXNlVk1MKSB7XG4gICAgICAgICAgICBpZiAoIXBhaW50ZXJDdG9ycy52bWwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBuZWVkIHRvIHJlcXVpcmUgXFwnenJlbmRlci92bWwvdm1sXFwnIHRvIHN1cHBvcnQgSUU4Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZW5kZXJlclR5cGUgPSAndm1sJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghcmVuZGVyZXJUeXBlIHx8ICFwYWludGVyQ3RvcnNbcmVuZGVyZXJUeXBlXSkge1xuICAgICAgICAgICAgcmVuZGVyZXJUeXBlID0gJ2NhbnZhcyc7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBhaW50ZXIgPSBuZXcgcGFpbnRlckN0b3JzW3JlbmRlcmVyVHlwZV0oZG9tLCBzdG9yYWdlLCBvcHRzKTtcblxuICAgICAgICB0aGlzLnN0b3JhZ2UgPSBzdG9yYWdlO1xuICAgICAgICB0aGlzLnBhaW50ZXIgPSBwYWludGVyO1xuXG4gICAgICAgIHZhciBoYW5kZXJQcm94eSA9ICFlbnYubm9kZSA/IG5ldyBIYW5kbGVyUHJveHkocGFpbnRlci5nZXRWaWV3cG9ydFJvb3QoKSkgOiBudWxsO1xuICAgICAgICB0aGlzLmhhbmRsZXIgPSBuZXcgSGFuZGxlcihzdG9yYWdlLCBwYWludGVyLCBoYW5kZXJQcm94eSk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHttb2R1bGU6enJlbmRlci9hbmltYXRpb24vQW5pbWF0aW9ufVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5hbmltYXRpb24gPSBuZXcgQW5pbWF0aW9uKHtcbiAgICAgICAgICAgIHN0YWdlOiB7XG4gICAgICAgICAgICAgICAgdXBkYXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLl9uZWVkc1JlZnJlc2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYucmVmcmVzaEltbWVkaWF0ZWx5KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuX25lZWRzUmVmcmVzaEhvdmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnJlZnJlc2hIb3ZlckltbWVkaWF0ZWx5KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmFuaW1hdGlvbi5zdGFydCgpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX25lZWRzUmVmcmVzaDtcblxuICAgICAgICAvLyDkv67mlLkgc3RvcmFnZS5kZWxGcm9tTWFwLCDmr4/mrKHliKDpmaTlhYPntKDkuYvliY3liKDpmaTliqjnlLtcbiAgICAgICAgLy8gRklYTUUg5pyJ54K5dWdseVxuICAgICAgICB2YXIgb2xkRGVsRnJvbU1hcCA9IHN0b3JhZ2UuZGVsRnJvbU1hcDtcbiAgICAgICAgdmFyIG9sZEFkZFRvTWFwID0gc3RvcmFnZS5hZGRUb01hcDtcblxuICAgICAgICBzdG9yYWdlLmRlbEZyb21NYXAgPSBmdW5jdGlvbiAoZWxJZCkge1xuICAgICAgICAgICAgdmFyIGVsID0gc3RvcmFnZS5nZXQoZWxJZCk7XG5cbiAgICAgICAgICAgIG9sZERlbEZyb21NYXAuY2FsbChzdG9yYWdlLCBlbElkKTtcblxuICAgICAgICAgICAgZWwgJiYgZWwucmVtb3ZlU2VsZkZyb21acihzZWxmKTtcbiAgICAgICAgfTtcblxuICAgICAgICBzdG9yYWdlLmFkZFRvTWFwID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICBvbGRBZGRUb01hcC5jYWxsKHN0b3JhZ2UsIGVsKTtcblxuICAgICAgICAgICAgZWwuYWRkU2VsZlRvWnIoc2VsZik7XG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIFpSZW5kZXIucHJvdG90eXBlID0ge1xuXG4gICAgICAgIGNvbnN0cnVjdG9yOiBaUmVuZGVyLFxuICAgICAgICAvKipcbiAgICAgICAgICog6I635Y+W5a6e5L6L5ZSv5LiA5qCH6K+GXG4gICAgICAgICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIGdldElkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pZDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5re75Yqg5YWD57SgXG4gICAgICAgICAqIEBwYXJhbSAge21vZHVsZTp6cmVuZGVyL0VsZW1lbnR9IGVsXG4gICAgICAgICAqL1xuICAgICAgICBhZGQ6IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgdGhpcy5zdG9yYWdlLmFkZFJvb3QoZWwpO1xuICAgICAgICAgICAgdGhpcy5fbmVlZHNSZWZyZXNoID0gdHJ1ZTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5Yig6Zmk5YWD57SgXG4gICAgICAgICAqIEBwYXJhbSAge21vZHVsZTp6cmVuZGVyL0VsZW1lbnR9IGVsXG4gICAgICAgICAqL1xuICAgICAgICByZW1vdmU6IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgdGhpcy5zdG9yYWdlLmRlbFJvb3QoZWwpO1xuICAgICAgICAgICAgdGhpcy5fbmVlZHNSZWZyZXNoID0gdHJ1ZTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2hhbmdlIGNvbmZpZ3VyYXRpb24gb2YgbGF5ZXJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHpMZXZlbFxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY29uZmlnLmNsZWFyQ29sb3I9MF0gQ2xlYXIgY29sb3JcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtjb25maWcubW90aW9uQmx1cj1mYWxzZV0gSWYgZW5hYmxlIG1vdGlvbiBibHVyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbY29uZmlnLmxhc3RGcmFtZUFscGhhPTAuN10gTW90aW9uIGJsdXIgZmFjdG9yLiBMYXJnZXIgdmFsdWUgY2F1c2UgbG9uZ2VyIHRyYWlsZXJcbiAgICAgICAgKi9cbiAgICAgICAgY29uZmlnTGF5ZXI6IGZ1bmN0aW9uICh6TGV2ZWwsIGNvbmZpZykge1xuICAgICAgICAgICAgdGhpcy5wYWludGVyLmNvbmZpZ0xheWVyKHpMZXZlbCwgY29uZmlnKTtcbiAgICAgICAgICAgIHRoaXMuX25lZWRzUmVmcmVzaCA9IHRydWU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlcGFpbnQgdGhlIGNhbnZhcyBpbW1lZGlhdGVseVxuICAgICAgICAgKi9cbiAgICAgICAgcmVmcmVzaEltbWVkaWF0ZWx5OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBDbGVhciBuZWVkc1JlZnJlc2ggYWhlYWQgdG8gYXZvaWQgc29tZXRoaW5nIHdyb25nIGhhcHBlbnMgaW4gcmVmcmVzaFxuICAgICAgICAgICAgLy8gT3IgaXQgd2lsbCBjYXVzZSB6cmVuZGVyIHJlZnJlc2hlcyBhZ2FpbiBhbmQgYWdhaW4uXG4gICAgICAgICAgICB0aGlzLl9uZWVkc1JlZnJlc2ggPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMucGFpbnRlci5yZWZyZXNoKCk7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEF2b2lkIHRyaWdnZXIgenIucmVmcmVzaCBpbiBFbGVtZW50I2JlZm9yZVVwZGF0ZSBob29rXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuX25lZWRzUmVmcmVzaCA9IGZhbHNlO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNYXJrIGFuZCByZXBhaW50IHRoZSBjYW52YXMgaW4gdGhlIG5leHQgZnJhbWUgb2YgYnJvd3NlclxuICAgICAgICAgKi9cbiAgICAgICAgcmVmcmVzaDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLl9uZWVkc1JlZnJlc2ggPSB0cnVlO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBZGQgZWxlbWVudCB0byBob3ZlciBsYXllclxuICAgICAgICAgKiBAcGFyYW0gIHttb2R1bGU6enJlbmRlci9FbGVtZW50fSBlbFxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gc3R5bGVcbiAgICAgICAgICovXG4gICAgICAgIGFkZEhvdmVyOiBmdW5jdGlvbiAoZWwsIHN0eWxlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wYWludGVyLmFkZEhvdmVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wYWludGVyLmFkZEhvdmVyKGVsLCBzdHlsZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWZyZXNoSG92ZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQWRkIGVsZW1lbnQgZnJvbSBob3ZlciBsYXllclxuICAgICAgICAgKiBAcGFyYW0gIHttb2R1bGU6enJlbmRlci9FbGVtZW50fSBlbFxuICAgICAgICAgKi9cbiAgICAgICAgcmVtb3ZlSG92ZXI6IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucGFpbnRlci5yZW1vdmVIb3Zlcikge1xuICAgICAgICAgICAgICAgIHRoaXMucGFpbnRlci5yZW1vdmVIb3ZlcihlbCk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWZyZXNoSG92ZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2xlYXIgYWxsIGhvdmVyIGVsZW1lbnRzIGluIGhvdmVyIGxheWVyXG4gICAgICAgICAqIEBwYXJhbSAge21vZHVsZTp6cmVuZGVyL0VsZW1lbnR9IGVsXG4gICAgICAgICAqL1xuICAgICAgICBjbGVhckhvdmVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wYWludGVyLmNsZWFySG92ZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBhaW50ZXIuY2xlYXJIb3ZlcigpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVmcmVzaEhvdmVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlZnJlc2ggaG92ZXIgaW4gbmV4dCBmcmFtZVxuICAgICAgICAgKi9cbiAgICAgICAgcmVmcmVzaEhvdmVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl9uZWVkc1JlZnJlc2hIb3ZlciA9IHRydWU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlZnJlc2ggaG92ZXIgaW1tZWRpYXRlbHlcbiAgICAgICAgICovXG4gICAgICAgIHJlZnJlc2hIb3ZlckltbWVkaWF0ZWx5OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl9uZWVkc1JlZnJlc2hIb3ZlciA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5wYWludGVyLnJlZnJlc2hIb3ZlciAmJiB0aGlzLnBhaW50ZXIucmVmcmVzaEhvdmVyKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlc2l6ZSB0aGUgY2FudmFzLlxuICAgICAgICAgKiBTaG91bGQgYmUgaW52b2tlZCB3aGVuIGNvbnRhaW5lciBzaXplIGlzIGNoYW5nZWRcbiAgICAgICAgICovXG4gICAgICAgIHJlc2l6ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLnBhaW50ZXIucmVzaXplKCk7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZXIucmVzaXplKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFN0b3AgYW5kIGNsZWFyIGFsbCBhbmltYXRpb24gaW1tZWRpYXRlbHlcbiAgICAgICAgICovXG4gICAgICAgIGNsZWFyQW5pbWF0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLmFuaW1hdGlvbi5jbGVhcigpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgY29udGFpbmVyIHdpZHRoXG4gICAgICAgICAqL1xuICAgICAgICBnZXRXaWR0aDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYWludGVyLmdldFdpZHRoKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCBjb250YWluZXIgaGVpZ2h0XG4gICAgICAgICAqL1xuICAgICAgICBnZXRIZWlnaHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFpbnRlci5nZXRIZWlnaHQoKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogRXhwb3J0IHRoZSBjYW52YXMgYXMgQmFzZTY0IFVSTFxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2JhY2tncm91bmRDb2xvcj0nI2ZmZiddXG4gICAgICAgICAqIEByZXR1cm4ge3N0cmluZ30gQmFzZTY0IFVSTFxuICAgICAgICAgKi9cbiAgICAgICAgLy8gdG9EYXRhVVJMOiBmdW5jdGlvbih0eXBlLCBiYWNrZ3JvdW5kQ29sb3IpIHtcbiAgICAgICAgLy8gICAgIHJldHVybiB0aGlzLnBhaW50ZXIuZ2V0UmVuZGVyZWRDYW52YXMoe1xuICAgICAgICAvLyAgICAgICAgIGJhY2tncm91bmRDb2xvcjogYmFja2dyb3VuZENvbG9yXG4gICAgICAgIC8vICAgICB9KS50b0RhdGFVUkwodHlwZSk7XG4gICAgICAgIC8vIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnZlcnRpbmcgYSBwYXRoIHRvIGltYWdlLlxuICAgICAgICAgKiBJdCBoYXMgbXVjaCBiZXR0ZXIgcGVyZm9ybWFuY2Ugb2YgZHJhd2luZyBpbWFnZSByYXRoZXIgdGhhbiBkcmF3aW5nIGEgdmVjdG9yIHBhdGguXG4gICAgICAgICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvZ3JhcGhpYy9QYXRofSBlXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aFxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0XG4gICAgICAgICAqL1xuICAgICAgICBwYXRoVG9JbWFnZTogZnVuY3Rpb24oZSwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgICAgICAgdmFyIGlkID0gZ3VpZCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFpbnRlci5wYXRoVG9JbWFnZShpZCwgZSwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldCBkZWZhdWx0IGN1cnNvclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2N1cnNvclN0eWxlPSdkZWZhdWx0J10g5L6L5aaCIGNyb3NzaGFpclxuICAgICAgICAgKi9cbiAgICAgICAgc2V0Q3Vyc29yU3R5bGU6IGZ1bmN0aW9uIChjdXJzb3JTdHlsZSkge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVyLnNldEN1cnNvclN0eWxlKGN1cnNvclN0eWxlKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQmluZCBldmVudFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lIEV2ZW50IG5hbWVcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXZlbnRIYW5kbGVyIEhhbmRsZXIgZnVuY3Rpb25cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IFtjb250ZXh0XSBDb250ZXh0IG9iamVjdFxuICAgICAgICAgKi9cbiAgICAgICAgb246IGZ1bmN0aW9uKGV2ZW50TmFtZSwgZXZlbnRIYW5kbGVyLCBjb250ZXh0KSB7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZXIub24oZXZlbnROYW1lLCBldmVudEhhbmRsZXIsIGNvbnRleHQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVbmJpbmQgZXZlbnRcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSBFdmVudCBuYW1lXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtldmVudEhhbmRsZXJdIEhhbmRsZXIgZnVuY3Rpb25cbiAgICAgICAgICovXG4gICAgICAgIG9mZjogZnVuY3Rpb24oZXZlbnROYW1lLCBldmVudEhhbmRsZXIpIHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlci5vZmYoZXZlbnROYW1lLCBldmVudEhhbmRsZXIpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUcmlnZ2VyIGV2ZW50IG1hbnVhbGx5XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUgRXZlbnQgbmFtZVxuICAgICAgICAgKiBAcGFyYW0ge2V2ZW50PX0gZXZlbnQgRXZlbnQgb2JqZWN0XG4gICAgICAgICAqL1xuICAgICAgICB0cmlnZ2VyOiBmdW5jdGlvbiAoZXZlbnROYW1lLCBldmVudCkge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVyLnRyaWdnZXIoZXZlbnROYW1lLCBldmVudCk7XG4gICAgICAgIH0sXG5cblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2xlYXIgYWxsIG9iamVjdHMgYW5kIHRoZSBjYW52YXMuXG4gICAgICAgICAqL1xuICAgICAgICBjbGVhcjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5zdG9yYWdlLmRlbFJvb3QoKTtcbiAgICAgICAgICAgIHRoaXMucGFpbnRlci5jbGVhcigpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEaXNwb3NlIHNlbGYuXG4gICAgICAgICAqL1xuICAgICAgICBkaXNwb3NlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLmFuaW1hdGlvbi5zdG9wKCk7XG5cbiAgICAgICAgICAgIHRoaXMuY2xlYXIoKTtcbiAgICAgICAgICAgIHRoaXMuc3RvcmFnZS5kaXNwb3NlKCk7XG4gICAgICAgICAgICB0aGlzLnBhaW50ZXIuZGlzcG9zZSgpO1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVyLmRpc3Bvc2UoKTtcblxuICAgICAgICAgICAgdGhpcy5hbmltYXRpb24gPVxuICAgICAgICAgICAgdGhpcy5zdG9yYWdlID1cbiAgICAgICAgICAgIHRoaXMucGFpbnRlciA9XG4gICAgICAgICAgICB0aGlzLmhhbmRsZXIgPSBudWxsO1xuXG4gICAgICAgICAgICBkZWxJbnN0YW5jZSh0aGlzLmlkKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHpyZW5kZXI7XG5cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3pyZW5kZXIvbGliL3pyZW5kZXIuanNcbiAqKiBtb2R1bGUgaWQgPSA1OVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBlY2hhcnRz6K6+5aSH546v5aKD6K+G5YirXG4gKlxuICogQGRlc2MgZWNoYXJ0c+WfuuS6jkNhbnZhc++8jOe6r0phdmFzY3JpcHTlm77ooajlupPvvIzmj5Dkvpvnm7Top4LvvIznlJ/liqjvvIzlj6/kuqTkupLvvIzlj6/kuKrmgKfljJblrprliLbnmoTmlbDmja7nu5/orqHlm77ooajjgIJcbiAqIEBhdXRob3IgZmlyZWRlW2ZpcmVkZUBmaXJlZGUudXNdXG4gKiBAZGVzYyB0aGFua3MgemVwdG8uXG4gKi9cblxuICAgIHZhciBlbnYgPSB7fTtcbiAgICBpZiAodHlwZW9mIG5hdmlnYXRvciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgLy8gSW4gbm9kZVxuICAgICAgICBlbnYgPSB7XG4gICAgICAgICAgICBicm93c2VyOiB7fSxcbiAgICAgICAgICAgIG9zOiB7fSxcbiAgICAgICAgICAgIG5vZGU6IHRydWUsXG4gICAgICAgICAgICAvLyBBc3N1bWUgY2FudmFzIGlzIHN1cHBvcnRlZFxuICAgICAgICAgICAgY2FudmFzU3VwcG9ydGVkOiB0cnVlXG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBlbnYgPSBkZXRlY3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBlbnY7XG5cbiAgICAvLyBaZXB0by5qc1xuICAgIC8vIChjKSAyMDEwLTIwMTMgVGhvbWFzIEZ1Y2hzXG4gICAgLy8gWmVwdG8uanMgbWF5IGJlIGZyZWVseSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG5cbiAgICBmdW5jdGlvbiBkZXRlY3QodWEpIHtcbiAgICAgICAgdmFyIG9zID0ge307XG4gICAgICAgIHZhciBicm93c2VyID0ge307XG4gICAgICAgIC8vIHZhciB3ZWJraXQgPSB1YS5tYXRjaCgvV2ViW2tLXWl0W1xcL117MCwxfShbXFxkLl0rKS8pO1xuICAgICAgICAvLyB2YXIgYW5kcm9pZCA9IHVhLm1hdGNoKC8oQW5kcm9pZCk7P1tcXHNcXC9dKyhbXFxkLl0rKT8vKTtcbiAgICAgICAgLy8gdmFyIGlwYWQgPSB1YS5tYXRjaCgvKGlQYWQpLipPU1xccyhbXFxkX10rKS8pO1xuICAgICAgICAvLyB2YXIgaXBvZCA9IHVhLm1hdGNoKC8oaVBvZCkoLipPU1xccyhbXFxkX10rKSk/Lyk7XG4gICAgICAgIC8vIHZhciBpcGhvbmUgPSAhaXBhZCAmJiB1YS5tYXRjaCgvKGlQaG9uZVxcc09TKVxccyhbXFxkX10rKS8pO1xuICAgICAgICAvLyB2YXIgd2Vib3MgPSB1YS5tYXRjaCgvKHdlYk9TfGhwd09TKVtcXHNcXC9dKFtcXGQuXSspLyk7XG4gICAgICAgIC8vIHZhciB0b3VjaHBhZCA9IHdlYm9zICYmIHVhLm1hdGNoKC9Ub3VjaFBhZC8pO1xuICAgICAgICAvLyB2YXIga2luZGxlID0gdWEubWF0Y2goL0tpbmRsZVxcLyhbXFxkLl0rKS8pO1xuICAgICAgICAvLyB2YXIgc2lsayA9IHVhLm1hdGNoKC9TaWxrXFwvKFtcXGQuX10rKS8pO1xuICAgICAgICAvLyB2YXIgYmxhY2tiZXJyeSA9IHVhLm1hdGNoKC8oQmxhY2tCZXJyeSkuKlZlcnNpb25cXC8oW1xcZC5dKykvKTtcbiAgICAgICAgLy8gdmFyIGJiMTAgPSB1YS5tYXRjaCgvKEJCMTApLipWZXJzaW9uXFwvKFtcXGQuXSspLyk7XG4gICAgICAgIC8vIHZhciByaW10YWJsZXRvcyA9IHVhLm1hdGNoKC8oUklNXFxzVGFibGV0XFxzT1MpXFxzKFtcXGQuXSspLyk7XG4gICAgICAgIC8vIHZhciBwbGF5Ym9vayA9IHVhLm1hdGNoKC9QbGF5Qm9vay8pO1xuICAgICAgICAvLyB2YXIgY2hyb21lID0gdWEubWF0Y2goL0Nocm9tZVxcLyhbXFxkLl0rKS8pIHx8IHVhLm1hdGNoKC9DcmlPU1xcLyhbXFxkLl0rKS8pO1xuICAgICAgICB2YXIgZmlyZWZveCA9IHVhLm1hdGNoKC9GaXJlZm94XFwvKFtcXGQuXSspLyk7XG4gICAgICAgIC8vIHZhciBzYWZhcmkgPSB3ZWJraXQgJiYgdWEubWF0Y2goL01vYmlsZVxcLy8pICYmICFjaHJvbWU7XG4gICAgICAgIC8vIHZhciB3ZWJ2aWV3ID0gdWEubWF0Y2goLyhpUGhvbmV8aVBvZHxpUGFkKS4qQXBwbGVXZWJLaXQoPyEuKlNhZmFyaSkvKSAmJiAhY2hyb21lO1xuICAgICAgICB2YXIgaWUgPSB1YS5tYXRjaCgvTVNJRVxccyhbXFxkLl0rKS8pXG4gICAgICAgICAgICAvLyBJRSAxMSBUcmlkZW50LzcuMDsgcnY6MTEuMFxuICAgICAgICAgICAgfHwgdWEubWF0Y2goL1RyaWRlbnRcXC8uKz9ydjooKFtcXGQuXSspKS8pO1xuICAgICAgICB2YXIgZWRnZSA9IHVhLm1hdGNoKC9FZGdlXFwvKFtcXGQuXSspLyk7IC8vIElFIDEyIGFuZCAxMitcblxuICAgICAgICAvLyBUb2RvOiBjbGVhbiB0aGlzIHVwIHdpdGggYSBiZXR0ZXIgT1MvYnJvd3NlciBzZXBlcmF0aW9uOlxuICAgICAgICAvLyAtIGRpc2Nlcm4gKG1vcmUpIGJldHdlZW4gbXVsdGlwbGUgYnJvd3NlcnMgb24gYW5kcm9pZFxuICAgICAgICAvLyAtIGRlY2lkZSBpZiBraW5kbGUgZmlyZSBpbiBzaWxrIG1vZGUgaXMgYW5kcm9pZCBvciBub3RcbiAgICAgICAgLy8gLSBGaXJlZm94IG9uIEFuZHJvaWQgZG9lc24ndCBzcGVjaWZ5IHRoZSBBbmRyb2lkIHZlcnNpb25cbiAgICAgICAgLy8gLSBwb3NzaWJseSBkZXZpZGUgaW4gb3MsIGRldmljZSBhbmQgYnJvd3NlciBoYXNoZXNcblxuICAgICAgICAvLyBpZiAoYnJvd3Nlci53ZWJraXQgPSAhIXdlYmtpdCkgYnJvd3Nlci52ZXJzaW9uID0gd2Via2l0WzFdO1xuXG4gICAgICAgIC8vIGlmIChhbmRyb2lkKSBvcy5hbmRyb2lkID0gdHJ1ZSwgb3MudmVyc2lvbiA9IGFuZHJvaWRbMl07XG4gICAgICAgIC8vIGlmIChpcGhvbmUgJiYgIWlwb2QpIG9zLmlvcyA9IG9zLmlwaG9uZSA9IHRydWUsIG9zLnZlcnNpb24gPSBpcGhvbmVbMl0ucmVwbGFjZSgvXy9nLCAnLicpO1xuICAgICAgICAvLyBpZiAoaXBhZCkgb3MuaW9zID0gb3MuaXBhZCA9IHRydWUsIG9zLnZlcnNpb24gPSBpcGFkWzJdLnJlcGxhY2UoL18vZywgJy4nKTtcbiAgICAgICAgLy8gaWYgKGlwb2QpIG9zLmlvcyA9IG9zLmlwb2QgPSB0cnVlLCBvcy52ZXJzaW9uID0gaXBvZFszXSA/IGlwb2RbM10ucmVwbGFjZSgvXy9nLCAnLicpIDogbnVsbDtcbiAgICAgICAgLy8gaWYgKHdlYm9zKSBvcy53ZWJvcyA9IHRydWUsIG9zLnZlcnNpb24gPSB3ZWJvc1syXTtcbiAgICAgICAgLy8gaWYgKHRvdWNocGFkKSBvcy50b3VjaHBhZCA9IHRydWU7XG4gICAgICAgIC8vIGlmIChibGFja2JlcnJ5KSBvcy5ibGFja2JlcnJ5ID0gdHJ1ZSwgb3MudmVyc2lvbiA9IGJsYWNrYmVycnlbMl07XG4gICAgICAgIC8vIGlmIChiYjEwKSBvcy5iYjEwID0gdHJ1ZSwgb3MudmVyc2lvbiA9IGJiMTBbMl07XG4gICAgICAgIC8vIGlmIChyaW10YWJsZXRvcykgb3MucmltdGFibGV0b3MgPSB0cnVlLCBvcy52ZXJzaW9uID0gcmltdGFibGV0b3NbMl07XG4gICAgICAgIC8vIGlmIChwbGF5Ym9vaykgYnJvd3Nlci5wbGF5Ym9vayA9IHRydWU7XG4gICAgICAgIC8vIGlmIChraW5kbGUpIG9zLmtpbmRsZSA9IHRydWUsIG9zLnZlcnNpb24gPSBraW5kbGVbMV07XG4gICAgICAgIC8vIGlmIChzaWxrKSBicm93c2VyLnNpbGsgPSB0cnVlLCBicm93c2VyLnZlcnNpb24gPSBzaWxrWzFdO1xuICAgICAgICAvLyBpZiAoIXNpbGsgJiYgb3MuYW5kcm9pZCAmJiB1YS5tYXRjaCgvS2luZGxlIEZpcmUvKSkgYnJvd3Nlci5zaWxrID0gdHJ1ZTtcbiAgICAgICAgLy8gaWYgKGNocm9tZSkgYnJvd3Nlci5jaHJvbWUgPSB0cnVlLCBicm93c2VyLnZlcnNpb24gPSBjaHJvbWVbMV07XG4gICAgICAgIGlmIChmaXJlZm94KSBicm93c2VyLmZpcmVmb3ggPSB0cnVlLCBicm93c2VyLnZlcnNpb24gPSBmaXJlZm94WzFdO1xuICAgICAgICAvLyBpZiAoc2FmYXJpICYmICh1YS5tYXRjaCgvU2FmYXJpLykgfHwgISFvcy5pb3MpKSBicm93c2VyLnNhZmFyaSA9IHRydWU7XG4gICAgICAgIC8vIGlmICh3ZWJ2aWV3KSBicm93c2VyLndlYnZpZXcgPSB0cnVlO1xuICAgICAgICBpZiAoaWUpIHtcbiAgICAgICAgICAgIGJyb3dzZXIuaWUgPSB0cnVlOyBicm93c2VyLnZlcnNpb24gPSBpZVsxXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaWUpIHtcbiAgICAgICAgICAgIGJyb3dzZXIuaWUgPSB0cnVlO1xuICAgICAgICAgICAgYnJvd3Nlci52ZXJzaW9uID0gaWVbMV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVkZ2UpIHtcbiAgICAgICAgICAgIGJyb3dzZXIuZWRnZSA9IHRydWU7XG4gICAgICAgICAgICBicm93c2VyLnZlcnNpb24gPSBlZGdlWzFdO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gb3MudGFibGV0ID0gISEoaXBhZCB8fCBwbGF5Ym9vayB8fCAoYW5kcm9pZCAmJiAhdWEubWF0Y2goL01vYmlsZS8pKSB8fFxuICAgICAgICAvLyAgICAgKGZpcmVmb3ggJiYgdWEubWF0Y2goL1RhYmxldC8pKSB8fCAoaWUgJiYgIXVhLm1hdGNoKC9QaG9uZS8pICYmIHVhLm1hdGNoKC9Ub3VjaC8pKSk7XG4gICAgICAgIC8vIG9zLnBob25lICA9ICEhKCFvcy50YWJsZXQgJiYgIW9zLmlwb2QgJiYgKGFuZHJvaWQgfHwgaXBob25lIHx8IHdlYm9zIHx8XG4gICAgICAgIC8vICAgICAoY2hyb21lICYmIHVhLm1hdGNoKC9BbmRyb2lkLykpIHx8IChjaHJvbWUgJiYgdWEubWF0Y2goL0NyaU9TXFwvKFtcXGQuXSspLykpIHx8XG4gICAgICAgIC8vICAgICAoZmlyZWZveCAmJiB1YS5tYXRjaCgvTW9iaWxlLykpIHx8IChpZSAmJiB1YS5tYXRjaCgvVG91Y2gvKSkpKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYnJvd3NlcjogYnJvd3NlcixcbiAgICAgICAgICAgIG9zOiBvcyxcbiAgICAgICAgICAgIG5vZGU6IGZhbHNlLFxuICAgICAgICAgICAgLy8g5Y6f55SfY2FudmFz5pSv5oyB77yM5pS55p6B56uv54K55LqGXG4gICAgICAgICAgICAvLyBjYW52YXNTdXBwb3J0ZWQgOiAhKGJyb3dzZXIuaWUgJiYgcGFyc2VGbG9hdChicm93c2VyLnZlcnNpb24pIDwgOSlcbiAgICAgICAgICAgIGNhbnZhc1N1cHBvcnRlZCA6IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpLmdldENvbnRleHQgPyB0cnVlIDogZmFsc2UsXG4gICAgICAgICAgICAvLyBAc2VlIDxodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzQ4MTcwMjkvd2hhdHMtdGhlLWJlc3Qtd2F5LXRvLWRldGVjdC1hLXRvdWNoLXNjcmVlbi1kZXZpY2UtdXNpbmctamF2YXNjcmlwdD5cbiAgICAgICAgICAgIC8vIHdvcmtzIG9uIG1vc3QgYnJvd3NlcnNcbiAgICAgICAgICAgIC8vIElFMTAvMTEgZG9lcyBub3Qgc3VwcG9ydCB0b3VjaCBldmVudCwgYW5kIE1TIEVkZ2Ugc3VwcG9ydHMgdGhlbSBidXQgbm90IGJ5XG4gICAgICAgICAgICAvLyBkZWZhdWx0LCBzbyB3ZSBkb250IGNoZWNrIG5hdmlnYXRvci5tYXhUb3VjaFBvaW50cyBmb3IgdGhlbSBoZXJlLlxuICAgICAgICAgICAgdG91Y2hFdmVudHNTdXBwb3J0ZWQ6ICdvbnRvdWNoc3RhcnQnIGluIHdpbmRvdyAmJiAhYnJvd3Nlci5pZSAmJiAhYnJvd3Nlci5lZGdlLFxuICAgICAgICAgICAgLy8gPGh0dHA6Ly9jYW5pdXNlLmNvbS8jc2VhcmNoPXBvaW50ZXIlMjBldmVudD4uXG4gICAgICAgICAgICBwb2ludGVyRXZlbnRzU3VwcG9ydGVkOiAnb25wb2ludGVyZG93bicgaW4gd2luZG93XG4gICAgICAgICAgICAgICAgLy8gRmlyZWZveCBzdXBwb3J0cyBwb2ludGVyIGJ1dCBub3QgYnkgZGVmYXVsdCxcbiAgICAgICAgICAgICAgICAvLyBvbmx5IE1TIGJyb3dzZXJzIGFyZSByZWxpYWJsZSBvbiBwb2ludGVyIGV2ZW50cyBjdXJyZW50bHkuXG4gICAgICAgICAgICAgICAgJiYgKGJyb3dzZXIuZWRnZSB8fCAoYnJvd3Nlci5pZSAmJiBicm93c2VyLnZlcnNpb24gPj0gMTApKVxuICAgICAgICB9O1xuICAgIH1cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3pyZW5kZXIvbGliL2NvcmUvZW52LmpzXG4gKiogbW9kdWxlIGlkID0gNjBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0Jztcbi8qKlxuICogSGFuZGxlclxuICogQG1vZHVsZSB6cmVuZGVyL0hhbmRsZXJcbiAqIEBhdXRob3IgS2VuZXIgKEBLZW5lci3mnpfls7AsIGtlbmVyLmxpbmZlbmdAZ21haWwuY29tKVxuICogICAgICAgICBlcnJvcnJpayAoZXJyb3JyaWtAZ21haWwuY29tKVxuICogICAgICAgICBwaXNzYW5nIChzaGVueWkuOTE0QGdtYWlsLmNvbSlcbiAqL1xuXG5cbiAgICB2YXIgdXRpbCA9IHJlcXVpcmUoJy4vY29yZS91dGlsJyk7XG4gICAgdmFyIERyYWdnYWJsZSA9IHJlcXVpcmUoJy4vbWl4aW4vRHJhZ2dhYmxlJyk7XG5cbiAgICB2YXIgRXZlbnRmdWwgPSByZXF1aXJlKCcuL21peGluL0V2ZW50ZnVsJyk7XG5cbiAgICBmdW5jdGlvbiBtYWtlRXZlbnRQYWNrZXQoZXZlVHlwZSwgdGFyZ2V0LCBldmVudCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogZXZlVHlwZSxcbiAgICAgICAgICAgIGV2ZW50OiBldmVudCxcbiAgICAgICAgICAgIHRhcmdldDogdGFyZ2V0LFxuICAgICAgICAgICAgY2FuY2VsQnViYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIG9mZnNldFg6IGV2ZW50LnpyWCxcbiAgICAgICAgICAgIG9mZnNldFk6IGV2ZW50LnpyWSxcbiAgICAgICAgICAgIGdlc3R1cmVFdmVudDogZXZlbnQuZ2VzdHVyZUV2ZW50LFxuICAgICAgICAgICAgcGluY2hYOiBldmVudC5waW5jaFgsXG4gICAgICAgICAgICBwaW5jaFk6IGV2ZW50LnBpbmNoWSxcbiAgICAgICAgICAgIHBpbmNoU2NhbGU6IGV2ZW50LnBpbmNoU2NhbGUsXG4gICAgICAgICAgICB3aGVlbERlbHRhOiBldmVudC56ckRlbHRhXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gRW1wdHlQcm94eSAoKSB7fVxuICAgIEVtcHR5UHJveHkucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7fTtcblxuICAgIHZhciBoYW5kbGVyTmFtZXMgPSBbXG4gICAgICAgICdjbGljaycsICdkYmxjbGljaycsICdtb3VzZXdoZWVsJywgJ21vdXNlb3V0JyxcbiAgICAgICAgJ21vdXNldXAnLCAnbW91c2Vkb3duJywgJ21vdXNlbW92ZSdcbiAgICBdO1xuICAgIC8qKlxuICAgICAqIEBhbGlhcyBtb2R1bGU6enJlbmRlci9IYW5kbGVyXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQGV4dGVuZHMgbW9kdWxlOnpyZW5kZXIvbWl4aW4vRXZlbnRmdWxcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSByb290IE1haW4gSFRNTCBlbGVtZW50IGZvciBwYWludGluZy5cbiAgICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL1N0b3JhZ2V9IHN0b3JhZ2UgU3RvcmFnZSBpbnN0YW5jZS5cbiAgICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL1BhaW50ZXJ9IHBhaW50ZXIgUGFpbnRlciBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICB2YXIgSGFuZGxlciA9IGZ1bmN0aW9uKHN0b3JhZ2UsIHBhaW50ZXIsIHByb3h5KSB7XG4gICAgICAgIEV2ZW50ZnVsLmNhbGwodGhpcyk7XG5cbiAgICAgICAgdGhpcy5zdG9yYWdlID0gc3RvcmFnZTtcblxuICAgICAgICB0aGlzLnBhaW50ZXIgPSBwYWludGVyO1xuXG4gICAgICAgIHByb3h5ID0gcHJveHkgfHwgbmV3IEVtcHR5UHJveHkoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFByb3h5IG9mIGV2ZW50LiBjYW4gYmUgRG9tLCBXZWJHTFN1cmZhY2UsIGV0Yy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucHJveHkgPSBwcm94eTtcblxuICAgICAgICAvLyBBdHRhY2ggaGFuZGxlclxuICAgICAgICBwcm94eS5oYW5kbGVyID0gdGhpcztcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9ob3ZlcmVkO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAdHlwZSB7RGF0ZX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2xhc3RUb3VjaE1vbWVudDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2xhc3RYO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fbGFzdFk7XG5cblxuICAgICAgICBEcmFnZ2FibGUuY2FsbCh0aGlzKTtcblxuICAgICAgICB1dGlsLmVhY2goaGFuZGxlck5hbWVzLCBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgcHJveHkub24gJiYgcHJveHkub24obmFtZSwgdGhpc1tuYW1lXSwgdGhpcyk7XG4gICAgICAgIH0sIHRoaXMpO1xuICAgIH07XG5cbiAgICBIYW5kbGVyLnByb3RvdHlwZSA9IHtcblxuICAgICAgICBjb25zdHJ1Y3RvcjogSGFuZGxlcixcblxuICAgICAgICBtb3VzZW1vdmU6IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgdmFyIHggPSBldmVudC56clg7XG4gICAgICAgICAgICB2YXIgeSA9IGV2ZW50LnpyWTtcblxuICAgICAgICAgICAgdmFyIGhvdmVyZWQgPSB0aGlzLmZpbmRIb3Zlcih4LCB5LCBudWxsKTtcbiAgICAgICAgICAgIHZhciBsYXN0SG92ZXJlZCA9IHRoaXMuX2hvdmVyZWQ7XG4gICAgICAgICAgICB2YXIgcHJveHkgPSB0aGlzLnByb3h5O1xuXG4gICAgICAgICAgICB0aGlzLl9ob3ZlcmVkID0gaG92ZXJlZDtcblxuICAgICAgICAgICAgcHJveHkuc2V0Q3Vyc29yICYmIHByb3h5LnNldEN1cnNvcihob3ZlcmVkID8gaG92ZXJlZC5jdXJzb3IgOiAnZGVmYXVsdCcpO1xuXG4gICAgICAgICAgICAvLyBNb3VzZSBvdXQgb24gcHJldmlvdXMgaG92ZXJlZCBlbGVtZW50XG4gICAgICAgICAgICBpZiAobGFzdEhvdmVyZWQgJiYgaG92ZXJlZCAhPT0gbGFzdEhvdmVyZWQgJiYgbGFzdEhvdmVyZWQuX196cikge1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hUb0VsZW1lbnQobGFzdEhvdmVyZWQsICdtb3VzZW91dCcsIGV2ZW50KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gTW91c2UgbW92aW5nIG9uIG9uZSBlbGVtZW50XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoVG9FbGVtZW50KGhvdmVyZWQsICdtb3VzZW1vdmUnLCBldmVudCk7XG5cbiAgICAgICAgICAgIC8vIE1vdXNlIG92ZXIgb24gYSBuZXcgZWxlbWVudFxuICAgICAgICAgICAgaWYgKGhvdmVyZWQgJiYgaG92ZXJlZCAhPT0gbGFzdEhvdmVyZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoVG9FbGVtZW50KGhvdmVyZWQsICdtb3VzZW92ZXInLCBldmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgbW91c2VvdXQ6IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaFRvRWxlbWVudCh0aGlzLl9ob3ZlcmVkLCAnbW91c2VvdXQnLCBldmVudCk7XG5cbiAgICAgICAgICAgIHRoaXMudHJpZ2dlcignZ2xvYmFsb3V0Jywge1xuICAgICAgICAgICAgICAgIGV2ZW50OiBldmVudFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlc2l6ZVxuICAgICAgICAgKi9cbiAgICAgICAgcmVzaXplOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuX2hvdmVyZWQgPSBudWxsO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEaXNwYXRjaCBldmVudFxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lXG4gICAgICAgICAqIEBwYXJhbSB7ZXZlbnQ9fSBldmVudEFyZ3NcbiAgICAgICAgICovXG4gICAgICAgIGRpc3BhdGNoOiBmdW5jdGlvbiAoZXZlbnROYW1lLCBldmVudEFyZ3MpIHtcbiAgICAgICAgICAgIHZhciBoYW5kbGVyID0gdGhpc1tldmVudE5hbWVdO1xuICAgICAgICAgICAgaGFuZGxlciAmJiBoYW5kbGVyLmNhbGwodGhpcywgZXZlbnRBcmdzKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGlzcG9zZVxuICAgICAgICAgKi9cbiAgICAgICAgZGlzcG9zZTogZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICB0aGlzLnByb3h5LmRpc3Bvc2UoKTtcblxuICAgICAgICAgICAgdGhpcy5zdG9yYWdlID1cbiAgICAgICAgICAgIHRoaXMucHJveHkgPVxuICAgICAgICAgICAgdGhpcy5wYWludGVyID0gbnVsbDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog6K6+572u6buY6K6k55qEY3Vyc29yIHN0eWxlXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY3Vyc29yU3R5bGU9J2RlZmF1bHQnXSDkvovlpoIgY3Jvc3NoYWlyXG4gICAgICAgICAqL1xuICAgICAgICBzZXRDdXJzb3JTdHlsZTogZnVuY3Rpb24gKGN1cnNvclN0eWxlKSB7XG4gICAgICAgICAgICB2YXIgcHJveHkgPSB0aGlzLnByb3h5O1xuICAgICAgICAgICAgcHJveHkuc2V0Q3Vyc29yICYmIHByb3h5LnNldEN1cnNvcihjdXJzb3JTdHlsZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOS6i+S7tuWIhuWPkeS7o+eQhlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0RWwg55uu5qCH5Zu+5b2i5YWD57SgXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUg5LqL5Lu25ZCN56ewXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCDkuovku7blr7nosaFcbiAgICAgICAgICovXG4gICAgICAgIGRpc3BhdGNoVG9FbGVtZW50OiBmdW5jdGlvbiAodGFyZ2V0RWwsIGV2ZW50TmFtZSwgZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBldmVudEhhbmRsZXIgPSAnb24nICsgZXZlbnROYW1lO1xuICAgICAgICAgICAgdmFyIGV2ZW50UGFja2V0ID0gbWFrZUV2ZW50UGFja2V0KGV2ZW50TmFtZSwgdGFyZ2V0RWwsIGV2ZW50KTtcblxuICAgICAgICAgICAgdmFyIGVsID0gdGFyZ2V0RWw7XG5cbiAgICAgICAgICAgIHdoaWxlIChlbCkge1xuICAgICAgICAgICAgICAgIGVsW2V2ZW50SGFuZGxlcl1cbiAgICAgICAgICAgICAgICAgICAgJiYgKGV2ZW50UGFja2V0LmNhbmNlbEJ1YmJsZSA9IGVsW2V2ZW50SGFuZGxlcl0uY2FsbChlbCwgZXZlbnRQYWNrZXQpKTtcblxuICAgICAgICAgICAgICAgIGVsLnRyaWdnZXIoZXZlbnROYW1lLCBldmVudFBhY2tldCk7XG5cbiAgICAgICAgICAgICAgICBlbCA9IGVsLnBhcmVudDtcblxuICAgICAgICAgICAgICAgIGlmIChldmVudFBhY2tldC5jYW5jZWxCdWJibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWV2ZW50UGFja2V0LmNhbmNlbEJ1YmJsZSkge1xuICAgICAgICAgICAgICAgIC8vIOWGkuazoeWIsOmhtue6pyB6cmVuZGVyIOWvueixoVxuICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlcihldmVudE5hbWUsIGV2ZW50UGFja2V0KTtcbiAgICAgICAgICAgICAgICAvLyDliIblj5Hkuovku7bliLDnlKjmiLfoh6rlrprkuYnlsYJcbiAgICAgICAgICAgICAgICAvLyDnlKjmiLfmnInlj6/og73lnKjlhajlsYAgY2xpY2sg5LqL5Lu25LitIGRpc3Bvc2XvvIzmiYDku6XpnIDopoHliKTmlq3kuIsgcGFpbnRlciDmmK/lkKblrZjlnKhcbiAgICAgICAgICAgICAgICB0aGlzLnBhaW50ZXIgJiYgdGhpcy5wYWludGVyLmVhY2hPdGhlckxheWVyKGZ1bmN0aW9uIChsYXllcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mKGxheWVyW2V2ZW50SGFuZGxlcl0pID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxheWVyW2V2ZW50SGFuZGxlcl0uY2FsbChsYXllciwgZXZlbnRQYWNrZXQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChsYXllci50cmlnZ2VyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYXllci50cmlnZ2VyKGV2ZW50TmFtZSwgZXZlbnRQYWNrZXQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gICAgICAgICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvZ3JhcGhpYy9EaXNwbGF5YWJsZX0gZXhjbHVkZVxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqL1xuICAgICAgICBmaW5kSG92ZXI6IGZ1bmN0aW9uKHgsIHksIGV4Y2x1ZGUpIHtcbiAgICAgICAgICAgIHZhciBsaXN0ID0gdGhpcy5zdG9yYWdlLmdldERpc3BsYXlMaXN0KCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gbGlzdC5sZW5ndGggLSAxOyBpID49IDAgOyBpLS0pIHtcbiAgICAgICAgICAgICAgICBpZiAoIWxpc3RbaV0uc2lsZW50XG4gICAgICAgICAgICAgICAgICYmIGxpc3RbaV0gIT09IGV4Y2x1ZGVcbiAgICAgICAgICAgICAgICAgLy8gZ2V0RGlzcGxheUxpc3QgbWF5IGluY2x1ZGUgaWdub3JlZCBpdGVtIGluIFZNTCBtb2RlXG4gICAgICAgICAgICAgICAgICYmICFsaXN0W2ldLmlnbm9yZVxuICAgICAgICAgICAgICAgICAmJiBpc0hvdmVyKGxpc3RbaV0sIHgsIHkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBsaXN0W2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBDb21tb24gaGFuZGxlcnNcbiAgICB1dGlsLmVhY2goWydjbGljaycsICdtb3VzZWRvd24nLCAnbW91c2V1cCcsICdtb3VzZXdoZWVsJywgJ2RibGNsaWNrJ10sIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIEhhbmRsZXIucHJvdG90eXBlW25hbWVdID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAvLyBGaW5kIGhvdmVyIGFnYWluIHRvIGF2b2lkIGNsaWNrIGV2ZW50IGlzIGRpc3BhdGNoZWQgbWFudWFsbHkuIE9yIGNsaWNrIGlzIHRyaWdnZXJlZCB3aXRob3V0IG1vdXNlb3ZlclxuICAgICAgICAgICAgdmFyIGhvdmVyZWQgPSB0aGlzLmZpbmRIb3ZlcihldmVudC56clgsIGV2ZW50LnpyWSwgbnVsbCk7XG5cbiAgICAgICAgICAgIGlmIChuYW1lID09PSAnbW91c2Vkb3duJykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2Rvd25lbCA9IGhvdmVyZWQ7XG4gICAgICAgICAgICAgICAgLy8gSW4gY2FzZSBjbGljayB0cmlnZ2VyZWQgYmVmb3JlIG1vdXNldXBcbiAgICAgICAgICAgICAgICB0aGlzLl91cGVsID0gaG92ZXJlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG5hbWUgPT09ICdtb3N1ZXVwJykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3VwZWwgPSBob3ZlcmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobmFtZSA9PT0gJ2NsaWNrJykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9kb3duZWwgIT09IHRoaXMuX3VwZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaFRvRWxlbWVudChob3ZlcmVkLCBuYW1lLCBldmVudCk7XG4gICAgICAgIH07XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBpc0hvdmVyKGRpc3BsYXlhYmxlLCB4LCB5KSB7XG4gICAgICAgIGlmIChkaXNwbGF5YWJsZVtkaXNwbGF5YWJsZS5yZWN0SG92ZXIgPyAncmVjdENvbnRhaW4nIDogJ2NvbnRhaW4nXSh4LCB5KSkge1xuICAgICAgICAgICAgdmFyIGVsID0gZGlzcGxheWFibGU7XG4gICAgICAgICAgICB3aGlsZSAoZWwpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBhbmNlc3RvciBpcyBzaWxlbnQgb3IgY2xpcHBlZCBieSBhbmNlc3RvclxuICAgICAgICAgICAgICAgIGlmIChlbC5zaWxlbnQgfHwgKGVsLmNsaXBQYXRoICYmICFlbC5jbGlwUGF0aC5jb250YWluKHgsIHkpKSkgIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbCA9IGVsLnBhcmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHV0aWwubWl4aW4oSGFuZGxlciwgRXZlbnRmdWwpO1xuICAgIHV0aWwubWl4aW4oSGFuZGxlciwgRHJhZ2dhYmxlKTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gSGFuZGxlcjtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3pyZW5kZXIvbGliL0hhbmRsZXIuanNcbiAqKiBtb2R1bGUgaWQgPSA2MVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuLyoqXG4gKiBTdG9yYWdl5YaF5a655LuT5bqT5qih5Z2XXG4gKiBAbW9kdWxlIHpyZW5kZXIvU3RvcmFnZVxuICogQGF1dGhvciBLZW5lciAoQEtlbmVyLeael+WzsCwga2VuZXIubGluZmVuZ0BnbWFpbC5jb20pXG4gKiBAYXV0aG9yIGVycm9ycmlrIChlcnJvcnJpa0BnbWFpbC5jb20pXG4gKiBAYXV0aG9yIHBpc3NhbmcgKGh0dHBzOi8vZ2l0aHViLmNvbS9waXNzYW5nLylcbiAqL1xuXG5cbiAgICB2YXIgdXRpbCA9IHJlcXVpcmUoJy4vY29yZS91dGlsJyk7XG4gICAgdmFyIGVudiA9IHJlcXVpcmUoJy4vY29yZS9lbnYnKTtcblxuICAgIHZhciBHcm91cCA9IHJlcXVpcmUoJy4vY29udGFpbmVyL0dyb3VwJyk7XG5cbiAgICAvLyBVc2UgdGltc29ydCBiZWNhdXNlIGluIG1vc3QgY2FzZSBlbGVtZW50cyBhcmUgcGFydGlhbGx5IHNvcnRlZFxuICAgIC8vIGh0dHBzOi8vanNmaWRkbGUubmV0L3Bpc3NhbmcvanI0eDdtZG0vOC9cbiAgICB2YXIgdGltc29ydCA9IHJlcXVpcmUoJy4vY29yZS90aW1zb3J0Jyk7XG5cbiAgICBmdW5jdGlvbiBzaGFwZUNvbXBhcmVGdW5jKGEsIGIpIHtcbiAgICAgICAgaWYgKGEuemxldmVsID09PSBiLnpsZXZlbCkge1xuICAgICAgICAgICAgaWYgKGEueiA9PT0gYi56KSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgKGEuejIgPT09IGIuejIpIHtcbiAgICAgICAgICAgICAgICAvLyAgICAgLy8gRklYTUUgU2xvdyBoYXMgcmVuZGVyaWR4IGNvbXBhcmVcbiAgICAgICAgICAgICAgICAvLyAgICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8yMDg4MzQyMS9zb3J0aW5nLWluLWphdmFzY3JpcHQtc2hvdWxkLWV2ZXJ5LWNvbXBhcmUtZnVuY3Rpb24taGF2ZS1hLXJldHVybi0wLXN0YXRlbWVudFxuICAgICAgICAgICAgICAgIC8vICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vdjgvdjgvYmxvYi80N2NjZTU0NGEzMWVkNTU3N2ZmZTI5NjNmNjdhY2I0MTQ0ZWUwMjMyL3NyYy9qcy9hcnJheS5qcyNMMTAxMlxuICAgICAgICAgICAgICAgIC8vICAgICByZXR1cm4gYS5fX3JlbmRlcmlkeCAtIGIuX19yZW5kZXJpZHg7XG4gICAgICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgICAgIHJldHVybiBhLnoyIC0gYi56MjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhLnogLSBiLno7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGEuemxldmVsIC0gYi56bGV2ZWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIOWGheWuueS7k+W6kyAoTSlcbiAgICAgKiBAYWxpYXMgbW9kdWxlOnpyZW5kZXIvU3RvcmFnZVxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIHZhciBTdG9yYWdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyDmiYDmnInluLjop4TlvaLnirbvvIxpZOe0ouW8leeahG1hcFxuICAgICAgICB0aGlzLl9lbGVtZW50cyA9IHt9O1xuXG4gICAgICAgIHRoaXMuX3Jvb3RzID0gW107XG5cbiAgICAgICAgdGhpcy5fZGlzcGxheUxpc3QgPSBbXTtcblxuICAgICAgICB0aGlzLl9kaXNwbGF5TGlzdExlbiA9IDA7XG4gICAgfTtcblxuICAgIFN0b3JhZ2UucHJvdG90eXBlID0ge1xuXG4gICAgICAgIGNvbnN0cnVjdG9yOiBTdG9yYWdlLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gY2JcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIHRyYXZlcnNlOiBmdW5jdGlvbiAoY2IsIGNvbnRleHQpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fcm9vdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yb290c1tpXS50cmF2ZXJzZShjYiwgY29udGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOi/lOWbnuaJgOacieWbvuW9oueahOe7mOWItumYn+WIl1xuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFt1cGRhdGU9ZmFsc2VdIOaYr+WQpuWcqOi/lOWbnuWJjeabtOaWsOivpeaVsOe7hFxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpbmNsdWRlSWdub3JlPWZhbHNlXSDmmK/lkKbljIXlkKsgaWdub3JlIOeahOaVsOe7hCwg5ZyoIHVwZGF0ZSDkuLogdHJ1ZSDnmoTml7blgJnmnInmlYhcbiAgICAgICAgICpcbiAgICAgICAgICog6K+m6KeBe0BsaW5rIG1vZHVsZTp6cmVuZGVyL2dyYXBoaWMvRGlzcGxheWFibGUucHJvdG90eXBlLnVwZGF0ZURpc3BsYXlMaXN0fVxuICAgICAgICAgKiBAcmV0dXJuIHtBcnJheS48bW9kdWxlOnpyZW5kZXIvZ3JhcGhpYy9EaXNwbGF5YWJsZT59XG4gICAgICAgICAqL1xuICAgICAgICBnZXREaXNwbGF5TGlzdDogZnVuY3Rpb24gKHVwZGF0ZSwgaW5jbHVkZUlnbm9yZSkge1xuICAgICAgICAgICAgaW5jbHVkZUlnbm9yZSA9IGluY2x1ZGVJZ25vcmUgfHwgZmFsc2U7XG4gICAgICAgICAgICBpZiAodXBkYXRlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVEaXNwbGF5TGlzdChpbmNsdWRlSWdub3JlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kaXNwbGF5TGlzdDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5pu05paw5Zu+5b2i55qE57uY5Yi26Zif5YiX44CCXG4gICAgICAgICAqIOavj+asoee7mOWItuWJjemDveS8muiwg+eUqO+8jOivpeaWueazleS8muWFiOa3seW6puS8mOWFiOmBjeWOhuaVtOS4quagke+8jOabtOaWsOaJgOaciUdyb3Vw5ZKMU2hhcGXnmoTlj5jmjaLlubbkuJTmiormiYDmnInlj6/op4HnmoRTaGFwZeS/neWtmOWIsOaVsOe7hOS4re+8jFxuICAgICAgICAgKiDmnIDlkI7moLnmja7nu5jliLbnmoTkvJjlhYjnuqfvvIh6bGV2ZWwgPiB6ID4g5o+S5YWl6aG65bqP77yJ5o6S5bqP5b6X5Yiw57uY5Yi26Zif5YiXXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2luY2x1ZGVJZ25vcmU9ZmFsc2VdIOaYr+WQpuWMheWQqyBpZ25vcmUg55qE5pWw57uEXG4gICAgICAgICAqL1xuICAgICAgICB1cGRhdGVEaXNwbGF5TGlzdDogZnVuY3Rpb24gKGluY2x1ZGVJZ25vcmUpIHtcbiAgICAgICAgICAgIHRoaXMuX2Rpc3BsYXlMaXN0TGVuID0gMDtcbiAgICAgICAgICAgIHZhciByb290cyA9IHRoaXMuX3Jvb3RzO1xuICAgICAgICAgICAgdmFyIGRpc3BsYXlMaXN0ID0gdGhpcy5fZGlzcGxheUxpc3Q7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gcm9vdHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVBbmRBZGREaXNwbGF5YWJsZShyb290c1tpXSwgbnVsbCwgaW5jbHVkZUlnbm9yZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkaXNwbGF5TGlzdC5sZW5ndGggPSB0aGlzLl9kaXNwbGF5TGlzdExlbjtcblxuICAgICAgICAgICAgLy8gZm9yICh2YXIgaSA9IDAsIGxlbiA9IGRpc3BsYXlMaXN0Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAvLyAgICAgZGlzcGxheUxpc3RbaV0uX19yZW5kZXJpZHggPSBpO1xuICAgICAgICAgICAgLy8gfVxuXG4gICAgICAgICAgICAvLyBkaXNwbGF5TGlzdC5zb3J0KHNoYXBlQ29tcGFyZUZ1bmMpO1xuICAgICAgICAgICAgZW52LmNhbnZhc1N1cHBvcnRlZCAmJiB0aW1zb3J0KGRpc3BsYXlMaXN0LCBzaGFwZUNvbXBhcmVGdW5jKTtcbiAgICAgICAgfSxcblxuICAgICAgICBfdXBkYXRlQW5kQWRkRGlzcGxheWFibGU6IGZ1bmN0aW9uIChlbCwgY2xpcFBhdGhzLCBpbmNsdWRlSWdub3JlKSB7XG5cbiAgICAgICAgICAgIGlmIChlbC5pZ25vcmUgJiYgIWluY2x1ZGVJZ25vcmUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGVsLmJlZm9yZVVwZGF0ZSgpO1xuXG4gICAgICAgICAgICBpZiAoZWwuX19kaXJ0eSkge1xuXG4gICAgICAgICAgICAgICAgZWwudXBkYXRlKCk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZWwuYWZ0ZXJVcGRhdGUoKTtcblxuICAgICAgICAgICAgdmFyIGNsaXBQYXRoID0gZWwuY2xpcFBhdGg7XG4gICAgICAgICAgICBpZiAoY2xpcFBhdGgpIHtcbiAgICAgICAgICAgICAgICAvLyBjbGlwUGF0aCDnmoTlj5jmjaLmmK/ln7rkuo4gZ3JvdXAg55qE5Y+Y5o2iXG4gICAgICAgICAgICAgICAgY2xpcFBhdGgucGFyZW50ID0gZWw7XG4gICAgICAgICAgICAgICAgY2xpcFBhdGgudXBkYXRlVHJhbnNmb3JtKCk7XG5cbiAgICAgICAgICAgICAgICAvLyBGSVhNRSDmlYjnjoflvbHlk41cbiAgICAgICAgICAgICAgICBpZiAoY2xpcFBhdGhzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsaXBQYXRocyA9IGNsaXBQYXRocy5zbGljZSgpO1xuICAgICAgICAgICAgICAgICAgICBjbGlwUGF0aHMucHVzaChjbGlwUGF0aCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjbGlwUGF0aHMgPSBbY2xpcFBhdGhdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGVsLmlzR3JvdXApIHtcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGRyZW4gPSBlbC5fY2hpbGRyZW47XG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIEZvcmNlIHRvIG1hcmsgYXMgZGlydHkgaWYgZ3JvdXAgaXMgZGlydHlcbiAgICAgICAgICAgICAgICAgICAgLy8gRklYTUUgX19kaXJ0eVBhdGggP1xuICAgICAgICAgICAgICAgICAgICBpZiAoZWwuX19kaXJ0eSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGQuX19kaXJ0eSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVBbmRBZGREaXNwbGF5YWJsZShjaGlsZCwgY2xpcFBhdGhzLCBpbmNsdWRlSWdub3JlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBNYXJrIGdyb3VwIGNsZWFuIGhlcmVcbiAgICAgICAgICAgICAgICBlbC5fX2RpcnR5ID0gZmFsc2U7XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGVsLl9fY2xpcFBhdGhzID0gY2xpcFBhdGhzO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5fZGlzcGxheUxpc3RbdGhpcy5fZGlzcGxheUxpc3RMZW4rK10gPSBlbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5re75Yqg5Zu+5b2iKFNoYXBlKeaIluiAhee7hChHcm91cCnliLDmoLnoioLngrlcbiAgICAgICAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9FbGVtZW50fSBlbFxuICAgICAgICAgKi9cbiAgICAgICAgYWRkUm9vdDogZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICAvLyBFbGVtZW50IGhhcyBiZWVuIGFkZGVkXG4gICAgICAgICAgICBpZiAodGhpcy5fZWxlbWVudHNbZWwuaWRdKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZWwgaW5zdGFuY2VvZiBHcm91cCkge1xuICAgICAgICAgICAgICAgIGVsLmFkZENoaWxkcmVuVG9TdG9yYWdlKHRoaXMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmFkZFRvTWFwKGVsKTtcbiAgICAgICAgICAgIHRoaXMuX3Jvb3RzLnB1c2goZWwpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDliKDpmaTmjIflrprnmoTlm77lvaIoU2hhcGUp5oiW6ICF57uEKEdyb3VwKVxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ3xBcnJheS48c3RyaW5nPn0gW2VsSWRdIOWmguaenOS4uuepuua4heepuuaVtOS4qlN0b3JhZ2VcbiAgICAgICAgICovXG4gICAgICAgIGRlbFJvb3Q6IGZ1bmN0aW9uIChlbElkKSB7XG4gICAgICAgICAgICBpZiAoZWxJZCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgLy8g5LiN5oyH5a6aZWxJZOa4heepulxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fcm9vdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJvb3QgPSB0aGlzLl9yb290c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJvb3QgaW5zdGFuY2VvZiBHcm91cCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcm9vdC5kZWxDaGlsZHJlbkZyb21TdG9yYWdlKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5fZWxlbWVudHMgPSB7fTtcbiAgICAgICAgICAgICAgICB0aGlzLl9yb290cyA9IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuX2Rpc3BsYXlMaXN0ID0gW107XG4gICAgICAgICAgICAgICAgdGhpcy5fZGlzcGxheUxpc3RMZW4gPSAwO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZWxJZCBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBlbElkLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlbFJvb3QoZWxJZFtpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGVsO1xuICAgICAgICAgICAgaWYgKHR5cGVvZihlbElkKSA9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGVsID0gdGhpcy5fZWxlbWVudHNbZWxJZF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBlbCA9IGVsSWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBpZHggPSB1dGlsLmluZGV4T2YodGhpcy5fcm9vdHMsIGVsKTtcbiAgICAgICAgICAgIGlmIChpZHggPj0gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGVsRnJvbU1hcChlbC5pZCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcm9vdHMuc3BsaWNlKGlkeCwgMSk7XG4gICAgICAgICAgICAgICAgaWYgKGVsIGluc3RhbmNlb2YgR3JvdXApIHtcbiAgICAgICAgICAgICAgICAgICAgZWwuZGVsQ2hpbGRyZW5Gcm9tU3RvcmFnZSh0aGlzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgYWRkVG9NYXA6IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgaWYgKGVsIGluc3RhbmNlb2YgR3JvdXApIHtcbiAgICAgICAgICAgICAgICBlbC5fX3N0b3JhZ2UgPSB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWwuZGlydHkoZmFsc2UpO1xuXG4gICAgICAgICAgICB0aGlzLl9lbGVtZW50c1tlbC5pZF0gPSBlbDtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoZWxJZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2VsZW1lbnRzW2VsSWRdO1xuICAgICAgICB9LFxuXG4gICAgICAgIGRlbEZyb21NYXA6IGZ1bmN0aW9uIChlbElkKSB7XG4gICAgICAgICAgICB2YXIgZWxlbWVudHMgPSB0aGlzLl9lbGVtZW50cztcbiAgICAgICAgICAgIHZhciBlbCA9IGVsZW1lbnRzW2VsSWRdO1xuICAgICAgICAgICAgaWYgKGVsKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGVsZW1lbnRzW2VsSWRdO1xuICAgICAgICAgICAgICAgIGlmIChlbCBpbnN0YW5jZW9mIEdyb3VwKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsLl9fc3RvcmFnZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5riF56m65bm25LiU6YeK5pS+U3RvcmFnZVxuICAgICAgICAgKi9cbiAgICAgICAgZGlzcG9zZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5fZWxlbWVudHMgPVxuICAgICAgICAgICAgdGhpcy5fcmVuZGVyTGlzdCA9XG4gICAgICAgICAgICB0aGlzLl9yb290cyA9IG51bGw7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZGlzcGxheWFibGVTb3J0RnVuYzogc2hhcGVDb21wYXJlRnVuY1xuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IFN0b3JhZ2U7XG5cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3pyZW5kZXIvbGliL1N0b3JhZ2UuanNcbiAqKiBtb2R1bGUgaWQgPSA2MlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL216aWNjYXJkL25vZGUtdGltc29ydFxuXG4gICAgdmFyIERFRkFVTFRfTUlOX01FUkdFID0gMzI7XG5cbiAgICB2YXIgREVGQVVMVF9NSU5fR0FMTE9QSU5HID0gNztcblxuICAgIHZhciBERUZBVUxUX1RNUF9TVE9SQUdFX0xFTkdUSCA9IDI1NjtcblxuICAgIGZ1bmN0aW9uIG1pblJ1bkxlbmd0aChuKSB7XG4gICAgICAgIHZhciByID0gMDtcblxuICAgICAgICB3aGlsZSAobiA+PSBERUZBVUxUX01JTl9NRVJHRSkge1xuICAgICAgICAgICAgciB8PSBuICYgMTtcbiAgICAgICAgICAgIG4gPj49IDE7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbiArIHI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWFrZUFzY2VuZGluZ1J1bihhcnJheSwgbG8sIGhpLCBjb21wYXJlKSB7XG4gICAgICAgIHZhciBydW5IaSA9IGxvICsgMTtcblxuICAgICAgICBpZiAocnVuSGkgPT09IGhpKSB7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb21wYXJlKGFycmF5W3J1bkhpKytdLCBhcnJheVtsb10pIDwgMCkge1xuICAgICAgICAgICAgd2hpbGUgKHJ1bkhpIDwgaGkgJiYgY29tcGFyZShhcnJheVtydW5IaV0sIGFycmF5W3J1bkhpIC0gMV0pIDwgMCkge1xuICAgICAgICAgICAgICAgIHJ1bkhpKys7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldmVyc2VSdW4oYXJyYXksIGxvLCBydW5IaSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB3aGlsZSAocnVuSGkgPCBoaSAmJiBjb21wYXJlKGFycmF5W3J1bkhpXSwgYXJyYXlbcnVuSGkgLSAxXSkgPj0gMCkge1xuICAgICAgICAgICAgICAgIHJ1bkhpKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcnVuSGkgLSBsbztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZXZlcnNlUnVuKGFycmF5LCBsbywgaGkpIHtcbiAgICAgICAgaGktLTtcblxuICAgICAgICB3aGlsZSAobG8gPCBoaSkge1xuICAgICAgICAgICAgdmFyIHQgPSBhcnJheVtsb107XG4gICAgICAgICAgICBhcnJheVtsbysrXSA9IGFycmF5W2hpXTtcbiAgICAgICAgICAgIGFycmF5W2hpLS1dID0gdDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGJpbmFyeUluc2VydGlvblNvcnQoYXJyYXksIGxvLCBoaSwgc3RhcnQsIGNvbXBhcmUpIHtcbiAgICAgICAgaWYgKHN0YXJ0ID09PSBsbykge1xuICAgICAgICAgICAgc3RhcnQrKztcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoOyBzdGFydCA8IGhpOyBzdGFydCsrKSB7XG4gICAgICAgICAgICB2YXIgcGl2b3QgPSBhcnJheVtzdGFydF07XG5cbiAgICAgICAgICAgIHZhciBsZWZ0ID0gbG87XG4gICAgICAgICAgICB2YXIgcmlnaHQgPSBzdGFydDtcbiAgICAgICAgICAgIHZhciBtaWQ7XG5cbiAgICAgICAgICAgIHdoaWxlIChsZWZ0IDwgcmlnaHQpIHtcbiAgICAgICAgICAgICAgICBtaWQgPSBsZWZ0ICsgcmlnaHQgPj4+IDE7XG5cbiAgICAgICAgICAgICAgICBpZiAoY29tcGFyZShwaXZvdCwgYXJyYXlbbWlkXSkgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gbWlkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGVmdCA9IG1pZCArIDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgbiA9IHN0YXJ0IC0gbGVmdDtcblxuICAgICAgICAgICAgc3dpdGNoIChuKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICBhcnJheVtsZWZ0ICsgM10gPSBhcnJheVtsZWZ0ICsgMl07XG5cbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIGFycmF5W2xlZnQgKyAyXSA9IGFycmF5W2xlZnQgKyAxXTtcblxuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgYXJyYXlbbGVmdCArIDFdID0gYXJyYXlbbGVmdF07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChuID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJyYXlbbGVmdCArIG5dID0gYXJyYXlbbGVmdCArIG4gLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG4tLTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBhcnJheVtsZWZ0XSA9IHBpdm90O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2FsbG9wTGVmdCh2YWx1ZSwgYXJyYXksIHN0YXJ0LCBsZW5ndGgsIGhpbnQsIGNvbXBhcmUpIHtcbiAgICAgICAgdmFyIGxhc3RPZmZzZXQgPSAwO1xuICAgICAgICB2YXIgbWF4T2Zmc2V0ID0gMDtcbiAgICAgICAgdmFyIG9mZnNldCA9IDE7XG5cbiAgICAgICAgaWYgKGNvbXBhcmUodmFsdWUsIGFycmF5W3N0YXJ0ICsgaGludF0pID4gMCkge1xuICAgICAgICAgICAgbWF4T2Zmc2V0ID0gbGVuZ3RoIC0gaGludDtcblxuICAgICAgICAgICAgd2hpbGUgKG9mZnNldCA8IG1heE9mZnNldCAmJiBjb21wYXJlKHZhbHVlLCBhcnJheVtzdGFydCArIGhpbnQgKyBvZmZzZXRdKSA+IDApIHtcbiAgICAgICAgICAgICAgICBsYXN0T2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICAgICAgICAgIG9mZnNldCA9IChvZmZzZXQgPDwgMSkgKyAxO1xuXG4gICAgICAgICAgICAgICAgaWYgKG9mZnNldCA8PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG9mZnNldCA9IG1heE9mZnNldDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChvZmZzZXQgPiBtYXhPZmZzZXQpIHtcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSBtYXhPZmZzZXQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxhc3RPZmZzZXQgKz0gaGludDtcbiAgICAgICAgICAgIG9mZnNldCArPSBoaW50O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWF4T2Zmc2V0ID0gaGludCArIDE7XG4gICAgICAgICAgICB3aGlsZSAob2Zmc2V0IDwgbWF4T2Zmc2V0ICYmIGNvbXBhcmUodmFsdWUsIGFycmF5W3N0YXJ0ICsgaGludCAtIG9mZnNldF0pIDw9IDApIHtcbiAgICAgICAgICAgICAgICBsYXN0T2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICAgICAgICAgIG9mZnNldCA9IChvZmZzZXQgPDwgMSkgKyAxO1xuXG4gICAgICAgICAgICAgICAgaWYgKG9mZnNldCA8PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG9mZnNldCA9IG1heE9mZnNldDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob2Zmc2V0ID4gbWF4T2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gbWF4T2Zmc2V0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgdG1wID0gbGFzdE9mZnNldDtcbiAgICAgICAgICAgIGxhc3RPZmZzZXQgPSBoaW50IC0gb2Zmc2V0O1xuICAgICAgICAgICAgb2Zmc2V0ID0gaGludCAtIHRtcDtcbiAgICAgICAgfVxuXG4gICAgICAgIGxhc3RPZmZzZXQrKztcbiAgICAgICAgd2hpbGUgKGxhc3RPZmZzZXQgPCBvZmZzZXQpIHtcbiAgICAgICAgICAgIHZhciBtID0gbGFzdE9mZnNldCArIChvZmZzZXQgLSBsYXN0T2Zmc2V0ID4+PiAxKTtcblxuICAgICAgICAgICAgaWYgKGNvbXBhcmUodmFsdWUsIGFycmF5W3N0YXJ0ICsgbV0pID4gMCkge1xuICAgICAgICAgICAgICAgIGxhc3RPZmZzZXQgPSBtICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG9mZnNldCA9IG07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9mZnNldDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnYWxsb3BSaWdodCh2YWx1ZSwgYXJyYXksIHN0YXJ0LCBsZW5ndGgsIGhpbnQsIGNvbXBhcmUpIHtcbiAgICAgICAgdmFyIGxhc3RPZmZzZXQgPSAwO1xuICAgICAgICB2YXIgbWF4T2Zmc2V0ID0gMDtcbiAgICAgICAgdmFyIG9mZnNldCA9IDE7XG5cbiAgICAgICAgaWYgKGNvbXBhcmUodmFsdWUsIGFycmF5W3N0YXJ0ICsgaGludF0pIDwgMCkge1xuICAgICAgICAgICAgbWF4T2Zmc2V0ID0gaGludCArIDE7XG5cbiAgICAgICAgICAgIHdoaWxlIChvZmZzZXQgPCBtYXhPZmZzZXQgJiYgY29tcGFyZSh2YWx1ZSwgYXJyYXlbc3RhcnQgKyBoaW50IC0gb2Zmc2V0XSkgPCAwKSB7XG4gICAgICAgICAgICAgICAgbGFzdE9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSAob2Zmc2V0IDw8IDEpICsgMTtcblxuICAgICAgICAgICAgICAgIGlmIChvZmZzZXQgPD0gMCkge1xuICAgICAgICAgICAgICAgICAgICBvZmZzZXQgPSBtYXhPZmZzZXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAob2Zmc2V0ID4gbWF4T2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gbWF4T2Zmc2V0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgdG1wID0gbGFzdE9mZnNldDtcbiAgICAgICAgICAgIGxhc3RPZmZzZXQgPSBoaW50IC0gb2Zmc2V0O1xuICAgICAgICAgICAgb2Zmc2V0ID0gaGludCAtIHRtcDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1heE9mZnNldCA9IGxlbmd0aCAtIGhpbnQ7XG5cbiAgICAgICAgICAgIHdoaWxlIChvZmZzZXQgPCBtYXhPZmZzZXQgJiYgY29tcGFyZSh2YWx1ZSwgYXJyYXlbc3RhcnQgKyBoaW50ICsgb2Zmc2V0XSkgPj0gMCkge1xuICAgICAgICAgICAgICAgIGxhc3RPZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gKG9mZnNldCA8PCAxKSArIDE7XG5cbiAgICAgICAgICAgICAgICBpZiAob2Zmc2V0IDw9IDApIHtcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ID0gbWF4T2Zmc2V0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG9mZnNldCA+IG1heE9mZnNldCkge1xuICAgICAgICAgICAgICAgIG9mZnNldCA9IG1heE9mZnNldDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGFzdE9mZnNldCArPSBoaW50O1xuICAgICAgICAgICAgb2Zmc2V0ICs9IGhpbnQ7XG4gICAgICAgIH1cblxuICAgICAgICBsYXN0T2Zmc2V0Kys7XG5cbiAgICAgICAgd2hpbGUgKGxhc3RPZmZzZXQgPCBvZmZzZXQpIHtcbiAgICAgICAgICAgIHZhciBtID0gbGFzdE9mZnNldCArIChvZmZzZXQgLSBsYXN0T2Zmc2V0ID4+PiAxKTtcblxuICAgICAgICAgICAgaWYgKGNvbXBhcmUodmFsdWUsIGFycmF5W3N0YXJ0ICsgbV0pIDwgMCkge1xuICAgICAgICAgICAgICAgIG9mZnNldCA9IG07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsYXN0T2Zmc2V0ID0gbSArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb2Zmc2V0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIFRpbVNvcnQoYXJyYXksIGNvbXBhcmUpIHtcbiAgICAgICAgdmFyIG1pbkdhbGxvcCA9IERFRkFVTFRfTUlOX0dBTExPUElORztcbiAgICAgICAgdmFyIGxlbmd0aCA9IDA7XG4gICAgICAgIHZhciB0bXBTdG9yYWdlTGVuZ3RoID0gREVGQVVMVF9UTVBfU1RPUkFHRV9MRU5HVEg7XG4gICAgICAgIHZhciBzdGFja0xlbmd0aCA9IDA7XG4gICAgICAgIHZhciBydW5TdGFydDtcbiAgICAgICAgdmFyIHJ1bkxlbmd0aDtcbiAgICAgICAgdmFyIHN0YWNrU2l6ZSA9IDA7XG5cbiAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gICAgICAgIGlmIChsZW5ndGggPCAyICogREVGQVVMVF9UTVBfU1RPUkFHRV9MRU5HVEgpIHtcbiAgICAgICAgICAgIHRtcFN0b3JhZ2VMZW5ndGggPSBsZW5ndGggPj4+IDE7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdG1wID0gW107XG5cbiAgICAgICAgc3RhY2tMZW5ndGggPSBsZW5ndGggPCAxMjAgPyA1IDogbGVuZ3RoIDwgMTU0MiA/IDEwIDogbGVuZ3RoIDwgMTE5MTUxID8gMTkgOiA0MDtcblxuICAgICAgICBydW5TdGFydCA9IFtdO1xuICAgICAgICBydW5MZW5ndGggPSBbXTtcblxuICAgICAgICBmdW5jdGlvbiBwdXNoUnVuKF9ydW5TdGFydCwgX3J1bkxlbmd0aCkge1xuICAgICAgICAgICAgcnVuU3RhcnRbc3RhY2tTaXplXSA9IF9ydW5TdGFydDtcbiAgICAgICAgICAgIHJ1bkxlbmd0aFtzdGFja1NpemVdID0gX3J1bkxlbmd0aDtcbiAgICAgICAgICAgIHN0YWNrU2l6ZSArPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gbWVyZ2VSdW5zKCkge1xuICAgICAgICAgICAgd2hpbGUgKHN0YWNrU2l6ZSA+IDEpIHtcbiAgICAgICAgICAgICAgICB2YXIgbiA9IHN0YWNrU2l6ZSAtIDI7XG5cbiAgICAgICAgICAgICAgICBpZiAobiA+PSAxICYmIHJ1bkxlbmd0aFtuIC0gMV0gPD0gcnVuTGVuZ3RoW25dICsgcnVuTGVuZ3RoW24gKyAxXSB8fCBuID49IDIgJiYgcnVuTGVuZ3RoW24gLSAyXSA8PSBydW5MZW5ndGhbbl0gKyBydW5MZW5ndGhbbiAtIDFdKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChydW5MZW5ndGhbbiAtIDFdIDwgcnVuTGVuZ3RoW24gKyAxXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbi0tO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJ1bkxlbmd0aFtuXSA+IHJ1bkxlbmd0aFtuICsgMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG1lcmdlQXQobik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBmb3JjZU1lcmdlUnVucygpIHtcbiAgICAgICAgICAgIHdoaWxlIChzdGFja1NpemUgPiAxKSB7XG4gICAgICAgICAgICAgICAgdmFyIG4gPSBzdGFja1NpemUgLSAyO1xuXG4gICAgICAgICAgICAgICAgaWYgKG4gPiAwICYmIHJ1bkxlbmd0aFtuIC0gMV0gPCBydW5MZW5ndGhbbiArIDFdKSB7XG4gICAgICAgICAgICAgICAgICAgIG4tLTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBtZXJnZUF0KG4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gbWVyZ2VBdChpKSB7XG4gICAgICAgICAgICB2YXIgc3RhcnQxID0gcnVuU3RhcnRbaV07XG4gICAgICAgICAgICB2YXIgbGVuZ3RoMSA9IHJ1bkxlbmd0aFtpXTtcbiAgICAgICAgICAgIHZhciBzdGFydDIgPSBydW5TdGFydFtpICsgMV07XG4gICAgICAgICAgICB2YXIgbGVuZ3RoMiA9IHJ1bkxlbmd0aFtpICsgMV07XG5cbiAgICAgICAgICAgIHJ1bkxlbmd0aFtpXSA9IGxlbmd0aDEgKyBsZW5ndGgyO1xuXG4gICAgICAgICAgICBpZiAoaSA9PT0gc3RhY2tTaXplIC0gMykge1xuICAgICAgICAgICAgICAgIHJ1blN0YXJ0W2kgKyAxXSA9IHJ1blN0YXJ0W2kgKyAyXTtcbiAgICAgICAgICAgICAgICBydW5MZW5ndGhbaSArIDFdID0gcnVuTGVuZ3RoW2kgKyAyXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc3RhY2tTaXplLS07XG5cbiAgICAgICAgICAgIHZhciBrID0gZ2FsbG9wUmlnaHQoYXJyYXlbc3RhcnQyXSwgYXJyYXksIHN0YXJ0MSwgbGVuZ3RoMSwgMCwgY29tcGFyZSk7XG4gICAgICAgICAgICBzdGFydDEgKz0gaztcbiAgICAgICAgICAgIGxlbmd0aDEgLT0gaztcblxuICAgICAgICAgICAgaWYgKGxlbmd0aDEgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxlbmd0aDIgPSBnYWxsb3BMZWZ0KGFycmF5W3N0YXJ0MSArIGxlbmd0aDEgLSAxXSwgYXJyYXksIHN0YXJ0MiwgbGVuZ3RoMiwgbGVuZ3RoMiAtIDEsIGNvbXBhcmUpO1xuXG4gICAgICAgICAgICBpZiAobGVuZ3RoMiA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGxlbmd0aDEgPD0gbGVuZ3RoMikge1xuICAgICAgICAgICAgICAgIG1lcmdlTG93KHN0YXJ0MSwgbGVuZ3RoMSwgc3RhcnQyLCBsZW5ndGgyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG1lcmdlSGlnaChzdGFydDEsIGxlbmd0aDEsIHN0YXJ0MiwgbGVuZ3RoMik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBtZXJnZUxvdyhzdGFydDEsIGxlbmd0aDEsIHN0YXJ0MiwgbGVuZ3RoMikge1xuICAgICAgICAgICAgdmFyIGkgPSAwO1xuXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoMTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdG1wW2ldID0gYXJyYXlbc3RhcnQxICsgaV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBjdXJzb3IxID0gMDtcbiAgICAgICAgICAgIHZhciBjdXJzb3IyID0gc3RhcnQyO1xuICAgICAgICAgICAgdmFyIGRlc3QgPSBzdGFydDE7XG5cbiAgICAgICAgICAgIGFycmF5W2Rlc3QrK10gPSBhcnJheVtjdXJzb3IyKytdO1xuXG4gICAgICAgICAgICBpZiAoLS1sZW5ndGgyID09PSAwKSB7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDE7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBhcnJheVtkZXN0ICsgaV0gPSB0bXBbY3Vyc29yMSArIGldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChsZW5ndGgxID09PSAxKSB7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDI7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBhcnJheVtkZXN0ICsgaV0gPSBhcnJheVtjdXJzb3IyICsgaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFycmF5W2Rlc3QgKyBsZW5ndGgyXSA9IHRtcFtjdXJzb3IxXTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBfbWluR2FsbG9wID0gbWluR2FsbG9wO1xuICAgICAgICAgICAgdmFyIGNvdW50MSwgY291bnQyLCBleGl0O1xuXG4gICAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgICAgIGNvdW50MSA9IDA7XG4gICAgICAgICAgICAgICAgY291bnQyID0gMDtcbiAgICAgICAgICAgICAgICBleGl0ID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb21wYXJlKGFycmF5W2N1cnNvcjJdLCB0bXBbY3Vyc29yMV0pIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJyYXlbZGVzdCsrXSA9IGFycmF5W2N1cnNvcjIrK107XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudDIrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50MSA9IDA7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgtLWxlbmd0aDIgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGl0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFycmF5W2Rlc3QrK10gPSB0bXBbY3Vyc29yMSsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50MSsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY291bnQyID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgtLWxlbmd0aDEgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGl0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gd2hpbGUgKChjb3VudDEgfCBjb3VudDIpIDwgX21pbkdhbGxvcCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoZXhpdCkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50MSA9IGdhbGxvcFJpZ2h0KGFycmF5W2N1cnNvcjJdLCB0bXAsIGN1cnNvcjEsIGxlbmd0aDEsIDAsIGNvbXBhcmUpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb3VudDEgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb3VudDE7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFycmF5W2Rlc3QgKyBpXSA9IHRtcFtjdXJzb3IxICsgaV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGRlc3QgKz0gY291bnQxO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3Vyc29yMSArPSBjb3VudDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZW5ndGgxIC09IGNvdW50MTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsZW5ndGgxIDw9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGl0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGFycmF5W2Rlc3QrK10gPSBhcnJheVtjdXJzb3IyKytdO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICgtLWxlbmd0aDIgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4aXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBjb3VudDIgPSBnYWxsb3BMZWZ0KHRtcFtjdXJzb3IxXSwgYXJyYXksIGN1cnNvcjIsIGxlbmd0aDIsIDAsIGNvbXBhcmUpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb3VudDIgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb3VudDI7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFycmF5W2Rlc3QgKyBpXSA9IGFycmF5W2N1cnNvcjIgKyBpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgZGVzdCArPSBjb3VudDI7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3IyICs9IGNvdW50MjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlbmd0aDIgLT0gY291bnQyO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobGVuZ3RoMiA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4aXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGFycmF5W2Rlc3QrK10gPSB0bXBbY3Vyc29yMSsrXTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoLS1sZW5ndGgxID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBleGl0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgX21pbkdhbGxvcC0tO1xuICAgICAgICAgICAgICAgIH0gd2hpbGUgKGNvdW50MSA+PSBERUZBVUxUX01JTl9HQUxMT1BJTkcgfHwgY291bnQyID49IERFRkFVTFRfTUlOX0dBTExPUElORyk7XG5cbiAgICAgICAgICAgICAgICBpZiAoZXhpdCkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoX21pbkdhbGxvcCA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgX21pbkdhbGxvcCA9IDA7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgX21pbkdhbGxvcCArPSAyO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtaW5HYWxsb3AgPSBfbWluR2FsbG9wO1xuXG4gICAgICAgICAgICBtaW5HYWxsb3AgPCAxICYmIChtaW5HYWxsb3AgPSAxKTtcblxuICAgICAgICAgICAgaWYgKGxlbmd0aDEgPT09IDEpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoMjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGFycmF5W2Rlc3QgKyBpXSA9IGFycmF5W2N1cnNvcjIgKyBpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYXJyYXlbZGVzdCArIGxlbmd0aDJdID0gdG1wW2N1cnNvcjFdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobGVuZ3RoMSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigpO1xuICAgICAgICAgICAgICAgIC8vIHRocm93IG5ldyBFcnJvcignbWVyZ2VMb3cgcHJlY29uZGl0aW9ucyB3ZXJlIG5vdCByZXNwZWN0ZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGgxOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgYXJyYXlbZGVzdCArIGldID0gdG1wW2N1cnNvcjEgKyBpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBtZXJnZUhpZ2ggKHN0YXJ0MSwgbGVuZ3RoMSwgc3RhcnQyLCBsZW5ndGgyKSB7XG4gICAgICAgICAgICB2YXIgaSA9IDA7XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGgyOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0bXBbaV0gPSBhcnJheVtzdGFydDIgKyBpXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGN1cnNvcjEgPSBzdGFydDEgKyBsZW5ndGgxIC0gMTtcbiAgICAgICAgICAgIHZhciBjdXJzb3IyID0gbGVuZ3RoMiAtIDE7XG4gICAgICAgICAgICB2YXIgZGVzdCA9IHN0YXJ0MiArIGxlbmd0aDIgLSAxO1xuICAgICAgICAgICAgdmFyIGN1c3RvbUN1cnNvciA9IDA7XG4gICAgICAgICAgICB2YXIgY3VzdG9tRGVzdCA9IDA7XG5cbiAgICAgICAgICAgIGFycmF5W2Rlc3QtLV0gPSBhcnJheVtjdXJzb3IxLS1dO1xuXG4gICAgICAgICAgICBpZiAoLS1sZW5ndGgxID09PSAwKSB7XG4gICAgICAgICAgICAgICAgY3VzdG9tQ3Vyc29yID0gZGVzdCAtIChsZW5ndGgyIC0gMSk7XG5cbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoMjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGFycmF5W2N1c3RvbUN1cnNvciArIGldID0gdG1wW2ldO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGxlbmd0aDIgPT09IDEpIHtcbiAgICAgICAgICAgICAgICBkZXN0IC09IGxlbmd0aDE7XG4gICAgICAgICAgICAgICAgY3Vyc29yMSAtPSBsZW5ndGgxO1xuICAgICAgICAgICAgICAgIGN1c3RvbURlc3QgPSBkZXN0ICsgMTtcbiAgICAgICAgICAgICAgICBjdXN0b21DdXJzb3IgPSBjdXJzb3IxICsgMTtcblxuICAgICAgICAgICAgICAgIGZvciAoaSA9IGxlbmd0aDEgLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgICAgICBhcnJheVtjdXN0b21EZXN0ICsgaV0gPSBhcnJheVtjdXN0b21DdXJzb3IgKyBpXTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBhcnJheVtkZXN0XSA9IHRtcFtjdXJzb3IyXTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBfbWluR2FsbG9wID0gbWluR2FsbG9wO1xuXG4gICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgICAgIHZhciBjb3VudDEgPSAwO1xuICAgICAgICAgICAgICAgIHZhciBjb3VudDIgPSAwO1xuICAgICAgICAgICAgICAgIHZhciBleGl0ID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb21wYXJlKHRtcFtjdXJzb3IyXSwgYXJyYXlbY3Vyc29yMV0pIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJyYXlbZGVzdC0tXSA9IGFycmF5W2N1cnNvcjEtLV07XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudDErKztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50MiA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoLS1sZW5ndGgxID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhpdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcnJheVtkZXN0LS1dID0gdG1wW2N1cnNvcjItLV07XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudDIrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50MSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoLS1sZW5ndGgyID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhpdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IHdoaWxlICgoY291bnQxIHwgY291bnQyKSA8IF9taW5HYWxsb3ApO1xuXG4gICAgICAgICAgICAgICAgaWYgKGV4aXQpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICBjb3VudDEgPSBsZW5ndGgxIC0gZ2FsbG9wUmlnaHQodG1wW2N1cnNvcjJdLCBhcnJheSwgc3RhcnQxLCBsZW5ndGgxLCBsZW5ndGgxIC0gMSwgY29tcGFyZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvdW50MSAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVzdCAtPSBjb3VudDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3IxIC09IGNvdW50MTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlbmd0aDEgLT0gY291bnQxO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VzdG9tRGVzdCA9IGRlc3QgKyAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VzdG9tQ3Vyc29yID0gY3Vyc29yMSArIDE7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IGNvdW50MSAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJyYXlbY3VzdG9tRGVzdCArIGldID0gYXJyYXlbY3VzdG9tQ3Vyc29yICsgaV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsZW5ndGgxID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhpdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBhcnJheVtkZXN0LS1dID0gdG1wW2N1cnNvcjItLV07XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKC0tbGVuZ3RoMiA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXhpdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGNvdW50MiA9IGxlbmd0aDIgLSBnYWxsb3BMZWZ0KGFycmF5W2N1cnNvcjFdLCB0bXAsIDAsIGxlbmd0aDIsIGxlbmd0aDIgLSAxLCBjb21wYXJlKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoY291bnQyICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZXN0IC09IGNvdW50MjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvcjIgLT0gY291bnQyO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVuZ3RoMiAtPSBjb3VudDI7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXN0b21EZXN0ID0gZGVzdCArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXN0b21DdXJzb3IgPSBjdXJzb3IyICsgMTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGNvdW50MjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJyYXlbY3VzdG9tRGVzdCArIGldID0gdG1wW2N1c3RvbUN1cnNvciArIGldO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobGVuZ3RoMiA8PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhpdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBhcnJheVtkZXN0LS1dID0gYXJyYXlbY3Vyc29yMS0tXTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoLS1sZW5ndGgxID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBleGl0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgX21pbkdhbGxvcC0tO1xuICAgICAgICAgICAgICAgIH0gd2hpbGUgKGNvdW50MSA+PSBERUZBVUxUX01JTl9HQUxMT1BJTkcgfHwgY291bnQyID49IERFRkFVTFRfTUlOX0dBTExPUElORyk7XG5cbiAgICAgICAgICAgICAgICBpZiAoZXhpdCkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoX21pbkdhbGxvcCA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgX21pbkdhbGxvcCA9IDA7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgX21pbkdhbGxvcCArPSAyO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtaW5HYWxsb3AgPSBfbWluR2FsbG9wO1xuXG4gICAgICAgICAgICBpZiAobWluR2FsbG9wIDwgMSkge1xuICAgICAgICAgICAgICAgIG1pbkdhbGxvcCA9IDE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChsZW5ndGgyID09PSAxKSB7XG4gICAgICAgICAgICAgICAgZGVzdCAtPSBsZW5ndGgxO1xuICAgICAgICAgICAgICAgIGN1cnNvcjEgLT0gbGVuZ3RoMTtcbiAgICAgICAgICAgICAgICBjdXN0b21EZXN0ID0gZGVzdCArIDE7XG4gICAgICAgICAgICAgICAgY3VzdG9tQ3Vyc29yID0gY3Vyc29yMSArIDE7XG5cbiAgICAgICAgICAgICAgICBmb3IgKGkgPSBsZW5ndGgxIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgYXJyYXlbY3VzdG9tRGVzdCArIGldID0gYXJyYXlbY3VzdG9tQ3Vyc29yICsgaV07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYXJyYXlbZGVzdF0gPSB0bXBbY3Vyc29yMl07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChsZW5ndGgyID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCk7XG4gICAgICAgICAgICAgICAgLy8gdGhyb3cgbmV3IEVycm9yKCdtZXJnZUhpZ2ggcHJlY29uZGl0aW9ucyB3ZXJlIG5vdCByZXNwZWN0ZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGN1c3RvbUN1cnNvciA9IGRlc3QgLSAobGVuZ3RoMiAtIDEpO1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGgyOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgYXJyYXlbY3VzdG9tQ3Vyc29yICsgaV0gPSB0bXBbaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5tZXJnZVJ1bnMgPSBtZXJnZVJ1bnM7XG4gICAgICAgIHRoaXMuZm9yY2VNZXJnZVJ1bnMgPSBmb3JjZU1lcmdlUnVucztcbiAgICAgICAgdGhpcy5wdXNoUnVuID0gcHVzaFJ1bjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzb3J0KGFycmF5LCBjb21wYXJlLCBsbywgaGkpIHtcbiAgICAgICAgaWYgKCFsbykge1xuICAgICAgICAgICAgbG8gPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaGkpIHtcbiAgICAgICAgICAgIGhpID0gYXJyYXkubGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlbWFpbmluZyA9IGhpIC0gbG87XG5cbiAgICAgICAgaWYgKHJlbWFpbmluZyA8IDIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBydW5MZW5ndGggPSAwO1xuXG4gICAgICAgIGlmIChyZW1haW5pbmcgPCBERUZBVUxUX01JTl9NRVJHRSkge1xuICAgICAgICAgICAgcnVuTGVuZ3RoID0gbWFrZUFzY2VuZGluZ1J1bihhcnJheSwgbG8sIGhpLCBjb21wYXJlKTtcbiAgICAgICAgICAgIGJpbmFyeUluc2VydGlvblNvcnQoYXJyYXksIGxvLCBoaSwgbG8gKyBydW5MZW5ndGgsIGNvbXBhcmUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRzID0gbmV3IFRpbVNvcnQoYXJyYXksIGNvbXBhcmUpO1xuXG4gICAgICAgIHZhciBtaW5SdW4gPSBtaW5SdW5MZW5ndGgocmVtYWluaW5nKTtcblxuICAgICAgICBkbyB7XG4gICAgICAgICAgICBydW5MZW5ndGggPSBtYWtlQXNjZW5kaW5nUnVuKGFycmF5LCBsbywgaGksIGNvbXBhcmUpO1xuICAgICAgICAgICAgaWYgKHJ1bkxlbmd0aCA8IG1pblJ1bikge1xuICAgICAgICAgICAgICAgIHZhciBmb3JjZSA9IHJlbWFpbmluZztcbiAgICAgICAgICAgICAgICBpZiAoZm9yY2UgPiBtaW5SdW4pIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yY2UgPSBtaW5SdW47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYmluYXJ5SW5zZXJ0aW9uU29ydChhcnJheSwgbG8sIGxvICsgZm9yY2UsIGxvICsgcnVuTGVuZ3RoLCBjb21wYXJlKTtcbiAgICAgICAgICAgICAgICBydW5MZW5ndGggPSBmb3JjZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdHMucHVzaFJ1bihsbywgcnVuTGVuZ3RoKTtcbiAgICAgICAgICAgIHRzLm1lcmdlUnVucygpO1xuXG4gICAgICAgICAgICByZW1haW5pbmcgLT0gcnVuTGVuZ3RoO1xuICAgICAgICAgICAgbG8gKz0gcnVuTGVuZ3RoO1xuICAgICAgICB9IHdoaWxlIChyZW1haW5pbmcgIT09IDApO1xuXG4gICAgICAgIHRzLmZvcmNlTWVyZ2VSdW5zKCk7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBzb3J0O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34venJlbmRlci9saWIvY29yZS90aW1zb3J0LmpzXG4gKiogbW9kdWxlIGlkID0gNjNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0Jztcbi8qKlxuICog5Yqo55S75Li757G7LCDosIPluqblkoznrqHnkIbmiYDmnInliqjnlLvmjqfliLblmahcbiAqXG4gKiBAbW9kdWxlIHpyZW5kZXIvYW5pbWF0aW9uL0FuaW1hdGlvblxuICogQGF1dGhvciBwaXNzYW5nKGh0dHBzOi8vZ2l0aHViLmNvbS9waXNzYW5nKVxuICovXG4vLyBUT0RPIEFkZGl0aXZlIGFuaW1hdGlvblxuLy8gaHR0cDovL2lvc290ZXJpYy5jb20vYWRkaXRpdmUtYW5pbWF0aW9ucy1hbmltYXRld2l0aGR1cmF0aW9uLWluLWlvcy04L1xuLy8gaHR0cHM6Ly9kZXZlbG9wZXIuYXBwbGUuY29tL3ZpZGVvcy93d2RjMjAxNC8jMjM2XG5cblxuICAgIHZhciB1dGlsID0gcmVxdWlyZSgnLi4vY29yZS91dGlsJyk7XG4gICAgdmFyIERpc3BhdGNoZXIgPSByZXF1aXJlKCcuLi9jb3JlL2V2ZW50JykuRGlzcGF0Y2hlcjtcblxuICAgIHZhciByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSByZXF1aXJlKCcuL3JlcXVlc3RBbmltYXRpb25GcmFtZScpO1xuXG4gICAgdmFyIEFuaW1hdG9yID0gcmVxdWlyZSgnLi9BbmltYXRvcicpO1xuICAgIC8qKlxuICAgICAqIEB0eXBlZGVmIHtPYmplY3R9IElaUmVuZGVyU3RhZ2VcbiAgICAgKiBAcHJvcGVydHkge0Z1bmN0aW9ufSB1cGRhdGVcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEBhbGlhcyBtb2R1bGU6enJlbmRlci9hbmltYXRpb24vQW5pbWF0aW9uXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLm9uZnJhbWVdXG4gICAgICogQHBhcmFtIHtJWlJlbmRlclN0YWdlfSBbb3B0aW9ucy5zdGFnZV1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqICAgICB2YXIgYW5pbWF0aW9uID0gbmV3IEFuaW1hdGlvbigpO1xuICAgICAqICAgICB2YXIgb2JqID0ge1xuICAgICAqICAgICAgICAgeDogMTAwLFxuICAgICAqICAgICAgICAgeTogMTAwXG4gICAgICogICAgIH07XG4gICAgICogICAgIGFuaW1hdGlvbi5hbmltYXRlKG5vZGUucG9zaXRpb24pXG4gICAgICogICAgICAgICAud2hlbigxMDAwLCB7XG4gICAgICogICAgICAgICAgICAgeDogNTAwLFxuICAgICAqICAgICAgICAgICAgIHk6IDUwMFxuICAgICAqICAgICAgICAgfSlcbiAgICAgKiAgICAgICAgIC53aGVuKDIwMDAsIHtcbiAgICAgKiAgICAgICAgICAgICB4OiAxMDAsXG4gICAgICogICAgICAgICAgICAgeTogMTAwXG4gICAgICogICAgICAgICB9KVxuICAgICAqICAgICAgICAgLnN0YXJ0KCdzcGxpbmUnKTtcbiAgICAgKi9cbiAgICB2YXIgQW5pbWF0aW9uID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcblxuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgICAgICB0aGlzLnN0YWdlID0gb3B0aW9ucy5zdGFnZSB8fCB7fTtcblxuICAgICAgICB0aGlzLm9uZnJhbWUgPSBvcHRpb25zLm9uZnJhbWUgfHwgZnVuY3Rpb24oKSB7fTtcblxuICAgICAgICAvLyBwcml2YXRlIHByb3BlcnRpZXNcbiAgICAgICAgdGhpcy5fY2xpcHMgPSBbXTtcblxuICAgICAgICB0aGlzLl9ydW5uaW5nID0gZmFsc2U7XG5cbiAgICAgICAgdGhpcy5fdGltZTtcblxuICAgICAgICB0aGlzLl9wYXVzZWRUaW1lO1xuXG4gICAgICAgIHRoaXMuX3BhdXNlU3RhcnQ7XG5cbiAgICAgICAgdGhpcy5fcGF1c2VkID0gZmFsc2U7XG5cbiAgICAgICAgRGlzcGF0Y2hlci5jYWxsKHRoaXMpO1xuICAgIH07XG5cbiAgICBBbmltYXRpb24ucHJvdG90eXBlID0ge1xuXG4gICAgICAgIGNvbnN0cnVjdG9yOiBBbmltYXRpb24sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmt7vliqAgY2xpcFxuICAgICAgICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL2FuaW1hdGlvbi9DbGlwfSBjbGlwXG4gICAgICAgICAqL1xuICAgICAgICBhZGRDbGlwOiBmdW5jdGlvbiAoY2xpcCkge1xuICAgICAgICAgICAgdGhpcy5fY2xpcHMucHVzaChjbGlwKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOa3u+WKoCBhbmltYXRvclxuICAgICAgICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL2FuaW1hdGlvbi9BbmltYXRvcn0gYW5pbWF0b3JcbiAgICAgICAgICovXG4gICAgICAgIGFkZEFuaW1hdG9yOiBmdW5jdGlvbiAoYW5pbWF0b3IpIHtcbiAgICAgICAgICAgIGFuaW1hdG9yLmFuaW1hdGlvbiA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgY2xpcHMgPSBhbmltYXRvci5nZXRDbGlwcygpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbGlwcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkQ2xpcChjbGlwc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDliKDpmaTliqjnlLvniYfmrrVcbiAgICAgICAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9hbmltYXRpb24vQ2xpcH0gY2xpcFxuICAgICAgICAgKi9cbiAgICAgICAgcmVtb3ZlQ2xpcDogZnVuY3Rpb24oY2xpcCkge1xuICAgICAgICAgICAgdmFyIGlkeCA9IHV0aWwuaW5kZXhPZih0aGlzLl9jbGlwcywgY2xpcCk7XG4gICAgICAgICAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jbGlwcy5zcGxpY2UoaWR4LCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5Yig6Zmk5Yqo55S754mH5q61XG4gICAgICAgICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvYW5pbWF0aW9uL0FuaW1hdG9yfSBhbmltYXRvclxuICAgICAgICAgKi9cbiAgICAgICAgcmVtb3ZlQW5pbWF0b3I6IGZ1bmN0aW9uIChhbmltYXRvcikge1xuICAgICAgICAgICAgdmFyIGNsaXBzID0gYW5pbWF0b3IuZ2V0Q2xpcHMoKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2xpcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZUNsaXAoY2xpcHNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYW5pbWF0b3IuYW5pbWF0aW9uID0gbnVsbDtcbiAgICAgICAgfSxcblxuICAgICAgICBfdXBkYXRlOiBmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgdmFyIHRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKSAtIHRoaXMuX3BhdXNlZFRpbWU7XG4gICAgICAgICAgICB2YXIgZGVsdGEgPSB0aW1lIC0gdGhpcy5fdGltZTtcbiAgICAgICAgICAgIHZhciBjbGlwcyA9IHRoaXMuX2NsaXBzO1xuICAgICAgICAgICAgdmFyIGxlbiA9IGNsaXBzLmxlbmd0aDtcblxuICAgICAgICAgICAgdmFyIGRlZmVycmVkRXZlbnRzID0gW107XG4gICAgICAgICAgICB2YXIgZGVmZXJyZWRDbGlwcyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBjbGlwID0gY2xpcHNbaV07XG4gICAgICAgICAgICAgICAgdmFyIGUgPSBjbGlwLnN0ZXAodGltZSk7XG4gICAgICAgICAgICAgICAgLy8gVGhyb3cgb3V0IHRoZSBldmVudHMgbmVlZCB0byBiZSBjYWxsZWQgYWZ0ZXJcbiAgICAgICAgICAgICAgICAvLyBzdGFnZS51cGRhdGUsIGxpa2UgZGVzdHJveVxuICAgICAgICAgICAgICAgIGlmIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlZmVycmVkRXZlbnRzLnB1c2goZSk7XG4gICAgICAgICAgICAgICAgICAgIGRlZmVycmVkQ2xpcHMucHVzaChjbGlwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgZmluaXNoZWQgY2xpcFxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47KSB7XG4gICAgICAgICAgICAgICAgaWYgKGNsaXBzW2ldLl9uZWVkc1JlbW92ZSkge1xuICAgICAgICAgICAgICAgICAgICBjbGlwc1tpXSA9IGNsaXBzW2xlbiAtIDFdO1xuICAgICAgICAgICAgICAgICAgICBjbGlwcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgbGVuLS07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZW4gPSBkZWZlcnJlZEV2ZW50cy5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZGVmZXJyZWRDbGlwc1tpXS5maXJlKGRlZmVycmVkRXZlbnRzW2ldKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5fdGltZSA9IHRpbWU7XG5cbiAgICAgICAgICAgIHRoaXMub25mcmFtZShkZWx0YSk7XG5cbiAgICAgICAgICAgIHRoaXMudHJpZ2dlcignZnJhbWUnLCBkZWx0YSk7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLnN0YWdlLnVwZGF0ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhZ2UudXBkYXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgX3N0YXJ0TG9vcDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgICAgICB0aGlzLl9ydW5uaW5nID0gdHJ1ZTtcblxuICAgICAgICAgICAgZnVuY3Rpb24gc3RlcCgpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5fcnVubmluZykge1xuXG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShzdGVwKTtcblxuICAgICAgICAgICAgICAgICAgICAhc2VsZi5fcGF1c2VkICYmIHNlbGYuX3VwZGF0ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHN0ZXApO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlvIDlp4vov5DooYzliqjnlLtcbiAgICAgICAgICovXG4gICAgICAgIHN0YXJ0OiBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgIHRoaXMuX3RpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgICAgICAgIHRoaXMuX3BhdXNlZFRpbWUgPSAwO1xuXG4gICAgICAgICAgICB0aGlzLl9zdGFydExvb3AoKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWBnOatoui/kOihjOWKqOeUu1xuICAgICAgICAgKi9cbiAgICAgICAgc3RvcDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5fcnVubmluZyA9IGZhbHNlO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQYXVzZVxuICAgICAgICAgKi9cbiAgICAgICAgcGF1c2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fcGF1c2VkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGF1c2VTdGFydCA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3BhdXNlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlc3VtZVxuICAgICAgICAgKi9cbiAgICAgICAgcmVzdW1lOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fcGF1c2VkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGF1c2VkVGltZSArPSAobmV3IERhdGUoKS5nZXRUaW1lKCkpIC0gdGhpcy5fcGF1c2VTdGFydDtcbiAgICAgICAgICAgICAgICB0aGlzLl9wYXVzZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5riF6Zmk5omA5pyJ5Yqo55S754mH5q61XG4gICAgICAgICAqL1xuICAgICAgICBjbGVhcjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5fY2xpcHMgPSBbXTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWvueS4gOS4quebruagh+WIm+W7uuS4gOS4qmFuaW1hdG9y5a+56LGh77yM5Y+v5Lul5oyH5a6a55uu5qCH5Lit55qE5bGe5oCn5L2/55So5Yqo55S7XG4gICAgICAgICAqIEBwYXJhbSAge09iamVjdH0gdGFyZ2V0XG4gICAgICAgICAqIEBwYXJhbSAge09iamVjdH0gb3B0aW9uc1xuICAgICAgICAgKiBAcGFyYW0gIHtib29sZWFufSBbb3B0aW9ucy5sb29wPWZhbHNlXSDmmK/lkKblvqrnjq/mkq3mlL7liqjnlLtcbiAgICAgICAgICogQHBhcmFtICB7RnVuY3Rpb259IFtvcHRpb25zLmdldHRlcj1udWxsXVxuICAgICAgICAgKiAgICAgICAgIOWmguaenOaMh+WummdldHRlcuWHveaVsO+8jOS8mumAmui/h2dldHRlcuWHveaVsOWPluWxnuaAp+WAvFxuICAgICAgICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gW29wdGlvbnMuc2V0dGVyPW51bGxdXG4gICAgICAgICAqICAgICAgICAg5aaC5p6c5oyH5a6ac2V0dGVy5Ye95pWw77yM5Lya6YCa6L+Hc2V0dGVy5Ye95pWw6K6+572u5bGe5oCn5YC8XG4gICAgICAgICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2FuaW1hdGlvbi9BbmltYXRpb25+QW5pbWF0b3J9XG4gICAgICAgICAqL1xuICAgICAgICAvLyBUT0RPIEdhcFxuICAgICAgICBhbmltYXRlOiBmdW5jdGlvbiAodGFyZ2V0LCBvcHRpb25zKSB7XG4gICAgICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgICAgICAgIHZhciBhbmltYXRvciA9IG5ldyBBbmltYXRvcihcbiAgICAgICAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5sb29wLFxuICAgICAgICAgICAgICAgIG9wdGlvbnMuZ2V0dGVyLFxuICAgICAgICAgICAgICAgIG9wdGlvbnMuc2V0dGVyXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICByZXR1cm4gYW5pbWF0b3I7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdXRpbC5taXhpbihBbmltYXRpb24sIERpc3BhdGNoZXIpO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBBbmltYXRpb247XG5cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3pyZW5kZXIvbGliL2FuaW1hdGlvbi9BbmltYXRpb24uanNcbiAqKiBtb2R1bGUgaWQgPSA2NFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuLyoqXG4gKiDkuovku7bovoXliqnnsbtcbiAqIEBtb2R1bGUgenJlbmRlci9jb3JlL2V2ZW50XG4gKiBAYXV0aG9yIEtlbmVyIChAS2VuZXIt5p6X5bOwLCBrZW5lci5saW5mZW5nQGdtYWlsLmNvbSlcbiAqL1xuXG5cbiAgICB2YXIgRXZlbnRmdWwgPSByZXF1aXJlKCcuLi9taXhpbi9FdmVudGZ1bCcpO1xuXG4gICAgdmFyIGlzRG9tTGV2ZWwyID0gKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSAmJiAhIXdpbmRvdy5hZGRFdmVudExpc3RlbmVyO1xuXG4gICAgZnVuY3Rpb24gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGVsKSB7XG4gICAgICAgIC8vIEJsYWNrQmVycnkgNSwgaU9TIDMgKG9yaWdpbmFsIGlQaG9uZSkgZG9uJ3QgaGF2ZSBnZXRCb3VuZGluZ1JlY3RcbiAgICAgICAgcmV0dXJuIGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCA/IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpIDoge2xlZnQ6IDAsIHRvcDogMH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xpZW50VG9Mb2NhbChlbCwgZSwgb3V0KSB7XG4gICAgICAgIC8vIGNsaWVudFgvY2xpZW50WSBpcyBhY2NvcmRpbmcgdG8gdmlldyBwb3J0LlxuICAgICAgICB2YXIgYm94ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGVsKTtcbiAgICAgICAgb3V0ID0gb3V0IHx8IHt9O1xuICAgICAgICBvdXQuenJYID0gZS5jbGllbnRYIC0gYm94LmxlZnQ7XG4gICAgICAgIG91dC56clkgPSBlLmNsaWVudFkgLSBib3gudG9wO1xuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOWmguaenOWtmOWcqOesrOS4ieaWueW1jOWFpeeahOS4gOS6m2RvbeinpuWPkeeahOS6i+S7tu+8jOaIlnRvdWNo5LqL5Lu277yM6ZyA6KaB6L2s5o2i5LiA5LiL5LqL5Lu25Z2Q5qCHXG4gICAgICovXG4gICAgZnVuY3Rpb24gbm9ybWFsaXplRXZlbnQoZWwsIGUpIHtcblxuICAgICAgICBlID0gZSB8fCB3aW5kb3cuZXZlbnQ7XG5cbiAgICAgICAgaWYgKGUuenJYICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGV2ZW50VHlwZSA9IGUudHlwZTtcbiAgICAgICAgdmFyIGlzVG91Y2ggPSBldmVudFR5cGUgJiYgZXZlbnRUeXBlLmluZGV4T2YoJ3RvdWNoJykgPj0gMDtcblxuICAgICAgICBpZiAoIWlzVG91Y2gpIHtcbiAgICAgICAgICAgIGNsaWVudFRvTG9jYWwoZWwsIGUsIGUpO1xuICAgICAgICAgICAgZS56ckRlbHRhID0gKGUud2hlZWxEZWx0YSkgPyBlLndoZWVsRGVsdGEgLyAxMjAgOiAtKGUuZGV0YWlsIHx8IDApIC8gMztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciB0b3VjaCA9IGV2ZW50VHlwZSAhPSAndG91Y2hlbmQnXG4gICAgICAgICAgICAgICAgPyBlLnRhcmdldFRvdWNoZXNbMF1cbiAgICAgICAgICAgICAgICA6IGUuY2hhbmdlZFRvdWNoZXNbMF07XG4gICAgICAgICAgICB0b3VjaCAmJiBjbGllbnRUb0xvY2FsKGVsLCB0b3VjaCwgZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGRFdmVudExpc3RlbmVyKGVsLCBuYW1lLCBoYW5kbGVyKSB7XG4gICAgICAgIGlmIChpc0RvbUxldmVsMikge1xuICAgICAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcihuYW1lLCBoYW5kbGVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVsLmF0dGFjaEV2ZW50KCdvbicgKyBuYW1lLCBoYW5kbGVyKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlbW92ZUV2ZW50TGlzdGVuZXIoZWwsIG5hbWUsIGhhbmRsZXIpIHtcbiAgICAgICAgaWYgKGlzRG9tTGV2ZWwyKSB7XG4gICAgICAgICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKG5hbWUsIGhhbmRsZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZWwuZGV0YWNoRXZlbnQoJ29uJyArIG5hbWUsIGhhbmRsZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog5YGc5q2i5YaS5rOh5ZKM6Zi75q2i6buY6K6k6KGM5Li6XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvZXZlbnRcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQHBhcmFtIHtFdmVudH0gZSA6IGV2ZW505a+56LGhXG4gICAgICovXG4gICAgdmFyIHN0b3AgPSBpc0RvbUxldmVsMlxuICAgICAgICA/IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgZS5jYW5jZWxCdWJibGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGUucmV0dXJuVmFsdWUgPSBmYWxzZTtcbiAgICAgICAgICAgIGUuY2FuY2VsQnViYmxlID0gdHJ1ZTtcbiAgICAgICAgfTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0ge1xuICAgICAgICBjbGllbnRUb0xvY2FsOiBjbGllbnRUb0xvY2FsLFxuICAgICAgICBub3JtYWxpemVFdmVudDogbm9ybWFsaXplRXZlbnQsXG4gICAgICAgIGFkZEV2ZW50TGlzdGVuZXI6IGFkZEV2ZW50TGlzdGVuZXIsXG4gICAgICAgIHJlbW92ZUV2ZW50TGlzdGVuZXI6IHJlbW92ZUV2ZW50TGlzdGVuZXIsXG5cbiAgICAgICAgc3RvcDogc3RvcCxcbiAgICAgICAgLy8g5YGa5ZCR5LiK5YW85a65XG4gICAgICAgIERpc3BhdGNoZXI6IEV2ZW50ZnVsXG4gICAgfTtcblxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34venJlbmRlci9saWIvY29yZS9ldmVudC5qc1xuICoqIG1vZHVsZSBpZCA9IDY1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcblxuICAgIG1vZHVsZS5leHBvcnRzID0gKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAod2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfHwgd2luZG93Lm1zUmVxdWVzdEFuaW1hdGlvbkZyYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8fCB3aW5kb3cubW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8fCB3aW5kb3cud2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfHwgZnVuY3Rpb24gKGZ1bmMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuYywgMTYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi96cmVuZGVyL2xpYi9hbmltYXRpb24vcmVxdWVzdEFuaW1hdGlvbkZyYW1lLmpzXG4gKiogbW9kdWxlIGlkID0gNjZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlxuXG4gICAgdmFyIGV2ZW50VG9vbCA9IHJlcXVpcmUoJy4uL2NvcmUvZXZlbnQnKTtcbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnLi4vY29yZS91dGlsJyk7XG4gICAgdmFyIEV2ZW50ZnVsID0gcmVxdWlyZSgnLi4vbWl4aW4vRXZlbnRmdWwnKTtcbiAgICB2YXIgZW52ID0gcmVxdWlyZSgnLi4vY29yZS9lbnYnKTtcbiAgICB2YXIgR2VzdHVyZU1nciA9IHJlcXVpcmUoJy4uL2NvcmUvR2VzdHVyZU1ncicpO1xuXG4gICAgdmFyIGFkZEV2ZW50TGlzdGVuZXIgPSBldmVudFRvb2wuYWRkRXZlbnRMaXN0ZW5lcjtcbiAgICB2YXIgcmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGV2ZW50VG9vbC5yZW1vdmVFdmVudExpc3RlbmVyO1xuICAgIHZhciBub3JtYWxpemVFdmVudCA9IGV2ZW50VG9vbC5ub3JtYWxpemVFdmVudDtcblxuICAgIHZhciBUT1VDSF9DTElDS19ERUxBWSA9IDMwMDtcblxuICAgIHZhciBtb3VzZUhhbmRsZXJOYW1lcyA9IFtcbiAgICAgICAgJ2NsaWNrJywgJ2RibGNsaWNrJywgJ21vdXNld2hlZWwnLCAnbW91c2VvdXQnLFxuICAgICAgICAnbW91c2V1cCcsICdtb3VzZWRvd24nLCAnbW91c2Vtb3ZlJ1xuICAgIF07XG5cbiAgICB2YXIgdG91Y2hIYW5kbGVyTmFtZXMgPSBbXG4gICAgICAgICd0b3VjaHN0YXJ0JywgJ3RvdWNoZW5kJywgJ3RvdWNobW92ZSdcbiAgICBdO1xuXG4gICAgZnVuY3Rpb24gZXZlbnROYW1lRml4KG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIChuYW1lID09PSAnbW91c2V3aGVlbCcgJiYgZW52LmJyb3dzZXIuZmlyZWZveCkgPyAnRE9NTW91c2VTY3JvbGwnIDogbmFtZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcm9jZXNzR2VzdHVyZShwcm94eSwgZXZlbnQsIHN0YWdlKSB7XG4gICAgICAgIHZhciBnZXN0dXJlTWdyID0gcHJveHkuX2dlc3R1cmVNZ3I7XG5cbiAgICAgICAgc3RhZ2UgPT09ICdzdGFydCcgJiYgZ2VzdHVyZU1nci5jbGVhcigpO1xuXG4gICAgICAgIHZhciBnZXN0dXJlSW5mbyA9IGdlc3R1cmVNZ3IucmVjb2duaXplKFxuICAgICAgICAgICAgZXZlbnQsXG4gICAgICAgICAgICBwcm94eS5oYW5kbGVyLmZpbmRIb3ZlcihldmVudC56clgsIGV2ZW50LnpyWSwgbnVsbCksXG4gICAgICAgICAgICBwcm94eS5kb21cbiAgICAgICAgKTtcblxuICAgICAgICBzdGFnZSA9PT0gJ2VuZCcgJiYgZ2VzdHVyZU1nci5jbGVhcigpO1xuXG4gICAgICAgIGlmIChnZXN0dXJlSW5mbykge1xuICAgICAgICAgICAgLy8gZXZlbnRUb29sLnN0b3AoZXZlbnQpO1xuICAgICAgICAgICAgdmFyIHR5cGUgPSBnZXN0dXJlSW5mby50eXBlO1xuICAgICAgICAgICAgZXZlbnQuZ2VzdHVyZUV2ZW50ID0gdHlwZTtcblxuICAgICAgICAgICAgcHJveHkuaGFuZGxlci5kaXNwYXRjaFRvRWxlbWVudChnZXN0dXJlSW5mby50YXJnZXQsIHR5cGUsIGdlc3R1cmVJbmZvLmV2ZW50KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFByZXZlbnQgbW91c2UgZXZlbnQgZnJvbSBiZWluZyBkaXNwYXRjaGVkIGFmdGVyIFRvdWNoIEV2ZW50cyBhY3Rpb25cbiAgICAgKiBAc2VlIDxodHRwczovL2dpdGh1Yi5jb20vZGVsdGFrb3NoL2hhbmRqcy9ibG9iL21hc3Rlci9zcmMvaGFuZC5iYXNlLmpzPlxuICAgICAqIDEuIE1vYmlsZSBicm93c2VycyBkaXNwYXRjaCBtb3VzZSBldmVudHMgMzAwbXMgYWZ0ZXIgdG91Y2hlbmQuXG4gICAgICogMi4gQ2hyb21lIGZvciBBbmRyb2lkIGRpc3BhdGNoIG1vdXNlZG93biBmb3IgbG9uZy10b3VjaCBhYm91dCA2NTBtc1xuICAgICAqIFJlc3VsdDogQmxvY2tpbmcgTW91c2UgRXZlbnRzIGZvciA3MDBtcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzZXRUb3VjaFRpbWVyKGluc3RhbmNlKSB7XG4gICAgICAgIGluc3RhbmNlLl90b3VjaGluZyA9IHRydWU7XG4gICAgICAgIGNsZWFyVGltZW91dChpbnN0YW5jZS5fdG91Y2hUaW1lcik7XG4gICAgICAgIGluc3RhbmNlLl90b3VjaFRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpbnN0YW5jZS5fdG91Y2hpbmcgPSBmYWxzZTtcbiAgICAgICAgfSwgNzAwKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1c2VUb3VjaEV2ZW50KCkge1xuICAgICAgICByZXR1cm4gZW52LnRvdWNoRXZlbnRzU3VwcG9ydGVkO1xuICAgIH1cblxuICAgIHZhciBkb21IYW5kbGVycyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1vdXNlIG1vdmUgaGFuZGxlclxuICAgICAgICAgKiBAaW5uZXJcbiAgICAgICAgICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAgICAgICAgICovXG4gICAgICAgIG1vdXNlbW92ZTogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICBldmVudCA9IG5vcm1hbGl6ZUV2ZW50KHRoaXMuZG9tLCBldmVudCk7XG5cbiAgICAgICAgICAgIHRoaXMudHJpZ2dlcignbW91c2Vtb3ZlJywgZXZlbnQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNb3VzZSBvdXQgaGFuZGxlclxuICAgICAgICAgKiBAaW5uZXJcbiAgICAgICAgICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAgICAgICAgICovXG4gICAgICAgIG1vdXNlb3V0OiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIGV2ZW50ID0gbm9ybWFsaXplRXZlbnQodGhpcy5kb20sIGV2ZW50KTtcblxuICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSBldmVudC50b0VsZW1lbnQgfHwgZXZlbnQucmVsYXRlZFRhcmdldDtcbiAgICAgICAgICAgIGlmIChlbGVtZW50ICE9IHRoaXMuZG9tKSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGVsZW1lbnQgJiYgZWxlbWVudC5ub2RlVHlwZSAhPSA5KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIOW/veeVpeWMheWQq+WcqHJvb3TkuK3nmoRkb23lvJXotbfnmoRtb3VzZU91dFxuICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbWVudCA9PT0gdGhpcy5kb20pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQgPSBlbGVtZW50LnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnRyaWdnZXIoJ21vdXNlb3V0JywgZXZlbnQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUb3VjaOW8gOWni+WTjeW6lOWHveaVsFxuICAgICAgICAgKiBAaW5uZXJcbiAgICAgICAgICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAgICAgICAgICovXG4gICAgICAgIHRvdWNoc3RhcnQ6IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgLy8gRGVmYXVsdCBtb3VzZSBiZWhhdmlvdXIgc2hvdWxkIG5vdCBiZSBkaXNhYmxlZCBoZXJlLlxuICAgICAgICAgICAgLy8gRm9yIGV4YW1wbGUsIHBhZ2UgbWF5IG5lZWRzIHRvIGJlIHNsaWRlZC5cblxuICAgICAgICAgICAgZXZlbnQgPSBub3JtYWxpemVFdmVudCh0aGlzLmRvbSwgZXZlbnQpO1xuXG4gICAgICAgICAgICB0aGlzLl9sYXN0VG91Y2hNb21lbnQgPSBuZXcgRGF0ZSgpO1xuXG4gICAgICAgICAgICBwcm9jZXNzR2VzdHVyZSh0aGlzLCBldmVudCwgJ3N0YXJ0Jyk7XG5cbiAgICAgICAgICAgIC8vIOW5s+adv+ihpeWFheS4gOasoWZpbmRIb3ZlclxuICAgICAgICAgICAgLy8gdGhpcy5fbW9iaWxlRmluZEZpeGVkKGV2ZW50KTtcbiAgICAgICAgICAgIC8vIFRyaWdnZXIgbW91c2Vtb3ZlIGFuZCBtb3VzZWRvd25cbiAgICAgICAgICAgIGRvbUhhbmRsZXJzLm1vdXNlbW92ZS5jYWxsKHRoaXMsIGV2ZW50KTtcblxuICAgICAgICAgICAgZG9tSGFuZGxlcnMubW91c2Vkb3duLmNhbGwodGhpcywgZXZlbnQpO1xuXG4gICAgICAgICAgICBzZXRUb3VjaFRpbWVyKHRoaXMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUb3VjaOenu+WKqOWTjeW6lOWHveaVsFxuICAgICAgICAgKiBAaW5uZXJcbiAgICAgICAgICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAgICAgICAgICovXG4gICAgICAgIHRvdWNobW92ZTogZnVuY3Rpb24gKGV2ZW50KSB7XG5cbiAgICAgICAgICAgIGV2ZW50ID0gbm9ybWFsaXplRXZlbnQodGhpcy5kb20sIGV2ZW50KTtcblxuICAgICAgICAgICAgcHJvY2Vzc0dlc3R1cmUodGhpcywgZXZlbnQsICdjaGFuZ2UnKTtcblxuICAgICAgICAgICAgLy8gTW91c2UgbW92ZSBzaG91bGQgYWx3YXlzIGJlIHRyaWdnZXJlZCBubyBtYXR0ZXIgd2hldGhlclxuICAgICAgICAgICAgLy8gdGhlcmUgaXMgZ2VzdHJ1ZSBldmVudCwgYmVjYXVzZSBtb3VzZSBtb3ZlIGFuZCBwaW5jaCBtYXlcbiAgICAgICAgICAgIC8vIGJlIHVzZWQgYXQgdGhlIHNhbWUgdGltZS5cbiAgICAgICAgICAgIGRvbUhhbmRsZXJzLm1vdXNlbW92ZS5jYWxsKHRoaXMsIGV2ZW50KTtcblxuICAgICAgICAgICAgc2V0VG91Y2hUaW1lcih0aGlzKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVG91Y2jnu5PmnZ/lk43lupTlh73mlbBcbiAgICAgICAgICogQGlubmVyXG4gICAgICAgICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gICAgICAgICAqL1xuICAgICAgICB0b3VjaGVuZDogZnVuY3Rpb24gKGV2ZW50KSB7XG5cbiAgICAgICAgICAgIGV2ZW50ID0gbm9ybWFsaXplRXZlbnQodGhpcy5kb20sIGV2ZW50KTtcblxuICAgICAgICAgICAgcHJvY2Vzc0dlc3R1cmUodGhpcywgZXZlbnQsICdlbmQnKTtcblxuICAgICAgICAgICAgZG9tSGFuZGxlcnMubW91c2V1cC5jYWxsKHRoaXMsIGV2ZW50KTtcblxuICAgICAgICAgICAgLy8gY2xpY2sgZXZlbnQgc2hvdWxkIGFsd2F5cyBiZSB0cmlnZ2VyZWQgbm8gbWF0dGVyIHdoZXRoZXJcbiAgICAgICAgICAgIC8vIHRoZXJlIGlzIGdlc3RydWUgZXZlbnQuIFN5c3RlbSBjbGljayBjYW4gbm90IGJlIHByZXZlbnRlZC5cbiAgICAgICAgICAgIGlmICgrbmV3IERhdGUoKSAtIHRoaXMuX2xhc3RUb3VjaE1vbWVudCA8IFRPVUNIX0NMSUNLX0RFTEFZKSB7XG4gICAgICAgICAgICAgICAgZG9tSGFuZGxlcnMuY2xpY2suY2FsbCh0aGlzLCBldmVudCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNldFRvdWNoVGltZXIodGhpcyk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gQ29tbW9uIGhhbmRsZXJzXG4gICAgenJVdGlsLmVhY2goWydjbGljaycsICdtb3VzZWRvd24nLCAnbW91c2V1cCcsICdtb3VzZXdoZWVsJywgJ2RibGNsaWNrJ10sIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIGRvbUhhbmRsZXJzW25hbWVdID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICBldmVudCA9IG5vcm1hbGl6ZUV2ZW50KHRoaXMuZG9tLCBldmVudCk7XG4gICAgICAgICAgICB0aGlzLnRyaWdnZXIobmFtZSwgZXZlbnQpO1xuICAgICAgICB9O1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICog5Li65o6n5Yi257G75a6e5L6L5Yid5aeL5YyWZG9tIOS6i+S7tuWkhOeQhuWHveaVsFxuICAgICAqXG4gICAgICogQGlubmVyXG4gICAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9IYW5kbGVyfSBpbnN0YW5jZSDmjqfliLbnsbvlrp7kvotcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbml0RG9tSGFuZGxlcihpbnN0YW5jZSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRvdWNoSGFuZGxlck5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgbmFtZSA9IHRvdWNoSGFuZGxlck5hbWVzW2ldO1xuICAgICAgICAgICAgaW5zdGFuY2UuX2hhbmRsZXJzW25hbWVdID0genJVdGlsLmJpbmQoZG9tSGFuZGxlcnNbbmFtZV0sIGluc3RhbmNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbW91c2VIYW5kbGVyTmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBuYW1lID0gbW91c2VIYW5kbGVyTmFtZXNbaV07XG4gICAgICAgICAgICBpbnN0YW5jZS5faGFuZGxlcnNbbmFtZV0gPSBtYWtlTW91c2VIYW5kbGVyKGRvbUhhbmRsZXJzW25hbWVdLCBpbnN0YW5jZSk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBtYWtlTW91c2VIYW5kbGVyKGZuLCBpbnN0YW5jZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5zdGFuY2UuX3RvdWNoaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZuLmFwcGx5KGluc3RhbmNlLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgZnVuY3Rpb24gSGFuZGxlckRvbVByb3h5KGRvbSkge1xuICAgICAgICBFdmVudGZ1bC5jYWxsKHRoaXMpO1xuXG4gICAgICAgIHRoaXMuZG9tID0gZG9tO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3RvdWNoaW5nID0gZmFsc2U7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl90b3VjaFRpbWVyO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAdHlwZSB7bW9kdWxlOnpyZW5kZXIvY29yZS9HZXN0dXJlTWdyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fZ2VzdHVyZU1nciA9IG5ldyBHZXN0dXJlTWdyKCk7XG5cbiAgICAgICAgdGhpcy5faGFuZGxlcnMgPSB7fTtcblxuICAgICAgICBpbml0RG9tSGFuZGxlcih0aGlzKTtcblxuICAgICAgICBpZiAodXNlVG91Y2hFdmVudCgpKSB7XG4gICAgICAgICAgICBtb3VudEhhbmRsZXJzKHRvdWNoSGFuZGxlck5hbWVzLCB0aGlzKTtcblxuICAgICAgICAgICAgLy8gSGFuZGxlciBvZiAnbW91c2VvdXQnIGV2ZW50IGlzIG5lZWRlZCBpbiB0b3VjaCBtb2RlLCB3aGljaCB3aWxsIGJlIG1vdW50ZWQgYmVsb3cuXG4gICAgICAgICAgICAvLyBhZGRFdmVudExpc3RlbmVyKHJvb3QsICdtb3VzZW91dCcsIHRoaXMuX21vdXNlb3V0SGFuZGxlcik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDb25zaWRlcmluZyBzb21lIGRldmljZXMgdGhhdCBib3RoIGVuYWJsZSB0b3VjaCBhbmQgbW91c2UgZXZlbnQgKGxpa2UgTVMgU3VyZmFjZVxuICAgICAgICAvLyBhbmQgbGVub3ZvIFgyNDAsIEBzZWUgIzIzNTApLCB3ZSBtYWtlIG1vdXNlIGV2ZW50IGJlIGFsd2F5cyBsaXN0ZW5lZCwgb3RoZXJ3aXNlXG4gICAgICAgIC8vIG1vdXNlIGV2ZW50IGNhbiBub3QgYmUgaGFuZGxlIGluIHRob3NlIGRldmljZXMuXG4gICAgICAgIG1vdW50SGFuZGxlcnMobW91c2VIYW5kbGVyTmFtZXMsIHRoaXMpO1xuXG4gICAgICAgIGZ1bmN0aW9uIG1vdW50SGFuZGxlcnMoaGFuZGxlck5hbWVzLCBpbnN0YW5jZSkge1xuICAgICAgICAgICAgenJVdGlsLmVhY2goaGFuZGxlck5hbWVzLCBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgICAgIGFkZEV2ZW50TGlzdGVuZXIoZG9tLCBldmVudE5hbWVGaXgobmFtZSksIGluc3RhbmNlLl9oYW5kbGVyc1tuYW1lXSk7XG4gICAgICAgICAgICB9LCBpbnN0YW5jZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgaGFuZGxlckRvbVByb3h5UHJvdG8gPSBIYW5kbGVyRG9tUHJveHkucHJvdG90eXBlO1xuICAgIGhhbmRsZXJEb21Qcm94eVByb3RvLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBoYW5kbGVyTmFtZXMgPSBtb3VzZUhhbmRsZXJOYW1lcy5jb25jYXQodG91Y2hIYW5kbGVyTmFtZXMpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaGFuZGxlck5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgbmFtZSA9IGhhbmRsZXJOYW1lc1tpXTtcbiAgICAgICAgICAgIHJlbW92ZUV2ZW50TGlzdGVuZXIodGhpcy5kb20sIGV2ZW50TmFtZUZpeChuYW1lKSwgdGhpcy5faGFuZGxlcnNbbmFtZV0pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGhhbmRsZXJEb21Qcm94eVByb3RvLnNldEN1cnNvciA9IGZ1bmN0aW9uIChjdXJzb3JTdHlsZSkge1xuICAgICAgICB0aGlzLmRvbS5zdHlsZS5jdXJzb3IgPSBjdXJzb3JTdHlsZSB8fCAnZGVmYXVsdCc7XG4gICAgfTtcblxuICAgIHpyVXRpbC5taXhpbihIYW5kbGVyRG9tUHJveHksIEV2ZW50ZnVsKTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gSGFuZGxlckRvbVByb3h5O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34venJlbmRlci9saWIvZG9tL0hhbmRsZXJQcm94eS5qc1xuICoqIG1vZHVsZSBpZCA9IDY3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG4vKipcbiAqIE9ubHkgaW1wbGVtZW50cyBuZWVkZWQgZ2VzdHVyZXMgZm9yIG1vYmlsZS5cbiAqL1xuXG5cbiAgICB2YXIgZXZlbnRVdGlsID0gcmVxdWlyZSgnLi9ldmVudCcpO1xuXG4gICAgdmFyIEdlc3R1cmVNZ3IgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEB0eXBlIHtBcnJheS48T2JqZWN0Pn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3RyYWNrID0gW107XG4gICAgfTtcblxuICAgIEdlc3R1cmVNZ3IucHJvdG90eXBlID0ge1xuXG4gICAgICAgIGNvbnN0cnVjdG9yOiBHZXN0dXJlTWdyLFxuXG4gICAgICAgIHJlY29nbml6ZTogZnVuY3Rpb24gKGV2ZW50LCB0YXJnZXQsIHJvb3QpIHtcbiAgICAgICAgICAgIHRoaXMuX2RvVHJhY2soZXZlbnQsIHRhcmdldCwgcm9vdCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVjb2duaXplKGV2ZW50KTtcbiAgICAgICAgfSxcblxuICAgICAgICBjbGVhcjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5fdHJhY2subGVuZ3RoID0gMDtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9kb1RyYWNrOiBmdW5jdGlvbiAoZXZlbnQsIHRhcmdldCwgcm9vdCkge1xuICAgICAgICAgICAgdmFyIHRvdWNoZXMgPSBldmVudC50b3VjaGVzO1xuXG4gICAgICAgICAgICBpZiAoIXRvdWNoZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciB0cmFja0l0ZW0gPSB7XG4gICAgICAgICAgICAgICAgcG9pbnRzOiBbXSxcbiAgICAgICAgICAgICAgICB0b3VjaGVzOiBbXSxcbiAgICAgICAgICAgICAgICB0YXJnZXQ6IHRhcmdldCxcbiAgICAgICAgICAgICAgICBldmVudDogZXZlbnRcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0b3VjaGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRvdWNoID0gdG91Y2hlc1tpXTtcbiAgICAgICAgICAgICAgICB2YXIgcG9zID0gZXZlbnRVdGlsLmNsaWVudFRvTG9jYWwocm9vdCwgdG91Y2gpO1xuICAgICAgICAgICAgICAgIHRyYWNrSXRlbS5wb2ludHMucHVzaChbcG9zLnpyWCwgcG9zLnpyWV0pO1xuICAgICAgICAgICAgICAgIHRyYWNrSXRlbS50b3VjaGVzLnB1c2godG91Y2gpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl90cmFjay5wdXNoKHRyYWNrSXRlbSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX3JlY29nbml6ZTogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICBmb3IgKHZhciBldmVudE5hbWUgaW4gcmVjb2duaXplcnMpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVjb2duaXplcnMuaGFzT3duUHJvcGVydHkoZXZlbnROYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZ2VzdHVyZUluZm8gPSByZWNvZ25pemVyc1tldmVudE5hbWVdKHRoaXMuX3RyYWNrLCBldmVudCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChnZXN0dXJlSW5mbykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdlc3R1cmVJbmZvO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGRpc3QocG9pbnRQYWlyKSB7XG4gICAgICAgIHZhciBkeCA9IHBvaW50UGFpclsxXVswXSAtIHBvaW50UGFpclswXVswXTtcbiAgICAgICAgdmFyIGR5ID0gcG9pbnRQYWlyWzFdWzFdIC0gcG9pbnRQYWlyWzBdWzFdO1xuXG4gICAgICAgIHJldHVybiBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNlbnRlcihwb2ludFBhaXIpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIChwb2ludFBhaXJbMF1bMF0gKyBwb2ludFBhaXJbMV1bMF0pIC8gMixcbiAgICAgICAgICAgIChwb2ludFBhaXJbMF1bMV0gKyBwb2ludFBhaXJbMV1bMV0pIC8gMlxuICAgICAgICBdO1xuICAgIH1cblxuICAgIHZhciByZWNvZ25pemVycyA9IHtcblxuICAgICAgICBwaW5jaDogZnVuY3Rpb24gKHRyYWNrLCBldmVudCkge1xuICAgICAgICAgICAgdmFyIHRyYWNrTGVuID0gdHJhY2subGVuZ3RoO1xuXG4gICAgICAgICAgICBpZiAoIXRyYWNrTGVuKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgcGluY2hFbmQgPSAodHJhY2tbdHJhY2tMZW4gLSAxXSB8fCB7fSkucG9pbnRzO1xuICAgICAgICAgICAgdmFyIHBpbmNoUHJlID0gKHRyYWNrW3RyYWNrTGVuIC0gMl0gfHwge30pLnBvaW50cyB8fCBwaW5jaEVuZDtcblxuICAgICAgICAgICAgaWYgKHBpbmNoUHJlXG4gICAgICAgICAgICAgICAgJiYgcGluY2hQcmUubGVuZ3RoID4gMVxuICAgICAgICAgICAgICAgICYmIHBpbmNoRW5kXG4gICAgICAgICAgICAgICAgJiYgcGluY2hFbmQubGVuZ3RoID4gMVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBpbmNoU2NhbGUgPSBkaXN0KHBpbmNoRW5kKSAvIGRpc3QocGluY2hQcmUpO1xuICAgICAgICAgICAgICAgICFpc0Zpbml0ZShwaW5jaFNjYWxlKSAmJiAocGluY2hTY2FsZSA9IDEpO1xuXG4gICAgICAgICAgICAgICAgZXZlbnQucGluY2hTY2FsZSA9IHBpbmNoU2NhbGU7XG5cbiAgICAgICAgICAgICAgICB2YXIgcGluY2hDZW50ZXIgPSBjZW50ZXIocGluY2hFbmQpO1xuICAgICAgICAgICAgICAgIGV2ZW50LnBpbmNoWCA9IHBpbmNoQ2VudGVyWzBdO1xuICAgICAgICAgICAgICAgIGV2ZW50LnBpbmNoWSA9IHBpbmNoQ2VudGVyWzFdO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3BpbmNoJyxcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiB0cmFja1swXS50YXJnZXQsXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50OiBldmVudFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBPbmx5IHBpbmNoIGN1cnJlbnRseS5cbiAgICB9O1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBHZXN0dXJlTWdyO1xuXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi96cmVuZGVyL2xpYi9jb3JlL0dlc3R1cmVNZ3IuanNcbiAqKiBtb2R1bGUgaWQgPSA2OFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuLyoqXG4gKiBEZWZhdWx0IGNhbnZhcyBwYWludGVyXG4gKiBAbW9kdWxlIHpyZW5kZXIvUGFpbnRlclxuICogQGF1dGhvciBLZW5lciAoQEtlbmVyLeael+WzsCwga2VuZXIubGluZmVuZ0BnbWFpbC5jb20pXG4gKiAgICAgICAgIGVycm9ycmlrIChlcnJvcnJpa0BnbWFpbC5jb20pXG4gKiAgICAgICAgIHBpc3NhbmcgKGh0dHBzOi8vd3d3LmdpdGh1Yi5jb20vcGlzc2FuZylcbiAqL1xuIFxuXG4gICAgdmFyIGNvbmZpZyA9IHJlcXVpcmUoJy4vY29uZmlnJyk7XG4gICAgdmFyIHV0aWwgPSByZXF1aXJlKCcuL2NvcmUvdXRpbCcpO1xuICAgIHZhciBsb2cgPSByZXF1aXJlKCcuL2NvcmUvbG9nJyk7XG4gICAgdmFyIEJvdW5kaW5nUmVjdCA9IHJlcXVpcmUoJy4vY29yZS9Cb3VuZGluZ1JlY3QnKTtcbiAgICB2YXIgdGltc29ydCA9IHJlcXVpcmUoJy4vY29yZS90aW1zb3J0Jyk7XG5cbiAgICB2YXIgTGF5ZXIgPSByZXF1aXJlKCcuL0xheWVyJyk7XG5cbiAgICB2YXIgcmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gcmVxdWlyZSgnLi9hbmltYXRpb24vcmVxdWVzdEFuaW1hdGlvbkZyYW1lJyk7XG5cbiAgICAvLyBQRU5ESUdOXG4gICAgLy8gTGF5ZXIgZXhjZWVkcyBNQVhfUFJPR1JFU1NJVkVfTEFZRVJfTlVNQkVSIG1heSBoYXZlIHNvbWUgcHJvYmxlbSB3aGVuIGZsdXNoIGRpcmVjdGx5IHNlY29uZCB0aW1lLlxuICAgIC8vXG4gICAgLy8gTWF4aW11bSBwcm9ncmVzc2l2ZSBsYXllci4gV2hlbiBleGNlZWRpbmcgdGhpcyBudW1iZXIuIEFsbCBlbGVtZW50cyB3aWxsIGJlIGRyYXdlZCBpbiB0aGUgbGFzdCBsYXllci5cbiAgICB2YXIgTUFYX1BST0dSRVNTSVZFX0xBWUVSX05VTUJFUiA9IDU7XG5cbiAgICBmdW5jdGlvbiBwYXJzZUludDEwKHZhbCkge1xuICAgICAgICByZXR1cm4gcGFyc2VJbnQodmFsLCAxMCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNMYXllclZhbGlkKGxheWVyKSB7XG4gICAgICAgIGlmICghbGF5ZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsYXllci5pc0J1aWxkaW4pIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZihsYXllci5yZXNpemUpICE9PSAnZnVuY3Rpb24nXG4gICAgICAgICAgICB8fCB0eXBlb2YobGF5ZXIucmVmcmVzaCkgIT09ICdmdW5jdGlvbidcbiAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcmVQcm9jZXNzTGF5ZXIobGF5ZXIpIHtcbiAgICAgICAgbGF5ZXIuX191bnVzZWRDb3VudCsrO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBvc3RQcm9jZXNzTGF5ZXIobGF5ZXIpIHtcbiAgICAgICAgaWYgKGxheWVyLl9fdW51c2VkQ291bnQgPT0gMSkge1xuICAgICAgICAgICAgbGF5ZXIuY2xlYXIoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciB0bXBSZWN0ID0gbmV3IEJvdW5kaW5nUmVjdCgwLCAwLCAwLCAwKTtcbiAgICB2YXIgdmlld1JlY3QgPSBuZXcgQm91bmRpbmdSZWN0KDAsIDAsIDAsIDApO1xuICAgIGZ1bmN0aW9uIGlzRGlzcGxheWFibGVDdWxsZWQoZWwsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgdG1wUmVjdC5jb3B5KGVsLmdldEJvdW5kaW5nUmVjdCgpKTtcbiAgICAgICAgaWYgKGVsLnRyYW5zZm9ybSkge1xuICAgICAgICAgICAgdG1wUmVjdC5hcHBseVRyYW5zZm9ybShlbC50cmFuc2Zvcm0pO1xuICAgICAgICB9XG4gICAgICAgIHZpZXdSZWN0LndpZHRoID0gd2lkdGg7XG4gICAgICAgIHZpZXdSZWN0LmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgcmV0dXJuICF0bXBSZWN0LmludGVyc2VjdCh2aWV3UmVjdCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNDbGlwUGF0aENoYW5nZWQoY2xpcFBhdGhzLCBwcmV2Q2xpcFBhdGhzKSB7XG4gICAgICAgIGlmIChjbGlwUGF0aHMgPT0gcHJldkNsaXBQYXRocykgeyAvLyBDYW4gYm90aCBiZSBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFjbGlwUGF0aHMgfHwgIXByZXZDbGlwUGF0aHMgfHwgKGNsaXBQYXRocy5sZW5ndGggIT09IHByZXZDbGlwUGF0aHMubGVuZ3RoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbGlwUGF0aHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChjbGlwUGF0aHNbaV0gIT09IHByZXZDbGlwUGF0aHNbaV0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRvQ2xpcChjbGlwUGF0aHMsIGN0eCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNsaXBQYXRocy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGNsaXBQYXRoID0gY2xpcFBhdGhzW2ldO1xuICAgICAgICAgICAgdmFyIHBhdGggPSBjbGlwUGF0aC5wYXRoO1xuXG4gICAgICAgICAgICBjbGlwUGF0aC5zZXRUcmFuc2Zvcm0oY3R4KTtcbiAgICAgICAgICAgIHBhdGguYmVnaW5QYXRoKGN0eCk7XG4gICAgICAgICAgICBjbGlwUGF0aC5idWlsZFBhdGgocGF0aCwgY2xpcFBhdGguc2hhcGUpO1xuICAgICAgICAgICAgY3R4LmNsaXAoKTtcbiAgICAgICAgICAgIC8vIFRyYW5zZm9ybSBiYWNrXG4gICAgICAgICAgICBjbGlwUGF0aC5yZXN0b3JlVHJhbnNmb3JtKGN0eCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVSb290KHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgdmFyIGRvbVJvb3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdmFyIGRvbVJvb3RTdHlsZSA9IGRvbVJvb3Quc3R5bGU7XG5cbiAgICAgICAgLy8gZG9tUm9vdC5vbnNlbGVjdHN0YXJ0ID0gcmV0dXJuRmFsc2U7IC8vIOmBv+WFjemhtemdoumAieS4reeahOWwtOWwrFxuICAgICAgICBkb21Sb290U3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnO1xuICAgICAgICBkb21Sb290U3R5bGUub3ZlcmZsb3cgPSAnaGlkZGVuJztcbiAgICAgICAgZG9tUm9vdFN0eWxlLndpZHRoID0gd2lkdGggKyAncHgnO1xuICAgICAgICBkb21Sb290U3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgJ3B4JztcbiAgICAgICAgcmV0dXJuIGRvbVJvb3Q7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGFsaWFzIG1vZHVsZTp6cmVuZGVyL1BhaW50ZXJcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSByb290IOe7mOWbvuWuueWZqFxuICAgICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvU3RvcmFnZX0gc3RvcmFnZVxuICAgICAqIEBwYXJhbSB7T2piZWN0fSBvcHRzXG4gICAgICovXG4gICAgdmFyIFBhaW50ZXIgPSBmdW5jdGlvbiAocm9vdCwgc3RvcmFnZSwgb3B0cykge1xuICAgICAgICAvLyBJbiBub2RlIGVudmlyb25tZW50IHVzaW5nIG5vZGUtY2FudmFzXG4gICAgICAgIHZhciBzaW5nbGVDYW52YXMgPSAhcm9vdC5ub2RlTmFtZSAvLyBJbiBub2RlID9cbiAgICAgICAgICAgIHx8IHJvb3Qubm9kZU5hbWUudG9VcHBlckNhc2UoKSA9PT0gJ0NBTlZBUyc7XG5cbiAgICAgICAgb3B0cyA9IG9wdHMgfHwge307XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRwciA9IG9wdHMuZGV2aWNlUGl4ZWxSYXRpbyB8fCBjb25maWcuZGV2aWNlUGl4ZWxSYXRpbztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fc2luZ2xlQ2FudmFzID0gc2luZ2xlQ2FudmFzO1xuICAgICAgICAvKipcbiAgICAgICAgICog57uY5Zu+5a655ZmoXG4gICAgICAgICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucm9vdCA9IHJvb3Q7XG5cbiAgICAgICAgdmFyIHJvb3RTdHlsZSA9IHJvb3Quc3R5bGU7XG5cbiAgICAgICAgaWYgKHJvb3RTdHlsZSkge1xuICAgICAgICAgICAgcm9vdFN0eWxlWyctd2Via2l0LXRhcC1oaWdobGlnaHQtY29sb3InXSA9ICd0cmFuc3BhcmVudCc7XG4gICAgICAgICAgICByb290U3R5bGVbJy13ZWJraXQtdXNlci1zZWxlY3QnXSA9XG4gICAgICAgICAgICByb290U3R5bGVbJ3VzZXItc2VsZWN0J10gPVxuICAgICAgICAgICAgcm9vdFN0eWxlWyctd2Via2l0LXRvdWNoLWNhbGxvdXQnXSA9ICdub25lJztcblxuICAgICAgICAgICAgcm9vdC5pbm5lckhUTUwgPSAnJztcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7bW9kdWxlOnpyZW5kZXIvU3RvcmFnZX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3RvcmFnZSA9IHN0b3JhZ2U7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtBcnJheS48bnVtYmVyPn1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHZhciB6bGV2ZWxMaXN0ID0gdGhpcy5femxldmVsTGlzdCA9IFtdO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsIG1vZHVsZTp6cmVuZGVyL0xheWVyPn1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHZhciBsYXllcnMgPSB0aGlzLl9sYXllcnMgPSB7fTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge09iamVjdC48c3RyaW5nLCBPYmplY3Q+fVxuICAgICAgICAgKiBAdHlwZSB7cHJpdmF0ZX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2xheWVyQ29uZmlnID0ge307XG5cbiAgICAgICAgaWYgKCFzaW5nbGVDYW52YXMpIHtcbiAgICAgICAgICAgIHRoaXMuX3dpZHRoID0gdGhpcy5fZ2V0V2lkdGgoKTtcbiAgICAgICAgICAgIHRoaXMuX2hlaWdodCA9IHRoaXMuX2dldEhlaWdodCgpO1xuXG4gICAgICAgICAgICB2YXIgZG9tUm9vdCA9IHRoaXMuX2RvbVJvb3QgPSBjcmVhdGVSb290KFxuICAgICAgICAgICAgICAgIHRoaXMuX3dpZHRoLCB0aGlzLl9oZWlnaHRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICByb290LmFwcGVuZENoaWxkKGRvbVJvb3QpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gVXNlIGNhbnZhcyB3aWR0aCBhbmQgaGVpZ2h0IGRpcmVjdGx5XG4gICAgICAgICAgICB2YXIgd2lkdGggPSByb290LndpZHRoO1xuICAgICAgICAgICAgdmFyIGhlaWdodCA9IHJvb3QuaGVpZ2h0O1xuICAgICAgICAgICAgdGhpcy5fd2lkdGggPSB3aWR0aDtcbiAgICAgICAgICAgIHRoaXMuX2hlaWdodCA9IGhlaWdodDtcblxuICAgICAgICAgICAgLy8gQ3JlYXRlIGxheWVyIGlmIG9ubHkgb25lIGdpdmVuIGNhbnZhc1xuICAgICAgICAgICAgLy8gRGV2aWNlIHBpeGVsIHJhdGlvIGlzIGZpeGVkIHRvIDEgYmVjYXVzZSBnaXZlbiBjYW52YXMgaGFzIGl0cyBzcGVjaWZpZWQgd2lkdGggYW5kIGhlaWdodFxuICAgICAgICAgICAgdmFyIG1haW5MYXllciA9IG5ldyBMYXllcihyb290LCB0aGlzLCAxKTtcbiAgICAgICAgICAgIG1haW5MYXllci5pbml0Q29udGV4dCgpO1xuICAgICAgICAgICAgLy8gRklYTUUgVXNlIGNhbnZhcyB3aWR0aCBhbmQgaGVpZ2h0XG4gICAgICAgICAgICAvLyBtYWluTGF5ZXIucmVzaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgICAgbGF5ZXJzWzBdID0gbWFpbkxheWVyO1xuICAgICAgICAgICAgemxldmVsTGlzdC5wdXNoKDApO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5wYXRoVG9JbWFnZSA9IHRoaXMuX2NyZWF0ZVBhdGhUb0ltYWdlKCk7XG5cbiAgICAgICAgLy8gTGF5ZXJzIGZvciBwcm9ncmVzc2l2ZSByZW5kZXJpbmdcbiAgICAgICAgdGhpcy5fcHJvZ3Jlc3NpdmVMYXllcnMgPSBbXTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge21vZHVsZTp6cmVuZGVyL0xheWVyfVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5faG92ZXJsYXllcjtcblxuICAgICAgICB0aGlzLl9ob3ZlckVsZW1lbnRzID0gW107XG4gICAgfTtcblxuICAgIFBhaW50ZXIucHJvdG90eXBlID0ge1xuXG4gICAgICAgIGNvbnN0cnVjdG9yOiBQYWludGVyLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiBwYWludGVyIHVzZSBhIHNpbmdsZSBjYW52YXNcbiAgICAgICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIGlzU2luZ2xlQ2FudmFzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2luZ2xlQ2FudmFzO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7SFRNTERpdkVsZW1lbnR9XG4gICAgICAgICAqL1xuICAgICAgICBnZXRWaWV3cG9ydFJvb3Q6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zaW5nbGVDYW52YXMgPyB0aGlzLl9sYXllcnNbMF0uZG9tIDogdGhpcy5fZG9tUm9vdDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5Yi35pawXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3BhaW50QWxsPWZhbHNlXSDlvLrliLbnu5jliLbmiYDmnIlkaXNwbGF5YWJsZVxuICAgICAgICAgKi9cbiAgICAgICAgcmVmcmVzaDogZnVuY3Rpb24gKHBhaW50QWxsKSB7XG5cbiAgICAgICAgICAgIHZhciBsaXN0ID0gdGhpcy5zdG9yYWdlLmdldERpc3BsYXlMaXN0KHRydWUpO1xuXG4gICAgICAgICAgICB2YXIgemxldmVsTGlzdCA9IHRoaXMuX3psZXZlbExpc3Q7XG5cbiAgICAgICAgICAgIHRoaXMuX3BhaW50TGlzdChsaXN0LCBwYWludEFsbCk7XG5cbiAgICAgICAgICAgIC8vIFBhaW50IGN1c3R1bSBsYXllcnNcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgemxldmVsTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciB6ID0gemxldmVsTGlzdFtpXTtcbiAgICAgICAgICAgICAgICB2YXIgbGF5ZXIgPSB0aGlzLl9sYXllcnNbel07XG4gICAgICAgICAgICAgICAgaWYgKCFsYXllci5pc0J1aWxkaW4gJiYgbGF5ZXIucmVmcmVzaCkge1xuICAgICAgICAgICAgICAgICAgICBsYXllci5yZWZyZXNoKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnJlZnJlc2hIb3ZlcigpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5fcHJvZ3Jlc3NpdmVMYXllcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhcnRQcm9nZXNzaXZlKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGFkZEhvdmVyOiBmdW5jdGlvbiAoZWwsIGhvdmVyU3R5bGUpIHtcbiAgICAgICAgICAgIGlmIChlbC5fX2hvdmVyTWlyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGVsTWlycm9yID0gbmV3IGVsLmNvbnN0cnVjdG9yKHtcbiAgICAgICAgICAgICAgICBzdHlsZTogZWwuc3R5bGUsXG4gICAgICAgICAgICAgICAgc2hhcGU6IGVsLnNoYXBlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGVsTWlycm9yLl9fZnJvbSA9IGVsO1xuICAgICAgICAgICAgZWwuX19ob3Zlck1pciA9IGVsTWlycm9yO1xuICAgICAgICAgICAgZWxNaXJyb3Iuc2V0U3R5bGUoaG92ZXJTdHlsZSk7XG4gICAgICAgICAgICB0aGlzLl9ob3ZlckVsZW1lbnRzLnB1c2goZWxNaXJyb3IpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHJlbW92ZUhvdmVyOiBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgIHZhciBlbE1pcnJvciA9IGVsLl9faG92ZXJNaXI7XG4gICAgICAgICAgICB2YXIgaG92ZXJFbGVtZW50cyA9IHRoaXMuX2hvdmVyRWxlbWVudHM7XG4gICAgICAgICAgICB2YXIgaWR4ID0gdXRpbC5pbmRleE9mKGhvdmVyRWxlbWVudHMsIGVsTWlycm9yKTtcbiAgICAgICAgICAgIGlmIChpZHggPj0gMCkge1xuICAgICAgICAgICAgICAgIGhvdmVyRWxlbWVudHMuc3BsaWNlKGlkeCwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbC5fX2hvdmVyTWlyID0gbnVsbDtcbiAgICAgICAgfSxcblxuICAgICAgICBjbGVhckhvdmVyOiBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgIHZhciBob3ZlckVsZW1lbnRzID0gdGhpcy5faG92ZXJFbGVtZW50cztcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaG92ZXJFbGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBmcm9tID0gaG92ZXJFbGVtZW50c1tpXS5fX2Zyb207XG4gICAgICAgICAgICAgICAgaWYgKGZyb20pIHtcbiAgICAgICAgICAgICAgICAgICAgZnJvbS5fX2hvdmVyTWlyID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBob3ZlckVsZW1lbnRzLmxlbmd0aCA9IDA7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVmcmVzaEhvdmVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgaG92ZXJFbGVtZW50cyA9IHRoaXMuX2hvdmVyRWxlbWVudHM7XG4gICAgICAgICAgICB2YXIgbGVuID0gaG92ZXJFbGVtZW50cy5sZW5ndGg7XG4gICAgICAgICAgICB2YXIgaG92ZXJMYXllciA9IHRoaXMuX2hvdmVybGF5ZXI7XG4gICAgICAgICAgICBob3ZlckxheWVyICYmIGhvdmVyTGF5ZXIuY2xlYXIoKTtcblxuICAgICAgICAgICAgaWYgKCFsZW4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aW1zb3J0KGhvdmVyRWxlbWVudHMsIHRoaXMuc3RvcmFnZS5kaXNwbGF5YWJsZVNvcnRGdW5jKTtcblxuICAgICAgICAgICAgLy8gVXNlIGEgZXh0cmVhbSBsYXJnZSB6bGV2ZWxcbiAgICAgICAgICAgIC8vIEZJWE1FP1xuICAgICAgICAgICAgaWYgKCFob3ZlckxheWVyKSB7XG4gICAgICAgICAgICAgICAgaG92ZXJMYXllciA9IHRoaXMuX2hvdmVybGF5ZXIgPSB0aGlzLmdldExheWVyKDFlNSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBzY29wZSA9IHt9O1xuICAgICAgICAgICAgaG92ZXJMYXllci5jdHguc2F2ZSgpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47KSB7XG4gICAgICAgICAgICAgICAgdmFyIGVsID0gaG92ZXJFbGVtZW50c1tpXTtcbiAgICAgICAgICAgICAgICB2YXIgb3JpZ2luYWxFbCA9IGVsLl9fZnJvbTtcbiAgICAgICAgICAgICAgICAvLyBPcmlnaW5hbCBlbCBpcyByZW1vdmVkXG4gICAgICAgICAgICAgICAgLy8gUEVORElOR1xuICAgICAgICAgICAgICAgIGlmICghKG9yaWdpbmFsRWwgJiYgb3JpZ2luYWxFbC5fX3pyKSkge1xuICAgICAgICAgICAgICAgICAgICBob3ZlckVsZW1lbnRzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxFbC5fX2hvdmVyTWlyID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgbGVuLS07XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpKys7XG5cbiAgICAgICAgICAgICAgICAvLyBVc2UgdHJhbnNmb3JtXG4gICAgICAgICAgICAgICAgLy8gRklYTUUgc3R5bGUgYW5kIHNoYXBlID9cbiAgICAgICAgICAgICAgICBpZiAoIW9yaWdpbmFsRWwuaW52aXNpYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsLnRyYW5zZm9ybSA9IG9yaWdpbmFsRWwudHJhbnNmb3JtO1xuICAgICAgICAgICAgICAgICAgICBlbC5pbnZUcmFuc2Zvcm0gPSBvcmlnaW5hbEVsLmludlRyYW5zZm9ybTtcbiAgICAgICAgICAgICAgICAgICAgZWwuX19jbGlwUGF0aHMgPSBvcmlnaW5hbEVsLl9fY2xpcFBhdGhzO1xuICAgICAgICAgICAgICAgICAgICAvLyBlbC5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZG9QYWludEVsKGVsLCBob3ZlckxheWVyLCB0cnVlLCBzY29wZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaG92ZXJMYXllci5jdHgucmVzdG9yZSgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9zdGFydFByb2dlc3NpdmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICAgICAgaWYgKCFzZWxmLl9mdXJ0aGVyUHJvZ3Jlc3NpdmUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFVzZSBhIHRva2VuIHRvIHN0b3AgcHJvZ3Jlc3Mgc3RlcHMgdHJpZ2dlcmVkIGJ5XG4gICAgICAgICAgICAvLyBwcmV2aW91cyB6ci5yZWZyZXNoIGNhbGxpbmcuXG4gICAgICAgICAgICB2YXIgdG9rZW4gPSBzZWxmLl9wcm9ncmVzc2l2ZVRva2VuID0gK25ldyBEYXRlKCk7XG5cbiAgICAgICAgICAgIHNlbGYuX3Byb2dyZXNzKys7XG4gICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoc3RlcCk7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIHN0ZXAoKSB7XG4gICAgICAgICAgICAgICAgLy8gSW4gY2FzZSByZWZyZXNoZWQgb3IgZGlzcG9zZWRcbiAgICAgICAgICAgICAgICBpZiAodG9rZW4gPT09IHNlbGYuX3Byb2dyZXNzaXZlVG9rZW4gJiYgc2VsZi5zdG9yYWdlKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgc2VsZi5fZG9QYWludExpc3Qoc2VsZi5zdG9yYWdlLmdldERpc3BsYXlMaXN0KCkpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLl9mdXJ0aGVyUHJvZ3Jlc3NpdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX3Byb2dyZXNzKys7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoc3RlcCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9wcm9ncmVzc2l2ZVRva2VuID0gLTE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2NsZWFyUHJvZ3Jlc3NpdmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX3Byb2dyZXNzaXZlVG9rZW4gPSAtMTtcbiAgICAgICAgICAgIHRoaXMuX3Byb2dyZXNzID0gMDtcbiAgICAgICAgICAgIHV0aWwuZWFjaCh0aGlzLl9wcm9ncmVzc2l2ZUxheWVycywgZnVuY3Rpb24gKGxheWVyKSB7XG4gICAgICAgICAgICAgICAgbGF5ZXIuX19kaXJ0eSAmJiBsYXllci5jbGVhcigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX3BhaW50TGlzdDogZnVuY3Rpb24gKGxpc3QsIHBhaW50QWxsKSB7XG5cbiAgICAgICAgICAgIGlmIChwYWludEFsbCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcGFpbnRBbGwgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5fdXBkYXRlTGF5ZXJTdGF0dXMobGlzdCk7XG5cbiAgICAgICAgICAgIHRoaXMuX2NsZWFyUHJvZ3Jlc3NpdmUoKTtcblxuICAgICAgICAgICAgdGhpcy5lYWNoQnVpbGRpbkxheWVyKHByZVByb2Nlc3NMYXllcik7XG5cbiAgICAgICAgICAgIHRoaXMuX2RvUGFpbnRMaXN0KGxpc3QsIHBhaW50QWxsKTtcblxuICAgICAgICAgICAgdGhpcy5lYWNoQnVpbGRpbkxheWVyKHBvc3RQcm9jZXNzTGF5ZXIpO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9kb1BhaW50TGlzdDogZnVuY3Rpb24gKGxpc3QsIHBhaW50QWxsKSB7XG4gICAgICAgICAgICB2YXIgY3VycmVudExheWVyO1xuICAgICAgICAgICAgdmFyIGN1cnJlbnRaTGV2ZWw7XG4gICAgICAgICAgICB2YXIgY3R4O1xuXG4gICAgICAgICAgICAvLyB2YXIgaW52VHJhbnNmb3JtID0gW107XG4gICAgICAgICAgICB2YXIgc2NvcGU7XG5cbiAgICAgICAgICAgIHZhciBwcm9ncmVzc2l2ZUxheWVySWR4ID0gMDtcbiAgICAgICAgICAgIHZhciBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllcjtcblxuICAgICAgICAgICAgdmFyIHdpZHRoID0gdGhpcy5fd2lkdGg7XG4gICAgICAgICAgICB2YXIgaGVpZ2h0ID0gdGhpcy5faGVpZ2h0O1xuICAgICAgICAgICAgdmFyIGxheWVyUHJvZ3Jlc3M7XG4gICAgICAgICAgICB2YXIgZnJhbWUgPSB0aGlzLl9wcm9ncmVzcztcbiAgICAgICAgICAgIGZ1bmN0aW9uIGZsdXNoUHJvZ3Jlc3NpdmVMYXllcihsYXllcikge1xuICAgICAgICAgICAgICAgIHZhciBkcHIgPSBjdHguZHByIHx8IDE7XG4gICAgICAgICAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSAxO1xuICAgICAgICAgICAgICAgIGN0eC5zaGFkb3dCbHVyID0gMDtcbiAgICAgICAgICAgICAgICAvLyBBdm9pZCBsYXllciBkb24ndCBjbGVhciBpbiBuZXh0IHByb2dyZXNzaXZlIGZyYW1lXG4gICAgICAgICAgICAgICAgY3VycmVudExheWVyLl9fZGlydHkgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGN0eC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG4gICAgICAgICAgICAgICAgY3R4LmRyYXdJbWFnZShsYXllci5kb20sIDAsIDAsIHdpZHRoICogZHByLCBoZWlnaHQgKiBkcHIpO1xuICAgICAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gbGlzdC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgZWwgPSBsaXN0W2ldO1xuICAgICAgICAgICAgICAgIHZhciBlbFpMZXZlbCA9IHRoaXMuX3NpbmdsZUNhbnZhcyA/IDAgOiBlbC56bGV2ZWw7XG5cbiAgICAgICAgICAgICAgICB2YXIgZWxGcmFtZSA9IGVsLl9fZnJhbWU7XG5cbiAgICAgICAgICAgICAgICAvLyBGbHVzaCBhdCBjdXJyZW50IGNvbnRleHRcbiAgICAgICAgICAgICAgICAvLyBQRU5ESU5HXG4gICAgICAgICAgICAgICAgaWYgKGVsRnJhbWUgPCAwICYmIGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGZsdXNoUHJvZ3Jlc3NpdmVMYXllcihjdXJyZW50UHJvZ3Jlc3NpdmVMYXllcik7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBDaGFuZ2UgZHJhdyBsYXllclxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50WkxldmVsICE9PSBlbFpMZXZlbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY3R4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gUmVzZXQgc2NvcGVcbiAgICAgICAgICAgICAgICAgICAgc2NvcGUgPSB7fTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBPbmx5IDAgemxldmVsIGlmIG9ubHkgaGFzIG9uZSBjYW52YXNcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFpMZXZlbCA9IGVsWkxldmVsO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50TGF5ZXIgPSB0aGlzLmdldExheWVyKGN1cnJlbnRaTGV2ZWwpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICghY3VycmVudExheWVyLmlzQnVpbGRpbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdaTGV2ZWwgJyArIGN1cnJlbnRaTGV2ZWxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICArICcgaGFzIGJlZW4gdXNlZCBieSB1bmtvd24gbGF5ZXIgJyArIGN1cnJlbnRMYXllci5pZFxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IGN1cnJlbnRMYXllci5jdHg7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5zYXZlKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gUmVzZXQgdGhlIGNvdW50XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRMYXllci5fX3VudXNlZENvdW50ID0gMDtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudExheWVyLl9fZGlydHkgfHwgcGFpbnRBbGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRMYXllci5jbGVhcigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCEoY3VycmVudExheWVyLl9fZGlydHkgfHwgcGFpbnRBbGwpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChlbEZyYW1lID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUHJvZ3Jlc3NpdmUgbGF5ZXIgY2hhbmdlZFxuICAgICAgICAgICAgICAgICAgICBpZiAoIWN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllciA9IHRoaXMuX3Byb2dyZXNzaXZlTGF5ZXJzW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1hdGgubWluKHByb2dyZXNzaXZlTGF5ZXJJZHgrKywgTUFYX1BST0dSRVNTSVZFX0xBWUVSX05VTUJFUiAtIDEpXG4gICAgICAgICAgICAgICAgICAgICAgICBdO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllci5jdHguc2F2ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFByb2dyZXNzaXZlTGF5ZXIucmVuZGVyU2NvcGUgPSB7fTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgKGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyLl9fcHJvZ3Jlc3MgPiBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllci5fX21heFByb2dyZXNzKVxuICAgICAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZmx1c2hQcm9ncmVzc2l2ZUxheWVyKGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBRdWljayBqdW1wIGFsbCBwcm9ncmVzc2l2ZSBlbGVtZW50c1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFsbCBwcm9ncmVzc2l2ZSBlbGVtZW50IGFyZSBub3QgZGlydHksIGp1bXAgb3ZlciBhbmQgZmx1c2ggZGlyZWN0bHlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpID0gY3VycmVudFByb2dyZXNzaXZlTGF5ZXIuX19uZXh0SWR4Tm90UHJvZyAtIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY3VycmVudFByb2dyZXNzaXZlTGF5ZXIgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBsYXllclByb2dyZXNzID0gY3VycmVudFByb2dyZXNzaXZlTGF5ZXIuX19wcm9ncmVzcztcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjdXJyZW50UHJvZ3Jlc3NpdmVMYXllci5fX2RpcnR5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gS2VlcCByZW5kZXJpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcmFtZSA9IGxheWVyUHJvZ3Jlc3M7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyLl9fcHJvZ3Jlc3MgPSBmcmFtZSArIDE7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoZWxGcmFtZSA9PT0gZnJhbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2RvUGFpbnRFbChlbCwgY3VycmVudFByb2dyZXNzaXZlTGF5ZXIsIHRydWUsIGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyLnJlbmRlclNjb3BlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZG9QYWludEVsKGVsLCBjdXJyZW50TGF5ZXIsIHBhaW50QWxsLCBzY29wZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZWwuX19kaXJ0eSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoY3VycmVudFByb2dyZXNzaXZlTGF5ZXIpIHtcbiAgICAgICAgICAgICAgICBmbHVzaFByb2dyZXNzaXZlTGF5ZXIoY3VycmVudFByb2dyZXNzaXZlTGF5ZXIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBSZXN0b3JlIHRoZSBsYXN0TGF5ZXIgY3R4XG4gICAgICAgICAgICBjdHggJiYgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgICAgIC8vIElmIHN0aWxsIGhhcyBjbGlwcGluZyBzdGF0ZVxuICAgICAgICAgICAgLy8gaWYgKHNjb3BlLnByZXZFbENsaXBQYXRocykge1xuICAgICAgICAgICAgLy8gICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgICAgICAvLyB9XG5cbiAgICAgICAgICAgIHRoaXMuX2Z1cnRoZXJQcm9ncmVzc2l2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgdXRpbC5lYWNoKHRoaXMuX3Byb2dyZXNzaXZlTGF5ZXJzLCBmdW5jdGlvbiAobGF5ZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAobGF5ZXIuX19tYXhQcm9ncmVzcyA+PSBsYXllci5fX3Byb2dyZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2Z1cnRoZXJQcm9ncmVzc2l2ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2RvUGFpbnRFbDogZnVuY3Rpb24gKGVsLCBjdXJyZW50TGF5ZXIsIGZvcmNlUGFpbnQsIHNjb3BlKSB7XG4gICAgICAgICAgICB2YXIgY3R4ID0gY3VycmVudExheWVyLmN0eDtcbiAgICAgICAgICAgIHZhciBtID0gZWwudHJhbnNmb3JtO1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIChjdXJyZW50TGF5ZXIuX19kaXJ0eSB8fCBmb3JjZVBhaW50KVxuICAgICAgICAgICAgICAgIC8vIElnbm9yZSBpbnZpc2libGUgZWxlbWVudFxuICAgICAgICAgICAgICAgICYmICFlbC5pbnZpc2libGVcbiAgICAgICAgICAgICAgICAvLyBJZ25vcmUgdHJhbnNwYXJlbnQgZWxlbWVudFxuICAgICAgICAgICAgICAgICYmIGVsLnN0eWxlLm9wYWNpdHkgIT09IDBcbiAgICAgICAgICAgICAgICAvLyBJZ25vcmUgc2NhbGUgMCBlbGVtZW50LCBpbiBzb21lIGVudmlyb25tZW50IGxpa2Ugbm9kZS1jYW52YXNcbiAgICAgICAgICAgICAgICAvLyBEcmF3IGEgc2NhbGUgMCBlbGVtZW50IGNhbiBjYXVzZSBhbGwgZm9sbG93aW5nIGRyYXcgd3JvbmdcbiAgICAgICAgICAgICAgICAvLyBBbmQgc2V0VHJhbnNmb3JtIHdpdGggc2NhbGUgMCB3aWxsIGNhdXNlIHNldCBiYWNrIHRyYW5zZm9ybSBmYWlsZWQuXG4gICAgICAgICAgICAgICAgJiYgIShtICYmICFtWzBdICYmICFtWzNdKVxuICAgICAgICAgICAgICAgIC8vIElnbm9yZSBjdWxsZWQgZWxlbWVudFxuICAgICAgICAgICAgICAgICYmICEoZWwuY3VsbGluZyAmJiBpc0Rpc3BsYXlhYmxlQ3VsbGVkKGVsLCB0aGlzLl93aWR0aCwgdGhpcy5faGVpZ2h0KSlcbiAgICAgICAgICAgICkge1xuXG4gICAgICAgICAgICAgICAgdmFyIGNsaXBQYXRocyA9IGVsLl9fY2xpcFBhdGhzO1xuXG4gICAgICAgICAgICAgICAgLy8gT3B0aW1pemUgd2hlbiBjbGlwcGluZyBvbiBncm91cCB3aXRoIHNldmVyYWwgZWxlbWVudHNcbiAgICAgICAgICAgICAgICBpZiAoc2NvcGUucHJldkNsaXBMYXllciAhPT0gY3VycmVudExheWVyXG4gICAgICAgICAgICAgICAgICAgIHx8IGlzQ2xpcFBhdGhDaGFuZ2VkKGNsaXBQYXRocywgc2NvcGUucHJldkVsQ2xpcFBhdGhzKVxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiBoYXMgcHJldmlvdXMgY2xpcHBpbmcgc3RhdGUsIHJlc3RvcmUgZnJvbSBpdFxuICAgICAgICAgICAgICAgICAgICBpZiAoc2NvcGUucHJldkVsQ2xpcFBhdGhzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzY29wZS5wcmV2Q2xpcExheWVyLmN0eC5yZXN0b3JlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzY29wZS5wcmV2Q2xpcExheWVyID0gc2NvcGUucHJldkVsQ2xpcFBhdGhzID0gbnVsbDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVzZXQgcHJldkVsIHNpbmNlIGNvbnRleHQgaGFzIGJlZW4gcmVzdG9yZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlLnByZXZFbCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gTmV3IGNsaXBwaW5nIHN0YXRlXG4gICAgICAgICAgICAgICAgICAgIGlmIChjbGlwUGF0aHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb0NsaXAoY2xpcFBhdGhzLCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGUucHJldkNsaXBMYXllciA9IGN1cnJlbnRMYXllcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlLnByZXZFbENsaXBQYXRocyA9IGNsaXBQYXRocztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbC5iZWZvcmVCcnVzaCAmJiBlbC5iZWZvcmVCcnVzaChjdHgpO1xuXG4gICAgICAgICAgICAgICAgZWwuYnJ1c2goY3R4LCBzY29wZS5wcmV2RWwgfHwgbnVsbCk7XG4gICAgICAgICAgICAgICAgc2NvcGUucHJldkVsID0gZWw7XG5cbiAgICAgICAgICAgICAgICBlbC5hZnRlckJydXNoICYmIGVsLmFmdGVyQnJ1c2goY3R4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog6I635Y+WIHpsZXZlbCDmiYDlnKjlsYLvvIzlpoLmnpzkuI3lrZjlnKjliJnkvJrliJvlu7rkuIDkuKrmlrDnmoTlsYJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHpsZXZlbFxuICAgICAgICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9MYXllcn1cbiAgICAgICAgICovXG4gICAgICAgIGdldExheWVyOiBmdW5jdGlvbiAoemxldmVsKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fc2luZ2xlQ2FudmFzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xheWVyc1swXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGxheWVyID0gdGhpcy5fbGF5ZXJzW3psZXZlbF07XG4gICAgICAgICAgICBpZiAoIWxheWVyKSB7XG4gICAgICAgICAgICAgICAgLy8gQ3JlYXRlIGEgbmV3IGxheWVyXG4gICAgICAgICAgICAgICAgbGF5ZXIgPSBuZXcgTGF5ZXIoJ3pyXycgKyB6bGV2ZWwsIHRoaXMsIHRoaXMuZHByKTtcbiAgICAgICAgICAgICAgICBsYXllci5pc0J1aWxkaW4gPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2xheWVyQ29uZmlnW3psZXZlbF0pIHtcbiAgICAgICAgICAgICAgICAgICAgdXRpbC5tZXJnZShsYXllciwgdGhpcy5fbGF5ZXJDb25maWdbemxldmVsXSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5pbnNlcnRMYXllcih6bGV2ZWwsIGxheWVyKTtcblxuICAgICAgICAgICAgICAgIC8vIENvbnRleHQgaXMgY3JlYXRlZCBhZnRlciBkb20gaW5zZXJ0ZWQgdG8gZG9jdW1lbnRcbiAgICAgICAgICAgICAgICAvLyBPciBleGNhbnZhcyB3aWxsIGdldCAwcHggY2xpZW50V2lkdGggYW5kIGNsaWVudEhlaWdodFxuICAgICAgICAgICAgICAgIGxheWVyLmluaXRDb250ZXh0KCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBsYXllcjtcbiAgICAgICAgfSxcblxuICAgICAgICBpbnNlcnRMYXllcjogZnVuY3Rpb24gKHpsZXZlbCwgbGF5ZXIpIHtcblxuICAgICAgICAgICAgdmFyIGxheWVyc01hcCA9IHRoaXMuX2xheWVycztcbiAgICAgICAgICAgIHZhciB6bGV2ZWxMaXN0ID0gdGhpcy5femxldmVsTGlzdDtcbiAgICAgICAgICAgIHZhciBsZW4gPSB6bGV2ZWxMaXN0Lmxlbmd0aDtcbiAgICAgICAgICAgIHZhciBwcmV2TGF5ZXIgPSBudWxsO1xuICAgICAgICAgICAgdmFyIGkgPSAtMTtcbiAgICAgICAgICAgIHZhciBkb21Sb290ID0gdGhpcy5fZG9tUm9vdDtcblxuICAgICAgICAgICAgaWYgKGxheWVyc01hcFt6bGV2ZWxdKSB7XG4gICAgICAgICAgICAgICAgbG9nKCdaTGV2ZWwgJyArIHpsZXZlbCArICcgaGFzIGJlZW4gdXNlZCBhbHJlYWR5Jyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgaXMgYSB2YWxpZCBsYXllclxuICAgICAgICAgICAgaWYgKCFpc0xheWVyVmFsaWQobGF5ZXIpKSB7XG4gICAgICAgICAgICAgICAgbG9nKCdMYXllciBvZiB6bGV2ZWwgJyArIHpsZXZlbCArICcgaXMgbm90IHZhbGlkJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobGVuID4gMCAmJiB6bGV2ZWwgPiB6bGV2ZWxMaXN0WzBdKSB7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbiAtIDE7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgICB6bGV2ZWxMaXN0W2ldIDwgemxldmVsXG4gICAgICAgICAgICAgICAgICAgICAgICAmJiB6bGV2ZWxMaXN0W2kgKyAxXSA+IHpsZXZlbFxuICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHByZXZMYXllciA9IGxheWVyc01hcFt6bGV2ZWxMaXN0W2ldXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHpsZXZlbExpc3Quc3BsaWNlKGkgKyAxLCAwLCB6bGV2ZWwpO1xuXG4gICAgICAgICAgICBpZiAocHJldkxheWVyKSB7XG4gICAgICAgICAgICAgICAgdmFyIHByZXZEb20gPSBwcmV2TGF5ZXIuZG9tO1xuICAgICAgICAgICAgICAgIGlmIChwcmV2RG9tLm5leHRTaWJsaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIGRvbVJvb3QuaW5zZXJ0QmVmb3JlKFxuICAgICAgICAgICAgICAgICAgICAgICAgbGF5ZXIuZG9tLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJldkRvbS5uZXh0U2libGluZ1xuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZG9tUm9vdC5hcHBlbmRDaGlsZChsYXllci5kb20pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChkb21Sb290LmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgZG9tUm9vdC5pbnNlcnRCZWZvcmUobGF5ZXIuZG9tLCBkb21Sb290LmZpcnN0Q2hpbGQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZG9tUm9vdC5hcHBlbmRDaGlsZChsYXllci5kb20pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGF5ZXJzTWFwW3psZXZlbF0gPSBsYXllcjtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBJdGVyYXRlIGVhY2ggbGF5ZXJcbiAgICAgICAgZWFjaExheWVyOiBmdW5jdGlvbiAoY2IsIGNvbnRleHQpIHtcbiAgICAgICAgICAgIHZhciB6bGV2ZWxMaXN0ID0gdGhpcy5femxldmVsTGlzdDtcbiAgICAgICAgICAgIHZhciB6O1xuICAgICAgICAgICAgdmFyIGk7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgemxldmVsTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHogPSB6bGV2ZWxMaXN0W2ldO1xuICAgICAgICAgICAgICAgIGNiLmNhbGwoY29udGV4dCwgdGhpcy5fbGF5ZXJzW3pdLCB6KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvLyBJdGVyYXRlIGVhY2ggYnVpbGRpbiBsYXllclxuICAgICAgICBlYWNoQnVpbGRpbkxheWVyOiBmdW5jdGlvbiAoY2IsIGNvbnRleHQpIHtcbiAgICAgICAgICAgIHZhciB6bGV2ZWxMaXN0ID0gdGhpcy5femxldmVsTGlzdDtcbiAgICAgICAgICAgIHZhciBsYXllcjtcbiAgICAgICAgICAgIHZhciB6O1xuICAgICAgICAgICAgdmFyIGk7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgemxldmVsTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHogPSB6bGV2ZWxMaXN0W2ldO1xuICAgICAgICAgICAgICAgIGxheWVyID0gdGhpcy5fbGF5ZXJzW3pdO1xuICAgICAgICAgICAgICAgIGlmIChsYXllci5pc0J1aWxkaW4pIHtcbiAgICAgICAgICAgICAgICAgICAgY2IuY2FsbChjb250ZXh0LCBsYXllciwgeik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8vIEl0ZXJhdGUgZWFjaCBvdGhlciBsYXllciBleGNlcHQgYnVpbGRpbiBsYXllclxuICAgICAgICBlYWNoT3RoZXJMYXllcjogZnVuY3Rpb24gKGNiLCBjb250ZXh0KSB7XG4gICAgICAgICAgICB2YXIgemxldmVsTGlzdCA9IHRoaXMuX3psZXZlbExpc3Q7XG4gICAgICAgICAgICB2YXIgbGF5ZXI7XG4gICAgICAgICAgICB2YXIgejtcbiAgICAgICAgICAgIHZhciBpO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHpsZXZlbExpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB6ID0gemxldmVsTGlzdFtpXTtcbiAgICAgICAgICAgICAgICBsYXllciA9IHRoaXMuX2xheWVyc1t6XTtcbiAgICAgICAgICAgICAgICBpZiAoISBsYXllci5pc0J1aWxkaW4pIHtcbiAgICAgICAgICAgICAgICAgICAgY2IuY2FsbChjb250ZXh0LCBsYXllciwgeik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDojrflj5bmiYDmnInlt7LliJvlu7rnmoTlsYJcbiAgICAgICAgICogQHBhcmFtIHtBcnJheS48bW9kdWxlOnpyZW5kZXIvTGF5ZXI+fSBbcHJldkxheWVyXVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0TGF5ZXJzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbGF5ZXJzO1xuICAgICAgICB9LFxuXG4gICAgICAgIF91cGRhdGVMYXllclN0YXR1czogZnVuY3Rpb24gKGxpc3QpIHtcblxuICAgICAgICAgICAgdmFyIGxheWVycyA9IHRoaXMuX2xheWVycztcbiAgICAgICAgICAgIHZhciBwcm9ncmVzc2l2ZUxheWVycyA9IHRoaXMuX3Byb2dyZXNzaXZlTGF5ZXJzO1xuXG4gICAgICAgICAgICB2YXIgZWxDb3VudHNMYXN0RnJhbWUgPSB7fTtcbiAgICAgICAgICAgIHZhciBwcm9ncmVzc2l2ZUVsQ291bnRzTGFzdEZyYW1lID0ge307XG5cbiAgICAgICAgICAgIHRoaXMuZWFjaEJ1aWxkaW5MYXllcihmdW5jdGlvbiAobGF5ZXIsIHopIHtcbiAgICAgICAgICAgICAgICBlbENvdW50c0xhc3RGcmFtZVt6XSA9IGxheWVyLmVsQ291bnQ7XG4gICAgICAgICAgICAgICAgbGF5ZXIuZWxDb3VudCA9IDA7XG4gICAgICAgICAgICAgICAgbGF5ZXIuX19kaXJ0eSA9IGZhbHNlO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHV0aWwuZWFjaChwcm9ncmVzc2l2ZUxheWVycywgZnVuY3Rpb24gKGxheWVyLCBpZHgpIHtcbiAgICAgICAgICAgICAgICBwcm9ncmVzc2l2ZUVsQ291bnRzTGFzdEZyYW1lW2lkeF0gPSBsYXllci5lbENvdW50O1xuICAgICAgICAgICAgICAgIGxheWVyLmVsQ291bnQgPSAwO1xuICAgICAgICAgICAgICAgIGxheWVyLl9fZGlydHkgPSBmYWxzZTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB2YXIgcHJvZ3Jlc3NpdmVMYXllckNvdW50ID0gMDtcbiAgICAgICAgICAgIHZhciBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllcjtcbiAgICAgICAgICAgIHZhciBsYXN0UHJvZ3Jlc3NpdmVLZXk7XG4gICAgICAgICAgICB2YXIgZnJhbWVDb3VudCA9IDA7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGxpc3QubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVsID0gbGlzdFtpXTtcbiAgICAgICAgICAgICAgICB2YXIgemxldmVsID0gdGhpcy5fc2luZ2xlQ2FudmFzID8gMCA6IGVsLnpsZXZlbDtcbiAgICAgICAgICAgICAgICB2YXIgbGF5ZXIgPSBsYXllcnNbemxldmVsXTtcbiAgICAgICAgICAgICAgICB2YXIgZWxQcm9ncmVzcyA9IGVsLnByb2dyZXNzaXZlO1xuICAgICAgICAgICAgICAgIGlmIChsYXllcikge1xuICAgICAgICAgICAgICAgICAgICBsYXllci5lbENvdW50Kys7XG4gICAgICAgICAgICAgICAgICAgIGxheWVyLl9fZGlydHkgPSBsYXllci5fX2RpcnR5IHx8IGVsLl9fZGlydHk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8vLy8vLyBVcGRhdGUgcHJvZ3Jlc3NpdmVcbiAgICAgICAgICAgICAgICBpZiAoZWxQcm9ncmVzcyA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEZpeCB3cm9uZyBwcm9ncmVzc2l2ZSBzZXF1ZW5jZSBwcm9ibGVtLlxuICAgICAgICAgICAgICAgICAgICBpZiAobGFzdFByb2dyZXNzaXZlS2V5ICE9PSBlbFByb2dyZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0UHJvZ3Jlc3NpdmVLZXkgPSBlbFByb2dyZXNzO1xuICAgICAgICAgICAgICAgICAgICAgICAgZnJhbWVDb3VudCsrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBlbEZyYW1lID0gZWwuX19mcmFtZSA9IGZyYW1lQ291bnQgLSAxO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaWR4ID0gTWF0aC5taW4ocHJvZ3Jlc3NpdmVMYXllckNvdW50LCBNQVhfUFJPR1JFU1NJVkVfTEFZRVJfTlVNQkVSIC0gMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllciA9IHByb2dyZXNzaXZlTGF5ZXJzW2lkeF07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFByb2dyZXNzaXZlTGF5ZXIgPSBwcm9ncmVzc2l2ZUxheWVyc1tpZHhdID0gbmV3IExheWVyKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAncHJvZ3Jlc3NpdmUnLCB0aGlzLCB0aGlzLmRwclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFByb2dyZXNzaXZlTGF5ZXIuaW5pdENvbnRleHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyLl9fbWF4UHJvZ3Jlc3MgPSAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyLl9fZGlydHkgPSBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllci5fX2RpcnR5IHx8IGVsLl9fZGlydHk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyLmVsQ291bnQrKztcblxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllci5fX21heFByb2dyZXNzID0gTWF0aC5tYXgoXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllci5fX21heFByb2dyZXNzLCBlbEZyYW1lXG4gICAgICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyLl9fbWF4UHJvZ3Jlc3MgPj0gY3VycmVudFByb2dyZXNzaXZlTGF5ZXIuX19wcm9ncmVzcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2hvdWxkIGtlZXAgcmVuZGVyaW5nIHRoaXMgIGxheWVyIGJlY2F1c2UgcHJvZ3Jlc3NpdmUgcmVuZGVyaW5nIGlzIG5vdCBmaW5pc2hlZCB5ZXRcbiAgICAgICAgICAgICAgICAgICAgICAgIGxheWVyLl9fZGlydHkgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBlbC5fX2ZyYW1lID0gLTE7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllci5fX25leHRJZHhOb3RQcm9nID0gaTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2dyZXNzaXZlTGF5ZXJDb3VudCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFByb2dyZXNzaXZlTGF5ZXIgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoY3VycmVudFByb2dyZXNzaXZlTGF5ZXIpIHtcbiAgICAgICAgICAgICAgICBwcm9ncmVzc2l2ZUxheWVyQ291bnQrKztcbiAgICAgICAgICAgICAgICBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllci5fX25leHRJZHhOb3RQcm9nID0gaTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8g5bGC5Lit55qE5YWD57Sg5pWw6YeP5pyJ5Y+R55Sf5Y+Y5YyWXG4gICAgICAgICAgICB0aGlzLmVhY2hCdWlsZGluTGF5ZXIoZnVuY3Rpb24gKGxheWVyLCB6KSB7XG4gICAgICAgICAgICAgICAgaWYgKGVsQ291bnRzTGFzdEZyYW1lW3pdICE9PSBsYXllci5lbENvdW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGxheWVyLl9fZGlydHkgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBwcm9ncmVzc2l2ZUxheWVycy5sZW5ndGggPSBNYXRoLm1pbihwcm9ncmVzc2l2ZUxheWVyQ291bnQsIE1BWF9QUk9HUkVTU0lWRV9MQVlFUl9OVU1CRVIpO1xuICAgICAgICAgICAgdXRpbC5lYWNoKHByb2dyZXNzaXZlTGF5ZXJzLCBmdW5jdGlvbiAobGF5ZXIsIGlkeCkge1xuICAgICAgICAgICAgICAgIGlmIChwcm9ncmVzc2l2ZUVsQ291bnRzTGFzdEZyYW1lW2lkeF0gIT09IGxheWVyLmVsQ291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgZWwuX19kaXJ0eSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChsYXllci5fX2RpcnR5KSB7XG4gICAgICAgICAgICAgICAgICAgIGxheWVyLl9fcHJvZ3Jlc3MgPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmuIXpmaRob3ZlcuWxguWkluaJgOacieWGheWuuVxuICAgICAgICAgKi9cbiAgICAgICAgY2xlYXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuZWFjaEJ1aWxkaW5MYXllcih0aGlzLl9jbGVhckxheWVyKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9jbGVhckxheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcbiAgICAgICAgICAgIGxheWVyLmNsZWFyKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOS/ruaUueaMh+WumnpsZXZlbOeahOe7mOWItuWPguaVsFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gemxldmVsXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcg6YWN572u5a+56LGhXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY29uZmlnLmNsZWFyQ29sb3I9MF0g5q+P5qyh5riF56m655S75biD55qE6aKc6ImyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY29uZmlnLm1vdGlvbkJsdXI9ZmFsc2VdIOaYr+WQpuW8gOWQr+WKqOaAgeaooeezilxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2NvbmZpZy5sYXN0RnJhbWVBbHBoYT0wLjddXG4gICAgICAgICAqICAgICAgICAgICAgICAgICDlnKjlvIDlkK/liqjmgIHmqKHns4rnmoTml7blgJnkvb/nlKjvvIzkuI7kuIrkuIDluKfmt7flkIjnmoRhbHBoYeWAvO+8jOWAvOi2iuWkp+Wwvui/uei2iuaYjuaYvlxuICAgICAgICAgKi9cbiAgICAgICAgY29uZmlnTGF5ZXI6IGZ1bmN0aW9uICh6bGV2ZWwsIGNvbmZpZykge1xuICAgICAgICAgICAgaWYgKGNvbmZpZykge1xuICAgICAgICAgICAgICAgIHZhciBsYXllckNvbmZpZyA9IHRoaXMuX2xheWVyQ29uZmlnO1xuICAgICAgICAgICAgICAgIGlmICghbGF5ZXJDb25maWdbemxldmVsXSkge1xuICAgICAgICAgICAgICAgICAgICBsYXllckNvbmZpZ1t6bGV2ZWxdID0gY29uZmlnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdXRpbC5tZXJnZShsYXllckNvbmZpZ1t6bGV2ZWxdLCBjb25maWcsIHRydWUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBsYXllciA9IHRoaXMuX2xheWVyc1t6bGV2ZWxdO1xuXG4gICAgICAgICAgICAgICAgaWYgKGxheWVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHV0aWwubWVyZ2UobGF5ZXIsIGxheWVyQ29uZmlnW3psZXZlbF0sIHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5Yig6Zmk5oyH5a6a5bGCXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB6bGV2ZWwg5bGC5omA5Zyo55qEemxldmVsXG4gICAgICAgICAqL1xuICAgICAgICBkZWxMYXllcjogZnVuY3Rpb24gKHpsZXZlbCkge1xuICAgICAgICAgICAgdmFyIGxheWVycyA9IHRoaXMuX2xheWVycztcbiAgICAgICAgICAgIHZhciB6bGV2ZWxMaXN0ID0gdGhpcy5femxldmVsTGlzdDtcbiAgICAgICAgICAgIHZhciBsYXllciA9IGxheWVyc1t6bGV2ZWxdO1xuICAgICAgICAgICAgaWYgKCFsYXllcikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxheWVyLmRvbS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGxheWVyLmRvbSk7XG4gICAgICAgICAgICBkZWxldGUgbGF5ZXJzW3psZXZlbF07XG5cbiAgICAgICAgICAgIHpsZXZlbExpc3Quc3BsaWNlKHV0aWwuaW5kZXhPZih6bGV2ZWxMaXN0LCB6bGV2ZWwpLCAxKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5Yy65Z+f5aSn5bCP5Y+Y5YyW5ZCO6YeN57uYXG4gICAgICAgICAqL1xuICAgICAgICByZXNpemU6IGZ1bmN0aW9uICh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgICAgICB2YXIgZG9tUm9vdCA9IHRoaXMuX2RvbVJvb3Q7XG4gICAgICAgICAgICAvLyBGSVhNRSBXaHkgP1xuICAgICAgICAgICAgZG9tUm9vdC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuXG4gICAgICAgICAgICB3aWR0aCA9IHdpZHRoIHx8IHRoaXMuX2dldFdpZHRoKCk7XG4gICAgICAgICAgICBoZWlnaHQgPSBoZWlnaHQgfHwgdGhpcy5fZ2V0SGVpZ2h0KCk7XG5cbiAgICAgICAgICAgIGRvbVJvb3Quc3R5bGUuZGlzcGxheSA9ICcnO1xuXG4gICAgICAgICAgICAvLyDkvJjljJbmsqHmnInlrp7pmYXmlLnlj5jnmoRyZXNpemVcbiAgICAgICAgICAgIGlmICh0aGlzLl93aWR0aCAhPSB3aWR0aCB8fCBoZWlnaHQgIT0gdGhpcy5faGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgZG9tUm9vdC5zdHlsZS53aWR0aCA9IHdpZHRoICsgJ3B4JztcbiAgICAgICAgICAgICAgICBkb21Sb290LnN0eWxlLmhlaWdodCA9IGhlaWdodCArICdweCc7XG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpZCBpbiB0aGlzLl9sYXllcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbGF5ZXJzW2lkXS5yZXNpemUod2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5yZWZyZXNoKHRydWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl93aWR0aCA9IHdpZHRoO1xuICAgICAgICAgICAgdGhpcy5faGVpZ2h0ID0gaGVpZ2h0O1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5riF6Zmk5Y2V54us55qE5LiA5Liq5bGCXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB6bGV2ZWxcbiAgICAgICAgICovXG4gICAgICAgIGNsZWFyTGF5ZXI6IGZ1bmN0aW9uICh6bGV2ZWwpIHtcbiAgICAgICAgICAgIHZhciBsYXllciA9IHRoaXMuX2xheWVyc1t6bGV2ZWxdO1xuICAgICAgICAgICAgaWYgKGxheWVyKSB7XG4gICAgICAgICAgICAgICAgbGF5ZXIuY2xlYXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog6YeK5pS+XG4gICAgICAgICAqL1xuICAgICAgICBkaXNwb3NlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLnJvb3QuaW5uZXJIVE1MID0gJyc7XG5cbiAgICAgICAgICAgIHRoaXMucm9vdCA9XG4gICAgICAgICAgICB0aGlzLnN0b3JhZ2UgPVxuXG4gICAgICAgICAgICB0aGlzLl9kb21Sb290ID1cbiAgICAgICAgICAgIHRoaXMuX2xheWVycyA9IG51bGw7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCBjYW52YXMgd2hpY2ggaGFzIGFsbCB0aGluZyByZW5kZXJlZFxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuYmFja2dyb3VuZENvbG9yXVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0UmVuZGVyZWRDYW52YXM6IGZ1bmN0aW9uIChvcHRzKSB7XG4gICAgICAgICAgICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9zaW5nbGVDYW52YXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbGF5ZXJzWzBdLmRvbTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGltYWdlTGF5ZXIgPSBuZXcgTGF5ZXIoJ2ltYWdlJywgdGhpcywgb3B0cy5waXhlbFJhdGlvIHx8IHRoaXMuZHByKTtcbiAgICAgICAgICAgIGltYWdlTGF5ZXIuaW5pdENvbnRleHQoKTtcblxuICAgICAgICAgICAgaW1hZ2VMYXllci5jbGVhckNvbG9yID0gb3B0cy5iYWNrZ3JvdW5kQ29sb3I7XG4gICAgICAgICAgICBpbWFnZUxheWVyLmNsZWFyKCk7XG5cbiAgICAgICAgICAgIHZhciBkaXNwbGF5TGlzdCA9IHRoaXMuc3RvcmFnZS5nZXREaXNwbGF5TGlzdCh0cnVlKTtcblxuICAgICAgICAgICAgdmFyIHNjb3BlID0ge307XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpc3BsYXlMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVsID0gZGlzcGxheUxpc3RbaV07XG4gICAgICAgICAgICAgICAgdGhpcy5fZG9QYWludEVsKGVsLCBpbWFnZUxheWVyLCB0cnVlLCBzY29wZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBpbWFnZUxheWVyLmRvbTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOiOt+WPlue7mOWbvuWMuuWfn+WuveW6plxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0V2lkdGg6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl93aWR0aDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog6I635Y+W57uY5Zu+5Yy65Z+f6auY5bqmXG4gICAgICAgICAqL1xuICAgICAgICBnZXRIZWlnaHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9oZWlnaHQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2dldFdpZHRoOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcm9vdCA9IHRoaXMucm9vdDtcbiAgICAgICAgICAgIHZhciBzdGwgPSBkb2N1bWVudC5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKHJvb3QpO1xuXG4gICAgICAgICAgICAvLyBGSVhNRSBCZXR0ZXIgd2F5IHRvIGdldCB0aGUgd2lkdGggYW5kIGhlaWdodCB3aGVuIGVsZW1lbnQgaGFzIG5vdCBiZWVuIGFwcGVuZCB0byB0aGUgZG9jdW1lbnRcbiAgICAgICAgICAgIHJldHVybiAoKHJvb3QuY2xpZW50V2lkdGggfHwgcGFyc2VJbnQxMChzdGwud2lkdGgpIHx8IHBhcnNlSW50MTAocm9vdC5zdHlsZS53aWR0aCkpXG4gICAgICAgICAgICAgICAgICAgIC0gKHBhcnNlSW50MTAoc3RsLnBhZGRpbmdMZWZ0KSB8fCAwKVxuICAgICAgICAgICAgICAgICAgICAtIChwYXJzZUludDEwKHN0bC5wYWRkaW5nUmlnaHQpIHx8IDApKSB8IDA7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2dldEhlaWdodDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHJvb3QgPSB0aGlzLnJvb3Q7XG4gICAgICAgICAgICB2YXIgc3RsID0gZG9jdW1lbnQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZShyb290KTtcblxuICAgICAgICAgICAgcmV0dXJuICgocm9vdC5jbGllbnRIZWlnaHQgfHwgcGFyc2VJbnQxMChzdGwuaGVpZ2h0KSB8fCBwYXJzZUludDEwKHJvb3Quc3R5bGUuaGVpZ2h0KSlcbiAgICAgICAgICAgICAgICAgICAgLSAocGFyc2VJbnQxMChzdGwucGFkZGluZ1RvcCkgfHwgMClcbiAgICAgICAgICAgICAgICAgICAgLSAocGFyc2VJbnQxMChzdGwucGFkZGluZ0JvdHRvbSkgfHwgMCkpIHwgMDtcbiAgICAgICAgfSxcblxuICAgICAgICBfcGF0aFRvSW1hZ2U6IGZ1bmN0aW9uIChpZCwgcGF0aCwgd2lkdGgsIGhlaWdodCwgZHByKSB7XG4gICAgICAgICAgICB2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgICAgICB2YXIgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG5cbiAgICAgICAgICAgIGNhbnZhcy53aWR0aCA9IHdpZHRoICogZHByO1xuICAgICAgICAgICAgY2FudmFzLmhlaWdodCA9IGhlaWdodCAqIGRwcjtcblxuICAgICAgICAgICAgY3R4LmNsZWFyUmVjdCgwLCAwLCB3aWR0aCAqIGRwciwgaGVpZ2h0ICogZHByKTtcblxuICAgICAgICAgICAgdmFyIHBhdGhUcmFuc2Zvcm0gPSB7XG4gICAgICAgICAgICAgICAgcG9zaXRpb246IHBhdGgucG9zaXRpb24sXG4gICAgICAgICAgICAgICAgcm90YXRpb246IHBhdGgucm90YXRpb24sXG4gICAgICAgICAgICAgICAgc2NhbGU6IHBhdGguc2NhbGVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBwYXRoLnBvc2l0aW9uID0gWzAsIDAsIDBdO1xuICAgICAgICAgICAgcGF0aC5yb3RhdGlvbiA9IDA7XG4gICAgICAgICAgICBwYXRoLnNjYWxlID0gWzEsIDFdO1xuICAgICAgICAgICAgaWYgKHBhdGgpIHtcbiAgICAgICAgICAgICAgICBwYXRoLmJydXNoKGN0eCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBJbWFnZVNoYXBlID0gcmVxdWlyZSgnLi9ncmFwaGljL0ltYWdlJyk7XG4gICAgICAgICAgICB2YXIgaW1nU2hhcGUgPSBuZXcgSW1hZ2VTaGFwZSh7XG4gICAgICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICAgICAgICAgIHk6IDAsXG4gICAgICAgICAgICAgICAgICAgIGltYWdlOiBjYW52YXNcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKHBhdGhUcmFuc2Zvcm0ucG9zaXRpb24gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGltZ1NoYXBlLnBvc2l0aW9uID0gcGF0aC5wb3NpdGlvbiA9IHBhdGhUcmFuc2Zvcm0ucG9zaXRpb247XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChwYXRoVHJhbnNmb3JtLnJvdGF0aW9uICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpbWdTaGFwZS5yb3RhdGlvbiA9IHBhdGgucm90YXRpb24gPSBwYXRoVHJhbnNmb3JtLnJvdGF0aW9uO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocGF0aFRyYW5zZm9ybS5zY2FsZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaW1nU2hhcGUuc2NhbGUgPSBwYXRoLnNjYWxlID0gcGF0aFRyYW5zZm9ybS5zY2FsZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGltZ1NoYXBlO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9jcmVhdGVQYXRoVG9JbWFnZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG1lID0gdGhpcztcblxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChpZCwgZSwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtZS5fcGF0aFRvSW1hZ2UoXG4gICAgICAgICAgICAgICAgICAgIGlkLCBlLCB3aWR0aCwgaGVpZ2h0LCBtZS5kcHJcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IFBhaW50ZXI7XG5cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3pyZW5kZXIvbGliL1BhaW50ZXIuanNcbiAqKiBtb2R1bGUgaWQgPSA2OVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBAbW9kdWxlIHpyZW5kZXIvTGF5ZXJcbiAqIEBhdXRob3IgcGlzc2FuZyhodHRwczovL3d3dy5naXRodWIuY29tL3Bpc3NhbmcpXG4gKi9cblxuXG4gICAgdmFyIHV0aWwgPSByZXF1aXJlKCcuL2NvcmUvdXRpbCcpO1xuICAgIHZhciBjb25maWcgPSByZXF1aXJlKCcuL2NvbmZpZycpO1xuICAgIHZhciBTdHlsZSA9IHJlcXVpcmUoJy4vZ3JhcGhpYy9TdHlsZScpO1xuICAgIHZhciBQYXR0ZXJuID0gcmVxdWlyZSgnLi9ncmFwaGljL1BhdHRlcm4nKTtcblxuICAgIGZ1bmN0aW9uIHJldHVybkZhbHNlKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog5Yib5bu6ZG9tXG4gICAgICpcbiAgICAgKiBAaW5uZXJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgZG9tIGlkIOW+heeUqFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIGRvbSB0eXBl77yMc3VjaCBhcyBjYW52YXMsIGRpdiBldGMuXG4gICAgICogQHBhcmFtIHtQYWludGVyfSBwYWludGVyIHBhaW50ZXIgaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbnVtYmVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlRG9tKGlkLCB0eXBlLCBwYWludGVyLCBkcHIpIHtcbiAgICAgICAgdmFyIG5ld0RvbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodHlwZSk7XG4gICAgICAgIHZhciB3aWR0aCA9IHBhaW50ZXIuZ2V0V2lkdGgoKTtcbiAgICAgICAgdmFyIGhlaWdodCA9IHBhaW50ZXIuZ2V0SGVpZ2h0KCk7XG5cbiAgICAgICAgdmFyIG5ld0RvbVN0eWxlID0gbmV3RG9tLnN0eWxlO1xuICAgICAgICAvLyDmsqFhcHBlbmTlkaLvvIzor7fljp/osIXmiJHov5nmoLflhpnvvIzmuIXmmbB+XG4gICAgICAgIG5ld0RvbVN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgICAgbmV3RG9tU3R5bGUubGVmdCA9IDA7XG4gICAgICAgIG5ld0RvbVN0eWxlLnRvcCA9IDA7XG4gICAgICAgIG5ld0RvbVN0eWxlLndpZHRoID0gd2lkdGggKyAncHgnO1xuICAgICAgICBuZXdEb21TdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyAncHgnO1xuICAgICAgICBuZXdEb20ud2lkdGggPSB3aWR0aCAqIGRwcjtcbiAgICAgICAgbmV3RG9tLmhlaWdodCA9IGhlaWdodCAqIGRwcjtcblxuICAgICAgICAvLyBpZOS4jeS9nOS4uue0ouW8leeUqO+8jOmBv+WFjeWPr+iDvemAoOaIkOeahOmHjeWQje+8jOWumuS5ieS4uuengeacieWxnuaAp1xuICAgICAgICBuZXdEb20uc2V0QXR0cmlidXRlKCdkYXRhLXpyLWRvbS1pZCcsIGlkKTtcbiAgICAgICAgcmV0dXJuIG5ld0RvbTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAYWxpYXMgbW9kdWxlOnpyZW5kZXIvTGF5ZXJcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAZXh0ZW5kcyBtb2R1bGU6enJlbmRlci9taXhpbi9UcmFuc2Zvcm1hYmxlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGlkXG4gICAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9QYWludGVyfSBwYWludGVyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtkcHJdXG4gICAgICovXG4gICAgdmFyIExheWVyID0gZnVuY3Rpb24oaWQsIHBhaW50ZXIsIGRwcikge1xuICAgICAgICB2YXIgZG9tO1xuICAgICAgICBkcHIgPSBkcHIgfHwgY29uZmlnLmRldmljZVBpeGVsUmF0aW87XG4gICAgICAgIGlmICh0eXBlb2YgaWQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBkb20gPSBjcmVhdGVEb20oaWQsICdjYW52YXMnLCBwYWludGVyLCBkcHIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5vdCB1c2luZyBpc0RvbSBiZWNhdXNlIGluIG5vZGUgaXQgd2lsbCByZXR1cm4gZmFsc2VcbiAgICAgICAgZWxzZSBpZiAodXRpbC5pc09iamVjdChpZCkpIHtcbiAgICAgICAgICAgIGRvbSA9IGlkO1xuICAgICAgICAgICAgaWQgPSBkb20uaWQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pZCA9IGlkO1xuICAgICAgICB0aGlzLmRvbSA9IGRvbTtcblxuICAgICAgICB2YXIgZG9tU3R5bGUgPSBkb20uc3R5bGU7XG4gICAgICAgIGlmIChkb21TdHlsZSkgeyAvLyBOb3QgaW4gbm9kZVxuICAgICAgICAgICAgZG9tLm9uc2VsZWN0c3RhcnQgPSByZXR1cm5GYWxzZTsgLy8g6YG/5YWN6aG16Z2i6YCJ5Lit55qE5bC05bCsXG4gICAgICAgICAgICBkb21TdHlsZVsnLXdlYmtpdC11c2VyLXNlbGVjdCddID0gJ25vbmUnO1xuICAgICAgICAgICAgZG9tU3R5bGVbJ3VzZXItc2VsZWN0J10gPSAnbm9uZSc7XG4gICAgICAgICAgICBkb21TdHlsZVsnLXdlYmtpdC10b3VjaC1jYWxsb3V0J10gPSAnbm9uZSc7XG4gICAgICAgICAgICBkb21TdHlsZVsnLXdlYmtpdC10YXAtaGlnaGxpZ2h0LWNvbG9yJ10gPSAncmdiYSgwLDAsMCwwKSc7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmRvbUJhY2sgPSBudWxsO1xuICAgICAgICB0aGlzLmN0eEJhY2sgPSBudWxsO1xuXG4gICAgICAgIHRoaXMucGFpbnRlciA9IHBhaW50ZXI7XG5cbiAgICAgICAgdGhpcy5jb25maWcgPSBudWxsO1xuXG4gICAgICAgIC8vIENvbmZpZ3NcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOavj+asoea4heepuueUu+W4g+eahOminOiJslxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKiBAZGVmYXVsdCAwXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNsZWFyQ29sb3IgPSAwO1xuICAgICAgICAvKipcbiAgICAgICAgICog5piv5ZCm5byA5ZCv5Yqo5oCB5qih57OKXG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5tb3Rpb25CbHVyID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlnKjlvIDlkK/liqjmgIHmqKHns4rnmoTml7blgJnkvb/nlKjvvIzkuI7kuIrkuIDluKfmt7flkIjnmoRhbHBoYeWAvO+8jOWAvOi2iuWkp+Wwvui/uei2iuaYjuaYvlxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKiBAZGVmYXVsdCAwLjdcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubGFzdEZyYW1lQWxwaGEgPSAwLjc7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIExheWVyIGRwclxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kcHIgPSBkcHI7XG4gICAgfTtcblxuICAgIExheWVyLnByb3RvdHlwZSA9IHtcblxuICAgICAgICBjb25zdHJ1Y3RvcjogTGF5ZXIsXG5cbiAgICAgICAgZWxDb3VudDogMCxcblxuICAgICAgICBfX2RpcnR5OiB0cnVlLFxuXG4gICAgICAgIGluaXRDb250ZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLmN0eCA9IHRoaXMuZG9tLmdldENvbnRleHQoJzJkJyk7XG5cbiAgICAgICAgICAgIHRoaXMuY3R4LmRwciA9IHRoaXMuZHByO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNyZWF0ZUJhY2tCdWZmZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBkcHIgPSB0aGlzLmRwcjtcblxuICAgICAgICAgICAgdGhpcy5kb21CYWNrID0gY3JlYXRlRG9tKCdiYWNrLScgKyB0aGlzLmlkLCAnY2FudmFzJywgdGhpcy5wYWludGVyLCBkcHIpO1xuICAgICAgICAgICAgdGhpcy5jdHhCYWNrID0gdGhpcy5kb21CYWNrLmdldENvbnRleHQoJzJkJyk7XG5cbiAgICAgICAgICAgIGlmIChkcHIgIT0gMSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY3R4QmFjay5zY2FsZShkcHIsIGRwcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gd2lkdGhcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSBoZWlnaHRcbiAgICAgICAgICovXG4gICAgICAgIHJlc2l6ZTogZnVuY3Rpb24gKHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgICAgIHZhciBkcHIgPSB0aGlzLmRwcjtcblxuICAgICAgICAgICAgdmFyIGRvbSA9IHRoaXMuZG9tO1xuICAgICAgICAgICAgdmFyIGRvbVN0eWxlID0gZG9tLnN0eWxlO1xuICAgICAgICAgICAgdmFyIGRvbUJhY2sgPSB0aGlzLmRvbUJhY2s7XG5cbiAgICAgICAgICAgIGRvbVN0eWxlLndpZHRoID0gd2lkdGggKyAncHgnO1xuICAgICAgICAgICAgZG9tU3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgJ3B4JztcblxuICAgICAgICAgICAgZG9tLndpZHRoID0gd2lkdGggKiBkcHI7XG4gICAgICAgICAgICBkb20uaGVpZ2h0ID0gaGVpZ2h0ICogZHByO1xuXG4gICAgICAgICAgICBpZiAoZG9tQmFjaykge1xuICAgICAgICAgICAgICAgIGRvbUJhY2sud2lkdGggPSB3aWR0aCAqIGRwcjtcbiAgICAgICAgICAgICAgICBkb21CYWNrLmhlaWdodCA9IGhlaWdodCAqIGRwcjtcblxuICAgICAgICAgICAgICAgIGlmIChkcHIgIT0gMSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmN0eEJhY2suc2NhbGUoZHByLCBkcHIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5riF56m66K+l5bGC55S75biDXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gY2xlYXJBbGwgQ2xlYXIgYWxsIHdpdGggb3V0IG1vdGlvbiBibHVyXG4gICAgICAgICAqL1xuICAgICAgICBjbGVhcjogZnVuY3Rpb24gKGNsZWFyQWxsKSB7XG4gICAgICAgICAgICB2YXIgZG9tID0gdGhpcy5kb207XG4gICAgICAgICAgICB2YXIgY3R4ID0gdGhpcy5jdHg7XG4gICAgICAgICAgICB2YXIgd2lkdGggPSBkb20ud2lkdGg7XG4gICAgICAgICAgICB2YXIgaGVpZ2h0ID0gZG9tLmhlaWdodDtcblxuICAgICAgICAgICAgdmFyIGNsZWFyQ29sb3IgPSB0aGlzLmNsZWFyQ29sb3I7XG4gICAgICAgICAgICB2YXIgaGF2ZU1vdGlvbkJMdXIgPSB0aGlzLm1vdGlvbkJsdXIgJiYgIWNsZWFyQWxsO1xuICAgICAgICAgICAgdmFyIGxhc3RGcmFtZUFscGhhID0gdGhpcy5sYXN0RnJhbWVBbHBoYTtcblxuICAgICAgICAgICAgdmFyIGRwciA9IHRoaXMuZHByO1xuXG4gICAgICAgICAgICBpZiAoaGF2ZU1vdGlvbkJMdXIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuZG9tQmFjaykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNyZWF0ZUJhY2tCdWZmZXIoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLmN0eEJhY2suZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gJ2NvcHknO1xuICAgICAgICAgICAgICAgIHRoaXMuY3R4QmFjay5kcmF3SW1hZ2UoXG4gICAgICAgICAgICAgICAgICAgIGRvbSwgMCwgMCxcbiAgICAgICAgICAgICAgICAgICAgd2lkdGggLyBkcHIsXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodCAvIGRwclxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgICBpZiAoY2xlYXJDb2xvcikge1xuICAgICAgICAgICAgICAgIHZhciBjbGVhckNvbG9yR3JhZGllbnRPclBhdHRlcm47XG4gICAgICAgICAgICAgICAgLy8gR3JhZGllbnRcbiAgICAgICAgICAgICAgICBpZiAoY2xlYXJDb2xvci5jb2xvclN0b3BzKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIENhY2hlIGNhbnZhcyBncmFkaWVudFxuICAgICAgICAgICAgICAgICAgICBjbGVhckNvbG9yR3JhZGllbnRPclBhdHRlcm4gPSBjbGVhckNvbG9yLl9fY2FudmFzR3JhZGllbnQgfHwgU3R5bGUuZ2V0R3JhZGllbnQoY3R4LCBjbGVhckNvbG9yLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgeTogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIGNsZWFyQ29sb3IuX19jYW52YXNHcmFkaWVudCA9IGNsZWFyQ29sb3JHcmFkaWVudE9yUGF0dGVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gUGF0dGVyblxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNsZWFyQ29sb3IuaW1hZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJDb2xvckdyYWRpZW50T3JQYXR0ZXJuID0gUGF0dGVybi5wcm90b3R5cGUuZ2V0Q2FudmFzUGF0dGVybi5jYWxsKGNsZWFyQ29sb3IsIGN0eCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGNsZWFyQ29sb3JHcmFkaWVudE9yUGF0dGVybiB8fCBjbGVhckNvbG9yO1xuICAgICAgICAgICAgICAgIGN0eC5maWxsUmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaGF2ZU1vdGlvbkJMdXIpIHtcbiAgICAgICAgICAgICAgICB2YXIgZG9tQmFjayA9IHRoaXMuZG9tQmFjaztcbiAgICAgICAgICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICAgICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IGxhc3RGcmFtZUFscGhhO1xuICAgICAgICAgICAgICAgIGN0eC5kcmF3SW1hZ2UoZG9tQmFjaywgMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IExheWVyO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34venJlbmRlci9saWIvTGF5ZXIuanNcbiAqKiBtb2R1bGUgaWQgPSA3MFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXHJcbiAqIOW3peWFt+aWueazleexu1xyXG4gKiBAYXV0aG9yIHdhbmcueGlhb2h1XHJcbiAqL1xyXG5cclxuICAgIHZhciBQb2ludCA9IHJlcXVpcmUoXCIuL1BvaW50LmpzXCIpO1xyXG4gICAgdmFyIExpbmUgPSByZXF1aXJlKFwiLi9MaW5lU3RydWN0LmpzXCIpO1xyXG4gICAgdmFyIGdyYXBoaWMgPSByZXF1aXJlKFwiLi9ncmFwaGljLmpzXCIpO1xyXG4gICAgdmFyIEJvdW5kaW5nUmVjdCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvQm91bmRpbmdSZWN0Jyk7XHJcbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XHJcbiAgICAvKipcclxuICAgICAqIOaehOmAoOexu+e7p+aJv+WFs+ezu1xyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNsYXp6IOa6kOexu1xyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gYmFzZUNsYXp6IOWfuuexu1xyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBpbmhlcml0cyhjbGF6eiwgYmFzZUNsYXp6KSB7XHJcbiAgICAgICAgdmFyIGNsYXp6UHJvdG90eXBlID0gY2xhenoucHJvdG90eXBlO1xyXG5cclxuICAgICAgICBmdW5jdGlvbiBGKCkge31cclxuICAgICAgICBGLnByb3RvdHlwZSA9IGJhc2VDbGF6ei5wcm90b3R5cGU7XHJcbiAgICAgICAgY2xhenoucHJvdG90eXBlID0gbmV3IEYoKTtcclxuXHJcbiAgICAgICAgZm9yICh2YXIgcHJvcCBpbiBjbGF6elByb3RvdHlwZSkge1xyXG4gICAgICAgICAgICBjbGF6ei5wcm90b3R5cGVbcHJvcF0gPSBjbGF6elByb3RvdHlwZVtwcm9wXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2xhenoucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY2xheno7XHJcbiAgICAgICAgY2xhenouc3VwZXJDbGFzcyA9IGJhc2VDbGF6ejtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBnZXRVVUlEKCkge1xyXG4gICAgICAgIHZhciBjaGFycyA9ICcwMTIzNDU2Nzg5QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5eicuc3BsaXQoJycpLFxyXG4gICAgICAgICAgICB1dWlkID0gbmV3IEFycmF5KDM2KSxcclxuICAgICAgICAgICAgcm5kID0gMCxcclxuICAgICAgICAgICAgcjtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDM2OyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKGkgPT0gOCB8fCBpID09IDEzIHx8IGkgPT0gMTggfHwgaSA9PSAyMykge1xyXG4gICAgICAgICAgICAgICAgdXVpZFtpXSA9ICctJztcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChpID09IDE0KSB7XHJcbiAgICAgICAgICAgICAgICB1dWlkW2ldID0gJzQnO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKHJuZCA8PSAweDAyKSBybmQgPSAweDIwMDAwMDAgKyAoTWF0aC5yYW5kb20oKSAqIDB4MTAwMDAwMCkgfCAwO1xyXG4gICAgICAgICAgICAgICAgciA9IHJuZCAmIDB4ZjtcclxuICAgICAgICAgICAgICAgIHJuZCA9IHJuZCA+PiA0O1xyXG4gICAgICAgICAgICAgICAgdXVpZFtpXSA9IGNoYXJzWyhpID09IDE5KSA/IChyICYgMHgzKSB8IDB4OCA6IHJdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBcInNpZC1cIiArIHV1aWQuam9pbignJyk7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICog6K6h566X5Lik54K55LmL6Ze055qE6Led56a7XHJcbiAgICAgKkBwYXJhbSB7UG9pbnR9IHAxIC0gZmlyc3Qge1BvaW50fVxyXG4gICAgICpAcGFyYW0ge1BvaW50fSBwMiAtIHNlY29uZCB7UG9pbnR9XHJcbiAgICAgKkByZXR1cm4ge051bWJlcn0gLSB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0aG9zZSAyIHBvaW50cy4gSXQgaXMgYWx3YXlzIHBvc2l0aXZlLlxyXG4gICAgICoqL1xyXG4gICAgZnVuY3Rpb24gZGlzdGFuY2UocDEsIHAyKSB7XHJcbiAgICAgICAgcmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyhwMS54IC0gcDIueCwgMikgKyBNYXRoLnBvdyhwMS55IC0gcDIueSwgMikpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog6L+U5Zue5LiA5p2h5oqY57q/IOacgOmVv+eahOS4pOS4queCuVxyXG4gICAgICogQHBhcmFtICB7W3R5cGVdfSBwb2ludHMgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICogQHJldHVybiB7W3R5cGVdfSAgICAgICAgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBnZXRNYXhMaW5lTGVuZ3RoKHBvaW50cykge1xyXG4gICAgICAgIHZhciBtID0gZGlzdGFuY2UocG9pbnRzWzBdLCBwb2ludHNbMV0pO1xyXG4gICAgICAgIHZhciByZXN1bHQgPSBbcG9pbnRzWzBdLCBwb2ludHNbMV1dO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgcG9pbnRzLmxlbmd0aCAtIDE7IGkrKykge1xyXG5cclxuICAgICAgICAgICAgaWYgKG0gPCBkaXN0YW5jZShwb2ludHNbaV0sIHBvaW50c1tpICsgMV0pKSB7XHJcbiAgICAgICAgICAgICAgICBtID0gZGlzdGFuY2UocG9pbnRzW2ldLCBwb2ludHNbaSArIDFdKVxyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gW3BvaW50c1tpXSwgcG9pbnRzW2kgKyAxXV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqUmV0dXJucyB0aGUgbGVuZ3RoIG9mIGEgUG9seWxpbmUgdGhhdCB3b3VsZCBiZSBjcmVhdGVkIHdpdGggYSBzZXQgb2YgcG9pbnRzXHJcbiAgICAgKkBwYXJhbSB7QXJyYXl9IHYgLSBhbiB7QXJyYXl9IG9mIHtQb2ludHN9XHJcbiAgICAgKkByZXR1cm4ge051bWJlcn0gLSBhIHBvc2l0aXZlIG51bWJlciBlcXVhbCB3aXRoIHRvdGFsIGxlbmd0aCovXHJcbiAgICBmdW5jdGlvbiBnZXRQb2x5bGluZUxlbmd0aCh2KSB7XHJcbiAgICAgICAgdmFyIGwgPSAwO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdi5sZW5ndGggLSAxOyBpKyspIHtcclxuICAgICAgICAgICAgbCArPSBkaXN0YW5jZSh2W2ldLCB2W2kgKyAxXSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gbDtcclxuICAgIH1cclxuXHJcblxyXG4gICAgLyoqUmV0dXJucyB0aGUgbWF4IG9mIGEgdmVjdG9yXHJcbiAgICAgKkBwYXJhbSB7QXJyYXl9IHYgLSB2ZWN0b3Igb2Yge051bWJlcn1zXHJcbiAgICAgKkByZXR1cm4ge051bWJlcn0gLSB0aGUgbWF4aW11bSBudW1iZXIgZnJvbSB0aGUgdmVjdG9yIG9yIE5hTiBpZiB2ZWN0b3IgaXMgZW1wdHlcclxuICAgICAqKi9cclxuICAgIGZ1bmN0aW9uIG1heCh2KSB7XHJcbiAgICAgICAgaWYgKHYubGVuZ2h0ID09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIE5hTjtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB2YXIgbSA9IHZbMF07XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKG0gPCB2W2ldKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbSA9IHZbaV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBtO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcblxyXG4gICAgLyoqUmV0dXJucyB0aGUgbWluIG9mIGEgdmVjdG9yXHJcbiAgICAgKkBwYXJhbSB7QXJyYXl9IHYgLSB2ZWN0b3Igb2Yge051bWJlcn1zXHJcbiAgICAgKkByZXR1cm4ge051bWJlcn0gLSB0aGUgbWluaW11bSBudW1iZXIgZnJvbSB0aGUgdmVjdG9yIG9yIE5hTiBpZiB2ZWN0b3IgaXMgZW1wdHlcclxuICAgICAqQGF1dGhvciBhbGV4QHNjcmlwdG9pZC5jb21cclxuICAgICAqKi9cclxuICAgIGZ1bmN0aW9uIG1pbih2KSB7XHJcbiAgICAgICAgaWYgKHYubGVuZ2h0ID09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIE5hTjtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB2YXIgbSA9IHZbMF07XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKG0gPiB2W2ldKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbSA9IHZbaV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBtO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOWIpOaWrSDngrnmlbDnu4Qg5piv5ZCm5q2j5Lqk55u057q/6Lev5b6EXHJcbiAgICAgKlRlc3RzIGlmIGEgdmVjdG9yIG9mIHBvaW50cyBpcyBhbiBvcnRob2dvbmFsIHBhdGggKG1vdmluZyBpbiBtdWx0aXBsZXMgb2YgOTAgZGVncmVlcylcclxuICAgICAqQHBhcmFtIHtBcnJheX0gdiAtIGFuIHtBcnJheX0gb2Yge1BvaW50fXNcclxuICAgICAqQHJldHVybiB7Qm9vbGVhbn0gLSB0cnVlIGlmIHBhdGggaXMgdmFsaWQsIGZhbHNlIG90aGVyd2lzZVxyXG4gICAgICoqL1xyXG4gICAgZnVuY3Rpb24gb3J0aG9nb25hbFBhdGgodikge1xyXG4gICAgICAgIGlmICh2Lmxlbmd0aCA8PSAxKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2Lmxlbmd0aCAtIDE7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAodltpXS54ICE9IHZbaSArIDFdLnggJiYgdltpXS55ICE9IHZbaSArIDFdLnkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICpUZXN0IHRvIHNlZSBpZiAyIHtMaW5lfXMgaW50ZXJzZWN0cy4gVGhleSBhcmUgY29uc2lkZXJlZCBmaW5pdGUgc2VnbWVudHNcclxuICAgICAqYW5kIG5vdCB0aGUgaW5maW5pdGUgbGluZXMgZnJvbSBnZW9tZXRyeVxyXG4gICAgICpAcGFyYW0ge0xpbmV9IGwxIC0gZmlzdCBsaW5lL3NlZ21lbnRcclxuICAgICAqQHBhcmFtIHtMaW5lfSBsMiAtIGxhc3QgbGluZS9zZWdtZW50XHJcbiAgICAgKkByZXR1cm4ge0Jvb2xlYW59IHRydWUgLSBpZiB0aGUgbGluZXMgaW50ZXJzZWN0IG9yIGZhbHNlIGlmIG5vdFxyXG4gICAgICoqL1xyXG4gICAgZnVuY3Rpb24gbGluZUludGVyc2VjdHNMaW5lKGwxLCBsMikge1xyXG4gICAgICAgIC8vIGNoZWNrIGZvciB0d28gdmVydGljYWwgbGluZXNcclxuICAgICAgICBpZiAobDEuc3RhcnRQb2ludC54ID09IGwxLmVuZFBvaW50LnggJiYgbDIuc3RhcnRQb2ludC54ID09IGwyLmVuZFBvaW50LngpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGwxLnN0YXJ0UG9pbnQueCA9PSBsMi5zdGFydFBvaW50LnggPyAvLyBpZiAnaW5maW5pdGUgJ2xpbmVzIGRvIGNvaW5jaWRlLFxyXG4gICAgICAgICAgICAgICAgLy8gdGhlbiBjaGVjayBzZWdtZW50IGJvdW5kcyBmb3Igb3ZlcmxhcHBpbmdcclxuICAgICAgICAgICAgICAgIGwxLmNvbnRhaW5zKGwyLnN0YXJ0UG9pbnQueCwgbDIuc3RhcnRQb2ludC55KSB8fFxyXG4gICAgICAgICAgICAgICAgbDEuY29udGFpbnMobDIuZW5kUG9pbnQueCwgbDIuZW5kUG9pbnQueSkgOlxyXG4gICAgICAgICAgICAgICAgLy8gbGluZXMgYXJlIHBhcmFsZWxcclxuICAgICAgICAgICAgICAgIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBpZiBvbmUgbGluZSBpcyB2ZXJ0aWNhbCwgYW5kIGFub3RoZXIgbGluZSBpcyBub3QgdmVydGljYWxcclxuICAgICAgICBlbHNlIGlmIChsMS5zdGFydFBvaW50LnggPT0gbDEuZW5kUG9pbnQueCB8fCBsMi5zdGFydFBvaW50LnggPT0gbDIuZW5kUG9pbnQueCkge1xyXG4gICAgICAgICAgICAvLyBsZXQgYXNzdW1lIGwyIGlzIHZlcnRpY2FsLCBvdGhlcndpc2UgZXhjaGFuZ2UgdGhlbVxyXG4gICAgICAgICAgICBpZiAobDEuc3RhcnRQb2ludC54ID09IGwxLmVuZFBvaW50LngpIHtcclxuICAgICAgICAgICAgICAgIHZhciBsID0gbDE7XHJcbiAgICAgICAgICAgICAgICBsMSA9IGwyO1xyXG4gICAgICAgICAgICAgICAgbDIgPSBsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGZpbmRpbmcgaW50ZXJzZWN0aW9uIG9mICdpbmZpbml0ZScgbGluZXNcclxuICAgICAgICAgICAgLy8gZXF1YXRpb24gb2YgdGhlIGZpcnN0IGxpbmUgaXMgeSA9IGF4ICsgYiwgc2Vjb25kOiB4ID0gY1xyXG4gICAgICAgICAgICB2YXIgYSA9IChsMS5lbmRQb2ludC55IC0gbDEuc3RhcnRQb2ludC55KSAvIChsMS5lbmRQb2ludC54IC0gbDEuc3RhcnRQb2ludC54KTtcclxuICAgICAgICAgICAgdmFyIGIgPSBsMS5zdGFydFBvaW50LnkgLSBhICogbDEuc3RhcnRQb2ludC54O1xyXG4gICAgICAgICAgICB2YXIgeDAgPSBsMi5zdGFydFBvaW50Lng7XHJcbiAgICAgICAgICAgIHZhciB5MCA9IGEgKiB4MCArIGI7XHJcbiAgICAgICAgICAgIHJldHVybiBsMS5jb250YWlucyh4MCwgeTApICYmIGwyLmNvbnRhaW5zKHgwLCB5MCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBjaGVjayBub3JtYWwgY2FzZSAtIGJvdGggbGluZXMgYXJlIG5vdCB2ZXJ0aWNhbFxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvL2xpbmUgZXF1YXRpb24gaXMgOiB5ID0gYSp4ICsgYiwgYiA9IHkgLSBhICogeFxyXG4gICAgICAgICAgICB2YXIgYTEgPSAobDEuZW5kUG9pbnQueSAtIGwxLnN0YXJ0UG9pbnQueSkgLyAobDEuZW5kUG9pbnQueCAtIGwxLnN0YXJ0UG9pbnQueCk7XHJcbiAgICAgICAgICAgIHZhciBiMSA9IGwxLnN0YXJ0UG9pbnQueSAtIGExICogbDEuc3RhcnRQb2ludC54O1xyXG5cclxuICAgICAgICAgICAgdmFyIGEyID0gKGwyLmVuZFBvaW50LnkgLSBsMi5zdGFydFBvaW50LnkpIC8gKGwyLmVuZFBvaW50LnggLSBsMi5zdGFydFBvaW50LngpO1xyXG4gICAgICAgICAgICB2YXIgYjIgPSBsMi5zdGFydFBvaW50LnkgLSBhMiAqIGwyLnN0YXJ0UG9pbnQueDtcclxuXHJcbiAgICAgICAgICAgIGlmIChhMSA9PSBhMikgeyAvL3BhcmFsZWwgbGluZXNcclxuICAgICAgICAgICAgICAgIHJldHVybiBiMSA9PSBiMiA/XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZm9yIGNvaW5jaWRlIGxpbmVzLCBjaGVjayBmb3Igc2VnbWVudCBib3VuZHMgb3ZlcmxhcHBpbmdcclxuICAgICAgICAgICAgICAgICAgICBsMS5jb250YWlucyhsMi5zdGFydFBvaW50LngsIGwyLnN0YXJ0UG9pbnQueSkgfHwgbDEuY29udGFpbnMobDIuZW5kUG9pbnQueCwgbDIuZW5kUG9pbnQueSkgOlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIG5vdCBjb2luY2lkZSBwYXJhbGVsIGxpbmVzIGhhdmUgbm8gY2hhbmNlIHRvIGludGVyc2VjdFxyXG4gICAgICAgICAgICAgICAgICAgIGZhbHNlO1xyXG4gICAgICAgICAgICB9IGVsc2UgeyAvL3VzdWFsIGNhc2UgLSBub24gcGFyYWxlbCwgdGhlICdpbmZpbml0ZScgbGluZXMgaW50ZXJzZWN0cy4uLndlIG9ubHkgbmVlZCB0byBrbm93IGlmIGluc2lkZSB0aGUgc2VnbWVudFxyXG5cclxuICAgICAgICAgICAgICAgIC8qXHJcbiAgICAgICAgICAgICAgICAgKiBpZiBvbmUgb2YgdGhlIGxpbmVzIGFyZSB2ZXJ0aWNhbCwgdGhlbiB4MCBpcyBlcXVhbCB0byB0aGVpciB4LFxyXG4gICAgICAgICAgICAgICAgICogb3RoZXJ3aXNlOlxyXG4gICAgICAgICAgICAgICAgICogeTEgPSBhMSAqIHggKyBiMVxyXG4gICAgICAgICAgICAgICAgICogeTIgPSBhMiAqIHggKyBiMlxyXG4gICAgICAgICAgICAgICAgICogPT4geDAgPSAoYjIgLSBiMSkgLyAoYTEgLSBhMilcclxuICAgICAgICAgICAgICAgICAqID0+IHkwID0gYTEgKiB4MCArIGIxXHJcbiAgICAgICAgICAgICAgICAgKiovXHJcbiAgICAgICAgICAgICAgICB4MCA9IChiMiAtIGIxKSAvIChhMSAtIGEyKTtcclxuICAgICAgICAgICAgICAgIHkwID0gYTEgKiB4MCArIGIxO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGwxLmNvbnRhaW5zKHgwLCB5MCkgJiYgbDIuY29udGFpbnMoeDAsIHkwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqXHJcbiAgICAgKlRlc3RzIGlmIGEgYSBwb2x5bGluZSBkZWZpbmVkIGJ5IGEgc2V0IG9mIHBvaW50cyBpbnRlcnNlY3RzIGEgcmVjdGFuZ2xlXHJcbiAgICAgKkBwYXJhbSB7QXJyYXl9IHBvaW50cyAtIGFuZCB7QXJyYXl9IG9mIHtQb2ludH1zXHJcbiAgICAgKkBwYXJhbSB7QXJyYXl9IGJvdW5kcyAtIHRoZSBib3VuZHMgb2YgdGhlIHJlY3RhbmdsZSBkZWZpbmVkIGJ5ICh4MSwgeTEsIHgyLCB5MilcclxuICAgICAqQHBhcmFtIHtCb29sZWFufSBjbG9zZWRQb2x5bGluZSAtIGluY2FzZSBwb2x5bGluZSBpcyBjbG9zZWQgZmlndXJlIHRoZW4gdHJ1ZSwgZWxzZSBmYWxzZVxyXG4gICAgICpcclxuICAgICAqQHJldHVybiB0cnVlIC0gaWYgbGluZSBpbnRlcnNlY3RzIHRoZSByZWN0YW5nbGUsIGZhbHNlIC0gaWYgbm90XHJcbiAgICAgKiovXHJcbiAgICBmdW5jdGlvbiBwb2x5bGluZUludGVyc2VjdHNSZWN0YW5nbGUocG9pbnRzLCBib3VuZHMsIGNsb3NlZFBvbHlsaW5lKSB7XHJcblxyXG5cclxuICAgICAgICAvL2dldCB0aGUgNCBsaW5lcy9zZWdtZW50cyByZXByZXNlbnRlZCBieSB0aGUgYm91bmRzXHJcbiAgICAgICAgdmFyIGxpbmVzID0gW107XHJcbiAgICAgICAgbGluZXMucHVzaChuZXcgTGluZShuZXcgUG9pbnQoYm91bmRzWzBdLCBib3VuZHNbMV0pLCBuZXcgUG9pbnQoYm91bmRzWzJdLCBib3VuZHNbMV0pKSk7XHJcbiAgICAgICAgbGluZXMucHVzaChuZXcgTGluZShuZXcgUG9pbnQoYm91bmRzWzJdLCBib3VuZHNbMV0pLCBuZXcgUG9pbnQoYm91bmRzWzJdLCBib3VuZHNbM10pKSk7XHJcbiAgICAgICAgbGluZXMucHVzaChuZXcgTGluZShuZXcgUG9pbnQoYm91bmRzWzJdLCBib3VuZHNbM10pLCBuZXcgUG9pbnQoYm91bmRzWzBdLCBib3VuZHNbM10pKSk7XHJcbiAgICAgICAgbGluZXMucHVzaChuZXcgTGluZShuZXcgUG9pbnQoYm91bmRzWzBdLCBib3VuZHNbM10pLCBuZXcgUG9pbnQoYm91bmRzWzBdLCBib3VuZHNbMV0pKSk7XHJcblxyXG4gICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgcG9pbnRzLmxlbmd0aCAtIDE7IGsrKykge1xyXG4gICAgICAgICAgICAvL2NyZWF0ZSBhIGxpbmUgb3V0IG9mIGVhY2ggMiBjb25zZWN1dGl2ZSBwb2ludHNcclxuICAgICAgICAgICAgdmFyIHRlbXBMaW5lID0gbmV3IExpbmUocG9pbnRzW2tdLCBwb2ludHNbayArIDFdKTtcclxuXHJcbiAgICAgICAgICAgIC8vc2VlIGlmIHRoYXQgbGluZSBpbnRlcnNlY3QgYW55IG9mIHRoZSBsaW5lIG9uIGJvdW5kcyBib3JkZXJcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGxpbmVJbnRlcnNlY3RzTGluZSh0ZW1wTGluZSwgbGluZXNbaV0pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vY2hlY2sgdGhlIGNsb3NlZCBmaWd1cmUgLSB0aGF0IGlzIGxhc3QgcG9pbnQgY29ubmVjdGVkIHRvIHRoZSBmaXJzdFxyXG4gICAgICAgIGlmIChjbG9zZWRQb2x5bGluZSkge1xyXG4gICAgICAgICAgICAvL2NyZWF0ZSBhIGxpbmUgb3V0IG9mIGVhY2ggMiBjb25zZWN1dGl2ZSBwb2ludHNcclxuICAgICAgICAgICAgdmFyIHRlbXBMaW5lMSA9IG5ldyBMaW5lKHBvaW50c1twb2ludHMubGVuZ3RoIC0gMV0sIHBvaW50c1swXSk7XHJcblxyXG4gICAgICAgICAgICAvL3NlZSBpZiB0aGF0IGxpbmUgaW50ZXJzZWN0IGFueSBvZiB0aGUgbGluZSBvbiBib3VuZHMgYm9yZGVyXHJcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbGluZXMubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgICAgIGlmIChsaW5lSW50ZXJzZWN0c0xpbmUodGVtcExpbmUxLCBsaW5lc1tqXSkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog6K6h566X6Lev5b6E55qE5YiG5pWwXHJcbiAgICAgKiBTY29yZSBhIG9ydG9nb25hbCBwYXRoIG1hZGUgb3V0IG9mIFBvaW50c1xyXG4gICAgICpJdGVyYXRlcyBvdmVyIGEgc2V0IG9mIHBvaW50cyAobWluaW11bSAzKVxyXG4gICAgICpGb3IgZWFjaCAzIHBvaW50cyAoaSwgaSsxLCBpKzIpIDpcclxuICAgICAqICAtIGlmIHRoZSAzcmQgb25lIGlzIGFmdGVyIHRoZSAybmQgb24gdGhlIHNhbWUgbGluZSB3ZSBhZGQgKzFcclxuICAgICAqICAtIGlmIHRoZSAzcmQgaXMgdXAgb3IgZG93biByZWxhdGVkIHRvIHRoZSAybmQgd2UgZG8gbm90IGRvIGFueXRoaW5nICswXHJcbiAgICAgKiAgLSBpZiB0aGUgM3JkIGdvZXMgYmFjayB3ZSBpbWVkaWF0ZWxseSByZXR1cm4gLTFcclxuICAgICAqQHBhcmFtIHtBcnJheX0gdiAtIGFuIGFycmF5IG9mIHtQb2ludH1zXHJcbiAgICAgKkByZXR1cm4ge051bWJlcn0gLSAtMSBpZiB0aGUgcGF0aCBpcyB3cm9uZyAoZ29lcyBiYWNrKSBvciBzb21ldGhpbmcgPj0gMCBpZiBpcyBmaW5lXHJcbiAgICAgKiAgVGhlIGJpZ2dlciB0aGUgbnVtYmVyIHRoZSBzbW9vdGggdGhlIHBhdGggaXNcclxuICAgICAqKi9cclxuICAgIGZ1bmN0aW9uIHNjb3JlUGF0aCh2KSB7XHJcbiAgICAgICAgaWYgKHYubGVuZ3RoIDw9IDIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHNjb3JlID0gMDtcclxuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IHYubGVuZ3RoIC0gMTsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmICh2W2kgLSAxXS54ID09IHZbaV0ueCAmJiB2W2ldLnggPT0gdltpICsgMV0ueCkgeyAvL29uIHRoZSBzYW1lIHZlcnRpY2FsXHJcbiAgICAgICAgICAgICAgICBpZiAoc2lnbnVtKHZbaSArIDFdLnkgLSB2W2ldLnkpID09IHNpZ251bSh2W2ldLnkgLSB2W2kgLSAxXS55KSkgeyAvL3NhbWUgZGlyZWN0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgc2NvcmUrKztcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7IC8vZ29pbmcgYmFjayAtIG5vIGdvb2RcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodltpIC0gMV0ueSA9PSB2W2ldLnkgJiYgdltpXS55ID09IHZbaSArIDFdLnkpIHsgLy9vbiB0aGUgc2FtZSBob3Jpem9udGFsXHJcbiAgICAgICAgICAgICAgICBpZiAoc2lnbnVtKHZbaSArIDFdLnggLSB2W2ldLngpID09IHNpZ251bSh2W2ldLnggLSB2W2kgLSAxXS54KSkgeyAvL3NhbWUgZGlyZWN0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgc2NvcmUrKztcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7IC8vZ29pbmcgYmFjayAtIG5vIGdvb2RcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7IC8vbm90IG9uIHNhbWUgdmVydGljYWwgbm9yIGhvcml6b250YWxcclxuICAgICAgICAgICAgICAgIHNjb3JlLS07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBzY29yZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOi/lOWbnuaVsOWtl+espuWPt++8iCsgLSlcclxuICAgICAqIFJldHVybnMgdGhlIHNpZ24gb2YgYSBudW1iZXJcclxuICAgICAqQHBhcmFtIHtOdW1iZXJ9IHggLSB0aGUgbnVtYmVyXHJcbiAgICAgKkByZXR1cm5zIHtOdW1iZXJ9XHJcbiAgICAgKkBzZWUgPGEgaHJlZj1cImh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU2lnbl9mdW5jdGlvblwiPmh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU2lnbl9mdW5jdGlvbjwvYT5cclxuICAgICAqKi9cclxuICAgIGZ1bmN0aW9uIHNpZ251bSh4KSB7XHJcbiAgICAgICAgaWYgKHggPiAwKVxyXG4gICAgICAgICAgICByZXR1cm4gMTtcclxuICAgICAgICBlbHNlIGlmICh4IDwgMClcclxuICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDliKTmlq0g54K55pWw57uEIOaYr+S4jeaYr+acieaViOi3r+W+hO+8iOayoeacieWbnui3r++8iVxyXG4gICAgICpUZXN0cyBpZiBhIHZlY3RvciBvZiBwb2ludHMgaXMgYSB2YWxpZCBwYXRoIChub3QgZ29pbmcgYmFjaylcclxuICAgICAqVGhlcmUgYXJlIGEgZmV3IHByb2JsZW1zIGhlcmUuIElmIHlvdSBoYXZlIHAxLCBwMiwgcDMgYW5kIHA0IGFuZCBwMiA9IHAzIHlvdSBuZWVkIHRvIGlnbm9yZSB0aGF0XHJcbiAgICAgKkBwYXJhbSB7QXJyYXl9IHYgLSBhbiB7QXJyYXl9IG9mIHtQb2ludH1zXHJcbiAgICAgKkByZXR1cm4ge0Jvb2xlYW59IC0gdHJ1ZSBpZiBwYXRoIGlzIHZhbGlkLCBmYWxzZSBvdGhlcndpc2VcclxuICAgICAqKi9cclxuICAgIGZ1bmN0aW9uIGZvcndhcmRQYXRoKHYpIHtcclxuICAgICAgICBpZiAodi5sZW5ndGggPD0gMikge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdi5sZW5ndGggLSAyOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKHZbaV0ueCA9PSB2W2kgKyAxXS54ICYmIHZbaSArIDFdLnggPT0gdltpICsgMl0ueCkgeyAvL29uIHRoZSBzYW1lIHZlcnRpY2FsXHJcbiAgICAgICAgICAgICAgICBpZiAoc2lnbnVtKHZbaSArIDFdLnkgLSB2W2ldLnkpICE9IDApIHsgLy90ZXN0IG9ubHkgd2UgaGF2ZSBhIHByb2dyZXNzaW5nIHBhdGhcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc2lnbnVtKHZbaSArIDFdLnkgLSB2W2ldLnkpID09IC0xICogc2lnbnVtKHZbaSArIDJdLnkgLSB2W2kgKyAxXS55KSkgeyAvL2dvaW5nIGJhY2sgKGlnbm9yZSB6ZXJvKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHZbaV0ueSA9PSB2W2kgKyAxXS55ICYmIHZbaSArIDFdLnkgPT0gdltpICsgMl0ueSkgeyAvL29uIHRoZSBzYW1lIGhvcml6b250YWxcclxuICAgICAgICAgICAgICAgIGlmIChzaWdudW0odltpICsgMV0ueCAtIHZbaV0ueCkgIT0gMCkgeyAvL3Rlc3Qgb25seSB3ZSBoYXZlIGEgcHJvZ3Jlc3NpbmcgcGF0aFxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzaWdudW0odltpICsgMV0ueCAtIHZbaV0ueCkgPT0gLTEgKiBzaWdudW0odltpICsgMl0ueCAtIHZbaSArIDFdLngpKSB7IC8vZ29pbmcgYmFjayAoaWdub3JlIHplcm8pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog5bCGW3g6MCx5OjBd6L2s5YyW5Li6WzAsIDBdICDnu5l6cmVuZGVy5L2/55SoXHJcbiAgICAgKiBAcGFyYW0gIHtbdHlwZV19IHBvaW50cyBbZGVzY3JpcHRpb25dXHJcbiAgICAgKiBAcGFyYW0gIHtbdHlwZV19IGlzUmV2ZXJ0IFtkZXNjcmlwdGlvbl1cclxuICAgICAqIEByZXR1cm4ge1t0eXBlXX0gICAgICAgIFtkZXNjcmlwdGlvbl1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gdHJhc2xhdGVQb2ludHMocG9pbnRzLCBpc1JldmVydCkge1xyXG4gICAgICAgIHZhciBuZXdQb2ludHMgPSBbXTtcclxuICAgICAgICBpZiAoaXNSZXZlcnQpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBwb2ludCA9IHBvaW50c1tpXTtcclxuICAgICAgICAgICAgICAgIG5ld1BvaW50cy5wdXNoKG5ldyBQb2ludChwb2ludFswXSwgcG9pbnRbMV0pKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbmV3UG9pbnRzO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcG9pbnRzLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcG9pbnQxID0gcG9pbnRzW2pdO1xyXG4gICAgICAgICAgICAgICAgbmV3UG9pbnRzLnB1c2goW3BvaW50MS54LCBwb2ludDEueV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBuZXdQb2ludHM7XHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gcm90YXRpb25NYXRyaXgoYW5nbGUpIHtcclxuICAgICAgICB2YXIgbVJldHVybiA9IFtcclxuICAgICAgICAgICAgW01hdGguY29zKGFuZ2xlKSwgLU1hdGguc2luKGFuZ2xlKSwgMF0sXHJcbiAgICAgICAgICAgIFtNYXRoLnNpbihhbmdsZSksIE1hdGguY29zKGFuZ2xlKSwgMF0sXHJcbiAgICAgICAgICAgIFswLCAwLCAxXVxyXG4gICAgICAgIF07XHJcbiAgICAgICAgcmV0dXJuIG1SZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gdHJhbnNsYXRpb25NYXRyaXgoZHgsIGR5KSB7XHJcbiAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgWzEsIDAsIGR4XSxcclxuICAgICAgICAgICAgWzAsIDEsIGR5XSxcclxuICAgICAgICAgICAgWzAsIDAsIDFdXHJcbiAgICAgICAgXTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBzY2FsZU1hdHJpeChzeCwgc3kpIHtcclxuICAgICAgICBpZiAoc3kgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBzeSA9IHN4O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICBbc3gsIDAsIDBdLFxyXG4gICAgICAgICAgICBbMCwgc3ksIDBdLFxyXG4gICAgICAgICAgICBbMCwgMCwgMV1cclxuICAgICAgICBdO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBJdCB3aWxsIHJldHVybiB0aGUgZW5kIHBvaW50IG9mIGEgbGluZSBvbiBhIGdpdmVuIGFuZ2xlIChjbG9ja3dpc2UpLlxyXG4gICAgICogQHBhcmFtIHtQb2ludH0gc3RhcnRQb2ludCAtIHRoZSBzdGFydCBvZiB0aGUgbGluZVxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxlbmd0aCAtIHRoZSBsZW5ndGggb2YgdGhlIGxpbmVcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhbmdsZSAtIHRoZSBhbmdsZSBvZiB0aGUgbGluZSBpbiByYWRpYW5zXHJcbiAgICAgKiBAcmV0dXJuIHtQb2ludH0gLSB0aGUgZW5kUG9pbnQgb2YgdGhlIGxpbmVcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZ2V0RW5kUG9pbnQoc3RhcnRQb2ludCwgbGVuZ3RoLCBhbmdsZSkge1xyXG4gICAgICAgIHZhciBlbmRQb2ludCA9IHN0YXJ0UG9pbnQuY2xvbmUoKTtcclxuICAgICAgICBlbmRQb2ludC50cmFuc2Zvcm0odHJhbnNsYXRpb25NYXRyaXgoLXN0YXJ0UG9pbnQueCwgLXN0YXJ0UG9pbnQueSkpO1xyXG4gICAgICAgIGVuZFBvaW50LnkgLT0gbGVuZ3RoO1xyXG4gICAgICAgIGVuZFBvaW50LnRyYW5zZm9ybShyb3RhdGlvbk1hdHJpeChhbmdsZSkpO1xyXG4gICAgICAgIGVuZFBvaW50LnRyYW5zZm9ybSh0cmFuc2xhdGlvbk1hdHJpeChzdGFydFBvaW50LngsIHN0YXJ0UG9pbnQueSkpO1xyXG4gICAgICAgIHJldHVybiBlbmRQb2ludDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOiOt+WPluiOt+WPluS4pOS4quWbvuW9oueahOWklumdouWbm+S4qui/nuaOpeeCuVxyXG4gICAgICogQHBhcmFtICB7W3R5cGVdfSBub2RlIFtkZXNjcmlwdGlvbl1cclxuICAgICAqIEByZXR1cm4ge1t0eXBlXX0gICAgICBbZGVzY3JpcHRpb25dXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGdldENvbm5lY3RvclBvaW50cyhub2RlKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgbGVmdDogbmV3IFBvaW50KG5vZGUueCwgbm9kZS55ICsgbm9kZS5oZWlnaHQgLyAyKSwgLy/nn6nlvaIg5bem5Lit55qE5L2N572uXHJcbiAgICAgICAgICAgIHRvcDogbmV3IFBvaW50KG5vZGUueCArIG5vZGUud2lkdGggLyAyLCBub2RlLnkpLCAvL+efqeW9oiDkuIrkuK3nmoTkvY3nva5cclxuICAgICAgICAgICAgcmlnaHQ6IG5ldyBQb2ludChub2RlLnggKyBub2RlLndpZHRoLCBub2RlLnkgKyBub2RlLmhlaWdodCAvIDIpLCAvL+efqeW9oiDlj7PkuK3nmoTkvY3nva5cclxuICAgICAgICAgICAgYm90dG9tOiBuZXcgUG9pbnQobm9kZS54ICsgbm9kZS53aWR0aCAvIDIsIG5vZGUueSArIG5vZGUuaGVpZ2h0KSwgLy/nn6nlvaIg5LiL5Lit55qE5L2N572uXHJcbiAgICAgICAgICAgIGNlbnRlcjogbmV3IFBvaW50KG5vZGUueCArIG5vZGUud2lkdGggLyAyLCBub2RlLnkgKyBub2RlLmhlaWdodCAvIDIpIC8v5Lit6Ze05L2N572uXHJcblxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDojrflj5bojrflj5bkuKTkuKrlm77lvaLnmoTlpJbpnaLlm5vkuKrov57mjqXngrlcclxuICAgICAqIEBwYXJhbSAge1t0eXBlXX0gbm9kZSBbZGVzY3JpcHRpb25dXHJcbiAgICAgKiBAcmV0dXJuIHtbdHlwZV19ICAgICAgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBnZXRTb2x0UG9pbnRzKG5vZGUpIHtcclxuICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICAvL3RvcFxyXG4gICAgICAgICAgICBbTWF0aC5yb3VuZChub2RlLmdldFJlY3QoKS53aWR0aCAvIDMgLzEwKSoxMCwgMCBdLFxyXG4gICAgICAgICAgICBbTWF0aC5yb3VuZCgyKm5vZGUuZ2V0UmVjdCgpLndpZHRoIC8gMyAvMTApKjEwLCAwIF0sXHJcbiAgICAgICAgICAgIC8vcmlnaHRcclxuICAgICAgICAgICAgW25vZGUuZ2V0UmVjdCgpLndpZHRoLCBNYXRoLnJvdW5kKG5vZGUuZ2V0UmVjdCgpLmhlaWdodCAvIDMgLzEwKSoxMCBdLFxyXG4gICAgICAgICAgICBbbm9kZS5nZXRSZWN0KCkud2lkdGgsIE1hdGgucm91bmQoMipub2RlLmdldFJlY3QoKS5oZWlnaHQgLyAzIC8xMCkqMTAgXSxcclxuICAgICAgICAgICAgLy9ib3R0b21cclxuICAgICAgICAgICAgW01hdGgucm91bmQobm9kZS5nZXRSZWN0KCkud2lkdGggLyAzIC8xMCkqMTAsIG5vZGUuZ2V0UmVjdCgpLmhlaWdodCBdLFxyXG4gICAgICAgICAgICBbTWF0aC5yb3VuZCgyKm5vZGUuZ2V0UmVjdCgpLndpZHRoIC8gMyAvMTApKjEwLCBub2RlLmdldFJlY3QoKS5oZWlnaHQgXSxcclxuICAgICAgICAgICAgLy9sZWZ0XHJcbiAgICAgICAgICAgIFswLCBNYXRoLnJvdW5kKG5vZGUuZ2V0UmVjdCgpLmhlaWdodCAvIDMgLzEwKSoxMCBdLFxyXG4gICAgICAgICAgICBbMCwgTWF0aC5yb3VuZCgyKm5vZGUuZ2V0UmVjdCgpLmhlaWdodCAvIDMgLzEwKSoxMCBdXHJcblxyXG4gICAgICAgIF1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOiuoeeulyBwMSBwMuS4pOeCueaJgOi/nuaOpeeahOebtOe6v+eahOinkuW6plxyXG4gICAgICogQHBhcmFtICB7W3R5cGVdfSBwMSBbZGVzY3JpcHRpb25dXHJcbiAgICAgKiBAcGFyYW0gIHtbdHlwZV19IHAyIFtkZXNjcmlwdGlvbl1cclxuICAgICAqIEByZXR1cm4ge1t0eXBlXX0gICAgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiB0YW5nZW50Um90YXRpb24ocDEsIHAyKSB7XHJcbiAgICAgICAgcmV0dXJuIC1NYXRoLlBJIC8gMiAtIE1hdGguYXRhbjIoXHJcbiAgICAgICAgICAgIHAyLnkgLSBwMS55LCBwMi54IC0gcDEueFxyXG4gICAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDliKTmlq0z54K55piv5ZCm5Zyo5LiA5p2h55u057q/5LiKXHJcbiAgICAgKiBUZXN0cyBpZiAzIHBvaW50cyBhcmUgY29saW5pYXIgd2l0aCBtYXRyaXggZGV0ZXJtaW5hbnRzLlxyXG4gICAgICogSWYgdGhlIGRldGVybWluYXQgb2YgbWF0cml4XHJcbiAgICAgKiAvICAgICAgICAgXFxcclxuICAgICAqIHwgeDEgeTEgMSB8XHJcbiAgICAgKiB8IHgyIHkyIDEgfFxyXG4gICAgICogfCB4MyB5MyAxIHxcclxuICAgICAqIFxcICAgICAgICAgL1xyXG4gICAgICogaXMgemVybyBpdCBtZWFucyB0aGF0IHRoZSBwb2ludHMgYXJlIGNvbGluZWFyXHJcbiAgICAgKkBwYXJhbSB7UG9pbnR9IHAxIC0gZmlyc3QgcG9pbnRcclxuICAgICAqQHBhcmFtIHtQb2ludH0gcDIgLSBzZWNvbmQgcG9pbnRcclxuICAgICAqQHBhcmFtIHtQb2ludH0gcDMgLSB0aGlyZCBwb2ludFxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHByZWNpc3Npb25cclxuICAgICAqQHJldHVybiB7Qm9vbGVhbn0gLSB0cnVlIGlmIGNvbGluaWFyIGFuZCBmYWxzZSBpZiBub3RcclxuICAgICAqQGF1dGhvciBBbGV4XHJcbiAgICAgKkBzZWUgaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9EZXRlcm1pbmFudFxyXG4gICAgICpAc2VlIGh0dHBzOi8vcGVvcGxlLnJpY2hsYW5kLmVkdS9qYW1lcy9sZWN0dXJlL20xMTYvbWF0cmljZXMvYXBwbGljYXRpb25zLmh0bWxcclxuICAgICAqKi9cclxuICAgIGZ1bmN0aW9uIGNvbGxpbmVhcml0eShwMSwgcDIsIHAzLCBwcmVjaXNzaW9uKSB7XHJcbiAgICAgICAgdmFyIGRldGVybWluYW50ID0gKHAxLnggKiBwMi55ICsgcDEueSAqIHAzLnggKyBwMi54ICogcDMueSkgLSAocDIueSAqIHAzLnggKyBwMS55ICogcDIueCArIHAxLnggKiBwMy55KTtcclxuXHJcbiAgICAgICAgaWYgKHByZWNpc3Npb24pIHtcclxuICAgICAgICAgICAgcmV0dXJuIE1hdGguYWJzKGRldGVybWluYW50KSA8PSBwcmVjaXNzaW9uO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBkZXRlcm1pbmFudCA9PT0gMDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICog5Zub6IiN5LqU5YWlIOS/neWtmGRlY2ltYWxz55qE5bCP5pWwXHJcbiAgICAgKiovXHJcbiAgICBmdW5jdGlvbiBlbmhhbmNlZFJvdW5kKG51bWJlciwgZGVjaW1hbHMpIHtcclxuICAgICAgICByZXR1cm4gTWF0aC5yb3VuZChudW1iZXIgKiBNYXRoLnBvdygxMCwgZGVjaW1hbHMpKSAvIE1hdGgucG93KDEwLCBkZWNpbWFscyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDojrflj5bkuKTngrnkuYvpl7TnmoTplb/luqZcclxuICAgICAqKi9cclxuICAgIGZ1bmN0aW9uIGdldExlbmd0aChzdGFydFBvaW50LCBlbmRQb2ludCkge1xyXG4gICAgICAgIHJldHVybiBNYXRoLnNxcnQoTWF0aC5wb3coc3RhcnRQb2ludC54IC0gZW5kUG9pbnQueCwgMikgKyBNYXRoLnBvdyhzdGFydFBvaW50LnkgLSBlbmRQb2ludC55LCAyKSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDojrflj5bop5LluqZcclxuICAgICAqIEBwYXJhbSAge1t0eXBlXX0gY2VudGVyUG9pbnQgIFtkZXNjcmlwdGlvbl1cclxuICAgICAqIEBwYXJhbSAge1t0eXBlXX0gb3V0c2lkZVBvaW50IFtkZXNjcmlwdGlvbl1cclxuICAgICAqIEBwYXJhbSAge1t0eXBlXX0gcm91bmQgICAgICAgIFtkZXNjcmlwdGlvbl1cclxuICAgICAqIEByZXR1cm4ge1t0eXBlXX0gICAgICAgICAgICAgIFtkZXNjcmlwdGlvbl1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZ2V0QW5nbGUoY2VudGVyUG9pbnQsIG91dHNpZGVQb2ludCwgcm91bmQpIHtcclxuICAgICAgICBjZW50ZXJQb2ludC54ID0gZW5oYW5jZWRSb3VuZChjZW50ZXJQb2ludC54LCA1KTtcclxuICAgICAgICBjZW50ZXJQb2ludC55ID0gZW5oYW5jZWRSb3VuZChjZW50ZXJQb2ludC55LCA1KTtcclxuICAgICAgICBvdXRzaWRlUG9pbnQueCA9IGVuaGFuY2VkUm91bmQob3V0c2lkZVBvaW50LngsIDUpO1xyXG4gICAgICAgIG91dHNpZGVQb2ludC55ID0gZW5oYW5jZWRSb3VuZChvdXRzaWRlUG9pbnQueSwgNSk7XHJcbiAgICAgICAgdmFyIGFuZ2xlID0gTWF0aC5hdGFuKChvdXRzaWRlUG9pbnQueCAtIGNlbnRlclBvaW50LngpIC8gKG91dHNpZGVQb2ludC55IC0gY2VudGVyUG9pbnQueSkpO1xyXG4gICAgICAgIGFuZ2xlID0gLWFuZ2xlO1xyXG5cclxuICAgICAgICAvL2VuZEFuZ2xlKz05MDtcclxuICAgICAgICBpZiAob3V0c2lkZVBvaW50LnggPj0gY2VudGVyUG9pbnQueCAmJiBvdXRzaWRlUG9pbnQueSA+PSBjZW50ZXJQb2ludC55KSB7XHJcbiAgICAgICAgICAgIGFuZ2xlICs9IE1hdGguUEk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChvdXRzaWRlUG9pbnQueCA8PSBjZW50ZXJQb2ludC54ICYmIG91dHNpZGVQb2ludC55ID49IGNlbnRlclBvaW50LnkpIHtcclxuICAgICAgICAgICAgYW5nbGUgKz0gTWF0aC5QSTtcclxuICAgICAgICB9IGVsc2UgaWYgKG91dHNpZGVQb2ludC54IDw9IGNlbnRlclBvaW50LnggJiYgb3V0c2lkZVBvaW50LnkgPD0gY2VudGVyUG9pbnQueSkge1xyXG4gICAgICAgICAgICBhbmdsZSArPSBNYXRoLlBJICogMjtcclxuICAgICAgICB9XHJcbiAgICAgICAgd2hpbGUgKGFuZ2xlID49IE1hdGguUEkgKiAyKSB7XHJcbiAgICAgICAgICAgIGFuZ2xlIC09IE1hdGguUEkgKiAyO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaXNOYU4oYW5nbGUpKSB7IC8vTmFuXHJcbiAgICAgICAgICAgIGFuZ2xlID0gMDsgLy93ZSBhcmUgYXQgY2VudGVyIHBvaW50O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocm91bmQpIHtcclxuICAgICAgICAgICAgYW5nbGUgPSBNYXRoLnJvdW5kKGFuZ2xlIC8gcm91bmQpICogcm91bmRcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGFuZ2xlO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGdldFJlY3Qobm9kZSkge1xyXG4gICAgICAgIHZhciBib3VuZGluZ1JlY3QgPSBub2RlLmdldEJvdW5kaW5nUmVjdCgpO1xyXG4gICAgICAgIC8v5Yib5bu65pyA5bCP5YyF5Zu055uS6Jma57q/XHJcbiAgICAgICAgdmFyIHBvaW50cyA9IFtdO1xyXG4gICAgICAgIHBvaW50c1swXSA9IFstYm91bmRpbmdSZWN0LndpZHRoIC8gMiwgLWJvdW5kaW5nUmVjdC5oZWlnaHQgLyAyXTtcclxuICAgICAgICBwb2ludHNbMV0gPSBbYm91bmRpbmdSZWN0LndpZHRoIC8gMiwgLWJvdW5kaW5nUmVjdC5oZWlnaHQgLyAyXTtcclxuICAgICAgICBwb2ludHNbMl0gPSBbYm91bmRpbmdSZWN0LndpZHRoIC8gMiwgYm91bmRpbmdSZWN0LmhlaWdodCAvIDJdO1xyXG4gICAgICAgIHBvaW50c1szXSA9IFstYm91bmRpbmdSZWN0LndpZHRoIC8gMiwgYm91bmRpbmdSZWN0LmhlaWdodCAvIDJdO1xyXG4gICAgICAgIHBvaW50c1s0XSA9IFstYm91bmRpbmdSZWN0LndpZHRoIC8gMiwgLWJvdW5kaW5nUmVjdC5oZWlnaHQgLyAyXTtcclxuXHJcbiAgICAgICAgdmFyIGJvdW5kUmVjdCwgY3gsIGN5O1xyXG4gICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgZ3JhcGhpYy5DaXJjbGUpIHtcclxuICAgICAgICAgICAgLy/ms6g6IOWboOS6i+S7tuS4uuWchuW9oiAg5omA5LulIHggeSDkuLrlnIblv4PnmoTkvY3nva4gIOWMheWbtOefqeW9ouimgeWHj+WOu+WuveW6puS4gOWNilxyXG4gICAgICAgICAgICBib3VuZFJlY3QgPSBuZXcgQm91bmRpbmdSZWN0KE51bWJlcihub2RlLnBvc2l0aW9uWzBdKSAtIE51bWJlcihib3VuZGluZ1JlY3Qud2lkdGggLyAyKSxcclxuICAgICAgICAgICAgICAgIE51bWJlcihub2RlLnBvc2l0aW9uWzFdKSAtIE51bWJlcihib3VuZGluZ1JlY3QuaGVpZ2h0IC8gMiksXHJcbiAgICAgICAgICAgICAgICBOdW1iZXIoYm91bmRpbmdSZWN0LndpZHRoKSwgTnVtYmVyKGJvdW5kaW5nUmVjdC5oZWlnaHQpKTtcclxuICAgICAgICAgICAgY3ggPSBOdW1iZXIobm9kZS5wb3NpdGlvblswXSk7XHJcbiAgICAgICAgICAgIGN5ID0gTnVtYmVyKG5vZGUucG9zaXRpb25bMV0pO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGJvdW5kUmVjdCA9IG5ldyBCb3VuZGluZ1JlY3QoTnVtYmVyKG5vZGUucG9zaXRpb25bMF0pLFxyXG4gICAgICAgICAgICAgICAgTnVtYmVyKG5vZGUucG9zaXRpb25bMV0pLFxyXG4gICAgICAgICAgICAgICAgTnVtYmVyKGJvdW5kaW5nUmVjdC53aWR0aCksIE51bWJlcihib3VuZGluZ1JlY3QuaGVpZ2h0KSk7XHJcbiAgICAgICAgICAgIGN4ID0gTnVtYmVyKG5vZGUucG9zaXRpb25bMF0pICsgTnVtYmVyKGJvdW5kaW5nUmVjdC53aWR0aCkgLyAyO1xyXG4gICAgICAgICAgICBjeSA9IE51bWJlcihub2RlLnBvc2l0aW9uWzFdKSArIE51bWJlcihib3VuZGluZ1JlY3QuaGVpZ2h0KSAvIDI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHg6IE51bWJlcihjeCksXHJcbiAgICAgICAgICAgIHk6IE51bWJlcihjeSksXHJcbiAgICAgICAgICAgIHdpZHRoOiBOdW1iZXIoYm91bmRpbmdSZWN0LndpZHRoKSxcclxuICAgICAgICAgICAgaGVpZ2h0OiBOdW1iZXIoYm91bmRpbmdSZWN0LmhlaWdodCksXHJcbiAgICAgICAgICAgIHBvaW50czogcG9pbnRzLFxyXG4gICAgICAgICAgICBib3VuZGluZ1JlY3Q6IGJvdW5kUmVjdFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIFN0YWNrZWRNYXAgPSB7XHJcbiAgICAgICAgY3JlYXRlTmV3OiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdmFyIHN0YWNrID0gW107XHJcblxyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgYWRkOiBmdW5jdGlvbihrZXksIHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFycktleSA9IHRoaXMuZ2V0KGtleSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYXJyS2V5LnB1c2godmFsdWUpXHJcblxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oa2V5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdGFjay5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoa2V5ID09IHN0YWNrW2ldLmtleSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0YWNrW2ldLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIC8v5aaC5p6c5rKh5pyJ5om+5Yiw55qE6K+d77yM5YiZ5Yib5bu65LiA5Liq5paw55qE5pWw57uEXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhY2sucHVzaCh7IGtleToga2V5LCB2YWx1ZTogdmFsdWUgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGtleXM6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBrZXlzID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdGFjay5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXlzLnB1c2goc3RhY2tbaV0ua2V5KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGtleXM7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgdG9wOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV07XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbihrZXkpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaWR4ID0gLTE7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdGFjay5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoa2V5ID09IHN0YWNrW2ldLmtleSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWR4ID0gaTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdGFjay5zcGxpY2UoaWR4LCAxKVswXTtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICByZW1vdmVJdGVtOiBmdW5jdGlvbihrZXksIGl0ZW0pIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYXJyS2V5ID0gdGhpcy5nZXQoa2V5KTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSB6clV0aWwuaW5kZXhPZihhcnJLZXksIGl0ZW0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGFycktleS5zcGxpY2UoaW5kZXgsIDEpO1xyXG5cclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICByZW1vdmVUb3A6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdGFjay5zcGxpY2Uoc3RhY2subGVuZ3RoIC0gMSwgMSlbMF07XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgbGVuZ3RoOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RhY2subGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGNsZWFyOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgICBzdGFjay5zcGxpY2UoMCwgc3RhY2subGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIGZ1bmN0aW9uIHJhbmRvbUNvbG9yKCkge1xyXG4gICAgICAgIHZhciBhcnJIZXggPSBbXCIwXCIsIFwiMlwiLCBcIjNcIiwgXCI0XCIsIFwiNVwiLCBcIjZcIiwgXCI3XCIsIFwiOFwiLCBcIjlcIiwgXCJhXCIsIFwiYlwiLCBcImNcIiwgXCJkXCJdLFxyXG4gICAgICAgICAgICBzdHJIZXggPSBcIiNcIixcclxuICAgICAgICAgICAgaW5kZXg7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA2OyBpKyspIHtcclxuICAgICAgICAgICAgaW5kZXggPSBNYXRoLnJvdW5kKE1hdGgucmFuZG9tKCkgKiAxNSk7XHJcbiAgICAgICAgICAgIHN0ckhleCArPSBhcnJIZXhbaW5kZXhdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc3RySGV4O1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGlzVW5kZWZpbmVkKG9iaikge1xyXG4gICAgICAgIHJldHVybiBvYmogPT09IHZvaWQgMDtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBjb2xsaW5lYXJSZWR1Y3Rpb24gKHYpIHtcclxuICAgICAgICB2YXIgciA9IFtdO1xyXG5cclxuICAgICAgICBpZih2Lmxlbmd0aCA8IDMpe1xyXG4gICAgICAgICAgICByZXR1cm4gUG9pbnQuY2xvbmVBcnJheSh2KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHIucHVzaCggdlswXS5jbG9uZSgpICk7XHJcbiAgICAgICAgZm9yKHZhciBpPTE7IGkgPCB2Lmxlbmd0aC0xOyBpKyspe1xyXG4gICAgICAgICAgICBpZiggKHZbaS0xXS54ID09IHZbaV0ueCAmJiB2W2ldLnggPT0gdltpKzFdLngpICB8fCAgKHZbaS0xXS55ID09IHZbaV0ueSAmJiB2W2ldLnkgPT0gdltpKzFdLnkpIClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZXtcclxuICAgICAgICAgICAgICAgIHIucHVzaCggdltpXS5jbG9uZSgpICk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgci5wdXNoKCB2W3YubGVuZ3RoLTFdLmNsb25lKCkgKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHI7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQnkgZGVmYXVsdCwgVW5kZXJzY29yZSB1c2VzIEVSQi1zdHlsZSB0ZW1wbGF0ZSBkZWxpbWl0ZXJzLCBjaGFuZ2UgdGhlXHJcbiAgICAvLyBmb2xsb3dpbmcgdGVtcGxhdGUgc2V0dGluZ3MgdG8gdXNlIGFsdGVybmF0aXZlIGRlbGltaXRlcnMuXHJcbiAgICB2YXIgdGVtcGxhdGVTZXR0aW5ncyA9IHtcclxuICAgICAgICBldmFsdWF0ZTogLzwlKFtcXHNcXFNdKz8pJT4vZyxcclxuICAgICAgICBpbnRlcnBvbGF0ZTogLzwlPShbXFxzXFxTXSs/KSU+L2csXHJcbiAgICAgICAgZXNjYXBlOiAvPCUtKFtcXHNcXFNdKz8pJT4vZ1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyBXaGVuIGN1c3RvbWl6aW5nIGB0ZW1wbGF0ZVNldHRpbmdzYCwgaWYgeW91IGRvbid0IHdhbnQgdG8gZGVmaW5lIGFuXHJcbiAgICAvLyBpbnRlcnBvbGF0aW9uLCBldmFsdWF0aW9uIG9yIGVzY2FwaW5nIHJlZ2V4LCB3ZSBuZWVkIG9uZSB0aGF0IGlzXHJcbiAgICAvLyBndWFyYW50ZWVkIG5vdCB0byBtYXRjaC5cclxuICAgIHZhciBub01hdGNoID0gLyguKV4vO1xyXG5cclxuICAgIC8vIENlcnRhaW4gY2hhcmFjdGVycyBuZWVkIHRvIGJlIGVzY2FwZWQgc28gdGhhdCB0aGV5IGNhbiBiZSBwdXQgaW50byBhXHJcbiAgICAvLyBzdHJpbmcgbGl0ZXJhbC5cclxuICAgIHZhciBlc2NhcGVzID0ge1xyXG4gICAgICAgIFwiJ1wiOiBcIidcIixcclxuICAgICAgICAnXFxcXCc6ICdcXFxcJyxcclxuICAgICAgICAnXFxyJzogJ3InLFxyXG4gICAgICAgICdcXG4nOiAnbicsXHJcbiAgICAgICAgJ1xcdTIwMjgnOiAndTIwMjgnLFxyXG4gICAgICAgICdcXHUyMDI5JzogJ3UyMDI5J1xyXG4gICAgfTtcclxuXHJcbiAgICB2YXIgZXNjYXBlciA9IC9cXFxcfCd8XFxyfFxcbnxcXHUyMDI4fFxcdTIwMjkvZztcclxuXHJcbiAgICB2YXIgZXNjYXBlQ2hhciA9IGZ1bmN0aW9uKG1hdGNoKSB7XHJcbiAgICAgICAgcmV0dXJuICdcXFxcJyArIGVzY2FwZXNbbWF0Y2hdO1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyBKYXZhU2NyaXB0IG1pY3JvLXRlbXBsYXRpbmcsIHNpbWlsYXIgdG8gSm9obiBSZXNpZydzIGltcGxlbWVudGF0aW9uLlxyXG4gICAgLy8gVW5kZXJzY29yZSB0ZW1wbGF0aW5nIGhhbmRsZXMgYXJiaXRyYXJ5IGRlbGltaXRlcnMsIHByZXNlcnZlcyB3aGl0ZXNwYWNlLFxyXG4gICAgLy8gYW5kIGNvcnJlY3RseSBlc2NhcGVzIHF1b3RlcyB3aXRoaW4gaW50ZXJwb2xhdGVkIGNvZGUuXHJcbiAgICAvLyBOQjogYG9sZFNldHRpbmdzYCBvbmx5IGV4aXN0cyBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXHJcbiAgICBmdW5jdGlvbiB0ZW1wbGF0ZSh0ZXh0LCBzZXR0aW5ncywgb2xkU2V0dGluZ3MpIHtcclxuICAgICAgICBpZiAoIXNldHRpbmdzICYmIG9sZFNldHRpbmdzKSBzZXR0aW5ncyA9IG9sZFNldHRpbmdzO1xyXG4gICAgICAgIHNldHRpbmdzID0gc2V0dGluZ3MgfHwge307XHJcbiAgICAgICAgc2V0dGluZ3MgPSB6clV0aWwuZGVmYXVsdHMoc2V0dGluZ3MsIHRlbXBsYXRlU2V0dGluZ3MsIHRydWUpO1xyXG5cclxuICAgICAgICAvLyBDb21iaW5lIGRlbGltaXRlcnMgaW50byBvbmUgcmVndWxhciBleHByZXNzaW9uIHZpYSBhbHRlcm5hdGlvbi5cclxuICAgICAgICB2YXIgbWF0Y2hlciA9IFJlZ0V4cChbXHJcbiAgICAgICAgICAgIChzZXR0aW5ncy5lc2NhcGUgfHwgbm9NYXRjaCkuc291cmNlLFxyXG4gICAgICAgICAgICAoc2V0dGluZ3MuaW50ZXJwb2xhdGUgfHwgbm9NYXRjaCkuc291cmNlLFxyXG4gICAgICAgICAgICAoc2V0dGluZ3MuZXZhbHVhdGUgfHwgbm9NYXRjaCkuc291cmNlXHJcbiAgICAgICAgXS5qb2luKCd8JykgKyAnfCQnLCAnZycpO1xyXG5cclxuICAgICAgICAvLyBDb21waWxlIHRoZSB0ZW1wbGF0ZSBzb3VyY2UsIGVzY2FwaW5nIHN0cmluZyBsaXRlcmFscyBhcHByb3ByaWF0ZWx5LlxyXG4gICAgICAgIHZhciBpbmRleCA9IDA7XHJcbiAgICAgICAgdmFyIHNvdXJjZSA9IFwiX19wKz0nXCI7XHJcbiAgICAgICAgdGV4dC5yZXBsYWNlKG1hdGNoZXIsIGZ1bmN0aW9uKG1hdGNoLCBlc2NhcGUsIGludGVycG9sYXRlLCBldmFsdWF0ZSwgb2Zmc2V0KSB7XHJcbiAgICAgICAgICAgIHNvdXJjZSArPSB0ZXh0LnNsaWNlKGluZGV4LCBvZmZzZXQpLnJlcGxhY2UoZXNjYXBlciwgZXNjYXBlQ2hhcik7XHJcbiAgICAgICAgICAgIGluZGV4ID0gb2Zmc2V0ICsgbWF0Y2gubGVuZ3RoO1xyXG5cclxuICAgICAgICAgICAgaWYgKGVzY2FwZSkge1xyXG4gICAgICAgICAgICAgICAgc291cmNlICs9IFwiJytcXG4oKF9fdD0oXCIgKyBlc2NhcGUgKyBcIikpPT1udWxsPycnOl8uZXNjYXBlKF9fdCkpK1xcbidcIjtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChpbnRlcnBvbGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgc291cmNlICs9IFwiJytcXG4oKF9fdD0oXCIgKyBpbnRlcnBvbGF0ZSArIFwiKSk9PW51bGw/Jyc6X190KStcXG4nXCI7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZXZhbHVhdGUpIHtcclxuICAgICAgICAgICAgICAgIHNvdXJjZSArPSBcIic7XFxuXCIgKyBldmFsdWF0ZSArIFwiXFxuX19wKz0nXCI7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIEFkb2JlIFZNcyBuZWVkIHRoZSBtYXRjaCByZXR1cm5lZCB0byBwcm9kdWNlIHRoZSBjb3JyZWN0IG9mZmVzdC5cclxuICAgICAgICAgICAgcmV0dXJuIG1hdGNoO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHNvdXJjZSArPSBcIic7XFxuXCI7XHJcblxyXG4gICAgICAgIC8vIElmIGEgdmFyaWFibGUgaXMgbm90IHNwZWNpZmllZCwgcGxhY2UgZGF0YSB2YWx1ZXMgaW4gbG9jYWwgc2NvcGUuXHJcbiAgICAgICAgaWYgKCFzZXR0aW5ncy52YXJpYWJsZSkgc291cmNlID0gJ3dpdGgob2JqfHx7fSl7XFxuJyArIHNvdXJjZSArICd9XFxuJztcclxuXHJcbiAgICAgICAgc291cmNlID0gXCJ2YXIgX190LF9fcD0nJyxfX2o9QXJyYXkucHJvdG90eXBlLmpvaW4sXCIgK1xyXG4gICAgICAgICAgICBcInByaW50PWZ1bmN0aW9uKCl7X19wKz1fX2ouY2FsbChhcmd1bWVudHMsJycpO307XFxuXCIgK1xyXG4gICAgICAgICAgICBzb3VyY2UgKyAncmV0dXJuIF9fcDtcXG4nO1xyXG5cclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICB2YXIgcmVuZGVyID0gbmV3IEZ1bmN0aW9uKHNldHRpbmdzLnZhcmlhYmxlIHx8ICdvYmonLCBzb3VyY2UpO1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgZS5zb3VyY2UgPSBzb3VyY2U7XHJcbiAgICAgICAgICAgIHRocm93IGU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgdGVtcGxhdGUgPSBmdW5jdGlvbihkYXRhKSB7XHJcbiAgICAgICAgICAgIHJldHVybiByZW5kZXIuY2FsbCh0aGlzLCBkYXRhKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvLyBQcm92aWRlIHRoZSBjb21waWxlZCBzb3VyY2UgYXMgYSBjb252ZW5pZW5jZSBmb3IgcHJlY29tcGlsYXRpb24uXHJcbiAgICAgICAgdmFyIGFyZ3VtZW50ID0gc2V0dGluZ3MudmFyaWFibGUgfHwgJ29iaic7XHJcbiAgICAgICAgdGVtcGxhdGUuc291cmNlID0gJ2Z1bmN0aW9uKCcgKyBhcmd1bWVudCArICcpe1xcbicgKyBzb3VyY2UgKyAnfSc7XHJcblxyXG4gICAgICAgIHJldHVybiB0ZW1wbGF0ZTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBpc0VtcHR5KG9iaikge1xyXG4gICAgICAgIGlmIChvYmogPT0gbnVsbCkgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgaWYgKHpyVXRpbC5pc0FycmF5TGlrZShvYmopICYmICh6clV0aWwuaXNBcnJheShvYmopIHx8IHpyVXRpbC5pc1N0cmluZyhvYmopKSkgcmV0dXJuIG9iai5sZW5ndGggPT09IDA7XHJcbiAgICB9XHJcblxyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgICAgICAgaW5oZXJpdHM6IGluaGVyaXRzLFxyXG4gICAgICAgIGdldFVVSUQ6IGdldFVVSUQsXHJcbiAgICAgICAgZGlzdGFuY2U6IGRpc3RhbmNlLFxyXG4gICAgICAgIGdldFBvbHlsaW5lTGVuZ3RoOiBnZXRQb2x5bGluZUxlbmd0aCxcclxuICAgICAgICBtYXg6IG1heCxcclxuICAgICAgICBtaW46IG1pbixcclxuICAgICAgICBpc0VtcHR5OiBpc0VtcHR5LFxyXG4gICAgICAgIG9ydGhvZ29uYWxQYXRoOiBvcnRob2dvbmFsUGF0aCxcclxuICAgICAgICBwb2x5bGluZUludGVyc2VjdHNSZWN0YW5nbGU6IHBvbHlsaW5lSW50ZXJzZWN0c1JlY3RhbmdsZSxcclxuICAgICAgICBzY29yZVBhdGg6IHNjb3JlUGF0aCxcclxuICAgICAgICBmb3J3YXJkUGF0aDogZm9yd2FyZFBhdGgsXHJcbiAgICAgICAgdHJhc2xhdGVQb2ludHM6IHRyYXNsYXRlUG9pbnRzLFxyXG4gICAgICAgIGdldEVuZFBvaW50OiBnZXRFbmRQb2ludCxcclxuICAgICAgICBnZXRDb25uZWN0b3JQb2ludHM6IGdldENvbm5lY3RvclBvaW50cyxcclxuICAgICAgICB0YW5nZW50Um90YXRpb246IHRhbmdlbnRSb3RhdGlvbixcclxuICAgICAgICBjb2xsaW5lYXJpdHk6IGNvbGxpbmVhcml0eSxcclxuICAgICAgICB0cmFuc2xhdGlvbk1hdHJpeDogdHJhbnNsYXRpb25NYXRyaXgsXHJcbiAgICAgICAgc2NhbGVNYXRyaXg6IHNjYWxlTWF0cml4LFxyXG4gICAgICAgIHJvdW5kOiBlbmhhbmNlZFJvdW5kLFxyXG4gICAgICAgIGdldExlbmd0aDogZ2V0TGVuZ3RoLFxyXG4gICAgICAgIGdldEFuZ2xlOiBnZXRBbmdsZSxcclxuICAgICAgICBnZXRSZWN0OiBnZXRSZWN0LFxyXG4gICAgICAgIFN0YWNrZWRNYXA6IFN0YWNrZWRNYXAsXHJcbiAgICAgICAgZ2V0TWF4TGluZUxlbmd0aDogZ2V0TWF4TGluZUxlbmd0aCxcclxuICAgICAgICByYW5kb21Db2xvcjogcmFuZG9tQ29sb3IsXHJcbiAgICAgICAgdGVtcGxhdGU6IHRlbXBsYXRlLFxyXG4gICAgICAgIGlzVW5kZWZpbmVkOiBpc1VuZGVmaW5lZCxcclxuICAgICAgICBnZXRTb2x0UG9pbnRzOmdldFNvbHRQb2ludHMsXHJcbiAgICAgICAgY29sbGluZWFyUmVkdWN0aW9uOiBjb2xsaW5lYXJSZWR1Y3Rpb25cclxuICAgIH07XHJcblxyXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vbGliL2Zpc2gtdG9wby1jb3JlL2xpYi91dGlsLmpzXG4gKiogbW9kdWxlIGlkID0gNzFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlxyXG5cclxuICAgIC8qKlxyXG4gICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgUG9pbnRcclxuICAgICAgKlxyXG4gICAgICAqXHJcbiAgICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgICogQHRoaXMge1BvaW50fVxyXG4gICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4IFRoZSB4IGNvb3JkaW5hdGUgb2YgcG9pbnQuXHJcbiAgICAgICogQHBhcmFtIHtOdW1iZXJ9IHkgVGhlIHkgY29vcmRpbmF0ZSBvZiBwb2ludC5cclxuICAgICAgKiBOb3RlOiBFdmVuIGlmIGl0IGlzIG5hbWVkIFBvaW50IHRoaXMgY2xhc3Mgc2hvdWxkIGJlIG5hbWVkIERvdCBhcyBEb3QgaXMgY2xvc2VyXHJcbiAgICAgICogdGhlbiBQb2ludCBmcm9tIG1hdGggcGVyc3BlY3RpdmUuXHJcbiAgICAgICoqL1xyXG4gICAgZnVuY3Rpb24gUG9pbnQoeCwgeSl7XHJcbiAgICAgICAgLyoqVGhlIHggY29vcmRpbmF0ZSBvZiBwb2ludCovXHJcbiAgICAgICAgdGhpcy54ID0geDtcclxuICAgICAgICBcclxuICAgICAgICAvKipUaGUgeSBjb29yZGluYXRlIG9mIHBvaW50Ki9cclxuICAgICAgICB0aGlzLnkgPSB5O1xyXG4gICAgICAgIFxyXG5cclxuICAgIH1cclxuXHJcbiAgICAvKipDcmVhdGVzIGEge1BvaW50fSBvdXQgb2YgSlNPTiBwYXJzZWQgb2JqZWN0XHJcbiAgICAgKkBwYXJhbSB7SlNPTk9iamVjdH0gbyAtIHRoZSBKU09OIHBhcnNlZCBvYmplY3RcclxuICAgICAqQHJldHVybiB7UG9pbnR9IGEgbmV3bHkgY29uc3RydWN0ZWQgUG9pbnRcclxuICAgICAqKi9cclxuICAgIFBvaW50LmxvYWQgPSBmdW5jdGlvbihvKXtcclxuICAgICAgICB2YXIgbmV3UG9pbnQgPSBuZXcgUG9pbnQoTnVtYmVyKG8ueCksIE51bWJlcihvLnkpKTtcclxuICAgICAgICByZXR1cm4gbmV3UG9pbnQ7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKipDcmVhdGVzIGFuIGFycmF5IG9mIHBvaW50cyBmcm9tIGFuIGFycmF5IG9mIHtKU09OT2JqZWN0fXNcclxuICAgICAqQHBhcmFtIHtBcnJheX0gdiAtIHRoZSBhcnJheSBvZiBKU09OT2JqZWN0c1xyXG4gICAgICpAcmV0dXJuIGFuIHtBcnJheX0gb2Yge1BvaW50fXNcclxuICAgICAqKi9cclxuICAgIFBvaW50LmxvYWRBcnJheSA9IGZ1bmN0aW9uKHYpe1xyXG4gICAgICAgIHZhciBuZXdQb2ludHMgPSBbXTtcclxuICAgICAgICBmb3IodmFyIGk9MDsgaTwgdi5sZW5ndGg7IGkrKyl7XHJcbiAgICAgICAgICAgIG5ld1BvaW50cy5wdXNoKFBvaW50LmxvYWQodltpXSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3UG9pbnRzO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLyoqQ2xvbmVzIGFuIGFycmF5IG9mIHBvaW50c1xyXG4gICAgICpAcGFyYW0ge0FycmF5fSB2IC0gdGhlIGFycmF5IG9mIHtQb2ludH1zXHJcbiAgICAgKkByZXR1cm4gYW4ge0FycmF5fSBvZiB7UG9pbnR9c1xyXG4gICAgICoqL1xyXG4gICAgUG9pbnQuY2xvbmVBcnJheSA9IGZ1bmN0aW9uKHYpe1xyXG4gICAgICAgIHZhciBuZXdQb2ludHMgPSBbXTtcclxuICAgICAgICBmb3IodmFyIGk9MDsgaTwgdi5sZW5ndGg7IGkrKyl7XHJcbiAgICAgICAgICAgIG5ld1BvaW50cy5wdXNoKHZbaV0uY2xvbmUoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXdQb2ludHM7XHJcbiAgICB9O1xyXG5cclxuICAgIFBvaW50LnByb3RvdHlwZSA9IHtcclxuICAgICAgICBjb25zdHJ1Y3RvciA6IFBvaW50LFxyXG4gICAgICAgIFxyXG4gICAgICAgIHRyYW5zZm9ybTpmdW5jdGlvbihtYXRyaXgpe1xyXG4gICAgICAgICAgICB2YXIgb2xkWCA9IHRoaXMueDtcclxuICAgICAgICAgICAgdmFyIG9sZFkgPSB0aGlzLnk7XHJcbiAgICAgICAgICAgIHRoaXMueCA9IG1hdHJpeFswXVswXSAqIG9sZFggKyBtYXRyaXhbMF1bMV0gKiBvbGRZICsgbWF0cml4WzBdWzJdO1xyXG4gICAgICAgICAgICB0aGlzLnkgPSBtYXRyaXhbMV1bMF0gKiBvbGRYICsgbWF0cml4WzFdWzFdICogb2xkWSArIG1hdHJpeFsxXVsyXTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIFxyXG4gICAgICAgIC8qKlRlc3RzIGlmIHRoaXMgcG9pbnQgaXMgc2ltaWxhciB0byBvdGhlciBwb2ludFxyXG4gICAgICAgICAqQHBhcmFtIHtQb2ludH0gYW5vdGhlclBvaW50IC0gdGhlIG90aGVyIHBvaW50XHJcbiAgICAgICAgICoqL1xyXG4gICAgICAgIGVxdWFsczpmdW5jdGlvbihhbm90aGVyUG9pbnQpe1xyXG4gICAgICAgICAgICBpZighIChhbm90aGVyUG9pbnQgaW5zdGFuY2VvZiBQb2ludCkgKXtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gKHRoaXMueCA9PSBhbm90aGVyUG9pbnQueClcclxuICAgICAgICAgICAgJiYgKHRoaXMueSA9PSBhbm90aGVyUG9pbnQueSlcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipDbG9uZSBjdXJyZW50IFBvaW50XHJcbiAgICAgICAgICoqL1xyXG4gICAgICAgIGNsb25lOiBmdW5jdGlvbigpe1xyXG4gICAgICAgICAgICB2YXIgbmV3UG9pbnQgPSBuZXcgUG9pbnQodGhpcy54LCB0aGlzLnkpO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3UG9pbnQ7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqVGVzdHMgdG8gc2VlIGlmIGEgcG9pbnQgKHgsIHkpIGlzIHdpdGhpbiBhIHJhbmdlIG9mIGN1cnJlbnQgUG9pbnRcclxuICAgICAgICAgKkBwYXJhbSB7TnVtZXJpY30geCAtIHRoZSB4IGNvb3JkaW5hdGUgb2YgdGVzdGVkIHBvaW50XHJcbiAgICAgICAgICpAcGFyYW0ge051bWVyaWN9IHkgLSB0aGUgeCBjb29yZGluYXRlIG9mIHRlc3RlZCBwb2ludFxyXG4gICAgICAgICAqQHBhcmFtIHtOdW1lcmljfSByYWRpdXMgLSB0aGUgcmFkaXVzIG9mIHRoZSB2aWNpbml0eVxyXG4gICAgICAgICAqKi9cclxuICAgICAgICBuZWFyOmZ1bmN0aW9uKHgsIHksIHJhZGl1cyl7XHJcbiAgICAgICAgICAgIHZhciBkaXN0YW5jZSA9IE1hdGguc3FydChNYXRoLnBvdyh0aGlzLnggLSB4LCAyKSArIE1hdGgucG93KHRoaXMueSAtIHksIDIpKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiAoZGlzdGFuY2UgPD0gcmFkaXVzKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBjb250YWluczogZnVuY3Rpb24oeCx5KXtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMueCA9PSB4ICYmIHRoaXMueSA9PSB5O1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHRvU3RyaW5nOmZ1bmN0aW9uKCl7XHJcbiAgICAgICAgICAgIHJldHVybiAnWycgKyB0aGlzLnggKyAnLCcgKyB0aGlzLnkgKyAnXSc7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgZ2V0UG9pbnRzOmZ1bmN0aW9uKCl7XHJcbiAgICAgICAgICAgIHJldHVybiBbdGhpc107XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIG1vZHVsZS5leHBvcnRzID0gUG9pbnQ7XHJcbiAgICBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vbGliL2Zpc2gtdG9wby1jb3JlL2xpYi9Qb2ludC5qc1xuICoqIG1vZHVsZSBpZCA9IDcyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcclxuXHJcbiAgICAvKipcclxuICAgICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIGEgTGluZS4gQSBMaW5lIGlzIGFjdHVhbGx5IGEgc2VnbWVudCBhbmQgbm90IGEgcHVyZVxyXG4gICAgICAqIGdlb21ldHJpY2FsIExpbmVcclxuICAgICAgKlxyXG4gICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICAqIEB0aGlzIHtMaW5lfVxyXG4gICAgICAqIEBwYXJhbSB7UG9pbnR9IHN0YXJ0UG9pbnQgLSBzdGFydGluZyBwb2ludCBvZiB0aGUgbGluZVxyXG4gICAgICAqIEBwYXJhbSB7UG9pbnR9IGVuZFBvaW50IC0gdGhlIGVuZGluZyBwb2ludCBvZiB0aGUgbGluZVxyXG4gICAgICAqKi9cclxuICAgIGZ1bmN0aW9uIExpbmUoc3RhcnRQb2ludCwgZW5kUG9pbnQpe1xyXG4gICAgICAgIC8qKlN0YXJ0aW5nIHtAbGluayBQb2ludH0gb2YgdGhlIGxpbmUqL1xyXG4gICAgICAgIHRoaXMuc3RhcnRQb2ludCA9IHN0YXJ0UG9pbnQ7XHJcblxyXG4gICAgICAgIC8qKkVuZGluZyB7QGxpbmsgUG9pbnR9IG9mIHRoZSBsaW5lKi9cclxuICAgICAgICB0aGlzLmVuZFBvaW50ID0gZW5kUG9pbnQ7XHJcblxyXG4gICAgICAgIC8qKlNlcmlhbGl6YXRpb24gdHlwZSovXHJcbiAgICAgICAgdGhpcy5vVHlwZSA9ICdMaW5lJzsgLy9vYmplY3QgdHlwZSB1c2VkIGZvciBKU09OIGRlc2VyaWFsaXphdGlvblxyXG4gICAgfVxyXG5cclxuICAgIC8qKkNyZWF0ZXMgYSB7TGluZX0gb3V0IG9mIEpTT04gcGFyc2VkIG9iamVjdFxyXG4gICAgICpAcGFyYW0ge0pTT05PYmplY3R9IG8gLSB0aGUgSlNPTiBwYXJzZWQgb2JqZWN0XHJcbiAgICAgKkByZXR1cm4ge0xpbmV9IGEgbmV3bHkgY29uc3RydWN0ZWQgTGluZVxyXG4gICAgICoqL1xyXG4gICAgTGluZS5sb2FkID0gZnVuY3Rpb24obyl7XHJcbiAgICAgICAgdmFyIG5ld0xpbmUgPSBuZXcgTGluZShcclxuICAgICAgICAgICAgUG9pbnQubG9hZChvLnN0YXJ0UG9pbnQpLFxyXG4gICAgICAgICAgICBQb2ludC5sb2FkKG8uZW5kUG9pbnQpXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIG5ld0xpbmU7XHJcbiAgICB9O1xyXG5cclxuICAgIExpbmUucHJvdG90eXBlID0ge1xyXG4gICAgICAgIGNvbnRydWN0b3I6IExpbmUsXHJcblxyXG5cclxuXHJcbiAgICAgICAgY2xvbmU6ZnVuY3Rpb24oKXtcclxuICAgICAgICAgICAgdmFyIHJldCA9IG5ldyBMaW5lKHRoaXMuc3RhcnRQb2ludC5jbG9uZSgpLCB0aGlzLmVuZFBvaW50LmNsb25lKCkpO1xyXG4gICAgICAgICAgICByZXR1cm4gcmV0O1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGVxdWFsczpmdW5jdGlvbihhbm90aGVyTGluZSl7XHJcbiAgICAgICAgICAgIGlmKCFhbm90aGVyTGluZSBpbnN0YW5jZW9mIExpbmUpe1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0YXJ0UG9pbnQuZXF1YWxzKGFub3RoZXJMaW5lLnN0YXJ0UG9pbnQpXHJcbiAgICAgICAgICAgICYmIHRoaXMuZW5kUG9pbnQuZXF1YWxzKGFub3RoZXJMaW5lLmVuZFBvaW50KVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKiBUZXN0cyB0byBzZWUgaWYgYSBwb2ludCBiZWxvbmdzIHRvIHRoaXMgbGluZSAobm90IGFzIGluZmluaXRlIGxpbmUgYnV0IG1vcmUgbGlrZSBhIHNlZ21lbnQpXHJcbiAgICAgICAgICogQWxnb3JpdGhtOiBDb21wdXRlIGxpbmUncyBlcXVhdGlvbiBhbmQgc2VlIGlmICh4LCB5KSB2ZXJpZmllcyBpdC5cclxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0geCAtIHRoZSBYIGNvb3JkaW5hdGVzXHJcbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IHkgLSB0aGUgWSBjb29yZGluYXRlc1xyXG4gICAgICAgICAqKi9cclxuICAgICAgICBjb250YWluczogZnVuY3Rpb24oeCwgeSl7XHJcbiAgICAgICAgICAgIC8vIGlmIHRoZSBwb2ludCBpcyBpbnNpZGUgcmVjdGFuZ2xlIGJvdW5kcyBvZiB0aGUgc2VnbWVudFxyXG4gICAgICAgICAgICBpZiAoTWF0aC5taW4odGhpcy5zdGFydFBvaW50LngsIHRoaXMuZW5kUG9pbnQueCkgPD0geFxyXG4gICAgICAgICAgICAgICAgJiYgeCA8PSBNYXRoLm1heCh0aGlzLnN0YXJ0UG9pbnQueCwgdGhpcy5lbmRQb2ludC54KVxyXG4gICAgICAgICAgICAgICAgJiYgTWF0aC5taW4odGhpcy5zdGFydFBvaW50LnksIHRoaXMuZW5kUG9pbnQueSkgPD0geVxyXG4gICAgICAgICAgICAgICAgJiYgeSA8PSBNYXRoLm1heCh0aGlzLnN0YXJ0UG9pbnQueSwgdGhpcy5lbmRQb2ludC55KSkge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIGNoZWNrIGZvciB2ZXJ0aWNhbCBsaW5lXHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zdGFydFBvaW50LnggPT0gdGhpcy5lbmRQb2ludC54KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHggPT0gdGhpcy5zdGFydFBvaW50Lng7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgeyAvLyB1c3VhbCAobm90IHZlcnRpY2FsKSBsaW5lIGNhbiBiZSByZXByZXNlbnRlZCBhcyB5ID0gYSAqIHggKyBiXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGEgPSAodGhpcy5lbmRQb2ludC55IC0gdGhpcy5zdGFydFBvaW50LnkpIC8gKHRoaXMuZW5kUG9pbnQueCAtIHRoaXMuc3RhcnRQb2ludC54KTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYiA9IHRoaXMuc3RhcnRQb2ludC55IC0gYSAqIHRoaXMuc3RhcnRQb2ludC54O1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB5ID09IGEgKiB4ICsgYjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qXHJcbiAgICAgICAgICpTZWUgaWYgd2UgYXJlIG5lYXIgYSB7TGluZX0gYnkgYSBjZXJ0YWluIHJhZGl1cyAoYWxzbyBpbmNsdWRlcyB0aGUgZXh0cmVtaXRpZXMgaW50byBjb21wdXRhdGlvbilcclxuICAgICAgICAgKkBwYXJhbSB7TnVtYmVyfSB4IC0gdGhlIHggY29vcmRpbmF0ZXNcclxuICAgICAgICAgKkBwYXJhbSB7TnVtYmVyfSB5IC0gdGhlIHkgY29vcmRpbmF0ZXNcclxuICAgICAgICAgKkBwYXJhbSB7TnVtYmVyfSByYWRpdXMgLSB0aGUgcmFkaXVzIHRvIHNlYXJjaCBmb3JcclxuICAgICAgICAgKkBzZWUgaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9EaXN0YW5jZV9mcm9tX2FfcG9pbnRfdG9fYV9saW5lXHJcbiAgICAgICAgICpAc2VlIFwiTWF0aGVtYXRpY3MgZm9yIENvbXB1dGVyIEdyYXBoaWNzLCAybmQgRWQuLCBieSBKb2huIFZpY2UsIHBhZ2UgMjI3XCJcclxuICAgICAgICAgKiovXHJcbiAgICAgICAgbmVhcjpmdW5jdGlvbih4LHkscmFkaXVzKXtcclxuXHJcbiAgICAgICAgICAgIGlmKHRoaXMuZW5kUG9pbnQueCA9PT0gdGhpcy5zdGFydFBvaW50LngpeyAvL1ZlcnRpY2FsIGxpbmUsIHNvIHRoZSB2aWNpbml0eSBhcmVhIGlzIGEgcmVjdGFuZ2xlXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKCAodGhpcy5zdGFydFBvaW50LnktcmFkaXVzPD15ICYmIHRoaXMuZW5kUG9pbnQueStyYWRpdXM+PXkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHx8ICh0aGlzLmVuZFBvaW50LnktcmFkaXVzPD15ICYmIHRoaXMuc3RhcnRQb2ludC55K3JhZGl1cz49eSkpXHJcbiAgICAgICAgICAgICAgICAmJiB4ID4gdGhpcy5zdGFydFBvaW50LnggLSByYWRpdXMgJiYgeCA8IHRoaXMuc3RhcnRQb2ludC54ICsgcmFkaXVzIDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYodGhpcy5zdGFydFBvaW50LnkgPT09IHRoaXMuZW5kUG9pbnQueSl7IC8vSG9yaXpvbnRhbCBsaW5lLCBzbyB0aGUgdmljaW5pdHkgYXJlYSBpcyBhIHJlY3RhbmdsZVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuICggKHRoaXMuc3RhcnRQb2ludC54IC0gcmFkaXVzPD14ICYmIHRoaXMuZW5kUG9pbnQueCtyYWRpdXM+PXgpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHx8ICh0aGlzLmVuZFBvaW50LngtcmFkaXVzPD14ICYmIHRoaXMuc3RhcnRQb2ludC54K3JhZGl1cz49eCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICYmIHk+dGhpcy5zdGFydFBvaW50LnktcmFkaXVzICYmIHk8dGhpcy5zdGFydFBvaW50LnkrcmFkaXVzIDtcclxuICAgICAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgICAgIHZhciBzdGFydFggPSBNYXRoLm1pbih0aGlzLmVuZFBvaW50LngsdGhpcy5zdGFydFBvaW50LngpO1xyXG4gICAgICAgICAgICB2YXIgc3RhcnRZID0gTWF0aC5taW4odGhpcy5lbmRQb2ludC55LHRoaXMuc3RhcnRQb2ludC55KTtcclxuICAgICAgICAgICAgdmFyIGVuZFggPSBNYXRoLm1heCh0aGlzLmVuZFBvaW50LngsdGhpcy5zdGFydFBvaW50LngpO1xyXG4gICAgICAgICAgICB2YXIgZW5kWSA9IE1hdGgubWF4KHRoaXMuZW5kUG9pbnQueSx0aGlzLnN0YXJ0UG9pbnQueSk7XHJcblxyXG4gICAgICAgICAgICAvKldlIHdpbGwgY29tcHV0ZSB0aGUgZGlzdGFuY2UgZnJvbSBwb2ludCB0byB0aGUgbGluZVxyXG4gICAgICAgICAgICAgKiBieSB1c2luZyB0aGUgYWxnb3JpdGhtIGZyb21cclxuICAgICAgICAgICAgICogaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9EaXN0YW5jZV9mcm9tX2FfcG9pbnRfdG9fYV9saW5lXHJcbiAgICAgICAgICAgICAqICovXHJcblxyXG4gICAgICAgICAgICAvL0ZpcnN0IHdlIG5lZWQgdG8gZmluZCBhLGIsYyBvZiB0aGUgbGluZSBlcXVhdGlvbiBheCArIGJ5ICsgYyA9IDBcclxuICAgICAgICAgICAgdmFyIGEgPSB0aGlzLmVuZFBvaW50LnkgLSB0aGlzLnN0YXJ0UG9pbnQueTtcclxuICAgICAgICAgICAgdmFyIGIgPSB0aGlzLnN0YXJ0UG9pbnQueCAtIHRoaXMuZW5kUG9pbnQueDtcclxuICAgICAgICAgICAgdmFyIGMgPSAtKHRoaXMuc3RhcnRQb2ludC54ICogdGhpcy5lbmRQb2ludC55IC0gdGhpcy5lbmRQb2ludC54ICogdGhpcy5zdGFydFBvaW50LnkpO1xyXG5cclxuICAgICAgICAgICAgLy9TZWNvbmRseSB3ZSBnZXQgdGhlIGRpc3RhbmNlIFwiTWF0aGVtYXRpY3MgZm9yIENvbXB1dGVyIEdyYXBoaWNzLCAybmQgRWQuLCBieSBKb2huIFZpY2UsIHBhZ2UgMjI3XCJcclxuICAgICAgICAgICAgdmFyIGQgPSBNYXRoLmFicyggKGEqeCArIGIqeSArIGMpIC8gTWF0aC5zcXJ0KE1hdGgucG93KGEsMikgKyBNYXRoLnBvdyhiLDIpKSApO1xyXG5cclxuICAgICAgICAgICAgLy9UaGlyZGx5IHdlIGdldCBjb29yZGluYXRlcyBvZiBjbG9zZXN0IGxpbmUncyBwb2ludCB0byB0YXJnZXQgcG9pbnRcclxuICAgICAgICAgICAgLy9odHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Rpc3RhbmNlX2Zyb21fYV9wb2ludF90b19hX2xpbmUjQ2FydGVzaWFuX2Nvb3JkaW5hdGVzXHJcbiAgICAgICAgICAgIHZhciBjbG9zZXN0WCA9IChiICogKGIqeCAtIGEqeSkgLSBhKmMpIC8gKCBNYXRoLnBvdyhhLDIpICsgTWF0aC5wb3coYiwyKSApO1xyXG4gICAgICAgICAgICB2YXIgY2xvc2VzdFkgPSAoYSAqICgtYip4ICsgYSp5KSAtIGIqYykgLyAoIE1hdGgucG93KGEsMikgKyBNYXRoLnBvdyhiLDIpICk7XHJcblxyXG4gICAgICAgICAgICB2YXIgciA9ICggZCA8PSByYWRpdXMgJiYgZW5kWD49Y2xvc2VzdFggJiYgY2xvc2VzdFg+PXN0YXJ0WCAmJiBlbmRZPj1jbG9zZXN0WSAmJiBjbG9zZXN0WT49c3RhcnRZICkgLy90aGUgcHJvamVjdGlvbiBvZiB0aGUgcG9pbnQgZmFsbHMgSU5TSURFIG9mIHRoZSBzZWdtZW50XHJcbiAgICAgICAgICAgICAgICB8fCB0aGlzLnN0YXJ0UG9pbnQubmVhcih4LHkscmFkaXVzKSB8fCB0aGlzLmVuZFBvaW50Lm5lYXIoeCx5LHJhZGl1cyk7IC8vdGhlIHByb2plY3Rpb24gb2YgdGhlIHBvaW50IGZhbGxzIE9VVFNJREUgb2YgdGhlIHNlZ21lbnRcclxuXHJcbiAgICAgICAgICAgIHJldHVybiAgcjtcclxuXHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqd2UgbmVlZCB0byBjcmVhdGUgYSBuZXcgYXJyYXkgZWFjaCB0aW1lLCBvciB3ZSB3aWxsIGFmZmVjdCB0aGUgYWN0dWFsIHNoYXBlKi9cclxuICAgICAgICBnZXRQb2ludHM6ZnVuY3Rpb24oKXtcclxuICAgICAgICAgICAgdmFyIHBvaW50cyA9IFtdO1xyXG4gICAgICAgICAgICBwb2ludHMucHVzaCh0aGlzLnN0YXJ0UG9pbnQpO1xyXG4gICAgICAgICAgICBwb2ludHMucHVzaCh0aGlzLmVuZFBvaW50KTtcclxuICAgICAgICAgICAgcmV0dXJuIHBvaW50cztcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipSZXR1cm4gdGhlIHtQb2ludH0gY29ycmVzcG9uZGluZyB0aGUgdCBjZXJ0YWluIHQgdmFsdWVcclxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gdCB0aGUgdmFsdWUgb2YgcGFyYW1ldGVyIHQsIHdoZXJlIHQgaW4gWzAsMV0sIHQgaXMgbGlrZSBhIHBlcmNlbnQqL1xyXG4gICAgICAgIGdldFBvaW50OiBmdW5jdGlvbih0KXtcclxuICAgICAgICAgICAgdmFyIFhwID0gdCAqICh0aGlzLmVuZFBvaW50LnggLSB0aGlzLnN0YXJ0UG9pbnQueCkgKyB0aGlzLnN0YXJ0UG9pbnQueDtcclxuICAgICAgICAgICAgdmFyIFlwID0gdCAqICh0aGlzLmVuZFBvaW50LnkgLSB0aGlzLnN0YXJ0UG9pbnQueSkgKyB0aGlzLnN0YXJ0UG9pbnQueTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQoWHAsIFlwKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvLyAvKipcclxuICAgICAgICAvLyAgKiBSZXR1cm5zIHRoZSBtaWRkbGUgb2YgdGhlIGxpbmVcclxuICAgICAgICAvLyAgKiBAcmV0dXJuIHtQb2ludH0gdGhlIG1pZGRsZSBwb2ludFxyXG4gICAgICAgIC8vICAqICovXHJcbiAgICAgICAgLy8gZ2V0TWlkZGxlIDogZnVuY3Rpb24oKXtcclxuICAgICAgICAvLyAgICAgcmV0dXJuIFV0aWwuZ2V0TWlkZGxlKHRoaXMuc3RhcnRQb2ludCwgdGhpcy5lbmRQb2ludCk7XHJcbiAgICAgICAgLy8gfSxcclxuXHJcblxyXG4gICAgICAgIC8vIGdldExlbmd0aCA6IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgLy8gICAgIHJldHVybiBVdGlsLmdldExlbmd0aCh0aGlzLnN0YXJ0UG9pbnQsIHRoaXMuZW5kUG9pbnQpO1xyXG4gICAgICAgIC8vIH0sXHJcblxyXG4gICAgICAgIC8vIC8qKlxyXG4gICAgICAgIC8vICAqR2V0IGJvdW5kcyBmb3IgdGhpcyBsaW5lXHJcbiAgICAgICAgLy8gICpAYXV0aG9yIEFsZXggR2hlb3JnaGl1IDxhbGV4QHNjcmlwdG9pZC5jb20+XHJcbiAgICAgICAgLy8gICoqL1xyXG4gICAgICAgIC8vIGdldEJvdW5kczpmdW5jdGlvbigpe1xyXG4gICAgICAgIC8vICAgICByZXR1cm4gVXRpbC5nZXRCb3VuZHModGhpcy5nZXRQb2ludHMoKSk7XHJcbiAgICAgICAgLy8gfSxcclxuXHJcbiAgICAgICAgLyoqU3RyaW5nIHJlcHJlc2VudGF0aW9uKi9cclxuICAgICAgICB0b1N0cmluZzpmdW5jdGlvbigpe1xyXG4gICAgICAgICAgICByZXR1cm4gJ2xpbmUoJyArIHRoaXMuc3RhcnRQb2ludCArICcsJyArIHRoaXMuZW5kUG9pbnQgKyAnKSc7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIG1vZHVsZS5leHBvcnRzID0gTGluZTtcclxuXHJcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9saWIvZmlzaC10b3BvLWNvcmUvbGliL0xpbmVTdHJ1Y3QuanNcbiAqKiBtb2R1bGUgaWQgPSA3M1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXHJcbiAqIE5ldHdvcmsgbW9kZWxcclxuICpcclxuICovXHJcblxyXG5cclxuICAgIHZhciBNb2RlbCA9IHJlcXVpcmUoJy4uLy4uLy4uL2Zpc2gtdG9wby1jb3JlL2xpYi9Nb2RlbCcpO1xyXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xyXG5cclxuICAgIHZhciBOZXR3b3JrTW9kZWwgPSBNb2RlbC5leHRlbmQoe1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEB0eXBlIHtPYmplY3R9XHJcbiAgICAgICAgICogQHByb3RlY3RlZFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGRlZmF1bHRPcHRpb246IHtcclxuICAgICAgICBcdHJlc291cmNlSWQ6IFwiXCIsICAvL+i1hOa6kElEXHJcbiAgICAgICAgICAgIHByb3BlcnRpZXM6IHtcclxuICAgICAgICAgICAgICAgIHR5cGU6IC0xLCAgLy/nsbvlnotcclxuICAgICAgICAgICAgICAgIG5hbWU6IFwiXCIsIC8v5ZCN56ewXHJcbiAgICAgICAgICAgICAgICBub3RlczogXCJcIiwgIC8v5aSH5rOoXHJcbiAgICAgICAgICAgICAgICAvL25vOiBcIlwiXHJcbiAgICAgICAgICAgICAgICBleHRQcm9wZXJ0aWVzOiB7XHJcbiAgICAgICAgICAgICAgICB9LCAgLy/mianlsZXlsZ7mgKdcclxuICAgICAgICAgICAgICAgIGJvdW5kczoge1xyXG4gICAgICAgICAgICAgICAgICAgIHVwcGVyTGVmdDoge3g6IDAsIHk6IDB9LCAgLy/lt6bkuIrop5LlnZDmoIdcclxuICAgICAgICAgICAgICAgICAgICBsb3dlclJpZ2h0OiB7eDogMCwgeTogMH0gLy/lj7PkuIvop5LlnZDmoIdcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgc3RlbmNpbDoge3R5cGU6IFwiTmV4dHdvcmtOb2RlXCJ9LFxyXG4gICAgICAgICAgICBzaG93VGlwOiBmYWxzZVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGluaXQ6IGZ1bmN0aW9uIChvcHRpb24sIHBhcmVudE1vZGVsLCBleHRyYU9wdCkge1xyXG4gICAgICAgICAgICB6clV0aWwubWVyZ2Uob3B0aW9uLCB0aGlzLmdldERlZmF1bHRPcHRpb24oKSk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgZ2V0RGVmYXVsdE9wdGlvbjogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuaGFzT3duUHJvcGVydHkoJ19fZGVmYXVsdE9wdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgb3B0TGlzdCA9IFtdO1xyXG4gICAgICAgICAgICAgICAgdmFyIENsYXNzID0gdGhpcy5jb25zdHJ1Y3RvcjtcclxuICAgICAgICAgICAgICAgIHdoaWxlIChDbGFzcykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBvcHQgPSBDbGFzcy5wcm90b3R5cGUuZGVmYXVsdE9wdGlvbjtcclxuICAgICAgICAgICAgICAgICAgICBvcHQgJiYgb3B0TGlzdC5wdXNoKG9wdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgQ2xhc3MgPSBDbGFzcy5zdXBlckNsYXNzO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHZhciBkZWZhdWx0T3B0aW9uID0ge307XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gb3B0TGlzdC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHRPcHRpb24gPSB6clV0aWwubWVyZ2UoZGVmYXVsdE9wdGlvbiwgb3B0TGlzdFtpXSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9fZGVmYXVsdE9wdGlvbiA9IGRlZmF1bHRPcHRpb247XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX19kZWZhdWx0T3B0aW9uO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9KTtcclxuICAgIG1vZHVsZS5leHBvcnRzID0gTmV0d29ya01vZGVsO1xyXG5cclxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2xpYi9maXNoLXRvcG8tbmV0d29yay9saWIvbW9kZWwvTmV0d29ya01vZGVsLmpzXG4gKiogbW9kdWxlIGlkID0gNzRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxyXG4gKiDoioLngrnnrYnnmoTmqKHlnotcclxuICog6YeM6Z2i5a2Y55qE5pWw5o2u55So5p2l5aSE55CG5bqP5YiX5YyW5ZKM5Y+N5bqP5YiX5YyWXHJcbiAqIEBjbGFzcyBmaXNoLnRvcG8ubW9kZWxcclxuICovXHJcblxyXG5cclxuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcclxuICAgIHZhciBjbGF6elV0aWwgPSByZXF1aXJlKCcuL2NsYXp6Jyk7XHJcblxyXG4gICAgZnVuY3Rpb24gTW9kZWwob3B0aW9uLCBwYXJlbnRNb2RlbCwgIGV4dHJhT3B0KSB7XHJcbiAgICAgICAgdGhpcy5wYXJlbnRNb2RlbCA9IHBhcmVudE1vZGVsO1xyXG4gICAgICAgIHRoaXMub3B0aW9uID0gb3B0aW9uO1xyXG5cclxuICAgICAgICAvLyBTaW1wbGUgb3B0aW1pemF0aW9uXHJcbiAgICAgICAgaWYgKHRoaXMuaW5pdCkge1xyXG4gICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8PSAzKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmluaXQob3B0aW9uLCBwYXJlbnRNb2RlbCwgIGV4dHJhT3B0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuaW5pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIE1vZGVsLnByb3RvdHlwZSA9IHtcclxuXHJcbiAgICAgICAgY29uc3RydWN0b3I6IE1vZGVsLFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBNb2RlbCDnmoTliJ3lp4vljJblh73mlbBcclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25cclxuICAgICAgICAgKi9cclxuICAgICAgICBpbml0OiBmdW5jdGlvbiAob3B0aW9uKSB7XHJcbiAgICAgICAgICAgIHpyVXRpbC5tZXJnZShvcHRpb24sIHRoaXMuZ2V0RGVmYXVsdE9wdGlvbigpKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBnZXREZWZhdWx0T3B0aW9uOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5oYXNPd25Qcm9wZXJ0eSgnX19kZWZhdWx0T3B0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgIHZhciBvcHRMaXN0ID0gW107XHJcbiAgICAgICAgICAgICAgICB2YXIgQ2xhc3MgPSB0aGlzLmNvbnN0cnVjdG9yO1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKENsYXNzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9wdCA9IENsYXNzLnByb3RvdHlwZS5kZWZhdWx0T3B0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgIG9wdCAmJiBvcHRMaXN0LnB1c2gob3B0KTtcclxuICAgICAgICAgICAgICAgICAgICBDbGFzcyA9IENsYXNzLnN1cGVyQ2xhc3M7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGRlZmF1bHRPcHRpb24gPSB7fTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSBvcHRMaXN0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdE9wdGlvbiA9IHpyVXRpbC5tZXJnZShkZWZhdWx0T3B0aW9uLCBvcHRMaXN0W2ldLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuX19kZWZhdWx0T3B0aW9uID0gZGVmYXVsdE9wdGlvbjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fX2RlZmF1bHRPcHRpb247XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKi9cclxuICAgICAgICBtZXJnZU9wdGlvbjogZnVuY3Rpb24gKG9wdGlvbikge1xyXG4gICAgICAgICAgICB6clV0aWwubWVyZ2UodGhpcy5vcHRpb24sIG9wdGlvbiwgdHJ1ZSk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICog6I635Y+WbW9kZWznmoTmn5DkuKrlsZ7mgKfnmoTlgLxcclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBtb2RlbOS4reeahOWxnuaAp1xyXG4gICAgICAgICAqIEByZXR1cm4ge1N0cmluZ31cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICoq5L2/55So6IyD5L6LKirvvJpcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICAgQGV4YW1wbGVcclxuICAgICAgICAgKiAgICAgICAgICBub2RlLm1vZGVsLmdldChcIm9wdGlvbnMudGV4dFwiKTtcclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIChwYXRoLCBpZ25vcmVQYXJlbnQpIHtcclxuICAgICAgICAgICAgaWYgKCFwYXRoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vcHRpb247XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcGF0aCA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgICAgIHBhdGggPSBwYXRoLnNwbGl0KCcuJyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBvYmogPSB0aGlzLm9wdGlvbjtcclxuICAgICAgICAgICAgdmFyIHBhcmVudE1vZGVsID0gdGhpcy5wYXJlbnRNb2RlbDtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRoLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBvYmogY291bGQgYmUgbnVtYmVyL3N0cmluZy8uLi4gKGxpa2UgMClcclxuICAgICAgICAgICAgICAgIG9iaiA9IChvYmogJiYgdHlwZW9mIG9iaiA9PT0gJ29iamVjdCcpID8gb2JqW3BhdGhbaV1dIDogbnVsbDtcclxuICAgICAgICAgICAgICAgIGlmIChvYmogPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChvYmogPT0gbnVsbCAmJiBwYXJlbnRNb2RlbCAmJiAhaWdub3JlUGFyZW50KSB7XHJcbiAgICAgICAgICAgICAgICBvYmogPSBwYXJlbnRNb2RlbC5nZXQocGF0aCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG9iajtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiDorr7nva5tb2RlbOeahOafkOS4quWxnuaAp+eahOWAvFxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIG1vZGVs5Lit55qE5bGe5oCnXHJcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlIOaJgOmcgOimgeiuvue9rueahOWAvFxyXG4gICAgICAgICAqIEByZXR1cm4ge1N0cmluZ31cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICoq5L2/55So6IyD5L6LKirvvJpcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICAgQGV4YW1wbGVcclxuICAgICAgICAgKiAgICAgICAgICBub2RlLm1vZGVsLnNldChcIm9wdGlvbnMudGV4dFwiLFwi5L6L5a2QXCIpO1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHBhdGgsIHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHZhciBvYmogPSB0aGlzLm9wdGlvbjtcclxuXHJcbiAgICAgICAgICAgIGlmIChwYXRoLmluZGV4T2YoXCIuXCIpID09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICBvYmpbcGF0aF0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHZhciBmaWVsZEFycmF5ICA9IHBhdGguc3BsaXQoJy4nKTtcclxuICAgICAgICAgICAgICAgIHZhciBuID0gZmllbGRBcnJheS5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICB2YXIgY3VycmVudFJlZiA9IG9iajtcclxuICAgICAgICAgICAgICAgIHZhciBmaWVsZE5hbWU7XHJcblxyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuIC0gMTsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZmllbGROYW1lID0gZmllbGRBcnJheVtpXTtcclxuICAgICAgICAgICAgICAgICAgICBpZihjdXJyZW50UmVmW2ZpZWxkTmFtZV0gPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50UmVmW2ZpZWxkTmFtZV0gPSB7fTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFJlZiA9IGN1cnJlbnRSZWZbZmllbGROYW1lXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGZpZWxkTmFtZSA9IGZpZWxkQXJyYXlbbi0xXTtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRSZWZbZmllbGROYW1lXSA9IHZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXRTaGFsbG93OiBmdW5jdGlvbiAoa2V5LCBpZ25vcmVQYXJlbnQpIHtcclxuICAgICAgICAgICAgdmFyIG9wdGlvbiA9IHRoaXMub3B0aW9uO1xyXG4gICAgICAgICAgICB2YXIgdmFsID0gb3B0aW9uICYmIG9wdGlvbltrZXldO1xyXG4gICAgICAgICAgICB2YXIgcGFyZW50TW9kZWwgPSB0aGlzLnBhcmVudE1vZGVsO1xyXG4gICAgICAgICAgICBpZiAodmFsID09IG51bGwgJiYgcGFyZW50TW9kZWwgJiYgIWlnbm9yZVBhcmVudCkge1xyXG4gICAgICAgICAgICAgICAgdmFsID0gcGFyZW50TW9kZWwuZ2V0U2hhbGxvdyhrZXkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB2YWw7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXRNb2RlbDogZnVuY3Rpb24gKHBhdGgsIHBhcmVudE1vZGVsKSB7XHJcbiAgICAgICAgICAgIHZhciBvYmogPSB0aGlzLmdldChwYXRoLCB0cnVlKTtcclxuICAgICAgICAgICAgdmFyIHRoaXNQYXJlbnRNb2RlbCA9IHRoaXMucGFyZW50TW9kZWw7XHJcbiAgICAgICAgICAgIHZhciBtb2RlbCA9IG5ldyBNb2RlbChcclxuICAgICAgICAgICAgICAgIG9iaiwgcGFyZW50TW9kZWwgfHwgKHRoaXNQYXJlbnRNb2RlbCAmJiB0aGlzUGFyZW50TW9kZWwuZ2V0TW9kZWwocGF0aCkpXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIHJldHVybiBtb2RlbDtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKua4heepum1vZGVs55qEb3B0aW9uXHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKi9cclxuICAgICAgICBpc0VtcHR5OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9wdGlvbiA9PSBudWxsO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHJlc3RvcmVEYXRhOiBmdW5jdGlvbiAoKSB7fSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKi9cclxuICAgICAgICBjbG9uZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgQ3RvciA9IHRoaXMuY29uc3RydWN0b3I7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ3Rvcih6clV0aWwuY2xvbmUodGhpcy5vcHRpb24pKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIEVuYWJsZSBNb2RlbC5leHRlbmQuXHJcbiAgICBjbGF6elV0aWwuZW5hYmxlQ2xhc3NFeHRlbmQoTW9kZWwpO1xyXG5cclxuICAgIG1vZHVsZS5leHBvcnRzID0gTW9kZWw7XHJcblxyXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vbGliL2Zpc2gtdG9wby1jb3JlL2xpYi9Nb2RlbC5qc1xuICoqIG1vZHVsZSBpZCA9IDc1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcclxuXHJcbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XHJcblxyXG4gICAgdmFyIGNsYXp6ID0ge307XHJcblxyXG4gICAgdmFyIFRZUEVfREVMSU1JVEVSID0gJy4nO1xyXG4gICAgdmFyIElTX0NPTlRBSU5FUiA9ICdfX19GVF9fQ09NUE9ORU5UX19DT05UQUlORVJfX18nO1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcHVibGljXHJcbiAgICAgKi9cclxuICAgIHZhciBwYXJzZUNsYXNzVHlwZSA9IGNsYXp6LnBhcnNlQ2xhc3NUeXBlID0gZnVuY3Rpb24gKGNvbXBvbmVudFR5cGUpIHtcclxuICAgICAgICB2YXIgcmV0ID0ge21haW46ICcnLCBzdWI6ICcnfTtcclxuICAgICAgICBpZiAoY29tcG9uZW50VHlwZSkge1xyXG4gICAgICAgICAgICBjb21wb25lbnRUeXBlID0gY29tcG9uZW50VHlwZS5zcGxpdChUWVBFX0RFTElNSVRFUik7XHJcbiAgICAgICAgICAgIHJldC5tYWluID0gY29tcG9uZW50VHlwZVswXSB8fCAnJztcclxuICAgICAgICAgICAgcmV0LnN1YiA9IGNvbXBvbmVudFR5cGVbMV0gfHwgJyc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXQ7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcHVibGljICDnm7jmr5Qg55u05o6l55SoenJVdGlsLmluaGVyaXRzIOWlveWkhOaYryAg5Y+v5Lul55u05o6l6LCD55So54i257G755qE5p6E6YCg5Ye95pWwXHJcbiAgICAgKi9cclxuICAgIGNsYXp6LmVuYWJsZUNsYXNzRXh0ZW5kID0gZnVuY3Rpb24gKFJvb3RDbGFzcywgcHJlQ29uc3RydWN0KSB7XHJcbiAgICAgICAgUm9vdENsYXNzLmV4dGVuZCA9IGZ1bmN0aW9uIChwcm90bykge1xyXG4gICAgICAgICAgICB2YXIgRXh0ZW5kZWRDbGFzcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHByZUNvbnN0cnVjdCAmJiBwcmVDb25zdHJ1Y3QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgICAgIFJvb3RDbGFzcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgenJVdGlsLmV4dGVuZChFeHRlbmRlZENsYXNzLnByb3RvdHlwZSwgcHJvdG8pO1xyXG5cclxuICAgICAgICAgICAgRXh0ZW5kZWRDbGFzcy5leHRlbmQgPSB0aGlzLmV4dGVuZDtcclxuICAgICAgICAgICAgRXh0ZW5kZWRDbGFzcy5zdXBlckNhbGwgPSBzdXBlckNhbGw7XHJcbiAgICAgICAgICAgIEV4dGVuZGVkQ2xhc3Muc3VwZXJBcHBseSA9IHN1cGVyQXBwbHk7XHJcbiAgICAgICAgICAgIHpyVXRpbC5pbmhlcml0cyhFeHRlbmRlZENsYXNzLCB0aGlzKTtcclxuICAgICAgICAgICAgRXh0ZW5kZWRDbGFzcy5zdXBlckNsYXNzID0gdGhpcztcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBFeHRlbmRlZENsYXNzO1xyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIHN1cGVyQ2FsbCBzaG91bGQgaGF2ZSBjbGFzcyBpbmZvLCB3aGljaCBjYW4gbm90IGJlIGZldGNoIGZyb20gJ3RoaXMnLlxyXG4gICAgLy8gQ29uc2lkZXIgdGhpcyBjYXNlOlxyXG4gICAgLy8gY2xhc3MgQSBoYXMgbWV0aG9kIGYsXHJcbiAgICAvLyBjbGFzcyBCIGluaGVyaXRzIGNsYXNzIEEsIG92ZXJyaWRlcyBtZXRob2QgZiwgZiBjYWxsIHN1cGVyQXBwbHkoJ2YnKSxcclxuICAgIC8vIGNsYXNzIEMgaW5oZXJpdHMgY2xhc3MgQiwgZG8gbm90IG92ZXJyaWRlcyBtZXRob2QgZixcclxuICAgIC8vIHRoZW4gd2hlbiBtZXRob2Qgb2YgY2xhc3MgQyBpcyBjYWxsZWQsIGRlYWQgbG9vcCBvY2N1cmVkLlxyXG4gICAgZnVuY3Rpb24gc3VwZXJDYWxsKGNvbnRleHQsIG1ldGhvZE5hbWUpIHtcclxuICAgICAgICB2YXIgYXJncyA9IHpyVXRpbC5zbGljZShhcmd1bWVudHMsIDIpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLnN1cGVyQ2xhc3MucHJvdG90eXBlW21ldGhvZE5hbWVdLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHN1cGVyQXBwbHkoY29udGV4dCwgbWV0aG9kTmFtZSwgYXJncykge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnN1cGVyQ2xhc3MucHJvdG90eXBlW21ldGhvZE5hbWVdLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGVudGl0eVxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMucmVnaXN0ZXJXaGVuRXh0ZW5kXVxyXG4gICAgICogQHB1YmxpY1xyXG4gICAgICovXHJcbiAgICBjbGF6ei5lbmFibGVDbGFzc01hbmFnZW1lbnQgPSBmdW5jdGlvbiAoZW50aXR5LCBvcHRpb25zKSB7XHJcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENvbXBvbmVudCBtb2RlbCBjbGFzc2VzXHJcbiAgICAgICAgICoga2V5OiBjb21wb25lbnRUeXBlLFxyXG4gICAgICAgICAqIHZhbHVlOlxyXG4gICAgICAgICAqICAgICBjb21wb25lbnRDbGFzcywgd2hlbiBjb21wb25lbnRUeXBlIGlzICd4eHgnXHJcbiAgICAgICAgICogICAgIG9yIE9iamVjdC48c3ViS2V5LCBjb21wb25lbnRDbGFzcz4sIHdoZW4gY29tcG9uZW50VHlwZSBpcyAneHh4Lnl5J1xyXG4gICAgICAgICAqIEB0eXBlIHtPYmplY3R9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdmFyIHN0b3JhZ2UgPSB7fTtcclxuXHJcbiAgICAgICAgZW50aXR5LnJlZ2lzdGVyQ2xhc3MgPSBmdW5jdGlvbiAoQ2xhenosIGNvbXBvbmVudFR5cGUpIHtcclxuICAgICAgICAgICAgaWYgKGNvbXBvbmVudFR5cGUpIHtcclxuICAgICAgICAgICAgICAgIGNvbXBvbmVudFR5cGUgPSBwYXJzZUNsYXNzVHlwZShjb21wb25lbnRUeXBlKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIWNvbXBvbmVudFR5cGUuc3ViKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0b3JhZ2VbY29tcG9uZW50VHlwZS5tYWluXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL+W3sue7j+azqOWGjOi/h+S6hu+8jOebtOaOpei/lOWbnlxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHN0b3JhZ2VbY29tcG9uZW50VHlwZS5tYWluXSA9IENsYXp6O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY29tcG9uZW50VHlwZS5zdWIgIT09IElTX0NPTlRBSU5FUikge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjb250YWluZXIgPSBtYWtlQ29udGFpbmVyKGNvbXBvbmVudFR5cGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lcltjb21wb25lbnRUeXBlLnN1Yl0gPSBDbGF6ejtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gQ2xheno7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgZW50aXR5LmdldENsYXNzID0gZnVuY3Rpb24gKGNvbXBvbmVudFR5cGVNYWluLCBzdWJUeXBlLCB0aHJvd1doZW5Ob3RGb3VuZCkge1xyXG4gICAgICAgICAgICB2YXIgQ2xhenogPSBzdG9yYWdlW2NvbXBvbmVudFR5cGVNYWluXTtcclxuXHJcbiAgICAgICAgICAgIGlmIChDbGF6eiAmJiBDbGF6eltJU19DT05UQUlORVJdKSB7XHJcbiAgICAgICAgICAgICAgICBDbGF6eiA9IHN1YlR5cGUgPyBDbGF6eltzdWJUeXBlXSA6IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICh0aHJvd1doZW5Ob3RGb3VuZCAmJiAhQ2xhenopIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcclxuICAgICAgICAgICAgICAgICAgICAnQ29tcG9uZW50ICcgKyBjb21wb25lbnRUeXBlTWFpbiArICcuJyArIChzdWJUeXBlIHx8ICcnKSArICcgbm90IGV4aXN0cy4gTG9hZCBpdCBmaXJzdC4nXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gQ2xheno7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgZW50aXR5LmdldENsYXNzZXNCeU1haW5UeXBlID0gZnVuY3Rpb24gKGNvbXBvbmVudFR5cGUpIHtcclxuICAgICAgICAgICAgY29tcG9uZW50VHlwZSA9IHBhcnNlQ2xhc3NUeXBlKGNvbXBvbmVudFR5cGUpO1xyXG5cclxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xyXG4gICAgICAgICAgICB2YXIgb2JqID0gc3RvcmFnZVtjb21wb25lbnRUeXBlLm1haW5dO1xyXG5cclxuICAgICAgICAgICAgaWYgKG9iaiAmJiBvYmpbSVNfQ09OVEFJTkVSXSkge1xyXG4gICAgICAgICAgICAgICAgenJVdGlsLmVhY2gob2JqLCBmdW5jdGlvbiAobywgdHlwZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHR5cGUgIT09IElTX0NPTlRBSU5FUiAmJiByZXN1bHQucHVzaChvKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gob2JqKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBlbnRpdHkuaGFzQ2xhc3MgPSBmdW5jdGlvbiAoY29tcG9uZW50VHlwZSkge1xyXG4gICAgICAgICAgICAvLyBKdXN0IGNvbnNpZGVyIGNvbXBvbmVudFR5cGUubWFpbi5cclxuICAgICAgICAgICAgY29tcG9uZW50VHlwZSA9IHBhcnNlQ2xhc3NUeXBlKGNvbXBvbmVudFR5cGUpO1xyXG4gICAgICAgICAgICByZXR1cm4gISFzdG9yYWdlW2NvbXBvbmVudFR5cGUubWFpbl07XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHJldHVybiB7QXJyYXkuPHN0cmluZz59IExpa2UgWydhYScsICdiYiddLCBidXQgY2FuIG5vdCBiZSBbJ2FhLnh4J11cclxuICAgICAgICAgKi9cclxuICAgICAgICBlbnRpdHkuZ2V0QWxsQ2xhc3NNYWluVHlwZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciB0eXBlcyA9IFtdO1xyXG4gICAgICAgICAgICB6clV0aWwuZWFjaChzdG9yYWdlLCBmdW5jdGlvbiAob2JqLCB0eXBlKSB7XHJcbiAgICAgICAgICAgICAgICB0eXBlcy5wdXNoKHR5cGUpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIHR5cGVzO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIElmIGEgbWFpbiB0eXBlIGlzIGNvbnRhaW5lciBhbmQgaGFzIHN1YiB0eXBlc1xyXG4gICAgICAgICAqIEBwYXJhbSAge3N0cmluZ30gIGNvbXBvbmVudFR5cGVcclxuICAgICAgICAgKiBAcmV0dXJuIHtib29sZWFufVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGVudGl0eS5oYXNTdWJUeXBlcyA9IGZ1bmN0aW9uIChjb21wb25lbnRUeXBlKSB7XHJcbiAgICAgICAgICAgIGNvbXBvbmVudFR5cGUgPSBwYXJzZUNsYXNzVHlwZShjb21wb25lbnRUeXBlKTtcclxuICAgICAgICAgICAgdmFyIG9iaiA9IHN0b3JhZ2VbY29tcG9uZW50VHlwZS5tYWluXTtcclxuICAgICAgICAgICAgcmV0dXJuIG9iaiAmJiBvYmpbSVNfQ09OVEFJTkVSXTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBlbnRpdHkucGFyc2VDbGFzc1R5cGUgPSBwYXJzZUNsYXNzVHlwZTtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gbWFrZUNvbnRhaW5lcihjb21wb25lbnRUeXBlKSB7XHJcbiAgICAgICAgICAgIHZhciBjb250YWluZXIgPSBzdG9yYWdlW2NvbXBvbmVudFR5cGUubWFpbl07XHJcbiAgICAgICAgICAgIGlmICghY29udGFpbmVyIHx8ICFjb250YWluZXJbSVNfQ09OVEFJTkVSXSkge1xyXG4gICAgICAgICAgICAgICAgY29udGFpbmVyID0gc3RvcmFnZVtjb21wb25lbnRUeXBlLm1haW5dID0ge307XHJcbiAgICAgICAgICAgICAgICBjb250YWluZXJbSVNfQ09OVEFJTkVSXSA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGNvbnRhaW5lcjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChvcHRpb25zLnJlZ2lzdGVyV2hlbkV4dGVuZCkge1xyXG4gICAgICAgICAgICB2YXIgb3JpZ2luYWxFeHRlbmQgPSBlbnRpdHkuZXh0ZW5kO1xyXG4gICAgICAgICAgICBpZiAob3JpZ2luYWxFeHRlbmQpIHtcclxuICAgICAgICAgICAgICAgIGVudGl0eS5leHRlbmQgPSBmdW5jdGlvbiAocHJvdG8pIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgRXh0ZW5kZWRDbGFzcyA9IG9yaWdpbmFsRXh0ZW5kLmNhbGwodGhpcywgcHJvdG8pO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlbnRpdHkucmVnaXN0ZXJDbGFzcyhFeHRlbmRlZENsYXNzLCBwcm90by50eXBlKTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBlbnRpdHk7XHJcbiAgICB9O1xyXG5cclxuICAgIG1vZHVsZS5leHBvcnRzID0gY2xheno7XHJcblxyXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vbGliL2Zpc2gtdG9wby1jb3JlL2xpYi9jbGF6ei5qc1xuICoqIG1vZHVsZSBpZCA9IDc2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcclxuXHR2YXIgTm9kZSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9maXNoLXRvcG8tY29yZS9saWIvTm9kZVwiKTtcclxuXHR2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XHJcblx0dmFyIGdyYXBoaWMgPSByZXF1aXJlKFwiLi4vLi4vLi4vZmlzaC10b3BvLWNvcmUvbGliL2dyYXBoaWMuanNcIik7XHJcblx0dmFyIGNsYXp6VXRpbCA9IHJlcXVpcmUoJy4uLy4uLy4uL2Zpc2gtdG9wby1jb3JlL2xpYi9jbGF6eicpO1xyXG5cdFxyXG5cdC8v5Yib5bu6Tm9kZeexuyDmiYDmnInlvaLnirbpg73nu6fmib9Ob2RlICDljIXmi6xmcm9tSlNPTiB0b0pTT05cclxuXHRmdW5jdGlvbiBOZXR3b3JrTm9kZShtb2RlbCwgYXBpKSB7XHJcblx0XHROb2RlLmNhbGwodGhpcyk7XHJcblx0XHR0aGlzLm1vZGVsID0gbW9kZWw7XHRcdFxyXG5cdFx0dGhpcy5vcHRpb25zID1cclxuXHRcdHtcclxuXHRcdFx0b3V0bGluZToge1xyXG5cdFx0XHRcdGVuYWJsZTogdHJ1ZSwgLy8g5piv5ZCm5pyJ5aSW5qGGXHJcblx0XHRcdFx0cmFkaXVzOiB0cnVlLCAvLyDmmK/lkKblnIbop5JcclxuXHRcdFx0XHRpbml0VmlzaWJsZTogZmFsc2VcclxuXHRcdFx0fSxcclxuXHRcdFx0dGV4dDoge1xyXG5cdFx0XHRcdGNvbG9yOiAnIzAwMDAwMCcsIC8vIOaWh+acrOminOiJslxyXG5cdFx0XHRcdGxpbmVIZWlnaHQ6IDI0IC8vIOaWh+acrOihjOmrmFxyXG5cdFx0XHR9XHJcblx0XHR9O1xyXG5cdFx0dGhpcy5uZXh0d29ya0luZm8gPSB7dHlwZTogLTEsIG5hbWU6XCJOZXh0d29ya05vZGVcIiB9OyAgICAvL+iKgueCueS/oeaBr1xyXG5cdFx0dGhpcy5wb3J0Tm9kZUxpc3QgPSBbXTtcclxuXHRcdHRoaXMuY2FyZE5vZGVMaXN0ID0gW107XHJcblx0XHR0aGlzLmluaXRFdmVudChhcGkpO1xyXG5cdH07XHJcblxyXG4gICAgTmV0d29ya05vZGUucHJvdG90eXBlLmluaXRFdmVudCA9IGZ1bmN0aW9uKGFwaSkge1xyXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgICAgICAvLyB2YXIgTU9VU0VfRVZFTlRfTkFNRVMgPSBbJ2NsaWNrJywgJ21vdXNlb3ZlcicsICdtb3VzZW91dCddOy8vJ2NsaWNrJywgJ2RibGNsaWNrJywgJ21vdXNlb3ZlcicsICdtb3VzZW91dCdcclxuICAgICAgICAvLyB6clV0aWwuZWFjaChNT1VTRV9FVkVOVF9OQU1FUywgZnVuY3Rpb24gKGV2ZU5hbWUpIHtcclxuICAgICAgICAvLyAgICAgdGhhdC5vbihldmVOYW1lLCBmdW5jdGlvbiAoZSkge1xyXG5cdCAgICAgICAvLyAgICAgIHZhciBwYXJhbXMgPSB7fTtcclxuXHQgICAgICAgLy8gICAgICBwYXJhbXMuZXZlbnQgPSBlO1xyXG5cdCAgICAgICAvLyAgICAgIHBhcmFtcy50eXBlID0gZXZlTmFtZTtcclxuXHQgICAgICAgLy8gICAgICBwYXJhbXMubW9kZWwgPSB0aGF0Lm1vZGVsXHJcblx0ICAgICAgIC8vICAgICAgYXBpLnRyaWdnZXIoZXZlTmFtZSwgcGFyYW1zKTsgXHJcbiAgICAgICAgLy8gICAgIH0sIHRoaXMpO1xyXG4gICAgICAgIC8vIH0sIHRoaXMpO1xyXG4gICAgfTtcdFxyXG5cclxuXHROZXR3b3JrTm9kZS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24oKSB7XHJcblxyXG5cdH07XHJcblxyXG5cdC8qKlxyXG5cdCAqIGRyYXdUZXh0XHJcblx0ICogQGRlc2NyaXB0aW9uIOeUu+S4gOS4quaWh+acrFxyXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBjb250ZW50XHJcblx0ICogQHBhcmFtIHtudW1iZXJ9IHhcclxuXHQgKiBAcGFyYW0ge251bWJlcn0geVxyXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBjb2xvclxyXG5cdCAqL1xyXG5cdE5ldHdvcmtOb2RlLnByb3RvdHlwZS5kcmF3VGV4dCA9IGZ1bmN0aW9uIChjb250ZW50LCB4LCB5LCBjb2xvcikge1xyXG5cdFx0dmFyIHRleHQgPSBuZXcgZ3JhcGhpYy5UZXh0KHtcclxuXHRcdFx0c3R5bGU6IHtcclxuXHRcdFx0XHR0ZXh0OiBjb250ZW50LFxyXG5cdFx0XHRcdHg6IHgsXHJcblx0XHRcdFx0eTogeSArIDYsXHJcblx0XHRcdFx0Y29sb3I6IGNvbG9yID8gY29sb3IgOiB0aGlzLm9wdGlvbnMudGV4dC5jb2xvcixcclxuXHRcdFx0XHR0ZXh0Rm9udDogJzEycHggTWljcm9zb2Z0IFlhSGVpJ1xyXG5cdFx0XHR9LFxyXG5cdFx0XHR6bGV2ZWw6IDIwXHJcblx0XHR9KTtcclxuXHRcdHJldHVybiB7XHJcblx0XHRcdHRleHQ6IHRleHQsXHJcblx0XHRcdHJlY3Q6IHRleHQuZ2V0Qm91bmRpbmdSZWN0KClcclxuXHRcdH07XHJcblx0fTtcdFxyXG5cclxuXHJcblx0TmV0d29ya05vZGUucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0dGhpcy5tb2RlbC5zZXQoXCJyZXNvdXJjZUlkXCIsIHRoaXMucmVzb3VyY2VJZCk7XHJcblx0XHR0aGlzLm1vZGVsLnNldChcInByb3BlcnRpZXMudHlwZVwiLCB0aGlzLm5leHR3b3JrSW5mby50eXBlKTtcclxuXHRcdHRoaXMubW9kZWwuc2V0KFwic3RlbmNpbC50eXBlXCIsIHRoaXMubmV4dHdvcmtJbmZvLm5hbWUpO1xyXG5cdFx0dGhpcy5tb2RlbC5zZXQoXCJib3VuZHMudXBwZXJMZWZ0LnhcIiwgdGhpcy5wb3NpdGlvblswXSk7XHJcblx0XHR0aGlzLm1vZGVsLnNldChcImJvdW5kcy51cHBlckxlZnQueVwiLCB0aGlzLnBvc2l0aW9uWzFdKTtcclxuXHRcdHRoaXMubW9kZWwuc2V0KFwiYm91bmRzLmxvd2VyUmlnaHQueFwiLCB0aGlzLnBvc2l0aW9uWzBdICsgdGhpcy5nZXRCb3VuZGluZ1JlY3QoKS53aWR0aCk7XHJcblx0XHR0aGlzLm1vZGVsLnNldChcImJvdW5kcy5sb3dlclJpZ2h0LnlcIiwgdGhpcy5wb3NpdGlvblsxXSArIHRoaXMuZ2V0Qm91bmRpbmdSZWN0KCkuaGVpZ2h0KTtcclxuXHRcdHJldHVybiB0aGlzLm1vZGVsLm9wdGlvbjtcclxuXHR9O1xyXG5cdHpyVXRpbC5pbmhlcml0cyhOZXR3b3JrTm9kZSwgTm9kZSk7XHJcblxyXG5cdGNsYXp6VXRpbC5lbmFibGVDbGFzc01hbmFnZW1lbnQoTmV0d29ya05vZGUsIHtcclxuICAgICAgICByZWdpc3RlcldoZW5FeHRlbmQ6IHRydWVcclxuICAgIH0pO1xyXG5cdG1vZHVsZS5leHBvcnRzID0gTmV0d29ya05vZGU7XHJcblxyXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vbGliL2Zpc2gtdG9wby1uZXR3b3JrL2xpYi9ub2RlL05ldHdvcmtOb2RlLmpzXG4gKiogbW9kdWxlIGlkID0gNzdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlxyXG4gICAgdmFyIGdyYXBoaWMgPSByZXF1aXJlKCcuL2dyYXBoaWMnKTtcclxuICAgIHZhciB1dGlsID0gcmVxdWlyZShcIi4vdXRpbC5qc1wiKVxyXG4gICAgLy/liJvlu7pOb2Rl57G7IOaJgOacieW9oueKtumDvee7p+aJv05vZGUgIOWMheaLrGZyb21KU09OIHRvSlNPTlxyXG4gICAgZnVuY3Rpb24gTm9kZSgpIHtcclxuICAgICAgICB0aGlzLnJlc291cmNlSWQgPSB1dGlsLmdldFVVSUQoKTsgLy8g55Sf5oiQ6IqC54K5SURcclxuICAgICAgICBncmFwaGljLkdyb3VwLmNhbGwodGhpcyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDnlLHniLbnsbvlrp7njrBcclxuICAgICAqIEByZXR1cm4ge1t0eXBlXX0gW2Rlc2NyaXB0aW9uXVxyXG4gICAgICovXHJcbiAgICBOb2RlLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbigpIHt9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICog55Sx54i257G75a6e546wXHJcbiAgICAgKiBAcGFyYW0gIHtbdHlwZV19IGpzb24gW2Rlc2NyaXB0aW9uXVxyXG4gICAgICogQHJldHVybiB7W3R5cGVdfSAgICAgIFtkZXNjcmlwdGlvbl1cclxuICAgICAqL1xyXG4gICAgTm9kZS5wcm90b3R5cGUuZ2V0UmVjdCA9IGZ1bmN0aW9uKGpzb24pIHt9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogZHJhd1RleHRcclxuICAgICAqIEBkZXNjcmlwdGlvbiDnlLvkuIDkuKrmlofmnKxcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29sb3JcclxuICAgICAqL1xyXG4gICAgTm9kZS5wcm90b3R5cGUuZHJhd1RleHQgPSBmdW5jdGlvbihuYW1lLGNvbG9yKSB7XHJcbiAgICAgICAgdmFyIHRleHROYW1lID0gdGhpcy5icG1uSW5mby5uYW1lO1xyXG4gICAgICAgIGlmKG5hbWUgIT0gbnVsbCl7XHJcbiAgICAgICAgICAgIHRleHROYW1lID0gbmFtZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHRleHQgPSBuZXcgZ3JhcGhpYy5UZXh0KHtcclxuICAgICAgICAgICAgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgIHRleHQ6IHRleHROYW1lLFxyXG4gICAgICAgICAgICAgICAgY29sb3I6IGNvbG9yID8gY29sb3IgOiB0aGlzLm9wdGlvbnMudGV4dC5jb2xvcixcclxuICAgICAgICAgICAgICAgIHRleHRGb250OiAnMTJweCBNaWNyb3NvZnQgWWFIZWknXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHpsZXZlbDogMjBcclxuICAgICAgICB9KTtcclxuICAgICAgICAvL+aWh+Wtl+e7mOWItueahOS9jee9riAgXHJcbiAgICAgICAgLy94ID0g5Lit5b+D54K5LnggLSDotbflp4vkvY3nva4ueCAtIOaWh+Wtl+WuveW6pueahOS4gOWNilxyXG4gICAgICAgIHZhciB4ID0gdGhpcy5nZXRSZWN0KCkueCAtIHRoaXMucG9zaXRpb25bMF0gLSB0ZXh0LmdldEJvdW5kaW5nUmVjdCgpLndpZHRoIC8gMjtcclxuICAgICAgICAvL3kgPSDkuK3lv4PngrkueSAtIOi1t+Wni+S9jee9ri55ICsg6IqC54K56auY5bqm55qE5LiA5Y2KICsg5YGP56e75YC877yINu+8iVxyXG4gICAgICAgIHZhciB5ID0gdGhpcy5nZXRSZWN0KCkueSAtIHRoaXMucG9zaXRpb25bMV0gKyB0aGlzLmdldEJvdW5kaW5nUmVjdCgpLmhlaWdodCAvIDIgKyB0ZXh0LmdldEJvdW5kaW5nUmVjdCgpLmhlaWdodCArIDY7XHJcbiAgICAgICAgdGV4dC5hdHRyKFwic3R5bGVcIiwgeyB4OiB4LCB5OiB5IH0pO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHRleHQ6IHRleHQsXHJcbiAgICAgICAgICAgIHJlY3Q6IHRleHQuZ2V0Qm91bmRpbmdSZWN0KClcclxuICAgICAgICB9O1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogcmVmcmVzaFRleHRcclxuICAgICAqIEBkZXNjcmlwdGlvbiDliLfmlrDmlofmnKxcclxuICAgICAqL1xyXG4gICAgTm9kZS5wcm90b3R5cGUucmVmcmVzaFRleHQgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgdGV4dCA9IHRoaXMuY2hpbGRPZk5hbWUoXCJUaXRsZVwiKTtcclxuICAgICAgICB2YXIgeCA9IHRoaXMuZ2V0UmVjdCgpLnggLSB0aGlzLnBvc2l0aW9uWzBdIC0gdGV4dC5nZXRCb3VuZGluZ1JlY3QoKS53aWR0aCAvIDI7XHJcbiAgICAgICAgdmFyIHkgPSB0aGlzLmdldFJlY3QoKS55IC0gdGhpcy5wb3NpdGlvblsxXSArIHRoaXMuZ2V0Qm91bmRpbmdSZWN0KCkuaGVpZ2h0IC8gMiArIHRleHQuZ2V0Qm91bmRpbmdSZWN0KCkuaGVpZ2h0ICsgNjtcclxuICAgICAgICB0ZXh0LmF0dHIoXCJzdHlsZVwiLCB7IHg6IHgsIHk6IHkgfSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiDnlLHniLbnsbvlrp7njrBcclxuICAgICAqIEByZXR1cm4ge1t0eXBlXX0gW2Rlc2NyaXB0aW9uXVxyXG4gICAgICovXHJcbiAgICBOb2RlLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbigpIHt9O1xyXG5cclxuICAgIGdyYXBoaWMuVXRpbC5pbmhlcml0cyhOb2RlLCBncmFwaGljLkdyb3VwKTtcclxuICAgIG1vZHVsZS5leHBvcnRzID0gTm9kZTtcclxuXHJcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9saWIvZmlzaC10b3BvLWNvcmUvbGliL05vZGUuanNcbiAqKiBtb2R1bGUgaWQgPSA3OFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXHJcbiAgICB2YXIgdXRpbCA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi9maXNoLXRvcG8tY29yZS9saWIvdXRpbC5qc1wiKTtcclxuICAgIHZhciBOZXR3b3JrTm9kZSA9IHJlcXVpcmUoXCIuLi9OZXR3b3JrTm9kZVwiKTtcclxuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcclxuICAgIHZhciBncmFwaGljID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uL2Zpc2gtdG9wby1jb3JlL2xpYi9ncmFwaGljLmpzXCIpO1xyXG4gICAgdmFyIE5ldHdvcmtNb2RlbCA9IHJlcXVpcmUoXCIuLi8uLi9tb2RlbC9OZXR3b3JrTW9kZWwuanNcIik7XHJcbiAgICBcclxuICAgIGZ1bmN0aW9uIFJhY2tOb2RlKG1vZGVsLGFwaSkge1xyXG4gICAgICAgIE5ldHdvcmtOb2RlLmNhbGwodGhpcywgbW9kZWwsIGFwaSk7XHJcbiAgICAgICAgdGhpcy5yYWNra0luZm8gPSB7dHlwZTogLTEsIG5hbWU6IFwiUmFja05vZGVcIiB9OyAgICBcclxuICAgICAgICB0aGlzLm1vZGVsID0gbW9kZWw7XHJcbiAgICAgICAgdGhpcy5yZW5kZXIobW9kZWwsIGFwaSk7XHJcbiAgICB9O1xyXG5cclxuICAgIFJhY2tOb2RlLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbihtb2RlbCxhcGkpIHtcclxuICAgICAgICB0aGlzLm1vZGVsID0gbW9kZWw7XHJcbiAgICAgICAgdmFyIF9VRGF0YSA9IG1vZGVsLmdldChcIlVEYXRhXCIpO1xyXG4gICAgICAgIHZhciBfc2hvd1RpcCA9IG1vZGVsLmdldChcInNob3dUaXBcIik7XHJcbiAgICAgICAgdmFyIF9yYWNrTmFtZSA9IG1vZGVsLmdldChcInJhY2tcIik7XHJcbiAgICAgICAgdmFyIF9yYWNrSWQgPSBtb2RlbC5nZXQoXCJpZFwiKTtcclxuICAgICAgICB2YXIgX2Rlc2NyaXB0aW9uID0gbW9kZWwuZ2V0KFwiZGVzY3JpcHRpb25cIik7XHJcbiAgICAgICAgLy90aXRsZVxyXG4gICAgICAgIHZhciBfdGl0bGUgPSBuZXcgZ3JhcGhpYy5UZXh0KHtcclxuICAgICAgICAgICAgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgIHg6IDgwLFxyXG4gICAgICAgICAgICAgICAgeTogLTMwLFxyXG4gICAgICAgICAgICAgICAgdGV4dDogX3JhY2tOYW1lICsgJyAgNDJVJyxcclxuICAgICAgICAgICAgICAgIHdpZHRoOiA4MCxcclxuICAgICAgICAgICAgICAgIGhlaWdodDogMjAsXHJcbiAgICAgICAgICAgICAgICBmaWxsOiAnIzhGOEI4QScsXHJcbiAgICAgICAgICAgICAgICB0ZXh0Rm9udDogJzE4cHggTWljcm9zb2Z0IFlhaGVpJyxcclxuICAgICAgICAgICAgICAgIHRleHRCYXNlbGluZTogJ3RvcCdcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZHJhZ2dhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBwYXJtRGF0ZTogeyBvcGVyYXRpb246IFwiZGV0YWlsUmFja1wiLCByYWNrOiBfcmFja05hbWUsIGlkOl9yYWNrSWQsIGRlc2NyaXB0aW9uOiBfZGVzY3JpcHRpb259XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5hZGQoX3RpdGxlKTtcclxuXHJcbiAgICAgICAgdmFyIGFmdGVyQnV0dG9uTm9kZSA9IG5ldyBncmFwaGljLkltYWdlKHtcclxuICAgICAgICAgICAgcG9zaXRpb246IFswLCAwXSxcclxuICAgICAgICAgICAgc2NhbGU6IFsxLCAxXSxcclxuICAgICAgICAgICAgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgIHg6IDQwLFxyXG4gICAgICAgICAgICAgICAgeTogLTI3LFxyXG4gICAgICAgICAgICAgICAgaW1hZ2U6ICcuL2ZybS9maXNoLWRlc2t0b3AvdGhpcmQtcGFydHkvZmlzaC10b3BvL2Zpc2gtdG9wby1uZXR3b3JrL3NyYy9pbWFnZXMvZGVsZXRlLnBuZycsXHJcbiAgICAgICAgICAgICAgICB3aWR0aDogMTgsXHJcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDE4XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHo6IDEwMDAsXHJcbiAgICAgICAgICAgIGRyYWdnYWJsZTogZmFsc2UsXHJcbiAgICAgICAgICAgIHBhcm1EYXRlOiB7IG9wZXJhdGlvbjogXCJkZWxldGVSYWNrXCIsIHJhY2s6IF9yYWNrTmFtZSwgaWQ6X3JhY2tJZCB9XHJcbiAgICAgICAgfSk7IFxyXG4gICAgICAgIHRoaXMuYWRkKGFmdGVyQnV0dG9uTm9kZSk7XHJcblxyXG4gICAgICAgIC8v57uR5a6a5oKs5rWu5LqL5Lu2XHJcbiAgICAgICAgdmFyIE1PVVNFX0VWRU5UX05BTUVTID0gWydjbGljayddO1xyXG4gICAgICAgIHpyVXRpbC5lYWNoKE1PVVNFX0VWRU5UX05BTUVTLCBmdW5jdGlvbiAoZXZlTmFtZSkge1xyXG5cclxuICAgICAgICAgICAgX3RpdGxlLm9uKGV2ZU5hbWUsIGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcGFyYW1zID0ge307XHJcbiAgICAgICAgICAgICAgICBpZiAoZXZlTmFtZSA9PT0gXCJjbGlja1wiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9wYXJtRGF0ZSA9IGUudGFyZ2V0LnBhcm1EYXRlO1xyXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtcy5ldmVudCA9IF9wYXJtRGF0ZTtcclxuICAgICAgICAgICAgICAgIH0gIFxyXG4gICAgICAgICAgICAgICAgYXBpLnRyaWdnZXIoZXZlTmFtZSwgcGFyYW1zKTsgXHJcbiAgICAgICAgICAgIH0sIHRoaXMpO1xyXG5cclxuICAgICAgICAgICAgYWZ0ZXJCdXR0b25Ob2RlLm9uKGV2ZU5hbWUsIGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcGFyYW1zID0ge307XHJcbiAgICAgICAgICAgICAgICBpZiAoZXZlTmFtZSA9PT0gXCJjbGlja1wiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9wYXJtRGF0ZSA9IGUudGFyZ2V0LnBhcm1EYXRlO1xyXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtcy5ldmVudCA9IF9wYXJtRGF0ZTtcclxuICAgICAgICAgICAgICAgIH0gIFxyXG4gICAgICAgICAgICAgICAgYXBpLnRyaWdnZXIoZXZlTmFtZSwgcGFyYW1zKTsgXHJcbiAgICAgICAgICAgIH0sIHRoaXMpO1xyXG5cclxuXHJcbiAgICAgICAgfSwgdGhpcyk7XHJcbiAgXHJcbiAgICAgICAgdmFyIHJlY3RPdXQgPSBuZXcgZ3JhcGhpYy5SZWN0KHtcclxuICAgICAgICAgICAgc2hhcGU6IHtcclxuICAgICAgICAgICAgICAgIHg6IDAsXHJcbiAgICAgICAgICAgICAgICB5OiAwLFxyXG4gICAgICAgICAgICAgICAgd2lkdGg6IG1vZGVsLmdldChcIndpZHRoXCIpLFxyXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBtb2RlbC5nZXQoXCJoZWlnaHRcIilcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgIGZpbGw6ICcjRkZGRkZGJyxcclxuICAgICAgICAgICAgICAgIHN0cm9rZTogJyNCM0IzQjMnLFxyXG4gICAgICAgICAgICAgICAgbGluZVdpZHRoOiAnMScvLyxcclxuICAgICAgICAgICAgfSAgICAgICAgICBcclxuICAgICAgICB9KTsgICAgICAgIFxyXG4gICAgICAgIHRoaXMuYWRkKHJlY3RPdXQpO1xyXG4gICAgICAgIHZhciByZWN0SW4gPSBuZXcgZ3JhcGhpYy5SZWN0KHtcclxuICAgICAgICAgICAgc2hhcGU6IHtcclxuICAgICAgICAgICAgICAgIHg6IDUsXHJcbiAgICAgICAgICAgICAgICB5OiA1LFxyXG4gICAgICAgICAgICAgICAgd2lkdGg6IG1vZGVsLmdldChcIndpZHRoXCIpIC0gMTAsXHJcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IG1vZGVsLmdldChcImhlaWdodFwiKSAtIDEwXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgICBmaWxsOiAnI0ZGRkZGRicsXHJcbiAgICAgICAgICAgICAgICBzdHJva2U6ICcjQjNCM0IzJyxcclxuICAgICAgICAgICAgICAgIGxpbmVXaWR0aDogJzEnLy8sXHJcbiAgICAgICAgICAgIH0gICAgICAgICAgXHJcbiAgICAgICAgfSk7ICAgICAgICBcclxuICAgICAgICB0aGlzLmFkZChyZWN0SW4pO1xyXG5cclxuICAgICAgICB2YXIgaiA9IDE7XHJcbiAgICAgICAgdmFyIF9zdGFydFkgPSAgNjM1O1xyXG4gICAgICAgIHdoaWxlKCBqIDwgNDMgKSB7IFxyXG4gICAgICAgICAgICB2YXIgX2Zsb29yTnVtID0gMTtcclxuICAgICAgICAgICAgLy8gdmFyIF95ID0gIDUgKyAoKDQyIC0gaiApICogMTUpO1xyXG4gICAgICAgICAgICB2YXIgX3kgPSAgX3N0YXJ0WSAtIChqICogMTUpO1xyXG4gICAgICAgICAgICB2YXIgX2lzbnVsbEZsb29yID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGZvciAoIHZhciBmID0gMDsgZiA8IF9VRGF0YS5sZW5ndGg7IGYrKyApIHtcclxuICAgICAgICAgICAgICAgIGlmICggaiA9PT0gcGFyc2VJbnQoX1VEYXRhW2ZdLmZsb29yKSApIHtcclxuICAgICAgICAgICAgICAgICAgICBfZmxvb3JOdW0gPSBwYXJzZUludChfVURhdGFbZl0uaGVpZ2h0KTtcclxuICAgICAgICAgICAgICAgICAgICBfeSA9IF95IC0gKF9mbG9vck51bSAtIDEpICogMTU7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9zZXJ2ZXIgPSBcIlNlcnZlclwiO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChfVURhdGFbZl0udHlwZS50b1VwcGVyQ2FzZSgpID09PSBcIlNXSVRDSFwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9zZXJ2ZXIgPSBcIlN3aXRjaFwiO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB2YXIgbW9kZWxPYmogPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc291cmNlSWQ6IHV0aWwuZ2V0VVVJRCgpLCAgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXM6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiU2VydmVyXCIsICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHRQcm9wZXJ0aWVzOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9ICBcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgYm91bmRzOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cHBlckxlZnQ6IHt4OiA1LCB5OiBfeX0gIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGVuY2lsOiB7dHlwZTogX3NlcnZlciArIFwiTm9kZVwifVxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgbW9kZWxPYmouaGVpZ2h0ID0gIDE1ICogX2Zsb29yTnVtIC0gMTtcclxuICAgICAgICAgICAgICAgICAgICBtb2RlbE9iai53aWR0aCA9IG1vZGVsLmdldChcIndpZHRoXCIpIC0gMTA7XHJcbiAgICAgICAgICAgICAgICAgICAgbW9kZWxPYmoucGFybURhdGUgPSBfVURhdGFbZl07XHJcbiAgICAgICAgICAgICAgICAgICAgbW9kZWxPYmouZmxvb3IgPSBfVURhdGFbZl0uZmxvb3I7XHJcbiAgICAgICAgICAgICAgICAgICAgbW9kZWxPYmouc3RhdHVzID0gX1VEYXRhW2ZdLnN0YXR1cztcclxuICAgICAgICAgICAgICAgICAgICBtb2RlbE9iai5mbG9vck51bSA9IF9mbG9vck51bTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBpZiAoKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIH1cclxuICAgICAgICAgICAgICAgICAgICBtb2RlbE9iai5zZXJ2ZXJUeXBlID0gIChfVURhdGFbZl0udmVuZG9yID09PSB1bmRlZmluZWQgfHwgX1VEYXRhW2ZdLnZlbmRvciA9PT0gXCJVbmtub3duXCIpID8gXCJTZXJ2ZXJcIjogX1VEYXRhW2ZdLnZlbmRvcjtcclxuICAgICAgICAgICAgICAgICAgICBpZiggX1VEYXRhW2ZdLmNvbHVtbiAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGVsT2JqLmNvbHVtbiA9IF9VRGF0YVtmXS5jb2x1bW47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIC8v5Yik5pat5piv5ZCmYmFuZOaCrOa1ruS6i+S7tlxyXG4gICAgICAgICAgICAgICAgICAgIG1vZGVsT2JqLnNob3dUaXAgPSBfc2hvd1RpcDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc2VydmVyTW9kZWwgPSBuZXcgTmV0d29ya01vZGVsKG1vZGVsT2JqKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZE5vZGVCeU1vZGVsKHNlcnZlck1vZGVsLCBhcGkpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgcmVjdFRyYXkgPSBuZXcgZ3JhcGhpYy5SZWN0KHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2hhcGU6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHg6IDUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5OiBfeSArICgxNSAqIF9mbG9vck51bSkgLSAxICxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiBtb2RlbC5nZXQoXCJ3aWR0aFwiKSAtIDEwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiAxXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxsOiAnI0ZGRkZGRicsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJva2U6ICcjQjNCM0IzJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVXaWR0aDogJzAuNScvLyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICB9KTsgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkKHJlY3RUcmF5KTtcclxuICAgICAgICAgICAgICAgICAgICBfaXNudWxsRmxvb3IgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmKCAhX2lzbnVsbEZsb29yICkge1xyXG4gICAgICAgICAgICAgICAgLy8gICB2YXIgcmVjdFRyYXkgPSBuZXcgZ3JhcGhpYy5SZWN0KHtcclxuICAgICAgICAgICAgICAgIC8vICAgICBzaGFwZToge1xyXG4gICAgICAgICAgICAgICAgLy8gICAgICAgICB4OiA1LFxyXG4gICAgICAgICAgICAgICAgLy8gICAgICAgICB5OiA1ICsgKCg0MiAtIGogKSAqIDE1KSAsXHJcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgIHdpZHRoOiBtb2RlbC5nZXQoXCJ3aWR0aFwiKSAtIDEwLFxyXG4gICAgICAgICAgICAgICAgLy8gICAgICAgICBoZWlnaHQ6IDE1XHJcbiAgICAgICAgICAgICAgICAvLyAgICAgfSxcclxuICAgICAgICAgICAgICAgIC8vICAgICBzdHlsZToge1xyXG4gICAgICAgICAgICAgICAgLy8gICAgICAgICBmaWxsOiAnI0ZGRkZGRicsXHJcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgIHN0cm9rZTogJyNCM0IzQjMnLFxyXG4gICAgICAgICAgICAgICAgLy8gICAgICAgICBsaW5lRGFzaDogWzNdLCAgXHJcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgIGxpbmVXaWR0aDogJzEnLy8sXHJcbiAgICAgICAgICAgICAgICAvLyAgICAgfSAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIC8vIH0pOyAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAvLyB0aGlzLmFkZChyZWN0VHJheSk7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIG1vZGVsT2JqID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc291cmNlSWQ6IHV0aWwuZ2V0VVVJRCgpLCAgXHJcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydGllczoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcIkVtcHR5Rmxvb3JcIiwgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXh0UHJvcGVydGllczoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9ICBcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIGJvdW5kczoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB1cHBlckxlZnQ6IHt4OiA1LCB5OiBfeX0gIFxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IG1vZGVsLmdldChcIndpZHRoXCIpLFxyXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogMTUsXHJcbiAgICAgICAgICAgICAgICAgICAgc3RlbmNpbDoge3R5cGU6IFwiRW1wdHlGbG9vck5vZGVcIn1cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBtb2RlbE9iai5zaG93VGlwID0gX3Nob3dUaXA7XHJcbiAgICAgICAgICAgICAgICBtb2RlbE9iai5wYXJtRGF0ZSA9IHtub2RlVHlwZTogJ0VtcHR5Rmxvb3JOb2RlJywgZmxvb3I6IGp9O1xyXG4gICAgICAgICAgICAgICAgdmFyIGVtcHR5Rmxvb3JNb2RlbCA9IG5ldyBOZXR3b3JrTW9kZWwobW9kZWxPYmopO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hZGROb2RlQnlNb2RlbChlbXB0eUZsb29yTW9kZWwsIGFwaSk7XHJcblxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGogPSBqICsgX2Zsb29yTnVtO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnBvc2l0aW9uID0gW21vZGVsLmdldChcImJvdW5kcy51cHBlckxlZnQueFwiKSAsIG1vZGVsLmdldChcImJvdW5kcy51cHBlckxlZnQueVwiKV07XHJcbiAgICB9O1xyXG5cclxuICAgIFJhY2tOb2RlLnByb3RvdHlwZS5hZGROb2RlQnlNb2RlbCA9IGZ1bmN0aW9uKCBwX21vZGVsLCBhcGkpIHtcclxuICAgICAgICB2YXIgU2hhcGUgPSBhcGkuZ2V0Tm9kZUNsYXNzKHBfbW9kZWwuZ2V0KFwic3RlbmNpbC50eXBlXCIpKTtcclxuICAgICAgICB2YXIgbm9kZSA9IG51bGw7XHJcbiAgICAgICAgaWYgKCBTaGFwZSApIHtcclxuICAgICAgICAgICAgbm9kZSA9IG5ldyBTaGFwZShwX21vZGVsLCB0aGlzLmFwaSk7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkKG5vZGUpO1xyXG4gICAgICAgICAgICB2YXIgTU9VU0VfRVZFTlRfTkFNRVMgPSBbJ2NsaWNrJ107XHJcbiAgICAgICAgICAgIGlmICggcF9tb2RlbC5nZXQoXCJzaG93VGlwXCIpICkge1xyXG4gICAgICAgICAgICAgICAgTU9VU0VfRVZFTlRfTkFNRVMgPSBbJ2NsaWNrJywgJ21vdXNlb3ZlcicsICdtb3VzZW91dCddO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoIHBfbW9kZWwuZ2V0KFwicHJvcGVydGllcy50eXBlXCIpID09PSBcIkVtcHR5Rmxvb3JOb2RlXCIgKSB7XHJcbiAgICAgICAgICAgICAgICAgTU9VU0VfRVZFTlRfTkFNRVMgPSBbJ2NsaWNrJ107XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8v57uR5a6a5oKs5rWu5LqL5Lu2XHJcbiAgICAgICAgICAgIHpyVXRpbC5lYWNoKE1PVVNFX0VWRU5UX05BTUVTLCBmdW5jdGlvbiAoZXZlTmFtZSkge1xyXG4gICAgICAgICAgICAgICAgbm9kZS5vbihldmVOYW1lLCBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXJhbXMgPSB7fTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIGV2ZU5hbWUgPT09IFwibW91c2VvdmVyXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdmFyIF9oID0gZS50YXJnZXQuc3R5bGUuaGVpZ2h0ICE9PSB1bmRlZmluZWQgPyAgKGUudGFyZ2V0LnN0eWxlLmhlaWdodCAvIDIpIDogKDE1IC8gMik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfZXcgPSBlLnRhcmdldC5zdHlsZS53aWR0aCAhPT0gdW5kZWZpbmVkID8gIChlLnRhcmdldC5zdHlsZS53aWR0aCArIDUpIDogMjA1O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMgPSB7fTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zLmV2ZW50ID0gZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcGFyYW1zLnggPSBub2RlLnBhcmVudC5wb3NpdGlvblswXSArIGUudGFyZ2V0LnBvc2l0aW9uWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBwYXJhbXMueSA9IG5vZGUucGFyZW50LnBvc2l0aW9uWzFdICsgZS50YXJnZXQucG9zaXRpb25bMV0gKyBfaDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zLnggPSBlLm9mZnNldFg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtcy55ID0gZS5vZmZzZXRZO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMud2lkdGggPSAxNTA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtcy5oZWlnaHQgPSAxNzA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtcy5lV2lkdGggPSAgNSA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHBhcmFtcy5lV2lkdGggPSBfZXcgO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMucGFybURhdGUgPSBlLnRhcmdldC5wYXJtRGF0ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBhcGkuZ2V0SGVpZ2h0KCkgLSBwYXJhbXMueSA+IHBhcmFtcy5oZWlnaHQgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMubGF5b3V0ID0gXCJkb3duXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMubGF5b3V0ID0gXCJ1cFwiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFwaS5zaG93VGlwV2luZG93KHBhcmFtcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChldmVOYW1lID09PSBcIm1vdXNlb3V0XCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXBpLmhpZGVUaXBXaW5kb3coZS5ldmVudC50YXJnZXQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gIGVsc2UgaWYgKGV2ZU5hbWUgPT09IFwiY2xpY2tcIikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX3Bhcm1EYXRlID0gZS50YXJnZXQucGFybURhdGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggZS50YXJnZXQucGFyZW50LnJhY2trSW5mbyAhPT0gdW5kZWZpbmVkICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3Bhcm1EYXRlLnJhY2tJZCA9IGUudGFyZ2V0LnBhcmVudC5tb2RlbC5vcHRpb24uaWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfcGFybURhdGUucmFja05hbWUgPSBlLnRhcmdldC5wYXJlbnQubW9kZWwub3B0aW9uLnJhY2s7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMuZXZlbnQgPV9wYXJtRGF0ZTtcclxuICAgICAgICAgICAgICAgICAgICB9ICBlbHNlIGlmIChldmVOYW1lID09PSBcImRiY2xpY2tcIikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMuZXZlbnQgPSBlLnRhcmdldC5wYXJtRGF0ZTtcclxuICAgICAgICAgICAgICAgICAgICB9IFxyXG4gICAgICAgICAgICAgICAgICAgIGFwaS50cmlnZ2VyKGV2ZU5hbWUsIHBhcmFtcyk7IFxyXG4gICAgICAgICAgICAgICAgfSwgdGhpcyk7XHJcbiAgICAgICAgICAgIH0sIHRoaXMpO1xyXG5cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIFJhY2tOb2RlLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbigpIHtcclxuICAgIC8vICAgICAvLyBib2R5Li4uXHJcbiAgICAvLyAgICAgcmV0dXJuIHRoaXMubW9kZWwub3B0aW9uO1xyXG4gICAgLy8gfTtcclxuICAgIHpyVXRpbC5pbmhlcml0cyhSYWNrTm9kZSwgTmV0d29ya05vZGUpO1xyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBSYWNrTm9kZTtcclxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2xpYi9maXNoLXRvcG8tbmV0d29yay9saWIvbm9kZS9yYWNrL1JhY2tOb2RlLmpzXG4gKiogbW9kdWxlIGlkID0gNzlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxyXG4gKi9cclxuXHJcbiAgICB2YXIgdXRpbCA9IHJlcXVpcmUoXCIuLi8uLi9maXNoLXRvcG8tY29yZS9saWIvdXRpbC5qc1wiKTtcclxuICAgIHZhciBOZXR3b3JrTm9kZSA9IHJlcXVpcmUoXCIuL25vZGUvTmV0d29ya05vZGUuanNcIik7XHJcbiAgICB2YXIgTmV0d29ya01vZGVsID0gcmVxdWlyZShcIi4vbW9kZWwvTmV0d29ya01vZGVsLmpzXCIpO1xyXG4gICAgdmFyIFJhY2tOb2RlID0gcmVxdWlyZShcIi4vbm9kZS9yYWNrL1JhY2tOb2RlXCIpO1xyXG4gICAgdmFyIFRpcFdpbmRvd05vZGUgPSByZXF1aXJlKFwiLi9ub2RlL1RpcFdpbmRvd05vZGVcIik7XHJcbiAgICB2YXIgU2VydmVyTm9kZSA9IHJlcXVpcmUoXCIuL25vZGUvcmFjay9TZXJ2ZXJOb2RlXCIpO1xyXG4gICAgdmFyIFN3aXRjaE5vZGUgPSByZXF1aXJlKFwiLi9ub2RlL3JhY2svU3dpdGNoTm9kZVwiKTtcclxuICAgIHZhciBFbXB0eUZsb29yTm9kZSA9IHJlcXVpcmUoXCIuL25vZGUvcmFjay9FbXB0eUZsb29yTm9kZVwiKTtcclxuICAgIFxyXG5cclxuICAgIHZhciBQb2ludE5vZGUgPSByZXF1aXJlKFwiLi9ub2RlL3RvcG8vUG9pbnROb2RlXCIpO1xyXG4gICAgdmFyIENhcmROb2RlID0gIHJlcXVpcmUoXCIuL25vZGUvdG9wby9DYXJkTm9kZVwiKTtcclxuICAgIHZhciBUb3BvRHJhd05vZGUgPSByZXF1aXJlKFwiLi9ub2RlL3RvcG8vVG9wb0RyYXdOb2RlXCIpO1xyXG4gICAgdmFyIFNlcnZlclRvcG9Ob2RlID0gcmVxdWlyZShcIi4vbm9kZS90b3BvL1NlcnZlclRvcG9Ob2RlXCIpO1xyXG4gICAgdmFyIFNlcnZlclI2MzBOb2RlID0gcmVxdWlyZShcIi4vbm9kZS90b3BvL1NlcnZlclI2MzBOb2RlXCIpO1xyXG4gICAgdmFyIFNlcnZlclI3MzBOb2RlID0gcmVxdWlyZShcIi4vbm9kZS90b3BvL1NlcnZlclI3MzBOb2RlXCIpO1xyXG4gICAgdmFyIFNlcnZlclgzNTUwTm9kZSA9IHJlcXVpcmUoXCIuL25vZGUvdG9wby9TZXJ2ZXJYMzU1ME5vZGVcIik7XHJcbiAgICB2YXIgU2VydmVyWDM2NTBOb2RlID0gcmVxdWlyZShcIi4vbm9kZS90b3BvL1NlcnZlclgzNjUwTm9kZVwiKTtcclxuICAgIHZhciBTZXJ2ZXJSRDM1ME5vZGUgPSByZXF1aXJlKFwiLi9ub2RlL3RvcG8vU2VydmVyUkQzNTBOb2RlXCIpO1xyXG4gICAgdmFyIFNlcnZlclJENjUwTm9kZSA9IHJlcXVpcmUoXCIuL25vZGUvdG9wby9TZXJ2ZXJSRDY1ME5vZGVcIik7XHJcbiAgICB2YXIgU3dpdGNoVG9wb05vZGUgPSByZXF1aXJlKFwiLi9ub2RlL3RvcG8vU3dpdGNoVG9wb05vZGVcIik7XHJcbiAgICB2YXIgU3dpdGNoSGFsZklCTm9kZSA9IHJlcXVpcmUoXCIuL25vZGUvdG9wby9Td2l0Y2hIYWxmSUJOb2RlXCIpO1xyXG4gICAgdmFyIFN3aXRjaEZ1bGxJQk5vZGUgPSByZXF1aXJlKFwiLi9ub2RlL3RvcG8vU3dpdGNoRnVsbElCTm9kZVwiKTtcclxuICAgIHZhciBTd2l0Y2hHTU5vZGUgPSByZXF1aXJlKFwiLi9ub2RlL3RvcG8vU3dpdGNoR01Ob2RlXCIpO1xyXG4gICAgdmFyIFN3aXRjaEtNTm9kZSA9IHJlcXVpcmUoXCIuL25vZGUvdG9wby9Td2l0Y2hLTU5vZGVcIik7XHJcblxyXG4gICAgdmFyIENsdXN0ZXJEcmF3Tm9kZSA9IHJlcXVpcmUoXCIuL25vZGUvY2x1c3Rlci9DbHVzdGVyRHJhd05vZGVcIik7XHJcbiAgICB2YXIgQ2x1c3RlckRhdGFiYXNlTm9kZSA9IHJlcXVpcmUoXCIuL25vZGUvY2x1c3Rlci9DbHVzdGVyRGF0YWJhc2VOb2RlXCIpO1xyXG4gICAgdmFyIENsdXN0ZXJBc21Ob2RlID0gcmVxdWlyZShcIi4vbm9kZS9jbHVzdGVyL0NsdXN0ZXJBc21Ob2RlXCIpO1xyXG4gICAgdmFyIENsdXN0ZXJBc21DZWxsTm9kZSA9IHJlcXVpcmUoXCIuL25vZGUvY2x1c3Rlci9DbHVzdGVyQXNtQ2VsbE5vZGVcIik7XHJcbiAgICB2YXIgQ2x1c3RlcklzZU5vZGUgPSByZXF1aXJlKFwiLi9ub2RlL2NsdXN0ZXIvQ2x1c3RlcklzZU5vZGVcIik7XHJcbiAgICB2YXIgQ2x1c3RlcklzZUNlbGxOb2RlID0gIHJlcXVpcmUoXCIuL25vZGUvY2x1c3Rlci9DbHVzdGVySXNlQ2VsbE5vZGVcIik7XHJcbiBcclxuICAgIC8qKlxyXG4gICAgICog5qC55o2u57uT54K55pWw57uEIOWvvOWHukpTT07moLzlvI/nmoTmlbDmja5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBub2RlcyDnu5PngrnmlbDnu4RcclxuICAgICAqIEByZXR1cm4ge0pTT059IEpTT07moLzlvI/nmoTmlbDmja5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZXhwb3J0SnNvbihuZXR3b3JrTW9kZWwsIG5vZGVzKSB7XHJcbiAgICAgICAgdmFyIGpzb25BcnIgPSBbXTtcclxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoO2krKyl7XHJcbiAgICAgICAgICAgIHZhciBub2RlID0gbm9kZXNbaV07XHJcbiAgICAgICAgICAgIGlmKCBub2RlICYmIG5vZGUudG9KU09OKSB7XHJcbiAgICAgICAgICAgICAgICBqc29uQXJyLnB1c2gobm9kZS50b0pTT04oKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgbmV0d29ya01vZGVsLnNldChcImNoaWxkU2hhcGVzXCIsIGpzb25BcnIpICBcclxuXHJcbiAgICAgICAgcmV0dXJuIG5ldHdvcmtNb2RlbC5vcHRpb247XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICog5qC55o2uIEpTT04g55Sf5oiQ6IqC54K5XHJcbiAgICAgKiBAcGFyYW0gIHtbdHlwZV19IGZpc2hUb3BvQnBtbiBbZGVzY3JpcHRpb25dXHJcbiAgICAgKiBAcGFyYW0gIHtbdHlwZV19IGpzb24gICAgICAgICBbZGVzY3JpcHRpb25dXHJcbiAgICAgKiBAcmV0dXJuIHtbdHlwZV19ICAgICAgICAgICAgICBbZGVzY3JpcHRpb25dXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGZyb21Kc29uKGZpc2hUb3BvTmV0d29yaywganNvbikge1xyXG4gICAgICAgIC8vIDEu5riF56m655S75biDXHJcbiAgICAgICAgZmlzaFRvcG9OZXR3b3JrLmNsZWFyKCk7XHJcbiAgICAgICAgaWYgKCBqc29uLnR5cGUgPT09IFwicmFja1wiICkge1xyXG4gICAgICAgICAgICB2YXIgX3ggPSA1MDtcclxuICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGpzb24uZGF0YS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIG1vZGVsT2JqID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc291cmNlSWQ6IHV0aWwuZ2V0VVVJRCgpLFxyXG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXM6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZToganNvbi5kYXRhW2ldLnJhY2tcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIGJvdW5kczoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB1cHBlckxlZnQ6IHt4OiBfeCwgeTogNTB9IFxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgc3RlbmNpbDoge3R5cGU6IFwiUmFja05vZGVcIn1cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBtb2RlbE9iai5oZWlnaHQgPSAganNvbi5kYXRhW2ldLmhlaWdodCAhPSB1bmRlZmluZWQgPyBqc29uLmRhdGFbaV0uaGVpZ2h0OiA2NDA7XHJcbiAgICAgICAgICAgICAgICBtb2RlbE9iai53aWR0aCA9IGpzb24uZGF0YVtpXS53aWR0aCAhPSB1bmRlZmluZWQgPyBqc29uLmRhdGFbaV0ud2lkdGg6IDIwMDtcclxuICAgICAgICAgICAgICAgIG1vZGVsT2JqLlVEYXRhID0ganNvbi5kYXRhW2ldLlVEYXRhO1xyXG4gICAgICAgICAgICAgICAgbW9kZWxPYmoucmFjayA9IGpzb24uZGF0YVtpXS5uYW1lO1xyXG4gICAgICAgICAgICAgICAgbW9kZWxPYmouaWQgPSAganNvbi5kYXRhW2ldLnJhY2s7XHJcbiAgICAgICAgICAgICAgICBtb2RlbE9iai5kZXNjcmlwdGlvbiA9ICBqc29uLmRhdGFbaV0uZGVzYztcclxuICAgICAgICAgICAgICAgIG1vZGVsT2JqLnNob3dUaXAgPSBqc29uLnNob3dUaXA7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmFja01vZGVsID0gbmV3IE5ldHdvcmtNb2RlbChtb2RlbE9iaik7XHJcbiAgICAgICAgICAgICAgICBmaXNoVG9wb05ldHdvcmsuYWRkTm9kZUJ5TW9kZWwocmFja01vZGVsKTtcclxuICAgICAgICAgICAgICAgIF94ICs9IDI1MDtcclxuICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIGlmKCBqc29uLnR5cGUgPT09IFwidG9wb1wiICkge1xyXG4gICAgICAgICAgICB2YXIgbW9kZWxPYmogPSB7XHJcbiAgICAgICAgICAgICAgICByZXNvdXJjZUlkOiB1dGlsLmdldFVVSUQoKSxcclxuICAgICAgICAgICAgICAgIGJvdW5kczoge1xyXG4gICAgICAgICAgICAgICAgICAgIHVwcGVyTGVmdDoge3g6IDAsIHk6IDB9IFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHN0ZW5jaWw6IHt0eXBlOiBcIlRvcG9EcmF3Tm9kZVwifVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBtb2RlbE9iai5oZWlnaHQgPSAgZmlzaFRvcG9OZXR3b3JrLmhlaWdodDtcclxuICAgICAgICAgICAgbW9kZWxPYmoud2lkdGggPSBmaXNoVG9wb05ldHdvcmsud2lkdGg7XHJcbiAgICAgICAgICAgIG1vZGVsT2JqLm5vZGVMaXN0ID0ganNvbi5kYXRhO1xyXG4gICAgICAgICAgICBtb2RlbE9iai5zaG93VGlwID0ganNvbi5zaG93VGlwO1xyXG4gICAgICAgICAgICB2YXIgdG9wb01vZGVsID0gbmV3IE5ldHdvcmtNb2RlbChtb2RlbE9iaik7XHJcbiAgICAgICAgICAgIGZpc2hUb3BvTmV0d29yay5hZGROb2RlQnlNb2RlbCh0b3BvTW9kZWwpO1xyXG4gICAgICAgIH0gZWxzZSBpZigganNvbi50eXBlID09PSBcImNsdXN0ZXJcIiApIHtcclxuICAgICAgICAgICAgdmFyIG1vZGVsT2JqID0ge1xyXG4gICAgICAgICAgICAgICAgcmVzb3VyY2VJZDogdXRpbC5nZXRVVUlEKCksXHJcbiAgICAgICAgICAgICAgICBib3VuZHM6IHtcclxuICAgICAgICAgICAgICAgICAgICB1cHBlckxlZnQ6IHt4OiAwLCB5OiAwfSBcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBzdGVuY2lsOiB7dHlwZTogXCJDbHVzdGVyRHJhd05vZGVcIn1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgbW9kZWxPYmouaGVpZ2h0ID0gIGZpc2hUb3BvTmV0d29yay5oZWlnaHQ7XHJcbiAgICAgICAgICAgIG1vZGVsT2JqLndpZHRoID0gZmlzaFRvcG9OZXR3b3JrLndpZHRoO1xyXG4gICAgICAgICAgICBtb2RlbE9iai5ub2RlTGlzdCA9IGpzb24uZGF0YTtcclxuICAgICAgICAgICAgbW9kZWxPYmouc2hvd1RpcCA9IGpzb24uc2hvd1RpcDtcclxuICAgICAgICAgICAgdmFyIGNsdXN0ZXJNb2RlbCA9IG5ldyBOZXR3b3JrTW9kZWwobW9kZWxPYmopO1xyXG4gICAgICAgICAgICBmaXNoVG9wb05ldHdvcmsuYWRkTm9kZUJ5TW9kZWwoY2x1c3Rlck1vZGVsKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gcmVnaXN0ZXJOZXR3b3JrTm9kZSAoKSB7XHJcbiAgICAgICAgTmV0d29ya05vZGUucmVnaXN0ZXJDbGFzcyhSYWNrTm9kZSwgXCJSYWNrTm9kZVwiKTtcclxuICAgICAgICBOZXR3b3JrTm9kZS5yZWdpc3RlckNsYXNzKFRpcFdpbmRvd05vZGUsIFwiVGlwV2luZG93Tm9kZVwiKTtcclxuICAgICAgICBOZXR3b3JrTm9kZS5yZWdpc3RlckNsYXNzKFNlcnZlck5vZGUsIFwiU2VydmVyTm9kZVwiKTtcclxuICAgICAgICBOZXR3b3JrTm9kZS5yZWdpc3RlckNsYXNzKFN3aXRjaE5vZGUsIFwiU3dpdGNoTm9kZVwiKTtcclxuICAgICAgICBOZXR3b3JrTm9kZS5yZWdpc3RlckNsYXNzKEVtcHR5Rmxvb3JOb2RlLCBcIkVtcHR5Rmxvb3JOb2RlXCIpO1xyXG5cclxuICAgICAgICBOZXR3b3JrTm9kZS5yZWdpc3RlckNsYXNzKFNlcnZlclRvcG9Ob2RlLCBcIlNlcnZlclRvcG9Ob2RlXCIpO1xyXG4gICAgICAgIE5ldHdvcmtOb2RlLnJlZ2lzdGVyQ2xhc3MoVG9wb0RyYXdOb2RlLCBcIlRvcG9EcmF3Tm9kZVwiKTtcclxuICAgICAgICBOZXR3b3JrTm9kZS5yZWdpc3RlckNsYXNzKFNlcnZlclI2MzBOb2RlLCBcIlNlcnZlclI2MzBOb2RlXCIpO1xyXG4gICAgICAgIE5ldHdvcmtOb2RlLnJlZ2lzdGVyQ2xhc3MoU2VydmVyUjczME5vZGUsIFwiU2VydmVyUjczME5vZGVcIik7XHJcbiAgICAgICAgTmV0d29ya05vZGUucmVnaXN0ZXJDbGFzcyhQb2ludE5vZGUsIFwiUG9pbnROb2RlXCIpOyBcclxuICAgICAgICBOZXR3b3JrTm9kZS5yZWdpc3RlckNsYXNzKENhcmROb2RlLCBcIkNhcmROb2RlXCIpOyBcclxuICAgICAgICBOZXR3b3JrTm9kZS5yZWdpc3RlckNsYXNzKFNlcnZlclgzNTUwTm9kZSwgXCJTZXJ2ZXJYMzU1ME5vZGVcIik7IFxyXG4gICAgICAgIE5ldHdvcmtOb2RlLnJlZ2lzdGVyQ2xhc3MoU2VydmVyWDM2NTBOb2RlLCBcIlNlcnZlclgzNjUwTm9kZVwiKTsgXHJcbiAgICAgICAgTmV0d29ya05vZGUucmVnaXN0ZXJDbGFzcyhTZXJ2ZXJSRDM1ME5vZGUsIFwiU2VydmVyUkQzNTBOb2RlXCIpO1xyXG4gICAgICAgIE5ldHdvcmtOb2RlLnJlZ2lzdGVyQ2xhc3MoU2VydmVyUkQ2NTBOb2RlLCBcIlNlcnZlclJENjUwTm9kZVwiKTtcclxuICAgICAgICBOZXR3b3JrTm9kZS5yZWdpc3RlckNsYXNzKFN3aXRjaEZ1bGxJQk5vZGUsIFwiU3dpdGNoRnVsbElCTm9kZVwiKTtcclxuICAgICAgICBOZXR3b3JrTm9kZS5yZWdpc3RlckNsYXNzKFN3aXRjaEhhbGZJQk5vZGUsIFwiU3dpdGNoSGFsZklCTm9kZVwiKTtcclxuICAgICAgICBOZXR3b3JrTm9kZS5yZWdpc3RlckNsYXNzKFN3aXRjaEtNTm9kZSwgXCJTd2l0Y2hLTU5vZGVcIik7XHJcbiAgICAgICAgTmV0d29ya05vZGUucmVnaXN0ZXJDbGFzcyhTd2l0Y2hHTU5vZGUsIFwiU3dpdGNoR01Ob2RlXCIpOyBcclxuICAgICAgICBcclxuICAgICAgICBOZXR3b3JrTm9kZS5yZWdpc3RlckNsYXNzKENsdXN0ZXJEcmF3Tm9kZSwgXCJDbHVzdGVyRHJhd05vZGVcIik7IFxyXG4gICAgICAgIE5ldHdvcmtOb2RlLnJlZ2lzdGVyQ2xhc3MoQ2x1c3RlckRhdGFiYXNlTm9kZSwgXCJDbHVzdGVyRGF0YWJhc2VOb2RlXCIpOyBcclxuICAgICAgICBOZXR3b3JrTm9kZS5yZWdpc3RlckNsYXNzKENsdXN0ZXJBc21Ob2RlLCBcIkNsdXN0ZXJBc21Ob2RlXCIpOyAgXHJcbiAgICAgICAgTmV0d29ya05vZGUucmVnaXN0ZXJDbGFzcyhDbHVzdGVyQXNtQ2VsbE5vZGUsIFwiQ2x1c3RlckFzbUNlbGxOb2RlXCIpOyBcclxuICAgICAgICBOZXR3b3JrTm9kZS5yZWdpc3RlckNsYXNzKENsdXN0ZXJJc2VOb2RlLCBcIkNsdXN0ZXJJc2VOb2RlXCIpOyBcclxuICAgICAgICBOZXR3b3JrTm9kZS5yZWdpc3RlckNsYXNzKENsdXN0ZXJJc2VDZWxsTm9kZSwgXCJDbHVzdGVySXNlQ2VsbE5vZGVcIik7IFxyXG4gICAgICAgICAgICAgICAgICAgICBcclxuICAgIH0gICBcclxuXHJcbiAgICB2YXIgTmV4dFdvcmtVdGlsID0ge1xyXG4gICAgICAgIGV4cG9ydEpzb246IGV4cG9ydEpzb24sXHJcbiAgICAgICAgZnJvbUpzb246IGZyb21Kc29uLFxyXG4gICAgICAgIHJlZ2lzdGVyTmV0d29ya05vZGU6IHJlZ2lzdGVyTmV0d29ya05vZGVcclxuICAgIH07XHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IE5leHRXb3JrVXRpbDtcclxuXHJcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9saWIvZmlzaC10b3BvLW5ldHdvcmsvbGliL05ldHdvcmtVdGlsLmpzXG4gKiogbW9kdWxlIGlkID0gODBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlxyXG5cdHZhciBOb2RlID0gcmVxdWlyZShcIi4uLy4uLy4uL2Zpc2gtdG9wby1jb3JlL2xpYi9Ob2RlXCIpO1xyXG5cdHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcclxuXHR2YXIgZ3JhcGhpYyA9IHJlcXVpcmUoXCIuLi8uLi8uLi9maXNoLXRvcG8tY29yZS9saWIvZ3JhcGhpYy5qc1wiKTtcclxuXHR2YXIgY2xhenpVdGlsID0gcmVxdWlyZSgnLi4vLi4vLi4vZmlzaC10b3BvLWNvcmUvbGliL2NsYXp6Jyk7XHJcblx0XHJcblx0Ly/liJvlu7pOb2Rl57G7IOaJgOacieW9oueKtumDvee7p+aJv05vZGUgIOWMheaLrGZyb21KU09OIHRvSlNPTlxyXG5cdGZ1bmN0aW9uIFRpcFdpbmRvd05vZGUobW9kZWwsIGFwaSkge1xyXG5cdFx0Tm9kZS5jYWxsKHRoaXMpO1xyXG5cdFx0dGhpcy5tb2RlbCA9IG1vZGVsO1x0XHRcclxuXHRcdHRoaXMubmV4dHdvcmtJbmZvID0ge3R5cGU6IC0xLCBuYW1lOlwiVGlwV2luZG93Tm9kZURpYWdyYW1cIiB9OyAgICAvL+iKgueCueS/oeaBr1xyXG5cdFx0dGhpcy5pbml0RXZlbnQoYXBpKTtcclxuICAgICAgICB0aGlzLnJlbmRlcihtb2RlbCwgYXBpKTtcclxuXHR9O1xyXG5cclxuICAgIFRpcFdpbmRvd05vZGUucHJvdG90eXBlLmluaXRFdmVudCA9IGZ1bmN0aW9uKGFwaSkge1xyXG4gICAgICAgIC8vIHZhciB0aGF0ID0gdGhpcztcclxuICAgICAgICAvLyB2YXIgTU9VU0VfRVZFTlRfTkFNRVMgPSBbJ2NsaWNrJywgJ21vdXNlb3ZlcicsICdtb3VzZW91dCddOy8vJ2NsaWNrJywgJ2RibGNsaWNrJywgJ21vdXNlb3ZlcicsICdtb3VzZW91dCdcclxuICAgICAgICAvLyB6clV0aWwuZWFjaChNT1VTRV9FVkVOVF9OQU1FUywgZnVuY3Rpb24gKGV2ZU5hbWUpIHtcclxuICAgICAgICAvLyAgICAgdGhhdC5vbihldmVOYW1lLCBmdW5jdGlvbiAoZSkge1xyXG5cdCAgICAgICAvLyAgICAgIHZhciBwYXJhbXMgPSB7fTtcclxuXHQgICAgICAgLy8gICAgICBwYXJhbXMuZXZlbnQgPSBlO1xyXG5cdCAgICAgICAvLyAgICAgIHBhcmFtcy50eXBlID0gZXZlTmFtZTtcclxuXHQgICAgICAgLy8gICAgICBwYXJhbXMubW9kZWwgPSB0aGF0Lm1vZGVsXHJcblx0ICAgICAgIC8vICAgICAgYXBpLnRyaWdnZXIoZXZlTmFtZSwgcGFyYW1zKTsgXHJcbiAgICAgICAgLy8gICAgIH0sIHRoaXMpO1xyXG4gICAgICAgIC8vIH0sIHRoaXMpO1xyXG4gICAgfTtcdFxyXG5cclxuXHRUaXBXaW5kb3dOb2RlLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbihtb2RlbCwgYXBpKSB7XHJcblx0XHR2YXIgX3ggPSBtb2RlbC54O1xyXG4gICAgICAgIHZhciBfeSA9IG1vZGVsLnk7XHJcbiAgICAgICAgdmFyIF94V2lkdGggPSBtb2RlbC5lV2lkdGg7XHJcbiAgICAgICAgdmFyIF93aWR0aCA9IG1vZGVsLndpZHRoO1xyXG4gICAgICAgIHZhciBfaGVpZ2h0ID0gbW9kZWwuaGVpZ2h0O1xyXG5cdFx0dmFyIHBvaW50cyA9IFtcclxuXHRcdFx0XHRbX3ggKyBfeFdpZHRoICsgMjAsIF95XSxcclxuXHRcdFx0XHRbX3ggKyBfeFdpZHRoLCBfeV0sXHJcblx0XHRcdFx0W194ICsgX3hXaWR0aCArIDIwLCBfeSArIDE1XSxcdFxyXG5cdFx0XHRcdFtfeCArIF94V2lkdGggKyAyMCwgX3kgKyBfaGVpZ2h0XSxcclxuXHRcdFx0XHRbX3ggKyBfeFdpZHRoICsgX3dpZHRoLCBfeSArIF9oZWlnaHRdLFxyXG5cdFx0XHRcdFtfeCArIF94V2lkdGggKyBfd2lkdGgsIF95XVxyXG5cdFx0XHRdO1xyXG5cdFx0aWYgKCBtb2RlbC5sYXlvdXQgIT0gdW5kZWZpbmVkICYmIG1vZGVsLmxheW91dCA9PT0gXCJ1cFwiICkge1xyXG5cdFx0XHRwb2ludHMgPSBbXHJcblx0XHRcdFx0W194ICsgX3hXaWR0aCArIDIwLCBfeV0sXHJcblx0XHRcdFx0W194ICsgX3hXaWR0aCwgX3ldLFxyXG5cdFx0XHRcdFtfeCArIF94V2lkdGggKyAyMCwgX3kgLSAxNV0sXHRcclxuXHRcdFx0XHRbX3ggKyBfeFdpZHRoICsgMjAsIF95IC0gX2hlaWdodF0sXHJcblx0XHRcdFx0W194ICsgX3hXaWR0aCArIF93aWR0aCwgX3kgLSBfaGVpZ2h0XSxcclxuXHRcdFx0XHRbX3ggKyBfeFdpZHRoICsgX3dpZHRoLCBfeV1cclxuXHRcdFx0XTtcclxuXHRcdH0gXHJcblxyXG5cdFx0aWYgKCBtb2RlbC5sYXlvdXQgIT0gdW5kZWZpbmVkICYmIG1vZGVsLmxheW91dCA9PT0gXCJsZWZ0XCIgKSB7XHJcblx0XHRcdHBvaW50cyA9IFtcclxuXHRcdFx0XHRbX3ggLSAyICogX3dpZHRoIC0gMTAsIF95XSxcclxuXHRcdFx0XHRbX3ggLSAyICogX3dpZHRoICsgMTAsIF95XSxcclxuXHRcdFx0XHRbX3ggLSAyICogX3dpZHRoIC0gMTAsIF95ICsgMTVdLFx0XHJcblx0XHRcdFx0W194IC0gMiAqIF93aWR0aCAtIDEwLCBfeSArIF9oZWlnaHRdLFxyXG5cdFx0XHRcdFtfeCAtIDIgKiBfd2lkdGggLSBfd2lkdGgsIF95ICsgX2hlaWdodF0sXHJcblx0XHRcdFx0W194IC0gMiAqIF93aWR0aCAtIF93aWR0aCwgX3ldXHJcblx0XHRcdF07XHJcblx0XHR9XHRcclxuXHRcdHZhciBfdGlwQ29udGV4dCA9IFwi6K+35p+l6K+i5pWw5o2uXCI7XHJcblx0XHRpZiAoIG1vZGVsLnBhcm1EYXRlICE9PSB1bmRlZmluZWQgKSB7XHJcblx0XHRcdGlmKCBtb2RlbC5wYXJtRGF0ZS50eXBlID09PSBcInN3aXRjaFwiICkge1xyXG5cdFx0XHRcdF90aXBDb250ZXh0ID0gJ2hvc3RuYW1lOiAnKyBtb2RlbC5wYXJtRGF0ZS5ob3N0bmFtZSArJyBcXG4gc3RhdHVzOiAnICsgbW9kZWwucGFybURhdGUuc3RhdHVzICsgJyBcXG4gZmxvb3I6ICcgKyBtb2RlbC5wYXJtRGF0ZS5mbG9vciArICAnXFxuIGhlaWdodDogJyArIG1vZGVsLnBhcm1EYXRlLmhlaWdodCArIFwiXFxuIHZlbmRvcjpcIiArICBtb2RlbC5wYXJtRGF0ZS52ZW5kb3I7XHJcblx0XHRcdFxyXG5cdFx0XHR9IGVsc2UgaWYoIG1vZGVsLnBhcm1EYXRlLm5vZGVUeXBlID09PSBcIkVtcHR5Rmxvb3JOb2RlXCIgKSB7XHJcblx0XHRcdFx0X3RpcENvbnRleHQgPSAnZmxvb3I6ICcgKyBtb2RlbC5wYXJtRGF0ZS5mbG9vcjtcclxuXHRcdFx0XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0X3RpcENvbnRleHQgPSAnaG9zdG5hbWU6ICcrIG1vZGVsLnBhcm1EYXRlLmhvc3RuYW1lICsnIFxcbiBzdGF0dXM6ICcgKyBtb2RlbC5wYXJtRGF0ZS5zdGF0dXMgKyAnIFxcbiAgSXA6ICcgKyBtb2RlbC5wYXJtRGF0ZS5pcGFkZHJlc3MgKyAgJ1xcbiBmbG9vcjogJyArIG1vZGVsLnBhcm1EYXRlLmZsb29yICsgICdcXG4gaGVpZ2h0OiAnICsgbW9kZWwucGFybURhdGUuaGVpZ2h0ICsgXCJcXG4gdmVuZG9yOlwiICsgIG1vZGVsLnBhcm1EYXRlLnZlbmRvcjtcclxuXHRcdFx0fVxyXG5cdFx0XHRcclxuXHRcdFx0aWYgKCBtb2RlbC5wYXJtRGF0ZS50aXBDb250ZXh0ICE9PSB1bmRlZmluZWQgKSB7XHJcblx0XHRcdFx0X3RpcENvbnRleHQgPSBtb2RlbC5wYXJtRGF0ZS50aXBDb250ZXh0O1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRcclxuXHRcdHZhciB0aXAgPSBuZXcgZ3JhcGhpYy5Qb2x5Z29uKHtcclxuICAgICAgICAgICAgc2hhcGU6IHtcclxuICAgICAgICAgICAgICAgIHBvaW50czogcG9pbnRzXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHN0eWxlOiB7XHJcblx0XHRcdFx0c3Ryb2tlOiAncmdiYSgxNzQsIDE3NCwxNzQsIDEuMCknLFxyXG5cdFx0XHRcdGZpbGw6ICdyZ2JhKDI1NSwgMjU1LCAyNTUsIDEuMCknLFxyXG5cdFx0XHRcdGxpbmVXaWR0aDogMSxcclxuXHRcdFx0XHR0ZXh0OiBfdGlwQ29udGV4dCxcclxuXHRcdFx0XHR0ZXh0QWxpZ246ICdjZW50ZXInLy8sXHJcblx0XHRcdFx0Ly90ZXh0UG9zaXRpb246ICdsZWZ0JyxcclxuXHRcdFx0XHQvL3Ntb290aDogJ2JlemllcidcdFxyXG5cdFx0XHR9LCAgIFxyXG5cdFx0XHR6OiAxMDAwICAgICBcclxuICAgICAgICB9KTsgICAgICAgIFxyXG4gICAgICAgIHRoaXMuYWRkKHRpcCk7XHJcblx0fTtcclxuXHJcblx0enJVdGlsLmluaGVyaXRzKFRpcFdpbmRvd05vZGUsIE5vZGUpO1xyXG5cclxuXHJcblx0bW9kdWxlLmV4cG9ydHMgPSBUaXBXaW5kb3dOb2RlO1xyXG5cclxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2xpYi9maXNoLXRvcG8tbmV0d29yay9saWIvbm9kZS9UaXBXaW5kb3dOb2RlLmpzXG4gKiogbW9kdWxlIGlkID0gODFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlxyXG4gICAgdmFyIE5ldHdvcmtOb2RlID0gcmVxdWlyZShcIi4uL05ldHdvcmtOb2RlXCIpO1xyXG4gICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcclxuICAgIHZhciBncmFwaGljID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uL2Zpc2gtdG9wby1jb3JlL2xpYi9ncmFwaGljLmpzXCIpO1xyXG4gICAgZnVuY3Rpb24gU2VydmVyTm9kZShtb2RlbCxhcGkpIHtcclxuICAgICAgICBOZXR3b3JrTm9kZS5jYWxsKHRoaXMsIG1vZGVsLCBhcGkpO1xyXG4gICAgICAgIHRoaXMuc2VydmVySW5mbyA9IHt0eXBlOiAtMSwgbmFtZTogXCJTZXJ2ZXJOb2RlXCIgfTsgICAgLy9cclxuICAgICAgICB0aGlzLm1vZGVsID0gbW9kZWw7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVyKG1vZGVsLGFwaSk7XHJcbiAgICB9O1xyXG5cclxuICAgIFxyXG4gICAgICAgIFxyXG4gICAgU2VydmVyTm9kZS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24obW9kZWwsIGFwaSkge1xyXG4gICAgICAgIHRoaXMubW9kZWwgPSBtb2RlbDtcclxuICAgICAgICB2YXIgc3RhdHVzID0gbW9kZWwuZ2V0KFwic3RhdHVzXCIpO1xyXG4gICAgICAgIHZhciBpbWFnZVVybCA9ICcuLi8uLi8uLi8uLi9maXNoLXRvcG8tbmV0d29yay9zcmMvaW1hZ2VzLycgKyBtb2RlbC5nZXQoXCJzZXJ2ZXJUeXBlXCIpIDtcclxuICAgICAgICAvLyBpZiAoIHN0YXR1cyAhPT0gXCJcIiAmJiBzdGF0dXMgIT09IG51bGwgJiYgc3RhdHVzICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAvLyAgICAgIGltYWdlVXJsICs9IHN0YXR1cztcclxuICAgICAgICAvLyB9XHJcbiAgICAgICAgaW1hZ2VVcmwgKz0gJy5wbmcnO1xyXG5cclxuICAgICAgICAvL9e0zKwgXHJcbiAgICAgICAgdmFyIGNlbGxTdGF0ZU5vZGUgPSBuZXcgZ3JhcGhpYy5DaXJjbGUoe1xyXG4gICAgICAgICAgICAgc2hhcGU6IHtcclxuICAgICAgICAgICAgICAgIGN4OiAxMCxcclxuICAgICAgICAgICAgICAgIGN5OiAoMTUgKiBtb2RlbC5nZXQoXCJmbG9vck51bVwiKSAtIDMpIC8gMixcclxuICAgICAgICAgICAgICAgIHI6IDRcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgIGZpbGw6ICcjMDc3ODI2JyxcclxuICAgICAgICAgICAgICAgIG9wYWNpdHk6IDEsXHJcbiAgICAgICAgICAgICAgICBzdHJva2U6ICcjQjNCM0IzJyxcclxuICAgICAgICAgICAgICAgIGxpbmVXaWR0aDogJzInLy8sKi9cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgejogMTAwMCBcclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAoIHN0YXR1cyAhPT0gXCJcIiAmJiBzdGF0dXMgIT09IG51bGwgJiYgc3RhdHVzID09PSBcIm9mZmxpbmVcIikge1xyXG4gICAgICAgICAgICBjZWxsU3RhdGVOb2RlLnN0eWxlLmZpbGwgPSBcIiM5OTk5OTlcIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5hZGQoY2VsbFN0YXRlTm9kZSk7XHJcblxyXG4gICAgICAgIHZhciByZWN0U2VydmVyID0gbmV3IGdyYXBoaWMuSW1hZ2Uoe1xyXG4gICAgICAgICAgICBwb3NpdGlvbjogWzAsIDBdLFxyXG4gICAgICAgICAgICBzY2FsZTogWzEsIDFdLFxyXG4gICAgICAgICAgICBzdHlsZToge1xyXG4gICAgICAgICAgICAgICAgeDogMCxcclxuICAgICAgICAgICAgICAgIHk6IDAsXHJcbiAgICAgICAgICAgICAgICBpbWFnZTogaW1hZ2VVcmwsXHJcbiAgICAgICAgICAgICAgICB3aWR0aDogbW9kZWwuZ2V0KFwid2lkdGhcIiksXHJcbiAgICAgICAgICAgICAgICBoZWlnaHQ6ICAxNSAqIG1vZGVsLmdldChcImZsb29yTnVtXCIpIC0gM1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBkcmFnZ2FibGU6IGZhbHNlLFxyXG4gICAgICAgICAgICBwYXJtRGF0ZTogbW9kZWwuZ2V0KFwicGFybURhdGVcIikgICAgXHJcbiAgICAgICAgfSk7IFxyXG4gICAgICAgIC8vcmVjdFNlcnZlci5wb3NpdGlvbiA9IFttb2RlbC5nZXQoXCJib3VuZHMudXBwZXJMZWZ0LnhcIiksIG1vZGVsLmdldChcImJvdW5kcy51cHBlckxlZnQueVwiKV07XHJcbiAgICAgICAgdGhpcy5hZGQocmVjdFNlcnZlcik7XHJcblxyXG4gICAgICAgIHRoaXMucG9zaXRpb24gPSBbbW9kZWwuZ2V0KFwiYm91bmRzLnVwcGVyTGVmdC54XCIpICwgbW9kZWwuZ2V0KFwiYm91bmRzLnVwcGVyTGVmdC55XCIpXTtcclxuICAgICAgICAvLyByZXR1cm4gcmVjdFNlcnZlcjtcclxuICAgIH07XHJcblxyXG4gICAgenJVdGlsLmluaGVyaXRzKFNlcnZlck5vZGUsIE5ldHdvcmtOb2RlKTtcclxuICAgIG1vZHVsZS5leHBvcnRzID0gU2VydmVyTm9kZTtcclxuXHJcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9saWIvZmlzaC10b3BvLW5ldHdvcmsvbGliL25vZGUvcmFjay9TZXJ2ZXJOb2RlLmpzXG4gKiogbW9kdWxlIGlkID0gODJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlxyXG4gICAgdmFyIE5ldHdvcmtOb2RlID0gcmVxdWlyZShcIi4uL05ldHdvcmtOb2RlXCIpO1xyXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xyXG4gICAgdmFyIGdyYXBoaWMgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vZmlzaC10b3BvLWNvcmUvbGliL2dyYXBoaWMuanNcIik7XHJcbiAgICBmdW5jdGlvbiBTd2l0Y2hOb2RlKG1vZGVsLGFwaSkge1xyXG4gICAgICAgIE5ldHdvcmtOb2RlLmNhbGwodGhpcywgbW9kZWwsIGFwaSk7XHJcbiAgICAgICAgdGhpcy5zZXJ2ZXJJbmZvID0ge3R5cGU6IC0xLCBuYW1lOiBcIlN3aXRjaE5vZGVcIiB9OyAgICAvL1xyXG4gICAgICAgIHRoaXMubW9kZWwgPSBtb2RlbDtcclxuICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXIobW9kZWwsYXBpKTtcclxuICAgIH07XHJcblxyXG4gICAgU3dpdGNoTm9kZS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24obW9kZWwsYXBpKSB7XHJcbiAgICAgICAgdGhpcy5tb2RlbCA9IG1vZGVsO1xyXG4gICAgICAgIHZhciBfcHggPSBtb2RlbC5nZXQoXCJib3VuZHMudXBwZXJMZWZ0LnhcIik7XHJcbiAgICAgICAgdmFyIF9weSA9IG1vZGVsLmdldChcImJvdW5kcy51cHBlckxlZnQueVwiKTtcclxuICAgICAgICB2YXIgX2hlaWdodCA9IG1vZGVsLmdldChcImhlaWdodFwiKTtcclxuICAgICAgICB2YXIgX3dpZHRoID0gbW9kZWwuZ2V0KFwid2lkdGhcIik7XHJcbiAgICAgICAgaWYobW9kZWwuZ2V0KFwiY29sdW1uXCIpID09PSB1bmRlZmluZWQgfHwgbW9kZWwuZ2V0KFwiY29sdW1uXCIpID09PSBcImFsbFwiICkge1xyXG4gICAgICAgICAgICBcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBfd2lkdGggPSBtb2RlbC5nZXQoXCJ3aWR0aFwiKSAvIDIgLSA1O1xyXG4gICAgICAgICAgICBpZiAoIG1vZGVsLmdldChcImNvbHVtblwiKSA9PT0gXCJyaWdodFwiICkge1xyXG4gICAgICAgICAgICAgICAgIF9weCA9IDUgKyBfd2lkdGggKyA1O1xyXG4gICAgICAgICAgICB9ICAgICAgXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciByZWN0U3dpdGNoID0gbmV3IGdyYXBoaWMuSW1hZ2Uoe1xyXG4gICAgICAgICAgICBwb3NpdGlvbjogWzAsIDBdLFxyXG4gICAgICAgICAgICBzY2FsZTogWzEsIDFdLFxyXG4gICAgICAgICAgICBzdHlsZToge1xyXG4gICAgICAgICAgICAgICAgeDogMCxcclxuICAgICAgICAgICAgICAgIHk6IDAsXHJcbiAgICAgICAgICAgICAgICBpbWFnZTogJy4uLy4uLy4uLy4uL2Zpc2gtdG9wby1uZXR3b3JrL3NyYy9pbWFnZXMvSUJTd2l0Y2hGdWxsLnBuZycsXHJcbiAgICAgICAgICAgICAgICB3aWR0aDogX3dpZHRoLFxyXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAgX2hlaWdodFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBkcmFnZ2FibGU6IGZhbHNlLFxyXG4gICAgICAgICAgICBwYXJtRGF0ZSA6IG1vZGVsLmdldChcInBhcm1EYXRlXCIpICAgIFxyXG4gICAgICAgICAgICAvLyBfcGFybURhdGUgOiBcIjExMVwiICAgICAgIFxyXG4gICAgICAgIH0pOyBcclxuICAgICAgICByZWN0U3dpdGNoLnBvc2l0aW9uID0gWyBfcHgsIF9weV07IFxyXG4gICAgICAgIHJldHVybiByZWN0U3dpdGNoO1xyXG4gICAgfTtcclxuXHJcbiAgICB6clV0aWwuaW5oZXJpdHMoU3dpdGNoTm9kZSwgTmV0d29ya05vZGUpO1xyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBTd2l0Y2hOb2RlO1xyXG5cclxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2xpYi9maXNoLXRvcG8tbmV0d29yay9saWIvbm9kZS9yYWNrL1N3aXRjaE5vZGUuanNcbiAqKiBtb2R1bGUgaWQgPSA4M1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXHJcbiAgICB2YXIgTmV0d29ya05vZGUgPSByZXF1aXJlKFwiLi4vTmV0d29ya05vZGVcIik7XHJcbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XHJcbiAgICB2YXIgZ3JhcGhpYyA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi9maXNoLXRvcG8tY29yZS9saWIvZ3JhcGhpYy5qc1wiKTtcclxuICAgIGZ1bmN0aW9uIEVtcHR5Rmxvb3JOb2RlKG1vZGVsLGFwaSkge1xyXG4gICAgICAgIE5ldHdvcmtOb2RlLmNhbGwodGhpcywgbW9kZWwsIGFwaSk7XHJcbiAgICAgICAgdGhpcy5zZXJ2ZXJJbmZvID0ge3R5cGU6IC0xLCBuYW1lOiBcIkVtcHR5Rmxvb3JOb2RlXCIgfTsgICAgLy9cclxuICAgICAgICB0aGlzLm1vZGVsID0gbW9kZWw7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVyKG1vZGVsLGFwaSk7XHJcbiAgICB9O1xyXG5cclxuICAgIEVtcHR5Rmxvb3JOb2RlLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbihtb2RlbCwgYXBpKSB7XHJcbiAgICAgICAgdGhpcy5tb2RlbCA9IG1vZGVsO1xyXG4gICAgICAgIHZhciByZWN0VHJheSA9IG5ldyBncmFwaGljLlJlY3Qoe1xyXG4gICAgICAgICAgICAgICAgc2hhcGU6IHtcclxuICAgICAgICAgICAgICAgICAgICB4OiAwLFxyXG4gICAgICAgICAgICAgICAgICAgIHk6IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IG1vZGVsLmdldChcIndpZHRoXCIpIC0gMTAsXHJcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiAxNVxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgZmlsbDogJyNGRkZGRkYnLFxyXG4gICAgICAgICAgICAgICAgICAgIHN0cm9rZTogJyNCM0IzQjMnLFxyXG4gICAgICAgICAgICAgICAgICAgIGxpbmVEYXNoOiBbM10sICBcclxuICAgICAgICAgICAgICAgICAgICBsaW5lV2lkdGg6ICcxJy8vLFxyXG4gICAgICAgICAgICAgICAgfSAgLFxyXG4gICAgICAgICAgICAgICAgZHJhZ2dhYmxlOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIHBhcm1EYXRlOiBtb2RlbC5nZXQoXCJwYXJtRGF0ZVwiKSAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB9KTsgICAgICAgIFxyXG4gICAgICAgIHRoaXMuYWRkKHJlY3RUcmF5KTtcclxuICAgICAgICByZWN0VHJheS5wb3NpdGlvbiA9IFttb2RlbC5nZXQoXCJib3VuZHMudXBwZXJMZWZ0LnhcIiksIG1vZGVsLmdldChcImJvdW5kcy51cHBlckxlZnQueVwiKV07IFxyXG4gICAgICAgIHJldHVybiByZWN0VHJheTtcclxuXHJcbiAgICAgICAgLy8gdmFyIHJlY3RTZXJ2ZXIgPSBuZXcgZ3JhcGhpYy5JbWFnZSh7XHJcbiAgICAgICAgLy8gICAgIHBvc2l0aW9uOiBbMCwgMF0sXHJcbiAgICAgICAgLy8gICAgIHNjYWxlOiBbMSwgMV0sXHJcbiAgICAgICAgLy8gICAgIHN0eWxlOiB7XHJcbiAgICAgICAgLy8gICAgICAgICB4OiAwLFxyXG4gICAgICAgIC8vICAgICAgICAgeTogMCxcclxuICAgICAgICAvLyAgICAgICAgIGltYWdlOiAnLi9mcm0vZmlzaC1kZXNrdG9wL3RoaXJkLXBhcnR5L2Zpc2gtdG9wby9maXNoLXRvcG8tbmV0d29yay9zcmMvaW1hZ2VzL2xlbm92b1JkNjUwYS5wbmcnLFxyXG4gICAgICAgIC8vICAgICAgICAgd2lkdGg6IG1vZGVsLmdldChcIndpZHRoXCIpIC0gMTAsXHJcbiAgICAgICAgLy8gICAgICAgICBoZWlnaHQ6ICAxNVxyXG4gICAgICAgIC8vICAgICB9LFxyXG4gICAgICAgIC8vICAgICBkcmFnZ2FibGU6IGZhbHNlXHJcbiAgICAgICAgLy8gfSk7IFxyXG4gICAgICAgIC8vIHJlY3RTZXJ2ZXIucG9zaXRpb24gPSBbbW9kZWwuZ2V0KFwiYm91bmRzLnVwcGVyTGVmdC54XCIpLCBtb2RlbC5nZXQoXCJib3VuZHMudXBwZXJMZWZ0LnlcIildO1xyXG4gICAgICAgIC8vIHJldHVybiByZWN0U2VydmVyO1xyXG5cclxuICAgIH07XHJcbiAgICB6clV0aWwuaW5oZXJpdHMoRW1wdHlGbG9vck5vZGUsIE5ldHdvcmtOb2RlKTtcclxuICAgIG1vZHVsZS5leHBvcnRzID0gRW1wdHlGbG9vck5vZGU7XHJcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9saWIvZmlzaC10b3BvLW5ldHdvcmsvbGliL25vZGUvcmFjay9FbXB0eUZsb29yTm9kZS5qc1xuICoqIG1vZHVsZSBpZCA9IDg0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcclxuICAgIHZhciB1dGlsID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uL2Zpc2gtdG9wby1jb3JlL2xpYi91dGlsLmpzXCIpO1xyXG4gICAgdmFyIE5ldHdvcmtOb2RlID0gcmVxdWlyZShcIi4uL05ldHdvcmtOb2RlXCIpO1xyXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xyXG4gICAgdmFyIGdyYXBoaWMgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vZmlzaC10b3BvLWNvcmUvbGliL2dyYXBoaWMuanNcIik7XHJcbiAgICB2YXIgTmV0d29ya01vZGVsID0gcmVxdWlyZShcIi4uLy4uL21vZGVsL05ldHdvcmtNb2RlbC5qc1wiKTtcclxuICAgIFxyXG4gICAgZnVuY3Rpb24gUG9pbnROb2RlKG1vZGVsLGFwaSkge1xyXG4gICAgICAgIE5ldHdvcmtOb2RlLmNhbGwodGhpcywgbW9kZWwsIGFwaSk7XHJcbiAgICAgICAgdGhpcy5yYWNra0luZm8gPSB7dHlwZTogLTEsIG5hbWU6IFwiUG9pbnROb2RlXCIgfTsgICAgXHJcbiAgICAgICAgdGhpcy5tb2RlbCA9IG1vZGVsO1xyXG4gICAgICAgIHRoaXMubGluZUluZm8gPSBtb2RlbC5nZXQoJ2xpbmVJbmZvJyk7XHJcbiAgICAgICAgdGhpcy5yZW5kZXIobW9kZWwsYXBpKTtcclxuICAgIH07XHJcblxyXG4gICAgUG9pbnROb2RlLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbihtb2RlbCwgYXBpKSB7XHJcbiAgICAgICAgdGhpcy5tb2RlbCA9IG1vZGVsO1xyXG4gICAgICAgIHZhciBfdGl0bGUgPSBuZXcgZ3JhcGhpYy5UZXh0KHtcclxuICAgICAgICAgICAgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgIHg6IG1vZGVsLmdldChcIndpZHRoXCIpIC8gMiAtIDEwLFxyXG4gICAgICAgICAgICAgICAgeTogLTIwLFxyXG4gICAgICAgICAgICAgICAgdGV4dDogbW9kZWwuZ2V0KFwibmFtZVwiKSxcclxuICAgICAgICAgICAgICAgIHdpZHRoOiAyMDAsXHJcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDIwLFxyXG4gICAgICAgICAgICAgICAgZmlsbDogJyM4RjhCOEEnLFxyXG4gICAgICAgICAgICAgICAgdGV4dEZvbnQ6ICcxMnB4IE1pY3Jvc29mdCBZYWhlaScsXHJcbiAgICAgICAgICAgICAgICB0ZXh0QmFzZWxpbmU6ICd0b3AnXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGRyYWdnYWJsZTogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vIHRoaXMuYWRkKF90aXRsZSk7XHJcblxyXG4gICAgICAgIHZhciBwb3J0Tm9kZSA9IG5ldyBncmFwaGljLlJlY3Qoe1xyXG4gICAgICAgICAgICBzaGFwZToge1xyXG4gICAgICAgICAgICAgICAgeDogMCxcclxuICAgICAgICAgICAgICAgIHk6IDAsXHJcbiAgICAgICAgICAgICAgICB3aWR0aDogbW9kZWwuZ2V0KFwid2lkdGhcIiksXHJcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IG1vZGVsLmdldChcImhlaWdodFwiKVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBzdHlsZToge1xyXG4gICAgICAgICAgICAgICAgZmlsbDogJyNFMkUzRDknLFxyXG4gICAgICAgICAgICAgICAgc3Ryb2tlOiAnI0IzQjNCMycsXHJcbiAgICAgICAgICAgICAgICBvcGFjaXR5OiAwLjEsXHJcbiAgICAgICAgICAgICAgICBsaW5lV2lkdGg6ICcxJy8vLFxyXG4gICAgICAgICAgICB9ICAgICAgICAgIFxyXG4gICAgICAgIH0pOyAgICAgICAgICAgICAgXHJcbiAgICAgICAgdGhpcy5hZGQocG9ydE5vZGUpO1xyXG5cclxuICAgICAgICB0aGlzLnBvc2l0aW9uID0gW21vZGVsLmdldChcImJvdW5kcy51cHBlckxlZnQueFwiKSAsIG1vZGVsLmdldChcImJvdW5kcy51cHBlckxlZnQueVwiKV07XHJcbiAgICB9O1xyXG5cclxuICAgXHJcblxyXG4gICAgenJVdGlsLmluaGVyaXRzKFBvaW50Tm9kZSwgTmV0d29ya05vZGUpO1xyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBQb2ludE5vZGU7XHJcblxyXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vbGliL2Zpc2gtdG9wby1uZXR3b3JrL2xpYi9ub2RlL3RvcG8vUG9pbnROb2RlLmpzXG4gKiogbW9kdWxlIGlkID0gODVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlxyXG4gICAgdmFyIHV0aWwgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vZmlzaC10b3BvLWNvcmUvbGliL3V0aWwuanNcIik7XHJcbiAgICB2YXIgTmV0d29ya05vZGUgPSByZXF1aXJlKFwiLi4vTmV0d29ya05vZGVcIik7XHJcbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XHJcbiAgICB2YXIgZ3JhcGhpYyA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi9maXNoLXRvcG8tY29yZS9saWIvZ3JhcGhpYy5qc1wiKTtcclxuICAgIHZhciBOZXR3b3JrTW9kZWwgPSByZXF1aXJlKFwiLi4vLi4vbW9kZWwvTmV0d29ya01vZGVsLmpzXCIpO1xyXG4gICAgXHJcbiAgICBmdW5jdGlvbiBDYXJkTm9kZShtb2RlbCxhcGkpIHtcclxuICAgICAgICBOZXR3b3JrTm9kZS5jYWxsKHRoaXMsIG1vZGVsLCBhcGkpO1xyXG4gICAgICAgIHRoaXMucmFja2tJbmZvID0ge3R5cGU6IC0xLCBuYW1lOiBcIkNhcmROb2RlXCIgfTsgICAgXHJcbiAgICAgICAgdGhpcy5tb2RlbCA9IG1vZGVsO1xyXG4gICAgICAgIHRoaXMubGluZUluZm8gPSBtb2RlbC5nZXQoJ2xpbmVJbmZvJyk7XHJcbiAgICAgICAgdGhpcy5wb2ludExpc3QgPSBbXTtcclxuICAgICAgICB0aGlzLnJlbmRlcihtb2RlbCxhcGkpO1xyXG4gICAgfTtcclxuXHJcbiAgICBDYXJkTm9kZS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24obW9kZWwsIGFwaSkge1xyXG4gICAgICAgIHRoaXMubW9kZWwgPSBtb2RlbDtcclxuICAgICAgICB2YXIgX3BvcnREYXRhID0gbW9kZWwuZ2V0KFwicG9ydERhdGFcIik7XHJcbiAgICAgICAgdmFyIF90eXBlID0gbW9kZWwuZ2V0KFwidHlwZVwiKTtcclxuICAgICAgICB2YXIgX2RpcmVjdGlvbiA9IG1vZGVsLmdldChcImRpcmVjdGlvblwiKTtcclxuICAgICAgICB2YXIgaW1nVXJsID0gXCJcIjtcclxuICAgICAgICBpZiggX3R5cGUgPT09IFwiMVwiIHx8IF90eXBlID09PSBcIjNcIiApIHtcclxuICAgICAgICAgICAgaW1nVXJsID0gJy4uLy4uLy4uL3NyYy90aGlyZC1wYXJ0eS9maXNoLXRvcG8vZmlzaC10b3BvLW5ldHdvcmsvc3JjL2ltYWdlcy9JQjEuanBnJztcclxuICAgICAgICB9ZWxzZSBpZiAoIF90eXBlID09PSBcIjVcIiApIHtcclxuICAgICAgICAgICAgaW1nVXJsID0gJy4uLy4uLy4uL3NyYy90aGlyZC1wYXJ0eS9maXNoLXRvcG8vZmlzaC10b3BvLW5ldHdvcmsvc3JjL2ltYWdlcy9rbTIuanBnJztcclxuICAgICAgICB9IGVsc2UgaWYoIF90eXBlID09PSBcIjZcIiApIHtcclxuICAgICAgICAgICAgaW1nVXJsID0gJy4uLy4uLy4uL3NyYy90aGlyZC1wYXJ0eS9maXNoLXRvcG8vZmlzaC10b3BvLW5ldHdvcmsvc3JjL2ltYWdlcy9rbTQuanBnJztcclxuICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAgdmFyIHJlY3RTZXJ2ZXIgPSBuZXcgZ3JhcGhpYy5JbWFnZSh7XHJcbiAgICAgICAgICAgIHNjYWxlOiBbMSwgMV0sXHJcbiAgICAgICAgICAgIHN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgICB4OiAwLFxyXG4gICAgICAgICAgICAgICAgeTogMCxcclxuICAgICAgICAgICAgICAgIGltYWdlOiBpbWdVcmwsXHJcbiAgICAgICAgICAgICAgICB3aWR0aDogbW9kZWwuZ2V0KFwid2lkdGhcIiksXHJcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IG1vZGVsLmdldChcImhlaWdodFwiKVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBkcmFnZ2FibGU6IGZhbHNlLFxyXG4gICAgICAgICAgICBpbnZpc2libGU6IGZhbHNlLFxyXG4gICAgICAgICAgICBwYXJtRGF0ZTogX3BvcnREYXRhXHJcbiAgICAgICAgfSk7IFxyXG4gICAgICAgIHRoaXMuYWRkKHJlY3RTZXJ2ZXIpO1xyXG4gICAgICAgIHJlY3RTZXJ2ZXIuaGlkZSgpO1xyXG5cclxuICAgICAgICB2YXIgX3Jlc291cmNlc05hbWUgPSBtb2RlbC5nZXQoXCJyZXNvdXJjZXNOYW1lXCIpO1xyXG4gICAgICAgIHZhciBfcmVzb3VyY2VOb2RlVHlwZSA9IG1vZGVsLmdldChcInJlc291cmNlTm9kZVR5cGVcIik7XHJcbiAgICAgICAgdmFyIF9ObyA9IG1vZGVsLmdldChcIk5vXCIpO1xyXG4gICAgICAgIGlmICggX2RpcmVjdGlvbiA9PT0gXCJsZWZ0UmlnaHRcIiApIHtcclxuICAgICAgICAgICAgdmFyIF94ID0gNDtcclxuICAgICAgICAgICAgdmFyIF95ID0gMjtcclxuICAgICAgICAgICAgdmFyIF93aWR0aCA9IDg7XHJcbiAgICAgICAgICAgIHZhciBfaGVpZ2h0ID0gNTsgXHJcbiAgICAgICAgICAgIGlmICggX3R5cGUgPT09IFwiMVwiIHx8ICBfdHlwZSA9PT0gXCIyXCIgfHwgIF90eXBlID09PSBcIjNcIiB8fCAgX3R5cGUgPT09IFwiNFwiICkge1xyXG4gICAgICAgICAgICAgICAgX3dpZHRoID0gMjA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBfcG9ydERhdGEubGVuZ3RoOyBpKysgKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcG9ydE1vZGVsID0ge307XHJcbiAgICAgICAgICAgICAgICBwb3J0TW9kZWwgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzb3VyY2VJZDogdXRpbC5nZXRVVUlEKCksICBcclxuICAgICAgICAgICAgICAgICAgICBib3VuZHM6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdXBwZXJMZWZ0OiB7eDogX3gsIHk6IF95fSAgXHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICBzdGVuY2lsOiB7dHlwZTogXCJQb2ludE5vZGVcIn1cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBwb3J0TW9kZWwuaGVpZ2h0ID0gX2hlaWdodDtcclxuICAgICAgICAgICAgICAgIHBvcnRNb2RlbC53aWR0aCA9IF93aWR0aDtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgX2xpbkluZm8gPSB7fTtcclxuICAgICAgICAgICAgICAgIF9saW5JbmZvLnNvdXJjZVJlb3VyY2UgPSBfcmVzb3VyY2VzTmFtZTtcclxuICAgICAgICAgICAgICAgIF9saW5JbmZvLnNvdXJjZUNhcmRObyA9IF9ObztcclxuICAgICAgICAgICAgICAgIF9saW5JbmZvLnNvdXJjZVBvcnQgPSBpO1xyXG4gICAgICAgICAgICAgICAgX2xpbkluZm8ubm9kZXR5cGUgPSBfcmVzb3VyY2VOb2RlVHlwZTsgXHJcbiAgICAgICAgICAgICAgICBfbGluSW5mby5zb3VyY2VTdGF0dXMgPSAgX3BvcnREYXRhW2ldLnN0YXR1czsgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgX2xpbkluZm8udGFyZ2V0UmVvdXJjZSA9IF9wb3J0RGF0YVtpXS50YXJnZXQucmVzb3VyY2VOYW1lIDtcclxuICAgICAgICAgICAgICAgIF9saW5JbmZvLnRhcmdldFBvcnQgPSBfcG9ydERhdGFbaV0udGFyZ2V0LnBvcnQ7XHJcblxyXG4gICAgICAgICAgICAgICAgcG9ydE1vZGVsLmxpbmVJbmZvID0gX2xpbkluZm87XHJcbiAgICAgICAgICAgICAgICB2YXIgcE1vZGVsID0gbmV3IE5ldHdvcmtNb2RlbChwb3J0TW9kZWwpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hZGRQb3J0QnlNb2RlbChwTW9kZWwsIGFwaSk7XHJcbiAgICAgICAgICAgICAgICAgX3ggPSBfeCArIF93aWR0aCArIDI7XHJcbiAgICAgICAgICAgIH0gICAgXHJcbiAgICAgICAgfSBcclxuICAgICAgICBcclxuXHJcbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IFttb2RlbC5nZXQoXCJib3VuZHMudXBwZXJMZWZ0LnhcIikgLCBtb2RlbC5nZXQoXCJib3VuZHMudXBwZXJMZWZ0LnlcIildO1xyXG4gICAgfTtcclxuXHJcbiAgIENhcmROb2RlLnByb3RvdHlwZS5hZGRQb3J0QnlNb2RlbCA9IGZ1bmN0aW9uKCBwX21vZGVsLCBhcGkpIHtcclxuICAgICAgICB2YXIgU2hhcGUgPSBhcGkuZ2V0Tm9kZUNsYXNzKHBfbW9kZWwuZ2V0KFwic3RlbmNpbC50eXBlXCIpKTtcclxuICAgICAgICB2YXIgbm9kZSA9IG51bGw7XHJcbiAgICAgICAgaWYgKCBTaGFwZSApIHtcclxuICAgICAgICAgICAgbm9kZSA9IG5ldyBTaGFwZShwX21vZGVsLCBhcGkpO1xyXG4gICAgICAgICAgICB0aGlzLnBvaW50TGlzdC5wdXNoKG5vZGUpO1xyXG4gICAgICAgICAgICB0aGlzLmFkZChub2RlKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHpyVXRpbC5pbmhlcml0cyhDYXJkTm9kZSwgTmV0d29ya05vZGUpO1xyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBDYXJkTm9kZTtcclxuXHJcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9saWIvZmlzaC10b3BvLW5ldHdvcmsvbGliL25vZGUvdG9wby9DYXJkTm9kZS5qc1xuICoqIG1vZHVsZSBpZCA9IDg2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcclxuICAgIHZhciB1dGlsID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uL2Zpc2gtdG9wby1jb3JlL2xpYi91dGlsLmpzXCIpO1xyXG4gICAgdmFyIE5ldHdvcmtOb2RlID0gcmVxdWlyZShcIi4uL05ldHdvcmtOb2RlXCIpO1xyXG4gICAgdmFyIE5ldFdvcmtMaW5lTm9kZSA9IHJlcXVpcmUoXCIuLi9OZXRXb3JrTGluZU5vZGUuanNcIik7XHJcbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XHJcbiAgICB2YXIgZ3JhcGhpYyA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi9maXNoLXRvcG8tY29yZS9saWIvZ3JhcGhpYy5qc1wiKTtcclxuICAgIHZhciBOZXR3b3JrTW9kZWwgPSByZXF1aXJlKFwiLi4vLi4vbW9kZWwvTmV0d29ya01vZGVsLmpzXCIpO1xyXG4gICAgdmFyIE5ldFdvcmtMaW5lTW9kZWwgPSByZXF1aXJlKFwiLi4vLi4vbW9kZWwvTmV0V29ya0xpbmVNb2RlbC5qc1wiKTtcclxuXHJcbiAgICBmdW5jdGlvbiBUb3BvRHJhd05vZGUobW9kZWwsYXBpKSB7XHJcbiAgICAgICAgTmV0d29ya05vZGUuY2FsbCh0aGlzLCBtb2RlbCwgYXBpKTtcclxuICAgICAgICB0aGlzLnRvcG9JbmZvID0ge3R5cGU6IC0xLCBuYW1lOiBcIlRvcG9EcmF3Tm9kZVwiIH07ICAgIFxyXG4gICAgICAgIHRoaXMubW9kZWwgPSBtb2RlbDtcclxuICAgICAgICB0aGlzLnBvcnRMaXN0ID0gW107XHJcbiAgICAgICAgdGhpcy5yZW5kZXIobW9kZWwsYXBpKTtcclxuICAgIH07XHJcblxyXG4gICAgVG9wb0RyYXdOb2RlLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbihtb2RlbCwgYXBpKSB7XHJcbiAgICAgICAgdmFyIG5vZGVMaXN0ID0gbW9kZWwuZ2V0KFwibm9kZUxpc3RcIik7XHJcbiAgICAgICAgdmFyIHNlcnZlcldpZHRoID0gMTYwOyAvL+acjeWKoeWZqOWuveW6plxyXG4gICAgICAgIHZhciBzd2l0Y2hXaWR0aCA9IDMwMDsgLy/kuqTmjaLmnLrlrr3luqZcclxuICAgICAgICAvL+agueaNrk5vZGXmlbDph4/orqHnrpflrp7pmYXnlLvluIPlrr3luqZcclxuICAgICAgICB2YXIgY2xlbnRXaWR0aCA9IHRoaXMuZ2V0V2lkdGgobm9kZUxpc3QsIHNlcnZlcldpZHRoLCBzd2l0Y2hXaWR0aCk7XHJcbiAgICAgICAgY2xlbnRXaWR0aCA9IGNsZW50V2lkdGggPiBtb2RlbC5nZXQoXCJ3aWR0aFwiKSA/IGNsZW50V2lkdGggOiBtb2RlbC5nZXQoXCJ3aWR0aFwiKTtcclxuICAgICAgICBhcGkucmVzaXplKGNsZW50V2lkdGgsIG1vZGVsLmdldChcImhlaWdodFwiKSk7XHJcblxyXG4gICAgICAgIHRoaXMubW9kZWwgPSBtb2RlbDtcclxuICAgICAgICB2YXIgX3Nob3dUaXAgPSBtb2RlbC5nZXQoXCJzaG93VGlwXCIpO1xyXG5cclxuICAgICAgICB2YXIgX3N0YXJ0WCA9IDEwMCxcclxuICAgICAgICAgICAgX3RleHRXID0gMzAsXHJcbiAgICAgICAgICAgIF9zdGFydFkgPSAxMCxcclxuICAgICAgICAgICAgX3RleHRIID0gMjA7XHJcbiAgICAgICAgdmFyIHRleHRLTSA9IG5ldyBncmFwaGljLlRleHQoe1xyXG4gICAgICAgICAgICBzdHlsZToge1xyXG4gICAgICAgICAgICAgICAgeDogX3N0YXJ0WCxcclxuICAgICAgICAgICAgICAgIHk6IF9zdGFydFksXHJcbiAgICAgICAgICAgICAgICB0ZXh0OiAn5Y2D5YWGJyxcclxuICAgICAgICAgICAgICAgIHdpZHRoOiBfdGV4dFcsXHJcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IF90ZXh0SCxcclxuICAgICAgICAgICAgICAgIGZpbGw6ICcjOEY4QjhBJyxcclxuICAgICAgICAgICAgICAgIHRleHRGb250OiAnMTBweCBNaWNyb3NvZnQgWWFoZWknLFxyXG4gICAgICAgICAgICAgICAgdGV4dEJhc2VsaW5lOiAndG9wJ1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBkcmFnZ2FibGU6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmFkZCh0ZXh0S00pO1xyXG5cclxuICAgICAgICB2YXIgbGluZUtNID0gbmV3IGdyYXBoaWMuTGluZSh7XHJcbiAgICAgICAgICAgIHNoYXBlOiB7XHJcbiAgICAgICAgICAgICAgICB4MSA6IF9zdGFydFggKyBfdGV4dFcsXHJcbiAgICAgICAgICAgICAgICB5MSA6IF9zdGFydFkgKyAxMCxcclxuICAgICAgICAgICAgICAgIHgyIDogX3N0YXJ0WCArIF90ZXh0VyArIDEwMCxcclxuICAgICAgICAgICAgICAgIHkyIDogX3N0YXJ0WSArIDEwLFxyXG4gICAgICAgICAgICAgICAgbGluZVdpZHRoIDogNSwgIFxyXG4gICAgICAgICAgICAgICAgdGV4dCA6ICdsaW5lJ1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBzdHlsZToge1xyXG4gICAgICAgICAgICAgICAgc3Ryb2tlOiAnIzA3MDRFQycsXHJcbiAgICAgICAgICAgICAgICBsaW5lVHlwZSA6ICdzb2xpZCcsLy8gZGVmYXVsdCBzb2xpZFxyXG4gICAgICAgICAgICAgICAgZmlsbDogbnVsbFxyXG4gICAgICAgICAgICB9ICAgICAgICBcclxuICAgICAgICB9KTsgICAgICAgIFxyXG4gICAgICAgIHRoaXMuYWRkKGxpbmVLTSk7XHJcblxyXG4gICAgICAgIF9zdGFydFkgPSBfc3RhcnRZICsgX3RleHRIO1xyXG4gICAgICAgIHZhciB0ZXh0R0IgPSBuZXcgZ3JhcGhpYy5UZXh0KHtcclxuICAgICAgICAgICAgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgIHg6IF9zdGFydFgsXHJcbiAgICAgICAgICAgICAgICB5OiBfc3RhcnRZLFxyXG4gICAgICAgICAgICAgICAgdGV4dDogJ+S4h+WFhicsXHJcbiAgICAgICAgICAgICAgICB3aWR0aDogX3RleHRXLFxyXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBfdGV4dEgsXHJcbiAgICAgICAgICAgICAgICBmaWxsOiAnIzhGOEI4QScsXHJcbiAgICAgICAgICAgICAgICB0ZXh0Rm9udDogJzEwcHggTWljcm9zb2Z0IFlhaGVpJyxcclxuICAgICAgICAgICAgICAgIHRleHRCYXNlbGluZTogJ3RvcCdcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZHJhZ2dhYmxlOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5hZGQodGV4dEdCKTtcclxuXHJcbiAgICAgICAgdmFyIGxpbmVHQiA9IG5ldyBncmFwaGljLkxpbmUoe1xyXG4gICAgICAgICAgICBzaGFwZToge1xyXG4gICAgICAgICAgICAgICAgeDEgOiBfc3RhcnRYICsgX3RleHRXLFxyXG4gICAgICAgICAgICAgICAgeTEgOiBfc3RhcnRZICsgMTAgLFxyXG4gICAgICAgICAgICAgICAgeDIgOiBfc3RhcnRYICsgX3RleHRXICsgMTAwLFxyXG4gICAgICAgICAgICAgICAgeTIgOiBfc3RhcnRZICsgMTAsXHJcbiAgICAgICAgICAgICAgICBsaW5lV2lkdGggOiA1LCAgXHJcbiAgICAgICAgICAgICAgICB0ZXh0IDogJ2xpbmUnXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgICBzdHJva2U6ICcjMDcwNDEzJyxcclxuICAgICAgICAgICAgICAgIGxpbmVUeXBlIDogJ3NvbGlkJywvLyBkZWZhdWx0IHNvbGlkXHJcbiAgICAgICAgICAgICAgICBmaWxsOiBudWxsXHJcbiAgICAgICAgICAgIH0gICAgICAgIFxyXG4gICAgICAgIH0pOyAgICAgICAgXHJcbiAgICAgICAgdGhpcy5hZGQobGluZUdCKTtcclxuXHJcbiAgICAgICAgX3N0YXJ0WSA9ICBfc3RhcnRZICsgX3RleHRIO1xyXG4gICAgICAgIHZhciB0ZXh0SUIgPSBuZXcgZ3JhcGhpYy5UZXh0KHtcclxuICAgICAgICAgICAgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgIHg6IF9zdGFydFgsXHJcbiAgICAgICAgICAgICAgICB5OiBfc3RhcnRZLFxyXG4gICAgICAgICAgICAgICAgdGV4dDogJ0lCJyxcclxuICAgICAgICAgICAgICAgIHdpZHRoOiBfdGV4dFcsXHJcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IF90ZXh0SCxcclxuICAgICAgICAgICAgICAgIGZpbGw6ICcjOEY4QjhBJyxcclxuICAgICAgICAgICAgICAgIHRleHRGb250OiAnMTBweCBNaWNyb3NvZnQgWWFoZWknLFxyXG4gICAgICAgICAgICAgICAgdGV4dEJhc2VsaW5lOiAndG9wJ1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBkcmFnZ2FibGU6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmFkZCh0ZXh0SUIpO1xyXG5cclxuICAgICAgICB2YXIgbGluZUlCID0gbmV3IGdyYXBoaWMuTGluZSh7XHJcbiAgICAgICAgICAgIHNoYXBlOiB7XHJcbiAgICAgICAgICAgICAgICB4MSA6IF9zdGFydFggKyBfdGV4dFcsXHJcbiAgICAgICAgICAgICAgICB5MSA6IF9zdGFydFkgKyAxMCxcclxuICAgICAgICAgICAgICAgIHgyIDogX3N0YXJ0WCArIF90ZXh0VyArIDEwMCxcclxuICAgICAgICAgICAgICAgIHkyIDogX3N0YXJ0WSArIDEwLFxyXG4gICAgICAgICAgICAgICAgbGluZVdpZHRoIDogNSwgIFxyXG4gICAgICAgICAgICAgICAgdGV4dCA6ICdsaW5lJ1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBzdHlsZToge1xyXG4gICAgICAgICAgICAgICAgc3Ryb2tlOiAnIzYyQTRERCcsXHJcbiAgICAgICAgICAgICAgICBsaW5lVHlwZSA6ICdzb2xpZCcsLy8gZGVmYXVsdCBzb2xpZFxyXG4gICAgICAgICAgICAgICAgZmlsbDogbnVsbFxyXG4gICAgICAgICAgICB9ICAgICAgICBcclxuICAgICAgICB9KTsgICAgICAgIFxyXG4gICAgICAgIHRoaXMuYWRkKGxpbmVJQik7XHJcblxyXG4gICAgICAgIC8v5Li757q/5biD5bGAXHJcbiAgICAgICAgdmFyIGxpbmVPdXQgPSBuZXcgZ3JhcGhpYy5MaW5lKHtcclxuICAgICAgICAgICAgc2hhcGU6IHtcclxuICAgICAgICAgICAgICAgIHgxIDogNTAsXHJcbiAgICAgICAgICAgICAgICB5MSA6IDcwLFxyXG4gICAgICAgICAgICAgICAgeDIgOiA1MCxcclxuICAgICAgICAgICAgICAgIHkyIDogNzAwLFxyXG4gICAgICAgICAgICAgICAgdGV4dCA6ICdsaW5lJ1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBzdHlsZToge1xyXG4gICAgICAgICAgICAgICAgc3Ryb2tlOiAnIzAwMCcsXHJcbiAgICAgICAgICAgICAgICBsaW5lVHlwZSA6ICdzb2xpZCcsLy8gZGVmYXVsdCBzb2xpZFxyXG4gICAgICAgICAgICAgICAgbGluZVdpZHRoIDogMywgIFxyXG4gICAgICAgICAgICAgICAgZmlsbDogbnVsbFxyXG4gICAgICAgICAgICB9ICAgICAgICBcclxuICAgICAgICB9KTsgICAgICAgIFxyXG4gICAgICAgIHRoaXMuYWRkKGxpbmVPdXQpO1xyXG5cclxuICAgICAgICB2YXIgbGluZVVwID0gbmV3IGdyYXBoaWMuTGluZSh7XHJcbiAgICAgICAgICAgIHNoYXBlOiB7XHJcbiAgICAgICAgICAgICAgICB4MSA6IDUwLFxyXG4gICAgICAgICAgICAgICAgeTEgOiAyNTAsXHJcbiAgICAgICAgICAgICAgICB4MiA6IGNsZW50V2lkdGggLSA1MCxcclxuICAgICAgICAgICAgICAgIHkyIDogMjUwLFxyXG4gICAgICAgICAgICAgICAgdGV4dCA6ICdsaW5lJ1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBzdHlsZToge1xyXG4gICAgICAgICAgICAgICAgc3Ryb2tlOiAnIzAwMCcsXHJcbiAgICAgICAgICAgICAgICBsaW5lVHlwZSA6ICdzb2xpZCcsLy8gZGVmYXVsdCBzb2xpZFxyXG4gICAgICAgICAgICAgICAgbGluZVdpZHRoIDogMywgIFxyXG4gICAgICAgICAgICAgICAgZmlsbDogbnVsbFxyXG4gICAgICAgICAgICB9ICAgICAgICBcclxuICAgICAgICB9KTsgICAgICAgIFxyXG4gICAgICAgIHRoaXMuYWRkKGxpbmVVcCk7XHJcblxyXG4gICAgICAgIHZhciBsaW5lRG93biA9IG5ldyBncmFwaGljLkxpbmUoe1xyXG4gICAgICAgICAgICBzaGFwZToge1xyXG4gICAgICAgICAgICAgICAgeDEgOiA1MCxcclxuICAgICAgICAgICAgICAgIHkxIDogNDUwLFxyXG4gICAgICAgICAgICAgICAgeDIgOiBjbGVudFdpZHRoIC0gNTAsXHJcbiAgICAgICAgICAgICAgICB5MiA6IDQ1MCwgXHJcbiAgICAgICAgICAgICAgICB0ZXh0IDogJ2xpbmUnXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgICBzdHJva2U6ICcjMDAwJyxcclxuICAgICAgICAgICAgICAgIGxpbmVUeXBlIDogJ3NvbGlkJywvLyBkZWZhdWx0IHNvbGlkXHJcbiAgICAgICAgICAgICAgICBsaW5lV2lkdGggOiAzLCAgXHJcbiAgICAgICAgICAgICAgICBmaWxsOiBudWxsXHJcbiAgICAgICAgICAgIH0gICAgICAgIFxyXG4gICAgICAgIH0pOyAgICAgICAgXHJcbiAgICAgICAgdGhpcy5hZGQobGluZURvd24pO1xyXG5cclxuICAgICAgICAgLy/lvqrnjq/mt7vliqB0b3Bv5Zu+5LiK55qE6IqC54K5XHJcbiAgICAgICAgdmFyIHN0YXJ0Q29tcHV0ZVggPSA3MDtcclxuICAgICAgICB2YXIgc3RhcnRTdG9yYWdlWCA9IDExMDsgXHJcbiAgICAgICAgdmFyIHN0YXJ0U3dpdGNoWCA9IDkwOyBcclxuICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBub2RlTGlzdC5sZW5ndGg7IGkrKyApIHtcclxuICAgICAgICAgICAgdmFyIG5vZGVZID0gMTQ1O1xyXG4gICAgICAgICAgICB2YXIgbW9kZWxPYmogPSB7fTtcclxuICAgICAgICAgICAgdmFyIF90eXBlTm9kZSA9IFwiVG9wb0RyYXdOb2RlXCI7XHJcbiAgICAgICAgICAgIGlmICggbm9kZUxpc3RbaV0ubm9kZXR5cGUgPT09IFwiY29tcHV0ZVwiICkge1xyXG4gICAgICAgICAgICAgICAgaWYgKG5vZGVMaXN0W2ldLnR5cGUgID09PSBcIlNlcnZlclI3MzBcIiB8fCBub2RlTGlzdFtpXS50eXBlICA9PT0gXCJTZXJ2ZXJYMzY1MFwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZVkgPSAxMjU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBfdHlwZU5vZGUgPSBub2RlTGlzdFtpXS50eXBlICsgXCJOb2RlXCI7XHJcbiAgICAgICAgICAgICAgICBtb2RlbE9iaiA9IHtcclxuICAgICAgICAgICAgICAgICAgICByZXNvdXJjZUlkOiB1dGlsLmdldFVVSUQoKSwgIFxyXG4gICAgICAgICAgICAgICAgICAgIGJvdW5kczoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB1cHBlckxlZnQ6IHt4OiBzdGFydENvbXB1dGVYLCB5OiBub2RlWX0gIFxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgc3RlbmNpbDoge3R5cGU6IF90eXBlTm9kZX1cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBtb2RlbE9iai5uYW1lID0gbm9kZUxpc3RbaV0ucmVzb3VyY2VOYW1lO1xyXG4gICAgICAgICAgICAgICAgbW9kZWxPYmoud2lkdGggPSBzZXJ2ZXJXaWR0aDtcclxuICAgICAgICAgICAgICAgIHN0YXJ0Q29tcHV0ZVggKz0gc2VydmVyV2lkdGggKyAyMDtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChub2RlTGlzdFtpXS5ub2RldHlwZSA9PT0gXCJzdG9yYWdlXCIgKSB7ICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIG5vZGVZID0gNTUwO1xyXG4gICAgICAgICAgICAgICAgX3R5cGVOb2RlID0gbm9kZUxpc3RbaV0udHlwZSArIFwiTm9kZVwiO1xyXG4gICAgICAgICAgICAgICAgbW9kZWxPYmogPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzb3VyY2VJZDogdXRpbC5nZXRVVUlEKCksICBcclxuICAgICAgICAgICAgICAgICAgICBib3VuZHM6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdXBwZXJMZWZ0OiB7eDogc3RhcnRTdG9yYWdlWCwgeTogbm9kZVl9ICBcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIHN0ZW5jaWw6IHt0eXBlOiBfdHlwZU5vZGV9XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgbW9kZWxPYmoubmFtZSA9IG5vZGVMaXN0W2ldLnJlc291cmNlTmFtZTtcclxuICAgICAgICAgICAgICAgIG1vZGVsT2JqLndpZHRoID0gc2VydmVyV2lkdGg7XHJcbiAgICAgICAgICAgICAgICBzdGFydFN0b3JhZ2VYICs9IHNlcnZlcldpZHRoICsgMjA7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobm9kZUxpc3RbaV0ubm9kZXR5cGUgPT09IFwic3dpdGNoXCIgKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdHlwZSA9IG5vZGVMaXN0W2ldLnR5cGUgIT09IHVuZGVmaW5lZCAmJiBub2RlTGlzdFtpXS50eXBlICE9PSBudWxsID8gbm9kZUxpc3RbaV0udHlwZSA6IFwiXCI7XHJcbiAgICAgICAgICAgICAgICB2YXIgc3dpdGNoVHlwZSA9IFwiU3dpdGNoSGFsZklCXCI7XHJcbiAgICAgICAgICAgICAgICBpZiAoIHR5cGUudG9VcHBlckNhc2UoKSA9PT0gXCJGVUxMXCIgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoVHlwZSA9IFwiU3dpdGNoRnVsbElCXCI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBfdHlwZU5vZGUgPSBzd2l0Y2hUeXBlICsgXCJOb2RlXCI7XHJcbiAgICAgICAgICAgICAgICBub2RlWSA9IDMzNTtcclxuICAgICAgICAgICAgICAgIG1vZGVsT2JqID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc291cmNlSWQ6IHV0aWwuZ2V0VVVJRCgpLCAgXHJcbiAgICAgICAgICAgICAgICAgICAgYm91bmRzOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwcGVyTGVmdDoge3g6IHN0YXJ0U3dpdGNoWCwgeTogbm9kZVl9ICBcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIHN0ZW5jaWw6IHt0eXBlOiBfdHlwZU5vZGV9XHJcbiAgICAgICAgICAgICAgICB9OyBcclxuICAgICAgICAgICAgICAgIGlmICggbm9kZUxpc3RbaV0udHlwZSAgPT09IFwiSGFsZlwiICkge1xyXG4gICAgICAgICAgICAgICAgICAgIG1vZGVsT2JqLndpZHRoID0gc3dpdGNoV2lkdGggLyAyO1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0U3dpdGNoWCArPSBzd2l0Y2hXaWR0aCAvIDIgKyA1MDtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbW9kZWxPYmoud2lkdGggPSBzd2l0Y2hXaWR0aDtcclxuICAgICAgICAgICAgICAgICAgICBzdGFydFN3aXRjaFggKz0gc3dpdGNoV2lkdGggKyA1MDtcclxuICAgICAgICAgICAgICAgIH0gXHJcbiAgICAgICAgICAgICAgICBtb2RlbE9iai5uYW1lID0gXCJOYW1lOiBcIiAgKyBub2RlTGlzdFtpXS5yZXNvdXJjZU5hbWUgKyBcIiwgTm/vvJpcIiArIG5vZGVMaXN0W2ldLm1hbmFnZXJfaXBhZGRyO1xyXG4gICAgICAgICAgICAgICAgbW9kZWxPYmoucG9ydE51bSA9IG5vZGVMaXN0W2ldLnBvcnRUb3RhbDtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChub2RlTGlzdFtpXS5ub2RldHlwZSA9PT0gXCJFU3dpdGNoXCIgKSB7XHJcbiAgICAgICAgICAgICAgICBub2RlWSA9IDMzNTtcclxuICAgICAgICAgICAgICAgIG1vZGVsT2JqID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc291cmNlSWQ6IHV0aWwuZ2V0VVVJRCgpLCAgXHJcbiAgICAgICAgICAgICAgICAgICAgYm91bmRzOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwcGVyTGVmdDoge3g6IHN0YXJ0U3dpdGNoWCwgeTogbm9kZVl9ICBcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIHN0ZW5jaWw6IHt0eXBlOiBcIlN3aXRjaEtNTm9kZVwifVxyXG4gICAgICAgICAgICAgICAgfTsgXHJcbiAgICAgICAgICAgICAgICBtb2RlbE9iai5uYW1lID0gbm9kZUxpc3RbaV0ucmVzb3VyY2VOYW1lO1xyXG4gICAgICAgICAgICAgICAgbW9kZWxPYmoud2lkdGggPSBzd2l0Y2hXaWR0aDtcclxuICAgICAgICAgICAgICAgIHN0YXJ0U3dpdGNoWCArPSBzd2l0Y2hXaWR0aCArIDUwOyAgICAgICBcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIG1vZGVsT2JqLnN0ZW5jaWwgIT09IHVuZGVmaW5lZCAmJiBtb2RlbE9iai5zdGVuY2lsLnR5cGUgIT09IHVuZGVmaW5lZCApIHtcclxuICAgICAgICAgICAgICAgIGlmICggbW9kZWxPYmouc3RlbmNpbC50eXBlICE9PSB1bmRlZmluZWQgJiYgIG1vZGVsT2JqLnN0ZW5jaWwudHlwZSAhPT0gXCJTZXJ2ZXJSNzMwTm9kZVwiICYmXHJcbiAgICAgICAgICAgICAgICAgICAgIG1vZGVsT2JqLnN0ZW5jaWwudHlwZSAhPT0gXCJTZXJ2ZXJSNjMwTm9kZVwiICYmXHJcbiAgICAgICAgICAgICAgICAgICAgIG1vZGVsT2JqLnN0ZW5jaWwudHlwZSAhPT0gXCJTd2l0Y2hGdWxsSUJOb2RlXCIgJiZcclxuICAgICAgICAgICAgICAgICAgICAgbW9kZWxPYmouc3RlbmNpbC50eXBlICE9PSBcIlN3aXRjaEhhbGZJQk5vZGVcIiAmJlxyXG4gICAgICAgICAgICAgICAgICAgICBtb2RlbE9iai5zdGVuY2lsLnR5cGUgIT09IFwiU3dpdGNoS01Ob2RlXCJcclxuICAgICAgICAgICAgICAgICApIHtcclxuICAgICAgICAgICAgICAgICAgICBtb2RlbE9iai5zdGVuY2lsLnR5cGUgPSBcIlNlcnZlclRvcG9Ob2RlXCI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIG1vZGVsT2JqLnN0YXR1cyA9ICBub2RlTGlzdFtpXS5zdGF0dXM7XHJcbiAgICAgICAgICAgIG1vZGVsT2JqLm5vZGV0eXBlID0gbm9kZUxpc3RbaV0ubm9kZXR5cGU7XHJcbiAgICAgICAgICAgIG1vZGVsT2JqLnR5cGUgPSBub2RlTGlzdFtpXS50eXBlO1xyXG4gICAgICAgICAgICB2YXIgX3Bhcm1EYXRlID0ge307XHJcbiAgICAgICAgICAgIF9wYXJtRGF0ZS5ob3N0SWQgPSBub2RlTGlzdFtpXS5ob3N0X2lkO1xyXG4gICAgICAgICAgICBfcGFybURhdGUubmFtZSA9IG5vZGVMaXN0W2ldLnJlc291cmNlTmFtZTtcclxuICAgICAgICAgICAgX3Bhcm1EYXRlLm5vdGVUeXBlID0gbm9kZUxpc3RbaV0ubm9kZXR5cGU7XHJcbiAgICAgICAgICAgIF9wYXJtRGF0ZS5zdGF0dXMgPSBub2RlTGlzdFtpXS5zdGF0dXM7XHJcbiAgICAgICAgICAgIF9wYXJtRGF0ZS50eXBlID0gbm9kZUxpc3RbaV0udHlwZTtcclxuICAgICAgICAgICAgX3Bhcm1EYXRlLmtleSA9IG5vZGVMaXN0W2ldLm1hbmFnZXJfaXBhZGRyID8gbm9kZUxpc3RbaV0ubWFuYWdlcl9pcGFkZHIgOiBcIlwiO1xyXG5cclxuXHJcbiAgICAgICAgICAgIG1vZGVsT2JqLnBhcm1EYXRlID0gX3Bhcm1EYXRlO1xyXG4gICAgICAgICAgICBtb2RlbE9iai5oZWlnaHQgPSAgMTU7XHJcbiAgICAgICAgICAgIGlmICggbm9kZUxpc3RbaV0ucG9ydHMgIT0gdW5kZWZpbmVkICkge1xyXG4gICAgICAgICAgICAgICAgbW9kZWxPYmoucG9ydHMgPSBub2RlTGlzdFtpXS5wb3J0cztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvL+WIpOaWreaYr+WQpmJhbmTmgqzmta7kuovku7ZcclxuICAgICAgICAgICAgbW9kZWxPYmouc2hvd1RpcCA9IF9zaG93VGlwO1xyXG4gICAgICAgICAgICB2YXIgc2VydmVyTW9kZWwgPSBuZXcgTmV0d29ya01vZGVsKG1vZGVsT2JqKTtcclxuICAgICAgICAgICAgdGhpcy5hZGROb2RlQnlNb2RlbChzZXJ2ZXJNb2RlbCwgYXBpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8v6L+e57q/XHJcbiAgICAgICAgZm9yICggdmFyIHBzID0gMDsgcHMgPCB0aGlzLnBvcnRMaXN0Lmxlbmd0aDsgcHMrKyApIHtcclxuICAgICAgICAgICAgdmFyIHN0YXJ0Tm9kZSA9IHRoaXMucG9ydExpc3RbcHNdO1xyXG4gICAgICAgICAgICB2YXIgZW5kTm9kZSA9IG51bGw7XHJcbiAgICAgICAgICAgIGZvciAoIHZhciBwZSA9IDA7IHBlIDwgdGhpcy5wb3J0TGlzdC5sZW5ndGg7IHBlKysgKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoc3RhcnROb2RlLmxpbmVJbmZvLnRhcmdldFJlb3VyY2UgPT09IHRoaXMucG9ydExpc3RbcGVdLmxpbmVJbmZvLnNvdXJjZVJlb3VyY2UgXHJcbiAgICAgICAgICAgICAgICAgICAgJiYgc3RhcnROb2RlLmxpbmVJbmZvLnRhcmdldFBvcnQgPT09IHRoaXMucG9ydExpc3RbcGVdLmxpbmVJbmZvLnNvdXJjZVBvcnQgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZW5kTm9kZSA9IHRoaXMucG9ydExpc3RbcGVdO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8v6L+e57q/XHJcbiAgICAgICAgICAgIGlmKCBlbmROb2RlICE9PSBudWxsICYmIHN0YXJ0Tm9kZSAhPSBudWxsICkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kcmF3TGluZShzdGFydE5vZGUsIGVuZE5vZGUsIGFwaSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnBvc2l0aW9uID0gW21vZGVsLmdldChcImJvdW5kcy51cHBlckxlZnQueFwiKSAsIG1vZGVsLmdldChcImJvdW5kcy51cHBlckxlZnQueVwiKV07XHJcbiAgICB9O1xyXG5cclxuICAgIFRvcG9EcmF3Tm9kZS5wcm90b3R5cGUuZ2V0V2lkdGggPSBmdW5jdGlvbiggcF9ub2RlTGlzdCwgcF9zZXJ2ZXJXLCBwX3N3aXRjaFcgKSB7XHJcbiAgICAgICAgLy8gdmFyIGNvbXB1dGVDb3VudCA9IDA7XHJcbiAgICAgICAgLy8gdmFyIHN0b3JhZ2VDb3VudCA9IDA7IFxyXG4gICAgICAgIC8vIHZhciBzd2l0Y2hDb3VudCA9IDA7IFxyXG4gICAgICAgIC8vIGZvciAoIHZhciBpID0gMDsgaSA8IHBfbm9kZUxpc3QubGVuZ3RoOyBpKysgKSB7XHJcbiAgICAgICAgLy8gICAgIGlmICggcF9ub2RlTGlzdFtpXS5ub2RldHlwZSA9PT0gXCIxXCIgKSB7XHJcbiAgICAgICAgLy8gICAgICAgIGNvbXB1dGVDb3VudCsrO1xyXG4gICAgICAgIC8vICAgICB9IGVsc2UgaWYgKHBfbm9kZUxpc3RbaV0ubm9kZXR5cGUgPT09IFwiMlwiICkgeyAgICAgICAgICAgXHJcbiAgICAgICAgLy8gICAgICAgICBzdG9yYWdlQ291bnQrKztcclxuICAgICAgICAvLyAgICAgfSBlbHNlIGlmIChwX25vZGVMaXN0W2ldLm5vZGV0eXBlID09PSBcIjNcIiApIHtcclxuICAgICAgICAvLyAgICAgICAgIHN3aXRjaENvdW50Kys7XHJcbiAgICAgICAgLy8gICAgIH1cclxuICAgICAgICAvLyB9XHJcbiAgICAgICAgLy8gdmFyIHNlcnZlckNvdW50ID0gY29tcHV0ZUNvdW50ID4gc3RvcmFnZUNvdW50ID8gY29tcHV0ZUNvdW50IDogc3RvcmFnZUNvdW50OyBcclxuICAgICAgICAvLyB2YXIgdzEgPSA2MCArIHNlcnZlckNvdW50ICogKHBfc2VydmVyVyArIDUwKSArIDE1MDtcclxuICAgICAgICAvLyB2YXIgczEgPSA0MCArIHN3aXRjaENvdW50ICogKHBfc3dpdGNoVyArIDUwKSArIDE1MDtcclxuICAgICAgICB2YXIgY29tcHV0ZVdpZHRoID0gMjEwO1xyXG4gICAgICAgIHZhciBzdG9yYWdlV2lkdGggPSAyMTA7IFxyXG4gICAgICAgIHZhciBzd2l0Y2hXaWR0aCA9IDE5MDsgXHJcbiAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgcF9ub2RlTGlzdC5sZW5ndGg7IGkrKyApIHtcclxuICAgICAgICAgICAgaWYgKCBwX25vZGVMaXN0W2ldLm5vZGV0eXBlID09PSBcImNvbXB1dGVcIiApIHtcclxuICAgICAgICAgICAgICAgY29tcHV0ZVdpZHRoICs9IHBfc2VydmVyVyArIDUwO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHBfbm9kZUxpc3RbaV0ubm9kZXR5cGUgPT09IFwic3RvcmFnZVwiICkgeyAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICBzdG9yYWdlV2lkdGggKz0gcF9zZXJ2ZXJXICsgNTA7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocF9ub2RlTGlzdFtpXS5ub2RldHlwZSA9PT0gXCJzd2l0Y2hcIiApIHtcclxuICAgICAgICAgICAgICAgIGlmKCBwX25vZGVMaXN0W2ldLnBvcnRUb3RhbCA+IDEyICkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaFdpZHRoICs9IHBfc3dpdGNoVyArIDUwOyBcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoV2lkdGggKz0gKHBfc3dpdGNoVyAvIDIpICsgNTA7IFxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHBfbm9kZUxpc3RbaV0ubm9kZXR5cGUgPT09IFwiRVN3aXRjaFwiICkge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoV2lkdGggKz0gcF9zd2l0Y2hXICsgNTA7IFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBzZXJ2ZXJXaWR0aCA9IGNvbXB1dGVXaWR0aCA+IHN0b3JhZ2VXaWR0aCA/IGNvbXB1dGVXaWR0aCA6IHN0b3JhZ2VXaWR0aDtcclxuICAgICAgICByZXR1cm4gc2VydmVyV2lkdGggPiBzd2l0Y2hXaWR0aCA/IHNlcnZlcldpZHRoIDogc3dpdGNoV2lkdGg7XHJcbiAgICB9O1xyXG5cclxuICAgIFRvcG9EcmF3Tm9kZS5wcm90b3R5cGUuYWRkTm9kZUJ5TW9kZWwgPSBmdW5jdGlvbiggcF9tb2RlbCwgYXBpKSB7XHJcbiAgICAgICAgdmFyIFNoYXBlID0gYXBpLmdldE5vZGVDbGFzcyhwX21vZGVsLmdldChcInN0ZW5jaWwudHlwZVwiKSk7XHJcbiAgICAgICAgdmFyIG5vZGUgPSBudWxsO1xyXG4gICAgICAgIGlmICggU2hhcGUgKSB7XHJcbiAgICAgICAgICAgIG5vZGUgPSBuZXcgU2hhcGUocF9tb2RlbCwgYXBpKTtcclxuICAgICAgICAgICAgdGhpcy5hZGQobm9kZSk7XHJcbiAgICAgICAgICAgIGlmKCBub2RlLnBvcnROb2RlTGlzdCAhPT0gdW5kZWZpbmVkICYmIG5vZGUucG9ydE5vZGVMaXN0Lmxlbmd0aCA+IDAgKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUucG9ydE5vZGVMaXN0Lmxlbmd0aDsgaSsrICkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucG9ydExpc3QucHVzaChub2RlLnBvcnROb2RlTGlzdFtpXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvL3RoaXMucG9ydExpc3QuY29uY2F0KG5vZGUucG9ydE5vZGVMaXN0KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgIC8v57uR5a6a5LqL5Lu2XHJcbiAgICAgICAgICAgIHZhciBNT1VTRV9FVkVOVF9OQU1FUyA9IFsnY2xpY2snXTtcclxuICAgICAgICAgICAgaWYgKCBwX21vZGVsLmdldChcInNob3dUaXBcIikgKSB7XHJcbiAgICAgICAgICAgICAgICBNT1VTRV9FVkVOVF9OQU1FUyA9IFsnY2xpY2snLCAnbW91c2VvdmVyJywgJ21vdXNlb3V0J107XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgenJVdGlsLmVhY2goTU9VU0VfRVZFTlRfTkFNRVMsIGZ1bmN0aW9uIChldmVOYW1lKSB7XHJcbiAgICAgICAgICAgICAgICBub2RlLm9uKGV2ZU5hbWUsIGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhcmFtcyA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICggZXZlTmFtZSA9PT0gXCJtb3VzZW92ZXJcIikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMuZXZlbnQgPSBlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMueCA9IGUub2Zmc2V0WDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zLnkgPSBlLm9mZnNldFk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtcy53aWR0aCA9IDE1MDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zLmhlaWdodCA9IDE3MDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zLmVXaWR0aCA9ICA1IDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zLnBhcm1EYXRlID0gZS50YXJnZXQucGFyZW50LnBhcm1EYXRlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMudHlwZSA9IFwibGluZVRpcFwiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyYW1zLnBhcm1EYXRlICE9PSB1bmRlZmluZWQgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX25hbWUgPSBwYXJhbXMucGFybURhdGUubmFtZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ZXh0ID0gXCJuYW1lOiBcIiArIF9uYW1lICsgXCJcXG5cIiArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwibm90ZVR5cGU6IFwiKyBwYXJhbXMucGFybURhdGUubm90ZVR5cGUgKyBcIlxcblwiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBwYXJhbXMucGFybURhdGUuc3RhdHVzICE9PSBudWxsICYmIHBhcmFtcy5wYXJtRGF0ZS5zdGF0dXMgIT09IHVuZGVmaW5lZCApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0ICs9IFwic3RhdHVzOiBcIisgcGFyYW1zLnBhcm1EYXRlLnN0YXR1cyArIFwiXFxuXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBwYXJhbXMucGFybURhdGUudHlwZSAhPT0gbnVsbCAmJiBwYXJhbXMucGFybURhdGUudHlwZSAhPT0gdW5kZWZpbmVkICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQgKz0gXCJ0eXBlOiBcIisgcGFyYW1zLnBhcm1EYXRlLnR5cGUgKyBcIlxcblwiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zLnBhcm1EYXRlLnRpcENvbnRleHQgPSB0ZXh0OyBcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBcclxuICAgICAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggYXBpLmdldEhlaWdodCgpIC0gcGFyYW1zLnkgPiBwYXJhbXMuaGVpZ2h0ICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zLmxheW91dCA9IFwiZG93blwiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zLmxheW91dCA9IFwidXBcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9hcGkuc2hvd1RpcFdpbmRvdyhwYXJhbXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZXZlTmFtZSA9PT0gXCJtb3VzZW91dFwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFwaS5oaWRlVGlwV2luZG93KGUuZXZlbnQudGFyZ2V0KTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGV2ZU5hbWUgPT09IFwiY2xpY2tcIikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX3Bhcm1EYXRlID0gZS50YXJnZXQucGFybURhdGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtcy5ldmVudCA9X3Bhcm1EYXRlO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gXHJcbiAgICAgICAgICAgICAgICAgICAgYXBpLnRyaWdnZXIoZXZlTmFtZSwgcGFyYW1zKTsgXHJcbiAgICAgICAgICAgICAgICB9LCB0aGlzKTtcclxuICAgICAgICAgICAgIH0sIHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgVG9wb0RyYXdOb2RlLnByb3RvdHlwZS5kcmF3TGluZSA9IGZ1bmN0aW9uKCBwX3N0YXJ0Tm9kZSwgcF9lbmROb2RlLCBhcGkgKSB7XHJcbiAgICAgICAgdmFyIGZsZWZ0eCA9IHBfc3RhcnROb2RlLnBvc2l0aW9uWzBdICsgcF9zdGFydE5vZGUucGFyZW50LnBvc2l0aW9uWzBdICsgcF9zdGFydE5vZGUucGFyZW50LnBhcmVudC5wb3NpdGlvblswXTtcclxuICAgICAgICB2YXIgZmxlZnR5ID0gcF9zdGFydE5vZGUucG9zaXRpb25bMV0gKyBwX3N0YXJ0Tm9kZS5wYXJlbnQucG9zaXRpb25bMV0gKyBwX3N0YXJ0Tm9kZS5wYXJlbnQucGFyZW50LnBvc2l0aW9uWzFdO1xyXG4gICAgICAgIHZhciBmd2lkdGggPSBwX3N0YXJ0Tm9kZS5tb2RlbC5nZXQoXCJ3aWR0aFwiKTtcclxuICAgICAgICB2YXIgZmhlaWdodCA9IHBfc3RhcnROb2RlLm1vZGVsLmdldChcImhlaWdodFwiKTtcclxuXHJcbiAgICAgICAgdmFyIHRvcmlnaHR4ID0gcF9lbmROb2RlLnBvc2l0aW9uWzBdICsgcF9lbmROb2RlLnBhcmVudC5wb3NpdGlvblswXTtcclxuICAgICAgICB2YXIgdG9yaWdodHkgPSBwX2VuZE5vZGUucG9zaXRpb25bMV0gKyBwX2VuZE5vZGUucGFyZW50LnBvc2l0aW9uWzFdO1xyXG4gICAgICAgIHZhciB0b3dpZHRoID0gcF9lbmROb2RlLm1vZGVsLmdldChcIndpZHRoXCIpO1xyXG4gICAgICAgIHZhciB0b2hlaWdodCA9IHBfZW5kTm9kZS5tb2RlbC5nZXQoXCJoZWlnaHRcIik7XHJcbiAgICAgICAgdmFyIG1vZGRsZVkgPSAyNTA7XHJcbiAgICAgICAgdmFyIG5vZGV0eXBlID0gcF9zdGFydE5vZGUubW9kZWwuZ2V0KFwibGluZUluZm9cIikubm9kZXR5cGU7XHJcbiAgICAgICAgaWYoIG5vZGV0eXBlID09PSBcInN0b3JhZ2VcIiApIHtcclxuICAgICAgICAgICAgbW9kZGxlWSA9IDQ1MDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIF9saW5kQ29sb3IgPSBcIiM2MkE0RERcIjtcclxuICAgICAgICB2YXIgX2xpbmVJbmZvID0gcF9zdGFydE5vZGUubW9kZWwuZ2V0KFwibGluZUluZm9cIik7XHJcbiAgICAgICAgaWYgKCBfbGluZUluZm8ucG9ydFR5cGUgPT09IFwiMVwiKSB7XHJcbiAgICAgICAgICAgIF9saW5kQ29sb3IgPSBcIiM2MkE0RERcIjtcclxuICAgICAgICB9IGVsc2UgaWYgKCBfbGluZUluZm8ucG9ydFR5cGUgPT09IFwiMlwiKSAge1xyXG4gICAgICAgICAgICAgX2xpbmRDb2xvciA9IFwiIzA3MDQxM1wiO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoIF9saW5lSW5mby5wb3J0VHlwZSA9PT0gXCIzXCIpICB7XHJcbiAgICAgICAgICAgIF9saW5kQ29sb3IgPSBcIiMwNzA0RUNcIjtcclxuICAgICAgICB9IFxyXG4gICAgICAgIGlmICggX2xpbmVJbmZvLnBvcnRTdGF0ZS50b1VwcGVyQ2FzZSgpICE9PSBcIlVQXCIgKSB7XHJcbiAgICAgICAgICAgIF9saW5kQ29sb3IgPSBcIiNGRkNDMDBcIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCBwX2VuZE5vZGUubW9kZWwuZ2V0KFwibGluZUluZm9cIikuc291cmNlUmVvdXJjZU5hbWUgIT09IHVuZGVmaW5lZCAmJiBwX2VuZE5vZGUubW9kZWwuZ2V0KFwibGluZUluZm9cIikuc291cmNlUmVvdXJjZU5hbWUgIT09IG51bGwgKSB7XHJcbiAgICAgICAgICAgIF9saW5lSW5mby5zb3VyY2VSZW91cmNlTmFtZSA9IHBfZW5kTm9kZS5tb2RlbC5nZXQoXCJsaW5lSW5mb1wiKS5zb3VyY2VSZW91cmNlTmFtZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIF9tb2RkbGVYID0gcF9zdGFydE5vZGUubGluZUluZm8ubW9kZGxlWDtcclxuICAgICAgICB2YXIgZGVmYXVsdE9wdGlvbiA9IHtcclxuICAgICAgICAgICAgZnJvbUJvdW5kcyA6IHt4OiBmbGVmdHgsIHk6IGZsZWZ0eSwgd2lkdGg6IGZ3aWR0aCwgaGVpZ2h0OiBmaGVpZ2h0fSxcclxuICAgICAgICAgICAgdG9Cb3VuZHM6IHt4OiB0b3JpZ2h0eCwgeTogdG9yaWdodHksIHdpZHRoOiB0b3dpZHRoLCBoZWlnaHQ6IHRvaGVpZ2h0fSxcclxuICAgICAgICAgICAgbW9kZGxlWTogbW9kZGxlWSxcclxuICAgICAgICAgICAgc3R5bGUgOiB7XHJcbiAgICAgICAgICAgICAgICBsaW5lV2lkdGggOiAxLFxyXG4gICAgICAgICAgICAgICAgc3Ryb2tlOiBfbGluZENvbG9yLy8sXHJcbiAgICAgICAgICAgICAgICAvL2ZpbGw6ICcjOTY5OUREJ1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBob3ZlclN0eWxlIDoge1xyXG4gICAgICAgICAgICAgICAgbGluZVdpZHRoIDogMSxcclxuICAgICAgICAgICAgICAgIHN0cm9rZTogJyM0N0Q5MzAnLy8sXHJcbiAgICAgICAgICAgICAgICAvL2ZpbGw6JyMyRkRFOTInXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIGlmICggX21vZGRsZVggIT09IHVuZGVmaW5lZCApIHtcclxuICAgICAgICAgICAgZGVmYXVsdE9wdGlvbi5tb2RkbGVYID0gIF9tb2RkbGVYO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZGVmYXVsdE9wdGlvbi5wYXJtRGF0YSA9IF9saW5lSW5mbztcclxuICAgICAgICB2YXIgbmV0V29ya0xpbmVNb2RlbCA9IG5ldyBOZXRXb3JrTGluZU1vZGVsKGRlZmF1bHRPcHRpb24pO1xyXG4gICAgICAgIHZhciBuZXRXb3JrTGluZU5vZGUgPSBuZXcgTmV0V29ya0xpbmVOb2RlKG5ldFdvcmtMaW5lTW9kZWwpO1xyXG4gICAgICAgIHRoaXMuYWRkKG5ldFdvcmtMaW5lTm9kZSk7XHJcblxyXG5cclxuICAgICAgICAvL+e7keWumuS6i+S7tlxyXG4gICAgICAgIHZhciBNT1VTRV9FVkVOVF9OQU1FUyA9IFsnbW91c2VvdmVyJywgJ21vdXNlb3V0J107XHJcbiAgICAgICAgenJVdGlsLmVhY2goTU9VU0VfRVZFTlRfTkFNRVMsIGZ1bmN0aW9uIChldmVOYW1lKSB7XHJcbiAgICAgICAgICAgIG5ldFdvcmtMaW5lTm9kZS5vbihldmVOYW1lLCBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHBhcmFtcyA9IHt9O1xyXG4gICAgICAgICAgICAgICAgaWYgKCBldmVOYW1lID09PSBcIm1vdXNlb3ZlclwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zLmV2ZW50ID0gZTtcclxuICAgICAgICAgICAgICAgICAgICBwYXJhbXMueCA9IGUub2Zmc2V0WDtcclxuICAgICAgICAgICAgICAgICAgICBwYXJhbXMueSA9IGUub2Zmc2V0WTtcclxuICAgICAgICAgICAgICAgICAgICBwYXJhbXMud2lkdGggPSAyMDA7XHJcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zLmhlaWdodCA9IDE3MDtcclxuICAgICAgICAgICAgICAgICAgICBwYXJhbXMuZVdpZHRoID0gIDUgO1xyXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtcy5wYXJtRGF0ZSA9IGUudGFyZ2V0LnBhcmVudC5wYXJlbnQucGFybURhdGE7XHJcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zLnR5cGUgPSBcImxpbmVUaXBcIjtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdGV4dCA9IFwiU3RhdHVzOiBcIisgIHBhcmFtcy5wYXJtRGF0ZS5wb3J0U3RhdGUgKyBcIlxcblwiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0ICs9IFwiU291cmNlIFJlb3VyY2U6IFwiKyAgcGFyYW1zLnBhcm1EYXRlLnNvdXJjZVJlb3VyY2UgKyBcIlxcblwiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0ICs9IFwiU291cmNlIFBvcnQ6IFwiKyAgcGFyYW1zLnBhcm1EYXRlLnNvdXJjZVBvcnQgKyBcIlxcblwiO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICggcGFyYW1zLnBhcm1EYXRlLmlwICE9PSB1bmRlZmluZWQgJiYgcGFyYW1zLnBhcm1EYXRlLmlwICE9PSBudWxsICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0ICs9IFwiSVA6IFwiKyAgcGFyYW1zLnBhcm1EYXRlLmlwKyBcIlxcblwiO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gIFxyXG4gICAgICAgICAgICAgICAgICAgIGlmICggcGFyYW1zLnBhcm1EYXRlLnBvcnRUeXBlICE9PSB1bmRlZmluZWQgJiYgcGFyYW1zLnBhcm1EYXRlLnBvcnRUeXBlICE9PSBudWxsICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHBhcmFtcy5wYXJtRGF0ZS5wb3J0VHlwZSA9PT0gXCIxXCIgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0ICs9IFwiUG9ydCBUeXBlOiBJQuWPo1xcblwiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCBwYXJhbXMucGFybURhdGUucG9ydFR5cGUgPT09IFwiMlwiICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dCArPSBcIlBvcnQgVHlwZTog5LiH5YWG5Y+jXFxuXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIHBhcmFtcy5wYXJtRGF0ZS5wb3J0VHlwZSA9PT0gXCIzXCIgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0ICs9IFwiUG9ydCBUeXBlOiDljYPlhYblj6NcXG5cIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0gIFxyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBwYXJhbXMucGFybURhdGUudGFyZ2V0UmVvdXJjZSAhPT0gdW5kZWZpbmVkICYmIHBhcmFtcy5wYXJtRGF0ZS50YXJnZXRSZW91cmNlICE9PSBudWxsICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHBhcmFtcy5wYXJtRGF0ZS5zb3VyY2VSZW91cmNlTmFtZSAhPT0gdW5kZWZpbmVkICYmIHBhcmFtcy5wYXJtRGF0ZS5zb3VyY2VSZW91cmNlTmFtZSAhPT0gbnVsbCApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQgKz0gXCJUYXJnZXQgUmVvdXJjZTogXCIgKyAgcGFyYW1zLnBhcm1EYXRlLnNvdXJjZVJlb3VyY2VOYW1lICsgXCJcXG5cIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQgKz0gXCJUYXJnZXQgUmVvdXJjZTogXCIgKyAgcGFyYW1zLnBhcm1EYXRlLnRhcmdldFJlb3VyY2UgKyBcIlxcblwiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9ICAgXHJcbiAgICAgICAgICAgICAgICAgICAgfSAgXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICggcGFyYW1zLnBhcm1EYXRlLnRhcmdldFBvcnQgIT09IHVuZGVmaW5lZCAmJiBwYXJhbXMucGFybURhdGUudGFyZ2V0UG9ydCAhPT0gbnVsbCApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dCArPSBcIlRhcmdldCBQb3J0OiBcIiArICBwYXJhbXMucGFybURhdGUudGFyZ2V0UG9ydCArIFwiXFxuXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgfSAgXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIFxyXG5cclxuICAgICAgICAgICAgICAgICAgICBwYXJhbXMucGFybURhdGUudGlwQ29udGV4dCA9IHRleHQ7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICggYXBpLmdldEhlaWdodCgpIC0gcGFyYW1zLnkgPiBwYXJhbXMuaGVpZ2h0ICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMubGF5b3V0ID0gXCJkb3duXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zLmxheW91dCA9IFwidXBcIjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAgICAgICAgICAgICBhcGkuc2hvd1RpcFdpbmRvdyhwYXJhbXMpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChldmVOYW1lID09PSBcIm1vdXNlb3V0XCIpIHtcclxuICAgICAgICAgICAgICAgICAgICBhcGkuaGlkZVRpcFdpbmRvdyhlLmV2ZW50LnRhcmdldCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvL2FwaS50cmlnZ2VyKGV2ZU5hbWUsIHBhcmFtcyk7IFxyXG4gICAgICAgICAgICB9LCB0aGlzKTtcclxuICAgICAgICAgfSwgdGhpcyk7XHJcbiAgICB9XHJcbiAgICB6clV0aWwuaW5oZXJpdHMoVG9wb0RyYXdOb2RlLCBOZXR3b3JrTm9kZSk7XHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IFRvcG9EcmF3Tm9kZTtcclxuXHJcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9saWIvZmlzaC10b3BvLW5ldHdvcmsvbGliL25vZGUvdG9wby9Ub3BvRHJhd05vZGUuanNcbiAqKiBtb2R1bGUgaWQgPSA4N1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXHJcblx0dmFyIE5vZGUgPSByZXF1aXJlKFwiLi4vLi4vLi4vZmlzaC10b3BvLWNvcmUvbGliL05vZGVcIik7XHJcbiAgICB2YXIgTmV0d29ya05vZGUgPSByZXF1aXJlKFwiLi9OZXR3b3JrTm9kZVwiKTtcclxuXHR2YXIgVXRpbCA9IHJlcXVpcmUoJy4uLy4uLy4uL2Zpc2gtdG9wby1jb3JlL2xpYi91dGlsJyk7XHJcblx0dmFyIGdyYXBoaWMgPSByZXF1aXJlKFwiLi4vLi4vLi4vZmlzaC10b3BvLWNvcmUvbGliL2dyYXBoaWMuanNcIik7XHJcbiAgICB2YXIgUG9pbnQgPSByZXF1aXJlKFwiLi4vLi4vLi4vZmlzaC10b3BvLWNvcmUvbGliL1BvaW50LmpzXCIpO1xyXG4gICAgdmFyIENvbm5lY3RvciA9IHJlcXVpcmUoXCIuLi8uLi8uLi9maXNoLXRvcG8tY29yZS9saWIvc2hhcGVzL0Nvbm5lY3Rvci5qc1wiKTtcclxuXHJcblx0ZnVuY3Rpb24gTmV0V29ya0xpbmVOb2RlKG1vZGVsLGFwaSkge1xyXG5cdFx0Tm9kZS5jYWxsKHRoaXMpO1xyXG4gICAgICAgIHRoaXMubW9kZWwgPSBtb2RlbDsgIC8vIE5ldFdvcmtMaW5lTW9kYWxcclxuICAgICAgICB0aGlzLmNvbiA9IG51bGw7ICAgICAgICBcclxuXHRcdHRoaXMucmVuZGVyKCk7XHJcblx0XHR0aGlzLnJlZnJlc2hMaW5lKCk7XHJcbiAgICAgICAgdGhpcy5saW5lVHlwZSA9IHRoaXMubW9kZWwuZ2V0KFwibGluZVR5cGVcIik7XHJcbiAgICAgICAgdGhpcy5wYXJtRGF0YSA9IHRoaXMubW9kZWwuZ2V0KFwicGFybURhdGFcIik7XHJcbiAgICAgICAgXHJcblx0fTtcclxuXHJcblx0TmV0V29ya0xpbmVOb2RlLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdmFyIHBhcm1EYXRhID0ge307XHJcbiAgICAgICAgICAgIGlmICggdGhpcy5tb2RlbC5nZXQoXCJpc1ZlY3RvclwiKSApIHtcclxuICAgICAgICAgICAgICAgICBwYXJtRGF0YS5zeW1ib2wgPSB7dHlwZTpcImFycm93XCIsIHNpemU6IDEwLCBjb2xvcjpcIiMwMDAwMDBcIn07XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgcGFybURhdGEuc3ltYm9sID0ge3R5cGU6XCJcIn07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIF9zdHlsZSA9IHRoaXMubW9kZWwuZ2V0KFwic3R5bGVcIik7XHJcbiAgICAgICAgICAgIGlmICggdGhpcy5saW5lVHlwZSA/ICB0aGlzLmxpbmVUeXBlIDogdGhpcy5tb2RlbC5vcHRpb24ubGluZVR5cGUpIHtcclxuICAgICAgICAgICAgICAgIF9zdHlsZS5saW5lVHlwZSA9IHRoaXMubGluZVR5cGUgPyAgdGhpcy5saW5lVHlwZSA6IHRoaXMubW9kZWwub3B0aW9uLmxpbmVUeXBlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBfaG92ZXJTdHlsZSA9IHRoaXMubW9kZWwuZ2V0KFwiaG92ZXJTdHlsZVwiKTtcclxuICAgICAgICAgICAgcGFybURhdGEuc3R5bGUgPSBfc3R5bGU7XHJcbiAgICAgICAgICAgIHBhcm1EYXRhLmhvdmVyU3R5bGUgPSBfaG92ZXJTdHlsZTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHZhciBfaXNFZGl0ID0gdGhpcy5tb2RlbC5nZXQoXCJpc0VkaXRcIik7XHJcbiAgICAgICAgICAgIHBhcm1EYXRhLmlzRWRpdCA9IF9pc0VkaXQ7XHJcbiAgICAgICAgICAgIHRoaXMuY29uID0gIG5ldyBDb25uZWN0b3IocGFybURhdGEpOyAgLy9cImFycm93XCJcclxuICAgICAgICAgICAgdGhpcy5hZGQodGhpcy5jb24pO1xyXG5cdH07XHJcblxyXG4gICAgTmV0V29ya0xpbmVOb2RlLnByb3RvdHlwZS5yZWZyZXNoTGluZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgbW9kZGxlWSA9IHRoaXMubW9kZWwuZ2V0KFwibW9kZGxlWVwiKTtcclxuICAgICAgICB2YXIgbW9kZGxlWCA9IHRoaXMubW9kZWwuZ2V0KFwibW9kZGxlWFwiKTtcclxuXHJcbiAgICAgICAgdmFyIHNSZWN0ID0gdGhpcy5tb2RlbC5nZXQoXCJmcm9tQm91bmRzXCIpO1xyXG4gICAgICAgIHZhciBzQm91bmRzID0gW3NSZWN0LngsIHNSZWN0LnksIHNSZWN0LnggKyBzUmVjdC53aWR0aCwgc1JlY3QueSArIHNSZWN0LmhlaWdodF07XHJcblxyXG4gICAgICAgIHZhciBlUmVjdCA9IHRoaXMubW9kZWwuZ2V0KFwidG9Cb3VuZHNcIik7XHJcbiAgICAgICAgdmFyIGVCb3VuZHMgPSBbZVJlY3QueCwgZVJlY3QueSwgZVJlY3QueCArIGVSZWN0LndpZHRoLCBlUmVjdC55ICsgZVJlY3QuaGVpZ2h0XTtcclxuXHJcbiAgICAgICAgdmFyIHNDb25uZWN0b3JQb2ludCA9IFV0aWwuZ2V0Q29ubmVjdG9yUG9pbnRzKHNSZWN0KTtcclxuICAgICAgICB2YXIgZUNvbm5lY3RvclBvaW50ID0gVXRpbC5nZXRDb25uZWN0b3JQb2ludHMoZVJlY3QpO1xyXG5cclxuICAgICAgICB2YXIgc3RhcnRQb2ludCA9IG51bGw7XHJcbiAgICAgICAgdmFyIGVuZFBvaW50ID0gbnVsbDtcclxuICAgICAgICBpZiAoc1JlY3QueSA8IGVSZWN0LnkpIHtcclxuICAgICAgICAgICAgc3RhcnRQb2ludCA9IHNDb25uZWN0b3JQb2ludC5ib3R0b207XHJcbiAgICAgICAgICAgIGVuZFBvaW50ID0gZUNvbm5lY3RvclBvaW50LnRvcDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBzdGFydFBvaW50ID0gc0Nvbm5lY3RvclBvaW50LnRvcDtcclxuICAgICAgICAgICAgZW5kUG9pbnQgPSBlQ29ubmVjdG9yUG9pbnQuYm90dG9tO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHNvbHV0aW9ucyA9IHRoaXMuY29ubmVjdG9yMlBvaW50cyhzdGFydFBvaW50LCBlbmRQb2ludCwgbW9kZGxlWCwgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGRsZVksIHNCb3VuZHMsIGVCb3VuZHMpO1xyXG4gICAgICAgICAgICAvL2FkanVzdCBjb25uZWN0b3JcclxuICAgICAgICAvLyAgY29uc29sZS5pbmZvKFwiY29ubmVjdG9yMlBvaW50cygpIC0+IFNvbHV0aW9uOiBcIiArIHNvbHV0aW9uc1swXVsyXSk7XHJcbiAgICAgICAgLy8gdmFyIHBvaW50cyA9IFV0aWwudHJhc2xhdGVQb2ludHMoc29sdXRpb25zWzBdWzJdKTtcclxuXHJcbiAgICAgICAgLy90aGlzLmxpbmUuYXR0cignc2hhcGUnLCB7cG9pbnRzOiBwb2ludHN9KTtcclxuICAgICAgICB0aGlzLmNvbi5yZWZyZXNoKHNvbHV0aW9uc1swXVsyXSk7XHJcbiAgICB9O1xyXG5cclxuICAgIE5ldFdvcmtMaW5lTm9kZS5wcm90b3R5cGUuY29ubmVjdG9yMlBvaW50cyA9IGZ1bmN0aW9uKHN0YXJ0UG9pbnQsIGVuZFBvaW50LCBtb2RkbGVYLCBtaWRkbGVZLCBzQm91bmRzLCBlQm91bmRzICl7XHJcbiAgICAgICAgdmFyIHNvbHV0aW9ucyA9IFtdO1xyXG4gICAgICAgIC8vQmFzaWMgc29sdXRpb24g5pyA5Z+65pys55qE6Kej5Yaz5pa55qGIICAg5Li65YW25LuW6Kej5Yaz5pa55qGI5YGa5YeG5aSHXHJcbiAgICAgICAgdmFyIHMgPSBbc3RhcnRQb2ludF07XHJcbiAgICAgICAgaWYgKCBtb2RkbGVYICE9PSB1bmRlZmluZWQgJiYgbW9kZGxlWCAhPT0gbnVsbCApIHtcclxuICAgICAgICAgICAgIHMucHVzaChuZXcgUG9pbnQoc3RhcnRQb2ludC54IC0gbW9kZGxlWCwgc3RhcnRQb2ludC55KSk7XHJcbiAgICAgICAgICAgICBzLnB1c2gobmV3IFBvaW50KHN0YXJ0UG9pbnQueCAtIG1vZGRsZVgsIG1pZGRsZVkpKTtcclxuICAgICAgICAgICAgIHMucHVzaChuZXcgUG9pbnQoZW5kUG9pbnQueCwgbWlkZGxlWSkpOyBcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBzLnB1c2gobmV3IFBvaW50KHN0YXJ0UG9pbnQueCwgbWlkZGxlWSkpO1xyXG4gICAgICAgICAgICBzLnB1c2gobmV3IFBvaW50KGVuZFBvaW50LngsIG1pZGRsZVkpKTsgXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHMucHVzaChlbmRQb2ludCk7ICAgICAgICBcclxuXHJcbiAgICAgICAgLy9TTyAtIG5vIGFkZGl0aW9uYWwgcG9pbnRzICAgICBTMCDop6PlhrPmlrnmoYggXHJcbiAgICAgICAgdmFyIHMwID0gUG9pbnQuY2xvbmVBcnJheShzKTtcclxuICAgICAgICBzb2x1dGlvbnMucHVzaChbJ3MwJywgJ3MwJywgczBdKTtcclxuICAgICAgICByZXR1cm4gc29sdXRpb25zO1xyXG4gICAgICAgIFxyXG4gICAgfTtcclxuXHJcblx0VXRpbC5pbmhlcml0cyhOZXRXb3JrTGluZU5vZGUsIE5vZGUpO1xyXG5cclxuXHRtb2R1bGUuZXhwb3J0cyA9IE5ldFdvcmtMaW5lTm9kZTtcclxuXHJcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9saWIvZmlzaC10b3BvLW5ldHdvcmsvbGliL25vZGUvTmV0V29ya0xpbmVOb2RlLmpzXG4gKiogbW9kdWxlIGlkID0gODhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxyXG4gKiDov57mjqXnur9cclxuICogQGF1dGhvciB3YW5nLnhpYW9odVxyXG4gKi9cclxuXHJcbiAgICB2YXIgVXRpbCA9IHJlcXVpcmUoXCIuLi91dGlsLmpzXCIpO1xyXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xyXG4gICAgdmFyIGdyYXBoaWMgPSByZXF1aXJlKFwiLi4vZ3JhcGhpYy5qc1wiKTtcclxuICAgIHZhciBOb2RlID0gcmVxdWlyZShcIi4uL05vZGUuanNcIik7XHJcbiAgICB2YXIgc3ltYm9sVXRpbCA9IHJlcXVpcmUoXCIuL1N5bWJvbC5qc1wiKTtcclxuICAgIHZhciBIYW5kbGUgPSByZXF1aXJlKFwiLi9IYW5kbGUuanNcIik7XHJcbiAgICB2YXIgRWZmZWN0TGluZSA9IHJlcXVpcmUoXCIuL0VmZmVjdExpbmUuanNcIik7XHJcbiAgICB2YXIgQ29ubmVjdGlvblBvaW50ID0gcmVxdWlyZShcIi4vQ29ubmVjdGlvblBvaW50LmpzXCIpO1xyXG4gICAgdmFyIFBvaW50ID0gcmVxdWlyZShcIi4uL1BvaW50LmpzXCIpO1xyXG4gICAgLyoqXHJcbiAgICAgKiDmnoTpgKDlh73mlbBcclxuICAgICAqIEBwYXJhbSB7W3R5cGVdfSBvcHRpb25zIFtkZXNjcmlwdGlvbl1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gQ29ubmVjdG9yKG9wdGlvbnMpIHtcclxuICAgICAgICBOb2RlLmNhbGwodGhpcyk7XHJcbiAgICAgICAgdGhpcy5yZXNvdXJjZUlkID0gVXRpbC5nZXRVVUlEKCk7ICAvLyDnlJ/miJDoioLngrlJRFxyXG4gICAgICAgIHZhciBkZWZhdWx0T3B0aW9ucyA9IHtcclxuICAgICAgICAgICAgc3ltYm9sOiB7dHlwZTpcImFycm93XCIgLCBzaXplOiAxMCwgY29sb3I6XCIjMDAwMDAwXCJ9LCAgLy/nrq3lpLQgIOWPr+mAieWAvOS4uu+8miAnY2lyY2xlJywgJ3JlY3QnLCAncm91bmRSZWN0JywgJ3RyaWFuZ2xlJywgJ2RpYW1vbmQnLCAncGluJywgJ2Fycm93J1xyXG4gICAgICAgICAgICBzdHlsZToge2xpbmVXaWR0aDoxLCBzdHJva2U6XCIjMDAwMDAwXCIsIGxpbmVUeXBlOkNvbm5lY3Rvci5UWVBFX1NUUkFJR0hUfSwgICAgLy/moLflvI9cclxuICAgICAgICAgICAgaG92ZXJTdHlsZToge2xpbmVXaWR0aDoyLCBzdHJva2U6XCJsaW1lXCJ9LCAvL+enu+S4iuWOu+eahOagt+W8j1xyXG4gICAgICAgICAgICBhcnJvd0hvdmVyU3R5bGU6IHtmaWxsOlwibGltZVwifSxcclxuICAgICAgICAgICAgc2hhcGU6IHtwb2ludHM6bnVsbCwgc21vb3RoOmZhbHNlLCBzbW9vdGhDb25zdHJhaW50Om51bGx9LC8v5b2i54q2XHJcbiAgICAgICAgICAgIHBvc2l0aW9uOiBbMCwwXSxcclxuICAgICAgICAgICAgaXNFZGl0OiB0cnVlLCAgLy/mmK/lkKblj6/nvJbovpFcclxuICAgICAgICAgICAgdGV4dDoge1xyXG4gICAgICAgICAgICAgICAgdGV4dDogXCJcIixcclxuICAgICAgICAgICAgICAgIGNvbG9yOiAnIzAwMDAwMCcsIC8vIOaWh+acrOminOiJslxyXG4gICAgICAgICAgICAgICAgdGV4dEZvbnQ6ICcxMnB4IE1pY3Jvc29mdCBZYUhlaSdcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgejogMFxyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgb3B0ID0gb3B0aW9ucyB8fCB7fTtcclxuICAgICAgICB0aGlzLm9wdGlvbnMgPSB6clV0aWwubWVyZ2UoZGVmYXVsdE9wdGlvbnMsIG9wdCwgdHJ1ZSk7XHJcbiAgICAgICAgdGhpcy5tb2RlbCA9IG9wdGlvbnMubW9kZWw7XHJcbiAgICAgICAgdGhpcy5oYW5kbGVzID0gW107XHJcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uUG9pbnRzID0gW107XHJcbiAgICAgICAgdGhpcy5jb25Qb2ludHNHcm91cCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5zdGFydE5vZGUgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuZW5kTm9kZSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5saW5lID0gbnVsbDtcclxuICAgICAgICB0aGlzLmdyb3VwQ3VydmUgPSBuZXcgZ3JhcGhpYy5Hcm91cCgpO1xyXG4gICAgICAgIHRoaXMuaWNvbnMgPSBbXTsgIC8vIOeUqOS6juWtmOWCqOe6v+auteS4iumdoueahOaTjeS9nOWbvuagh1xyXG4gICAgICAgIHRoaXMucmVuZGVyKCk7XHJcbiAgICB9XHJcblxyXG4gICAgQ29ubmVjdG9yLlRZUEVfU1RSQUlHSFQgPSAnc3RyYWlnaHQnO1xyXG5cclxuICAgIENvbm5lY3Rvci5UWVBFX0pBR0dFRCA9ICdqYWdnZWQnO1xyXG5cclxuICAgIENvbm5lY3Rvci5UWVBFX0NVUlZFID0gJ2N1cnZlJztcclxuXHJcbiAgICBDb25uZWN0b3IuUkFESVVTID0gMztcclxuXHJcbiAgICBDb25uZWN0b3IuU1RBUlRfTk9ERSA9IFwic3RhcnROb2RlXCI7XHJcblxyXG4gICAgQ29ubmVjdG9yLkVORF9OT0RFID0gXCJlbmROb2RlXCI7XHJcblxyXG4gICAgQ29ubmVjdG9yLkxFRlQgPSBcImxlZnRcIjtcclxuXHJcbiAgICBDb25uZWN0b3IuUklHSFQgPSBcInJpZ2h0XCI7XHJcblxyXG4gICAgQ29ubmVjdG9yLlRPUCA9IFwidG9wXCI7XHJcblxyXG4gICAgQ29ubmVjdG9yLkJPVFRPTSA9IFwiYm90dG9tXCI7XHJcblxyXG4gICAgQ29ubmVjdG9yLkJPVFRPTSA9IFwiYm90dG9tXCI7XHJcblxyXG4gICAgQ29ubmVjdG9yLlNFUEVSQVRPUiA9IFwiLVwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiDph43mlrDnlLvnur/vvIzlpoLmnpzkvKDnqbrliJnmoLnmja50dXJuaW5nUG9pbnRzIOmHjeaWsOeUu+e6v1xyXG4gICAgICogQHBhcmFtICB7W3R5cGVdfSBwb2ludHMgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICogQHJldHVybiB7W3R5cGVdfSAgICAgICAgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICovXHJcbiAgICBDb25uZWN0b3IucHJvdG90eXBlLnJlZnJlc2ggPSBmdW5jdGlvbihwb2ludHMpIHtcclxuICAgICAgICBpZihwb2ludHMpIHtcclxuICAgICAgICAgICAgdGhpcy50dXJuaW5nUG9pbnRzID0gcG9pbnRzO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvL+Wwhlt4OjAseTowXei9rOWMluS4ulswLCAwXSAg57uZenJlbmRlcuS9v+eUqFxyXG4gICAgICAgIHZhciBwb2ludHMgPSBVdGlsLnRyYXNsYXRlUG9pbnRzKHRoaXMudHVybmluZ1BvaW50cyk7XHJcblxyXG4gICAgICAgIGlmKCh0aGlzLm9wdGlvbnMuc3R5bGUubGluZVR5cGUgPT0gQ29ubmVjdG9yLlRZUEVfQ1VSVkUpICYmIChwb2ludHMubGVuZ3RoID4gMikpIHtcclxuICAgICAgICAgICAgdGhpcy5tb2RpZnlDdXJ2ZSh0aGlzLnR1cm5pbmdQb2ludHMpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMubGluZS5hdHRyKCdzaGFwZScsIHtwb2ludHM6IHBvaW50c30pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGxpbmVUZXh0ID0gdGhpcy5jaGlsZE9mTmFtZSgnbGluZVRleHQnKTtcclxuICAgICAgICAvL+W8gOWni+ayoeacieWIm+W7uuaWh+acrO+8jOWQjuadpeS8oOi/m+adpXRleHTkuobvvIzpnIDopoHlhYjliJvlu7rmlofmnKxcclxuICAgICAgICBpZiAoIWxpbmVUZXh0ICAmJiB0aGlzLm9wdGlvbnMudGV4dC50ZXh0KSB7XHJcbiAgICAgICAgICAgIHZhciB0ZXh0ID0gdGhpcy5kcmF3VGV4dChcImxpbmVUZXh0XCIsIHRoaXMub3B0aW9ucy50ZXh0LnRleHQsMCwgMCk7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkKHRleHQudGV4dCk7XHJcbiAgICAgICAgICAgIGxpbmVUZXh0ID0gdGhpcy5jaGlsZE9mTmFtZSgnbGluZVRleHQnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGxpbmVUZXh0KSB7XHJcbiAgICAgICAgICAgIGxpbmVUZXh0LnNldFN0eWxlKFwidGV4dFwiLCB0aGlzLm9wdGlvbnMudGV4dC50ZXh0KTtcclxuXHJcbiAgICAgICAgICAgIHZhciB0ZXh0UG9pbnQgPSB0aGlzLmdldFRleHRQb3N0aW9uKHRoaXMub3B0aW9ucy50ZXh0KTtcclxuXHJcbiAgICAgICAgICAgIC8vIGlmICh0aGlzLm9wdGlvbnMuc3R5bGUubGluZVR5cGUgPT0gQ29ubmVjdG9yLlRZUEVfU1RSQUlHSFQgKSB7XHJcbiAgICAgICAgICAgIC8vICAgICBsaW5lVGV4dC5hdHRyKCdyb3RhdGlvbicsIHRoaXMuZ2V0VGV4dFJvdGF0aW9uKHRleHRQb2ludCkpO1xyXG4gICAgICAgICAgICAvLyB9XHJcblxyXG4gICAgICAgICAgICBsaW5lVGV4dC5hdHRyKFwicG9zaXRpb25cIiwgdGV4dFBvaW50KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHN5bWJvbFRvID0gdGhpcy5jaGlsZE9mTmFtZSgndG9TeW1ib2wnKTtcclxuICAgICAgICBpZihzeW1ib2xUbykge1xyXG4gICAgICAgICAgICBpZih0aGlzLm9wdGlvbnMuZWZmZWN0JiZ0aGlzLm9wdGlvbnMuZWZmZWN0LnNob3cpe1xyXG4gICAgICAgICAgICAgICAgbmV3IEVmZmVjdExpbmUoc3ltYm9sVG8sdGhpcy5vcHRpb25zLHRoaXMuZ3JvdXBDdXJ2ZSx0aGlzLnBvbHlMaW5lKTtcclxuICAgICAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgICAgICBzeW1ib2xUby5hdHRyKCdwb3NpdGlvbicsIHBvaW50c1twb2ludHMubGVuZ3RoIC0xXSk7XHJcbiAgICAgICAgICAgICAgICBzeW1ib2xUby5hdHRyKCdyb3RhdGlvbicsIFV0aWwudGFuZ2VudFJvdGF0aW9uKHRoaXMudHVybmluZ1BvaW50c1t0aGlzLnR1cm5pbmdQb2ludHMubGVuZ3RoLTJdLCB0aGlzLnR1cm5pbmdQb2ludHNbdGhpcy50dXJuaW5nUG9pbnRzLmxlbmd0aC0xXSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiDmuLLmn5NcclxuICAgICAqIEByZXR1cm4ge1t0eXBlXX0gW2Rlc2NyaXB0aW9uXVxyXG4gICAgICovXHJcbiAgICBDb25uZWN0b3IucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgICAgICAvLzEu5Yib5bu6566t5aS0XHJcbiAgICAgICAgdmFyIHN5bWJvbFRvID0gdGhpcy5jcmVhdGVTeW1ib2woJ3RvU3ltYm9sJywgdGhpcy5vcHRpb25zKTsgLy9hcnJvdyx0cmlhbmdsZVxyXG4gICAgICAgIGlmIChzeW1ib2xUbykge1xyXG4gICAgICAgICAgICB0aGlzLmFkZChzeW1ib2xUbyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLzIu5Yib5bu657q/XHJcbiAgICAgICAgdGhpcy5jdXJ2ZUxpbmUgPSBuZXcgZ3JhcGhpYy5CZXppZXJDdXJ2ZSh7XHJcbiAgICAgICAgICAgIHBvc2l0aW9uOiB0aGlzLm9wdGlvbnMucG9zaXRpb24sXHJcbiAgICAgICAgICAgIHN0eWxlOiB0aGlzLm9wdGlvbnMuc3R5bGUsXHJcbiAgICAgICAgICAgIHo6IHRoaXMub3B0aW9ucy56XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5ncm91cEN1cnZlLmFkZCh0aGlzLmN1cnZlTGluZSk7XHJcbiAgICAgICAgdGhpcy5hZGQodGhpcy5ncm91cEN1cnZlKTtcclxuXHJcbiAgICAgICAgdGhpcy5wb2x5TGluZSA9IG5ldyBncmFwaGljLlBvbHlsaW5lKHtcclxuICAgICAgICAgICAgcG9zaXRpb246IHRoaXMub3B0aW9ucy5wb3NpdGlvbixcclxuICAgICAgICAgICAgc2hhcGU6IHRoaXMub3B0aW9ucy5zaGFwZSxcclxuICAgICAgICAgICAgc3R5bGU6IHRoaXMub3B0aW9ucy5zdHlsZSxcclxuICAgICAgICAgICAgejogdGhpcy5vcHRpb25zLnpcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmFkZCh0aGlzLnBvbHlMaW5lKTtcclxuXHJcbiAgICAgICAgaWYoKHRoaXMub3B0aW9ucy5zdHlsZS5saW5lVHlwZSA9PSBDb25uZWN0b3IuVFlQRV9DVVJWRSkpIHtcclxuICAgICAgICAgICAgdGhpcy5saW5lID0gdGhpcy5ncm91cEN1cnZlO1xyXG4gICAgICAgICAgICB0aGlzLmNyZWF0ZUhvdmVyU3R5bGUodGhpcy5jdXJ2ZUxpbmUpO1xyXG4gICAgICAgICAgICB0aGlzLnBvbHlMaW5lLmhpZGUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMubGluZSA9IHRoaXMucG9seUxpbmU7XHJcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlSG92ZXJTdHlsZSh0aGlzLnBvbHlMaW5lKTtcclxuICAgICAgICAgICAgdGhpcy5jdXJ2ZUxpbmUuaGlkZSgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8zLuS+puWQrOe6v+S6i+S7tlxyXG4gICAgICAgIHZhciBNT1VTRV9FVkVOVF9OQU1FUyA9IFsnZGJsY2xpY2snLCAnY2xpY2snXTsvLydjbGljaycsICdkYmxjbGljaycsICdtb3VzZW92ZXInLCAnbW91c2VvdXQnXHJcbiAgICAgICAgenJVdGlsLmVhY2goTU9VU0VfRVZFTlRfTkFNRVMsIGZ1bmN0aW9uIChldmVOYW1lKSB7XHJcbiAgICAgICAgICAgIHRoaXMubGluZS5vbihldmVOYW1lLCB6clV0aWwuYmluZChmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAgICAgZS5jYW5jZWxCdWJibGUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgdmFyIHBhcmFtcyA9IHt9O1xyXG4gICAgICAgICAgICAgICAgcGFyYW1zLmV2ZW50ID0gZTtcclxuICAgICAgICAgICAgICAgIHBhcmFtcy50eXBlID0gXCJDb25uZWN0b3I6XCIgKyBldmVOYW1lO1xyXG4gICAgICAgICAgICAgICAgcGFyYW1zLnRhcmdldCA9IHRoYXQ7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXIocGFyYW1zLnR5cGUsIHBhcmFtcyk7XHJcbiAgICAgICAgICAgICAgICBpZih0aGlzLm9wdGlvbnMuaXNFZGl0ID09IGZhbHNlKXtyZXR1cm47fVxyXG5cclxuICAgICAgICAgICAgICAgIGlmKHRoaXMub3B0aW9ucy5pc0VkaXQgJiYgdGhpcy5jb25uZWN0aW9uUG9pbnRzLmxlbmd0aCA8IDEgJiYgdGhpcy50dXJuaW5nUG9pbnRzLmxlbmd0aCA+PTIpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNyZWF0ZUFsbGNvbm5lY3Rpb25Qb2ludCgpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZih0aGlzLmhhbmRsZXMubGVuZ3RoIDwgMSApIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNoYXBlU2V0SGFuZGxlKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sIHRoaXMpKTtcclxuICAgICAgICB9LCB0aGlzKTtcclxuXHJcbiAgICAgICAgLy8zLuWIm+W7uuiwg+aVtOe6v+eahOi/nuaOpeeCuVxyXG4gICAgICAgIGlmKHRoaXMub3B0aW9ucy5pc0VkaXQpIHtcclxuICAgICAgICAgICAgdGhpcy5jb25Qb2ludHNHcm91cCA9IG5ldyBncmFwaGljLkdyb3VwKCk7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkKHRoaXMuY29uUG9pbnRzR3JvdXApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy80LuWIm+W7uue6v+S4iuaWh+acrFxyXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMudGV4dC50ZXh0ICYmIHRoaXMub3B0aW9ucy50ZXh0LnRleHQgIT0gXCJcIikge1xyXG4gICAgICAgICAgICB2YXIgdGV4dCA9IHRoaXMuZHJhd1RleHQoXCJsaW5lVGV4dFwiLCB0aGlzLm9wdGlvbnMudGV4dC50ZXh0LDAsIDApO1xyXG4gICAgICAgICAgICB0aGlzLmFkZCh0ZXh0LnRleHQpO1xyXG4gICAgICAgIH1cclxuXHJcblxyXG4gICAgfTtcclxuXHJcbiAgICAvL+iuvue9rnN0eWxlXHJcbiAgICBDb25uZWN0b3IucHJvdG90eXBlLnNldFN0eWxlID0gZnVuY3Rpb24ob3B0aW9ucykge1xyXG4gICAgICAgIGlmKG9wdGlvbnMuY29sb3Ipe1xyXG4gICAgICAgICAgICBpZih0aGlzLm9wdGlvbnMuc3R5bGUubGluZVR5cGUgPT0gQ29ubmVjdG9yLlRZUEVfQ1VSVkUpe1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ncm91cEN1cnZlLmVhY2hDaGlsZChmdW5jdGlvbihjdXJ2ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnZlLmF0dHIoXCJzdHlsZVwiLHtzdHJva2U6b3B0aW9ucy5jb2xvcn0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGdyYXBoaWMuc2V0Tm9ybWFsU3R5bGUoY3VydmUsIHtzdHJva2U6b3B0aW9ucy5jb2xvcn0pO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wb2x5TGluZS5hdHRyKFwic3R5bGVcIix7c3Ryb2tlOm9wdGlvbnMuY29sb3J9KTtcclxuICAgICAgICAgICAgICAgIGdyYXBoaWMuc2V0Tm9ybWFsU3R5bGUodGhpcy5wb2x5TGluZSwge3N0cm9rZTpvcHRpb25zLmNvbG9yfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHN5bWJvbFRvID0gdGhpcy5jaGlsZE9mTmFtZSgndG9TeW1ib2wnKTtcclxuICAgICAgICAgICAgaWYgKHN5bWJvbFRvKSB7XHJcbiAgICAgICAgICAgICAgICBzeW1ib2xUby5hdHRyKFwic3R5bGVcIix7ZmlsbDpvcHRpb25zLmNvbG9yfSk7XHJcbiAgICAgICAgICAgICAgICBncmFwaGljLnNldE5vcm1hbFN0eWxlKHN5bWJvbFRvLCB7ZmlsbDpvcHRpb25zLmNvbG9yfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5vcHRpb25zLnN0eWxlLnN0cm9rZSA9IG9wdGlvbnMuY29sb3I7XHJcbiAgICAgICAgICAgIHRoaXMubW9kZWwuc2V0KFwib3B0aW9ucy5zdHlsZS5zdHJva2VcIiwgb3B0aW9ucy5jb2xvcik7XHJcbiAgICAgICAgICAgIHRoaXMubW9kZWwuc2V0KFwib3B0aW9ucy5zeW1ib2wuY29sb3JcIiwgb3B0aW9ucy5jb2xvcik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZihvcHRpb25zLnRleHQpe1xyXG4gICAgICAgICAgICAgdmFyIGxpbmVUZXh0ID0gdGhpcy5jaGlsZE9mTmFtZSgnbGluZVRleHQnKTtcclxuICAgICAgICAgICAgLy/lvIDlp4vmsqHmnInliJvlu7rmlofmnKzvvIzlkI7mnaXkvKDov5vmnaV0ZXh05LqG77yM6ZyA6KaB5YWI5Yib5bu65paH5pysXHJcbiAgICAgICAgICAgIGlmICghbGluZVRleHQgICYmIG9wdGlvbnMudGV4dC50ZXh0KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdGV4dCA9IHRoaXMuZHJhd1RleHQoXCJsaW5lVGV4dFwiLCBvcHRpb25zLnRleHQudGV4dCwwLCAwKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuYWRkKHRleHQudGV4dCk7XHJcbiAgICAgICAgICAgICAgICBsaW5lVGV4dCA9IHRoaXMuY2hpbGRPZk5hbWUoJ2xpbmVUZXh0Jyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmKG9wdGlvbnMudGV4dC50ZXh0IHx8IG9wdGlvbnMudGV4dC50ZXh0ID09IFwiXCIpe1xyXG4gICAgICAgICAgICAgICAgbGluZVRleHQuc2V0U3R5bGUoXCJ0ZXh0XCIsIG9wdGlvbnMudGV4dC50ZXh0KTtcclxuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy50ZXh0LnRleHQgPSBvcHRpb25zLnRleHQudGV4dDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgdGV4dFBvaW50ID0gdGhpcy5nZXRUZXh0UG9zdGlvbihvcHRpb25zLnRleHQpO1xyXG4gICAgICAgICAgICBsaW5lVGV4dC5hdHRyKFwicG9zaXRpb25cIiwgdGV4dFBvaW50KTtcclxuICAgICAgICAgICAgaWYob3B0aW9ucy50ZXh0LnRleHRQb3Mpe1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLnRleHQudGV4dFBvcyA9IG9wdGlvbnMudGV4dC50ZXh0UG9zO1xyXG4gICAgICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy50ZXh0LnRleHRQb3MgPSAnY2VudGVyJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZihvcHRpb25zLnRleHQuY29sb3Ipe1xyXG4gICAgICAgICAgICAgICAgbGluZVRleHQuYXR0cihcInN0eWxlXCIse1xyXG4gICAgICAgICAgICAgICAgICAgIGZpbGw6IG9wdGlvbnMudGV4dC5jb2xvclxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMudGV4dC5jb2xvciA9IG9wdGlvbnMudGV4dC5jb2xvcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLm1vZGVsLnNldChcIm9wdGlvbnMudGV4dFwiLCBvcHRpb25zLnRleHQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICog6I635Y+W57q/5q6155qE5L2N572uXHJcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IHRleHQge3RleHQ6JycsIGNvbG9yOicnLCB0ZXh0UG9zOicnfVxyXG4gICAgICogQHJldHVybiB7T2JqZWN0fSAgICAgIHt4LHl9XHJcbiAgICAgKi9cclxuICAgIENvbm5lY3Rvci5wcm90b3R5cGUuZ2V0VGV4dFBvc3Rpb24gPSBmdW5jdGlvbih0ZXh0KSB7XHJcbiAgICAgICAgdmFyIHRleHRQb3N0aW9uID0gW107XHJcbiAgICAgICAgdmFyIHRleHRXaWR0aCA9IGdyYXBoaWMudGV4dENvbnRhaW4uZ2V0V2lkdGgodGV4dC50ZXh0LCB0ZXh0LnRleHRGb250KTtcclxuICAgICAgICBpZih0ZXh0JiZ0ZXh0LnRleHRQb3Mpe1xyXG4gICAgICAgICAgICBpZih0ZXh0LnRleHRQb3MgPT0gJ3N0YXJ0Jyl7XHJcbiAgICAgICAgICAgICAgICB2YXIgeE9mZnNldCA9IHRleHQueE9mZnNldCB8fCAwO1xyXG4gICAgICAgICAgICAgICAgdGV4dFBvc3Rpb24gPSBbdGhpcy50dXJuaW5nUG9pbnRzWzBdLnggKyB4T2Zmc2V0LHRoaXMudHVybmluZ1BvaW50c1swXS55XTtcclxuICAgICAgICAgICAgfWVsc2UgaWYodGV4dC50ZXh0UG9zID09ICdlbmQnKXtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc3R5bGUubGluZVR5cGUgPT0gQ29ubmVjdG9yLlRZUEVfU1RSQUlHSFQgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBvaW50cyAgPSBVdGlsLmdldE1heExpbmVMZW5ndGgodGhpcy50dXJuaW5nUG9pbnRzKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFuZ2xlID0gVXRpbC5nZXRBbmdsZShwb2ludHNbMF0scG9pbnRzWzFdKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbGVuZ3RoID0gIFV0aWwuZGlzdGFuY2UocG9pbnRzWzBdLHBvaW50c1sxXSkgLSB0ZXh0V2lkdGg7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5ld1BvaW50ID0gVXRpbC5nZXRFbmRQb2ludChwb2ludHNbMF0sIGxlbmd0aCwgYW5nbGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRleHRQb3N0aW9uID0gW25ld1BvaW50LngsbmV3UG9pbnQueV07XHJcbiAgICAgICAgICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgICAgICAgICB0ZXh0UG9zdGlvbiA9IFt0aGlzLnR1cm5pbmdQb2ludHNbdGhpcy50dXJuaW5nUG9pbnRzLmxlbmd0aC0xXS54LHRoaXMudHVybmluZ1BvaW50c1t0aGlzLnR1cm5pbmdQb2ludHMubGVuZ3RoLTFdLnldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgICAgIHRleHRQb3N0aW9uID0gdGhpcy5taWRkbGUodGV4dCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgdmFyIHBvc2l0aW9uID0gdGhpcy5taWRkbGUodGV4dCk7XHJcbiAgICAgICAgICAgIHRleHRQb3N0aW9uID0gW3Bvc2l0aW9uWzBdLXRleHRXaWR0aC8yLHBvc2l0aW9uWzFdXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0ZXh0UG9zdGlvbjtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDojrflj5bnur/mrrXnmoTml4vovazop5LluqZcclxuICAgICAqIEBwYXJhbSAge09iamVjdH0gdGV4dFBvc3Rpb24ge3gseX1cclxuICAgICAqIEByZXR1cm4ge051bWJlcn0gICAgICAgICAgICAg6KeS5bqm5YC8XHJcbiAgICAgKi9cclxuICAgIENvbm5lY3Rvci5wcm90b3R5cGUuZ2V0VGV4dFJvdGF0aW9uID0gZnVuY3Rpb24odGV4dFBvc3Rpb24pIHtcclxuICAgICAgICAvL+iuoeeul+WHuuaegeWdkOagh+eahOinkuW6plxyXG4gICAgICAgIHZhciBwb2ludHMgID0gVXRpbC5nZXRNYXhMaW5lTGVuZ3RoKHRoaXMudHVybmluZ1BvaW50cyk7XHJcbiAgICAgICAgdmFyIGFuZ2xlID0gLSBNYXRoLmF0YW4yKHBvaW50c1sxXS55IC0gdGV4dFBvc3Rpb25bMV0sIHBvaW50c1sxXS54IC0gdGV4dFBvc3Rpb25bMF0pOyAgLy8sTWF0aC5QSS8yXHJcbiAgICAgICAgcmV0dXJuIGFuZ2xlO1xyXG4gICAgfTtcclxuXHJcbiAgICBDb25uZWN0b3IucHJvdG90eXBlLmNyZWF0ZUhvdmVyU3R5bGUgPSBmdW5jdGlvbihlbCkge1xyXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuaG92ZXJTdHlsZSkge1xyXG4gICAgICAgICAgICBncmFwaGljLnNldEVsZW1lbnRIb3ZlclN0bChlbCwgdGhpcy5vcHRpb25zLmhvdmVyU3R5bGUpO1xyXG5cclxuICAgICAgICAgICAgdmFyIHN5bWJvbFRvID0gdGhpcy5jaGlsZE9mTmFtZSgndG9TeW1ib2wnKTtcclxuICAgICAgICAgICAgaWYoc3ltYm9sVG8pe2dyYXBoaWMuc2V0RWxlbWVudEhvdmVyU3RsKHN5bWJvbFRvLCB0aGlzLm9wdGlvbnMuYXJyb3dIb3ZlclN0eWxlKTt9XHJcblxyXG4gICAgICAgICAgICBlbC5vbignbW91c2VvdmVyJywgenJVdGlsLmJpbmQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICBncmFwaGljLmRvRW50ZXJIb3ZlcihlbCk7XHJcbiAgICAgICAgICAgICAgICBpZihzeW1ib2xUbyl7Z3JhcGhpYy5kb0VudGVySG92ZXIoc3ltYm9sVG8pO31cclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLmdyb3VwQ3VydmUuZWFjaENoaWxkKGZ1bmN0aW9uKGxpbmUpIHtcclxuICAgICAgICAgICAgICAgICAgICBncmFwaGljLmRvRW50ZXJIb3ZlcihsaW5lKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9LHRoaXMpKVxyXG4gICAgICAgICAgICAgIC5vbignbW91c2VvdXQnLCB6clV0aWwuYmluZChmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIGdyYXBoaWMuZG9MZWF2ZUhvdmVyKGVsKTtcclxuICAgICAgICAgICAgICAgIGlmKHN5bWJvbFRvKXtncmFwaGljLmRvTGVhdmVIb3ZlcihzeW1ib2xUbyk7fVxyXG4gICAgICAgICAgICAgICAgdGhpcy5ncm91cEN1cnZlLmVhY2hDaGlsZChmdW5jdGlvbihsaW5lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZ3JhcGhpYy5kb0xlYXZlSG92ZXIobGluZSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSx0aGlzKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICog5Yib5bu6Tm9kZeeahOi/nuaOpeeCuVxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJuIHtbdHlwZV19IFtkZXNjcmlwdGlvbl1cclxuICAgICAqL1xyXG4gICAgQ29ubmVjdG9yLnByb3RvdHlwZS5jcmVhdGVBbGxjb25uZWN0aW9uUG9pbnQgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgc1JlY3QgPSB0aGlzLnN0YXJ0Tm9kZS5nZXRSZWN0PyB0aGlzLnN0YXJ0Tm9kZS5nZXRSZWN0KCkuYm91bmRpbmdSZWN0IDogVXRpbC5nZXRSZWN0KHRoaXMuc3RhcnROb2RlKS5ib3VuZGluZ1JlY3Q7XHJcblxyXG4gICAgICAgIHZhciBlUmVjdCA9IHRoaXMuZW5kTm9kZS5nZXRSZWN0PyB0aGlzLmVuZE5vZGUuZ2V0UmVjdCgpLmJvdW5kaW5nUmVjdCA6IFV0aWwuZ2V0UmVjdCh0aGlzLmVuZE5vZGUpLmJvdW5kaW5nUmVjdDtcclxuXHJcbiAgICAgICAgdmFyIHNDb25uZWN0b3JQb2ludCA9IFV0aWwuZ2V0Q29ubmVjdG9yUG9pbnRzKHNSZWN0KTtcclxuICAgICAgICB2YXIgZUNvbm5lY3RvclBvaW50ID0gVXRpbC5nZXRDb25uZWN0b3JQb2ludHMoZVJlY3QpO1xyXG5cclxuICAgICAgICB0aGlzLmNvbm5lY3Rpb25Qb2ludENyZWF0ZSh0aGlzLnN0YXJ0Tm9kZSwgc0Nvbm5lY3RvclBvaW50LmxlZnQsIENvbm5lY3Rvci5TVEFSVF9OT0RFICsgQ29ubmVjdG9yLlNFUEVSQVRPUiArIENvbm5lY3Rvci5MRUZUKTtcclxuICAgICAgICB0aGlzLmNvbm5lY3Rpb25Qb2ludENyZWF0ZSh0aGlzLnN0YXJ0Tm9kZSwgc0Nvbm5lY3RvclBvaW50LnJpZ2h0LCBDb25uZWN0b3IuU1RBUlRfTk9ERSArIENvbm5lY3Rvci5TRVBFUkFUT1IgKyBDb25uZWN0b3IuUklHSFQpO1xyXG4gICAgICAgIHRoaXMuY29ubmVjdGlvblBvaW50Q3JlYXRlKHRoaXMuc3RhcnROb2RlLCBzQ29ubmVjdG9yUG9pbnQudG9wLCBDb25uZWN0b3IuU1RBUlRfTk9ERSArIENvbm5lY3Rvci5TRVBFUkFUT1IgKyBDb25uZWN0b3IuVE9QKTtcclxuICAgICAgICB0aGlzLmNvbm5lY3Rpb25Qb2ludENyZWF0ZSh0aGlzLnN0YXJ0Tm9kZSwgc0Nvbm5lY3RvclBvaW50LmJvdHRvbSwgQ29ubmVjdG9yLlNUQVJUX05PREUgKyBDb25uZWN0b3IuU0VQRVJBVE9SICsgQ29ubmVjdG9yLkJPVFRPTSk7XHJcblxyXG4gICAgICAgIHRoaXMuY29ubmVjdGlvblBvaW50Q3JlYXRlKHRoaXMuZW5kTm9kZSwgZUNvbm5lY3RvclBvaW50LmxlZnQsIENvbm5lY3Rvci5FTkRfTk9ERSArIENvbm5lY3Rvci5TRVBFUkFUT1IgKyBDb25uZWN0b3IuTEVGVCk7XHJcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uUG9pbnRDcmVhdGUodGhpcy5lbmROb2RlLCBlQ29ubmVjdG9yUG9pbnQucmlnaHQsIENvbm5lY3Rvci5FTkRfTk9ERSArIENvbm5lY3Rvci5TRVBFUkFUT1IgKyBDb25uZWN0b3IuUklHSFQpO1xyXG4gICAgICAgIHRoaXMuY29ubmVjdGlvblBvaW50Q3JlYXRlKHRoaXMuZW5kTm9kZSwgZUNvbm5lY3RvclBvaW50LnRvcCwgQ29ubmVjdG9yLkVORF9OT0RFICsgQ29ubmVjdG9yLlNFUEVSQVRPUiArIENvbm5lY3Rvci5UT1ApO1xyXG4gICAgICAgIHRoaXMuY29ubmVjdGlvblBvaW50Q3JlYXRlKHRoaXMuZW5kTm9kZSwgZUNvbm5lY3RvclBvaW50LmJvdHRvbSwgQ29ubmVjdG9yLkVORF9OT0RFICsgQ29ubmVjdG9yLlNFUEVSQVRPUiArIENvbm5lY3Rvci5CT1RUT00pO1xyXG5cclxuXHJcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uUG9pbnRDcmVhdGUodGhpcywgdGhpcy50dXJuaW5nUG9pbnRzWzBdLmNsb25lKCksIENvbm5lY3Rpb25Qb2ludC5UWVBFX0NPTk5FQ1RPUik7XHJcblxyXG4gICAgICAgIHRoaXMuY29ubmVjdGlvblBvaW50Q3JlYXRlKHRoaXMsIHRoaXMudHVybmluZ1BvaW50c1t0aGlzLnR1cm5pbmdQb2ludHMubGVuZ3RoLTFdLmNsb25lKCksIENvbm5lY3Rpb25Qb2ludC5UWVBFX0NPTk5FQ1RPUik7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICog5Yib5bu66L+e5o6l54K5XHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtICB7W3R5cGVdfSBzaGFwZSBbZGVzY3JpcHRpb25dXHJcbiAgICAgKiBAcGFyYW0gIHtbdHlwZV19IHBvaW50IFtkZXNjcmlwdGlvbl1cclxuICAgICAqIEBwYXJhbSAge1t0eXBlXX0gdHlwZSAgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICogQHJldHVybiB7W3R5cGVdfSAgICAgICBbZGVzY3JpcHRpb25dXHJcbiAgICAgKi9cclxuICAgIENvbm5lY3Rvci5wcm90b3R5cGUuY29ubmVjdGlvblBvaW50Q3JlYXRlID0gZnVuY3Rpb24oc2hhcGUsIHBvaW50LCB0eXBlKSB7XHJcbiAgICAgICAgdmFyIGNvblBvaW50ID0gbmV3IENvbm5lY3Rpb25Qb2ludCh0aGlzLCBwb2ludCwgdHlwZSwgdGhpcy5vcHRpb25zKTtcclxuICAgICAgICB0aGlzLmNvblBvaW50c0dyb3VwLmFkZChjb25Qb2ludC5zaGFwZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICog5riF56m65o6n5Yi254K5XHJcbiAgICAgKiBAcmV0dXJuIHtbdHlwZV19IFtkZXNjcmlwdGlvbl1cclxuICAgICAqL1xyXG4gICAgQ29ubmVjdG9yLnByb3RvdHlwZS5jbGVhckhhbmRsZXMgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuaGFuZGxlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB0aGlzLnJlbW92ZSh0aGlzLmhhbmRsZXNbaV0uaGFuZGxlU2hhcGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmhhbmRsZXMgPSBbXTtcclxuICAgICAgICBpZiAodGhpcy5jb25Qb2ludHNHcm91cCkge1xyXG4gICAgICAgICAgICB0aGlzLmNvblBvaW50c0dyb3VwLnJlbW92ZUFsbCgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDliJvlu7rmi4bnur8g57q/5pat55qE5o6n5Yi254K5XHJcbiAgICAgKiBAcmV0dXJuIHtbdHlwZV19IFtkZXNjcmlwdGlvbl1cclxuICAgICAqL1xyXG4gICAgQ29ubmVjdG9yLnByb3RvdHlwZS5zaGFwZVNldEhhbmRsZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGZvcih2YXIgaT0xOyBpPHRoaXMudHVybmluZ1BvaW50cy5sZW5ndGgtMjsgaSsrKXtcclxuICAgICAgICAgICAgdmFyIGg7XHJcbiAgICAgICAgICAgIHZhciB4LCB5O1xyXG4gICAgICAgICAgICAvL+aYr+WQpuWcqOS4gOadoee6v+S4ilxyXG4gICAgICAgICAgICB2YXIgaXNDb2xsaW5lYWl0eUZpcnN0ID0gVXRpbC5jb2xsaW5lYXJpdHkodGhpcy50dXJuaW5nUG9pbnRzW2ktMV0sIHRoaXMudHVybmluZ1BvaW50c1tpXSwgdGhpcy50dXJuaW5nUG9pbnRzW2krMV0pO1xyXG4gICAgICAgICAgICB2YXIgaXNDb2xsaW5lYWl0eVNlY29uZCA9IFV0aWwuY29sbGluZWFyaXR5KHRoaXMudHVybmluZ1BvaW50c1tpXSwgdGhpcy50dXJuaW5nUG9pbnRzW2krMV0sIHRoaXMudHVybmluZ1BvaW50c1tpKzJdKTtcclxuICAgICAgICAgICAgaWYoICghaXNDb2xsaW5lYWl0eUZpcnN0ICYmICghaXNDb2xsaW5lYWl0eVNlY29uZCB8fCB0aGlzLnR1cm5pbmdQb2ludHNbaSsxXS5lcXVhbHModGhpcy50dXJuaW5nUG9pbnRzW2krMl0pKSlcclxuICAgICAgICAgICAgICAgIHx8ICggKCFpc0NvbGxpbmVhaXR5Rmlyc3QgfHwgdGhpcy50dXJuaW5nUG9pbnRzW2ktMV0uZXF1YWxzKHRoaXMudHVybmluZ1BvaW50c1tpXSkpICYmICFpc0NvbGxpbmVhaXR5U2Vjb25kICkpIHtcclxuXHJcbiAgICAgICAgICAgICAgICBpZih0aGlzLnR1cm5pbmdQb2ludHNbaV0ueCA9PT0gdGhpcy50dXJuaW5nUG9pbnRzW2krMV0ueCl7IC8vc2FtZSB2ZXJ0aWNhbFxyXG4gICAgICAgICAgICAgICAgICAgIHggPSB0aGlzLnR1cm5pbmdQb2ludHNbaV0ueDtcclxuICAgICAgICAgICAgICAgICAgICB5ID0gKHRoaXMudHVybmluZ1BvaW50c1tpXS55ICsgdGhpcy50dXJuaW5nUG9pbnRzW2krMV0ueSkgLyAyO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBoID0gbmV3IEhhbmRsZSgnaCcseCx5LHRoaXMpO1xyXG5cclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmKHRoaXMudHVybmluZ1BvaW50c1tpXS55ID09PSB0aGlzLnR1cm5pbmdQb2ludHNbaSsxXS55KXsgLy8gc2FtZSBob3Jpem9udGFsXHJcbiAgICAgICAgICAgICAgICAgICAgeCA9ICh0aGlzLnR1cm5pbmdQb2ludHNbaV0ueCArICB0aGlzLnR1cm5pbmdQb2ludHNbaSsxXS54KSAvIDI7XHJcbiAgICAgICAgICAgICAgICAgICAgeSA9IHRoaXMudHVybmluZ1BvaW50c1tpXS55O1xyXG4gICAgICAgICAgICAgICAgICAgIGggPSAgbmV3ICBIYW5kbGUoJ3YnLHgseSx0aGlzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGQoaC5oYW5kbGVTaGFwZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVzLnB1c2goaCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDliJvlu7rnrq3lpLRcclxuICAgICAqIEBwYXJhbSAge1t0eXBlXX0gbmFtZSAgICAgICBbZGVzY3JpcHRpb25dXHJcbiAgICAgKiBAcGFyYW0gIHtbdHlwZV19IG9wdGlvbnMgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICogQHJldHVybiB7W3R5cGVdfSAgICAgICAgICAgIFtkZXNjcmlwdGlvbl1cclxuICAgICAqL1xyXG4gICAgQ29ubmVjdG9yLnByb3RvdHlwZS5jcmVhdGVTeW1ib2wgPSBmdW5jdGlvbihuYW1lLCBvcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIHN5bWJvbFR5cGUgPSBvcHRpb25zLnN5bWJvbC50eXBlO1xyXG4gICAgICAgIHZhciBzeW1ib2xTaXplID10aGlzLm9wdGlvbnMuc3ltYm9sLnNpemU7XHJcbiAgICAgICAgaWYgKHN5bWJvbFR5cGUgPT09ICdub25lJykge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIXpyVXRpbC5pc0FycmF5KHN5bWJvbFNpemUpKSB7XHJcbiAgICAgICAgICAgIHN5bWJvbFNpemUgPSBbc3ltYm9sU2l6ZSwgc3ltYm9sU2l6ZV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBzeW1ib2xQYXRoID0gc3ltYm9sVXRpbC5jcmVhdGVTeW1ib2woXHJcbiAgICAgICAgICAgIHN5bWJvbFR5cGUsIC1zeW1ib2xTaXplWzBdIC8gMiwgLXN5bWJvbFNpemVbMV0gLyAyLFxyXG4gICAgICAgICAgICBzeW1ib2xTaXplWzBdLCBzeW1ib2xTaXplWzFdLCB0aGlzLm9wdGlvbnMuc3ltYm9sLmNvbG9yLCB0aGlzLm9wdGlvbnMuelxyXG4gICAgICAgICk7XHJcbiAgICAgICAgc3ltYm9sUGF0aC5uYW1lID0gbmFtZTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHN5bWJvbFBhdGg7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICog57uY5Yi257q/5q615LiK55qE5paH5pysXHJcbiAgICAgKiBAcGFyYW0gIHtbdHlwZV19IGNvbnRlbnQgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICogQHBhcmFtICB7W3R5cGVdfSBuYW1lIFtkZXNjcmlwdGlvbl1cclxuICAgICAqIEBwYXJhbSAge1t0eXBlXX0geCAgICAgICBbZGVzY3JpcHRpb25dXHJcbiAgICAgKiBAcGFyYW0gIHtbdHlwZV19IHkgICAgICAgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICogQHBhcmFtICB7W3R5cGVdfSBjb2xvciAgIFtkZXNjcmlwdGlvbl1cclxuICAgICAqIEByZXR1cm4ge1t0eXBlXX0gICAgICAgICBbZGVzY3JpcHRpb25dXHJcbiAgICAgKi9cclxuICAgIENvbm5lY3Rvci5wcm90b3R5cGUuZHJhd1RleHQgPSBmdW5jdGlvbiAobmFtZSxjb250ZW50LCB4LCB5LCBjb2xvcikge1xyXG4gICAgICAgIHZhciB0ZXh0ID0gbmV3IGdyYXBoaWMuVGV4dCh7XHJcbiAgICAgICAgICAgIHN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgICB0ZXh0OiBjb250ZW50LFxyXG4gICAgICAgICAgICAgICAgeDogeCxcclxuICAgICAgICAgICAgICAgIHk6IHksXHJcbiAgICAgICAgICAgICAgICBmaWxsOiBjb2xvciA/IGNvbG9yIDogdGhpcy5vcHRpb25zLnRleHQuY29sb3IsXHJcbiAgICAgICAgICAgICAgICB0ZXh0Rm9udDogdGhpcy5vcHRpb25zLnRleHQudGV4dEZvbnRcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgemxldmVsOiAyMFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRleHQubmFtZSA9IG5hbWU7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgdGV4dDogdGV4dCxcclxuICAgICAgICAgICAgcmVjdDogdGV4dC5nZXRCb3VuZGluZ1JlY3QoKVxyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICog6I635Y+W57q/5q6155qE5Lit6Ze05YC8XHJcbiAgICAgKiBAcmV0dXJuIHtbdHlwZV19IHRleHRcclxuICAgICAqL1xyXG4gICAgQ29ubmVjdG9yLnByb3RvdHlwZS5taWRkbGUgPSBmdW5jdGlvbih0ZXh0KXtcclxuXHJcbiAgICAgICAgaWYodGhpcy5vcHRpb25zLnN0eWxlLmxpbmVUeXBlID09IENvbm5lY3Rvci5UWVBFX1NUUkFJR0hUKXtcclxuICAgICAgICAgICAgdmFyIHBvaW50cyAgPSBVdGlsLmdldE1heExpbmVMZW5ndGgodGhpcy50dXJuaW5nUG9pbnRzKTtcclxuICAgICAgICAgICAgLy/lpoLmnpzmmK/msYLnur/mrrXkuIrnmoTmloflrZfnmoTkuK3pl7TlgLxcclxuICAgICAgICAgICAgLy8gaWYodGV4dCkge1xyXG4gICAgICAgICAgICAvLyAgICAgLy/lj5blh7rlrZfnmoTplb/luqbvvIzorqHnrpfop5LluqbvvIxcclxuICAgICAgICAgICAgLy8gICAgIHZhciB0ZXh0V2lkdGggPSBncmFwaGljLnRleHRDb250YWluLmdldFdpZHRoKHRleHQudGV4dCwgdGV4dC50ZXh0Rm9udCk7XHJcbiAgICAgICAgICAgIC8vICAgICB2YXIgYW5nbGUgPSBVdGlsLmdldEFuZ2xlKHBvaW50c1swXSxwb2ludHNbMV0pO1xyXG4gICAgICAgICAgICAvLyAgICAgdmFyIGxlbmd0aCA9ICBVdGlsLmRpc3RhbmNlKHBvaW50c1swXSxwb2ludHNbMV0pLzIgLSB0ZXh0V2lkdGgvMjtcclxuICAgICAgICAgICAgLy8gICAgIHZhciBuZXdQb2ludCA9IFV0aWwuZ2V0RW5kUG9pbnQocG9pbnRzWzBdLCBsZW5ndGgsIGFuZ2xlKTtcclxuICAgICAgICAgICAgLy8gICAgIHJldHVybiBbbmV3UG9pbnQueCwgbmV3UG9pbnQueV07XHJcbiAgICAgICAgICAgIC8vIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vICAgICB2YXIgbWlkZGxlWCA9IChwb2ludHNbMF0ueCArIHBvaW50c1sxXS54KS8yO1xyXG4gICAgICAgICAgICAvLyAgICAgdmFyIG1pZGRsZVkgPSAocG9pbnRzWzBdLnkgKyBwb2ludHNbMV0ueSkgLzI7XHJcbiAgICAgICAgICAgIC8vICAgICByZXR1cm4gW21pZGRsZVgsIG1pZGRsZVldO1xyXG4gICAgICAgICAgICAvLyB9XHJcbiAgICAgICAgICAgIHZhciBtaWRkbGVYID0gKHBvaW50c1swXS54ICsgcG9pbnRzWzFdLngpLzI7XHJcbiAgICAgICAgICAgIHZhciBtaWRkbGVZID0gKHBvaW50c1swXS55ICsgcG9pbnRzWzFdLnkpIC8yO1xyXG4gICAgICAgICAgICByZXR1cm4gW21pZGRsZVgsIG1pZGRsZVldO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmKHRoaXMub3B0aW9ucy5zdHlsZS5saW5lVHlwZSA9PSBDb25uZWN0b3IuVFlQRV9KQUdHRUQpe1xyXG5cclxuICAgICAgICAgICAgLy9maW5kIHRvdGFsIGRpc3RhbmNlXHJcbiAgICAgICAgICAgIHZhciBkaXN0YW5jZSA9IHRoaXMuZ2V0TGVuZ3RoKCk7XHJcblxyXG4gICAgICAgICAgICAvL2ZpbmQgYmV0d2VlbiB3aGF0IHR1cm5pbmcgcG9pbnRzIHRoZSBoYWxmIGRpc3RhbmNlIGlzXHJcbiAgICAgICAgICAgIHZhciBpbmRleCA9IC0xO1xyXG4gICAgICAgICAgICB2YXIgZWxsYXBzZWREaXN0YW5jZSA9IDA7XHJcbiAgICAgICAgICAgIGZvcih2YXIgaT0wOyBpPHRoaXMudHVybmluZ1BvaW50cy5sZW5ndGgtMTsgaSsrKXtcclxuICAgICAgICAgICAgICAgIGluZGV4ID0gaTtcclxuICAgICAgICAgICAgICAgIHZhciBzZWdtZW50ID0gVXRpbC5nZXRMZW5ndGgodGhpcy50dXJuaW5nUG9pbnRzW2ldLCB0aGlzLnR1cm5pbmdQb2ludHNbaSsxXSk7XHJcbiAgICAgICAgICAgICAgICBpZihlbGxhcHNlZERpc3RhbmNlICsgc2VnbWVudCA8IGRpc3RhbmNlIC8yKXtcclxuICAgICAgICAgICAgICAgICAgICBlbGxhcHNlZERpc3RhbmNlICs9IHNlZ21lbnQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNle1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvL3dlIGhhdmUgdGhlIG1pZGRsZSBkaXN0YW5jZSBzb21ld2hlcmUgYmV0d2VlbiBpKG5kZXgpIGFuZCBpKG5kZXgpKzFcclxuICAgICAgICAgICAgaWYoaW5kZXggIT0gLTEpe1xyXG4gICAgICAgICAgICAgICAgdmFyIG1pc3NpbmdEaXN0YW5jZSA9IGRpc3RhbmNlIC8gMiAtIGVsbGFwc2VkRGlzdGFuY2U7XHJcbiAgICAgICAgICAgICAgICBpZiggVXRpbC5yb3VuZCh0aGlzLnR1cm5pbmdQb2ludHNbaW5kZXhdLngsIDMpID09IFV0aWwucm91bmQodGhpcy50dXJuaW5nUG9pbnRzW2luZGV4ICsgMV0ueCwgMykgKXsgLy92ZXJ0aWNhbCBzZWdtZW50IChzYW1lIHgpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFt0aGlzLnR1cm5pbmdQb2ludHNbaW5kZXhdLngsIE1hdGgubWluKHRoaXMudHVybmluZ1BvaW50c1tpbmRleF0ueSwgdGhpcy50dXJuaW5nUG9pbnRzW2luZGV4ICsgMV0ueSkgKyBtaXNzaW5nRGlzdGFuY2VdO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmKCBVdGlsLnJvdW5kKHRoaXMudHVybmluZ1BvaW50c1tpbmRleF0ueSwgMykgPT0gVXRpbC5yb3VuZCh0aGlzLnR1cm5pbmdQb2ludHNbaW5kZXggKyAxXS55LCAzKSApIHsgLy9ob3Jpem9udGFsIHNlZ21lbnQgKHNhbWUgeSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW01hdGgubWluKHRoaXMudHVybmluZ1BvaW50c1tpbmRleF0ueCwgdGhpcy50dXJuaW5nUG9pbnRzW2luZGV4ICsgMV0ueCkgKyBtaXNzaW5nRGlzdGFuY2UsIHRoaXMudHVybmluZ1BvaW50c1tpbmRleF0ueV07XHJcbiAgICAgICAgICAgICAgICB9IGVsc2V7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkNvbm5lY3RvcjptaWRkbGUoKSAtIHRoaXMgc2hvdWxkIG5ldmVyIGhhcHBlbiBcIiArIHRoaXMudHVybmluZ1BvaW50c1tpbmRleF0gKyBcIiBcIiArIHRoaXMudHVybmluZ1BvaW50c1tpbmRleCArIDFdXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICsgXCIgbnIgb2YgcG9pbnRzIFwiICsgdGhpcy50dXJuaW5nUG9pbnRzLmxlbmd0aFxyXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmKHRoaXMub3B0aW9ucy5zdHlsZS5saW5lVHlwZSA9PSBDb25uZWN0b3IuVFlQRV9DVVJWRSl7XHJcbiAgICAgICAgICAgIHZhciB0ID0gMC41O1xyXG4gICAgICAgICAgICB2YXIgbCA9IHRoaXMuZ2V0TGVuZ3RoKCk7XHJcblxyXG4gICAgICAgICAgICB2YXIgd2Fsa2VkID0gMDtcclxuICAgICAgICAgICAgZm9yKHZhciBqID0wOyBqPCB0aGlzLnR1cm5pbmdQb2ludHMubGVuZ3RoLTE7IGorKyl7XHJcbiAgICAgICAgICAgICAgICBpZiggd2Fsa2VkICsgVXRpbC5kaXN0YW5jZSh0aGlzLnR1cm5pbmdQb2ludHNbal0sIHRoaXMudHVybmluZ1BvaW50c1tqKzFdKSA+IGwgKiB0ICl7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgd2Fsa2VkICs9IFV0aWwuZGlzdGFuY2UodGhpcy50dXJuaW5nUG9pbnRzW2pdLCB0aGlzLnR1cm5pbmdQb2ludHNbaisxXSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciByZXN0ID0gbCAqIHQgLSB3YWxrZWQ7XHJcbiAgICAgICAgICAgIHZhciBjdXJyZW50U2VnbWVudExlbmd0aCA9IFV0aWwuZGlzdGFuY2UodGhpcy50dXJuaW5nUG9pbnRzW2pdLCB0aGlzLnR1cm5pbmdQb2ludHNbaisxXSk7XHJcblxyXG4gICAgICAgICAgICAvL2ZpbmQgdGhlIHBvc2l0aW9uL3JhdGlvbiBvZiB0aGUgbWlkZGxlIG9mIFBvbHlsaW5lIG9uIGN1cnJlbnQgc2VnbWVudFxyXG4gICAgICAgICAgICB2YXIgc2VnbWVudFBlcmNlbnQgPSByZXN0IC8gY3VycmVudFNlZ21lbnRMZW5ndGg7XHJcblxyXG4gICAgICAgICAgICB2YXIgWHAgPSBzZWdtZW50UGVyY2VudCAqICh0aGlzLnR1cm5pbmdQb2ludHNbaisxXS54IC0gdGhpcy50dXJuaW5nUG9pbnRzW2pdLngpICsgdGhpcy50dXJuaW5nUG9pbnRzW2pdLng7XHJcbiAgICAgICAgICAgIHZhciBZcCA9IHNlZ21lbnRQZXJjZW50ICogKHRoaXMudHVybmluZ1BvaW50c1tqKzFdLnkgLSB0aGlzLnR1cm5pbmdQb2ludHNbal0ueSkgKyB0aGlzLnR1cm5pbmdQb2ludHNbal0ueTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBbWHAsIFlwXTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBmaW5kIHRvdGFsIGRpc3RhbmNlXHJcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFtkZXNjcmlwdGlvbl1cclxuICAgICAqL1xyXG4gICAgQ29ubmVjdG9yLnByb3RvdHlwZS5nZXRMZW5ndGggPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgLy9maW5kIHRvdGFsIGRpc3RhbmNlXHJcbiAgICAgICAgdmFyIGRpc3RhbmNlID0gMDtcclxuICAgICAgICBmb3IodmFyIGk9MDsgaTx0aGlzLnR1cm5pbmdQb2ludHMubGVuZ3RoLTE7IGkrKyl7XHJcbiAgICAgICAgICAgIGRpc3RhbmNlICs9IFV0aWwuZ2V0TGVuZ3RoKHRoaXMudHVybmluZ1BvaW50c1tpXSwgdGhpcy50dXJuaW5nUG9pbnRzW2krMV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZGlzdGFuY2U7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICog6L2sSlNPTuWvueixoVxyXG4gICAgICogQHJldHVybiB7W3R5cGVdfSBbZGVzY3JpcHRpb25dXHJcbiAgICAgKi9cclxuICAgIENvbm5lY3Rvci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgICAgIHRoaXMubW9kZWwuc2V0KFwicmVzb3VyY2VJZFwiLCB0aGlzLnJlc291cmNlSWQpO1xyXG4gICAgICAgIHRoaXMubW9kZWwuc2V0KFwicHJvcGVydGllcy50eXBlXCIsIDE0KTtcclxuXHJcbiAgICAgICAgdGhpcy5tb2RlbC5zZXQoXCJib3VuZHMudXBwZXJMZWZ0LnhcIiwgdGhpcy5wb3NpdGlvblswXSk7XHJcbiAgICAgICAgdGhpcy5tb2RlbC5zZXQoXCJib3VuZHMudXBwZXJMZWZ0LnlcIiwgdGhpcy5wb3NpdGlvblsxXSk7XHJcbiAgICAgICAgdGhpcy5tb2RlbC5zZXQoXCJib3VuZHMubG93ZXJSaWdodC54XCIsIHRoaXMucG9zaXRpb25bMF0gKyB0aGlzLmdldEJvdW5kaW5nUmVjdCgpLndpZHRoKTtcclxuICAgICAgICB0aGlzLm1vZGVsLnNldChcImJvdW5kcy5sb3dlclJpZ2h0LnlcIiwgdGhpcy5wb3NpdGlvblsxXSArIHRoaXMuZ2V0Qm91bmRpbmdSZWN0KCkuaGVpZ2h0KTtcclxuICAgICAgICB0aGlzLm1vZGVsLnNldChcInN0eWxlLnNQb3NcIiwgdGhpcy5zUG9zKTtcclxuICAgICAgICB0aGlzLm1vZGVsLnNldChcInN0eWxlLmVQb3NcIiwgdGhpcy5lUG9zKTtcclxuICAgICAgICB0aGlzLm1vZGVsLnNldChcImRvY2tlcnNcIix0aGlzLnR1cm5pbmdQb2ludHMpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLm1vZGVsLm9wdGlvbjtcclxuICAgIH07XHJcblxyXG4gICAgIC8qKlxyXG4gICAgICogcmVmcmVzaE1vZGVsXHJcbiAgICAgKiBAcmV0dXJuIHtbdHlwZV19IFtkZXNjcmlwdGlvbl1cclxuICAgICAqL1xyXG4gICAgQ29ubmVjdG9yLnByb3RvdHlwZS5yZWZyZXNoTW9kZWwgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB0aGlzLm1vZGVsLnNldChcIm9wdGlvbnMuZG9ja2Vyc1wiLHRoaXMudHVybmluZ1BvaW50cyk7XHJcbiAgICAgICAgdmFyIGljb25zID0gW107XHJcbiAgICAgICAgZm9yKHZhciBpID0gMDtpIDwgdGhpcy5pY29ucy5sZW5ndGg7aSsrKXtcclxuICAgICAgICAgICAgdmFyIGljb25Ob2RlID0gdGhpcy5pY29uc1tpXTtcclxuICAgICAgICAgICAgdmFyIG9wdGlvbiA9IFtpY29uTm9kZS5rZXkse1xyXG4gICAgICAgICAgICAgICAgaWNvbjppY29uTm9kZS5zdHlsZS5pbWFnZSxcclxuICAgICAgICAgICAgICAgIHdpZHRoOiBpY29uTm9kZS5zdHlsZS53aWR0aCxcclxuICAgICAgICAgICAgICAgIGhlaWdodDogaWNvbk5vZGUuc3R5bGUuaGVpZ2h0XHJcbiAgICAgICAgICAgIH1dO1xyXG4gICAgICAgICAgICBpY29ucy5wdXNoKG9wdGlvbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMubW9kZWwuc2V0KFwiaWNvbnNcIixpY29ucyk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICog6LCD5pW05puy57q/55qE5b2i54q2XHJcbiAgICAgKiBAcGFyYW0gIHthcnJheX0gcG9pbnRzIOeCueaVsOe7hFxyXG4gICAgICogQHJldHVybiB7dm9pZH1cclxuICAgICAqL1xyXG4gICAgQ29ubmVjdG9yLnByb3RvdHlwZS5tb2RpZnlDdXJ2ZSA9IGZ1bmN0aW9uKHBvaW50cykge1xyXG4gICAgICAgIHZhciBzb2wgPSB0aGlzLmdldEN1cnZlUG9pbnQocG9pbnRzKTtcclxuXHJcbiAgICAgICAgLy8gMS4g5aaC5p6c5puy57q/55qE5pWw6YePIOavlOaVsOmHj+eahOS4reaVsOmHj+imgeWwkSDliJnliKDpmaTlpJrkvZnnmoTnur/mrrVcclxuICAgICAgICB2YXIgd2lsbERlbEN1cnZlcyA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIGogPSBzb2wubGVuZ3RoLCBjbnRDdXJ2ZSA9IHRoaXMuZ3JvdXBDdXJ2ZS5jaGlsZENvdW50KCk7IGogPCBjbnRDdXJ2ZSA7IGorKykge1xyXG4gICAgICAgICAgICB3aWxsRGVsQ3VydmVzLnB1c2godGhpcy5ncm91cEN1cnZlLmNoaWxkQXQoaikpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB6clV0aWwuZWFjaCh3aWxsRGVsQ3VydmVzLCBmdW5jdGlvbihjdXJ2ZSkge1xyXG4gICAgICAgICAgICB0aGlzLmdyb3VwQ3VydmUucmVtb3ZlKGN1cnZlKTtcclxuICAgICAgICB9LCB0aGlzKTtcclxuICAgICAgICAvLyAyLiDpgY3ljobmm7Lnur8gICDlpoLmnpzlrZjlnKjliJnnm7TmjqXorr7nva7lvaLnirbvvIzlkKbliJnliJvlu7pcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNvbC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgbGluZSA9IHRoaXMuZ3JvdXBDdXJ2ZS5jaGlsZEF0KGkpO1xyXG4gICAgICAgICAgICBpZiAobGluZSkge1xyXG4gICAgICAgICAgICAgICAgbGluZS5hdHRyKCdzaGFwZScsIHNvbFtpXSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY3VyZSA9IG5ldyBncmFwaGljLkJlemllckN1cnZlKHtcclxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogdGhpcy5vcHRpb25zLnBvc2l0aW9uLFxyXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlOiB0aGlzLm9wdGlvbnMuc3R5bGUsXHJcbiAgICAgICAgICAgICAgICAgICAgc2hhcGU6IHNvbFtpXSxcclxuICAgICAgICAgICAgICAgICAgICB6OiB0aGlzLm9wdGlvbnMuelxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmdyb3VwQ3VydmUuYWRkKGN1cmUpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jcmVhdGVIb3ZlclN0eWxlKGN1cmUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDmoLnmja7kvKDlhaXnmoTngrnmlbDnu4TorqHnrpfmm7Lnur/nmoTngrlcclxuICAgICAqIEBwYXJhbSAge2FycmF5fSBQIOeCueaVsOe7hFxyXG4gICAgICogQHJldHVybiB7b2JqZWN0fSAgICAgICAg5puy57q/55qE54K55pWw57uEXHJcbiAgICAgKi9cclxuICAgIENvbm5lY3Rvci5wcm90b3R5cGUuZ2V0Q3VydmVQb2ludCA9IGZ1bmN0aW9uKFApIHtcclxuICAgICAgICB2YXIgbiA9IFAubGVuZ3RoO1xyXG4gICAgICAgIHZhciBzb2wgPSBbXTtcclxuICAgICAgICBpZiAobiA9PT0gMykge1xyXG4gICAgICAgICAgICBzb2wucHVzaCh7eDE6IFBbMF0ueCxcclxuICAgICAgICAgICAgICAgICAgIHkxOiBQWzBdLnksXHJcbiAgICAgICAgICAgICAgICAgICBjcHgxOiBQWzFdLngsXHJcbiAgICAgICAgICAgICAgICAgICBjcHkxOiBQWzFdLnksXHJcbiAgICAgICAgICAgICAgICAgICB4MjogUFsyXS54LFxyXG4gICAgICAgICAgICAgICAgICAgeTI6IFBbMl0ueVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiBzb2w7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKG4gPT09IDQpIHtcclxuICAgICAgICAgICAgc29sLnB1c2goe3gxOiBQWzBdLngsXHJcbiAgICAgICAgICAgICAgICAgICB5MTogUFswXS55LFxyXG4gICAgICAgICAgICAgICAgICAgY3B4MTogUFsxXS54LFxyXG4gICAgICAgICAgICAgICAgICAgY3B5MTogUFsxXS55LFxyXG4gICAgICAgICAgICAgICAgICAgY3B4MjogUFsyXS54LFxyXG4gICAgICAgICAgICAgICAgICAgY3B5MjogUFsyXS55LFxyXG4gICAgICAgICAgICAgICAgICAgeDI6IFBbM10ueCxcclxuICAgICAgICAgICAgICAgICAgIHkyOiBQWzNdLnlcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gc29sO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyoqQ29tcHV0ZXMgZmFjdG9yaWFsXHJcbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IGsgdGhlIG51bWJlclxyXG4gICAgICAgICAqICovXHJcbiAgICAgICAgZnVuY3Rpb24gZmFjdChrKXtcclxuICAgICAgICAgICAgaWYoaz09PTAgfHwgaz09PTEpe1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZXtcclxuICAgICAgICAgICAgICAgIHJldHVybiBrICogZmFjdChrLTEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKipDb21wdXRlcyBCZXJuc3RhaW4qL1xyXG4gICAgICAgIGZ1bmN0aW9uIEIoaSxuLHUpe1xyXG4gICAgICAgICAgICByZXR1cm4gZmFjdChuKSAvIChmYWN0KGkpICogZmFjdChuLWkpKSogTWF0aC5wb3codSwgaSkgKiBNYXRoLnBvdygxLXUsIG4taSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKipDb21wdXRlcyB0aGUgc3VtIGJldHdlZW4gdHdvIHBvaW50XHJcbiAgICAgICAgICpAcGFyYW0gcDEgLSB7UG9pbnR9XHJcbiAgICAgICAgICpAcGFyYW0gcDIgLSB7UG9pbnR9XHJcbiAgICAgICAgICpAcmV0dXJuIHtQb2ludH0gdGhlIHN1bSBvZiBpbml0aWFsIHBvaW50c1xyXG4gICAgICAgICAqKi9cclxuICAgICAgICBmdW5jdGlvbiBzdW0ocDEsIHAyKXtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludChwMS54ICsgcDIueCwgcDEueSArIHAyLnkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyoqQ29tcHV0ZXMgdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiBmaXJzdCB7UG9pbnR9IGFuZCBzZWNvbmQge1BvaW50fVxyXG4gICAgICAgICAqQHBhcmFtIHAxIC0ge1BvaW50fVxyXG4gICAgICAgICAqQHBhcmFtIHAyIC0ge1BvaW50fVxyXG4gICAgICAgICAqQHJldHVybiB7UG9pbnR9IHRoZSBzdW0gb2YgaW5pdGlhbCBwb2ludHNcclxuICAgICAgICAgKiovXHJcbiAgICAgICAgZnVuY3Rpb24gbWludXMocDEsIHAyKXtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludChwMS54IC0gcDIueCwgcDEueSAtIHAyLnkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyoqQ29tcHV0ZXMgdGhlIGRpdmlzaW9uIG9mIGEge1BvaW50fSBieSBhIG51bWJlclxyXG4gICAgICAgICAqQHBhcmFtIHAgLSB7UG9pbnR9XHJcbiAgICAgICAgICpAcGFyYW0gbnIgLSB7TnVtYmVyfVxyXG4gICAgICAgICAqQHJldHVybiB7UG9pbnR9XHJcbiAgICAgICAgICoqL1xyXG4gICAgICAgIGZ1bmN0aW9uIGRpdmlkZShwLCBucil7XHJcbiAgICAgICAgICAgIGlmKG5yID09IDApe1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgXCJEaXZpc2lvbiBieSB6ZXJvIG5vdCBhbGxvd2VkICh5ZXQgOikgXCIgKyB0aGlzLmNhbGxlZSA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludChwLngvbnIsIHAueS9ucik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKipDb21wdXRlcyB0aGUgbXVsdGlwbGljYXRpb24gb2YgYSB7UG9pbnR9IGJ5IGEgbnVtYmVyXHJcbiAgICAgICAgICpAcGFyYW0gcCAtIHtQb2ludH1cclxuICAgICAgICAgKkBwYXJhbSBuciAtIHtOdW1iZXJ9XHJcbiAgICAgICAgICpAcmV0dXJuIHtQb2ludH1cclxuICAgICAgICAgKiovXHJcbiAgICAgICAgZnVuY3Rpb24gbXVsdGlwbHkocCwgbnIpe1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFBvaW50IChwLnggKiBuciwgcC55ICogbnIpO1xyXG4gICAgICAgIH1cclxuXHJcblxyXG5cclxuXHJcbiAgICAgICAgLypcclxuICAgICAgICAgKkkgZG8gbm90IGdldCB3aHkgZmlyc3QgNCBtdXN0IGJlIDAgYW5kIGxhc3QgMyBvZiBzYW1lIHZhbHVlLi4uLi5cclxuICAgICAgICAgKmJ1dCBvdGhlcndpc2Ugd2Ugd2lsbCBnZXQgZGl2aXNpb24gYnkgemVyb1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHZhciBrID0gWzAsMCwwXTtcclxuXHJcbiAgICAgICAgdmFyIGo7XHJcbiAgICAgICAgZm9yKGo9MDtqPD1uLTM7aisrKXtcclxuICAgICAgICAgICAgay5wdXNoKGopO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgay5wdXNoKG4tMywgbi0zKTtcclxuXHJcblxyXG5cclxuICAgICAgICBmb3IoaT0xOyBpPD1uLTM7IGkrKyl7XHJcbiAgICAgICAgICAgIC8vcTEgLSBjb21wdXRlIHN0YXJ0IHBvaW50XHJcbiAgICAgICAgICAgIHZhciBxMSA9IGRpdmlkZSggc3VtKCBtdWx0aXBseShQW2ldLCBrW2krNF0gLSBrW2krMl0pLCBtdWx0aXBseShQW2krMV0sIGtbaSsyXSAtIGtbaSsxXSkgKSwga1tpKzRdIC0ga1tpKzFdKTtcclxuXHJcbiAgICAgICAgICAgIC8vcTAgLSBjb21wdXRlIDFzdCBjb250cm9sbCBwb2ludFxyXG4gICAgICAgICAgICB2YXIgcV8wMSA9IChrW2krM10gLSBrW2krMl0pIC8gKGtbaSszXSAtIGtbaSsxXSk7XHJcbiAgICAgICAgICAgIHZhciBxXzAyID0gZGl2aWRlKCBzdW0oIG11bHRpcGx5KFBbaS0xXSxrW2krM10gLSBrW2krMl0pLCBtdWx0aXBseShQW2ldLCBrW2krMl0gLSBrW2ldKSksIGtbaSszXSAtIGtbaV0pO1xyXG4gICAgICAgICAgICB2YXIgcV8wMyA9IG11bHRpcGx5KHExLCAoIGtbaSsyXSAtIGtbaSsxXSkvIChrW2krM10gLSBrW2krMV0pICk7XHJcbiAgICAgICAgICAgIHZhciBxMCA9IHN1bShtdWx0aXBseShxXzAyLCBxXzAxKSwgcV8wMyk7XHJcblxyXG4gICAgICAgICAgICAvL3EyIC0gY29tcHV0ZSAybmQgY29udHJvbGwgcG9pbnRcclxuICAgICAgICAgICAgdmFyIHEyID0gZGl2aWRlKCBzdW0oIG11bHRpcGx5KFBbaV0sIGtbaSs0XSAtIGtbaSszXSksIG11bHRpcGx5KFBbaSsxXSwga1tpKzNdIC0ga1tpKzFdKSApLCBrW2krNF0gLSBrW2krMV0gKTtcclxuXHJcbiAgICAgICAgICAgIC8vcTMgLSBjb21wdXRlIGVuZCBwb2ludFxyXG4gICAgICAgICAgICB2YXIgcV8zMSA9IChrW2krM10gLSBrW2krMl0pIC8gKGtbaSs0XSAtIGtbaSsyXSk7XHJcbiAgICAgICAgICAgIHZhciBxXzMyID0gZGl2aWRlKCBzdW0oIG11bHRpcGx5KFBbaSsxXSwga1tpKzVdIC0ga1tpKzNdKSwgbXVsdGlwbHkoUFtpKzJdLCBrW2krM10gLSBrW2krMl0pICkgLCBrW2krNV0gLSBrW2krMl0pO1xyXG4gICAgICAgICAgICB2YXIgcV8zMyA9IG11bHRpcGx5KHEyLCAoa1tpKzRdIC0ga1tpKzNdKS8oa1tpKzRdIC0ga1tpKzJdKSApO1xyXG4gICAgICAgICAgICB2YXIgcTMgPSBzdW0obXVsdGlwbHkocV8zMiwgcV8zMSksIHFfMzMpO1xyXG5cclxuICAgICAgICAgICAgLy9zdG9yZSBzb2x1dGlvblxyXG4gICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICBzb2wucHVzaCh7eDE6IHEwLngsXHJcbiAgICAgICAgICAgICAgICAgICB5MTogcTAueSxcclxuICAgICAgICAgICAgICAgICAgIGNweDE6IHExLngsXHJcbiAgICAgICAgICAgICAgICAgICBjcHkxOiBxMS55LFxyXG4gICAgICAgICAgICAgICAgICAgY3B4MjogcTIueCxcclxuICAgICAgICAgICAgICAgICAgIGNweTI6IHEyLnksXHJcbiAgICAgICAgICAgICAgICAgICB4MjogcTMueCxcclxuICAgICAgICAgICAgICAgICAgIHkyOiBxMy55XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBzb2w7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICBVdGlsLmluaGVyaXRzKENvbm5lY3RvcixOb2RlKTtcclxuXHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IENvbm5lY3RvcjtcclxuXHJcblxyXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vbGliL2Zpc2gtdG9wby1jb3JlL2xpYi9zaGFwZXMvQ29ubmVjdG9yLmpzXG4gKiogbW9kdWxlIGlkID0gODlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0Jztcbi8vIFN5bWJvbCBmYWN0b3J5XHJcblxyXG5cclxuICAgIHZhciBncmFwaGljID0gcmVxdWlyZSgnLi4vZ3JhcGhpYycpO1xyXG4gICAgdmFyIEJvdW5kaW5nUmVjdCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvQm91bmRpbmdSZWN0Jyk7XHJcbiAgICAvKipcclxuICAgICAqIFRyaWFuZ2xlIHNoYXBlXHJcbiAgICAgKiBAaW5uZXJcclxuICAgICAqL1xyXG4gICAgdmFyIFRyaWFuZ2xlID0gZ3JhcGhpYy5leHRlbmRTaGFwZSh7XHJcbiAgICAgICAgdHlwZTogJ3RyaWFuZ2xlJyxcclxuICAgICAgICBzaGFwZToge1xyXG4gICAgICAgICAgICBjeDogMCxcclxuICAgICAgICAgICAgY3k6IDAsXHJcbiAgICAgICAgICAgIHdpZHRoOiAwLFxyXG4gICAgICAgICAgICBoZWlnaHQ6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIGJ1aWxkUGF0aDogZnVuY3Rpb24gKHBhdGgsIHNoYXBlKSB7XHJcbiAgICAgICAgICAgIHZhciBjeCA9IHNoYXBlLmN4O1xyXG4gICAgICAgICAgICB2YXIgY3kgPSBzaGFwZS5jeTtcclxuICAgICAgICAgICAgdmFyIHdpZHRoID0gc2hhcGUud2lkdGggLyAyO1xyXG4gICAgICAgICAgICB2YXIgaGVpZ2h0ID0gc2hhcGUuaGVpZ2h0IC8gMjtcclxuICAgICAgICAgICAgcGF0aC5tb3ZlVG8oY3gsIGN5IC0gaGVpZ2h0KTtcclxuICAgICAgICAgICAgcGF0aC5saW5lVG8oY3ggKyB3aWR0aCwgY3kgKyBoZWlnaHQpO1xyXG4gICAgICAgICAgICBwYXRoLmxpbmVUbyhjeCAtIHdpZHRoLCBjeSArIGhlaWdodCk7XHJcbiAgICAgICAgICAgIHBhdGguY2xvc2VQYXRoKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICAvKipcclxuICAgICAqIERpYW1vbmQgc2hhcGVcclxuICAgICAqIEBpbm5lclxyXG4gICAgICovXHJcbiAgICB2YXIgRGlhbW9uZCA9IGdyYXBoaWMuZXh0ZW5kU2hhcGUoe1xyXG4gICAgICAgIHR5cGU6ICdkaWFtb25kJyxcclxuICAgICAgICBzaGFwZToge1xyXG4gICAgICAgICAgICBjeDogMCxcclxuICAgICAgICAgICAgY3k6IDAsXHJcbiAgICAgICAgICAgIHdpZHRoOiAwLFxyXG4gICAgICAgICAgICBoZWlnaHQ6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIGJ1aWxkUGF0aDogZnVuY3Rpb24gKHBhdGgsIHNoYXBlKSB7XHJcbiAgICAgICAgICAgIHZhciBjeCA9IHNoYXBlLmN4O1xyXG4gICAgICAgICAgICB2YXIgY3kgPSBzaGFwZS5jeTtcclxuICAgICAgICAgICAgdmFyIHdpZHRoID0gc2hhcGUud2lkdGggLyAyO1xyXG4gICAgICAgICAgICB2YXIgaGVpZ2h0ID0gc2hhcGUuaGVpZ2h0IC8gMjtcclxuICAgICAgICAgICAgcGF0aC5tb3ZlVG8oY3gsIGN5IC0gaGVpZ2h0KTtcclxuICAgICAgICAgICAgcGF0aC5saW5lVG8oY3ggKyB3aWR0aCwgY3kpO1xyXG4gICAgICAgICAgICBwYXRoLmxpbmVUbyhjeCwgY3kgKyBoZWlnaHQpO1xyXG4gICAgICAgICAgICBwYXRoLmxpbmVUbyhjeCAtIHdpZHRoLCBjeSk7XHJcbiAgICAgICAgICAgIHBhdGguY2xvc2VQYXRoKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQaW4gc2hhcGVcclxuICAgICAqIEBpbm5lclxyXG4gICAgICovXHJcbiAgICB2YXIgUGluID0gZ3JhcGhpYy5leHRlbmRTaGFwZSh7XHJcbiAgICAgICAgdHlwZTogJ3BpbicsXHJcbiAgICAgICAgc2hhcGU6IHtcclxuICAgICAgICAgICAgLy8geCwgeSBvbiB0aGUgY3VzcFxyXG4gICAgICAgICAgICB4OiAwLFxyXG4gICAgICAgICAgICB5OiAwLFxyXG4gICAgICAgICAgICB3aWR0aDogMCxcclxuICAgICAgICAgICAgaGVpZ2h0OiAwXHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgYnVpbGRQYXRoOiBmdW5jdGlvbiAocGF0aCwgc2hhcGUpIHtcclxuICAgICAgICAgICAgdmFyIHggPSBzaGFwZS54O1xyXG4gICAgICAgICAgICB2YXIgeSA9IHNoYXBlLnk7XHJcbiAgICAgICAgICAgIHZhciB3ID0gc2hhcGUud2lkdGggLyA1ICogMztcclxuICAgICAgICAgICAgLy8gSGVpZ2h0IG11c3QgYmUgbGFyZ2VyIHRoYW4gd2lkdGhcclxuICAgICAgICAgICAgdmFyIGggPSBNYXRoLm1heCh3LCBzaGFwZS5oZWlnaHQpO1xyXG4gICAgICAgICAgICB2YXIgciA9IHcgLyAyO1xyXG5cclxuICAgICAgICAgICAgLy8gRGlzdCBvbiB5IHdpdGggdGFuZ2VudCBwb2ludCBhbmQgY2lyY2xlIGNlbnRlclxyXG4gICAgICAgICAgICB2YXIgZHkgPSByICogciAvIChoIC0gcik7XHJcbiAgICAgICAgICAgIHZhciBjeSA9IHkgLSBoICsgciArIGR5O1xyXG4gICAgICAgICAgICB2YXIgYW5nbGUgPSBNYXRoLmFzaW4oZHkgLyByKTtcclxuICAgICAgICAgICAgLy8gRGlzdCBvbiB4IHdpdGggdGFuZ2VudCBwb2ludCBhbmQgY2lyY2xlIGNlbnRlclxyXG4gICAgICAgICAgICB2YXIgZHggPSBNYXRoLmNvcyhhbmdsZSkgKiByO1xyXG5cclxuICAgICAgICAgICAgdmFyIHRhblggPSBNYXRoLnNpbihhbmdsZSk7XHJcbiAgICAgICAgICAgIHZhciB0YW5ZID0gTWF0aC5jb3MoYW5nbGUpO1xyXG5cclxuICAgICAgICAgICAgcGF0aC5hcmMoXHJcbiAgICAgICAgICAgICAgICB4LCBjeSwgcixcclxuICAgICAgICAgICAgICAgIE1hdGguUEkgLSBhbmdsZSxcclxuICAgICAgICAgICAgICAgIE1hdGguUEkgKiAyICsgYW5nbGVcclxuICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgIHZhciBjcExlbiA9IHIgKiAwLjY7XHJcbiAgICAgICAgICAgIHZhciBjcExlbjIgPSByICogMC43O1xyXG4gICAgICAgICAgICBwYXRoLmJlemllckN1cnZlVG8oXHJcbiAgICAgICAgICAgICAgICB4ICsgZHggLSB0YW5YICogY3BMZW4sIGN5ICsgZHkgKyB0YW5ZICogY3BMZW4sXHJcbiAgICAgICAgICAgICAgICB4LCB5IC0gY3BMZW4yLFxyXG4gICAgICAgICAgICAgICAgeCwgeVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICBwYXRoLmJlemllckN1cnZlVG8oXHJcbiAgICAgICAgICAgICAgICB4LCB5IC0gY3BMZW4yLFxyXG4gICAgICAgICAgICAgICAgeCAtIGR4ICsgdGFuWCAqIGNwTGVuLCBjeSArIGR5ICsgdGFuWSAqIGNwTGVuLFxyXG4gICAgICAgICAgICAgICAgeCAtIGR4LCBjeSArIGR5XHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIHBhdGguY2xvc2VQYXRoKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBcnJvdyBzaGFwZVxyXG4gICAgICogQGlubmVyXHJcbiAgICAgKi9cclxuICAgIHZhciBBcnJvdyA9IGdyYXBoaWMuZXh0ZW5kU2hhcGUoe1xyXG5cclxuICAgICAgICB0eXBlOiAnYXJyb3cnLFxyXG5cclxuICAgICAgICBzaGFwZToge1xyXG4gICAgICAgICAgICB4OiAwLFxyXG4gICAgICAgICAgICB5OiAwLFxyXG4gICAgICAgICAgICB3aWR0aDogMCxcclxuICAgICAgICAgICAgaGVpZ2h0OiAwXHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgYnVpbGRQYXRoOiBmdW5jdGlvbiAoY3R4LCBzaGFwZSkge1xyXG4gICAgICAgICAgICB2YXIgaGVpZ2h0ID0gc2hhcGUuaGVpZ2h0O1xyXG4gICAgICAgICAgICB2YXIgd2lkdGggPSBzaGFwZS53aWR0aDtcclxuICAgICAgICAgICAgdmFyIHggPSBzaGFwZS54O1xyXG4gICAgICAgICAgICB2YXIgeSA9IHNoYXBlLnk7XHJcbiAgICAgICAgICAgIHZhciBkeCA9IHdpZHRoIC8gMyAqIDI7XHJcbiAgICAgICAgICAgIGN0eC5tb3ZlVG8oeCwgeSk7XHJcbiAgICAgICAgICAgIGN0eC5saW5lVG8oeCArIGR4LCB5ICsgaGVpZ2h0KTtcclxuICAgICAgICAgICAgY3R4LmxpbmVUbyh4LCB5ICsgaGVpZ2h0IC8gNCAqIDMpO1xyXG4gICAgICAgICAgICBjdHgubGluZVRvKHggLSBkeCwgeSArIGhlaWdodCk7XHJcbiAgICAgICAgICAgIGN0eC5saW5lVG8oeCwgeSk7XHJcbiAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIE1hcCBvZiBwYXRoIGNvbnRydWN0b3JzXHJcbiAgICAgKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsIG1vZHVsZTp6cmVuZGVyL2dyYXBoaWMvUGF0aD59XHJcbiAgICAgKi9cclxuICAgIHZhciBzeW1ib2xDdG9ycyA9IHtcclxuICAgICAgICBsaW5lOiBncmFwaGljLkxpbmUsXHJcblxyXG4gICAgICAgIHJlY3Q6IGdyYXBoaWMuUmVjdCxcclxuXHJcbiAgICAgICAgcm91bmRSZWN0OiBncmFwaGljLlJlY3QsXHJcblxyXG4gICAgICAgIHNxdWFyZTogZ3JhcGhpYy5SZWN0LFxyXG5cclxuICAgICAgICBjaXJjbGU6IGdyYXBoaWMuQ2lyY2xlLFxyXG5cclxuICAgICAgICBkaWFtb25kOiBEaWFtb25kLFxyXG5cclxuICAgICAgICBwaW46IFBpbixcclxuXHJcbiAgICAgICAgYXJyb3c6IEFycm93LFxyXG5cclxuICAgICAgICB0cmlhbmdsZTogVHJpYW5nbGVcclxuICAgIH07XHJcblxyXG4gICAgdmFyIHN5bWJvbFNoYXBlTWFrZXJzID0ge1xyXG5cclxuICAgICAgICBsaW5lOiBmdW5jdGlvbiAoeCwgeSwgdywgaCwgc2hhcGUpIHtcclxuICAgICAgICAgICAgLy8gRklYTUVcclxuICAgICAgICAgICAgc2hhcGUueDEgPSB4O1xyXG4gICAgICAgICAgICBzaGFwZS55MSA9IHkgKyBoIC8gMjtcclxuICAgICAgICAgICAgc2hhcGUueDIgPSB4ICsgdztcclxuICAgICAgICAgICAgc2hhcGUueTIgPSB5ICsgaCAvIDI7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgcmVjdDogZnVuY3Rpb24gKHgsIHksIHcsIGgsIHNoYXBlKSB7XHJcbiAgICAgICAgICAgIHNoYXBlLnggPSB4O1xyXG4gICAgICAgICAgICBzaGFwZS55ID0geTtcclxuICAgICAgICAgICAgc2hhcGUud2lkdGggPSB3O1xyXG4gICAgICAgICAgICBzaGFwZS5oZWlnaHQgPSBoO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHJvdW5kUmVjdDogZnVuY3Rpb24gKHgsIHksIHcsIGgsIHNoYXBlKSB7XHJcbiAgICAgICAgICAgIHNoYXBlLnggPSB4O1xyXG4gICAgICAgICAgICBzaGFwZS55ID0geTtcclxuICAgICAgICAgICAgc2hhcGUud2lkdGggPSB3O1xyXG4gICAgICAgICAgICBzaGFwZS5oZWlnaHQgPSBoO1xyXG4gICAgICAgICAgICBzaGFwZS5yID0gTWF0aC5taW4odywgaCkgLyA0O1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNxdWFyZTogZnVuY3Rpb24gKHgsIHksIHcsIGgsIHNoYXBlKSB7XHJcbiAgICAgICAgICAgIHZhciBzaXplID0gTWF0aC5taW4odywgaCk7XHJcbiAgICAgICAgICAgIHNoYXBlLnggPSB4O1xyXG4gICAgICAgICAgICBzaGFwZS55ID0geTtcclxuICAgICAgICAgICAgc2hhcGUud2lkdGggPSBzaXplO1xyXG4gICAgICAgICAgICBzaGFwZS5oZWlnaHQgPSBzaXplO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGNpcmNsZTogZnVuY3Rpb24gKHgsIHksIHcsIGgsIHNoYXBlKSB7XHJcbiAgICAgICAgICAgIC8vIFB1dCBjaXJjbGUgaW4gdGhlIGNlbnRlciBvZiBzcXVhcmVcclxuICAgICAgICAgICAgc2hhcGUuY3ggPSB4ICsgdyAvIDI7XHJcbiAgICAgICAgICAgIHNoYXBlLmN5ID0geSArIGggLyAyO1xyXG4gICAgICAgICAgICBzaGFwZS5yID0gTWF0aC5taW4odywgaCkgLyAyO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGRpYW1vbmQ6IGZ1bmN0aW9uICh4LCB5LCB3LCBoLCBzaGFwZSkge1xyXG4gICAgICAgICAgICBzaGFwZS5jeCA9IHggKyB3IC8gMjtcclxuICAgICAgICAgICAgc2hhcGUuY3kgPSB5ICsgaCAvIDI7XHJcbiAgICAgICAgICAgIHNoYXBlLndpZHRoID0gdztcclxuICAgICAgICAgICAgc2hhcGUuaGVpZ2h0ID0gaDtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBwaW46IGZ1bmN0aW9uICh4LCB5LCB3LCBoLCBzaGFwZSkge1xyXG4gICAgICAgICAgICBzaGFwZS54ID0geCArIHcgLyAyO1xyXG4gICAgICAgICAgICBzaGFwZS55ID0geSArIGggLyAyO1xyXG4gICAgICAgICAgICBzaGFwZS53aWR0aCA9IHc7XHJcbiAgICAgICAgICAgIHNoYXBlLmhlaWdodCA9IGg7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgYXJyb3c6IGZ1bmN0aW9uICh4LCB5LCB3LCBoLCBzaGFwZSkge1xyXG4gICAgICAgICAgICBzaGFwZS54ID0geCArIHcgLyAyO1xyXG4gICAgICAgICAgICBzaGFwZS55ID0geSArIGggLyAyO1xyXG4gICAgICAgICAgICBzaGFwZS53aWR0aCA9IHc7XHJcbiAgICAgICAgICAgIHNoYXBlLmhlaWdodCA9IGg7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgdHJpYW5nbGU6IGZ1bmN0aW9uICh4LCB5LCB3LCBoLCBzaGFwZSkge1xyXG4gICAgICAgICAgICBzaGFwZS5jeCA9IHggKyB3IC8gMjtcclxuICAgICAgICAgICAgc2hhcGUuY3kgPSB5ICsgaCAvIDI7XHJcbiAgICAgICAgICAgIHNoYXBlLndpZHRoID0gdztcclxuICAgICAgICAgICAgc2hhcGUuaGVpZ2h0ID0gaDtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHZhciBzeW1ib2xCdWlsZFByb3hpZXMgPSB7fTtcclxuICAgIGZvciAodmFyIG5hbWUgaW4gc3ltYm9sQ3RvcnMpIHtcclxuICAgICAgICBzeW1ib2xCdWlsZFByb3hpZXNbbmFtZV0gPSBuZXcgc3ltYm9sQ3RvcnNbbmFtZV0oKTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgU3ltYm9sID0gZ3JhcGhpYy5leHRlbmRTaGFwZSh7XHJcblxyXG4gICAgICAgIHR5cGU6ICdzeW1ib2wnLFxyXG5cclxuICAgICAgICBzaGFwZToge1xyXG4gICAgICAgICAgICBzeW1ib2xUeXBlOiAnJyxcclxuICAgICAgICAgICAgeDogMCxcclxuICAgICAgICAgICAgeTogMCxcclxuICAgICAgICAgICAgd2lkdGg6IDAsXHJcbiAgICAgICAgICAgIGhlaWdodDogMFxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGJlZm9yZUJydXNoOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBzdHlsZSA9IHRoaXMuc3R5bGU7XHJcbiAgICAgICAgICAgIHZhciBzaGFwZSA9IHRoaXMuc2hhcGU7XHJcbiAgICAgICAgICAgIC8vIEZJWE1FXHJcbiAgICAgICAgICAgIGlmIChzaGFwZS5zeW1ib2xUeXBlID09PSAncGluJyAmJiBzdHlsZS50ZXh0UG9zaXRpb24gPT09ICdpbnNpZGUnKSB7XHJcbiAgICAgICAgICAgICAgICBzdHlsZS50ZXh0UG9zaXRpb24gPSBbJzUwJScsICc0MCUnXTtcclxuICAgICAgICAgICAgICAgIHN0eWxlLnRleHRBbGlnbiA9ICdjZW50ZXInO1xyXG4gICAgICAgICAgICAgICAgc3R5bGUudGV4dFZlcnRpY2FsQWxpZ24gPSAnbWlkZGxlJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGJ1aWxkUGF0aDogZnVuY3Rpb24gKGN0eCwgc2hhcGUpIHtcclxuICAgICAgICAgICAgdmFyIHN5bWJvbFR5cGUgPSBzaGFwZS5zeW1ib2xUeXBlO1xyXG4gICAgICAgICAgICB2YXIgcHJveHlTeW1ib2wgPSBzeW1ib2xCdWlsZFByb3hpZXNbc3ltYm9sVHlwZV07XHJcbiAgICAgICAgICAgIGlmIChzaGFwZS5zeW1ib2xUeXBlICE9PSAnbm9uZScpIHtcclxuICAgICAgICAgICAgICAgIGlmICghcHJveHlTeW1ib2wpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBEZWZhdWx0IHJlY3RcclxuICAgICAgICAgICAgICAgICAgICBzeW1ib2xUeXBlID0gJ3JlY3QnO1xyXG4gICAgICAgICAgICAgICAgICAgIHByb3h5U3ltYm9sID0gc3ltYm9sQnVpbGRQcm94aWVzW3N5bWJvbFR5cGVdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgc3ltYm9sU2hhcGVNYWtlcnNbc3ltYm9sVHlwZV0oXHJcbiAgICAgICAgICAgICAgICAgICAgc2hhcGUueCwgc2hhcGUueSwgc2hhcGUud2lkdGgsIHNoYXBlLmhlaWdodCwgcHJveHlTeW1ib2wuc2hhcGVcclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICBwcm94eVN5bWJvbC5idWlsZFBhdGgoY3R4LCBwcm94eVN5bWJvbC5zaGFwZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBQcm92aWRlIHNldENvbG9yIGhlbHBlciBtZXRob2QgdG8gYXZvaWQgZGV0ZXJtaW5lIGlmIHNldCB0aGUgZmlsbCBvciBzdHJva2Ugb3V0c2lkZVxyXG4gICAgdmFyIHN5bWJvbFBhdGhTZXRDb2xvciA9IGZ1bmN0aW9uIChjb2xvcikge1xyXG4gICAgICAgIGlmICh0aGlzLnR5cGUgIT09ICdpbWFnZScpIHtcclxuICAgICAgICAgICAgdmFyIHN5bWJvbFN0eWxlID0gdGhpcy5zdHlsZTtcclxuICAgICAgICAgICAgdmFyIHN5bWJvbFNoYXBlID0gdGhpcy5zaGFwZTtcclxuICAgICAgICAgICAgaWYgKHN5bWJvbFNoYXBlICYmIHN5bWJvbFNoYXBlLnN5bWJvbFR5cGUgPT09ICdsaW5lJykge1xyXG4gICAgICAgICAgICAgICAgc3ltYm9sU3R5bGUuc3Ryb2tlID0gY29sb3I7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fX2lzRW1wdHlCcnVzaCkge1xyXG4gICAgICAgICAgICAgICAgc3ltYm9sU3R5bGUuc3Ryb2tlID0gY29sb3I7XHJcbiAgICAgICAgICAgICAgICBzeW1ib2xTdHlsZS5maWxsID0gJyNmZmYnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gRklYTUUg5Yik5pat5Zu+5b2i6buY6K6k5piv5aGr5YWF6L+Y5piv5o+P6L6577yM5L2/55SoIG9ubHlTdHJva2UgP1xyXG4gICAgICAgICAgICAgICAgc3ltYm9sU3R5bGUuZmlsbCAmJiAoc3ltYm9sU3R5bGUuZmlsbCA9IGNvbG9yKTtcclxuICAgICAgICAgICAgICAgIHN5bWJvbFN0eWxlLnN0cm9rZSAmJiAoc3ltYm9sU3R5bGUuc3Ryb2tlID0gY29sb3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuZGlydHkoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHZhciBzeW1ib2xVdGlsID0ge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENyZWF0ZSBhIHN5bWJvbCBlbGVtZW50IHdpdGggZ2l2ZW4gc3ltYm9sIGNvbmZpZ3VyYXRpb246IHNoYXBlLCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCBjb2xvclxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzeW1ib2xUeXBlXHJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHhcclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0geVxyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3XHJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGhcclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gelxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb2xvclxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGNyZWF0ZVN5bWJvbDogZnVuY3Rpb24gKHN5bWJvbFR5cGUsIHgsIHksIHcsIGgsIGNvbG9yLCB6KSB7XHJcbiAgICAgICAgICAgIHZhciBpc0VtcHR5ID0gc3ltYm9sVHlwZS5pbmRleE9mKCdlbXB0eScpID09PSAwO1xyXG4gICAgICAgICAgICBpZiAoaXNFbXB0eSkge1xyXG4gICAgICAgICAgICAgICAgc3ltYm9sVHlwZSA9IHN5bWJvbFR5cGUuc3Vic3RyKDUsIDEpLnRvTG93ZXJDYXNlKCkgKyBzeW1ib2xUeXBlLnN1YnN0cig2KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgc3ltYm9sUGF0aDtcclxuXHJcbiAgICAgICAgICAgIGlmIChzeW1ib2xUeXBlLmluZGV4T2YoJ2ltYWdlOi8vJykgPT09IDApIHtcclxuICAgICAgICAgICAgICAgIHN5bWJvbFBhdGggPSBuZXcgZ3JhcGhpYy5JbWFnZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2U6IHN5bWJvbFR5cGUuc2xpY2UoOCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHg6IHgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHk6IHksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiB3LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGhcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIHo6IHpcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHN5bWJvbFR5cGUuaW5kZXhPZigncGF0aDovLycpID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBzeW1ib2xQYXRoID0gZ3JhcGhpYy5tYWtlUGF0aChzeW1ib2xUeXBlLnNsaWNlKDcpLCB7ejogen0sIG5ldyBCb3VuZGluZ1JlY3QoeCwgeSwgdywgaCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgc3ltYm9sUGF0aCA9IG5ldyBTeW1ib2woe1xyXG4gICAgICAgICAgICAgICAgICAgIHNoYXBlOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN5bWJvbFR5cGU6IHN5bWJvbFR5cGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHg6IHgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHk6IHksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiB3LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGhcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIHo6IHpcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBzeW1ib2xQYXRoLl9faXNFbXB0eUJydXNoID0gaXNFbXB0eTtcclxuXHJcbiAgICAgICAgICAgIHN5bWJvbFBhdGguc2V0Q29sb3IgPSBzeW1ib2xQYXRoU2V0Q29sb3I7XHJcblxyXG4gICAgICAgICAgICBzeW1ib2xQYXRoLnNldENvbG9yKGNvbG9yKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBzeW1ib2xQYXRoO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBzeW1ib2xVdGlsO1xyXG5cclxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2xpYi9maXNoLXRvcG8tY29yZS9saWIvc2hhcGVzL1N5bWJvbC5qc1xuICoqIG1vZHVsZSBpZCA9IDkwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcclxuICog55S75Y+l5p+EXHJcbiAqIEBhdXRob3Igd2FuZy54aWFvaHVcclxuICovXHJcblxyXG4gICAgdmFyIGdyYXBoaWMgPSByZXF1aXJlKFwiLi4vZ3JhcGhpYy5qc1wiKTtcclxuICAgIHZhciBVdGlsID0gcmVxdWlyZShcIi4uL3V0aWwuanNcIik7XHJcbiAgICBmdW5jdGlvbiBIYW5kbGUodHlwZSwgeCwgeSwgY29ubmVjdG9yKXtcclxuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xyXG5cclxuICAgICAgICB0aGlzLnggPSB4O1xyXG5cclxuICAgICAgICB0aGlzLnkgPSB5O1xyXG5cclxuICAgICAgICB0aGlzLnZpc2libGUgPSB0cnVlO1xyXG5cclxuICAgICAgICB0aGlzLmNvbm5lY3RvciA9IGNvbm5lY3RvcjtcclxuXHJcbiAgICAgICAgdGhpcy5oYW5kbGVTaGFwZSA9IG5ldyBncmFwaGljLkNpcmNsZSh7XHJcbiAgICAgICAgICAgIHNoYXBlOiB7XHJcbiAgICAgICAgICAgICAgICBjeDogeCxcclxuICAgICAgICAgICAgICAgIGN5OiB5LFxyXG4gICAgICAgICAgICAgICAgcjogSGFuZGxlLlJBRElVU1xyXG4gICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgIGZpbGw6IFwicmdiKDAsMjU1LDApXCIsXHJcbiAgICAgICAgICAgICAgICBzdHJva2U6XCJyZ2IoMCwwLDApXCJcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgeiA6IGNvbm5lY3Rvci5vcHRpb25zLnogKyAyLCAgLy/oioLngrla5Li6MSDnur/mrrXkuLowO1xyXG4gICAgICAgICAgICBkcmFnZ2FibGU6dHJ1ZVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5oYW5kbGVTaGFwZS5vbihcImRyYWdcIiwgZnVuY3Rpb24oZSkge1xyXG4gICAgICAgICAgICB0aGF0LmFjdGlvbkNvbm5lY3RvcihlLm9mZnNldFgsZS5vZmZzZXRZKTtcclxuICAgICAgICB9KTtcclxuICAgICAgIC8vIHJldHVybiB0aGlzLmNpcmNsZTtcclxuICAgIH1cclxuXHJcbiAgICBIYW5kbGUuUkFESVVTID0gNDtcclxuXHJcbiAgICBIYW5kbGUucHJvdG90eXBlID0ge1xyXG5cclxuICAgICAgICBjb25zdHJ1Y3RvciA6IEhhbmRsZSxcclxuXHJcbiAgICAgICAgZXF1YWxzIDogZnVuY3Rpb24oYW5vdGhlckhhbmRsZSl7XHJcbiAgICAgICAgICAgIGlmKCFhbm90aGVySGFuZGxlIGluc3RhbmNlb2YgSGFuZGxlKXtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudHlwZSA9PSBhbm90aGVySGFuZGxlLnR5cGVcclxuICAgICAgICAgICAgJiYgdGhpcy54ID09IGFub3RoZXJIYW5kbGUueFxyXG4gICAgICAgICAgICAmJiB0aGlzLnkgPT0gYW5vdGhlckhhbmRsZS55XHJcbiAgICAgICAgICAgICYmIHRoaXMudmlzaWJsZSA9PSBhbm90aGVySGFuZGxlLnZpc2libGU7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICog56e75Yqo5Y+l5p+EXHJcbiAgICAgICAgICogQHBhcmFtICB7W3R5cGVdfSBuZXdYIFtkZXNjcmlwdGlvbl1cclxuICAgICAgICAgKiBAcGFyYW0gIHtbdHlwZV19IG5ld1kgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICAgICAqIEByZXR1cm4ge1t0eXBlXX0gICAgICBbZGVzY3JpcHRpb25dXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgYWN0aW9uQ29ubmVjdG9yOiBmdW5jdGlvbihuZXdYLCBuZXdZKXtcclxuICAgICAgICAgICAgc3dpdGNoKHRoaXMudHlwZSl7XHJcbiAgICAgICAgICAgICAgICBjYXNlICd2JzpcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXg7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8g5om+5Ye65Lik5Liq6L2s5oqY54K577yI5Y+v56e75Yqo5Y+l5p+E5Zyo6L+Z5Lik5Liq6L2s5oqY54K55Lit6Ze077yJXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yKHZhciBpID0gMTsgaSA8IHRoaXMuY29ubmVjdG9yLnR1cm5pbmdQb2ludHMubGVuZ3RoLTE7IGkrKyl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHRoaXMuY29ubmVjdG9yLnR1cm5pbmdQb2ludHNbaS0xXS55ID09IHRoaXMuY29ubmVjdG9yLnR1cm5pbmdQb2ludHNbaV0ueVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgdGhpcy5jb25uZWN0b3IudHVybmluZ1BvaW50c1tpXS55ID09IHRoaXMueVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgTWF0aC5taW4odGhpcy5jb25uZWN0b3IudHVybmluZ1BvaW50c1tpXS54LCB0aGlzLmNvbm5lY3Rvci50dXJuaW5nUG9pbnRzW2ktMV0ueCkgPD0gdGhpcy54XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAmJiBNYXRoLm1heCh0aGlzLmNvbm5lY3Rvci50dXJuaW5nUG9pbnRzW2ldLngsIHRoaXMuY29ubmVjdG9yLnR1cm5pbmdQb2ludHNbaS0xXS54KSA+PSB0aGlzLngpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ID0gaTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB2YXIgZGVsdGFZID0gbmV3WSAtIHRoaXMueTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdHJhbnNsYXRpb25NYXRyaXggPSBVdGlsLnRyYW5zbGF0aW9uTWF0cml4KDAsIGRlbHRhWSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdG9yLnR1cm5pbmdQb2ludHNbaW5kZXgtMV0udHJhbnNmb3JtKHRyYW5zbGF0aW9uTWF0cml4KTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3Rvci50dXJuaW5nUG9pbnRzW2luZGV4XS50cmFuc2Zvcm0odHJhbnNsYXRpb25NYXRyaXgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdG9yLnJlZnJlc2goKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnkgPSBuZXdZOyAgLy/lsIblj6Xmn4TmlrDnmoTkvY3nva7otYvlgLznu5l5XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIGNhc2UgJ2gnOlxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmRleDtcclxuICAgICAgICAgICAgICAgICAgICAvLyDmib7lh7rkuKTkuKrovazmipjngrnvvIjlj6/np7vliqjlj6Xmn4TlnKjov5nkuKTkuKrovazmipjngrnkuK3pl7TvvIlcclxuICAgICAgICAgICAgICAgICAgICBmb3IodmFyIGkgPSAxOyBpIDwgdGhpcy5jb25uZWN0b3IudHVybmluZ1BvaW50cy5sZW5ndGgtMTsgaSsrKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYodGhpcy5jb25uZWN0b3IudHVybmluZ1BvaW50c1tpLTFdLnggPT0gdGhpcy5jb25uZWN0b3IudHVybmluZ1BvaW50c1tpXS54XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAmJiB0aGlzLmNvbm5lY3Rvci50dXJuaW5nUG9pbnRzW2ldLnggPT0gdGhpcy54XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAmJiBNYXRoLm1pbih0aGlzLmNvbm5lY3Rvci50dXJuaW5nUG9pbnRzW2ldLnksIHRoaXMuY29ubmVjdG9yLnR1cm5pbmdQb2ludHNbaS0xXS55KSA8PSB0aGlzLnlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICYmIE1hdGgubWF4KHRoaXMuY29ubmVjdG9yLnR1cm5pbmdQb2ludHNbaV0ueSwgdGhpcy5jb25uZWN0b3IudHVybmluZ1BvaW50c1tpLTFdLnkpID49IHRoaXMueSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ID0gaTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB2YXIgZGVsdGFYID0gbmV3WC10aGlzLng7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRyYW5zbGF0aW9uTWF0cml4ID0gVXRpbC50cmFuc2xhdGlvbk1hdHJpeChkZWx0YVgsIDApO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdG9yLnR1cm5pbmdQb2ludHNbaW5kZXgtMV0udHJhbnNmb3JtKHRyYW5zbGF0aW9uTWF0cml4KTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3Rvci50dXJuaW5nUG9pbnRzW2luZGV4XS50cmFuc2Zvcm0odHJhbnNsYXRpb25NYXRyaXgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdG9yLnJlZnJlc2goKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnggPSBuZXdYOyAvL+WwhuWPpeafhOaWsOeahOS9jee9rui1i+WAvOe7mXhcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAvLy4gdGhpcy5zaGFwZS51cGRhdGVNaWRkbGVUZXh0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIG1vZHVsZS5leHBvcnRzID0gSGFuZGxlO1xyXG5cclxuXHJcblxyXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vbGliL2Zpc2gtdG9wby1jb3JlL2xpYi9zaGFwZXMvSGFuZGxlLmpzXG4gKiogbW9kdWxlIGlkID0gOTFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxyXG4gKiDov57nur/liqjmgIHmlYjmnpxcclxuICogQGF1dGhvciBtaWFvLmN1bnpoaVxyXG4gKi9cclxuXHJcbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XHJcbiAgICB2YXIgdmVjMiA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdmVjdG9yJyk7XHJcbiAgICB2YXIgY3VydmVVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS9jdXJ2ZScpO1xyXG4gICAgdmFyIHN5bWJvbFV0aWwgPSByZXF1aXJlKCcuL1N5bWJvbC5qcycpO1xyXG5cclxuICAgIGZ1bmN0aW9uIEVmZmVjdExpbmUoc3ltYm9sLCBvcHRpb25zLCBncm91cEN1cnZlLCBwb2x5TGluZSkge1xyXG4gICAgICAgIHRoaXMuX2xhc3RGcmFtZSA9IDA7XHJcbiAgICAgICAgdGhpcy5fbGFzdEZyYW1lUGVyY2VudCA9IDA7XHJcbiAgICAgICAgdGhpcy5zeW1ib2wgPSBzeW1ib2w7XHJcbiAgICAgICAgdGhpcy5ncm91cEN1cnZlID0gZ3JvdXBDdXJ2ZTtcclxuICAgICAgICB0aGlzLmluaXRTeW1ib2wob3B0aW9ucywgcG9seUxpbmUpO1xyXG4gICAgfVxyXG4gICAgdmFyIEVmZmVjdExpbmVQcm90byA9IEVmZmVjdExpbmUucHJvdG90eXBlO1xyXG5cclxuICAgIEVmZmVjdExpbmVQcm90by5pbml0U3ltYm9sID0gZnVuY3Rpb24ob3B0aW9ucywgcG9seUxpbmUpIHtcclxuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5zeW1ib2wuejIgPSAxMDA7XHJcbiAgICAgICAgdGhpcy5zeW1ib2wuY3VsbGluZyA9IHRydWU7XHJcbiAgICAgICAgdmFyIHBlcmlvZCA9IG9wdGlvbnMuZWZmZWN0LnBlcmlvZCAqIDEwMDA7XHJcbiAgICAgICAgdGhpcy5zeW1ib2wuX190ID0gMDtcclxuICAgICAgICB0aGlzLnN5bWJvbC5zdG9wQW5pbWF0aW9uKCk7XHJcbiAgICAgICAgaWYgKChvcHRpb25zLnN0eWxlLmxpbmVUeXBlID09IFwiY3VydmVcIikpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuZ3JvdXBDdXJ2ZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGkgPSAwO1xyXG4gICAgICAgICAgICAgICAgcGVyaW9kID0gcGVyaW9kIC8gdGhpcy5ncm91cEN1cnZlLl9jaGlsZHJlbi5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmdyb3VwQ3VydmVBbmltYXRlKHRoaXMuZ3JvdXBDdXJ2ZS5fY2hpbGRyZW5bMF0sIGksIHBlcmlvZCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5zeW1ib2wuYW5pbWF0ZSgnJywgdHJ1ZSlcclxuICAgICAgICAgICAgICAgIC53aGVuKHBlcmlvZCwge1xyXG4gICAgICAgICAgICAgICAgICAgIF9fdDogMVxyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC5kZWxheSgwKVxyXG4gICAgICAgICAgICAgICAgLmR1cmluZyhmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGF0LnVwZGF0ZVN5bWJvbFBvc2l0aW9uUG9seWxpbmUoKTtcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAuc3RhcnQoKTtcclxuICAgICAgICAgICAgdGhpcy5zZXRBbmltYXRpb25Qb2ludHNQb2x5bGluZShwb2x5TGluZS5zaGFwZS5wb2ludHMpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9O1xyXG5cclxuICAgIEVmZmVjdExpbmVQcm90by5ncm91cEN1cnZlQW5pbWF0ZSA9IGZ1bmN0aW9uKGN1cnZlTGluZSwgaSwgcGVyaW9kKSB7XHJcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgICAgIGlmIChjdXJ2ZUxpbmUgPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIGN1cnZlTGluZSA9IHRoaXMuZ3JvdXBDdXJ2ZS5fY2hpbGRyZW5bMF07XHJcbiAgICAgICAgICAgIGkgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcG9pbnRzO1xyXG4gICAgICAgIHZhciBwb3MgPSBjdXJ2ZUxpbmUuc2hhcGU7XHJcbiAgICAgICAgcG9pbnRzID0gW1xyXG4gICAgICAgICAgICBbcG9zLngxLCBwb3MueTFdLFxyXG4gICAgICAgICAgICBbcG9zLngyLCBwb3MueTJdLFxyXG4gICAgICAgICAgICBbcG9zLmNweDEsIHBvcy5jcHkxXSxcclxuICAgICAgICAgICAgW3Bvcy5jcHgyLCBwb3MuY3B5Ml1cclxuICAgICAgICBdO1xyXG4gICAgICAgIHRoaXMuc2V0QW5pbWF0aW9uUG9pbnRzQmV6aWVyQ3VydmUocG9pbnRzKTtcclxuICAgICAgICB0aGlzLnN5bWJvbC5hbmltYXRlKCcnKVxyXG4gICAgICAgICAgICAud2hlbihwZXJpb2QsIHtcclxuICAgICAgICAgICAgICAgIF9fdDogMVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAuZGVsYXkoMClcclxuICAgICAgICAgICAgLmR1cmluZyhmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIHRoYXQudXBkYXRlU3ltYm9sUG9zaXRpb25CZXppZXJDdXJ2ZSgpO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAuZG9uZShmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIHRoYXQuc3ltYm9sLl9fdCA9IDA7XHJcbiAgICAgICAgICAgICAgICB0aGF0Lmdyb3VwQ3VydmVBbmltYXRlKHRoYXQuZ3JvdXBDdXJ2ZS5fY2hpbGRyZW5baSArIDFdLCBpICsgMSwgcGVyaW9kKTtcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgLnN0YXJ0KCk7XHJcblxyXG4gICAgfTtcclxuXHJcblxyXG4gICAgRWZmZWN0TGluZVByb3RvLnNldEFuaW1hdGlvblBvaW50c0JlemllckN1cnZlID0gZnVuY3Rpb24ocG9pbnRzKSB7XHJcbiAgICAgICAgdGhpcy5zeW1ib2wuX19wMSA9IHBvaW50c1swXTtcclxuICAgICAgICB0aGlzLnN5bWJvbC5fX3AyID0gcG9pbnRzWzFdO1xyXG4gICAgICAgIHRoaXMuc3ltYm9sLl9fY3AxID0gcG9pbnRzWzJdIHx8IFtcclxuICAgICAgICAgICAgKHBvaW50c1swXVswXSArIHBvaW50c1sxXVswXSkgLyAyLFxyXG4gICAgICAgICAgICAocG9pbnRzWzBdWzFdICsgcG9pbnRzWzFdWzFdKSAvIDJcclxuICAgICAgICBdO1xyXG4gICAgICAgIHRoaXMuc3ltYm9sLl9fY3AyID0gcG9pbnRzWzNdO1xyXG4gICAgfTtcclxuXHJcbiAgICBFZmZlY3RMaW5lUHJvdG8udXBkYXRlU3ltYm9sUG9zaXRpb25CZXppZXJDdXJ2ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBwMSA9IHRoaXMuc3ltYm9sLl9fcDE7XHJcbiAgICAgICAgdmFyIHAyID0gdGhpcy5zeW1ib2wuX19wMjtcclxuICAgICAgICB2YXIgY3AxID0gdGhpcy5zeW1ib2wuX19jcDE7XHJcbiAgICAgICAgdmFyIGNwMiA9IHRoaXMuc3ltYm9sLl9fY3AyO1xyXG4gICAgICAgIHZhciB0ID0gdGhpcy5zeW1ib2wuX190O1xyXG4gICAgICAgIHZhciBwb3MgPSB0aGlzLnN5bWJvbC5wb3NpdGlvbjtcclxuICAgICAgICB2YXIgdHgsIHR5O1xyXG4gICAgICAgIGlmIChjcDJbMF0gIT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHZhciBjdWJpY0F0ID0gY3VydmVVdGlsLmN1YmljQXQ7XHJcbiAgICAgICAgICAgIHZhciBjdWJpY0Rlcml2YXRpdmVBdCA9IGN1cnZlVXRpbC5jdWJpY0Rlcml2YXRpdmVBdDtcclxuICAgICAgICAgICAgcG9zWzBdID0gY3ViaWNBdChwMVswXSwgY3AxWzBdLCBjcDJbMF0sIHAyWzBdLCB0KTtcclxuICAgICAgICAgICAgcG9zWzFdID0gY3ViaWNBdChwMVsxXSwgY3AxWzFdLCBjcDJbMV0sIHAyWzFdLCB0KTtcclxuICAgICAgICAgICAgLy8gVGFuZ2VudFxyXG4gICAgICAgICAgICB0eCA9IGN1YmljRGVyaXZhdGl2ZUF0KHAxWzBdLCBjcDFbMF0sIGNwMlswXSwgcDJbMF0sIHQpO1xyXG4gICAgICAgICAgICB0eSA9IGN1YmljRGVyaXZhdGl2ZUF0KHAxWzFdLCBjcDFbMV0sIGNwMlsxXSwgcDJbMV0sIHQpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHZhciBxdWFkcmF0aWNBdCA9IGN1cnZlVXRpbC5xdWFkcmF0aWNBdDtcclxuICAgICAgICAgICAgdmFyIHF1YWRyYXRpY0Rlcml2YXRpdmVBdCA9IGN1cnZlVXRpbC5xdWFkcmF0aWNEZXJpdmF0aXZlQXQ7XHJcbiAgICAgICAgICAgIHBvc1swXSA9IHF1YWRyYXRpY0F0KHAxWzBdLCBjcDFbMF0sIHAyWzBdLCB0KTtcclxuICAgICAgICAgICAgcG9zWzFdID0gcXVhZHJhdGljQXQocDFbMV0sIGNwMVsxXSwgcDJbMV0sIHQpO1xyXG4gICAgICAgICAgICAvLyBUYW5nZW50XHJcbiAgICAgICAgICAgIHR4ID0gcXVhZHJhdGljRGVyaXZhdGl2ZUF0KHAxWzBdLCBjcDFbMF0sIHAyWzBdLCB0KTtcclxuICAgICAgICAgICAgdHkgPSBxdWFkcmF0aWNEZXJpdmF0aXZlQXQocDFbMV0sIGNwMVsxXSwgcDJbMV0sIHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnN5bWJvbC5yb3RhdGlvbiA9IC1NYXRoLmF0YW4yKHR5LCB0eCkgLSBNYXRoLlBJIC8gMjtcclxuXHJcbiAgICAgICAgdGhpcy5zeW1ib2wuaWdub3JlID0gZmFsc2U7XHJcbiAgICB9O1xyXG5cclxuICAgIEVmZmVjdExpbmVQcm90by5zZXRBbmltYXRpb25Qb2ludHNQb2x5bGluZSA9IGZ1bmN0aW9uKHBvaW50cykge1xyXG4gICAgICAgIHRoaXMuX3BvaW50cyA9IHBvaW50cztcclxuICAgICAgICB2YXIgYWNjTGVuQXJyID0gWzBdO1xyXG4gICAgICAgIHZhciBsZW4gPSAwO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBwMSA9IHBvaW50c1tpIC0gMV07XHJcbiAgICAgICAgICAgIHZhciBwMiA9IHBvaW50c1tpXTtcclxuICAgICAgICAgICAgbGVuICs9IHZlYzIuZGlzdChwMSwgcDIpO1xyXG4gICAgICAgICAgICBhY2NMZW5BcnIucHVzaChsZW4pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobGVuID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgYWNjTGVuQXJyLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgIGFjY0xlbkFycltqXSAvPSBsZW47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX29mZnNldHMgPSBhY2NMZW5BcnI7XHJcbiAgICAgICAgdGhpcy5fbGVuZ3RoID0gbGVuO1xyXG4gICAgICAgIHRoaXMuc3ltYm9sLl9sYXN0RnJhbWUgPSAwO1xyXG4gICAgICAgIHRoaXMuc3ltYm9sLl9fbGFzdEZyYW1lUGVyY2VudCA9IDA7XHJcbiAgICB9O1xyXG5cclxuICAgIEVmZmVjdExpbmVQcm90by51cGRhdGVTeW1ib2xQb3NpdGlvblBvbHlsaW5lID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIHQgPSB0aGlzLnN5bWJvbC5fX3Q7XHJcbiAgICAgICAgdmFyIHBvaW50cyA9IHRoaXMuX3BvaW50cztcclxuICAgICAgICB2YXIgb2Zmc2V0cyA9IHRoaXMuX29mZnNldHM7XHJcbiAgICAgICAgdmFyIGxlbiA9IHBvaW50cy5sZW5ndGg7XHJcblxyXG4gICAgICAgIGlmICghb2Zmc2V0cykge1xyXG4gICAgICAgICAgICAvLyBIYXMgbGVuZ3RoIDBcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGxhc3RGcmFtZSA9IHRoaXMuX2xhc3RGcmFtZTtcclxuICAgICAgICB2YXIgZnJhbWU7XHJcblxyXG4gICAgICAgIGlmICh0IDwgdGhpcy5fbGFzdEZyYW1lUGVyY2VudCkge1xyXG4gICAgICAgICAgICAvLyBTdGFydCBmcm9tIHRoZSBuZXh0IGZyYW1lXHJcbiAgICAgICAgICAgIC8vIFBFTkRJTkcgc3RhcnQgZnJvbSBsYXN0RnJhbWUgP1xyXG4gICAgICAgICAgICB2YXIgc3RhcnQgPSBNYXRoLm1pbihsYXN0RnJhbWUgKyAxLCBsZW4gLSAxKTtcclxuICAgICAgICAgICAgZm9yIChmcmFtZSA9IHN0YXJ0OyBmcmFtZSA+PSAwOyBmcmFtZS0tKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAob2Zmc2V0c1tmcmFtZV0gPD0gdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIFBFTkRJTkcgcmVhbGx5IG5lZWQgdG8gZG8gdGhpcyA/XHJcbiAgICAgICAgICAgIGZyYW1lID0gTWF0aC5taW4oZnJhbWUsIGxlbiAtIDIpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGZyYW1lID0gbGFzdEZyYW1lOyBmcmFtZSA8IGxlbjsgZnJhbWUrKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKG9mZnNldHNbZnJhbWVdID4gdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZyYW1lID0gTWF0aC5taW4oZnJhbWUgLSAxLCBsZW4gLSAyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmVjMi5sZXJwKFxyXG4gICAgICAgICAgICB0aGlzLnN5bWJvbC5wb3NpdGlvbiwgcG9pbnRzW2ZyYW1lXSwgcG9pbnRzW2ZyYW1lICsgMV0sXHJcbiAgICAgICAgICAgICh0IC0gb2Zmc2V0c1tmcmFtZV0pIC8gKG9mZnNldHNbZnJhbWUgKyAxXSAtIG9mZnNldHNbZnJhbWVdKVxyXG4gICAgICAgICk7XHJcblxyXG4gICAgICAgIHRoaXMuX2xhc3RGcmFtZSA9IGZyYW1lO1xyXG4gICAgICAgIHRoaXMuX2xhc3RGcmFtZVBlcmNlbnQgPSB0O1xyXG4gICAgICAgIHZhciBhbmdsZSA9IC1NYXRoLmF0YW4yKHBvaW50c1tmcmFtZSArIDFdWzFdIC0gcG9pbnRzW2ZyYW1lXVsxXSwgcG9pbnRzW2ZyYW1lICsgMV1bMF0gLSBwb2ludHNbZnJhbWVdWzBdKTtcclxuICAgICAgICB0aGlzLnN5bWJvbC5yb3RhdGlvbiA9IGFuZ2xlIC0gTWF0aC5QSSAvIDI7XHJcbiAgICAgICAgdGhpcy5zeW1ib2wuaWdub3JlID0gZmFsc2U7XHJcbiAgICB9O1xyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBFZmZlY3RMaW5lO1xyXG5cclxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2xpYi9maXNoLXRvcG8tY29yZS9saWIvc2hhcGVzL0VmZmVjdExpbmUuanNcbiAqKiBtb2R1bGUgaWQgPSA5MlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXHJcbiAqIOaOp+WItueCuVxyXG4gKiBAYXV0aG9yIHdhbmcueGlhb2h1XHJcbiAqL1xyXG5cclxuICAgIHZhciBncmFwaGljID0gcmVxdWlyZShcIi4uL2dyYXBoaWMuanNcIik7XHJcbiAgICB2YXIgVXRpbCA9IHJlcXVpcmUoXCIuLi91dGlsLmpzXCIpO1xyXG4gICAgZnVuY3Rpb24gQ29ubmVjdGlvblBvaW50KGNvbm5lY3RvciwgcG9pbnQsIHR5cGUsIG9wdGlvbnMpe1xyXG4gICAgICAgIHRoaXMuY29ubmVjdG9yID0gY29ubmVjdG9yO1xyXG5cclxuICAgICAgICB0aGlzLnBvaW50ID0gcG9pbnQuY2xvbmUoKTtcclxuXHJcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcclxuXHJcbiAgICAgICAgdGhpcy5jb2xvciA9IENvbm5lY3Rpb25Qb2ludC5OT1JNQUxfQ09MT1I7XHJcblxyXG4gICAgICAgIHRoaXMub1R5cGUgPSAnQ29ubmVjdGlvblBvaW50JztcclxuXHJcbiAgICAgICAgdGhpcy5zaGFwZSA9IG5ldyBncmFwaGljLkNpcmNsZSh7XHJcbiAgICAgICAgICAgIHNoYXBlOiB7XHJcbiAgICAgICAgICAgICAgICBjeDogdGhpcy5wb2ludC54LFxyXG4gICAgICAgICAgICAgICAgY3k6IHRoaXMucG9pbnQueSxcclxuICAgICAgICAgICAgICAgIHI6IENvbm5lY3Rpb25Qb2ludC5SQURJVVNcclxuICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgIHN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgICBmaWxsOiB0aGlzLmNvbG9yLFxyXG4gICAgICAgICAgICAgICAgc3Ryb2tlOicjMDAwMDAwJ1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB6IDogb3B0aW9ucy56ICsgMiAgLy/oioLngrla5Li6MSDnur/mrrXkuLowO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuc2hhcGUudHlwZSA9ICB0aGlzLnR5cGU7XHJcblxyXG4gICAgICAgIHRoaXMuc2hhcGUuY29ubmVjdG9yID0gY29ubmVjdG9yO1xyXG4gICAgICAgIC8vcmV0dXJuIHRoaXMuY2lyY2xlO1xyXG4gICAgfVxyXG5cclxuICAgIENvbm5lY3Rpb25Qb2ludC5OT1JNQUxfQ09MT1IgPSBcIiNGRkZGMzNcIjsgLy95ZWxsb3cuXHJcblxyXG4gICAgQ29ubmVjdGlvblBvaW50Lk9WRVJfQ09MT1IgPSBcIiNGRjk5MDBcIjsgLy9vcmFuZ2VcclxuXHJcbiAgICBDb25uZWN0aW9uUG9pbnQuQ09OTkVDVEVEX0NPTE9SID0gXCIjZmYwMDAwXCI7IC8vcmVkXHJcblxyXG4gICAgQ29ubmVjdGlvblBvaW50LlJBRElVUyA9IDQ7XHJcblxyXG4gICAgQ29ubmVjdGlvblBvaW50LlRZUEVfRklHVVJFID0gJ2ZpZ3VyZSc7XHJcblxyXG4gICAgQ29ubmVjdGlvblBvaW50LlRZUEVfQ09OTkVDVE9SID0gJ2Nvbm5lY3Rvcic7XHJcblxyXG4gICAgQ29ubmVjdGlvblBvaW50LnByb3RvdHlwZSA9IHtcclxuXHJcbiAgICAgICAgY29uc3RydWN0b3IgOiBDb25uZWN0aW9uUG9pbnQsXHJcblxyXG4gICAgICAgIGVxdWFscyA6IGZ1bmN0aW9uKGFub3RoZXJDb25uZWN0aW9uUG9pbnQpe1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wb2ludC5lcXVhbHMoYW5vdGhlckNvbm5lY3Rpb25Qb2ludC5wb2ludClcclxuICAgICAgICAgICAgJiYgdGhpcy5jb25uZWN0b3IgPT0gYW5vdGhlckNvbm5lY3Rpb25Qb2ludC5jb25uZWN0b3JcclxuICAgICAgICAgICAgJiYgdGhpcy50eXBlID09IGFub3RoZXJDb25uZWN0aW9uUG9pbnQudHlwZVxyXG4gICAgICAgICAgICAmJiB0aGlzLmNvbG9yID09IGFub3RoZXJDb25uZWN0aW9uUG9pbnQuY29sb3JcclxuICAgICAgICAgICAgJiYgdGhpcy5yYWRpdXMgPT0gYW5vdGhlckNvbm5lY3Rpb25Qb2ludC5yYWRpdXM7XHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICB9O1xyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBDb25uZWN0aW9uUG9pbnQ7XHJcblxyXG5cclxuXHJcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9saWIvZmlzaC10b3BvLWNvcmUvbGliL3NoYXBlcy9Db25uZWN0aW9uUG9pbnQuanNcbiAqKiBtb2R1bGUgaWQgPSA5M1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXHJcbiAqIE5ldHdvcmsgbW9kZWxcclxuICpcclxuICovXHJcblxyXG5cclxuICAgIHZhciBNb2RlbCA9IHJlcXVpcmUoJy4uLy4uLy4uL2Zpc2gtdG9wby1jb3JlL2xpYi9Nb2RlbCcpO1xyXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xyXG5cclxuICAgIHZhciBOZXRXb3JrTGluZU1vZGVsID0gTW9kZWwuZXh0ZW5kKHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAdHlwZSB7T2JqZWN0fVxyXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcclxuICAgICAgICAgKi9cclxuICAgICAgICBkZWZhdWx0T3B0aW9uOiB7XHJcbiAgICAgICAgICAgIGZyb21Cb3VuZHM6IHt4OjAsIHk6MCwgd2lkdGg6MCwgaGVpZ2h0OjB9LCAgLy8gW+W3puS4iuinklgsIOW3puS4iuinklksIOWuveW6piAsIOmrmOW6pl1cclxuICAgICAgICAgICAgdG9Cb3VuZHM6IHt4OjAsIHk6MCwgd2lkdGg6MCwgaGVpZ2h0OjB9LCAgLy8gW+W3puS4iuinklgsIOW3puS4iuinklksIOWuveW6piAsIOmrmOW6pl1cclxuICAgICAgICAgICAgbW9kZGxlWDogMCwgIC8vIOS4remXtOe6v+eahFnlnZDmoIdcclxuICAgICAgICAgICAgbW9kZGxlWTogMCwgIC8vIOS4remXtOe6v+eahFnlnZDmoIdcclxuICAgICAgICAgICAgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgIGxpbmVXaWR0aDoxLCAgLy8g57q/5a695bqmXHJcbiAgICAgICAgICAgICAgICBzdHJva2U6IFwiI0ZGRkZGRlwiLCAgLy/nur/popzoibJcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgaG92ZXJTdHlsZToge1xyXG4gICAgICAgICAgICAgICAgbGluZVdpZHRoOjEsICAvLyDnur/lrr3luqZcclxuICAgICAgICAgICAgICAgIHN0cm9rZTogXCIjRkZGRkZGXCIsICAvL+e6v+minOiJslxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBpc1ZlY3RvcjogZmFsc2VcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBpbml0OiBmdW5jdGlvbiAob3B0aW9uLCBwYXJlbnRNb2RlbCwgZXh0cmFPcHQpIHtcclxuICAgICAgICAgICAgenJVdGlsLm1lcmdlKG9wdGlvbiwgdGhpcy5nZXREZWZhdWx0T3B0aW9uKCkpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGdldERlZmF1bHRPcHRpb246IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLmhhc093blByb3BlcnR5KCdfX2RlZmF1bHRPcHRpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIG9wdExpc3QgPSBbXTtcclxuICAgICAgICAgICAgICAgIHZhciBDbGFzcyA9IHRoaXMuY29uc3RydWN0b3I7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoQ2xhc3MpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgb3B0ID0gQ2xhc3MucHJvdG90eXBlLmRlZmF1bHRPcHRpb247XHJcbiAgICAgICAgICAgICAgICAgICAgb3B0ICYmIG9wdExpc3QucHVzaChvcHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIENsYXNzID0gQ2xhc3Muc3VwZXJDbGFzcztcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgZGVmYXVsdE9wdGlvbiA9IHt9O1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IG9wdExpc3QubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0T3B0aW9uID0genJVdGlsLm1lcmdlKGRlZmF1bHRPcHRpb24sIG9wdExpc3RbaV0sIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5fX2RlZmF1bHRPcHRpb24gPSBkZWZhdWx0T3B0aW9uO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9fZGVmYXVsdE9wdGlvbjtcclxuICAgICAgICB9XHJcblxyXG4gICAgfSk7XHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IE5ldFdvcmtMaW5lTW9kZWw7XHJcblxyXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vbGliL2Zpc2gtdG9wby1uZXR3b3JrL2xpYi9tb2RlbC9OZXRXb3JrTGluZU1vZGVsLmpzXG4gKiogbW9kdWxlIGlkID0gOTRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlxyXG4gICAgdmFyIHV0aWwgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vZmlzaC10b3BvLWNvcmUvbGliL3V0aWwuanNcIik7XHJcbiAgICB2YXIgTmV0d29ya05vZGUgPSByZXF1aXJlKFwiLi4vTmV0d29ya05vZGVcIik7XHJcbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XHJcbiAgICB2YXIgZ3JhcGhpYyA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi9maXNoLXRvcG8tY29yZS9saWIvZ3JhcGhpYy5qc1wiKTtcclxuICAgIHZhciBOZXR3b3JrTW9kZWwgPSByZXF1aXJlKFwiLi4vLi4vbW9kZWwvTmV0d29ya01vZGVsLmpzXCIpO1xyXG4gICAgXHJcbiAgICBmdW5jdGlvbiBTZXJ2ZXJUb3BvTm9kZShtb2RlbCxhcGkpIHtcclxuICAgICAgICBOZXR3b3JrTm9kZS5jYWxsKHRoaXMsIG1vZGVsLCBhcGkpO1xyXG4gICAgICAgIHRoaXMucmFja2tJbmZvID0ge3R5cGU6IC0xLCBuYW1lOiBcIlNlcnZlclRvcG9Ob2RlXCIgfTsgICAgXHJcbiAgICAgICAgdGhpcy5tb2RlbCA9IG1vZGVsO1xyXG4gICAgICAgIHRoaXMucG9ydE5vZGVMaXN0ID0gW107XHJcbiAgICAgICAgdGhpcy5wYXJtRGF0ZSA9IHRoaXMubW9kZWwuZ2V0KFwicGFybURhdGVcIik7XHJcbiAgICAgICAgdGhpcy5yZW5kZXIobW9kZWwsYXBpKTtcclxuICAgIH07XHJcblxyXG4gICAgU2VydmVyVG9wb05vZGUucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uKG1vZGVsLCBhcGkpIHtcclxuICAgICAgICB0aGlzLm1vZGVsID0gbW9kZWw7XHJcbiAgICAgICAgdmFyIF9zaG93VGlwID0gbW9kZWwuZ2V0KFwic2hvd1RpcFwiKTtcclxuICAgICAgICB2YXIgX3dpZHRoID0gbW9kZWwuZ2V0KFwid2lkdGhcIik7XHJcbiAgICAgICAgdmFyIF9oZWlnaHQgPSAyMDtcclxuXHJcbiAgICAgICAgdmFyIF90aXRsZSA9IG5ldyBncmFwaGljLlRleHQoe1xyXG4gICAgICAgICAgICBzdHlsZToge1xyXG4gICAgICAgICAgICAgICAgeDogbW9kZWwuZ2V0KFwid2lkdGhcIikgLyAyIC0gMTAsXHJcbiAgICAgICAgICAgICAgICB5OiAtMjAsXHJcbiAgICAgICAgICAgICAgICB0ZXh0OiBtb2RlbC5nZXQoXCJuYW1lXCIpLFxyXG4gICAgICAgICAgICAgICAgd2lkdGg6IDIwMCxcclxuICAgICAgICAgICAgICAgIGhlaWdodDogX2hlaWdodCxcclxuICAgICAgICAgICAgICAgIGZpbGw6ICcjOEY4QjhBJyxcclxuICAgICAgICAgICAgICAgIHRleHRGb250OiAnMTJweCBNaWNyb3NvZnQgWWFoZWknLFxyXG4gICAgICAgICAgICAgICAgdGV4dEJhc2VsaW5lOiAndG9wJ1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBkcmFnZ2FibGU6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmFkZChfdGl0bGUpO1xyXG5cclxuICAgICAgICB2YXIgc3RhdHVzID0gbW9kZWwuZ2V0KFwic3RhdHVzXCIpO1xyXG4gICAgICAgIHZhciBpbWFnZVVybCA9ICcuLi8uLi8uLi8uLi9maXNoLXRvcG8tbmV0d29yay9zcmMvaW1hZ2VzLycgKyBtb2RlbC5nZXQoXCJ0eXBlXCIpO1xyXG4gICAgICAgIC8vIGlmICggc3RhdHVzICE9PSBcIlwiICYmIHN0YXR1cyAhPT0gbnVsbCAmJiBzdGF0dXMgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIC8vICAgICAgaW1hZ2VVcmwgKz0gc3RhdHVzO1xyXG4gICAgICAgIC8vIH1cclxuICAgICAgICBpbWFnZVVybCArPSAnLnBuZyc7XHJcbiAgICAgICAgdmFyIGNlbGxTdGF0ZU5vZGUgPSBuZXcgZ3JhcGhpYy5DaXJjbGUoe1xyXG4gICAgICAgICAgICAgc2hhcGU6IHtcclxuICAgICAgICAgICAgICAgIGN4OiAxMCxcclxuICAgICAgICAgICAgICAgIGN5OiAxMCxcclxuICAgICAgICAgICAgICAgIHI6IDVcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgIGZpbGw6ICcjMDc3ODI2JyxcclxuICAgICAgICAgICAgICAgIG9wYWNpdHk6IDEsXHJcbiAgICAgICAgICAgICAgICBzdHJva2U6ICcjQjNCM0IzJyxcclxuICAgICAgICAgICAgICAgIGxpbmVXaWR0aDogJzInLy8sKi9cclxuICAgICAgICAgICAgfSAsXHJcbiAgICAgICAgICAgIHo6IDEwMDBcclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAoIHN0YXR1cyAhPT0gXCJcIiAmJiBzdGF0dXMgIT09IG51bGwgJiYgc3RhdHVzID09PSBcIm9mZmxpbmVcIikge1xyXG4gICAgICAgICAgICBjZWxsU3RhdGVOb2RlLnN0eWxlLmZpbGwgPSBcIiM5OTk5OTlcIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5hZGQoY2VsbFN0YXRlTm9kZSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIHNlcnZlck5vZGVCID0gbmV3IGdyYXBoaWMuSW1hZ2Uoe1xyXG4gICAgICAgICAgICBwb3NpdGlvbjogWzAsIDBdLFxyXG4gICAgICAgICAgICBzY2FsZTogWzEsIDFdLFxyXG4gICAgICAgICAgICBzdHlsZToge1xyXG4gICAgICAgICAgICAgICAgeDogMCxcclxuICAgICAgICAgICAgICAgIHk6IDAsXHJcbiAgICAgICAgICAgICAgICBpbWFnZTogaW1hZ2VVcmwsXHJcbiAgICAgICAgICAgICAgICB3aWR0aDogX3dpZHRoLFxyXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAgX2hlaWdodFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAvL3o6IDEwMDAsXHJcbiAgICAgICAgICAgIGRyYWdnYWJsZTogZmFsc2UsXHJcbiAgICAgICAgICAgIHBhcm1EYXRlOiB0aGlzLm1vZGVsLmdldChcInBhcm1EYXRlXCIpXHJcbiAgICAgICAgfSk7IFxyXG5cclxuICAgICAgICB0aGlzLmFkZChzZXJ2ZXJOb2RlQik7XHJcblxyXG4gICAgICAgIHZhciBwb3J0c0xpc3QgPSBtb2RlbC5nZXQoXCJwb3J0c1wiKTtcclxuICAgICAgICBpZiAoIHBvcnRzTGlzdCAhPT0gdW5kZWZpbmVkICkge1xyXG4gICAgICAgICAgICB2YXIgX2tteCA9IDEwO1xyXG4gICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBwb3J0c0xpc3QubGVuZ3RoOyBpKysgKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcG9ydE1vZGVsID0ge307XHJcbiAgICAgICAgICAgICAgICBwb3J0TW9kZWwgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzb3VyY2VJZDogdXRpbC5nZXRVVUlEKCksICBcclxuICAgICAgICAgICAgICAgICAgICBib3VuZHM6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdXBwZXJMZWZ0OiB7eDogX2tteCwgeTogX2hlaWdodCAvIDIuNX0gIFxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgc3RlbmNpbDoge3R5cGU6IFwiUG9pbnROb2RlXCJ9XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgcG9ydE1vZGVsLmhlaWdodCA9IDc7XHJcbiAgICAgICAgICAgICAgICBwb3J0TW9kZWwud2lkdGggPSA3O1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBfbGluSW5mbyA9IHt9O1xyXG4gICAgICAgICAgICAgICAgX2xpbkluZm8uc291cmNlUmVvdXJjZSA9IHRoaXMubW9kZWwuZ2V0KFwibmFtZVwiKTtcclxuICAgICAgICAgICAgICAgIF9saW5JbmZvLnNvdXJjZVBvcnQgPSBpO1xyXG4gICAgICAgICAgICAgICAgX2xpbkluZm8uc291cmNlQ2FyZE5vID0gMDtcclxuICAgICAgICAgICAgICAgIF9saW5JbmZvLnBvcnRUeXBlID0gKHBvcnRzTGlzdFtpXS50eXBlICE9PSB1bmRlZmluZWQgJiYgcG9ydHNMaXN0W2ldLnR5cGUgIT09IG51bGwpID8gcG9ydHNMaXN0W2ldLnR5cGUgOiBcIjFcIjsgXHJcbiAgICAgICAgICAgICAgICBfbGluSW5mby5wb3J0U3RhdGUgPSAocG9ydHNMaXN0W2ldLnN0YXR1cyAhPT0gdW5kZWZpbmVkICYmIHBvcnRzTGlzdFtpXS5zdGF0dXMgIT09IG51bGwpID8gcG9ydHNMaXN0W2ldLnN0YXR1cyA6IFwiRE9XTlwiOyAgIFxyXG4gICAgICAgICAgICAgICAgX2xpbkluZm8ubm9kZXR5cGUgPSB0aGlzLm1vZGVsLmdldChcIm5vZGV0eXBlXCIpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHBvcnRzTGlzdFtpXS5pcCAhPT0gbnVsbCAmJiBwb3J0c0xpc3RbaV0uaXAgIT09IHVuZGVmaW5lZCApIHtcclxuICAgICAgICAgICAgICAgICAgICAgX2xpbkluZm8uaXAgPSBwb3J0c0xpc3RbaV0uaXA7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoIHBvcnRzTGlzdFtpXS50YXJnZXQgIT09IG51bGwgJiYgcG9ydHNMaXN0W2ldLnRhcmdldCAhPT0gdW5kZWZpbmVkICkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICggcG9ydHNMaXN0W2ldLnR5cGUgPT09IFwiMVwiICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfbGluSW5mby50YXJnZXRSZW91cmNlID0gcG9ydHNMaXN0W2ldLnRhcmdldC5yZXNvdXJjZU5hbWUgIT09IHVuZGVmaW5lZCA/IHBvcnRzTGlzdFtpXS50YXJnZXQucmVzb3VyY2VOYW1lIDogXCJcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2xpbkluZm8udGFyZ2V0UG9ydCA9IHBvcnRzTGlzdFtpXS50YXJnZXQucG9ydCAhPT0gdW5kZWZpbmVkID8gcG9ydHNMaXN0W2ldLnRhcmdldC5wb3J0IDogXCJcIjtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfbGluSW5mby50YXJnZXRSZW91cmNlID0gcG9ydHNMaXN0W2ldLnRhcmdldCAhPT0gdW5kZWZpbmVkID8gcG9ydHNMaXN0W2ldLnRhcmdldCA6IFwiXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9saW5JbmZvLnRhcmdldFBvcnQgPSBwb3J0c0xpc3RbaV0udGFyZ2V0LnBvcnQgIT09IHVuZGVmaW5lZCA/IHBvcnRzTGlzdFtpXS50YXJnZXQucG9ydCA6IFwiLTFcIjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9ICAgXHJcbiAgICAgICAgICAgICAgICBwb3J0TW9kZWwubGluZUluZm8gPSBfbGluSW5mbzsgICAgICAgICBcclxuICAgICAgICAgICAgICAgIHZhciBwTW9kZWwgPSBuZXcgTmV0d29ya01vZGVsKHBvcnRNb2RlbCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFkZFBvcnRCeU1vZGVsKHBNb2RlbCwgYXBpKTtcclxuICAgICAgICAgICAgICAgIF9rbXggPSBfa214ICsgNTsgICAgICBcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgIFxyXG4gICAgICAgIHZhciBwb3J0cyA9IG1vZGVsLmdldCgncG9ydHMnKTtcclxuICAgICAgICBpZiAoIHBvcnRzICE9PSB1bmRlZmluZWQgJiYgcG9ydHMuY2FyZDEgIT09IHVuZGVmaW5lZCAmJiBwb3J0cy5jYXJkMS5sZW5ndGggPCAzKSB7XHJcblxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnBvc2l0aW9uID0gW21vZGVsLmdldChcImJvdW5kcy51cHBlckxlZnQueFwiKSAsIG1vZGVsLmdldChcImJvdW5kcy51cHBlckxlZnQueVwiKV07XHJcbiAgICB9O1xyXG5cclxuICAgIFNlcnZlclRvcG9Ob2RlLnByb3RvdHlwZS5hZGRQb3J0QnlNb2RlbCA9IGZ1bmN0aW9uKCBwX21vZGVsLCBhcGkpIHtcclxuICAgICAgICB2YXIgU2hhcGUgPSBhcGkuZ2V0Tm9kZUNsYXNzKHBfbW9kZWwuZ2V0KFwic3RlbmNpbC50eXBlXCIpKTtcclxuICAgICAgICB2YXIgbm9kZSA9IG51bGw7XHJcbiAgICAgICAgaWYgKCBTaGFwZSApIHtcclxuICAgICAgICAgICAgbm9kZSA9IG5ldyBTaGFwZShwX21vZGVsLCB0aGlzLl9hcGkpO1xyXG4gICAgICAgICAgICB0aGlzLnBvcnROb2RlTGlzdC5wdXNoKG5vZGUpO1xyXG4gICAgICAgICAgICB0aGlzLmFkZChub2RlKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHpyVXRpbC5pbmhlcml0cyhTZXJ2ZXJUb3BvTm9kZSwgTmV0d29ya05vZGUpO1xyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBTZXJ2ZXJUb3BvTm9kZTtcclxuXHJcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9saWIvZmlzaC10b3BvLW5ldHdvcmsvbGliL25vZGUvdG9wby9TZXJ2ZXJUb3BvTm9kZS5qc1xuICoqIG1vZHVsZSBpZCA9IDk1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcclxuICAgIHZhciB1dGlsID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uL2Zpc2gtdG9wby1jb3JlL2xpYi91dGlsLmpzXCIpO1xyXG4gICAgdmFyIE5ldHdvcmtOb2RlID0gcmVxdWlyZShcIi4uL05ldHdvcmtOb2RlXCIpO1xyXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xyXG4gICAgdmFyIGdyYXBoaWMgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vZmlzaC10b3BvLWNvcmUvbGliL2dyYXBoaWMuanNcIik7XHJcbiAgICB2YXIgTmV0d29ya01vZGVsID0gcmVxdWlyZShcIi4uLy4uL21vZGVsL05ldHdvcmtNb2RlbC5qc1wiKTtcclxuICAgIHZhciBTZXJ2ZXJUb3BvTm9kZSA9IHJlcXVpcmUoXCIuL1NlcnZlclRvcG9Ob2RlXCIpO1xyXG4gICAgXHJcbiAgICBmdW5jdGlvbiBTZXJ2ZXJSNjMwTm9kZShtb2RlbCxhcGkpIHtcclxuICAgICAgICBOZXR3b3JrTm9kZS5jYWxsKHRoaXMsIG1vZGVsLCBhcGkpO1xyXG4gICAgICAgIHRoaXMucmFja2tJbmZvID0ge3R5cGU6IC0xLCBuYW1lOiBcIlNlcnZlclI2MzBOb2RlXCIgfTsgICAgXHJcbiAgICAgICAgdGhpcy5tb2RlbCA9IG1vZGVsO1xyXG4gICAgICAgIHRoaXMucG9ydE5vZGVMaXN0ID0gW107XHJcbiAgICAgICAgdGhpcy5jYXJkTm9kZUxpc3QgPSBbXTtcclxuICAgICAgICB0aGlzLnBhcm1EYXRlID0gdGhpcy5tb2RlbC5nZXQoXCJwYXJtRGF0ZVwiKTtcclxuICAgICAgICB0aGlzLnJlbmRlcihtb2RlbCxhcGkpO1xyXG4gICAgfTtcclxuXHJcbiAgICBTZXJ2ZXJSNjMwTm9kZS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24obW9kZWwsIGFwaSkge1xyXG4gICAgICAgIHRoaXMubW9kZWwgPSBtb2RlbDtcclxuICAgICAgICB2YXIgX3Nob3dUaXAgPSBtb2RlbC5nZXQoXCJzaG93VGlwXCIpO1xyXG4gICAgICAgIHZhciBfd2lkdGggPSBtb2RlbC5nZXQoXCJ3aWR0aFwiKTtcclxuICAgICAgICB2YXIgX2hlaWdodCA9IDIwO1xyXG5cclxuICAgICAgICB2YXIgX3RpdGxlID0gbmV3IGdyYXBoaWMuVGV4dCh7XHJcbiAgICAgICAgICAgIHN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgICB4OiBtb2RlbC5nZXQoXCJ3aWR0aFwiKSAvIDIgLSAxMCxcclxuICAgICAgICAgICAgICAgIHk6IC0yMCxcclxuICAgICAgICAgICAgICAgIHRleHQ6IG1vZGVsLmdldChcIm5hbWVcIiksXHJcbiAgICAgICAgICAgICAgICB3aWR0aDogMjAwLFxyXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBfaGVpZ2h0LFxyXG4gICAgICAgICAgICAgICAgZmlsbDogJyM4RjhCOEEnLFxyXG4gICAgICAgICAgICAgICAgdGV4dEZvbnQ6ICcxMnB4IE1pY3Jvc29mdCBZYWhlaScsXHJcbiAgICAgICAgICAgICAgICB0ZXh0QmFzZWxpbmU6ICd0b3AnXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGRyYWdnYWJsZTogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuYWRkKF90aXRsZSk7XHJcblxyXG4gICAgICAgIHZhciBzdGF0dXMgPSBtb2RlbC5nZXQoXCJzdGF0dXNcIik7XHJcbiAgICAgICAgdmFyIGltYWdlVXJsID0gJy4uLy4uLy4uLy4uL2Zpc2gtdG9wby1uZXR3b3JrL3NyYy9pbWFnZXMvJyArIG1vZGVsLmdldChcInR5cGVcIik7XHJcbiAgICAgICAgLy8gaWYgKCBzdGF0dXMgIT09IFwiXCIgJiYgc3RhdHVzICE9PSBudWxsICYmIHN0YXR1cyAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgLy8gICAgICBpbWFnZVVybCArPSBzdGF0dXM7XHJcbiAgICAgICAgLy8gfVxyXG4gICAgICAgIGltYWdlVXJsICs9ICcucG5nJztcclxuXHJcbiAgICAgICAgdmFyIGNlbGxTdGF0ZU5vZGUgPSBuZXcgZ3JhcGhpYy5DaXJjbGUoe1xyXG4gICAgICAgICAgICAgc2hhcGU6IHtcclxuICAgICAgICAgICAgICAgIGN4OiAxMCxcclxuICAgICAgICAgICAgICAgIGN5OiAxMCxcclxuICAgICAgICAgICAgICAgIHI6IDVcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgIGZpbGw6ICcjMDc3ODI2JyxcclxuICAgICAgICAgICAgICAgIG9wYWNpdHk6IDEsXHJcbiAgICAgICAgICAgICAgICBzdHJva2U6ICcjQjNCM0IzJyxcclxuICAgICAgICAgICAgICAgIGxpbmVXaWR0aDogJzInLy8sKi9cclxuICAgICAgICAgICAgfSAsXHJcbiAgICAgICAgICAgIHo6IDEwMDBcclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAoIHN0YXR1cyAhPT0gXCJcIiAmJiBzdGF0dXMgIT09IG51bGwgJiYgc3RhdHVzID09PSBcIm9mZmxpbmVcIikge1xyXG4gICAgICAgICAgICBjZWxsU3RhdGVOb2RlLnN0eWxlLmZpbGwgPSBcIiM5OTk5OTlcIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5hZGQoY2VsbFN0YXRlTm9kZSk7XHJcbiAgXHJcbiAgICAgICAgdmFyIHNlcnZlck5vZGVCID0gbmV3IGdyYXBoaWMuSW1hZ2Uoe1xyXG4gICAgICAgICAgICBwb3NpdGlvbjogWzAsIDBdLFxyXG4gICAgICAgICAgICBzY2FsZTogWzEsIDFdLFxyXG4gICAgICAgICAgICBzdHlsZToge1xyXG4gICAgICAgICAgICAgICAgeDogMCxcclxuICAgICAgICAgICAgICAgIHk6IDAsXHJcbiAgICAgICAgICAgICAgICBpbWFnZTogaW1hZ2VVcmwsXHJcbiAgICAgICAgICAgICAgICB3aWR0aDogX3dpZHRoLFxyXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAgX2hlaWdodFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAvL3o6IDEwMDAsXHJcbiAgICAgICAgICAgIGRyYWdnYWJsZTogZmFsc2UsXHJcbiAgICAgICAgICAgIHBhcm1EYXRlOiB0aGlzLm1vZGVsLmdldChcInBhcm1EYXRlXCIpXHJcbiAgICAgICAgfSk7IFxyXG5cclxuICAgICAgICB0aGlzLmFkZChzZXJ2ZXJOb2RlQik7XHJcblxyXG4gICAgICAgIHZhciBwb3J0c0xpc3QgPSBtb2RlbC5nZXQoXCJwb3J0c1wiKTtcclxuICAgICAgICBpZiAoIHBvcnRzTGlzdCAhPT0gdW5kZWZpbmVkICkge1xyXG4gICAgICAgICAgICB2YXIgX2tteCA9IDEwO1xyXG4gICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBwb3J0c0xpc3QubGVuZ3RoOyBpKysgKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcG9ydE1vZGVsID0ge307XHJcbiAgICAgICAgICAgICAgICBwb3J0TW9kZWwgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzb3VyY2VJZDogdXRpbC5nZXRVVUlEKCksICBcclxuICAgICAgICAgICAgICAgICAgICBib3VuZHM6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdXBwZXJMZWZ0OiB7eDogX2tteCwgeTogX2hlaWdodCAvIDIuNX0gIFxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgc3RlbmNpbDoge3R5cGU6IFwiUG9pbnROb2RlXCJ9XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgcG9ydE1vZGVsLmhlaWdodCA9IDc7XHJcbiAgICAgICAgICAgICAgICBwb3J0TW9kZWwud2lkdGggPSA3O1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBfbGluSW5mbyA9IHt9O1xyXG4gICAgICAgICAgICAgICAgX2xpbkluZm8uc291cmNlUmVvdXJjZSA9IHRoaXMubW9kZWwuZ2V0KFwibmFtZVwiKTtcclxuICAgICAgICAgICAgICAgIF9saW5JbmZvLnNvdXJjZVBvcnQgPSBpO1xyXG4gICAgICAgICAgICAgICAgX2xpbkluZm8uc291cmNlQ2FyZE5vID0gMDtcclxuICAgICAgICAgICAgICAgIF9saW5JbmZvLnBvcnRUeXBlID0gKHBvcnRzTGlzdFtpXS50eXBlICE9PSB1bmRlZmluZWQgJiYgcG9ydHNMaXN0W2ldLnR5cGUgIT09IG51bGwpID8gcG9ydHNMaXN0W2ldLnR5cGUgOiBcIjFcIjsgXHJcbiAgICAgICAgICAgICAgICBfbGluSW5mby5wb3J0U3RhdGUgPSAocG9ydHNMaXN0W2ldLnN0YXR1cyAhPT0gdW5kZWZpbmVkICYmIHBvcnRzTGlzdFtpXS5zdGF0dXMgIT09IG51bGwpID8gcG9ydHNMaXN0W2ldLnN0YXR1cyA6IFwiRE9XTlwiOyAgIFxyXG4gICAgICAgICAgICAgICAgX2xpbkluZm8ubm9kZXR5cGUgPSB0aGlzLm1vZGVsLmdldChcIm5vZGV0eXBlXCIpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHBvcnRzTGlzdFtpXS5pcCAhPT0gbnVsbCAmJiBwb3J0c0xpc3RbaV0uaXAgIT09IHVuZGVmaW5lZCApIHtcclxuICAgICAgICAgICAgICAgICAgICAgX2xpbkluZm8uaXAgPSBwb3J0c0xpc3RbaV0uaXA7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoIHBvcnRzTGlzdFtpXS50YXJnZXQgIT09IG51bGwgJiYgcG9ydHNMaXN0W2ldLnRhcmdldCAhPT0gdW5kZWZpbmVkICkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICggcG9ydHNMaXN0W2ldLnR5cGUgPT09IFwiMVwiICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfbGluSW5mby50YXJnZXRSZW91cmNlID0gcG9ydHNMaXN0W2ldLnRhcmdldC5yZXNvdXJjZU5hbWUgIT09IHVuZGVmaW5lZCA/IHBvcnRzTGlzdFtpXS50YXJnZXQucmVzb3VyY2VOYW1lIDogXCJcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2xpbkluZm8udGFyZ2V0UG9ydCA9IHBvcnRzTGlzdFtpXS50YXJnZXQucG9ydCAhPT0gdW5kZWZpbmVkID8gcG9ydHNMaXN0W2ldLnRhcmdldC5wb3J0IDogXCJcIjtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfbGluSW5mby50YXJnZXRSZW91cmNlID0gcG9ydHNMaXN0W2ldLnRhcmdldCAhPT0gdW5kZWZpbmVkID8gcG9ydHNMaXN0W2ldLnRhcmdldCA6IFwiXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9saW5JbmZvLnRhcmdldFBvcnQgPSBwb3J0c0xpc3RbaV0udGFyZ2V0LnBvcnQgIT09IHVuZGVmaW5lZCA/IHBvcnRzTGlzdFtpXS50YXJnZXQucG9ydCA6IFwiLTFcIjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9ICAgXHJcbiAgICAgICAgICAgICAgICBwb3J0TW9kZWwubGluZUluZm8gPSBfbGluSW5mbzsgICAgICAgICBcclxuICAgICAgICAgICAgICAgIHZhciBwTW9kZWwgPSBuZXcgTmV0d29ya01vZGVsKHBvcnRNb2RlbCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFkZFBvcnRCeU1vZGVsKHBNb2RlbCwgYXBpKTtcclxuICAgICAgICAgICAgICAgIF9rbXggPSBfa214ICsgNTsgICAgICBcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgIFxyXG4gICAgICAgIHZhciBwb3J0cyA9IG1vZGVsLmdldCgncG9ydHMnKTtcclxuICAgICAgICBpZiAoIHBvcnRzICE9PSB1bmRlZmluZWQgJiYgcG9ydHMuY2FyZDEgIT09IHVuZGVmaW5lZCAmJiBwb3J0cy5jYXJkMS5sZW5ndGggPCAzKSB7XHJcblxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnBvc2l0aW9uID0gW21vZGVsLmdldChcImJvdW5kcy51cHBlckxlZnQueFwiKSAsIG1vZGVsLmdldChcImJvdW5kcy51cHBlckxlZnQueVwiKV07XHJcbiAgICB9O1xyXG5cclxuICAgIFNlcnZlclI2MzBOb2RlLnByb3RvdHlwZS5hZGRQb3J0QnlNb2RlbCA9IGZ1bmN0aW9uKCBwX21vZGVsLCBhcGkpIHtcclxuICAgICAgICB2YXIgU2hhcGUgPSBhcGkuZ2V0Tm9kZUNsYXNzKHBfbW9kZWwuZ2V0KFwic3RlbmNpbC50eXBlXCIpKTtcclxuICAgICAgICB2YXIgbm9kZSA9IG51bGw7XHJcbiAgICAgICAgaWYgKCBTaGFwZSApIHtcclxuICAgICAgICAgICAgbm9kZSA9IG5ldyBTaGFwZShwX21vZGVsLCB0aGlzLl9hcGkpO1xyXG4gICAgICAgICAgICB0aGlzLnBvcnROb2RlTGlzdC5wdXNoKG5vZGUpO1xyXG4gICAgICAgICAgICB0aGlzLmFkZChub2RlKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHpyVXRpbC5pbmhlcml0cyhTZXJ2ZXJSNjMwTm9kZSwgTmV0d29ya05vZGUpO1xyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBTZXJ2ZXJSNjMwTm9kZTtcclxuXHJcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9saWIvZmlzaC10b3BvLW5ldHdvcmsvbGliL25vZGUvdG9wby9TZXJ2ZXJSNjMwTm9kZS5qc1xuICoqIG1vZHVsZSBpZCA9IDk2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcclxuICAgIHZhciB1dGlsID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uL2Zpc2gtdG9wby1jb3JlL2xpYi91dGlsLmpzXCIpO1xyXG4gICAgdmFyIE5ldHdvcmtOb2RlID0gcmVxdWlyZShcIi4uL05ldHdvcmtOb2RlXCIpO1xyXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xyXG4gICAgdmFyIGdyYXBoaWMgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vZmlzaC10b3BvLWNvcmUvbGliL2dyYXBoaWMuanNcIik7XHJcbiAgICB2YXIgTmV0d29ya01vZGVsID0gcmVxdWlyZShcIi4uLy4uL21vZGVsL05ldHdvcmtNb2RlbC5qc1wiKTtcclxuICAgIHZhciBDYXJkTW9kZWwgPSByZXF1aXJlKFwiLi4vLi4vbW9kZWwvdG9wby9DYXJkTW9kZWwuanNcIik7XHJcbiAgICB2YXIgU2VydmVyVG9wb05vZGUgPSByZXF1aXJlKFwiLi9TZXJ2ZXJUb3BvTm9kZVwiKTtcclxuICAgIFxyXG4gICAgZnVuY3Rpb24gU2VydmVyUjczME5vZGUobW9kZWwsYXBpKSB7XHJcbiAgICAgICAgTmV0d29ya05vZGUuY2FsbCh0aGlzLCBtb2RlbCwgYXBpKTtcclxuICAgICAgICB0aGlzLnJhY2trSW5mbyA9IHt0eXBlOiAtMSwgbmFtZTogXCJTZXJ2ZXJSNzMwTm9kZVwiIH07ICAgIFxyXG4gICAgICAgIHRoaXMubW9kZWwgPSBtb2RlbDtcclxuICAgICAgICB0aGlzLnBvcnROb2RlTGlzdCA9IFtdO1xyXG4gICAgICAgIHRoaXMuY2FyZE5vZGVMaXN0ID0gW107XHJcbiAgICAgICAgdGhpcy5wYXJtRGF0ZSA9IHRoaXMubW9kZWwuZ2V0KFwicGFybURhdGVcIik7XHJcbiAgICAgICAgdGhpcy5yZW5kZXIobW9kZWwsYXBpKTtcclxuICAgIH07XHJcblxyXG4gICAgU2VydmVyUjczME5vZGUucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uKG1vZGVsLCBhcGkpIHtcclxuICAgICAgICB0aGlzLm1vZGVsID0gbW9kZWw7XHJcbiAgICAgICAgdmFyIF9zaG93VGlwID0gbW9kZWwuZ2V0KFwic2hvd1RpcFwiKTtcclxuICAgICAgICB2YXIgX2hlaWdodCA9IDIwO1xyXG4gICAgICAgIHZhciBtZSA9IHRoaXM7XHJcbiAgICAgICAgdmFyIF90aXRsZSA9IG5ldyBncmFwaGljLlRleHQoe1xyXG4gICAgICAgICAgICBzdHlsZToge1xyXG4gICAgICAgICAgICAgICAgeDogbW9kZWwuZ2V0KFwid2lkdGhcIikgLyAyIC0gMTAsXHJcbiAgICAgICAgICAgICAgICB5OiAtMjAsXHJcbiAgICAgICAgICAgICAgICB0ZXh0OiBtb2RlbC5nZXQoXCJuYW1lXCIpLFxyXG4gICAgICAgICAgICAgICAgd2lkdGg6IDIwMCxcclxuICAgICAgICAgICAgICAgIGhlaWdodDogMjAsXHJcbiAgICAgICAgICAgICAgICBmaWxsOiAnIzhGOEI4QScsXHJcbiAgICAgICAgICAgICAgICB0ZXh0Rm9udDogJzEycHggTWljcm9zb2Z0IFlhaGVpJyxcclxuICAgICAgICAgICAgICAgIHRleHRCYXNlbGluZTogJ3RvcCdcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZHJhZ2dhYmxlOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5hZGQoX3RpdGxlKTtcclxuXHJcbiAgICAgICAgdmFyIHN0YXR1cyA9IG1vZGVsLmdldChcInN0YXR1c1wiKTtcclxuICAgICAgICB2YXIgaW1hZ2VVcmwgPSAnLi4vLi4vLi4vLi4vZmlzaC10b3BvLW5ldHdvcmsvc3JjL2ltYWdlcy8nICsgbW9kZWwuZ2V0KFwidHlwZVwiKTtcclxuICAgICAgICAvLyBpZiAoIHN0YXR1cyAhPT0gXCJcIiAmJiBzdGF0dXMgIT09IG51bGwgJiYgc3RhdHVzICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAvLyAgICAgIGltYWdlVXJsICs9IHN0YXR1cztcclxuICAgICAgICAvLyB9XHJcbiAgICAgICAgaW1hZ2VVcmwgKz0gJy5wbmcnO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciBjZWxsU3RhdGVOb2RlID0gbmV3IGdyYXBoaWMuQ2lyY2xlKHtcclxuICAgICAgICAgICAgIHNoYXBlOiB7XHJcbiAgICAgICAgICAgICAgICBjeDogMTAsXHJcbiAgICAgICAgICAgICAgICBjeTogMjAsXHJcbiAgICAgICAgICAgICAgICByOiA1XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgICBmaWxsOiAnIzA3NzgyNicsXHJcbiAgICAgICAgICAgICAgICBvcGFjaXR5OiAxLFxyXG4gICAgICAgICAgICAgICAgc3Ryb2tlOiAnI0IzQjNCMycsXHJcbiAgICAgICAgICAgICAgICBsaW5lV2lkdGg6ICcyJy8vLCovXHJcbiAgICAgICAgICAgIH0gLFxyXG4gICAgICAgICAgICB6OiAxMDAwXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKCBzdGF0dXMgIT09IFwiXCIgJiYgc3RhdHVzICE9PSBudWxsICYmIHN0YXR1cyA9PT0gXCJvZmZsaW5lXCIpIHtcclxuICAgICAgICAgICAgY2VsbFN0YXRlTm9kZS5zdHlsZS5maWxsID0gXCIjOTk5OTk5XCI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuYWRkKGNlbGxTdGF0ZU5vZGUpO1xyXG5cclxuICAgICAgICB2YXIgc2VydmVyTm9kZUIgPSBuZXcgZ3JhcGhpYy5JbWFnZSh7XHJcbiAgICAgICAgICAgIHBvc2l0aW9uOiBbMCwgMF0sXHJcbiAgICAgICAgICAgIHNjYWxlOiBbMSwgMV0sXHJcbiAgICAgICAgICAgIHN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgICB4OiAwLFxyXG4gICAgICAgICAgICAgICAgeTogMCxcclxuICAgICAgICAgICAgICAgIGltYWdlOiBpbWFnZVVybCxcclxuICAgICAgICAgICAgICAgIHdpZHRoOiBtb2RlbC5nZXQoXCJ3aWR0aFwiKSxcclxuICAgICAgICAgICAgICAgIGhlaWdodDogIDQwLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAvL3o6IDEwMDAsXHJcbiAgICAgICAgICAgIGRyYWdnYWJsZTogZmFsc2UsXHJcbiAgICAgICAgICAgIHBhcm1EYXRlOiB0aGlzLm1vZGVsLmdldChcInBhcm1EYXRlXCIpXHJcbiAgICAgICAgfSk7IFxyXG4gICAgICAgIHRoaXMuYWRkKHNlcnZlck5vZGVCKTtcclxuICAgICAgICBcclxuICAgICAgICB2YXIgcG9ydHNMaXN0ID0gbW9kZWwuZ2V0KFwicG9ydHNcIik7XHJcbiAgICAgICAgaWYgKCBwb3J0c0xpc3QgIT09IHVuZGVmaW5lZCApIHtcclxuICAgICAgICAgICAgdmFyIF9rbXggPSAxMDtcclxuICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgcG9ydHNMaXN0Lmxlbmd0aDsgaSsrICkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHBvcnRNb2RlbCA9IHt9O1xyXG4gICAgICAgICAgICAgICAgcG9ydE1vZGVsID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc291cmNlSWQ6IHV0aWwuZ2V0VVVJRCgpLCAgXHJcbiAgICAgICAgICAgICAgICAgICAgYm91bmRzOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwcGVyTGVmdDoge3g6IF9rbXgsIHk6IF9oZWlnaHQgLyAyLjV9ICBcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIHN0ZW5jaWw6IHt0eXBlOiBcIlBvaW50Tm9kZVwifVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIHBvcnRNb2RlbC5oZWlnaHQgPSA3O1xyXG4gICAgICAgICAgICAgICAgcG9ydE1vZGVsLndpZHRoID0gNztcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgX2xpbkluZm8gPSB7fTtcclxuICAgICAgICAgICAgICAgIF9saW5JbmZvLnNvdXJjZVJlb3VyY2UgPSB0aGlzLm1vZGVsLmdldChcIm5hbWVcIik7XHJcbiAgICAgICAgICAgICAgICBfbGluSW5mby5zb3VyY2VQb3J0ID0gaTtcclxuICAgICAgICAgICAgICAgIF9saW5JbmZvLnNvdXJjZUNhcmRObyA9IDA7XHJcbiAgICAgICAgICAgICAgICBfbGluSW5mby5ub2RldHlwZSA9IHRoaXMubW9kZWwuZ2V0KFwibm9kZXR5cGVcIik7XHJcbiAgICAgICAgICAgICAgICBfbGluSW5mby5wb3J0VHlwZSA9IChwb3J0c0xpc3RbaV0udHlwZSAhPT0gdW5kZWZpbmVkICYmIHBvcnRzTGlzdFtpXS50eXBlICE9PSBudWxsKSA/IHBvcnRzTGlzdFtpXS50eXBlIDogXCIxXCI7IFxyXG4gICAgICAgICAgICAgICAgX2xpbkluZm8ucG9ydFN0YXRlID0gKHBvcnRzTGlzdFtpXS5zdGF0dXMgIT09IHVuZGVmaW5lZCAmJiBwb3J0c0xpc3RbaV0uc3RhdHVzICE9PSBudWxsKSA/IHBvcnRzTGlzdFtpXS5zdGF0dXMgOiBcIkRPV05cIjsgICBcclxuICAgICAgICAgICAgICAgICBpZiAocG9ydHNMaXN0W2ldLmlwICE9PSBudWxsICYmIHBvcnRzTGlzdFtpXS5pcCAhPT0gdW5kZWZpbmVkICkge1xyXG4gICAgICAgICAgICAgICAgICAgICBfbGluSW5mby5pcCA9IHBvcnRzTGlzdFtpXS5pcDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICggcG9ydHNMaXN0W2ldLnRhcmdldCAhPT0gbnVsbCAmJiBwb3J0c0xpc3RbaV0udGFyZ2V0ICE9PSB1bmRlZmluZWQgKSB7XHJcbiAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgICBpZiAoIHBvcnRzTGlzdFtpXS50eXBlID09PSBcIjFcIiApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2xpbkluZm8udGFyZ2V0UmVvdXJjZSA9IHBvcnRzTGlzdFtpXS50YXJnZXQucmVzb3VyY2VOYW1lICE9PSB1bmRlZmluZWQgPyBwb3J0c0xpc3RbaV0udGFyZ2V0LnJlc291cmNlTmFtZSA6IFwiXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9saW5JbmZvLnRhcmdldFBvcnQgPSBwb3J0c0xpc3RbaV0udGFyZ2V0LnBvcnQgIT09IHVuZGVmaW5lZCA/IHBvcnRzTGlzdFtpXS50YXJnZXQucG9ydCA6IFwiXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2xpbkluZm8udGFyZ2V0UmVvdXJjZSA9IHBvcnRzTGlzdFtpXS50YXJnZXQgIT09IHVuZGVmaW5lZCA/IHBvcnRzTGlzdFtpXS50YXJnZXQgOiBcIlwiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfbGluSW5mby50YXJnZXRQb3J0ID0gcG9ydHNMaXN0W2ldLnRhcmdldC5wb3J0ICE9PSB1bmRlZmluZWQgPyBwb3J0c0xpc3RbaV0udGFyZ2V0LnBvcnQgOiBcIi0xXCI7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0gIFxyXG5cclxuICAgICAgICAgICAgICAgIHBvcnRNb2RlbC5saW5lSW5mbyA9IF9saW5JbmZvOyAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgdmFyIHBNb2RlbCA9IG5ldyBOZXR3b3JrTW9kZWwocG9ydE1vZGVsKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuYWRkUG9ydEJ5TW9kZWwocE1vZGVsLCBhcGkpO1xyXG4gICAgICAgICAgICAgICAgX2tteCA9IF9rbXggKyA1OyAgICAgIFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSAgICAgICBcclxuICAgICAgICBcclxuICAgICAgICB0aGlzLnBvc2l0aW9uID0gW21vZGVsLmdldChcImJvdW5kcy51cHBlckxlZnQueFwiKSAsIG1vZGVsLmdldChcImJvdW5kcy51cHBlckxlZnQueVwiKV07XHJcbiAgICB9O1xyXG5cclxuICAgIFNlcnZlclI3MzBOb2RlLnByb3RvdHlwZS5hZGRQb3J0QnlNb2RlbCA9IGZ1bmN0aW9uKCBwX21vZGVsLCBhcGkpIHtcclxuICAgICAgICB2YXIgU2hhcGUgPSBhcGkuZ2V0Tm9kZUNsYXNzKHBfbW9kZWwuZ2V0KFwic3RlbmNpbC50eXBlXCIpKTtcclxuICAgICAgICB2YXIgbm9kZSA9IG51bGw7XHJcbiAgICAgICAgaWYgKCBTaGFwZSApIHtcclxuICAgICAgICAgICAgbm9kZSA9IG5ldyBTaGFwZShwX21vZGVsLCB0aGlzLl9hcGkpO1xyXG4gICAgICAgICAgICB0aGlzLnBvcnROb2RlTGlzdC5wdXNoKG5vZGUpO1xyXG4gICAgICAgICAgICB0aGlzLmFkZChub2RlKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIFNlcnZlclI3MzBOb2RlLnByb3RvdHlwZS5hZGROb2RlQnlNb2RlbCA9IGZ1bmN0aW9uKCBwX21vZGVsLCBhcGkpIHtcclxuICAgICAgICB2YXIgU2hhcGUgPSBhcGkuZ2V0Tm9kZUNsYXNzKHBfbW9kZWwuZ2V0KFwic3RlbmNpbC50eXBlXCIpKTtcclxuICAgICAgICB2YXIgbm9kZSA9IG51bGw7XHJcbiAgICAgICAgaWYgKCBTaGFwZSApIHtcclxuICAgICAgICAgICAgbm9kZSA9IG5ldyBTaGFwZShwX21vZGVsLCBhcGkpO1xyXG4gICAgICAgICAgICB2YXIgcG9pbnRMaXN0ID0gbm9kZS5wb2ludExpc3Q7XHJcbiAgICAgICAgICAgIGlmICggcG9pbnRMaXN0ICE9PSB1bmRlZmluZWQgJiYgcG9pbnRMaXN0Lmxlbmd0aCA+IDAgKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IoIHZhciBpID0gMDsgaSA8IHBvaW50TGlzdC5sZW5ndGg7IGkrKyApIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIHBvaW50TGlzdFtpXS5saW5lSW5mby5zb3VyY2VDYXJkTm8gPT09IFwiMVwiICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludExpc3RbaV0ubGluZUluZm8ubW9kZGxlWCA9IDM1O1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiggcG9pbnRMaXN0W2ldLmxpbmVJbmZvLnNvdXJjZUNhcmRObyA9PT0gXCIyXCIgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50TGlzdFtpXS5saW5lSW5mby5tb2RkbGVYID0gMjU7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmKCBwb2ludExpc3RbaV0ubGluZUluZm8uc291cmNlQ2FyZE5vID09PSBcIjNcIiApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmKCBwb2ludExpc3RbaV0ubGluZUluZm8uc291cmNlQ2FyZE5vID09PSBcIjRcIiApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRMaXN0W2ldLmxpbmVJbmZvLm1vZGRsZVggPSAyNTtcclxuICAgICAgICAgICAgICAgICAgICB9ZWxzZSBpZiggcG9pbnRMaXN0W2ldLmxpbmVJbmZvLnNvdXJjZUNhcmRObyA9PT0gXCI1XCIgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgdGhpcy5wb3J0Tm9kZUxpc3QucHVzaChwb2ludExpc3RbaV0pOyAgIFxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuYWRkKG5vZGUpO1xyXG4gICAgICAgICAgICB0aGlzLmNhcmROb2RlTGlzdC5wdXNoKG5vZGUpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgenJVdGlsLmluaGVyaXRzKFNlcnZlclI3MzBOb2RlLCBOZXR3b3JrTm9kZSk7XHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IFNlcnZlclI3MzBOb2RlO1xyXG5cclxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2xpYi9maXNoLXRvcG8tbmV0d29yay9saWIvbm9kZS90b3BvL1NlcnZlclI3MzBOb2RlLmpzXG4gKiogbW9kdWxlIGlkID0gOTdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlxyXG5cclxuICAgIHZhciBNb2RlbCA9IHJlcXVpcmUoJy4uLy4uLy4uLy4uL2Zpc2gtdG9wby1jb3JlL2xpYi9Nb2RlbCcpO1xyXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xyXG4gICAgdmFyIE5ldHdvcmtNb2RlbCA9IHJlcXVpcmUoJy4uL05ldHdvcmtNb2RlbCcpO1xyXG5cclxuICAgIHZhciBDYXJkTW9kZWwgPSBOZXR3b3JrTW9kZWwuZXh0ZW5kKHtcclxuICAgICAgICBObzogXCJcIixcclxuICAgICAgICByZXNvdXJjZXNOYW1lOiBcIlwiLFxyXG4gICAgICAgIHJlc291cmNlTm9kZVR5cGUgOiBcIjFcIixcclxuICAgICAgICBoZWlnaHQ6IDUsXHJcbiAgICAgICAgd2lkdGg6IDUsXHJcbiAgICAgICAgdHlwZTogXCJcIixcclxuICAgICAgICBkaXJlY3Rpb246IFwibGVmdFJpZ2h0XCIsLy91cGRvd25cclxuICAgICAgICBwb3J0RGF0YTogW11cclxuICAgIH0pO1xyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBDYXJkTW9kZWw7XHJcblxyXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vbGliL2Zpc2gtdG9wby1uZXR3b3JrL2xpYi9tb2RlbC90b3BvL0NhcmRNb2RlbC5qc1xuICoqIG1vZHVsZSBpZCA9IDk4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcclxuICAgIHZhciB1dGlsID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uL2Zpc2gtdG9wby1jb3JlL2xpYi91dGlsLmpzXCIpO1xyXG4gICAgdmFyIE5ldHdvcmtOb2RlID0gcmVxdWlyZShcIi4uL05ldHdvcmtOb2RlXCIpO1xyXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xyXG4gICAgdmFyIGdyYXBoaWMgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vZmlzaC10b3BvLWNvcmUvbGliL2dyYXBoaWMuanNcIik7XHJcbiAgICB2YXIgTmV0d29ya01vZGVsID0gcmVxdWlyZShcIi4uLy4uL21vZGVsL05ldHdvcmtNb2RlbC5qc1wiKTtcclxuICAgIHZhciBTZXJ2ZXJUb3BvTm9kZSA9IHJlcXVpcmUoXCIuL1NlcnZlclRvcG9Ob2RlXCIpO1xyXG4gICAgXHJcbiAgICBmdW5jdGlvbiBTZXJ2ZXJYMzU1ME5vZGUobW9kZWwsYXBpKSB7XHJcbiAgICAgICAgU2VydmVyVG9wb05vZGUuY2FsbCh0aGlzLCBtb2RlbCwgYXBpKTtcclxuICAgICAgICB0aGlzLnJhY2trSW5mbyA9IHt0eXBlOiAtMSwgbmFtZTogXCJTZXJ2ZXJYMzU1ME5vZGVcIiB9OyAgICBcclxuICAgICAgICB0aGlzLm1vZGVsID0gbW9kZWw7XHJcbiAgICAgICAgdGhpcy5yZW5kZXIobW9kZWwsYXBpKTtcclxuICAgIH07XHJcblxyXG4gICAgU2VydmVyWDM1NTBOb2RlLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbihtb2RlbCwgYXBpKSB7XHJcbiAgICAgICAgdGhpcy5tb2RlbCA9IG1vZGVsO1xyXG4gICAgICAgIHZhciBfc2hvd1RpcCA9IG1vZGVsLmdldChcInNob3dUaXBcIik7XHJcblxyXG4gICAgICAgIHZhciBfdGl0bGUgPSBuZXcgZ3JhcGhpYy5UZXh0KHtcclxuICAgICAgICAgICAgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgIHg6IG1vZGVsLmdldChcIndpZHRoXCIpIC8gMiAtIDEwLFxyXG4gICAgICAgICAgICAgICAgeTogLTIwLFxyXG4gICAgICAgICAgICAgICAgdGV4dDogbW9kZWwuZ2V0KFwibmFtZVwiKSxcclxuICAgICAgICAgICAgICAgIHdpZHRoOiAyMDAsXHJcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDIwLFxyXG4gICAgICAgICAgICAgICAgZmlsbDogJyM4RjhCOEEnLFxyXG4gICAgICAgICAgICAgICAgdGV4dEZvbnQ6ICcxMnB4IE1pY3Jvc29mdCBZYWhlaScsXHJcbiAgICAgICAgICAgICAgICB0ZXh0QmFzZWxpbmU6ICd0b3AnXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGRyYWdnYWJsZTogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuYWRkKF90aXRsZSk7XHJcblxyXG4gICAgICAgIHZhciBzZXJ2ZXJOb2RlQiA9IG5ldyBncmFwaGljLkltYWdlKHtcclxuICAgICAgICAgICAgcG9zaXRpb246IFswLCAwXSxcclxuICAgICAgICAgICAgc2NhbGU6IFsxLCAxXSxcclxuICAgICAgICAgICAgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgIHg6IDAsXHJcbiAgICAgICAgICAgICAgICB5OiAwLFxyXG4gICAgICAgICAgICAgICAgaW1hZ2U6ICcuLi8uLi8uLi8uLi9maXNoLXRvcG8tbmV0d29yay9zcmMvaW1hZ2VzL3hJQk1YMzU1MGIucG5nJyxcclxuICAgICAgICAgICAgICAgIHdpZHRoOiBtb2RlbC5nZXQoXCJ3aWR0aFwiKSxcclxuICAgICAgICAgICAgICAgIGhlaWdodDogIDQwXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGRyYWdnYWJsZTogZmFsc2UsXHJcbiAgICAgICAgICAgIHBhcm1EYXRlOiB0aGlzLm1vZGVsLmdldChcInBhcm1EYXRlXCIpXHJcbiAgICAgICAgfSk7IFxyXG5cclxuICAgICAgICB2YXIgc2VydmVyTm9kZUEgPSBuZXcgZ3JhcGhpYy5JbWFnZSh7XHJcbiAgICAgICAgICAgIHBvc2l0aW9uOiBbMCwgMF0sXHJcbiAgICAgICAgICAgIHNjYWxlOiBbMSwgMV0sXHJcbiAgICAgICAgICAgIHN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgICB4OiAwLFxyXG4gICAgICAgICAgICAgICAgeTogMCxcclxuICAgICAgICAgICAgICAgIGltYWdlOiAnLi4vLi4vLi4vLi4vZmlzaC10b3BvLW5ldHdvcmsvc3JjL2ltYWdlcy94SUJNWDM1NTBhLnBuZycsXHJcbiAgICAgICAgICAgICAgICB3aWR0aDogbW9kZWwuZ2V0KFwid2lkdGhcIiksXHJcbiAgICAgICAgICAgICAgICBoZWlnaHQ6ICA0MFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBkcmFnZ2FibGU6IGZhbHNlLFxyXG4gICAgICAgICAgICBwYXJtRGF0ZTogdGhpcy5tb2RlbC5nZXQoXCJwYXJtRGF0ZVwiKVxyXG4gICAgICAgIH0pOyBcclxuXHJcblxyXG4gICAgICAgIHNlcnZlck5vZGVCLm9uKFwibW91c2VvdmVyXCIsIGZ1bmN0aW9uKHBhcmFtcyl7XHJcbiAgICAgICAgICAgIHNlcnZlck5vZGVCLmF0dHIoXCJwb3NpdGlvblwiICwgWy0xMDAwLCAtMTAwMF0pO1xyXG4gICAgICAgICAgICBzZXJ2ZXJOb2RlQS5hdHRyKFwicG9zaXRpb25cIiwgWzAsMF0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHNlcnZlck5vZGVBLm9uKFwibW91c2VvdXRcIiwgZnVuY3Rpb24ocGFyYW1zKXtcclxuICAgICAgICAgICAgc2VydmVyTm9kZUEuYXR0cihcInBvc2l0aW9uXCIgLCBbLTEwMDAsIC0xMDAwXSk7XHJcbiAgICAgICAgICAgIHNlcnZlck5vZGVCLmF0dHIoXCJwb3NpdGlvblwiLCBbMCwwXSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHRoaXMuYWRkKHNlcnZlck5vZGVBKTtcclxuICAgICAgICB0aGlzLmFkZChzZXJ2ZXJOb2RlQik7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy/nlLvpu5jorqTnmoTku6XlpKrnvZHnq6/lj6NcclxuICAgICAgICB2YXIgX2tteCA9IDk1O1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNDsgaSsrICkge1xyXG4gICAgICAgICAgICB2YXIgcG9ydE1vZGVsID0ge307XHJcbiAgICAgICAgICAgIHBvcnRNb2RlbCA9IHtcclxuICAgICAgICAgICAgICAgIHJlc291cmNlSWQ6IHV0aWwuZ2V0VVVJRCgpLCAgXHJcbiAgICAgICAgICAgICAgICBib3VuZHM6IHtcclxuICAgICAgICAgICAgICAgICAgICB1cHBlckxlZnQ6IHt4OiBfa214LCB5OiAxNX0gIFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHN0ZW5jaWw6IHt0eXBlOiBcIlBvaW50Tm9kZVwifVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBwb3J0TW9kZWwuaGVpZ2h0ID0gODtcclxuICAgICAgICAgICAgcG9ydE1vZGVsLndpZHRoID0gODtcclxuICAgICAgICAgICAgdmFyIHBNb2RlbCA9IG5ldyBOZXR3b3JrTW9kZWwocG9ydE1vZGVsKTtcclxuICAgICAgICAgICAgdGhpcy5hZGRQb3J0QnlNb2RlbChwTW9kZWwsIGFwaSk7XHJcbiAgICAgICAgICAgIF9rbXggPSBfa214ICsgMTM7XHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IFttb2RlbC5nZXQoXCJib3VuZHMudXBwZXJMZWZ0LnhcIikgLCBtb2RlbC5nZXQoXCJib3VuZHMudXBwZXJMZWZ0LnlcIildO1xyXG4gICAgfTtcclxuXHJcbiAgICBTZXJ2ZXJYMzU1ME5vZGUucHJvdG90eXBlLmFkZFBvcnRCeU1vZGVsID0gZnVuY3Rpb24oIHBfbW9kZWwsIGFwaSkge1xyXG4gICAgICAgIHZhciBTaGFwZSA9IGFwaS5nZXROb2RlQ2xhc3MocF9tb2RlbC5nZXQoXCJzdGVuY2lsLnR5cGVcIikpO1xyXG4gICAgICAgIHZhciBub2RlID0gbnVsbDtcclxuICAgICAgICBpZiAoIFNoYXBlICkge1xyXG4gICAgICAgICAgICBub2RlID0gbmV3IFNoYXBlKHBfbW9kZWwsIHRoaXMuX2FwaSk7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkKG5vZGUpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgenJVdGlsLmluaGVyaXRzKFNlcnZlclgzNTUwTm9kZSwgTmV0d29ya05vZGUpO1xyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBTZXJ2ZXJYMzU1ME5vZGU7XHJcblxyXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vbGliL2Zpc2gtdG9wby1uZXR3b3JrL2xpYi9ub2RlL3RvcG8vU2VydmVyWDM1NTBOb2RlLmpzXG4gKiogbW9kdWxlIGlkID0gOTlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlxyXG4gICAgdmFyIHV0aWwgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vZmlzaC10b3BvLWNvcmUvbGliL3V0aWwuanNcIik7XHJcbiAgICB2YXIgTmV0d29ya05vZGUgPSByZXF1aXJlKFwiLi4vTmV0d29ya05vZGVcIik7XHJcbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XHJcbiAgICB2YXIgZ3JhcGhpYyA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi9maXNoLXRvcG8tY29yZS9saWIvZ3JhcGhpYy5qc1wiKTtcclxuICAgIHZhciBOZXR3b3JrTW9kZWwgPSByZXF1aXJlKFwiLi4vLi4vbW9kZWwvTmV0d29ya01vZGVsLmpzXCIpO1xyXG4gICAgdmFyIFNlcnZlclRvcG9Ob2RlID0gcmVxdWlyZShcIi4vU2VydmVyVG9wb05vZGVcIik7XHJcbiAgICBcclxuICAgIGZ1bmN0aW9uIFNlcnZlclgzNjUwTm9kZShtb2RlbCxhcGkpIHtcclxuICAgICAgICBTZXJ2ZXJUb3BvTm9kZS5jYWxsKHRoaXMsIG1vZGVsLCBhcGkpO1xyXG4gICAgICAgIHRoaXMucmFja2tJbmZvID0ge3R5cGU6IC0xLCBuYW1lOiBcIlNlcnZlclgzNjUwTm9kZVwiIH07ICAgIFxyXG4gICAgICAgIHRoaXMubW9kZWwgPSBtb2RlbDtcclxuICAgICAgICB0aGlzLnJlbmRlcihtb2RlbCxhcGkpO1xyXG4gICAgfTtcclxuXHJcbiAgICBTZXJ2ZXJYMzY1ME5vZGUucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uKG1vZGVsLCBhcGkpIHtcclxuICAgICAgICB0aGlzLm1vZGVsID0gbW9kZWw7XHJcbiAgICAgICAgdmFyIF9zaG93VGlwID0gbW9kZWwuZ2V0KFwic2hvd1RpcFwiKTtcclxuXHJcbiAgICAgICAgdmFyIF90aXRsZSA9IG5ldyBncmFwaGljLlRleHQoe1xyXG4gICAgICAgICAgICBzdHlsZToge1xyXG4gICAgICAgICAgICAgICAgeDogbW9kZWwuZ2V0KFwid2lkdGhcIikgLyAyIC0gMTAsXHJcbiAgICAgICAgICAgICAgICB5OiAtMjAsXHJcbiAgICAgICAgICAgICAgICB0ZXh0OiBtb2RlbC5nZXQoXCJuYW1lXCIpLFxyXG4gICAgICAgICAgICAgICAgd2lkdGg6IDIwMCxcclxuICAgICAgICAgICAgICAgIGhlaWdodDogMjAsXHJcbiAgICAgICAgICAgICAgICBmaWxsOiAnIzhGOEI4QScsXHJcbiAgICAgICAgICAgICAgICB0ZXh0Rm9udDogJzEycHggTWljcm9zb2Z0IFlhaGVpJyxcclxuICAgICAgICAgICAgICAgIHRleHRCYXNlbGluZTogJ3RvcCdcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZHJhZ2dhYmxlOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5hZGQoX3RpdGxlKTtcclxuXHJcbiAgICAgICAgdmFyIHNlcnZlck5vZGVCID0gbmV3IGdyYXBoaWMuSW1hZ2Uoe1xyXG4gICAgICAgICAgICBwb3NpdGlvbjogWzAsIDBdLFxyXG4gICAgICAgICAgICBzY2FsZTogWzEsIDFdLFxyXG4gICAgICAgICAgICBzdHlsZToge1xyXG4gICAgICAgICAgICAgICAgeDogMCxcclxuICAgICAgICAgICAgICAgIHk6IDAsXHJcbiAgICAgICAgICAgICAgICBpbWFnZTogJy4uLy4uLy4uLy4uZmlzaC10b3BvLW5ldHdvcmsvc3JjL2ltYWdlcy8nICsgbW9kZWwuZ2V0KFwidHlwZVwiKSArICcucG5nJyxcclxuICAgICAgICAgICAgICAgIHdpZHRoOiBtb2RlbC5nZXQoXCJ3aWR0aFwiKSxcclxuICAgICAgICAgICAgICAgIGhlaWdodDogIDgwXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGRyYWdnYWJsZTogZmFsc2UsXHJcbiAgICAgICAgICAgIHBhcm1EYXRlOiB0aGlzLm1vZGVsLmdldChcInBhcm1EYXRlXCIpXHJcbiAgICAgICAgfSk7IFxyXG5cclxuICAgICAgICB2YXIgc2VydmVyTm9kZUEgPSBuZXcgZ3JhcGhpYy5JbWFnZSh7XHJcbiAgICAgICAgICAgIHBvc2l0aW9uOiBbMCwgMF0sXHJcbiAgICAgICAgICAgIHNjYWxlOiBbMSwgMV0sXHJcbiAgICAgICAgICAgIHN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgICB4OiAwLFxyXG4gICAgICAgICAgICAgICAgeTogMCxcclxuICAgICAgICAgICAgICAgIGltYWdlOiAnLi4vLi4vLi4vLi4vZmlzaC10b3BvLW5ldHdvcmsvc3JjL2ltYWdlcy9JQk1YMzY1MGEucG5nJyxcclxuICAgICAgICAgICAgICAgIHdpZHRoOiBtb2RlbC5nZXQoXCJ3aWR0aFwiKSxcclxuICAgICAgICAgICAgICAgIGhlaWdodDogIDgwXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGRyYWdnYWJsZTogZmFsc2UsXHJcbiAgICAgICAgICAgIHBhcm1EYXRlOiB0aGlzLm1vZGVsLmdldChcInBhcm1EYXRlXCIpXHJcbiAgICAgICAgfSk7IFxyXG5cclxuXHJcbiAgICAgICAgc2VydmVyTm9kZUIub24oXCJtb3VzZW92ZXJcIiwgZnVuY3Rpb24ocGFyYW1zKXtcclxuICAgICAgICAgICAgc2VydmVyTm9kZUIuYXR0cihcInBvc2l0aW9uXCIgLCBbLTEwMDAsIC0xMDAwXSk7XHJcbiAgICAgICAgICAgIHNlcnZlck5vZGVBLmF0dHIoXCJwb3NpdGlvblwiLCBbMCwwXSk7XHJcbiAgICAgICAgICAvLyAgc2VydmVyTm9kZUEuc2hvdygpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHNlcnZlck5vZGVBLm9uKFwibW91c2VvdXRcIiwgZnVuY3Rpb24ocGFyYW1zKXtcclxuICAgICAgICAgICAgc2VydmVyTm9kZUEuYXR0cihcInBvc2l0aW9uXCIgLCBbLTEwMDAsIC0xMDAwXSk7XHJcbiAgICAgICAgICAgIHNlcnZlck5vZGVCLmF0dHIoXCJwb3NpdGlvblwiLCBbMCwwXSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHRoaXMuYWRkKHNlcnZlck5vZGVBKTtcclxuICAgICAgICB0aGlzLmFkZChzZXJ2ZXJOb2RlQik7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy/nlLvpu5jorqTnmoTku6XlpKrnvZHnq6/lj6NcclxuICAgICAgICB2YXIgX2tteCA9IDE2NTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7IGkrKyApIHtcclxuICAgICAgICAgICAgdmFyIHBvcnRNb2RlbCA9IHt9O1xyXG4gICAgICAgICAgICBwb3J0TW9kZWwgPSB7XHJcbiAgICAgICAgICAgICAgICByZXNvdXJjZUlkOiB1dGlsLmdldFVVSUQoKSwgIFxyXG4gICAgICAgICAgICAgICAgYm91bmRzOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdXBwZXJMZWZ0OiB7eDogX2tteCwgeTogNTV9ICBcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBzdGVuY2lsOiB7dHlwZTogXCJQb2ludE5vZGVcIn1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgcG9ydE1vZGVsLmhlaWdodCA9IDEwO1xyXG4gICAgICAgICAgICBwb3J0TW9kZWwud2lkdGggPSAxMDtcclxuICAgICAgICAgICAgdmFyIHBNb2RlbCA9IG5ldyBOZXR3b3JrTW9kZWwocG9ydE1vZGVsKTtcclxuICAgICAgICAgICAgdGhpcy5hZGRQb3J0QnlNb2RlbChwTW9kZWwsIGFwaSk7XHJcbiAgICAgICAgICAgIF9rbXggPSBfa214ICsgMTM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLnBvc2l0aW9uID0gW21vZGVsLmdldChcImJvdW5kcy51cHBlckxlZnQueFwiKSAsIG1vZGVsLmdldChcImJvdW5kcy51cHBlckxlZnQueVwiKV07XHJcbiAgICB9O1xyXG5cclxuICAgIFNlcnZlclgzNjUwTm9kZS5wcm90b3R5cGUuYWRkUG9ydEJ5TW9kZWwgPSBmdW5jdGlvbiggcF9tb2RlbCwgYXBpKSB7XHJcbiAgICAgICAgdmFyIFNoYXBlID0gYXBpLmdldE5vZGVDbGFzcyhwX21vZGVsLmdldChcInN0ZW5jaWwudHlwZVwiKSk7XHJcbiAgICAgICAgdmFyIG5vZGUgPSBudWxsO1xyXG4gICAgICAgIGlmICggU2hhcGUgKSB7XHJcbiAgICAgICAgICAgIG5vZGUgPSBuZXcgU2hhcGUocF9tb2RlbCwgdGhpcy5fYXBpKTtcclxuICAgICAgICAgICAgdGhpcy5hZGQobm9kZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICB6clV0aWwuaW5oZXJpdHMoU2VydmVyWDM2NTBOb2RlLCBOZXR3b3JrTm9kZSk7XHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IFNlcnZlclgzNjUwTm9kZTtcclxuXHJcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9saWIvZmlzaC10b3BvLW5ldHdvcmsvbGliL25vZGUvdG9wby9TZXJ2ZXJYMzY1ME5vZGUuanNcbiAqKiBtb2R1bGUgaWQgPSAxMDBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlxyXG4gICAgdmFyIHV0aWwgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vZmlzaC10b3BvLWNvcmUvbGliL3V0aWwuanNcIik7XHJcbiAgICB2YXIgTmV0d29ya05vZGUgPSByZXF1aXJlKFwiLi4vTmV0d29ya05vZGVcIik7XHJcbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XHJcbiAgICB2YXIgZ3JhcGhpYyA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi9maXNoLXRvcG8tY29yZS9saWIvZ3JhcGhpYy5qc1wiKTtcclxuICAgIHZhciBOZXR3b3JrTW9kZWwgPSByZXF1aXJlKFwiLi4vLi4vbW9kZWwvTmV0d29ya01vZGVsLmpzXCIpO1xyXG4gICAgdmFyIFNlcnZlclRvcG9Ob2RlID0gcmVxdWlyZShcIi4vU2VydmVyVG9wb05vZGVcIik7XHJcbiAgICBcclxuICAgIGZ1bmN0aW9uIFNlcnZlclJEMzUwTm9kZShtb2RlbCxhcGkpIHtcclxuICAgICAgICBTZXJ2ZXJUb3BvTm9kZS5jYWxsKHRoaXMsIG1vZGVsLCBhcGkpO1xyXG4gICAgICAgIHRoaXMucmFja2tJbmZvID0ge3R5cGU6IC0xLCBuYW1lOiBcIlNlcnZlclJEMzUwTm9kZVwiIH07ICAgIFxyXG4gICAgICAgIHRoaXMubW9kZWwgPSBtb2RlbDtcclxuICAgICAgICB0aGlzLnJlbmRlcihtb2RlbCxhcGkpO1xyXG4gICAgfTtcclxuXHJcbiAgICBTZXJ2ZXJSRDM1ME5vZGUucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uKG1vZGVsLCBhcGkpIHtcclxuICAgICAgICB0aGlzLm1vZGVsID0gbW9kZWw7XHJcbiAgICAgICAgdmFyIF9zaG93VGlwID0gbW9kZWwuZ2V0KFwic2hvd1RpcFwiKTtcclxuXHJcbiAgICAgICAgdmFyIF90aXRsZSA9IG5ldyBncmFwaGljLlRleHQoe1xyXG4gICAgICAgICAgICBzdHlsZToge1xyXG4gICAgICAgICAgICAgICAgeDogbW9kZWwuZ2V0KFwid2lkdGhcIikgLyAyIC0gMTAsXHJcbiAgICAgICAgICAgICAgICB5OiAtMjAsXHJcbiAgICAgICAgICAgICAgICB0ZXh0OiBtb2RlbC5nZXQoXCJuYW1lXCIpLFxyXG4gICAgICAgICAgICAgICAgd2lkdGg6IDIwMCxcclxuICAgICAgICAgICAgICAgIGhlaWdodDogMjAsXHJcbiAgICAgICAgICAgICAgICBmaWxsOiAnIzhGOEI4QScsXHJcbiAgICAgICAgICAgICAgICB0ZXh0Rm9udDogJzEycHggTWljcm9zb2Z0IFlhaGVpJyxcclxuICAgICAgICAgICAgICAgIHRleHRCYXNlbGluZTogJ3RvcCdcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZHJhZ2dhYmxlOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5hZGQoX3RpdGxlKTtcclxuXHJcbiAgICAgICAgdmFyIHNlcnZlck5vZGVCID0gbmV3IGdyYXBoaWMuSW1hZ2Uoe1xyXG4gICAgICAgICAgICBwb3NpdGlvbjogWzAsIDBdLFxyXG4gICAgICAgICAgICBzY2FsZTogWzEsIDFdLFxyXG4gICAgICAgICAgICBzdHlsZToge1xyXG4gICAgICAgICAgICAgICAgeDogMCxcclxuICAgICAgICAgICAgICAgIHk6IDAsXHJcbiAgICAgICAgICAgICAgICBpbWFnZTogJy4uLy4uLy4uLy4uL2Zpc2gtdG9wby1uZXR3b3JrL3NyYy9pbWFnZXMvbGVub3ZvUmQzNTBiLnBuZycsXHJcbiAgICAgICAgICAgICAgICB3aWR0aDogbW9kZWwuZ2V0KFwid2lkdGhcIiksXHJcbiAgICAgICAgICAgICAgICBoZWlnaHQ6ICA0MFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBkcmFnZ2FibGU6IGZhbHNlXHJcbiAgICAgICAgfSk7IFxyXG5cclxuICAgICAgICB2YXIgc2VydmVyTm9kZUEgPSBuZXcgZ3JhcGhpYy5JbWFnZSh7XHJcbiAgICAgICAgICAgIHBvc2l0aW9uOiBbMCwgMF0sXHJcbiAgICAgICAgICAgIHNjYWxlOiBbMSwgMV0sXHJcbiAgICAgICAgICAgIHN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgICB4OiAwLFxyXG4gICAgICAgICAgICAgICAgeTogMCxcclxuICAgICAgICAgICAgICAgIGltYWdlOiAnLi4vLi4vLi4vLi4vZmlzaC10b3BvLW5ldHdvcmsvc3JjL2ltYWdlcy9sZW5vdm9SZDM1MGEucG5nJyxcclxuICAgICAgICAgICAgICAgIHdpZHRoOiBtb2RlbC5nZXQoXCJ3aWR0aFwiKSxcclxuICAgICAgICAgICAgICAgIGhlaWdodDogIDQwXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHo6IDEwMDAsXHJcbiAgICAgICAgICAgIGRyYWdnYWJsZTogZmFsc2UsXHJcbiAgICAgICAgICAgIHBhcm1EYXRlOiB0aGlzLm1vZGVsLmdldChcInBhcm1EYXRlXCIpXHJcbiAgICAgICAgfSk7IFxyXG5cclxuXHJcbiAgICAgICAgc2VydmVyTm9kZUIub24oXCJtb3VzZW92ZXJcIiwgZnVuY3Rpb24ocGFyYW1zKXtcclxuICAgICAgICAgICAgc2VydmVyTm9kZUIuYXR0cihcInBvc2l0aW9uXCIgLCBbLTEwMDAsIC0xMDAwXSk7XHJcbiAgICAgICAgICAgIHNlcnZlck5vZGVBLmF0dHIoXCJwb3NpdGlvblwiLCBbMCwwXSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgc2VydmVyTm9kZUEub24oXCJtb3VzZW91dFwiLCBmdW5jdGlvbihwYXJhbXMpe1xyXG4gICAgICAgICAgICBzZXJ2ZXJOb2RlQS5hdHRyKFwicG9zaXRpb25cIiAsIFstMTAwMCwgLTEwMDBdKTtcclxuICAgICAgICAgICAgc2VydmVyTm9kZUIuYXR0cihcInBvc2l0aW9uXCIsIFswLDBdKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgdGhpcy5hZGQoc2VydmVyTm9kZUEpO1xyXG4gICAgICAgIHRoaXMuYWRkKHNlcnZlck5vZGVCKTtcclxuICAgICAgICBcclxuICAgICAgICAvL+eUu+m7mOiupOeahOS7peWkque9keerr+WPo1xyXG4gICAgICAgIHZhciBfa214ID0gOTU7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpKysgKSB7XHJcbiAgICAgICAgICAgIHZhciBwb3J0TW9kZWwgPSB7fTtcclxuICAgICAgICAgICAgcG9ydE1vZGVsID0ge1xyXG4gICAgICAgICAgICAgICAgcmVzb3VyY2VJZDogdXRpbC5nZXRVVUlEKCksICBcclxuICAgICAgICAgICAgICAgIGJvdW5kczoge1xyXG4gICAgICAgICAgICAgICAgICAgIHVwcGVyTGVmdDoge3g6IF9rbXgsIHk6IDE1fSAgXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgc3RlbmNpbDoge3R5cGU6IFwiUG9pbnROb2RlXCJ9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHBvcnRNb2RlbC5oZWlnaHQgPSA4O1xyXG4gICAgICAgICAgICBwb3J0TW9kZWwud2lkdGggPSA4O1xyXG4gICAgICAgICAgICB2YXIgcE1vZGVsID0gbmV3IE5ldHdvcmtNb2RlbChwb3J0TW9kZWwpO1xyXG4gICAgICAgICAgICB0aGlzLmFkZFBvcnRCeU1vZGVsKHBNb2RlbCwgYXBpKTtcclxuICAgICAgICAgICAgX2tteCA9IF9rbXggKyAxMztcclxuICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICB0aGlzLnBvc2l0aW9uID0gW21vZGVsLmdldChcImJvdW5kcy51cHBlckxlZnQueFwiKSAsIG1vZGVsLmdldChcImJvdW5kcy51cHBlckxlZnQueVwiKV07XHJcbiAgICB9O1xyXG5cclxuICAgIFNlcnZlclJEMzUwTm9kZS5wcm90b3R5cGUuYWRkUG9ydEJ5TW9kZWwgPSBmdW5jdGlvbiggcF9tb2RlbCwgYXBpKSB7XHJcbiAgICAgICAgdmFyIFNoYXBlID0gYXBpLmdldE5vZGVDbGFzcyhwX21vZGVsLmdldChcInN0ZW5jaWwudHlwZVwiKSk7XHJcbiAgICAgICAgdmFyIG5vZGUgPSBudWxsO1xyXG4gICAgICAgIGlmICggU2hhcGUgKSB7XHJcbiAgICAgICAgICAgIG5vZGUgPSBuZXcgU2hhcGUocF9tb2RlbCwgdGhpcy5fYXBpKTtcclxuICAgICAgICAgICAgdGhpcy5hZGQobm9kZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICB6clV0aWwuaW5oZXJpdHMoU2VydmVyUkQzNTBOb2RlLCBOZXR3b3JrTm9kZSk7XHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IFNlcnZlclJEMzUwTm9kZTtcclxuXHJcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9saWIvZmlzaC10b3BvLW5ldHdvcmsvbGliL25vZGUvdG9wby9TZXJ2ZXJSRDM1ME5vZGUuanNcbiAqKiBtb2R1bGUgaWQgPSAxMDFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlxyXG4gICAgdmFyIHV0aWwgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vZmlzaC10b3BvLWNvcmUvbGliL3V0aWwuanNcIik7XHJcbiAgICB2YXIgTmV0d29ya05vZGUgPSByZXF1aXJlKFwiLi4vTmV0d29ya05vZGVcIik7XHJcbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XHJcbiAgICB2YXIgZ3JhcGhpYyA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi9maXNoLXRvcG8tY29yZS9saWIvZ3JhcGhpYy5qc1wiKTtcclxuICAgIHZhciBOZXR3b3JrTW9kZWwgPSByZXF1aXJlKFwiLi4vLi4vbW9kZWwvTmV0d29ya01vZGVsLmpzXCIpO1xyXG4gICAgdmFyIFNlcnZlclRvcG9Ob2RlID0gcmVxdWlyZShcIi4vU2VydmVyVG9wb05vZGVcIik7XHJcbiAgICBcclxuICAgIGZ1bmN0aW9uIFNlcnZlclJENjUwTm9kZShtb2RlbCxhcGkpIHtcclxuICAgICAgICBTZXJ2ZXJUb3BvTm9kZS5jYWxsKHRoaXMsIG1vZGVsLCBhcGkpO1xyXG4gICAgICAgIHRoaXMucmFja2tJbmZvID0ge3R5cGU6IC0xLCBuYW1lOiBcIlNlcnZlclJENjUwTm9kZVwiIH07ICAgIFxyXG4gICAgICAgIHRoaXMubW9kZWwgPSBtb2RlbDtcclxuICAgICAgICB0aGlzLnJlbmRlcihtb2RlbCxhcGkpO1xyXG4gICAgfTtcclxuXHJcbiAgICBTZXJ2ZXJSRDY1ME5vZGUucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uKG1vZGVsLCBhcGkpIHtcclxuICAgICAgICB0aGlzLm1vZGVsID0gbW9kZWw7XHJcbiAgICAgICAgdmFyIF9zaG93VGlwID0gbW9kZWwuZ2V0KFwic2hvd1RpcFwiKTtcclxuXHJcbiAgICAgICAgdmFyIF90aXRsZSA9IG5ldyBncmFwaGljLlRleHQoe1xyXG4gICAgICAgICAgICBzdHlsZToge1xyXG4gICAgICAgICAgICAgICAgeDogbW9kZWwuZ2V0KFwid2lkdGhcIikgLyAyIC0gMTAsXHJcbiAgICAgICAgICAgICAgICB5OiAtMjAsXHJcbiAgICAgICAgICAgICAgICB0ZXh0OiBtb2RlbC5nZXQoXCJuYW1lXCIpLFxyXG4gICAgICAgICAgICAgICAgd2lkdGg6IDIwMCxcclxuICAgICAgICAgICAgICAgIGhlaWdodDogMjAsXHJcbiAgICAgICAgICAgICAgICBmaWxsOiAnIzhGOEI4QScsXHJcbiAgICAgICAgICAgICAgICB0ZXh0Rm9udDogJzEycHggTWljcm9zb2Z0IFlhaGVpJyxcclxuICAgICAgICAgICAgICAgIHRleHRCYXNlbGluZTogJ3RvcCdcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZHJhZ2dhYmxlOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5hZGQoX3RpdGxlKTtcclxuXHJcbiAgICAgICAgdmFyIHNlcnZlck5vZGVCID0gbmV3IGdyYXBoaWMuSW1hZ2Uoe1xyXG4gICAgICAgICAgICBwb3NpdGlvbjogWzAsIDBdLFxyXG4gICAgICAgICAgICBzY2FsZTogWzEsIDFdLFxyXG4gICAgICAgICAgICBzdHlsZToge1xyXG4gICAgICAgICAgICAgICAgeDogMCxcclxuICAgICAgICAgICAgICAgIHk6IDAsXHJcbiAgICAgICAgICAgICAgICBpbWFnZTogJy4uLy4uLy4uLy4uL2Zpc2gtdG9wby1uZXR3b3JrL3NyYy9pbWFnZXMvbGVub3ZvUmQ2NTBiLnBuZycsXHJcbiAgICAgICAgICAgICAgICB3aWR0aDogbW9kZWwuZ2V0KFwid2lkdGhcIiksXHJcbiAgICAgICAgICAgICAgICBoZWlnaHQ6ICA4MFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBkcmFnZ2FibGU6IGZhbHNlLFxyXG4gICAgICAgICAgICBwYXJtRGF0ZTogdGhpcy5tb2RlbC5nZXQoXCJwYXJtRGF0ZVwiKVxyXG4gICAgICAgIH0pOyBcclxuXHJcbiAgICAgICAgdmFyIHNlcnZlck5vZGVBID0gbmV3IGdyYXBoaWMuSW1hZ2Uoe1xyXG4gICAgICAgICAgICBwb3NpdGlvbjogWzAsIDBdLFxyXG4gICAgICAgICAgICBzY2FsZTogWzEsIDFdLFxyXG4gICAgICAgICAgICBzdHlsZToge1xyXG4gICAgICAgICAgICAgICAgeDogMCxcclxuICAgICAgICAgICAgICAgIHk6IDAsXHJcbiAgICAgICAgICAgICAgICBpbWFnZTogJy4uLy4uLy4uLy4uL2Zpc2gtdG9wby1uZXR3b3JrL3NyYy9pbWFnZXMvbGVub3ZvUmQ2NTBhLnBuZycsXHJcbiAgICAgICAgICAgICAgICB3aWR0aDogbW9kZWwuZ2V0KFwid2lkdGhcIiksXHJcbiAgICAgICAgICAgICAgICBoZWlnaHQ6ICA4MFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB6OiAxMDAwLFxyXG4gICAgICAgICAgICBkcmFnZ2FibGU6IGZhbHNlXHJcbiAgICAgICAgfSk7IFxyXG5cclxuXHJcbiAgICAgICAgc2VydmVyTm9kZUIub24oXCJtb3VzZW92ZXJcIiwgZnVuY3Rpb24ocGFyYW1zKXtcclxuICAgICAgICAgICAgc2VydmVyTm9kZUIuYXR0cihcInBvc2l0aW9uXCIgLCBbLTEwMDAsIC0xMDAwXSk7XHJcbiAgICAgICAgICAgIHNlcnZlck5vZGVBLmF0dHIoXCJwb3NpdGlvblwiLCBbMCwwXSk7XHJcbiAgICAgICAgICAvLyAgc2VydmVyTm9kZUEuc2hvdygpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHNlcnZlck5vZGVBLm9uKFwibW91c2VvdXRcIiwgZnVuY3Rpb24ocGFyYW1zKXtcclxuICAgICAgICAgICAgc2VydmVyTm9kZUEuYXR0cihcInBvc2l0aW9uXCIgLCBbLTEwMDAsIC0xMDAwXSk7XHJcbiAgICAgICAgICAgIHNlcnZlck5vZGVCLmF0dHIoXCJwb3NpdGlvblwiLCBbMCwwXSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHRoaXMuYWRkKHNlcnZlck5vZGVBKTtcclxuICAgICAgICB0aGlzLmFkZChzZXJ2ZXJOb2RlQik7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy/nlLvpu5jorqTnmoTku6XlpKrnvZHnq6/lj6NcclxuICAgICAgICB2YXIgcG9ydE1vZGVsID0ge307XHJcbiAgICAgICAgcG9ydE1vZGVsID0ge1xyXG4gICAgICAgICAgICByZXNvdXJjZUlkOiB1dGlsLmdldFVVSUQoKSwgIFxyXG4gICAgICAgICAgICBib3VuZHM6IHtcclxuICAgICAgICAgICAgICAgIHVwcGVyTGVmdDoge3g6IDg4LCB5OiA1NX0gIFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBzdGVuY2lsOiB7dHlwZTogXCJQb2ludE5vZGVcIn1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHBvcnRNb2RlbC5oZWlnaHQgPSAxMDtcclxuICAgICAgICBwb3J0TW9kZWwud2lkdGggPSAxMDtcclxuICAgICAgICB2YXIgcE1vZGVsID0gbmV3IE5ldHdvcmtNb2RlbChwb3J0TW9kZWwpO1xyXG4gICAgICAgIHRoaXMuYWRkUG9ydEJ5TW9kZWwocE1vZGVsLCBhcGkpO1xyXG5cclxuICAgICAgICB0aGlzLnBvc2l0aW9uID0gW21vZGVsLmdldChcImJvdW5kcy51cHBlckxlZnQueFwiKSAsIG1vZGVsLmdldChcImJvdW5kcy51cHBlckxlZnQueVwiKV07XHJcbiAgICB9O1xyXG5cclxuICAgIFNlcnZlclJENjUwTm9kZS5wcm90b3R5cGUuYWRkUG9ydEJ5TW9kZWwgPSBmdW5jdGlvbiggcF9tb2RlbCwgYXBpKSB7XHJcbiAgICAgICAgdmFyIFNoYXBlID0gYXBpLmdldE5vZGVDbGFzcyhwX21vZGVsLmdldChcInN0ZW5jaWwudHlwZVwiKSk7XHJcbiAgICAgICAgdmFyIG5vZGUgPSBudWxsO1xyXG4gICAgICAgIGlmICggU2hhcGUgKSB7XHJcbiAgICAgICAgICAgIG5vZGUgPSBuZXcgU2hhcGUocF9tb2RlbCwgdGhpcy5fYXBpKTtcclxuICAgICAgICAgICAgdGhpcy5hZGQobm9kZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICB6clV0aWwuaW5oZXJpdHMoU2VydmVyUkQ2NTBOb2RlLCBOZXR3b3JrTm9kZSk7XHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IFNlcnZlclJENjUwTm9kZTtcclxuXHJcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9saWIvZmlzaC10b3BvLW5ldHdvcmsvbGliL25vZGUvdG9wby9TZXJ2ZXJSRDY1ME5vZGUuanNcbiAqKiBtb2R1bGUgaWQgPSAxMDJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlxyXG4gICAgdmFyIHV0aWwgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vZmlzaC10b3BvLWNvcmUvbGliL3V0aWwuanNcIik7XHJcbiAgICB2YXIgTmV0d29ya05vZGUgPSByZXF1aXJlKFwiLi4vTmV0d29ya05vZGVcIik7XHJcbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XHJcbiAgICB2YXIgZ3JhcGhpYyA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi9maXNoLXRvcG8tY29yZS9saWIvZ3JhcGhpYy5qc1wiKTtcclxuICAgIFxyXG4gICAgZnVuY3Rpb24gU3dpdGNoVG9wb05vZGUobW9kZWwsYXBpKSB7XHJcbiAgICAgICAgTmV0d29ya05vZGUuY2FsbCh0aGlzLCBtb2RlbCwgYXBpKTtcclxuICAgICAgICB0aGlzLnJhY2trSW5mbyA9IHt0eXBlOiAtMSwgbmFtZTogXCJTd2l0Y2hUb3BvTm9kZVwiIH07ICAgIFxyXG4gICAgICAgIHRoaXMubW9kZWwgPSBtb2RlbDtcclxuICAgICAgICB0aGlzLnJlbmRlcihtb2RlbCxhcGkpO1xyXG4gICAgfTtcclxuXHJcbiAgICBTd2l0Y2hUb3BvTm9kZS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24obW9kZWwsIGFwaSkge1xyXG4gICAgICAgIFxyXG4gICAgfTtcclxuXHJcbiAgICB6clV0aWwuaW5oZXJpdHMoU3dpdGNoVG9wb05vZGUsIE5ldHdvcmtOb2RlKTtcclxuICAgIG1vZHVsZS5leHBvcnRzID0gU3dpdGNoVG9wb05vZGU7XHJcblxyXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vbGliL2Zpc2gtdG9wby1uZXR3b3JrL2xpYi9ub2RlL3RvcG8vU3dpdGNoVG9wb05vZGUuanNcbiAqKiBtb2R1bGUgaWQgPSAxMDNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlxyXG4gICAgdmFyIHV0aWwgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vZmlzaC10b3BvLWNvcmUvbGliL3V0aWwuanNcIik7XHJcbiAgICB2YXIgTmV0d29ya05vZGUgPSByZXF1aXJlKFwiLi4vTmV0d29ya05vZGVcIik7XHJcbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XHJcbiAgICB2YXIgZ3JhcGhpYyA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi9maXNoLXRvcG8tY29yZS9saWIvZ3JhcGhpYy5qc1wiKTtcclxuICAgIHZhciBOZXR3b3JrTW9kZWwgPSByZXF1aXJlKFwiLi4vLi4vbW9kZWwvTmV0d29ya01vZGVsLmpzXCIpO1xyXG4gICAgdmFyIFN3aXRjaFRvcG9Ob2RlID0gcmVxdWlyZShcIi4vU3dpdGNoVG9wb05vZGVcIik7XHJcbiAgICBcclxuICAgIGZ1bmN0aW9uIFN3aXRjaEhhbGZJQk5vZGUobW9kZWwsYXBpKSB7XHJcbiAgICAgICAgU3dpdGNoVG9wb05vZGUuY2FsbCh0aGlzLCBtb2RlbCwgYXBpKTtcclxuICAgICAgICB0aGlzLnJhY2trSW5mbyA9IHt0eXBlOiAtMSwgbmFtZTogXCJTd2l0Y2hIYWxmSUJOb2RlXCIgfTsgICAgXHJcbiAgICAgICAgdGhpcy5tb2RlbCA9IG1vZGVsO1xyXG4gICAgICAgIHRoaXMucGFybURhdGUgPSB0aGlzLm1vZGVsLmdldChcInBhcm1EYXRlXCIpO1xyXG4gICAgICAgIHRoaXMucG9ydE5vZGVMaXN0ID0gW107XHJcbiAgICAgICAgdGhpcy5yZW5kZXIobW9kZWwsYXBpKTtcclxuICAgIH07XHJcblxyXG4gICAgU3dpdGNoSGFsZklCTm9kZS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24obW9kZWwsIGFwaSkge1xyXG4gICAgICAgIHRoaXMubW9kZWwgPSBtb2RlbDtcclxuICAgICAgICB2YXIgX3Nob3dUaXAgPSBtb2RlbC5nZXQoXCJzaG93VGlwXCIpO1xyXG4gICAgICAgIHZhciBfcG9ydE51bSA9IG1vZGVsLmdldChcInBvcnROdW1cIik7XHJcbiAgICAgICAgdmFyIGltYWdlVXJsID0gXCIuLi8uLi8uLi8uLi9maXNoLXRvcG8tbmV0d29yay9zcmMvaW1hZ2VzL0lCU3dpdGNoSGFsZlwiICsgX3BvcnROdW0gKyBcIi5wbmdcIjtcclxuICAgICAgICB2YXIgX3RpdGxlID0gbmV3IGdyYXBoaWMuVGV4dCh7XHJcbiAgICAgICAgICAgIHN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgICB4OiAxMCxcclxuICAgICAgICAgICAgICAgIHk6IC0yMCxcclxuICAgICAgICAgICAgICAgIHRleHQ6IG1vZGVsLmdldChcIm5hbWVcIiksXHJcbiAgICAgICAgICAgICAgICB3aWR0aDogMTMwLFxyXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAyMCxcclxuICAgICAgICAgICAgICAgIGZpbGw6ICcjOEY4QjhBJyxcclxuICAgICAgICAgICAgICAgIHRleHRGb250OiAnMTJweCBNaWNyb3NvZnQgWWFoZWknLFxyXG4gICAgICAgICAgICAgICAgdGV4dEJhc2VsaW5lOiAndG9wJ1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBkcmFnZ2FibGU6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmFkZChfdGl0bGUpO1xyXG5cclxuICAgICAgICB2YXIgc3dpdGNoTm9kZSA9IG5ldyBncmFwaGljLkltYWdlKHtcclxuICAgICAgICAgICAgcG9zaXRpb246IFswLCAwXSxcclxuICAgICAgICAgICAgc2NhbGU6IFsxLCAxXSxcclxuICAgICAgICAgICAgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgIHg6IDAsXHJcbiAgICAgICAgICAgICAgICB5OiAwLFxyXG4gICAgICAgICAgICAgICAgaW1hZ2U6IGltYWdlVXJsLFxyXG4gICAgICAgICAgICAgICAgd2lkdGg6IG1vZGVsLmdldChcIndpZHRoXCIpLFxyXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAgNDBcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZHJhZ2dhYmxlOiBmYWxzZSxcclxuICAgICAgICAgICAgcGFybURhdGU6IHRoaXMubW9kZWwuZ2V0KFwicGFybURhdGVcIilcclxuICAgICAgICB9KTsgXHJcbiAgICAgICAgdGhpcy5hZGQoc3dpdGNoTm9kZSk7XHJcblxyXG4gICAgICAgIGlmICggX3BvcnROdW0gPT09IFwiMTJcIikge1xyXG4gICAgICAgICAgICB2YXIgX3kgPSAxMjtcclxuICAgICAgICAgICAgdmFyIF94ID0gNDI7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgNzsgaSsrICkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHBvcnRNb2RlbCA9IHt9O1xyXG4gICAgICAgICAgICAgICAgcG9ydE1vZGVsID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc291cmNlSWQ6IHV0aWwuZ2V0VVVJRCgpLCAgXHJcbiAgICAgICAgICAgICAgICAgICAgYm91bmRzOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwcGVyTGVmdDoge3g6IF94LCB5OiBfeX0gIFxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgc3RlbmNpbDoge3R5cGU6IFwiUG9pbnROb2RlXCJ9XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgcG9ydE1vZGVsLmhlaWdodCA9IDY7XHJcbiAgICAgICAgICAgICAgICBwb3J0TW9kZWwud2lkdGggPSAxMTtcclxuICAgICAgICAgICAgICAgIHZhciBfbGluSW5mbyA9IHt9O1xyXG4gICAgICAgICAgICAgICAgX2xpbkluZm8uc291cmNlUmVvdXJjZSA9IHRoaXMubW9kZWwuZ2V0KFwibmFtZVwiKS5zdWJzdHJpbmcodGhpcy5tb2RlbC5nZXQoXCJuYW1lXCIpLmluZGV4T2YoXCJOb1wiKSArIDMgLCB0aGlzLm1vZGVsLmdldChcIm5hbWVcIikubGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgIF9saW5JbmZvLnNvdXJjZVBvcnQgPSBpLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgICAgICBfbGluSW5mby5zb3VyY2VSZW91cmNlTmFtZSA9ICB0aGlzLm1vZGVsLmdldChcIm5hbWVcIikuc3Vic3RyaW5nKDYsIHRoaXMubW9kZWwuZ2V0KFwibmFtZVwiKS5pbmRleE9mKFwiTm9cIikgLSAyKTtcclxuICAgICAgICAgICAgICAgIHBvcnRNb2RlbC5saW5lSW5mbyA9IF9saW5JbmZvO1xyXG4gICAgICAgICAgICAgICAgdmFyIHBNb2RlbCA9IG5ldyBOZXR3b3JrTW9kZWwocG9ydE1vZGVsKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuYWRkUG9ydEJ5TW9kZWwocE1vZGVsLCBhcGkpO1xyXG4gICAgICAgICAgICAgICAgX3ggPSBfeCArIHBvcnRNb2RlbC53aWR0aCArIDM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIF95ID0gMjI7XHJcbiAgICAgICAgICAgIF94ID0gNDI7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSA3OyBpIDwgMTM7IGkrKyApIHtcclxuICAgICAgICAgICAgICAgIHZhciBwb3J0TW9kZWwgPSB7fTtcclxuICAgICAgICAgICAgICAgIHBvcnRNb2RlbCA9IHtcclxuICAgICAgICAgICAgICAgICAgICByZXNvdXJjZUlkOiB1dGlsLmdldFVVSUQoKSwgIFxyXG4gICAgICAgICAgICAgICAgICAgIGJvdW5kczoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB1cHBlckxlZnQ6IHt4OiBfeCwgeTogX3l9ICBcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIHN0ZW5jaWw6IHt0eXBlOiBcIlBvaW50Tm9kZVwifVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIHBvcnRNb2RlbC5oZWlnaHQgPSA2O1xyXG4gICAgICAgICAgICAgICAgcG9ydE1vZGVsLndpZHRoID0gMTE7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2xpbkluZm8gPSB7fTtcclxuICAgICAgICAgICAgICAgIF9saW5JbmZvLnNvdXJjZVJlb3VyY2UgPSB0aGlzLm1vZGVsLmdldChcIm5hbWVcIikuc3Vic3RyaW5nKHRoaXMubW9kZWwuZ2V0KFwibmFtZVwiKS5pbmRleE9mKFwiTm9cIikgKyAzICwgdGhpcy5tb2RlbC5nZXQoXCJuYW1lXCIpLmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICBfbGluSW5mby5zb3VyY2VQb3J0ID0gaS50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgX2xpbkluZm8uc291cmNlUmVvdXJjZU5hbWUgPSAgdGhpcy5tb2RlbC5nZXQoXCJuYW1lXCIpLnN1YnN0cmluZyg2LCB0aGlzLm1vZGVsLmdldChcIm5hbWVcIikuaW5kZXhPZihcIk5vXCIpIC0gMik7XHJcbiAgICAgICAgICAgICAgICBwb3J0TW9kZWwubGluZUluZm8gPSBfbGluSW5mbztcclxuICAgICAgICAgICAgICAgIHZhciBwTW9kZWwgPSBuZXcgTmV0d29ya01vZGVsKHBvcnRNb2RlbCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFkZFBvcnRCeU1vZGVsKHBNb2RlbCwgYXBpKTtcclxuICAgICAgICAgICAgICAgIF94ID0gX3ggKyBwb3J0TW9kZWwud2lkdGggKyAzOyAgICAgXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2UgaWYgKCBfcG9ydE51bSA9PT0gXCI4XCIgKSB7XHJcbiAgICAgICAgICAgIHZhciBfeSA9IDEyO1xyXG4gICAgICAgICAgICB2YXIgX3ggPSA3MDtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCA1OyBpKysgKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcG9ydE1vZGVsID0ge307XHJcbiAgICAgICAgICAgICAgICBwb3J0TW9kZWwgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzb3VyY2VJZDogdXRpbC5nZXRVVUlEKCksICBcclxuICAgICAgICAgICAgICAgICAgICBib3VuZHM6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdXBwZXJMZWZ0OiB7eDogX3gsIHk6IF95fSAgXHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICBzdGVuY2lsOiB7dHlwZTogXCJQb2ludE5vZGVcIn1cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBwb3J0TW9kZWwuaGVpZ2h0ID0gNjtcclxuICAgICAgICAgICAgICAgIHBvcnRNb2RlbC53aWR0aCA9IDExO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9saW5JbmZvID0ge307XHJcbiAgICAgICAgICAgICAgICBfbGluSW5mby5zb3VyY2VSZW91cmNlID0gdGhpcy5tb2RlbC5nZXQoXCJuYW1lXCIpLnN1YnN0cmluZyh0aGlzLm1vZGVsLmdldChcIm5hbWVcIikuaW5kZXhPZihcIk5vXCIpICsgMyAsIHRoaXMubW9kZWwuZ2V0KFwibmFtZVwiKS5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgX2xpbkluZm8uc291cmNlUG9ydCA9IGkudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgIF9saW5JbmZvLnNvdXJjZVJlb3VyY2VOYW1lID0gIHRoaXMubW9kZWwuZ2V0KFwibmFtZVwiKS5zdWJzdHJpbmcoNiwgdGhpcy5tb2RlbC5nZXQoXCJuYW1lXCIpLmluZGV4T2YoXCJOb1wiKSAtIDIpO1xyXG4gICAgICAgICAgICAgICAgcG9ydE1vZGVsLmxpbmVJbmZvID0gX2xpbkluZm87XHJcbiAgICAgICAgICAgICAgICB2YXIgcE1vZGVsID0gbmV3IE5ldHdvcmtNb2RlbChwb3J0TW9kZWwpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hZGRQb3J0QnlNb2RlbChwTW9kZWwsIGFwaSk7XHJcbiAgICAgICAgICAgICAgICBfeCA9IF94ICsgcG9ydE1vZGVsLndpZHRoICsgMztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgX3kgPSAyMjtcclxuICAgICAgICAgICAgX3ggPSA3MDtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDU7IGkgPCA5OyBpKysgKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcG9ydE1vZGVsID0ge307XHJcbiAgICAgICAgICAgICAgICBwb3J0TW9kZWwgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzb3VyY2VJZDogdXRpbC5nZXRVVUlEKCksICBcclxuICAgICAgICAgICAgICAgICAgICBib3VuZHM6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdXBwZXJMZWZ0OiB7eDogX3gsIHk6IF95fSAgXHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICBzdGVuY2lsOiB7dHlwZTogXCJQb2ludE5vZGVcIn1cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBwb3J0TW9kZWwuaGVpZ2h0ID0gNjtcclxuICAgICAgICAgICAgICAgIHBvcnRNb2RlbC53aWR0aCA9IDExO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9saW5JbmZvID0ge307XHJcbiAgICAgICAgICAgICAgICBfbGluSW5mby5zb3VyY2VSZW91cmNlID0gdGhpcy5tb2RlbC5nZXQoXCJuYW1lXCIpLnN1YnN0cmluZyh0aGlzLm1vZGVsLmdldChcIm5hbWVcIikuaW5kZXhPZihcIk5vXCIpICsgMyAsIHRoaXMubW9kZWwuZ2V0KFwibmFtZVwiKS5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgX2xpbkluZm8uc291cmNlUG9ydCA9IGkudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgIF9saW5JbmZvLnNvdXJjZVJlb3VyY2VOYW1lID0gIHRoaXMubW9kZWwuZ2V0KFwibmFtZVwiKS5zdWJzdHJpbmcoNiwgdGhpcy5tb2RlbC5nZXQoXCJuYW1lXCIpLmluZGV4T2YoXCJOb1wiKSAtIDIpO1xyXG4gICAgICAgICAgICAgICAgcG9ydE1vZGVsLmxpbmVJbmZvID0gX2xpbkluZm87XHJcbiAgICAgICAgICAgICAgICB2YXIgcE1vZGVsID0gbmV3IE5ldHdvcmtNb2RlbChwb3J0TW9kZWwpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hZGRQb3J0QnlNb2RlbChwTW9kZWwsIGFwaSk7XHJcbiAgICAgICAgICAgICAgICBfeCA9IF94ICsgcG9ydE1vZGVsLndpZHRoICsgMzsgICAgIFxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuXHJcblxyXG4gICAgICAgIHRoaXMucG9zaXRpb24gPSBbbW9kZWwuZ2V0KFwiYm91bmRzLnVwcGVyTGVmdC54XCIpICwgbW9kZWwuZ2V0KFwiYm91bmRzLnVwcGVyTGVmdC55XCIpXTtcclxuICAgIH07XHJcblxyXG4gICAgU3dpdGNoSGFsZklCTm9kZS5wcm90b3R5cGUuYWRkUG9ydEJ5TW9kZWwgPSBmdW5jdGlvbiggcF9tb2RlbCwgYXBpKSB7XHJcbiAgICAgICAgdmFyIFNoYXBlID0gYXBpLmdldE5vZGVDbGFzcyhwX21vZGVsLmdldChcInN0ZW5jaWwudHlwZVwiKSk7XHJcbiAgICAgICAgdmFyIG5vZGUgPSBudWxsO1xyXG4gICAgICAgIGlmICggU2hhcGUgKSB7XHJcbiAgICAgICAgICAgIG5vZGUgPSBuZXcgU2hhcGUocF9tb2RlbCwgdGhpcy5fYXBpKTtcclxuICAgICAgICAgICAgdGhpcy5hZGQobm9kZSk7XHJcbiAgICAgICAgICAgIHRoaXMucG9ydE5vZGVMaXN0LnB1c2gobm9kZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICB6clV0aWwuaW5oZXJpdHMoU3dpdGNoSGFsZklCTm9kZSwgTmV0d29ya05vZGUpO1xyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBTd2l0Y2hIYWxmSUJOb2RlO1xyXG5cclxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2xpYi9maXNoLXRvcG8tbmV0d29yay9saWIvbm9kZS90b3BvL1N3aXRjaEhhbGZJQk5vZGUuanNcbiAqKiBtb2R1bGUgaWQgPSAxMDRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlxyXG4gICAgdmFyIHV0aWwgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vZmlzaC10b3BvLWNvcmUvbGliL3V0aWwuanNcIik7XHJcbiAgICB2YXIgTmV0d29ya05vZGUgPSByZXF1aXJlKFwiLi4vTmV0d29ya05vZGVcIik7XHJcbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XHJcbiAgICB2YXIgZ3JhcGhpYyA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi9maXNoLXRvcG8tY29yZS9saWIvZ3JhcGhpYy5qc1wiKTtcclxuICAgIHZhciBOZXR3b3JrTW9kZWwgPSByZXF1aXJlKFwiLi4vLi4vbW9kZWwvTmV0d29ya01vZGVsLmpzXCIpO1xyXG4gICAgdmFyIFN3aXRjaFRvcG9Ob2RlID0gcmVxdWlyZShcIi4vU3dpdGNoVG9wb05vZGVcIik7XHJcbiAgICBcclxuICAgIGZ1bmN0aW9uIFN3aXRjaEZ1bGxJQk5vZGUobW9kZWwsYXBpKSB7XHJcbiAgICAgICAgU3dpdGNoVG9wb05vZGUuY2FsbCh0aGlzLCBtb2RlbCwgYXBpKTtcclxuICAgICAgICB0aGlzLnJhY2trSW5mbyA9IHt0eXBlOiAtMSwgbmFtZTogXCJTd2l0Y2hGdWxsSUJOb2RlXCIgfTsgICAgXHJcbiAgICAgICAgdGhpcy5tb2RlbCA9IG1vZGVsO1xyXG4gICAgICAgIHRoaXMucGFybURhdGUgPSB0aGlzLm1vZGVsLmdldChcInBhcm1EYXRlXCIpO1xyXG4gICAgICAgIHRoaXMucG9ydE5vZGVMaXN0ID0gW107XHJcbiAgICAgICAgdGhpcy5yZW5kZXIobW9kZWwsYXBpKTtcclxuICAgIH07XHJcblxyXG4gICAgU3dpdGNoRnVsbElCTm9kZS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24obW9kZWwsIGFwaSkge1xyXG4gICAgICAgIHRoaXMubW9kZWwgPSBtb2RlbDtcclxuICAgICAgICB2YXIgX3Nob3dUaXAgPSBtb2RlbC5nZXQoXCJzaG93VGlwXCIpO1xyXG4gICAgICAgIHZhciBfcG9ydE51bSA9IG1vZGVsLmdldChcInBvcnROdW1cIik7XHJcbiAgICAgICAgdmFyIGltYWdlVXJsID0gXCIuLi8uLi8uLi8uLi9maXNoLXRvcG8tbmV0d29yay9zcmMvaW1hZ2VzL0lCU3dpdGNoRnVsbFwiICsgX3BvcnROdW0gKyBcIi5wbmdcIjtcclxuICAgICAgICB2YXIgX3RpdGxlID0gbmV3IGdyYXBoaWMuVGV4dCh7XHJcbiAgICAgICAgICAgIHN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgICB4OiAyMCxcclxuICAgICAgICAgICAgICAgIHk6IC0yMCxcclxuICAgICAgICAgICAgICAgIHRleHQ6IG1vZGVsLmdldChcIm5hbWVcIiksXHJcbiAgICAgICAgICAgICAgICB3aWR0aDogMjAwLFxyXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAyMCxcclxuICAgICAgICAgICAgICAgIGZpbGw6ICcjOEY4QjhBJyxcclxuICAgICAgICAgICAgICAgIHRleHRGb250OiAnMTJweCBNaWNyb3NvZnQgWWFoZWknLFxyXG4gICAgICAgICAgICAgICAgdGV4dEJhc2VsaW5lOiAndG9wJ1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBkcmFnZ2FibGU6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmFkZChfdGl0bGUpO1xyXG5cclxuICAgICAgICB2YXIgc3dpdGNoTm9kZSA9IG5ldyBncmFwaGljLkltYWdlKHtcclxuICAgICAgICAgICAgcG9zaXRpb246IFswLCAwXSxcclxuICAgICAgICAgICAgc2NhbGU6IFsxLCAxXSxcclxuICAgICAgICAgICAgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgIHg6IDAsXHJcbiAgICAgICAgICAgICAgICB5OiAwLFxyXG4gICAgICAgICAgICAgICAgaW1hZ2U6IGltYWdlVXJsLFxyXG4gICAgICAgICAgICAgICAgd2lkdGg6IG1vZGVsLmdldChcIndpZHRoXCIpLFxyXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiA0MFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBkcmFnZ2FibGU6IGZhbHNlLFxyXG4gICAgICAgICAgICBwYXJtRGF0ZTogdGhpcy5tb2RlbC5nZXQoXCJwYXJtRGF0ZVwiKVxyXG4gICAgICAgIH0pOyBcclxuICAgICAgICB0aGlzLmFkZChzd2l0Y2hOb2RlKTtcclxuXHJcbiAgICAgICAgdmFyIF95ID0gMTQ7XHJcbiAgICAgICAgdmFyIF94ID0gMTg7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCAxOTsgaSsrICkge1xyXG4gICAgICAgICAgICB2YXIgcG9ydE1vZGVsID0ge307XHJcbiAgICAgICAgICAgIHBvcnRNb2RlbCA9IHtcclxuICAgICAgICAgICAgICAgIHJlc291cmNlSWQ6IHV0aWwuZ2V0VVVJRCgpLCAgXHJcbiAgICAgICAgICAgICAgICBib3VuZHM6IHtcclxuICAgICAgICAgICAgICAgICAgICB1cHBlckxlZnQ6IHt4OiBfeCwgeTogX3l9ICBcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBzdGVuY2lsOiB7dHlwZTogXCJQb2ludE5vZGVcIn1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgcG9ydE1vZGVsLmhlaWdodCA9IDY7XHJcbiAgICAgICAgICAgIHBvcnRNb2RlbC53aWR0aCA9IDExO1xyXG4gICAgICAgICAgICB2YXIgX2xpbkluZm8gPSB7fTtcclxuICAgICAgICAgICAgX2xpbkluZm8uc291cmNlUmVvdXJjZSA9IHRoaXMubW9kZWwuZ2V0KFwibmFtZVwiKS5zdWJzdHJpbmcodGhpcy5tb2RlbC5nZXQoXCJuYW1lXCIpLmluZGV4T2YoXCJOb1wiKSArIDMgLCB0aGlzLm1vZGVsLmdldChcIm5hbWVcIikubGVuZ3RoKTtcclxuICAgICAgICAgICAgX2xpbkluZm8uc291cmNlUG9ydCA9IGkudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgX2xpbkluZm8uc291cmNlUmVvdXJjZU5hbWUgPSAgdGhpcy5tb2RlbC5nZXQoXCJuYW1lXCIpLnN1YnN0cmluZyg2LCB0aGlzLm1vZGVsLmdldChcIm5hbWVcIikuaW5kZXhPZihcIk5vXCIpIC0gMiApO1xyXG4gICAgICAgICAgICBwb3J0TW9kZWwubGluZUluZm8gPSBfbGluSW5mbztcclxuICAgICAgICAgICAgdmFyIHBNb2RlbCA9IG5ldyBOZXR3b3JrTW9kZWwocG9ydE1vZGVsKTtcclxuICAgICAgICAgICAgdGhpcy5hZGRQb3J0QnlNb2RlbChwTW9kZWwsIGFwaSk7XHJcbiAgICAgICAgICAgIGlmIChpICUgMyA9PT0gMCApIHtcclxuICAgICAgICAgICAgICAgIF94ID0gX3ggKyBwb3J0TW9kZWwud2lkdGggKyA1O1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgX3ggPSBfeCArIHBvcnRNb2RlbC53aWR0aCArIDI7XHJcbiAgICAgICAgICAgIH0gICAgICAgXHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIGlmICggX3BvcnROdW0gPiAxOCApIHtcclxuICAgICAgICAgICAgX3kgPSAyNDtcclxuICAgICAgICAgICAgX3ggPSAxODtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE5OyBpIDwgMzc7IGkrKyApIHtcclxuICAgICAgICAgICAgICAgIHZhciBwb3J0TW9kZWwgPSB7fTtcclxuICAgICAgICAgICAgICAgIHBvcnRNb2RlbCA9IHtcclxuICAgICAgICAgICAgICAgICAgICByZXNvdXJjZUlkOiB1dGlsLmdldFVVSUQoKSwgIFxyXG4gICAgICAgICAgICAgICAgICAgIGJvdW5kczoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB1cHBlckxlZnQ6IHt4OiBfeCwgeTogX3l9ICBcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIHN0ZW5jaWw6IHt0eXBlOiBcIlBvaW50Tm9kZVwifVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIHBvcnRNb2RlbC5oZWlnaHQgPSA2O1xyXG4gICAgICAgICAgICAgICAgcG9ydE1vZGVsLndpZHRoID0gMTE7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2xpbkluZm8gPSB7fTtcclxuICAgICAgICAgICAgICAgIF9saW5JbmZvLnNvdXJjZVJlb3VyY2UgPSB0aGlzLm1vZGVsLmdldChcIm5hbWVcIikuc3Vic3RyaW5nKHRoaXMubW9kZWwuZ2V0KFwibmFtZVwiKS5pbmRleE9mKFwiTm9cIikgKyAzICwgdGhpcy5tb2RlbC5nZXQoXCJuYW1lXCIpLmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICBfbGluSW5mby5zb3VyY2VQb3J0ID0gaS50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgX2xpbkluZm8uc291cmNlUmVvdXJjZU5hbWUgPSAgdGhpcy5tb2RlbC5nZXQoXCJuYW1lXCIpLnN1YnN0cmluZyg2LCB0aGlzLm1vZGVsLmdldChcIm5hbWVcIikuaW5kZXhPZihcIk5vXCIpIC0gMiApO1xyXG4gICAgICAgICAgICAgICAgcG9ydE1vZGVsLmxpbmVJbmZvID0gX2xpbkluZm87XHJcbiAgICAgICAgICAgICAgICB2YXIgcE1vZGVsID0gbmV3IE5ldHdvcmtNb2RlbChwb3J0TW9kZWwpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hZGRQb3J0QnlNb2RlbChwTW9kZWwsIGFwaSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoaSAlIDMgPT09IDAgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3ggPSBfeCArIHBvcnRNb2RlbC53aWR0aCArIDU7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIF94ID0gX3ggKyBwb3J0TW9kZWwud2lkdGggKyAyO1xyXG4gICAgICAgICAgICAgICAgfSAgICAgICBcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICB0aGlzLnBvc2l0aW9uID0gW21vZGVsLmdldChcImJvdW5kcy51cHBlckxlZnQueFwiKSAsIG1vZGVsLmdldChcImJvdW5kcy51cHBlckxlZnQueVwiKV07XHJcbiAgICB9O1xyXG5cclxuICAgICBTd2l0Y2hGdWxsSUJOb2RlLnByb3RvdHlwZS5hZGRQb3J0QnlNb2RlbCA9IGZ1bmN0aW9uKCBwX21vZGVsLCBhcGkpIHtcclxuICAgICAgICB2YXIgU2hhcGUgPSBhcGkuZ2V0Tm9kZUNsYXNzKHBfbW9kZWwuZ2V0KFwic3RlbmNpbC50eXBlXCIpKTtcclxuICAgICAgICB2YXIgbm9kZSA9IG51bGw7XHJcbiAgICAgICAgaWYgKCBTaGFwZSApIHtcclxuICAgICAgICAgICAgbm9kZSA9IG5ldyBTaGFwZShwX21vZGVsLCB0aGlzLl9hcGkpO1xyXG4gICAgICAgICAgICB0aGlzLnBvcnROb2RlTGlzdC5wdXNoKG5vZGUpO1xyXG4gICAgICAgICAgICB0aGlzLmFkZChub2RlKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHpyVXRpbC5pbmhlcml0cyhTd2l0Y2hGdWxsSUJOb2RlLCBOZXR3b3JrTm9kZSk7XHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IFN3aXRjaEZ1bGxJQk5vZGU7XHJcblxyXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vbGliL2Zpc2gtdG9wby1uZXR3b3JrL2xpYi9ub2RlL3RvcG8vU3dpdGNoRnVsbElCTm9kZS5qc1xuICoqIG1vZHVsZSBpZCA9IDEwNVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXHJcbiAgICB2YXIgdXRpbCA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi9maXNoLXRvcG8tY29yZS9saWIvdXRpbC5qc1wiKTtcclxuICAgIHZhciBOZXR3b3JrTm9kZSA9IHJlcXVpcmUoXCIuLi9OZXR3b3JrTm9kZVwiKTtcclxuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcclxuICAgIHZhciBncmFwaGljID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uL2Zpc2gtdG9wby1jb3JlL2xpYi9ncmFwaGljLmpzXCIpO1xyXG4gICAgdmFyIE5ldHdvcmtNb2RlbCA9IHJlcXVpcmUoXCIuLi8uLi9tb2RlbC9OZXR3b3JrTW9kZWwuanNcIik7XHJcbiAgICB2YXIgU3dpdGNoVG9wb05vZGUgPSByZXF1aXJlKFwiLi9Td2l0Y2hUb3BvTm9kZVwiKTtcclxuICAgIFxyXG4gICAgZnVuY3Rpb24gU3dpdGNoR01Ob2RlKG1vZGVsLGFwaSkge1xyXG4gICAgICAgIFN3aXRjaFRvcG9Ob2RlLmNhbGwodGhpcywgbW9kZWwsIGFwaSk7XHJcbiAgICAgICAgdGhpcy5yYWNra0luZm8gPSB7dHlwZTogLTEsIG5hbWU6IFwiU3dpdGNoR01Ob2RlXCIgfTsgICAgXHJcbiAgICAgICAgdGhpcy5tb2RlbCA9IG1vZGVsO1xyXG4gICAgICAgIHRoaXMucmVuZGVyKG1vZGVsLGFwaSk7XHJcbiAgICB9O1xyXG5cclxuICAgIFN3aXRjaEdNTm9kZS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24obW9kZWwsIGFwaSkge1xyXG4gICAgICAgIHRoaXMubW9kZWwgPSBtb2RlbDtcclxuICAgICAgICB2YXIgX3Nob3dUaXAgPSBtb2RlbC5nZXQoXCJzaG93VGlwXCIpO1xyXG5cclxuICAgICAgICB2YXIgX3RpdGxlID0gbmV3IGdyYXBoaWMuVGV4dCh7XHJcbiAgICAgICAgICAgIHN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgICB4OiBtb2RlbC5nZXQoXCJ3aWR0aFwiKSAvIDIgLSAxMCxcclxuICAgICAgICAgICAgICAgIHk6IC0yMCxcclxuICAgICAgICAgICAgICAgIHRleHQ6IG1vZGVsLmdldChcIm5hbWVcIiksXHJcbiAgICAgICAgICAgICAgICB3aWR0aDogMjAwLFxyXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAyMCxcclxuICAgICAgICAgICAgICAgIGZpbGw6ICcjOEY4QjhBJyxcclxuICAgICAgICAgICAgICAgIHRleHRGb250OiAnMTJweCBNaWNyb3NvZnQgWWFoZWknLFxyXG4gICAgICAgICAgICAgICAgdGV4dEJhc2VsaW5lOiAndG9wJ1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBkcmFnZ2FibGU6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmFkZChfdGl0bGUpO1xyXG5cclxuICAgICAgICB2YXIgc3dpdGNoTm9kZSA9IG5ldyBncmFwaGljLkltYWdlKHtcclxuICAgICAgICAgICAgcG9zaXRpb246IFswLCAwXSxcclxuICAgICAgICAgICAgc2NhbGU6IFsxLCAxXSxcclxuICAgICAgICAgICAgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgIHg6IDAsXHJcbiAgICAgICAgICAgICAgICB5OiAwLFxyXG4gICAgICAgICAgICAgICAgaW1hZ2U6ICcuLi8uLi8uLi8uLi9maXNoLXRvcG8tbmV0d29yay9zcmMvaW1hZ2VzL0dNU3dpdGNoLnBuZycsXHJcbiAgICAgICAgICAgICAgICB3aWR0aDogbW9kZWwuZ2V0KFwid2lkdGhcIiksXHJcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDQwXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGRyYWdnYWJsZTogZmFsc2UsXHJcbiAgICAgICAgICAgIHBhcm1EYXRlOiB0aGlzLm1vZGVsLmdldChcInBhcm1EYXRlXCIpXHJcbiAgICAgICAgfSk7IFxyXG4gICAgICAgIHRoaXMuYWRkKHN3aXRjaE5vZGUpO1xyXG5cclxuICAgICAgICB0aGlzLnBvc2l0aW9uID0gW21vZGVsLmdldChcImJvdW5kcy51cHBlckxlZnQueFwiKSAsIG1vZGVsLmdldChcImJvdW5kcy51cHBlckxlZnQueVwiKV07XHJcbiAgICB9O1xyXG5cclxuICAgXHJcblxyXG4gICAgenJVdGlsLmluaGVyaXRzKFN3aXRjaEdNTm9kZSwgTmV0d29ya05vZGUpO1xyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBTd2l0Y2hHTU5vZGU7XHJcblxyXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vbGliL2Zpc2gtdG9wby1uZXR3b3JrL2xpYi9ub2RlL3RvcG8vU3dpdGNoR01Ob2RlLmpzXG4gKiogbW9kdWxlIGlkID0gMTA2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcclxuICAgIHZhciB1dGlsID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uL2Zpc2gtdG9wby1jb3JlL2xpYi91dGlsLmpzXCIpO1xyXG4gICAgdmFyIE5ldHdvcmtOb2RlID0gcmVxdWlyZShcIi4uL05ldHdvcmtOb2RlXCIpO1xyXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xyXG4gICAgdmFyIGdyYXBoaWMgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vZmlzaC10b3BvLWNvcmUvbGliL2dyYXBoaWMuanNcIik7XHJcbiAgICB2YXIgTmV0d29ya01vZGVsID0gcmVxdWlyZShcIi4uLy4uL21vZGVsL05ldHdvcmtNb2RlbC5qc1wiKTtcclxuICAgIHZhciBTd2l0Y2hUb3BvTm9kZSA9IHJlcXVpcmUoXCIuL1N3aXRjaFRvcG9Ob2RlXCIpO1xyXG4gICAgXHJcbiAgICBmdW5jdGlvbiBTd2l0Y2hLTU5vZGUobW9kZWwsYXBpKSB7XHJcbiAgICAgICAgU3dpdGNoVG9wb05vZGUuY2FsbCh0aGlzLCBtb2RlbCwgYXBpKTtcclxuICAgICAgICAvL3RoaXMucmFja2tJbmZvID0ge3R5cGU6IC0xLCBuYW1lOiBcIlN3aXRjaEtNTm9kZVwiIH07ICAgIFxyXG4gICAgICAgIHRoaXMubW9kZWwgPSBtb2RlbDtcclxuICAgICAgICB0aGlzLnBhcm1EYXRlID0gdGhpcy5tb2RlbC5nZXQoXCJwYXJtRGF0ZVwiKTtcclxuICAgICAgICB0aGlzLnBvcnROb2RlTGlzdCA9IFtdO1xyXG4gICAgICAgIHRoaXMucmVuZGVyKG1vZGVsLGFwaSk7XHJcbiAgICB9O1xyXG5cclxuICAgIFN3aXRjaEtNTm9kZS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24obW9kZWwsIGFwaSkge1xyXG4gICAgICAgIHRoaXMubW9kZWwgPSBtb2RlbDtcclxuICAgICAgICB2YXIgX3Nob3dUaXAgPSBtb2RlbC5nZXQoXCJzaG93VGlwXCIpO1xyXG5cclxuICAgICAgICB2YXIgX3RpdGxlID0gbmV3IGdyYXBoaWMuVGV4dCh7XHJcbiAgICAgICAgICAgIHN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgICB4OiBtb2RlbC5nZXQoXCJ3aWR0aFwiKSAvIDIgLSAxMCxcclxuICAgICAgICAgICAgICAgIHk6IC0yMCxcclxuICAgICAgICAgICAgICAgIHRleHQ6IG1vZGVsLmdldChcIm5hbWVcIiksXHJcbiAgICAgICAgICAgICAgICB3aWR0aDogMjAwLFxyXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAyMCxcclxuICAgICAgICAgICAgICAgIGZpbGw6ICcjOEY4QjhBJyxcclxuICAgICAgICAgICAgICAgIHRleHRGb250OiAnMTJweCBNaWNyb3NvZnQgWWFoZWknLFxyXG4gICAgICAgICAgICAgICAgdGV4dEJhc2VsaW5lOiAndG9wJ1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBkcmFnZ2FibGU6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmFkZChfdGl0bGUpO1xyXG5cclxuICAgICAgICB2YXIgc3dpdGNoTm9kZSA9IG5ldyBncmFwaGljLkltYWdlKHtcclxuICAgICAgICAgICAgcG9zaXRpb246IFswLCAwXSxcclxuICAgICAgICAgICAgc2NhbGU6IFsxLCAxXSxcclxuICAgICAgICAgICAgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgIHg6IDAsXHJcbiAgICAgICAgICAgICAgICB5OiAwLFxyXG4gICAgICAgICAgICAgICAgaW1hZ2U6ICcuLi8uLi8uLi8uLi9maXNoLXRvcG8tbmV0d29yay9zcmMvaW1hZ2VzL0tNU3dpdGNoLnBuZycsXHJcbiAgICAgICAgICAgICAgICB3aWR0aDogbW9kZWwuZ2V0KFwid2lkdGhcIiksXHJcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDQwXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGRyYWdnYWJsZTogZmFsc2UsXHJcbiAgICAgICAgICAgIHBhcm1EYXRlOiB0aGlzLm1vZGVsLmdldChcInBhcm1EYXRlXCIpXHJcbiAgICAgICAgfSk7IFxyXG4gICAgICAgIHRoaXMuYWRkKHN3aXRjaE5vZGUpO1xyXG5cclxuXHJcbiAgICAgICAgLy/vv73Lv++/vVxyXG4gICAgICAgIHZhciBwb3J0TW9kZWwgPSB7fTtcclxuICAgICAgICBwb3J0TW9kZWwgPSB7XHJcbiAgICAgICAgICAgIHJlc291cmNlSWQ6IHV0aWwuZ2V0VVVJRCgpLCAgXHJcbiAgICAgICAgICAgIGJvdW5kczoge1xyXG4gICAgICAgICAgICAgICAgdXBwZXJMZWZ0OiB7eDptb2RlbC5nZXQoXCJ3aWR0aFwiKSAvIDIsIHk6IDEwfSAgXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHN0ZW5jaWw6IHt0eXBlOiBcIlBvaW50Tm9kZVwifVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcG9ydE1vZGVsLmhlaWdodCA9IDY7XHJcbiAgICAgICAgcG9ydE1vZGVsLndpZHRoID0gMTE7XHJcbiAgICAgICAgdmFyIF9saW5JbmZvID0ge307XHJcbiAgICAgICAgX2xpbkluZm8uc291cmNlUmVvdXJjZSA9IG1vZGVsLmdldChcIm5hbWVcIik7XHJcbiAgICAgICAgX2xpbkluZm8uc291cmNlUG9ydCA9IFwiLTFcIjtcclxuICAgICAgICBwb3J0TW9kZWwubGluZUluZm8gPSBfbGluSW5mbztcclxuICAgICAgICB2YXIgcE1vZGVsID0gbmV3IE5ldHdvcmtNb2RlbChwb3J0TW9kZWwpO1xyXG4gICAgICAgIHRoaXMuYWRkUG9ydEJ5TW9kZWwocE1vZGVsLCBhcGkpO1xyXG5cclxuICAgICAgICB0aGlzLnBvc2l0aW9uID0gW21vZGVsLmdldChcImJvdW5kcy51cHBlckxlZnQueFwiKSAsIG1vZGVsLmdldChcImJvdW5kcy51cHBlckxlZnQueVwiKV07XHJcbiAgICB9O1xyXG5cclxuICAgIFN3aXRjaEtNTm9kZS5wcm90b3R5cGUuYWRkUG9ydEJ5TW9kZWwgPSBmdW5jdGlvbiggcF9tb2RlbCwgYXBpKSB7XHJcbiAgICAgICAgdmFyIFNoYXBlID0gYXBpLmdldE5vZGVDbGFzcyhwX21vZGVsLmdldChcInN0ZW5jaWwudHlwZVwiKSk7XHJcbiAgICAgICAgdmFyIG5vZGUgPSBudWxsO1xyXG4gICAgICAgIGlmICggU2hhcGUgKSB7XHJcbiAgICAgICAgICAgIG5vZGUgPSBuZXcgU2hhcGUocF9tb2RlbCwgdGhpcy5fYXBpKTtcclxuICAgICAgICAgICAgdGhpcy5wb3J0Tm9kZUxpc3QucHVzaChub2RlKTtcclxuICAgICAgICAgICAgdGhpcy5hZGQobm9kZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcblxyXG4gICAgenJVdGlsLmluaGVyaXRzKFN3aXRjaEtNTm9kZSwgTmV0d29ya05vZGUpO1xyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBTd2l0Y2hLTU5vZGU7XHJcblxyXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vbGliL2Zpc2gtdG9wby1uZXR3b3JrL2xpYi9ub2RlL3RvcG8vU3dpdGNoS01Ob2RlLmpzXG4gKiogbW9kdWxlIGlkID0gMTA3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcclxuICAgIHZhciB1dGlsID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uL2Zpc2gtdG9wby1jb3JlL2xpYi91dGlsLmpzXCIpO1xyXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xyXG4gICAgdmFyIGdyYXBoaWMgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vZmlzaC10b3BvLWNvcmUvbGliL2dyYXBoaWMuanNcIik7XHJcbiAgICB2YXIgTmV0d29ya05vZGUgPSByZXF1aXJlKFwiLi4vTmV0d29ya05vZGUuanNcIik7XHJcbiAgICB2YXIgTmV0V29ya0xpbmVOb2RlID0gcmVxdWlyZShcIi4uL05ldFdvcmtMaW5lTm9kZS5qc1wiKTtcclxuICAgIHZhciBOZXR3b3JrTW9kZWwgPSByZXF1aXJlKFwiLi4vLi4vbW9kZWwvTmV0d29ya01vZGVsLmpzXCIpO1xyXG4gICAgdmFyIERhdGFiYXNlTW9kZWwgPSByZXF1aXJlKFwiLi4vLi4vbW9kZWwvY2x1c3Rlci9EYXRhYmFzZU1vZGVsLmpzXCIpO1xyXG5cdHZhciBBc21Nb2RlbCA9IHJlcXVpcmUoXCIuLi8uLi9tb2RlbC9jbHVzdGVyL0FzbU1vZGVsLmpzXCIpO1xyXG5cdHZhciBJU0VNb2RlbCA9IHJlcXVpcmUoXCIuLi8uLi9tb2RlbC9jbHVzdGVyL0lTRU1vZGVsLmpzXCIpO1xyXG4gICAgdmFyIE5ldFdvcmtMaW5lTW9kZWwgPSByZXF1aXJlKFwiLi4vLi4vbW9kZWwvTmV0V29ya0xpbmVNb2RlbC5qc1wiKTtcclxuICAgIHZhciBDb25uZWN0b3IgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vZmlzaC10b3BvLWNvcmUvbGliL3NoYXBlcy9Db25uZWN0b3IuanNcIik7XHJcblxyXG5cclxuICAgIGZ1bmN0aW9uIENsdXN0ZXJEcmF3Tm9kZShtb2RlbCwgYXBpKSB7XHJcbiAgICAgICAgTmV0d29ya05vZGUuY2FsbCh0aGlzLCBtb2RlbCwgYXBpKTtcclxuICAgICAgICB0aGlzLmluZm8gPSB7dHlwZTogLTEsIG5hbWU6IFwiQ2x1c3RlckRyYXdOb2RlXCIgfTsgICAgXHJcbiAgICAgICAgdGhpcy5tb2RlbCA9IG1vZGVsO1xyXG4gICAgICAgIHRoaXMuZGF0YWJhc2VMaXN0ID0gW107XHJcbiAgICAgICAgdGhpcy5kZ0xpc3QgPSBbXTtcclxuICAgICAgICB0aGlzLnJlbmRlcihtb2RlbCwgYXBpKTtcclxuICAgIH07XHJcblxyXG4gICAgQ2x1c3RlckRyYXdOb2RlLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbihtb2RlbCwgYXBpKSB7XHJcbiAgICBcdHZhciBub2RlTGlzdCA9IG1vZGVsLmdldChcIm5vZGVMaXN0XCIpO1xyXG4gICAgICAgIHZhciBfc2hvd1RpcCA9IG1vZGVsLmdldChcInNob3dUaXBcIik7XHJcbiAgICAgICAgdmFyIGRhdGFNb2RlbERhdGEgPSB7fTtcclxuICAgIFx0dmFyIGFzbU1vZGVsRGF0YSA9IHt9O1xyXG4gICAgXHR2YXIgc3RvcmFnZU1vZGVsRGF0YSA9IHt9O1xyXG4gICAgXHR2YXIgX2RnTGlzdCA9IFtdO1xyXG4gICAgXHRmb3IoIHZhciBpID0gMDsgaSA8IG5vZGVMaXN0Lmxlbmd0aDsgaSsrICkge1xyXG4gICAgXHRcdHZhciBub2RlWSA9IDEwO1xyXG4gICAgICAgICAgICB2YXIgc3RhcnRYID0gMDtcclxuICAgIFx0XHRpZiAoIG5vZGVMaXN0W2ldLnR5cGUgPT09IFwiZGF0YWJhc2VcIiApIHtcclxuICAgIFx0XHRcdHZhciBkYkRhdGEgPSBub2RlTGlzdFtpXS5kYkRhdGE7XHJcbiAgICBcdFx0XHRpZiAoIGRiRGF0YSAhPSB1bmRlZmluZWQgJiYgZGJEYXRhLmxlbmd0aCA+IDAgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YU1vZGVsRGF0YSA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb3VyY2VJZDogdXRpbC5nZXRVVUlEKCksICBcclxuICAgICAgICAgICAgICAgICAgICAgICAgYm91bmRzOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cHBlckxlZnQ6IHt4OiBzdGFydFgsIHk6IG5vZGVZfSAgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0ZW5jaWw6IHt0eXBlOiBcIkNsdXN0ZXJEYXRhYmFzZU5vZGVcIn1cclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIGRhdGFNb2RlbERhdGEuZGJEYXRhID0gZGJEYXRhO1xyXG4gICAgICAgICAgICAgICAgICAgIGRhdGFNb2RlbERhdGEuc2hvd1RpcCA9IF9zaG93VGlwO1xyXG4gICAgXHRcdFx0fVx0XHJcbiAgICBcdFx0fSBlbHNlIGlmKCBub2RlTGlzdFtpXS50eXBlID09PSBcImFzbVwiKSB7XHJcbiAgICBcdFx0XHR2YXIgc3RhcnRYID0gMDtcclxuICAgIFx0XHRcdG5vZGVZID0gMjUwO1xyXG4gICAgXHRcdFx0YXNtTW9kZWxEYXRhID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc291cmNlSWQ6IHV0aWwuZ2V0VVVJRCgpLCAgXHJcbiAgICAgICAgICAgICAgICAgICAgYm91bmRzOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwcGVyTGVmdDoge3g6IHN0YXJ0WCwgeTogbm9kZVl9ICBcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIHN0ZW5jaWw6IHt0eXBlOiBcIkNsdXN0ZXJBc21Ob2RlXCJ9XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgYXNtTW9kZWxEYXRhLm5hbWUgPSBub2RlTGlzdFtpXS5uYW1lO1xyXG4gICAgICAgICAgICAgICAgYXNtTW9kZWxEYXRhLmFzbURhdGEgPSBub2RlTGlzdFtpXS5hc21EYXRhO1xyXG4gICAgICAgICAgICAgICAgYXNtTW9kZWxEYXRhLmRnRGF0YSA9IG5vZGVMaXN0W2ldLmRnRGF0YTtcclxuICAgICAgICAgICAgICAgIGFzbU1vZGVsRGF0YS5zdGF0dXMgPSBub2RlTGlzdFtpXS5zdGF0dXM7XHJcbiAgICAgICAgICAgICAgICBhc21Nb2RlbERhdGEuc2hvd1RpcCA9IF9zaG93VGlwO1xyXG4gICAgXHRcdH0gZWxzZSBpZiggbm9kZUxpc3RbaV0udHlwZSA9PT0gXCJzdG9yYWdlXCIgKSB7XHJcbiAgICBcdFx0XHR2YXIgc3RhcnRYID0gMDtcclxuICAgIFx0XHRcdG5vZGVZID0gNTUwO1xyXG4gICAgXHRcdFx0c3RvcmFnZU1vZGVsRGF0YSA9IHtcclxuICAgICAgICAgICAgICAgICAgICByZXNvdXJjZUlkOiB1dGlsLmdldFVVSUQoKSwgIFxyXG4gICAgICAgICAgICAgICAgICAgIGJvdW5kczoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB1cHBlckxlZnQ6IHt4OiBzdGFydFgsIHk6IG5vZGVZfSAgXHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICBzdGVuY2lsOiB7dHlwZTogXCJDbHVzdGVySXNlTm9kZVwifVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIHN0b3JhZ2VNb2RlbERhdGEuY2hpbGROb2RlTGlzdCA9IG5vZGVMaXN0W2ldLmlzZURhdGE7XHJcbiAgICAgICAgICAgICAgICBzdG9yYWdlTW9kZWxEYXRhLnNob3dUaXAgPSBfc2hvd1RpcDtcclxuICAgIFx0XHR9XHJcblxyXG4gICAgXHR9XHJcblxyXG4gICAgICAgIHZhciBkYXRhYmFzZU1vZGVsID0gbmV3IERhdGFiYXNlTW9kZWwoZGF0YU1vZGVsRGF0YSk7XHJcbiAgICAgICAgdGhpcy5hZGROb2RlQnlNb2RlbChkYXRhYmFzZU1vZGVsLCBhcGkpO1xyXG5cclxuICAgICAgICBcclxuICAgICAgICAvL+eUu+efqeW9olxyXG4gICAgICAgIHZhciBtYW5nZXJOb2RlID0gbmV3IGdyYXBoaWMuUmVjdCh7XHJcbiAgICAgICAgICAgIHNoYXBlOiB7XHJcbiAgICAgICAgICAgICAgICByOiAyMCxcclxuICAgICAgICAgICAgICAgIHg6IDUwLFxyXG4gICAgICAgICAgICAgICAgeTogMzAwLFxyXG4gICAgICAgICAgICAgICAgd2lkdGg6IGFwaS5nZXRXaWR0aCgpIC0gMTAwLFxyXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAzMDBcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgIGZpbGw6ICcjRkZGRkZGJyxcclxuICAgICAgICAgICAgICAgIHN0cm9rZTogJyNCM0IzQjMnLFxyXG4gICAgICAgICAgICAgICAgbGluZVdpZHRoOiAnMScsXHJcbiAgICAgICAgICAgICAgICBsaW5lRGFzaDogWzEyXSAgXHJcbiAgICAgICAgICAgIH0gICAgICAgICAgXHJcbiAgICAgICAgfSk7ICAgICAgICAgICAgICBcclxuICAgICAgICB0aGlzLmFkZChtYW5nZXJOb2RlKTtcclxuXHJcbiAgICAgICAgYXNtTW9kZWxEYXRhLmRhdGFiYXNlID0gZGF0YU1vZGVsRGF0YS5kYkRhdGEgIT09IHVuZGVmaW5lZCA/IGRhdGFNb2RlbERhdGEuZGJEYXRhLmxlbmd0aCA6IDA7XHJcbiAgICBcdHZhciBhc21Nb2RlbCA9IG5ldyBBc21Nb2RlbChhc21Nb2RlbERhdGEpO1xyXG4gICAgICAgIHRoaXMuYWRkTm9kZUJ5TW9kZWwoYXNtTW9kZWwsIGFwaSk7XHJcblxyXG4gICAgICAgIHZhciBpc2VNb2RlbCA9IG5ldyBJU0VNb2RlbChzdG9yYWdlTW9kZWxEYXRhKTtcclxuICAgICAgICB0aGlzLmFkZE5vZGVCeU1vZGVsKGlzZU1vZGVsLCBhcGkpO1xyXG5cclxuXHJcblxyXG4gICAgICAgIC8v6L+e57q/XHJcbiAgICAgICAgZm9yICh2YXIgbCA9IDA7IGwgPCB0aGlzLmRhdGFiYXNlTGlzdC5sZW5ndGg7IGwrKyApIHtcclxuICAgICAgICAgICAgdGhpcy5kcmF3TGluZSh0aGlzLmRhdGFiYXNlTGlzdFtsXSwgdGhpcy5kZ0xpc3RbbF0sIGFwaSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH07XHJcblxyXG4gICAgQ2x1c3RlckRyYXdOb2RlLnByb3RvdHlwZS5hZGROb2RlQnlNb2RlbCA9IGZ1bmN0aW9uKCBwX21vZGVsLCBhcGkpIHtcclxuICAgICAgICBcclxuICAgICAgICB2YXIgU2hhcGUgPSBhcGkuZ2V0Tm9kZUNsYXNzKHBfbW9kZWwuZ2V0KFwic3RlbmNpbC50eXBlXCIpKTtcclxuICAgICAgICB2YXIgbm9kZSA9IG51bGw7XHJcbiAgICAgICAgaWYgKCBTaGFwZSApIHtcclxuICAgICAgICAgICAgbm9kZSA9IG5ldyBTaGFwZShwX21vZGVsLCBhcGkpO1xyXG4gICAgICAgICAgICB0aGlzLmFkZChub2RlKTtcclxuICAgICAgICAgICAgdmFyIE1PVVNFX0VWRU5UX05BTUVTID0gWydjbGljayddO1xyXG4gICAgICAgICAgICBpZiAoIHBfbW9kZWwuZ2V0KFwic2hvd1RpcFwiKSApIHtcclxuICAgICAgICAgICAgICAgIE1PVVNFX0VWRU5UX05BTUVTID0gWydjbGljaycsICdtb3VzZW92ZXInLCAnbW91c2VvdXQnXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB6clV0aWwuZWFjaChNT1VTRV9FVkVOVF9OQU1FUywgZnVuY3Rpb24gKGV2ZU5hbWUpIHtcclxuICAgICAgICAgICAgICAgICBub2RlLm9uKGV2ZU5hbWUsIGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgIHZhciBwYXJhbXMgPSB7fTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIGV2ZU5hbWUgPT09IFwibW91c2VvdmVyXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zLmV2ZW50ID0gZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zLnggPSBub2RlLnBhcmVudC5wb3NpdGlvblswXSArICAoZS50YXJnZXQuc2hhcGUgPyBlLnRhcmdldC5zaGFwZS54IDogMCkgKyAoZS50YXJnZXQuc2hhcGUgPyBlLnRhcmdldC5zaGFwZS53aWR0aCA6IDApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMueSA9IG5vZGUucGFyZW50LnBvc2l0aW9uWzFdICsgKGUudGFyZ2V0LnNoYXBlID8gZS50YXJnZXQuc2hhcGUueSA6IDApICsgKGUudGFyZ2V0LnNoYXBlID8gZS50YXJnZXQuc2hhcGUuaGVpZ2h0IDogMCkgLyAyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMud2lkdGggPSAxNTA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtcy5oZWlnaHQgPSAxNzA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtcy5lV2lkdGggPSAgNSA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtcy5wYXJtRGF0ZSA9IGUudGFyZ2V0LnBhcm1EYXRlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGFwaS5nZXRXaWR0aCgpIC0gcGFyYW1zLnggPCBwYXJhbXMud2lkdGggKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMubGF5b3V0ID0gXCJsZWZ0XCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMubGF5b3V0ID0gXCJyaWdodFwiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vYXBpLnNob3dUaXBXaW5kb3cocGFyYW1zKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGV2ZU5hbWUgPT09IFwibW91c2VvdXRcIikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2FwaS5oaWRlVGlwV2luZG93KGUuZXZlbnQudGFyZ2V0KTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGV2ZU5hbWUgPT09IFwiY2xpY2tcIikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMuZXZlbnQgPSBlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMucGFybURhdGUgPSBlLnRhcmdldC5wYXJtRGF0ZTtcclxuICAgICAgICAgICAgICAgICAgICB9IFxyXG4gICAgICAgICAgICAgICAgICAgIGFwaS50cmlnZ2VyKGV2ZU5hbWUsIHBhcmFtcyk7ICAgXHJcbiAgICAgICAgICAgICAgICB9LCB0aGlzKTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICBpZiAoIGFwaS5nZXRXaWR0aCgpICA8IG5vZGUuY2xpZW50V2lkdGggKSB7XHJcbiAgICAgICAgICAgICAgICBhcGkucmVzaXplKG5vZGUuY2xpZW50V2lkdGgsIGFwaS5nZXRIZWlnaHQoKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYoIG5vZGUucG9ydE5vZGVMaXN0ICE9PSB1bmRlZmluZWQgJiYgbm9kZS5wb3J0Tm9kZUxpc3QubGVuZ3RoID4gMCApIHtcclxuICAgICAgICAgICAgICAgIGlmICggbm9kZS5pbmZvLm5hbWUgPT09IFwiQ2x1c3RlckRhdGFiYXNlTm9kZVwiICkge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5wb3J0Tm9kZUxpc3QubGVuZ3RoOyBpKysgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGF0YWJhc2VMaXN0LnB1c2gobm9kZS5wb3J0Tm9kZUxpc3RbaV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiggbm9kZS5pbmZvLm5hbWUgPT09IFwiQ2x1c3RlckFzbU5vZGVcIiApIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUucG9ydE5vZGVMaXN0Lmxlbmd0aDsgaSsrICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRnTGlzdC5wdXNoKG5vZGUucG9ydE5vZGVMaXN0W2ldKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9IFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH07XHJcblxyXG4gICAgQ2x1c3RlckRyYXdOb2RlLnByb3RvdHlwZS5kcmF3TGluZSA9IGZ1bmN0aW9uKCBwX3N0YXJ0Tm9kZSwgcF9lbmROb2RlLCBhcGkgKSB7XHJcbiAgICAgICAgdmFyIGZsZWZ0eCA9IHBfc3RhcnROb2RlLnBhcmVudC5wb3NpdGlvblswXSArIHBfc3RhcnROb2RlLnNoYXBlLng7XHJcbiAgICAgICAgdmFyIGZsZWZ0eSA9IHBfc3RhcnROb2RlLnBhcmVudC5wb3NpdGlvblsxXSArIHBfc3RhcnROb2RlLnNoYXBlLnk7XHJcbiAgICAgICAgdmFyIGZ3aWR0aCA9ICBwX3N0YXJ0Tm9kZS5zaGFwZS53aWR0aDtcclxuICAgICAgICB2YXIgZmhlaWdodCA9IHBfc3RhcnROb2RlLnNoYXBlLmhlaWdodDtcclxuXHJcbiAgICAgICAgdmFyIHRvcmlnaHR4ID0gcF9lbmROb2RlLnBhcmVudC5wb3NpdGlvblswXSArIHBfZW5kTm9kZS5zaGFwZS54O1xyXG4gICAgICAgIHZhciB0b3JpZ2h0eSA9IHBfZW5kTm9kZS5wYXJlbnQucG9zaXRpb25bMV0gKyBwX2VuZE5vZGUuc2hhcGUueTtcclxuICAgICAgICB2YXIgdG93aWR0aCA9ICBwX2VuZE5vZGUuc2hhcGUud2lkdGg7XHJcbiAgICAgICAgdmFyIHRvaGVpZ2h0ID0gcF9lbmROb2RlLnNoYXBlLmhlaWdodDtcclxuICAgICAgICB2YXIgbW9kZGxlWSA9IDIwMDsgICAgXHJcbiAgICAgICAgdmFyIG1vZGRsZVggPSBhcGkuZ2V0V2lkdGgoKSAvIDI7IFxyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciBfdG9Nb2RkbGVZID0gbW9kZGxlWTtcclxuICAgICAgICBpZiAoIHRvcmlnaHR4ICsgMjUgPiBtb2RkbGVYICkge1xyXG4gICAgICAgICAgICBfdG9Nb2RkbGVZID0gbW9kZGxlWSAtIDE1O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIF90b01vZGRsZVkgPSBtb2RkbGVZICsgMTU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgZGVmYXVsdE9wdGlvbkRhdGFiYXNlID0ge1xyXG4gICAgICAgICAgICBmcm9tQm91bmRzIDoge3g6IGZsZWZ0eCAtIDE1LCB5OiBmbGVmdHksIHdpZHRoOiBmd2lkdGgsIGhlaWdodDogZmhlaWdodH0sXHJcbiAgICAgICAgICAgIHRvQm91bmRzOiB7eDogdG9yaWdodHggLSAxNSwgeTogdG9yaWdodHksIHdpZHRoOiB0b3dpZHRoLCBoZWlnaHQ6IHRvaGVpZ2h0fSxcclxuICAgICAgICAgICAgbW9kZGxlWTogX3RvTW9kZGxlWSxcclxuICAgICAgICAgICAgc3R5bGUgOiB7XHJcbiAgICAgICAgICAgICAgICBsaW5lV2lkdGggOiAzLFxyXG4gICAgICAgICAgICAgICAgc3Ryb2tlOiAnIzA1MDUwNScvLyxcclxuICAgICAgICAgICAgICAgIC8vZmlsbDogJyM5Njk5REQnXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGhvdmVyU3R5bGUgOiB7XHJcbiAgICAgICAgICAgICAgICBsaW5lV2lkdGggOiAzLFxyXG4gICAgICAgICAgICAgICAgc3Ryb2tlOiAnIzBCODMyOScvLyxcclxuICAgICAgICAgICAgICAgIC8vZmlsbDonIzJGREU5MidcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgaXNFZGl0OiBmYWxzZSxcclxuICAgICAgICAgICAgaXNWZWN0b3I6IHRydWUsXHJcbiAgICAgICAgICAgIGxpbmVUeXBlOiBDb25uZWN0b3IuVFlQRV9DVVJWRVxyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgZGF0YWJhc2VNb2RlbCA9IG5ldyBOZXRXb3JrTGluZU1vZGVsKGRlZmF1bHRPcHRpb25EYXRhYmFzZSk7XHJcbiAgICAgICAgdmFyIGRhdGFiYXNlTm9kZSA9IG5ldyBOZXRXb3JrTGluZU5vZGUoZGF0YWJhc2VNb2RlbCk7XHJcbiAgICAgICAgdGhpcy5hZGQoZGF0YWJhc2VOb2RlKTtcclxuXHJcbiAgICAgICAgdmFyIF9iYWNrTW9kZGxlWSA9IG1vZGRsZVk7XHJcbiAgICAgICAgaWYgKCB0b3JpZ2h0eCArIDI1ID4gbW9kZGxlWCApIHtcclxuICAgICAgICAgICAgX2JhY2tNb2RkbGVZID0gbW9kZGxlWSArIDE1O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIF9iYWNrTW9kZGxlWSA9IG1vZGRsZVkgLSAxNTtcclxuICAgICAgICB9XHJcbiAgICAgICAgIHZhciBkZWZhdWx0T3B0aW9uRGcgPSB7XHJcbiAgICAgICAgICAgIGZyb21Cb3VuZHMgOiB7eDogdG9yaWdodHggKyAxNSwgeTogdG9yaWdodHksIHdpZHRoOiB0b3dpZHRoLCBoZWlnaHQ6IHRvaGVpZ2h0fSxcclxuICAgICAgICAgICAgdG9Cb3VuZHM6IHt4OiBmbGVmdHggKyAxNSwgeTogZmxlZnR5LCB3aWR0aDogZndpZHRoLCBoZWlnaHQ6IGZoZWlnaHR9LFxyXG4gICAgICAgICAgICBtb2RkbGVZOiBfYmFja01vZGRsZVksXHJcbiAgICAgICAgICAgIHN0eWxlIDoge1xyXG4gICAgICAgICAgICAgICAgbGluZVdpZHRoIDogMyxcclxuICAgICAgICAgICAgICAgIHN0cm9rZTogJyMwNTA1MDUnLy8sXHJcbiAgICAgICAgICAgICAgICAvL2ZpbGw6ICcjOTY5OUREJ1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBob3ZlclN0eWxlIDoge1xyXG4gICAgICAgICAgICAgICAgbGluZVdpZHRoIDogMyxcclxuICAgICAgICAgICAgICAgIHN0cm9rZTogJyMwQjgzMjknLy8sXHJcbiAgICAgICAgICAgICAgICAvL2ZpbGw6JyMyRkRFOTInXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGlzRWRpdDogZmFsc2UsXHJcbiAgICAgICAgICAgIGlzVmVjdG9yOiB0cnVlLFxyXG4gICAgICAgICAgICBsaW5lVHlwZTogQ29ubmVjdG9yLlRZUEVfQ1VSVkVcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGRnTW9kZWwgPSBuZXcgTmV0V29ya0xpbmVNb2RlbChkZWZhdWx0T3B0aW9uRGcpO1xyXG4gICAgICAgIHZhciBkZ05vZGUgPSBuZXcgTmV0V29ya0xpbmVOb2RlKGRnTW9kZWwpO1xyXG4gICAgICAgIHRoaXMuYWRkKGRnTm9kZSk7XHJcblxyXG5cclxuICAgIH07XHJcblxyXG4gICAgQ2x1c3RlckRyYXdOb2RlLnByb3RvdHlwZS5iaW5kID0gZnVuY3Rpb24oIHBfbm9kZSwgcF9ldmVudExpc3QsIGFwaSkge1xyXG4gICAgICAgIGlmICggcF9ldmVudExpc3QgIT0gdW5kZWZpbmVkICYmIHBfZXZlbnRMaXN0Lmxlbmd0aCA+IDAgKSB7XHJcbiAgICAgICAgICAgIC8v57uR5a6a5oKs5rWu5LqL5Lu2XHJcbiAgICAgICAgICAgIHpyVXRpbC5lYWNoKHBfZXZlbnRMaXN0LCBmdW5jdGlvbiAoZXZlTmFtZSkge1xyXG4gICAgICAgICAgICAgICAgcF9ub2RlLm9uKGV2ZU5hbWUsIGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBldmVOYW1lID09PSBcIm1vdXNlb3ZlclwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXJhbXMgPSB7fTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zLmV2ZW50ID0gZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zLnggPSBwX25vZGUucG9zaXRpb25bMF0gKyBlLnRhcmdldC5zaGFwZS53aWR0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zLnkgPSBwX25vZGUucG9zaXRpb25bMV0gKyBlLnRhcmdldC5zaGFwZS5oZWlnaHQgLyAyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMud2lkdGggPSAxNTA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtcy5oZWlnaHQgPSAxNzA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtcy5lV2lkdGggPSAgNSA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtcy5wYXJtRGF0ZSA9IGUudGFyZ2V0LnBhcm1EYXRlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhcGkuc2hvd1RpcFdpbmRvdyhwYXJhbXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFwaS5oaWRlVGlwV2luZG93KGUuZXZlbnQudGFyZ2V0KTtcclxuICAgICAgICAgICAgICAgICAgICB9ICAgIFxyXG4gICAgICAgICAgICAgICAgfSwgdGhpcyk7XHJcbiAgICAgICAgICAgIH0sIHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB6clV0aWwuaW5oZXJpdHMoQ2x1c3RlckRyYXdOb2RlLCBOZXR3b3JrTm9kZSk7XHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IENsdXN0ZXJEcmF3Tm9kZTtcclxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2xpYi9maXNoLXRvcG8tbmV0d29yay9saWIvbm9kZS9jbHVzdGVyL0NsdXN0ZXJEcmF3Tm9kZS5qc1xuICoqIG1vZHVsZSBpZCA9IDEwOFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXHJcbiAqIFNlcnZlciBEYXRhYmFzZU1vZGVsXHJcbiAqXHJcbiAqL1xyXG5cclxuXHJcbiAgICB2YXIgTW9kZWwgPSByZXF1aXJlKCcuLi8uLi8uLi8uLi9maXNoLXRvcG8tY29yZS9saWIvTW9kZWwnKTtcclxuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcclxuICAgIHZhciBOZXR3b3JrTW9kZWwgPSByZXF1aXJlKCcuLi9OZXR3b3JrTW9kZWwnKTtcclxuXHJcbiAgICB2YXIgRGF0YWJhc2VNb2RlbCA9IE5ldHdvcmtNb2RlbC5leHRlbmQoe1xyXG4gICAgICAgIG5hbWU6IFwiXCIsXHJcbiAgICBcdGhlaWdodDogMjAwLFxyXG4gICAgICAgIHdpZHRoOiAxOTAsXHJcbiAgICAgICAgc3RhdHVzIDogXCJvbmxpbmVcIixcclxuICAgICAgICBpbnN0YW5zZToge30sXHJcbiAgICAgICAgZGc6IFtdXHJcbiAgICB9KTtcclxuICAgIG1vZHVsZS5leHBvcnRzID0gRGF0YWJhc2VNb2RlbDtcclxuXHJcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9saWIvZmlzaC10b3BvLW5ldHdvcmsvbGliL21vZGVsL2NsdXN0ZXIvRGF0YWJhc2VNb2RlbC5qc1xuICoqIG1vZHVsZSBpZCA9IDEwOVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXHJcbiAqIFNlcnZlciBBc21Nb2RlbFxyXG4gKlxyXG4gKi9cclxuXHJcblxyXG4gICAgdmFyIE1vZGVsID0gcmVxdWlyZSgnLi4vLi4vLi4vLi4vZmlzaC10b3BvLWNvcmUvbGliL01vZGVsJyk7XHJcbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XHJcbiAgICB2YXIgTmV0d29ya01vZGVsID0gcmVxdWlyZSgnLi4vTmV0d29ya01vZGVsJyk7XHJcblxyXG4gICAgdmFyIEFzbU1vZGVsID0gTmV0d29ya01vZGVsLmV4dGVuZCh7XHJcbiAgICAgICAgbmFtZTogXCJcIixcclxuICAgIFx0aGVpZ2h0OiAyMDAsXHJcbiAgICAgICAgd2lkdGg6IDE5MCxcclxuICAgICAgICBzdGF0dXMgOiBcIm9ubGluZVwiLFxyXG4gICAgICAgIGFzbURhdGEgOiBbXSxcclxuICAgICAgICBkZzogW11cclxuICAgIH0pO1xyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBBc21Nb2RlbDtcclxuXHJcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9saWIvZmlzaC10b3BvLW5ldHdvcmsvbGliL21vZGVsL2NsdXN0ZXIvQXNtTW9kZWwuanNcbiAqKiBtb2R1bGUgaWQgPSAxMTBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxyXG4gKiBJU0UgTW9kZWxcclxuICpcclxuICovXHJcblxyXG5cclxuICAgIHZhciBNb2RlbCA9IHJlcXVpcmUoJy4uLy4uLy4uLy4uL2Zpc2gtdG9wby1jb3JlL2xpYi9Nb2RlbCcpO1xyXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xyXG4gICAgdmFyIE5ldHdvcmtNb2RlbCA9IHJlcXVpcmUoJy4uL05ldHdvcmtNb2RlbCcpO1xyXG5cclxuICAgIHZhciBJU0VNb2RlbCA9IE5ldHdvcmtNb2RlbC5leHRlbmQoe1xyXG4gICAgICAgIG5hbWU6IFwiXCIsXHJcbiAgICBcdGhlaWdodDogMjAwLFxyXG4gICAgICAgIHdpZHRoOiAyNTAsXHJcbiAgICAgICAgc3RhdHVzIDogXCJvbmxpbmVcIixcclxuICAgICAgICBjaGlsZE5vZGVMaXN0OiBbXVxyXG4gICAgfSk7XHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IElTRU1vZGVsO1xyXG5cclxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2xpYi9maXNoLXRvcG8tbmV0d29yay9saWIvbW9kZWwvY2x1c3Rlci9JU0VNb2RlbC5qc1xuICoqIG1vZHVsZSBpZCA9IDExMVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXHJcbiAgICB2YXIgdXRpbCA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi9maXNoLXRvcG8tY29yZS9saWIvdXRpbC5qc1wiKTtcclxuICAgIHZhciBOZXR3b3JrTm9kZSA9IHJlcXVpcmUoXCIuLi9OZXR3b3JrTm9kZVwiKTtcclxuICAgIHZhciBDbHVzdGVyRHJhd05vZGUgPSByZXF1aXJlKFwiLi9DbHVzdGVyRHJhd05vZGVcIik7XHJcbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XHJcbiAgICB2YXIgZ3JhcGhpYyA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi9maXNoLXRvcG8tY29yZS9saWIvZ3JhcGhpYy5qc1wiKTtcclxuICAgIHZhciBOZXR3b3JrTW9kZWwgPSByZXF1aXJlKFwiLi4vLi4vbW9kZWwvTmV0d29ya01vZGVsLmpzXCIpO1xyXG4gICAgXHJcbiAgICBmdW5jdGlvbiBDbHVzdGVyRGF0YWJhc2VOb2RlKG1vZGVsLCBhcGkpIHtcclxuICAgICAgICBDbHVzdGVyRHJhd05vZGUuY2FsbCh0aGlzLCBtb2RlbCwgYXBpKTtcclxuICAgICAgICB0aGlzLmluZm8gPSB7dHlwZTogLTEsIG5hbWU6IFwiQ2x1c3RlckRhdGFiYXNlTm9kZVwiIH07ICAgIFxyXG4gICAgICAgIHRoaXMubW9kZWwgPSBtb2RlbDtcclxuICAgICAgICB0aGlzLmxpbmVJbmZvID0gbW9kZWwuZ2V0KCdsaW5lSW5mbycpO1xyXG4gICAgICAgIHRoaXMucG9ydE5vZGVMaXN0ID0gW107XHJcbiAgICAgICAgdGhpcy5yZW5kZXIobW9kZWwsYXBpKTtcclxuICAgIH07XHJcblxyXG4gICAgQ2x1c3RlckRhdGFiYXNlTm9kZS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24obW9kZWwsIGFwaSkge1xyXG4gICAgICAgIHRoaXMubW9kZWwgPSBtb2RlbDtcclxuICAgICAgICB2YXIgZGJEYXRhID0gbW9kZWwuZ2V0KFwiZGJEYXRhXCIpO1xyXG4gICAgICAgIHZhciBfd2lkdGggPSAyODA7XHJcbiAgICAgICAgdmFyIF9oZWlnaHQgPSA4MDtcclxuICAgICAgICB2YXIgX2ludGVydmFsID0gNTA7XHJcbiAgICAgICAgdmFyIF94ID0gKGFwaS5nZXRXaWR0aCgpIC0gZGJEYXRhLmxlbmd0aCAqIChfd2lkdGggKyBfaW50ZXJ2YWwpKSAvIDIgLSAxNDA7XHJcbiAgICAgICAgdmFyIF95ID0gMDtcclxuICAgICAgICBmb3IgKCB2YXIgZCA9IDAgOyBkIDwgZGJEYXRhLmxlbmd0aDsgZCsrICkge1xyXG4gICAgICAgICAgICB2YXIgcGFybURhdGUgPSBkYkRhdGFbZF07XHJcbiAgICAgICAgICAgIHBhcm1EYXRlLnR5cGUgPSBcImRhdGFiYXNlXCI7XHJcbiAgICAgICAgICAgIC8v5a6e5L6L5a695bqmXHJcbiAgICAgICAgICAgIHZhciBfaW5zdGFuc2VXaWR0aCA9IDE1MDtcclxuICAgICAgICAgICAgX3dpZHRoID0gKF9pbnN0YW5zZVdpZHRoICsgMTApICogKGRiRGF0YVtkXS5pbnN0YW5zZS5sZW5ndGggKyAxKSArIDEwO1xyXG5cclxuICAgICAgICAgICAgIC8v5Yib5bu65pWw5o2u5bqT5a+56LGhXHJcbiAgICAgICAgICAgIHZhciBwb3J0Tm9kZSA9IG5ldyBncmFwaGljLlJlY3Qoe1xyXG4gICAgICAgICAgICAgICAgc2hhcGU6IHtcclxuICAgICAgICAgICAgICAgICAgICByOiAxMCxcclxuICAgICAgICAgICAgICAgICAgICB4OiBfeCxcclxuICAgICAgICAgICAgICAgICAgICB5OiBfeSxcclxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogX3dpZHRoLFxyXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogX2hlaWdodFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9maWxsOiAnI0UyRTNEOScsXHJcbiAgICAgICAgICAgICAgICAgICAgLy9zdHJva2U6ICcjQjNCM0IzJyxcclxuICAgICAgICAgICAgICAgICAgICBmaWxsOiAnI0ZGRkZGRicsXHJcbiAgICAgICAgICAgICAgICAgICAgc3Ryb2tlOiAnIzg4ODg4QicsXHJcbiAgICAgICAgICAgICAgICAgICAgb3BhY2l0eTogMSxcclxuICAgICAgICAgICAgICAgICAgICBsaW5lV2lkdGg6ICcyJy8vLFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHBhcm1EYXRlOiBwYXJtRGF0ZSAgICAgICBcclxuICAgICAgICAgICAgfSk7ICBcclxuICAgICAgICAgICAgcG9ydE5vZGUubGluZUluZm8gPSB0aGlzLmxpbmVJbmZvOyAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB0aGlzLmFkZChwb3J0Tm9kZSk7XHJcblxyXG4gICAgICAgICAgICAvLyB2YXIgTU9VU0VfRVZFTlRfTkFNRVMgPSBbJ2NsaWNrJywgJ21vdXNlb3ZlcicsICdtb3VzZW91dCddOyAgIFxyXG4gICAgICAgICAgICAvLyB6clV0aWwuZWFjaChNT1VTRV9FVkVOVF9OQU1FUywgZnVuY3Rpb24gKGV2ZU5hbWUpIHtcclxuICAgICAgICAgICAgLy8gICAgICBwb3J0Tm9kZS5vbihldmVOYW1lLCBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAvLyAgICAgICAgIGlmICggZXZlTmFtZSA9PT0gXCJtb3VzZW92ZXJcIikge1xyXG4gICAgICAgICAgICAvLyAgICAgICAgICAgICB2YXIgcGFyYW1zID0ge307XHJcbiAgICAgICAgICAgIC8vICAgICAgICAgICAgIHBhcmFtcy5ldmVudCA9IGU7XHJcbiAgICAgICAgICAgIC8vICAgICAgICAgICAgIHBhcmFtcy54ID0gcG9ydE5vZGUucGFyZW50LnBvc2l0aW9uWzBdICsgZS50YXJnZXQuc2hhcGUueCArIGUudGFyZ2V0LnNoYXBlLndpZHRoO1xyXG4gICAgICAgICAgICAvLyAgICAgICAgICAgICBwYXJhbXMueSA9IHBvcnROb2RlLnBhcmVudC5wb3NpdGlvblsxXSArIGUudGFyZ2V0LnNoYXBlLnkgKyBlLnRhcmdldC5zaGFwZS5oZWlnaHQgLyAyO1xyXG4gICAgICAgICAgICAvLyAgICAgICAgICAgICBwYXJhbXMud2lkdGggPSAxNTA7XHJcbiAgICAgICAgICAgIC8vICAgICAgICAgICAgIHBhcmFtcy5oZWlnaHQgPSAxNzA7XHJcbiAgICAgICAgICAgIC8vICAgICAgICAgICAgIHBhcmFtcy5lV2lkdGggPSAgNSA7XHJcbiAgICAgICAgICAgIC8vICAgICAgICAgICAgIHBhcmFtcy5wYXJtRGF0ZSA9IGUudGFyZ2V0LnBhcm1EYXRlO1xyXG4gICAgICAgICAgICAvLyAgICAgICAgICAgICBpZiAoIGFwaS5nZXRXaWR0aCgpIC0gcGFyYW1zLnggPCBwYXJhbXMud2lkdGggKSB7XHJcbiAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgICBwYXJhbXMubGF5b3V0ID0gXCJsZWZ0XCI7XHJcbiAgICAgICAgICAgIC8vICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgICBwYXJhbXMubGF5b3V0ID0gXCJyaWdodFwiO1xyXG4gICAgICAgICAgICAvLyAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vICAgICAgICAgICAgIC8vYXBpLnNob3dUaXBXaW5kb3cocGFyYW1zKTtcclxuICAgICAgICAgICAgLy8gICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvLyAgICAgICAgICAgICAvL2FwaS5oaWRlVGlwV2luZG93KGUuZXZlbnQudGFyZ2V0KTtcclxuICAgICAgICAgICAgLy8gICAgICAgICB9ICAgIFxyXG4gICAgICAgICAgICAvLyAgICAgfSwgdGhpcyk7XHJcbiAgICAgICAgICAgIC8vIH0pO1xyXG4gICAgICAgICAgIFxyXG5cclxuICAgICAgICAgICAgdGhpcy5wb3J0Tm9kZUxpc3QucHVzaChwb3J0Tm9kZSk7XHJcblxyXG4gICAgICAgICAgICB2YXIgX2luc3RhbnNlID0gZGJEYXRhW2RdLmluc3RhbnNlO1xyXG4gICAgICAgICAgICAvL+WIm+W7uuaVsOaNruW6k+WunuS+i+WvueixoVxyXG4gICAgICAgICAgICBpZiggX2luc3RhbnNlICE9IHVuZGVmaW5lZCAmJiBfaW5zdGFuc2UubGVuZ3RoID4gMCApIHtcclxuICAgICAgICAgICAgICAgICB2YXIgX3RpdGxlID0gbmV3IGdyYXBoaWMuVGV4dCh7XHJcbiAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeDogX3ggKyA3MCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgeTogMTUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IFwi5pWw5o2u5bqT5a6e5L6LOiBcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IDcwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IDIwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxsOiAnIzhGOEI4QScsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHRGb250OiAnMTRweCBNaWNyb3NvZnQgWWFoZWknLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0QmFzZWxpbmU6ICd0b3AnXHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICBkcmFnZ2FibGU6IHRydWVcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hZGQoX3RpdGxlKTtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgX2luc3RhbnNlWCA9IF94ICsgX2luc3RhbnNlV2lkdGggKyAxMDtcclxuICAgICAgICAgICAgICAgIF9pbnN0YW5zZVdpZHRoID0gMTUwO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBfaW5zdGFuc2UubGVuZ3RoOyBpKysgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBfaW5zdGFuc2VOb2RlID0gbmV3IGdyYXBoaWMuUmVjdCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNoYXBlOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4OiBfaW5zdGFuc2VYLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeTogMTAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogX2luc3RhbnNlV2lkdGgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IDMwXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxsOiAnI0ZGRkZGRicsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJva2U6ICcjODg4ODhCJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wYWNpdHk6IDEsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lV2lkdGg6ICcyJy8vLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9ICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgIH0pOyBcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZChfaW5zdGFuc2VOb2RlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgIC8v54q25oCBIFxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBfaW5zdGFuc2VzdGF0dXNOb2RlID0gbmV3IGdyYXBoaWMuQ2lyY2xlKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgIHNoYXBlOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjeDogX2luc3RhbnNlWCArIDE1LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3k6IDI1LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcjogNVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZToge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsbDogJyMwNzc4MjYnLyosXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJva2U6ICcjQjNCM0IzJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVXaWR0aDogJzInLy8sKi9cclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIF9pbnN0YW5zZVtpXS5zdGF0dXMgPT09IFwib2ZmbGluZVwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9pbnN0YW5zZXN0YXR1c05vZGUuc3R5bGUuZmlsbCA9IFwiIzk5OTk5OVwiO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZChfaW5zdGFuc2VzdGF0dXNOb2RlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy/mloflrZdcclxuICAgICAgICAgICAgICAgICAgICB2YXIgX2luc3RhbnNlVGl0bGUgPSBuZXcgZ3JhcGhpYy5UZXh0KHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHg6IF9pbnN0YW5zZVggKyAyNSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHk6IDE1LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogX2luc3RhbnNlW2ldLm5hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogMjAwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiAyMCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGw6ICcjOEY4QjhBJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHRGb250OiAnMTRweCBNaWNyb3NvZnQgWWFoZWknLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dEJhc2VsaW5lOiAndG9wJ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkcmFnZ2FibGU6IHRydWVcclxuICAgICAgICAgICAgICAgICAgICB9KTsgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGQoX2luc3RhbnNlVGl0bGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIF9pbnN0YW5zZVggPSBfaW5zdGFuc2VXaWR0aCArIF9pbnN0YW5zZVggKyAxMDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgICAgIC8vIC8v54mp55CG54q25oCBIFxyXG4gICAgICAgICAgICAvLyB2YXIgX3BoeVN0YXR1cyA9IG5ldyBncmFwaGljLlJlY3Qoe1xyXG4gICAgICAgICAgICAvLyAgICAgc2hhcGU6IHtcclxuICAgICAgICAgICAgLy8gICAgICAgICB4OiBfaW5zdGFuc2VYLFxyXG4gICAgICAgICAgICAvLyAgICAgICAgIHk6IDMyLFxyXG4gICAgICAgICAgICAvLyAgICAgICAgIHdpZHRoOiAyODAsXHJcbiAgICAgICAgICAgIC8vICAgICAgICAgaGVpZ2h0OiA1MFxyXG4gICAgICAgICAgICAvLyAgICAgfSxcclxuICAgICAgICAgICAgLy8gICAgIHN0eWxlOiB7XHJcbiAgICAgICAgICAgIC8vICAgICAgICAgZmlsbDogJyNDQ0NDQ0MnLFxyXG4gICAgICAgICAgICAvLyAgICAgICAgIHN0cm9rZTogJyNCM0IzQjMnLFxyXG4gICAgICAgICAgICAvLyAgICAgICAgIGxpbmVXaWR0aDogJzInLy8sXHJcbiAgICAgICAgICAgIC8vICAgICB9ICAgICAgICAgIFxyXG4gICAgICAgICAgICAvLyB9KTsgXHJcbiAgICAgICAgICAgIC8vIGlmICggbW9kZWwuZ2V0KFwic3RhdHVzXCIpID09PSBcIm9mZmxpbmVcIikge1xyXG4gICAgICAgICAgICAvLyAgICAgX3BoeVN0YXR1cy5zdHlsZS5maWxsID0gXCIjQ0ZCNjI0XCI7XHJcbiAgICAgICAgICAgIC8vIH1cclxuICAgICAgICAgICAgLy8gdGhpcy5hZGQoX3BoeVN0YXR1cyk7XHJcblxyXG4gICAgICAgICAgICAvL+eKtuaAgSBcclxuICAgICAgICAgICAgdmFyIF9zdGF0dXMgPSBuZXcgZ3JhcGhpYy5DaXJjbGUoe1xyXG4gICAgICAgICAgICAgICAgIHNoYXBlOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgY3g6IF94ICsgX3dpZHRoIC8gMiAtIDMwLFxyXG4gICAgICAgICAgICAgICAgICAgIGN5OiA2MCxcclxuICAgICAgICAgICAgICAgICAgICByOiA1XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgICAgICBmaWxsOiAnIzA3NzgyNicvKixcclxuICAgICAgICAgICAgICAgICAgICBzdHJva2U6ICcjQjNCM0IzJyxcclxuICAgICAgICAgICAgICAgICAgICBsaW5lV2lkdGg6ICcyJy8vLCovXHJcbiAgICAgICAgICAgICAgICB9IFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgaWYgKCBtb2RlbC5nZXQoXCJzdGF0dXNcIikgPT09IFwib2ZmbGluZVwiKSB7XHJcbiAgICAgICAgICAgICAgICBfc3RhdHVzLnN0eWxlLmZpbGwgPSBcIiM5OTk5OTlcIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmFkZChfc3RhdHVzKTtcclxuXHJcbiAgICAgICAgICAgIHZhciBfdGl0bGUgPSBuZXcgZ3JhcGhpYy5UZXh0KHtcclxuICAgICAgICAgICAgICAgIHN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgeDogX3ggKyBfd2lkdGggLyAyIC0gMjAsXHJcbiAgICAgICAgICAgICAgICAgICAgeTogNTAsXHJcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogZGJEYXRhW2RdLm5hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IDIwMCxcclxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IDIwLFxyXG4gICAgICAgICAgICAgICAgICAgIGZpbGw6ICcjMDIwMjAyJyxcclxuICAgICAgICAgICAgICAgICAgICB0ZXh0Rm9udDogJzE4cHggTWljcm9zb2Z0IFlhaGVpJyxcclxuICAgICAgICAgICAgICAgICAgICB0ZXh0QmFzZWxpbmU6ICd0b3AnXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgZHJhZ2dhYmxlOiB0cnVlXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB0aGlzLmFkZChfdGl0bGUpO1xyXG4gICAgICAgICAgICBfeCA9IF94ICsgX3dpZHRoICsgX2ludGVydmFsO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmNsaWVudFdpZHRoID0gX3ggKyA1MDtcclxuICAgIFxyXG4gICAgICAgIHRoaXMucG9zaXRpb24gPSBbbW9kZWwuZ2V0KFwiYm91bmRzLnVwcGVyTGVmdC54XCIpICwgbW9kZWwuZ2V0KFwiYm91bmRzLnVwcGVyTGVmdC55XCIpXTtcclxuICAgIH07XHJcblxyXG4gICBcclxuICAgIHpyVXRpbC5pbmhlcml0cyhDbHVzdGVyRGF0YWJhc2VOb2RlLCBOZXR3b3JrTm9kZSk7XHJcblxyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBDbHVzdGVyRGF0YWJhc2VOb2RlO1xyXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vbGliL2Zpc2gtdG9wby1uZXR3b3JrL2xpYi9ub2RlL2NsdXN0ZXIvQ2x1c3RlckRhdGFiYXNlTm9kZS5qc1xuICoqIG1vZHVsZSBpZCA9IDExMlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXHJcbiAgICB2YXIgdXRpbCA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi9maXNoLXRvcG8tY29yZS9saWIvdXRpbC5qc1wiKTtcclxuICAgIHZhciBOZXR3b3JrTm9kZSA9IHJlcXVpcmUoXCIuLi9OZXR3b3JrTm9kZVwiKTtcclxuICAgIHZhciBDbHVzdGVyRHJhd05vZGUgPSByZXF1aXJlKFwiLi9DbHVzdGVyRHJhd05vZGVcIik7XHJcbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XHJcbiAgICB2YXIgZ3JhcGhpYyA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi9maXNoLXRvcG8tY29yZS9saWIvZ3JhcGhpYy5qc1wiKTtcclxuICAgIHZhciBOZXR3b3JrTW9kZWwgPSByZXF1aXJlKFwiLi4vLi4vbW9kZWwvTmV0d29ya01vZGVsLmpzXCIpO1xyXG4gICAgXHJcbiAgICBmdW5jdGlvbiBDbHVzdGVyQXNtTm9kZShtb2RlbCxhcGkpIHtcclxuICAgICAgICBDbHVzdGVyRHJhd05vZGUuY2FsbCh0aGlzLCBtb2RlbCwgYXBpKTtcclxuICAgICAgICB0aGlzLmluZm8gPSB7dHlwZTogLTEsIG5hbWU6IFwiQ2x1c3RlckFzbU5vZGVcIiB9OyAgICBcclxuICAgICAgICB0aGlzLm1vZGVsID0gbW9kZWw7XHJcbiAgICAgICAgdGhpcy5saW5lSW5mbyA9IG1vZGVsLmdldCgnbGluZUluZm8nKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXIobW9kZWwsYXBpKTtcclxuICAgIH07XHJcblxyXG4gICAgQ2x1c3RlckFzbU5vZGUucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uKG1vZGVsLCBhcGkpIHtcclxuICAgICAgICB2YXIgZGdMaXN0ID0gbW9kZWwuZ2V0KFwiZGdEYXRhXCIpO1xyXG4gICAgICAgIHZhciBfZGdXID0gMTUwO1xyXG4gICAgICAgIHZhciBfZGdIID0gMzA7XHJcbiAgICAgICAgdmFyIGZ1bGxEZ0hlaWdodCA9IHRoaXMuZ2V0Tm9kZUhlaWdodCggZGdMaXN0Lmxlbmd0aCArIDEsIF9kZ0gsIDQgKTtcclxuICAgICAgICB2YXIgZnVsbERnV2lkdGggPSAoX2RnVyArIDUpICogNCArIDU7XHJcblxyXG4gICAgICAgIHZhciBfc3RhcnRYID0gKGFwaS5nZXRXaWR0aCgpIC0gZnVsbERnV2lkdGgpIC8gMjtcclxuICAgICAgICB2YXIgX3N0YXJ0WSA9IDA7XHJcblxyXG4gICAgICAgIC8v5b2x6JeP6L+e57q/54K5XHJcbiAgICAgICAgdmFyIGRhdGFiYXNlTGlzdCA9IG1vZGVsLmdldChcImRhdGFiYXNlXCIpO1xyXG4gICAgICAgIGlmICggZGF0YWJhc2VMaXN0ID4gMCApIHtcclxuICAgICAgICAgICAgdmFyIF9sU3BhY2UgPSAoIGZ1bGxEZ1dpZHRoIC0gKGRhdGFiYXNlTGlzdCAqIDMwKSApIC8gKGRhdGFiYXNlTGlzdCArIDEpIFxyXG4gICAgICAgICAgICB2YXIgX2xYID0gX3N0YXJ0WCArIF9sU3BhY2U7XHJcbiAgICAgICAgICAgIHZhciBfbFkgPSAwO1xyXG4gICAgICAgICAgICBmb3IgKCB2YXIgbCA9IDA7IGwgPCBkYXRhYmFzZUxpc3Q7IGwrKyApIHtcclxuICAgICAgICAgICAgICAgIHZhciBkZ0xpbmVOb2RlID0gbmV3IGdyYXBoaWMuUmVjdCh7XHJcbiAgICAgICAgICAgICAgICAgICAgc2hhcGU6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcjogMTAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHg6IF9sWCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgeTogMCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IDUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogNVxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmlsbDogJ3JlZCcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZTogJ3JlZCcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wYWNpdHk6IDAuMDAxLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lV2lkdGg6ICcyJy8vLFxyXG4gICAgICAgICAgICAgICAgICAgIH0gICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHRoaXMuYWRkKGRnTGluZU5vZGUpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wb3J0Tm9kZUxpc3QucHVzaChkZ0xpbmVOb2RlKTsgXHJcbiAgICAgICAgICAgICAgICBfbFggKz0gX2xTcGFjZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAgICAgICBcclxuICAgICAgICB2YXIgZnVsbERnTm9kZSA9IG5ldyBncmFwaGljLlJlY3Qoe1xyXG4gICAgICAgICAgICBzaGFwZToge1xyXG4gICAgICAgICAgICAgICAgcjogMTAsXHJcbiAgICAgICAgICAgICAgICB4OiBfc3RhcnRYLFxyXG4gICAgICAgICAgICAgICAgeTogX3N0YXJ0WSxcclxuICAgICAgICAgICAgICAgIHdpZHRoOiBmdWxsRGdXaWR0aCxcclxuICAgICAgICAgICAgICAgIGhlaWdodDogZnVsbERnSGVpZ2h0XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgICBmaWxsOiAnI0ZGRkZGRicsXHJcbiAgICAgICAgICAgICAgICBzdHJva2U6ICcjODg4ODhCJyxcclxuICAgICAgICAgICAgICAgIG9wYWNpdHk6IDEsXHJcbiAgICAgICAgICAgICAgICBsaW5lV2lkdGg6ICcyJy8vLFxyXG4gICAgICAgICAgICB9ICAgICAgICAgIFxyXG4gICAgICAgIH0pOyBcclxuICAgICAgICB0aGlzLmFkZChmdWxsRGdOb2RlKTtcclxuXHJcbiAgICAgICAgLy/mt7vliqBERyDljZXlhYNcclxuICAgICAgICB2YXIgX2RnQ2VsbFggPSBfc3RhcnRYICsgNTtcclxuICAgICAgICB2YXIgX2RnQ2VsbFkgPSBfc3RhcnRZICsgNTtcclxuICAgICAgICBmb3IgKCB2YXIgaSA9IC0xIDsgaSA8IGRnTGlzdC5sZW5ndGg7IGkrKyApIHsgXHJcbiAgICAgICAgICAgIGlmICggaSA9PT0gLTEgKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3RpdGxlID0gbmV3IGdyYXBoaWMuVGV4dCh7XHJcbiAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeDogX2RnQ2VsbFggKyA3MCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgeTogX2RnQ2VsbFkgKyA3LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiBcIkRHIExpc3Q6IFwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogX2RnVyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBfZGdILFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxsOiAnIzhGOEI4QScsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHRGb250OiAnMTRweCBNaWNyb3NvZnQgWWFoZWknLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0QmFzZWxpbmU6ICd0b3AnXHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICBkcmFnZ2FibGU6IHRydWVcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hZGQoX3RpdGxlKTtcclxuXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgdmFyIGNlbGxNb2RlbERhdGEgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzb3VyY2VJZDogdXRpbC5nZXRVVUlEKCksIFxyXG4gICAgICAgICAgICAgICAgICAgIGJvdW5kczoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBwZXJMZWZ0OiB7eDogMCwgeTogMH0gIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBcclxuICAgICAgICAgICAgICAgICAgICBzdGVuY2lsOiB7dHlwZTogXCJDbHVzdGVyQXNtQ2VsbE5vZGVcIn1cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgY2VsbE1vZGVsRGF0YS5ib3VuZHMudXBwZXJMZWZ0LnggPSBfZGdDZWxsWDtcclxuICAgICAgICAgICAgICAgIGNlbGxNb2RlbERhdGEuYm91bmRzLnVwcGVyTGVmdC55ID0gX2RnQ2VsbFk7XHJcblxyXG4gICAgICAgICAgICAgICAgY2VsbE1vZGVsRGF0YS5oZWlnaHQgPSBfZGdIO1xyXG4gICAgICAgICAgICAgICAgY2VsbE1vZGVsRGF0YS53aWR0aCA9IF9kZ1c7XHJcbiAgICAgICAgICAgICAgICBjZWxsTW9kZWxEYXRhLnRpdGxlID0gZGdMaXN0W2ldLm5hbWU7XHJcbiAgICAgICAgICAgICAgICBjZWxsTW9kZWxEYXRhLnN0YXR1cyA9IGRnTGlzdFtpXS5zdGF0dXM7XHJcbiAgICAgICAgICAgICAgICB2YXIgY2VsbE1vZGVsID0gbmV3IE5ldHdvcmtNb2RlbChjZWxsTW9kZWxEYXRhKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuYWRkTm9kZUJ5TW9kZWwoY2VsbE1vZGVsLCBhcGkpOyBcclxuXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICBcclxuICAgICAgICAgICAgaWYgKCAoaSArIDIpICUgNCAhPT0gMCApIHtcclxuICAgICAgICAgICAgICAgIF9kZ0NlbGxYID0gX2RnQ2VsbFggKyBfZGdXICsgNTtcclxuICAgICAgICAgICAgICAgIF9kZ0NlbGxZID0gX2RnQ2VsbFk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBfZGdDZWxsWCA9IF9zdGFydFggKyA1O1xyXG4gICAgICAgICAgICAgICAgX2RnQ2VsbFkgPSBfZGdDZWxsWSArIF9kZ0ggKyA1O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHBhcm1EYXRlID0ge307XHJcbiAgICAgICAgcGFybURhdGUudHlwZSA9IFwiYXNtXCI7XHJcbiAgICAgICAgdmFyIGFzbU5vZGUgPSBuZXcgZ3JhcGhpYy5SZWN0KHtcclxuICAgICAgICAgICAgc2hhcGU6IHtcclxuICAgICAgICAgICAgICAgIHI6IDEwLFxyXG4gICAgICAgICAgICAgICAgeDogX3N0YXJ0WCxcclxuICAgICAgICAgICAgICAgIHk6IF9zdGFydFkgKyBmdWxsRGdIZWlnaHQsXHJcbiAgICAgICAgICAgICAgICB3aWR0aDogZnVsbERnV2lkdGgsXHJcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDEwMFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBzdHlsZToge1xyXG4gICAgICAgICAgICAgICAgZmlsbDogJyNGRkZGRkYnLFxyXG4gICAgICAgICAgICAgICAgc3Ryb2tlOiAnIzg4ODg4QicsXHJcbiAgICAgICAgICAgICAgICBvcGFjaXR5OiAxLFxyXG4gICAgICAgICAgICAgICAgbGluZVdpZHRoOiAnMicvLyxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgcGFybURhdGU6IHBhcm1EYXRlICAgICAgICAgICAgIFxyXG4gICAgICAgIH0pOyAgICAgICAgICAgICAgXHJcbiAgICAgICAgdGhpcy5hZGQoYXNtTm9kZSk7XHJcblxyXG4gICAgICAgIC8v6YGN5Y6GQVNN5a6e5L6L5a+56LGhXHJcbiAgICAgICAgdmFyIGFzbURhdGEgPSBtb2RlbC5nZXQoXCJhc21EYXRhXCIpO1xyXG4gICAgICAgIHZhciBmdWxsQXNtSGVpZ2h0ID0gdGhpcy5nZXROb2RlSGVpZ2h0KGFzbURhdGEubGVuZ3RoLCBfZGdILCA0KTtcclxuICAgICAgICAgLy/mt7vliqBERyDljZXlhYNcclxuICAgICAgICB2YXIgX2FzbUNlbGxYID0gX3N0YXJ0WCArIDU7XHJcbiAgICAgICAgdmFyIF9hc21DZWxsWSA9IF9zdGFydFkgKyBmdWxsRGdIZWlnaHQgKyA1O1xyXG5cclxuICAgICAgICBmb3IgKCB2YXIgaiA9IC0xOyBqIDwgYXNtRGF0YS5sZW5ndGg7IGorKyApIHsgXHJcbiAgICAgICAgICAgIGlmICggaiA9PT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIHZhciBfdGl0bGUgPSBuZXcgZ3JhcGhpYy5UZXh0KHtcclxuICAgICAgICAgICAgICAgICAgICBzdHlsZToge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB4OiBfYXNtQ2VsbFggKyA3MCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgeTogX2FzbUNlbGxZICsgNyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogXCJBU03lrp7kvos6IFwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogX2RnVyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBfZGdILFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxsOiAnIzhGOEI4QScsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHRGb250OiAnMTRweCBNaWNyb3NvZnQgWWFoZWknLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0QmFzZWxpbmU6ICd0b3AnXHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICBkcmFnZ2FibGU6IHRydWVcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hZGQoX3RpdGxlKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHZhciBjZWxsTW9kZWxEYXRhID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc291cmNlSWQ6IHV0aWwuZ2V0VVVJRCgpLCBcclxuICAgICAgICAgICAgICAgICAgICBib3VuZHM6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwcGVyTGVmdDoge3g6IDAsIHk6IDB9ICBcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgXHJcbiAgICAgICAgICAgICAgICAgICAgc3RlbmNpbDoge3R5cGU6IFwiQ2x1c3RlckFzbUNlbGxOb2RlXCJ9XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICBcclxuICAgICAgICAgICAgICAgIGNlbGxNb2RlbERhdGEuYm91bmRzLnVwcGVyTGVmdC54ID0gX2FzbUNlbGxYO1xyXG4gICAgICAgICAgICAgICAgY2VsbE1vZGVsRGF0YS5ib3VuZHMudXBwZXJMZWZ0LnkgPSBfYXNtQ2VsbFk7XHJcblxyXG4gICAgICAgICAgICAgICAgY2VsbE1vZGVsRGF0YS5oZWlnaHQgPSBfZGdIO1xyXG4gICAgICAgICAgICAgICAgY2VsbE1vZGVsRGF0YS53aWR0aCA9IF9kZ1c7XHJcbiAgICAgICAgICAgICAgICBjZWxsTW9kZWxEYXRhLnRpdGxlID0gYXNtRGF0YVtqXS5uYW1lO1xyXG4gICAgICAgICAgICAgICAgY2VsbE1vZGVsRGF0YS5zdGF0dXMgPSBhc21EYXRhW2pdLnN0YXR1cztcclxuICAgICAgICAgICAgICAgIHZhciBjZWxsTW9kZWwgPSBuZXcgTmV0d29ya01vZGVsKGNlbGxNb2RlbERhdGEpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hZGROb2RlQnlNb2RlbChjZWxsTW9kZWwsIGFwaSk7IFxyXG5cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgaWYgKCAoaiArIDIpICUgNCAhPT0gMCApIHtcclxuICAgICAgICAgICAgICAgIF9hc21DZWxsWCA9IF9hc21DZWxsWCArIF9kZ1cgKyA1O1xyXG4gICAgICAgICAgICAgICAgX2FzbUNlbGxZID0gX2FzbUNlbGxZO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgX2FzbUNlbGxYID0gX3N0YXJ0WCArIDU7XHJcbiAgICAgICAgICAgICAgICBfYXNtQ2VsbFkgPSBfYXNtQ2VsbFkgKyBfZGdIICsgNTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIF9mdWxsQXNtWCA9IF9zdGFydFggKyAyMDA7XHJcbiAgICAgICAgdmFyIF9mdWxsQXNtWSA9IF9zdGFydFkgKyBmdWxsRGdIZWlnaHQgKyBmdWxsQXNtSGVpZ2h0ICsgMTA7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy/nirbmgIEgXHJcbiAgICAgICAgdmFyIF9hc21TdGF0dXNOb2RlID0gbmV3IGdyYXBoaWMuQ2lyY2xlKHtcclxuICAgICAgICAgICAgIHNoYXBlOiB7XHJcbiAgICAgICAgICAgICAgICBjeDogX2Z1bGxBc21YLFxyXG4gICAgICAgICAgICAgICAgY3k6IF9mdWxsQXNtWSArIDEwLFxyXG4gICAgICAgICAgICAgICAgcjogN1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBzdHlsZToge1xyXG4gICAgICAgICAgICAgICAgZmlsbDogJyMwNzc4MjYnLyosXHJcbiAgICAgICAgICAgICAgICBzdHJva2U6ICcjQjNCM0IzJyxcclxuICAgICAgICAgICAgICAgIGxpbmVXaWR0aDogJzInLy8sKi9cclxuICAgICAgICAgICAgfSBcclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAoIG1vZGVsLmdldChcInN0YXR1c1wiKSA9PT0gXCJvZmZsaW5lXCIpIHtcclxuICAgICAgICAgICAgX2FzbVN0YXR1c05vZGUuc3R5bGUuZmlsbCA9IFwiIzk5OTk5OVwiO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmFkZChfYXNtU3RhdHVzTm9kZSk7XHJcblxyXG4gICAgICAgIHZhciBfYXNtVGl0bGUgPSBuZXcgZ3JhcGhpYy5UZXh0KHtcclxuICAgICAgICAgICAgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgIHg6IF9mdWxsQXNtWCArIDIwLFxyXG4gICAgICAgICAgICAgICAgeTogX2Z1bGxBc21ZLFxyXG4gICAgICAgICAgICAgICAgdGV4dDogXCJBU01cIixcclxuICAgICAgICAgICAgICAgIHdpZHRoOiAxOTAsXHJcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDIwLFxyXG4gICAgICAgICAgICAgICAgZmlsbDogJyM4RjhCOEEnLFxyXG4gICAgICAgICAgICAgICAgdGV4dEZvbnQ6ICcxOHB4IE1pY3Jvc29mdCBZYWhlaScsXHJcbiAgICAgICAgICAgICAgICB0ZXh0QmFzZWxpbmU6ICd0b3AnXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGRyYWdnYWJsZTogdHJ1ZVxyXG4gICAgICAgIH0pOyAgICAgICBcclxuICAgICAgICB0aGlzLmFkZChfYXNtVGl0bGUpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIFxyXG4gICAgICAgIHRoaXMucG9zaXRpb24gPSBbbW9kZWwuZ2V0KFwiYm91bmRzLnVwcGVyTGVmdC54XCIpICwgbW9kZWwuZ2V0KFwiYm91bmRzLnVwcGVyTGVmdC55XCIpXTtcclxuICAgICAgICByZXR1cm4gX3N0YXJ0WSArIGZ1bGxEZ0hlaWdodCArIDEwMDtcclxuICAgIH07XHJcblxyXG4gICAgQ2x1c3RlckFzbU5vZGUucHJvdG90eXBlLmFkZE5vZGVCeU1vZGVsID0gZnVuY3Rpb24oIHBfbW9kZWwsIGFwaSkge1xyXG4gICAgICAgIHZhciBTaGFwZSA9IGFwaS5nZXROb2RlQ2xhc3MocF9tb2RlbC5nZXQoXCJzdGVuY2lsLnR5cGVcIikpO1xyXG4gICAgICAgIHZhciBub2RlID0gbnVsbDtcclxuICAgICAgICBpZiAoIFNoYXBlICkge1xyXG4gICAgICAgICAgICBub2RlID0gbmV3IFNoYXBlKHBfbW9kZWwsIHRoaXMuYXBpKTtcclxuICAgICAgICAgICAgdGhpcy5hZGQobm9kZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcblxyXG4gICAgQ2x1c3RlckFzbU5vZGUucHJvdG90eXBlLmdldE5vZGVIZWlnaHQgID0gZnVuY3Rpb24oIHBfY291bnQsIHBfaGVpZ2h0LCBwX251bSkge1xyXG4gICAgICAgIHZhciByZXR1cm5WYWx1ZSA9IDA7XHJcbiAgICAgICAgaWYoICBwX2NvdW50ICUgcF9udW0gIT09IDAgKSB7XHJcbiAgICAgICAgICAgIHJldHVyblZhbHVlID0gICggKHBhcnNlSW50KHBfY291bnQpIC0gcGFyc2VJbnQocF9jb3VudCkgJSAgcF9udW0pIC8gcF9udW0gICsgMSkgKiAocF9oZWlnaHQgKyA1KSArIDU7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuVmFsdWUgPSAgKCBwYXJzZUludChwX2NvdW50KSAvIHBfbnVtKSAqIChwX2hlaWdodCArIDUpICArIDU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXR1cm5WYWx1ZTtcclxuICAgIH07XHJcblxyXG4gICAgenJVdGlsLmluaGVyaXRzKENsdXN0ZXJBc21Ob2RlLCBOZXR3b3JrTm9kZSk7XHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IENsdXN0ZXJBc21Ob2RlO1xyXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vbGliL2Zpc2gtdG9wby1uZXR3b3JrL2xpYi9ub2RlL2NsdXN0ZXIvQ2x1c3RlckFzbU5vZGUuanNcbiAqKiBtb2R1bGUgaWQgPSAxMTNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlxyXG4gICAgdmFyIHV0aWwgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vZmlzaC10b3BvLWNvcmUvbGliL3V0aWwuanNcIik7XHJcbiAgICB2YXIgTmV0d29ya05vZGUgPSByZXF1aXJlKFwiLi4vTmV0d29ya05vZGVcIik7XHJcbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XHJcbiAgICB2YXIgZ3JhcGhpYyA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi9maXNoLXRvcG8tY29yZS9saWIvZ3JhcGhpYy5qc1wiKTtcclxuICAgIHZhciBOZXR3b3JrTW9kZWwgPSByZXF1aXJlKFwiLi4vLi4vbW9kZWwvTmV0d29ya01vZGVsLmpzXCIpO1xyXG4gICAgXHJcbiAgICBmdW5jdGlvbiBDbHVzdGVyQXNtQ2VsbE5vZGUobW9kZWwsYXBpKSB7XHJcbiAgICAgICAgTmV0d29ya05vZGUuY2FsbCh0aGlzLCBtb2RlbCwgYXBpKTtcclxuICAgICAgICB0aGlzLnJhY2trSW5mbyA9IHt0eXBlOiAtMSwgbmFtZTogXCJDbHVzdGVyQXNtQ2VsbE5vZGVcIiB9OyAgICBcclxuICAgICAgICB0aGlzLm1vZGVsID0gbW9kZWw7XHJcbiAgICAgICAgdGhpcy5saW5lSW5mbyA9IG1vZGVsLmdldCgnbGluZUluZm8nKTtcclxuICAgICAgICB0aGlzLnJlbmRlcihtb2RlbCxhcGkpO1xyXG4gICAgfTtcclxuXHJcbiAgICBDbHVzdGVyQXNtQ2VsbE5vZGUucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uKG1vZGVsLCBhcGkpIHtcclxuICAgICAgICB2YXIgX3kgPSBtb2RlbC5nZXQoXCJib3VuZHMudXBwZXJMZWZ0LnlcIik7XHJcbiAgICAgICAgdmFyIF94ID0gbW9kZWwuZ2V0KFwiYm91bmRzLnVwcGVyTGVmdC54XCIpO1xyXG4gICAgICAgIHZhciBfd2lkdGggPSBtb2RlbC5nZXQoXCJ3aWR0aFwiKTtcclxuICAgICAgICB2YXIgX2hlaWdodCA9IG1vZGVsLmdldChcImhlaWdodFwiKTtcclxuICAgICAgICB2YXIgY2VsbE5vZGUgPSBuZXcgZ3JhcGhpYy5SZWN0KHtcclxuICAgICAgICAgICAgc2hhcGU6IHtcclxuICAgICAgICAgICAgICAgIHI6IDEwLFxyXG4gICAgICAgICAgICAgICAgeDogMCxcclxuICAgICAgICAgICAgICAgIHk6IDAsXHJcbiAgICAgICAgICAgICAgICB3aWR0aDogX3dpZHRoLFxyXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBfaGVpZ2h0XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgICBmaWxsOiAnI0ZGRkZGRicsXHJcbiAgICAgICAgICAgICAgICBzdHJva2U6ICcjODg4ODhCJyxcclxuICAgICAgICAgICAgICAgIG9wYWNpdHk6IDEsXHJcbiAgICAgICAgICAgICAgICBsaW5lV2lkdGg6ICcyJy8vLFxyXG4gICAgICAgICAgICB9ICAgICAgICAgIFxyXG4gICAgICAgIH0pOyAgICAgICAgICAgICAgXHJcbiAgICAgICAgdGhpcy5hZGQoY2VsbE5vZGUpO1xyXG5cclxuICAgICAgICAvL+eKtuaAgSBcclxuICAgICAgICB2YXIgY2VsbFN0YXRlTm9kZSA9IG5ldyBncmFwaGljLkNpcmNsZSh7XHJcbiAgICAgICAgICAgICBzaGFwZToge1xyXG4gICAgICAgICAgICAgICAgY3g6IDEwLFxyXG4gICAgICAgICAgICAgICAgY3k6IDE1LFxyXG4gICAgICAgICAgICAgICAgcjogX2hlaWdodCAvIDIgLSAxMFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBzdHlsZToge1xyXG4gICAgICAgICAgICAgICAgZmlsbDogJyMwNzc4MjYnLyosXHJcbiAgICAgICAgICAgICAgICBzdHJva2U6ICcjQjNCM0IzJyxcclxuICAgICAgICAgICAgICAgIGxpbmVXaWR0aDogJzInLy8sKi9cclxuICAgICAgICAgICAgfSBcclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAoIG1vZGVsLmdldChcInN0YXR1c1wiKSA9PT0gXCJvZmZsaW5lXCIpIHtcclxuICAgICAgICAgICAgY2VsbFN0YXRlTm9kZS5zdHlsZS5maWxsID0gXCIjOTk5OTk5XCI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuYWRkKGNlbGxTdGF0ZU5vZGUpO1xyXG5cclxuICAgICAgICB2YXIgY2VsbFRpdGxlID0gbmV3IGdyYXBoaWMuVGV4dCh7XHJcbiAgICAgICAgICAgIHN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgICB4OiAyMCxcclxuICAgICAgICAgICAgICAgIHk6IDUsXHJcbiAgICAgICAgICAgICAgICB0ZXh0OiBtb2RlbC5nZXQoXCJ0aXRsZVwiKSxcclxuICAgICAgICAgICAgICAgIHdpZHRoOiA1MCxcclxuICAgICAgICAgICAgICAgIGhlaWdodDogMzAsXHJcbiAgICAgICAgICAgICAgICBmaWxsOiAnIzhGOEI4QScsXHJcbiAgICAgICAgICAgICAgICB0ZXh0Rm9udDogJzE0cHggTWljcm9zb2Z0IFlhaGVpJyxcclxuICAgICAgICAgICAgICAgIHRleHRCYXNlbGluZTogJ3RvcCdcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZHJhZ2dhYmxlOiB0cnVlXHJcbiAgICAgICAgfSk7ICAgICAgIFxyXG4gICAgICAgIHRoaXMuYWRkKGNlbGxUaXRsZSk7XHJcblxyXG4gICAgICAgIHRoaXMucG9zaXRpb24gPSBbbW9kZWwuZ2V0KFwiYm91bmRzLnVwcGVyTGVmdC54XCIpLCBtb2RlbC5nZXQoXCJib3VuZHMudXBwZXJMZWZ0LnlcIildO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgenJVdGlsLmluaGVyaXRzKENsdXN0ZXJBc21DZWxsTm9kZSwgTmV0d29ya05vZGUpO1xyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBDbHVzdGVyQXNtQ2VsbE5vZGU7XHJcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9saWIvZmlzaC10b3BvLW5ldHdvcmsvbGliL25vZGUvY2x1c3Rlci9DbHVzdGVyQXNtQ2VsbE5vZGUuanNcbiAqKiBtb2R1bGUgaWQgPSAxMTRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlxyXG4gICAgdmFyIHV0aWwgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vZmlzaC10b3BvLWNvcmUvbGliL3V0aWwuanNcIik7XHJcbiAgICB2YXIgTmV0d29ya05vZGUgPSByZXF1aXJlKFwiLi4vTmV0d29ya05vZGVcIik7XHJcbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XHJcbiAgICB2YXIgZ3JhcGhpYyA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi9maXNoLXRvcG8tY29yZS9saWIvZ3JhcGhpYy5qc1wiKTtcclxuICAgIHZhciBOZXR3b3JrTW9kZWwgPSByZXF1aXJlKFwiLi4vLi4vbW9kZWwvTmV0d29ya01vZGVsLmpzXCIpO1xyXG4gICAgdmFyIElTRU1vZGVsID0gcmVxdWlyZShcIi4uLy4uL21vZGVsL2NsdXN0ZXIvSVNFTW9kZWwuanNcIik7XHJcbiAgICBmdW5jdGlvbiBDbHVzdGVySXNlTm9kZShtb2RlbCxhcGkpIHtcclxuICAgICAgICBOZXR3b3JrTm9kZS5jYWxsKHRoaXMsIG1vZGVsLCBhcGkpO1xyXG4gICAgICAgIHRoaXMucmFja2tJbmZvID0ge3R5cGU6IC0xLCBuYW1lOiBcIkNsdXN0ZXJJc2VOb2RlXCIgfTsgICAgXHJcbiAgICAgICAgdGhpcy5tb2RlbCA9IG1vZGVsO1xyXG4gICAgICAgIHRoaXMubGluZUluZm8gPSBtb2RlbC5nZXQoJ2xpbmVJbmZvJyk7XHJcbiAgICAgICAgdGhpcy5yZW5kZXIobW9kZWwsYXBpKTtcclxuICAgIH07XHJcblxyXG4gICAgQ2x1c3RlcklzZU5vZGUucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uKG1vZGVsLCBhcGkpIHtcclxuICAgICAgICB2YXIgaXNlTGlzdCA9IG1vZGVsLmdldChcImNoaWxkTm9kZUxpc3RcIik7XHJcbiAgICAgICAgdmFyIHN0YXJ0WCA9IDA7XHJcbiAgICAgICAgdmFyIHN0YXJ0WSA9IDA7XHJcbiAgICAgICAgdmFyIG5vZGVXaWR0aCA9IDA7XHJcbiAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgaXNlTGlzdC5sZW5ndGg7IGkrKyApIHtcclxuICAgICAgICAgICAgdmFyIGlzZWRhdGEgPSB7XHJcbiAgICAgICAgICAgICAgICByZXNvdXJjZUlkOiB1dGlsLmdldFVVSUQoKSwgIFxyXG4gICAgICAgICAgICAgICAgYm91bmRzOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdXBwZXJMZWZ0OiB7eDogc3RhcnRYLCB5OiBzdGFydFl9ICBcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBzdGVuY2lsOiB7dHlwZTogXCJDbHVzdGVySXNlQ2VsbE5vZGVcIn1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgaXNlZGF0YS53aWR0aCA9IDEwMDtcclxuICAgICAgICAgICAgaXNlZGF0YS5oZWlnaHQgPSAxNTA7XHJcbiAgICAgICAgICAgIGlzZWRhdGEuc3RhdHVzID0gaXNlTGlzdFtpXS5zdGF0dXM7XHJcbiAgICAgICAgICAgIGlzZWRhdGEudGl0bGUgPSBpc2VMaXN0W2ldLm5hbWU7XHJcbiAgICAgICAgICAgIGlzZWRhdGEuY2hpbGROb2RlTGlzdCA9IGlzZUxpc3RbaV0uZGlzaztcclxuICAgICAgICAgICAgdmFyIGlzZUNlbGxNb2RlbCA9IG5ldyBJU0VNb2RlbChpc2VkYXRhKTtcclxuICAgICAgICAgICAgdGhpcy5hZGROb2RlQnlNb2RlbChpc2VDZWxsTW9kZWwsIGFwaSk7XHJcbiAgICAgICAgICAgIHN0YXJ0WCA9IHN0YXJ0WCArIDEwMCArIDUwO1xyXG4gICAgICAgICAgICBub2RlV2lkdGggPSBub2RlV2lkdGggKyAxNTA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgX3ggPSAoYXBpLmdldFdpZHRoKCkgLSBub2RlV2lkdGgpIC8gMjtcclxuICAgICAgICB0aGlzLnBvc2l0aW9uID0gW194ICwgbW9kZWwuZ2V0KFwiYm91bmRzLnVwcGVyTGVmdC55XCIpXTtcclxuICAgIH07XHJcblxyXG4gICAgQ2x1c3RlcklzZU5vZGUucHJvdG90eXBlLmFkZE5vZGVCeU1vZGVsID0gZnVuY3Rpb24oIHBfbW9kZWwsIGFwaSkge1xyXG4gICAgICAgIHZhciBTaGFwZSA9IGFwaS5nZXROb2RlQ2xhc3MocF9tb2RlbC5nZXQoXCJzdGVuY2lsLnR5cGVcIikpO1xyXG4gICAgICAgIHZhciBub2RlID0gbnVsbDtcclxuICAgICAgICBpZiAoIFNoYXBlICkge1xyXG4gICAgICAgICAgICBub2RlID0gbmV3IFNoYXBlKHBfbW9kZWwsIHRoaXMuYXBpKTtcclxuICAgICAgICAgICAgdGhpcy5hZGQobm9kZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcblxyXG4gICAgQ2x1c3RlcklzZU5vZGUucHJvdG90eXBlLmdldERnTm9kZVdpZHRoICA9IGZ1bmN0aW9uKCBwX2NvdW50LCBwX2hlaWdodCwgcF9zcGFjZSkge1xyXG4gICAgICAgIHZhciByZXR1cm5WYWx1ZSA9IDA7XHJcbiAgICAgICBcclxuICAgICAgICByZXR1cm4gcmV0dXJuVmFsdWU7XHJcbiAgICB9O1xyXG5cclxuICAgIHpyVXRpbC5pbmhlcml0cyhDbHVzdGVySXNlTm9kZSwgTmV0d29ya05vZGUpO1xyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBDbHVzdGVySXNlTm9kZTtcclxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2xpYi9maXNoLXRvcG8tbmV0d29yay9saWIvbm9kZS9jbHVzdGVyL0NsdXN0ZXJJc2VOb2RlLmpzXG4gKiogbW9kdWxlIGlkID0gMTE1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcclxuICAgIHZhciB1dGlsID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uL2Zpc2gtdG9wby1jb3JlL2xpYi91dGlsLmpzXCIpO1xyXG4gICAgdmFyIE5ldHdvcmtOb2RlID0gcmVxdWlyZShcIi4uL05ldHdvcmtOb2RlXCIpO1xyXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xyXG4gICAgdmFyIGdyYXBoaWMgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vZmlzaC10b3BvLWNvcmUvbGliL2dyYXBoaWMuanNcIik7XHJcbiAgICB2YXIgTmV0d29ya01vZGVsID0gcmVxdWlyZShcIi4uLy4uL21vZGVsL05ldHdvcmtNb2RlbC5qc1wiKTtcclxuICAgIFxyXG4gICAgZnVuY3Rpb24gQ2x1c3RlcklzZUNlbGxOb2RlKG1vZGVsLGFwaSkge1xyXG4gICAgICAgIE5ldHdvcmtOb2RlLmNhbGwodGhpcywgbW9kZWwsIGFwaSk7XHJcbiAgICAgICAgdGhpcy5yYWNra0luZm8gPSB7dHlwZTogLTEsIG5hbWU6IFwiQ2x1c3RlcklzZUNlbGxOb2RlXCIgfTsgICAgXHJcbiAgICAgICAgdGhpcy5tb2RlbCA9IG1vZGVsO1xyXG4gICAgICAgIHRoaXMubGluZUluZm8gPSBtb2RlbC5nZXQoJ2xpbmVJbmZvJyk7XHJcbiAgICAgICAgdGhpcy5yZW5kZXIobW9kZWwsYXBpKTtcclxuICAgIH07XHJcblxyXG4gICAgQ2x1c3RlcklzZUNlbGxOb2RlLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbihtb2RlbCwgYXBpKSB7XHJcbiAgICAgICAgdmFyIGlzZWNlbGxOb2RlID0gbmV3IGdyYXBoaWMuUmVjdCh7XHJcbiAgICAgICAgICAgIHNoYXBlOiB7XHJcbiAgICAgICAgICAgICAgICByOiAxMCxcclxuICAgICAgICAgICAgICAgIHg6IDAsXHJcbiAgICAgICAgICAgICAgICB5OiAwLFxyXG4gICAgICAgICAgICAgICAgd2lkdGg6IDEyMCxcclxuICAgICAgICAgICAgICAgIGhlaWdodDogMTAwXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgICBmaWxsOiAnI0ZGRkZGRicsXHJcbiAgICAgICAgICAgICAgICBzdHJva2U6ICcjODg4ODhCJyxcclxuICAgICAgICAgICAgICAgIG9wYWNpdHk6IDEsXHJcbiAgICAgICAgICAgICAgICBsaW5lV2lkdGg6ICcyJy8vLFxyXG4gICAgICAgICAgICB9ICAgICAgICAgIFxyXG4gICAgICAgIH0pOyAgICAgICAgICAgICAgXHJcbiAgICAgICAgdGhpcy5hZGQoaXNlY2VsbE5vZGUpO1xyXG5cclxuICAgICAgICAvL+eKtuaAgSBcclxuICAgICAgICB2YXIgaXNlY2VsbFN0YXR1cyA9IG5ldyBncmFwaGljLkNpcmNsZSh7XHJcbiAgICAgICAgICAgICBzaGFwZToge1xyXG4gICAgICAgICAgICAgICAgY3g6IDE1LFxyXG4gICAgICAgICAgICAgICAgY3k6IDQ1LFxyXG4gICAgICAgICAgICAgICAgcjogNVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBzdHlsZToge1xyXG4gICAgICAgICAgICAgICAgZmlsbDogJyMwNzc4MjYnLyosXHJcbiAgICAgICAgICAgICAgICBzdHJva2U6ICcjODk4OThCJyxcclxuICAgICAgICAgICAgICAgIGxpbmVXaWR0aDogJzInLy8sKi9cclxuICAgICAgICAgICAgfSBcclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAoIG1vZGVsLmdldChcInN0YXR1c1wiKSA9PT0gXCJvZmZsaW5lXCIpIHtcclxuICAgICAgICAgICAgaXNlY2VsbFN0YXR1cy5zdHlsZS5maWxsID0gXCIjOTk5OTk5XCI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuYWRkKGlzZWNlbGxTdGF0dXMpO1xyXG5cclxuICAgICAgICB2YXIgaXNlY2VsbFRpdGxlID0gbmV3IGdyYXBoaWMuVGV4dCh7XHJcbiAgICAgICAgICAgIHN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgICB4OiAyNSxcclxuICAgICAgICAgICAgICAgIHk6IDM1LFxyXG4gICAgICAgICAgICAgICAgdGV4dDogXCJJU0U6IFwiICsgbW9kZWwuZ2V0KFwidGl0bGVcIiksXHJcbiAgICAgICAgICAgICAgICB3aWR0aDogNTAsXHJcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDMwLFxyXG4gICAgICAgICAgICAgICAgZmlsbDogJyMwMjAyMDInLFxyXG4gICAgICAgICAgICAgICAgdGV4dEZvbnQ6ICcxNHB4IE1pY3Jvc29mdCBZYWhlaScsXHJcbiAgICAgICAgICAgICAgICB0ZXh0QmFzZWxpbmU6ICd0b3AnXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGRyYWdnYWJsZTogdHJ1ZVxyXG4gICAgICAgIH0pOyAgICAgICBcclxuICAgICAgICB0aGlzLmFkZChpc2VjZWxsVGl0bGUpO1xyXG5cclxuICAgICAgICB0aGlzLnBvc2l0aW9uID0gW21vZGVsLmdldChcImJvdW5kcy51cHBlckxlZnQueFwiKSwgbW9kZWwuZ2V0KFwiYm91bmRzLnVwcGVyTGVmdC55XCIpXTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIHpyVXRpbC5pbmhlcml0cyhDbHVzdGVySXNlQ2VsbE5vZGUsIE5ldHdvcmtOb2RlKTtcclxuICAgIG1vZHVsZS5leHBvcnRzID0gQ2x1c3RlcklzZUNlbGxOb2RlO1xyXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vbGliL2Zpc2gtdG9wby1uZXR3b3JrL2xpYi9ub2RlL2NsdXN0ZXIvQ2x1c3RlcklzZUNlbGxOb2RlLmpzXG4gKiogbW9kdWxlIGlkID0gMTE2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcbiAgICByZXF1aXJlKCcuL2dyYXBoaWMnKTtcbiAgICByZXF1aXJlKCcuLi96cmVuZGVyJykucmVnaXN0ZXJQYWludGVyKCd2bWwnLCByZXF1aXJlKCcuL1BhaW50ZXInKSk7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi96cmVuZGVyL2xpYi92bWwvdm1sLmpzXG4gKiogbW9kdWxlIGlkID0gMTE3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9OT1RFLVZNTFxuLy8gVE9ETyBVc2UgcHJveHkgbGlrZSBzdmcgaW5zdGVhZCBvZiBvdmVyd3JpdGUgYnJ1c2ggbWV0aG9kc1xuXG5cbmlmICghcmVxdWlyZSgnLi4vY29yZS9lbnYnKS5jYW52YXNTdXBwb3J0ZWQpIHtcbiAgICB2YXIgdmVjMiA9IHJlcXVpcmUoJy4uL2NvcmUvdmVjdG9yJyk7XG4gICAgdmFyIEJvdW5kaW5nUmVjdCA9IHJlcXVpcmUoJy4uL2NvcmUvQm91bmRpbmdSZWN0Jyk7XG4gICAgdmFyIENNRCA9IHJlcXVpcmUoJy4uL2NvcmUvUGF0aFByb3h5JykuQ01EO1xuICAgIHZhciBjb2xvclRvb2wgPSByZXF1aXJlKCcuLi90b29sL2NvbG9yJyk7XG4gICAgdmFyIHRleHRDb250YWluID0gcmVxdWlyZSgnLi4vY29udGFpbi90ZXh0Jyk7XG4gICAgdmFyIFJlY3RUZXh0ID0gcmVxdWlyZSgnLi4vZ3JhcGhpYy9taXhpbi9SZWN0VGV4dCcpO1xuICAgIHZhciBEaXNwbGF5YWJsZSA9IHJlcXVpcmUoJy4uL2dyYXBoaWMvRGlzcGxheWFibGUnKTtcbiAgICB2YXIgWkltYWdlID0gcmVxdWlyZSgnLi4vZ3JhcGhpYy9JbWFnZScpO1xuICAgIHZhciBUZXh0ID0gcmVxdWlyZSgnLi4vZ3JhcGhpYy9UZXh0Jyk7XG4gICAgdmFyIFBhdGggPSByZXF1aXJlKCcuLi9ncmFwaGljL1BhdGgnKTtcblxuICAgIHZhciBHcmFkaWVudCA9IHJlcXVpcmUoJy4uL2dyYXBoaWMvR3JhZGllbnQnKTtcblxuICAgIHZhciB2bWxDb3JlID0gcmVxdWlyZSgnLi9jb3JlJyk7XG5cbiAgICB2YXIgcm91bmQgPSBNYXRoLnJvdW5kO1xuICAgIHZhciBzcXJ0ID0gTWF0aC5zcXJ0O1xuICAgIHZhciBhYnMgPSBNYXRoLmFicztcbiAgICB2YXIgY29zID0gTWF0aC5jb3M7XG4gICAgdmFyIHNpbiA9IE1hdGguc2luO1xuICAgIHZhciBtYXRoTWF4ID0gTWF0aC5tYXg7XG5cbiAgICB2YXIgYXBwbHlUcmFuc2Zvcm0gPSB2ZWMyLmFwcGx5VHJhbnNmb3JtO1xuXG4gICAgdmFyIGNvbW1hID0gJywnO1xuICAgIHZhciBpbWFnZVRyYW5zZm9ybVByZWZpeCA9ICdwcm9naWQ6RFhJbWFnZVRyYW5zZm9ybS5NaWNyb3NvZnQnO1xuXG4gICAgdmFyIFogPSAyMTYwMDtcbiAgICB2YXIgWjIgPSBaIC8gMjtcblxuICAgIHZhciBaTEVWRUxfQkFTRSA9IDEwMDAwMDtcbiAgICB2YXIgWl9CQVNFID0gMTAwMDtcblxuICAgIHZhciBpbml0Um9vdEVsU3R5bGUgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgZWwuc3R5bGUuY3NzVGV4dCA9ICdwb3NpdGlvbjphYnNvbHV0ZTtsZWZ0OjA7dG9wOjA7d2lkdGg6MXB4O2hlaWdodDoxcHg7JztcbiAgICAgICAgZWwuY29vcmRzaXplID0gWiArICcsJyAgKyBaO1xuICAgICAgICBlbC5jb29yZG9yaWdpbiA9ICcwLDAnO1xuICAgIH07XG5cbiAgICB2YXIgZW5jb2RlSHRtbEF0dHJpYnV0ZSA9IGZ1bmN0aW9uIChzKSB7XG4gICAgICAgIHJldHVybiBTdHJpbmcocykucmVwbGFjZSgvJi9nLCAnJmFtcDsnKS5yZXBsYWNlKC9cIi9nLCAnJnF1b3Q7Jyk7XG4gICAgfTtcblxuICAgIHZhciByZ2IyU3RyID0gZnVuY3Rpb24gKHIsIGcsIGIpIHtcbiAgICAgICAgcmV0dXJuICdyZ2IoJyArIFtyLCBnLCBiXS5qb2luKCcsJykgKyAnKSc7XG4gICAgfTtcblxuICAgIHZhciBhcHBlbmQgPSBmdW5jdGlvbiAocGFyZW50LCBjaGlsZCkge1xuICAgICAgICBpZiAoY2hpbGQgJiYgcGFyZW50ICYmIGNoaWxkLnBhcmVudE5vZGUgIT09IHBhcmVudCkge1xuICAgICAgICAgICAgcGFyZW50LmFwcGVuZENoaWxkKGNoaWxkKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgcmVtb3ZlID0gZnVuY3Rpb24gKHBhcmVudCwgY2hpbGQpIHtcbiAgICAgICAgaWYgKGNoaWxkICYmIHBhcmVudCAmJiBjaGlsZC5wYXJlbnROb2RlID09PSBwYXJlbnQpIHtcbiAgICAgICAgICAgIHBhcmVudC5yZW1vdmVDaGlsZChjaGlsZCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIGdldFpJbmRleCA9IGZ1bmN0aW9uICh6bGV2ZWwsIHosIHoyKSB7XG4gICAgICAgIC8vIHog55qE5Y+W5YC86IyD5Zu05Li6IFswLCAxMDAwXVxuICAgICAgICByZXR1cm4gKHBhcnNlRmxvYXQoemxldmVsKSB8fCAwKSAqIFpMRVZFTF9CQVNFICsgKHBhcnNlRmxvYXQoeikgfHwgMCkgKiBaX0JBU0UgKyB6MjtcbiAgICB9O1xuXG4gICAgdmFyIHBhcnNlUGVyY2VudCA9IGZ1bmN0aW9uICh2YWx1ZSwgbWF4VmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZS5sYXN0SW5kZXhPZignJScpID49IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VGbG9hdCh2YWx1ZSkgLyAxMDAgKiBtYXhWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwYXJzZUZsb2F0KHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcblxuICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAgKiBQQVRIXG4gICAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgdmFyIHNldENvbG9yQW5kT3BhY2l0eSA9IGZ1bmN0aW9uIChlbCwgY29sb3IsIG9wYWNpdHkpIHtcbiAgICAgICAgdmFyIGNvbG9yQXJyID0gY29sb3JUb29sLnBhcnNlKGNvbG9yKTtcbiAgICAgICAgb3BhY2l0eSA9ICtvcGFjaXR5O1xuICAgICAgICBpZiAoaXNOYU4ob3BhY2l0eSkpIHtcbiAgICAgICAgICAgIG9wYWNpdHkgPSAxO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb2xvckFycikge1xuICAgICAgICAgICAgZWwuY29sb3IgPSByZ2IyU3RyKGNvbG9yQXJyWzBdLCBjb2xvckFyclsxXSwgY29sb3JBcnJbMl0pO1xuICAgICAgICAgICAgZWwub3BhY2l0eSA9IG9wYWNpdHkgKiBjb2xvckFyclszXTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgZ2V0Q29sb3JBbmRBbHBoYSA9IGZ1bmN0aW9uIChjb2xvcikge1xuICAgICAgICB2YXIgY29sb3JBcnIgPSBjb2xvclRvb2wucGFyc2UoY29sb3IpO1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgcmdiMlN0cihjb2xvckFyclswXSwgY29sb3JBcnJbMV0sIGNvbG9yQXJyWzJdKSxcbiAgICAgICAgICAgIGNvbG9yQXJyWzNdXG4gICAgICAgIF07XG4gICAgfTtcblxuICAgIHZhciB1cGRhdGVGaWxsTm9kZSA9IGZ1bmN0aW9uIChlbCwgc3R5bGUsIHpyRWwpIHtcbiAgICAgICAgLy8gVE9ETyBwYXR0ZXJuXG4gICAgICAgIHZhciBmaWxsID0gc3R5bGUuZmlsbDtcbiAgICAgICAgaWYgKGZpbGwgIT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gTW9kaWZpZWQgZnJvbSBleGNhbnZhc1xuICAgICAgICAgICAgaWYgKGZpbGwgaW5zdGFuY2VvZiBHcmFkaWVudCkge1xuICAgICAgICAgICAgICAgIHZhciBncmFkaWVudFR5cGU7XG4gICAgICAgICAgICAgICAgdmFyIGFuZ2xlID0gMDtcbiAgICAgICAgICAgICAgICB2YXIgZm9jdXMgPSBbMCwgMF07XG4gICAgICAgICAgICAgICAgLy8gYWRkaXRpb25hbCBvZmZzZXRcbiAgICAgICAgICAgICAgICB2YXIgc2hpZnQgPSAwO1xuICAgICAgICAgICAgICAgIC8vIHNjYWxlIGZhY3RvciBmb3Igb2Zmc2V0XG4gICAgICAgICAgICAgICAgdmFyIGV4cGFuc2lvbiA9IDE7XG4gICAgICAgICAgICAgICAgdmFyIHJlY3QgPSB6ckVsLmdldEJvdW5kaW5nUmVjdCgpO1xuICAgICAgICAgICAgICAgIHZhciByZWN0V2lkdGggPSByZWN0LndpZHRoO1xuICAgICAgICAgICAgICAgIHZhciByZWN0SGVpZ2h0ID0gcmVjdC5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgaWYgKGZpbGwudHlwZSA9PT0gJ2xpbmVhcicpIHtcbiAgICAgICAgICAgICAgICAgICAgZ3JhZGllbnRUeXBlID0gJ2dyYWRpZW50JztcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRyYW5zZm9ybSA9IHpyRWwudHJhbnNmb3JtO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcDAgPSBbZmlsbC54ICogcmVjdFdpZHRoLCBmaWxsLnkgKiByZWN0SGVpZ2h0XTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHAxID0gW2ZpbGwueDIgKiByZWN0V2lkdGgsIGZpbGwueTIgKiByZWN0SGVpZ2h0XTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRyYW5zZm9ybSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXBwbHlUcmFuc2Zvcm0ocDAsIHAwLCB0cmFuc2Zvcm0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXBwbHlUcmFuc2Zvcm0ocDEsIHAxLCB0cmFuc2Zvcm0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBkeCA9IHAxWzBdIC0gcDBbMF07XG4gICAgICAgICAgICAgICAgICAgIHZhciBkeSA9IHAxWzFdIC0gcDBbMV07XG4gICAgICAgICAgICAgICAgICAgIGFuZ2xlID0gTWF0aC5hdGFuMihkeCwgZHkpICogMTgwIC8gTWF0aC5QSTtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGFuZ2xlIHNob3VsZCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXIuXG4gICAgICAgICAgICAgICAgICAgIGlmIChhbmdsZSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFuZ2xlICs9IDM2MDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIFZlcnkgc21hbGwgYW5nbGVzIHByb2R1Y2UgYW4gdW5leHBlY3RlZCByZXN1bHQgYmVjYXVzZSB0aGV5IGFyZVxuICAgICAgICAgICAgICAgICAgICAvLyBjb252ZXJ0ZWQgdG8gYSBzY2llbnRpZmljIG5vdGF0aW9uIHN0cmluZy5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGFuZ2xlIDwgMWUtNikge1xuICAgICAgICAgICAgICAgICAgICAgICAgYW5nbGUgPSAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBncmFkaWVudFR5cGUgPSAnZ3JhZGllbnRyYWRpYWwnO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcDAgPSBbZmlsbC54ICogcmVjdFdpZHRoLCBmaWxsLnkgKiByZWN0SGVpZ2h0XTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRyYW5zZm9ybSA9IHpyRWwudHJhbnNmb3JtO1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2NhbGUgPSB6ckVsLnNjYWxlO1xuICAgICAgICAgICAgICAgICAgICB2YXIgd2lkdGggPSByZWN0V2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIHZhciBoZWlnaHQgPSByZWN0SGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICBmb2N1cyA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFBlcmNlbnQgaW4gYm91bmRpbmcgcmVjdFxuICAgICAgICAgICAgICAgICAgICAgICAgKHAwWzBdIC0gcmVjdC54KSAvIHdpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgKHAwWzFdIC0gcmVjdC55KSAvIGhlaWdodFxuICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHJhbnNmb3JtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcHBseVRyYW5zZm9ybShwMCwgcDAsIHRyYW5zZm9ybSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB3aWR0aCAvPSBzY2FsZVswXSAqIFo7XG4gICAgICAgICAgICAgICAgICAgIGhlaWdodCAvPSBzY2FsZVsxXSAqIFo7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkaW1lbnNpb24gPSBtYXRoTWF4KHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgICBzaGlmdCA9IDIgKiAwIC8gZGltZW5zaW9uO1xuICAgICAgICAgICAgICAgICAgICBleHBhbnNpb24gPSAyICogZmlsbC5yIC8gZGltZW5zaW9uIC0gc2hpZnQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gV2UgbmVlZCB0byBzb3J0IHRoZSBjb2xvciBzdG9wcyBpbiBhc2NlbmRpbmcgb3JkZXIgYnkgb2Zmc2V0LFxuICAgICAgICAgICAgICAgIC8vIG90aGVyd2lzZSBJRSB3b24ndCBpbnRlcnByZXQgaXQgY29ycmVjdGx5LlxuICAgICAgICAgICAgICAgIHZhciBzdG9wcyA9IGZpbGwuY29sb3JTdG9wcy5zbGljZSgpO1xuICAgICAgICAgICAgICAgIHN0b3BzLnNvcnQoZnVuY3Rpb24oY3MxLCBjczIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNzMS5vZmZzZXQgLSBjczIub2Zmc2V0O1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgdmFyIGxlbmd0aCA9IHN0b3BzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAvLyBDb2xvciBhbmQgYWxwaGEgbGlzdCBvZiBmaXJzdCBhbmQgbGFzdCBzdG9wXG4gICAgICAgICAgICAgICAgdmFyIGNvbG9yQW5kQWxwaGFMaXN0ID0gW107XG4gICAgICAgICAgICAgICAgdmFyIGNvbG9ycyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0b3AgPSBzdG9wc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbG9yQW5kQWxwaGEgPSBnZXRDb2xvckFuZEFscGhhKHN0b3AuY29sb3IpO1xuICAgICAgICAgICAgICAgICAgICBjb2xvcnMucHVzaChzdG9wLm9mZnNldCAqIGV4cGFuc2lvbiArIHNoaWZ0ICsgJyAnICsgY29sb3JBbmRBbHBoYVswXSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpID09PSAwIHx8IGkgPT09IGxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yQW5kQWxwaGFMaXN0LnB1c2goY29sb3JBbmRBbHBoYSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAobGVuZ3RoID49IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbG9yMSA9IGNvbG9yQW5kQWxwaGFMaXN0WzBdWzBdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29sb3IyID0gY29sb3JBbmRBbHBoYUxpc3RbMV1bMF07XG4gICAgICAgICAgICAgICAgICAgIHZhciBvcGFjaXR5MSA9IGNvbG9yQW5kQWxwaGFMaXN0WzBdWzFdICogc3R5bGUub3BhY2l0eTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9wYWNpdHkyID0gY29sb3JBbmRBbHBoYUxpc3RbMV1bMV0gKiBzdHlsZS5vcGFjaXR5O1xuXG4gICAgICAgICAgICAgICAgICAgIGVsLnR5cGUgPSBncmFkaWVudFR5cGU7XG4gICAgICAgICAgICAgICAgICAgIGVsLm1ldGhvZCA9ICdub25lJztcbiAgICAgICAgICAgICAgICAgICAgZWwuZm9jdXMgPSAnMTAwJSc7XG4gICAgICAgICAgICAgICAgICAgIGVsLmFuZ2xlID0gYW5nbGU7XG4gICAgICAgICAgICAgICAgICAgIGVsLmNvbG9yID0gY29sb3IxO1xuICAgICAgICAgICAgICAgICAgICBlbC5jb2xvcjIgPSBjb2xvcjI7XG4gICAgICAgICAgICAgICAgICAgIGVsLmNvbG9ycyA9IGNvbG9ycy5qb2luKCcsJyk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdoZW4gY29sb3JzIGF0dHJpYnV0ZSBpcyB1c2VkLCB0aGUgbWVhbmluZ3Mgb2Ygb3BhY2l0eSBhbmQgbzpvcGFjaXR5MlxuICAgICAgICAgICAgICAgICAgICAvLyBhcmUgcmV2ZXJzZWQuXG4gICAgICAgICAgICAgICAgICAgIGVsLm9wYWNpdHkgPSBvcGFjaXR5MjtcbiAgICAgICAgICAgICAgICAgICAgLy8gRklYTUUgZ19vXzpvcGFjaXR5ID9cbiAgICAgICAgICAgICAgICAgICAgZWwub3BhY2l0eTIgPSBvcGFjaXR5MTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGdyYWRpZW50VHlwZSA9PT0gJ3JhZGlhbCcpIHtcbiAgICAgICAgICAgICAgICAgICAgZWwuZm9jdXNwb3NpdGlvbiA9IGZvY3VzLmpvaW4oJywnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBGSVhNRSBDaGFuZ2UgZnJvbSBHcmFkaWVudCBmaWxsIHRvIGNvbG9yIGZpbGxcbiAgICAgICAgICAgICAgICBzZXRDb2xvckFuZE9wYWNpdHkoZWwsIGZpbGwsIHN0eWxlLm9wYWNpdHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciB1cGRhdGVTdHJva2VOb2RlID0gZnVuY3Rpb24gKGVsLCBzdHlsZSkge1xuICAgICAgICAvLyBpZiAoc3R5bGUubGluZUpvaW4gIT0gbnVsbCkge1xuICAgICAgICAvLyAgICAgZWwuam9pbnN0eWxlID0gc3R5bGUubGluZUpvaW47XG4gICAgICAgIC8vIH1cbiAgICAgICAgLy8gaWYgKHN0eWxlLm1pdGVyTGltaXQgIT0gbnVsbCkge1xuICAgICAgICAvLyAgICAgZWwubWl0ZXJsaW1pdCA9IHN0eWxlLm1pdGVyTGltaXQgKiBaO1xuICAgICAgICAvLyB9XG4gICAgICAgIC8vIGlmIChzdHlsZS5saW5lQ2FwICE9IG51bGwpIHtcbiAgICAgICAgLy8gICAgIGVsLmVuZGNhcCA9IHN0eWxlLmxpbmVDYXA7XG4gICAgICAgIC8vIH1cbiAgICAgICAgaWYgKHN0eWxlLmxpbmVEYXNoICE9IG51bGwpIHtcbiAgICAgICAgICAgIGVsLmRhc2hzdHlsZSA9IHN0eWxlLmxpbmVEYXNoLmpvaW4oJyAnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3R5bGUuc3Ryb2tlICE9IG51bGwgJiYgIShzdHlsZS5zdHJva2UgaW5zdGFuY2VvZiBHcmFkaWVudCkpIHtcbiAgICAgICAgICAgIHNldENvbG9yQW5kT3BhY2l0eShlbCwgc3R5bGUuc3Ryb2tlLCBzdHlsZS5vcGFjaXR5KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgdXBkYXRlRmlsbEFuZFN0cm9rZSA9IGZ1bmN0aW9uICh2bWxFbCwgdHlwZSwgc3R5bGUsIHpyRWwpIHtcbiAgICAgICAgdmFyIGlzRmlsbCA9IHR5cGUgPT0gJ2ZpbGwnO1xuICAgICAgICB2YXIgZWwgPSB2bWxFbC5nZXRFbGVtZW50c0J5VGFnTmFtZSh0eXBlKVswXTtcbiAgICAgICAgLy8gU3Ryb2tlIG11c3QgaGF2ZSBsaW5lV2lkdGhcbiAgICAgICAgaWYgKHN0eWxlW3R5cGVdICE9IG51bGwgJiYgc3R5bGVbdHlwZV0gIT09ICdub25lJyAmJiAoaXNGaWxsIHx8ICghaXNGaWxsICYmIHN0eWxlLmxpbmVXaWR0aCkpKSB7XG4gICAgICAgICAgICB2bWxFbFtpc0ZpbGwgPyAnZmlsbGVkJyA6ICdzdHJva2VkJ10gPSAndHJ1ZSc7XG4gICAgICAgICAgICAvLyBGSVhNRSBSZW1vdmUgYmVmb3JlIHVwZGF0aW5nLCBvciBzZXQgYGNvbG9yc2Agd2lsbCB0aHJvdyBlcnJvclxuICAgICAgICAgICAgaWYgKHN0eWxlW3R5cGVdIGluc3RhbmNlb2YgR3JhZGllbnQpIHtcbiAgICAgICAgICAgICAgICByZW1vdmUodm1sRWwsIGVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghZWwpIHtcbiAgICAgICAgICAgICAgICBlbCA9IHZtbENvcmUuY3JlYXRlTm9kZSh0eXBlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaXNGaWxsID8gdXBkYXRlRmlsbE5vZGUoZWwsIHN0eWxlLCB6ckVsKSA6IHVwZGF0ZVN0cm9rZU5vZGUoZWwsIHN0eWxlKTtcbiAgICAgICAgICAgIGFwcGVuZCh2bWxFbCwgZWwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdm1sRWxbaXNGaWxsID8gJ2ZpbGxlZCcgOiAnc3Ryb2tlZCddID0gJ2ZhbHNlJztcbiAgICAgICAgICAgIHJlbW92ZSh2bWxFbCwgZWwpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciBwb2ludHMgPSBbW10sIFtdLCBbXV07XG4gICAgdmFyIHBhdGhEYXRhVG9TdHJpbmcgPSBmdW5jdGlvbiAoZGF0YSwgbSkge1xuICAgICAgICB2YXIgTSA9IENNRC5NO1xuICAgICAgICB2YXIgQyA9IENNRC5DO1xuICAgICAgICB2YXIgTCA9IENNRC5MO1xuICAgICAgICB2YXIgQSA9IENNRC5BO1xuICAgICAgICB2YXIgUSA9IENNRC5RO1xuXG4gICAgICAgIHZhciBzdHIgPSBbXTtcbiAgICAgICAgdmFyIG5Qb2ludDtcbiAgICAgICAgdmFyIGNtZFN0cjtcbiAgICAgICAgdmFyIGNtZDtcbiAgICAgICAgdmFyIGk7XG4gICAgICAgIHZhciB4aTtcbiAgICAgICAgdmFyIHlpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7KSB7XG4gICAgICAgICAgICBjbWQgPSBkYXRhW2krK107XG4gICAgICAgICAgICBjbWRTdHIgPSAnJztcbiAgICAgICAgICAgIG5Qb2ludCA9IDA7XG4gICAgICAgICAgICBzd2l0Y2ggKGNtZCkge1xuICAgICAgICAgICAgICAgIGNhc2UgTTpcbiAgICAgICAgICAgICAgICAgICAgY21kU3RyID0gJyBtICc7XG4gICAgICAgICAgICAgICAgICAgIG5Qb2ludCA9IDE7XG4gICAgICAgICAgICAgICAgICAgIHhpID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICB5aSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRzWzBdWzBdID0geGk7XG4gICAgICAgICAgICAgICAgICAgIHBvaW50c1swXVsxXSA9IHlpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIEw6XG4gICAgICAgICAgICAgICAgICAgIGNtZFN0ciA9ICcgbCAnO1xuICAgICAgICAgICAgICAgICAgICBuUG9pbnQgPSAxO1xuICAgICAgICAgICAgICAgICAgICB4aSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgeWkgPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgIHBvaW50c1swXVswXSA9IHhpO1xuICAgICAgICAgICAgICAgICAgICBwb2ludHNbMF1bMV0gPSB5aTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBROlxuICAgICAgICAgICAgICAgIGNhc2UgQzpcbiAgICAgICAgICAgICAgICAgICAgY21kU3RyID0gJyBjICc7XG4gICAgICAgICAgICAgICAgICAgIG5Qb2ludCA9IDM7XG4gICAgICAgICAgICAgICAgICAgIHZhciB4MSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHkxID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgeDIgPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgIHZhciB5MiA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHgzO1xuICAgICAgICAgICAgICAgICAgICB2YXIgeTM7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjbWQgPT09IFEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvbnZlcnQgcXVhZHJhdGljIHRvIGN1YmljIHVzaW5nIGRlZ3JlZSBlbGV2YXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIHgzID0geDI7XG4gICAgICAgICAgICAgICAgICAgICAgICB5MyA9IHkyO1xuICAgICAgICAgICAgICAgICAgICAgICAgeDIgPSAoeDIgKyAyICogeDEpIC8gMztcbiAgICAgICAgICAgICAgICAgICAgICAgIHkyID0gKHkyICsgMiAqIHkxKSAvIDM7XG4gICAgICAgICAgICAgICAgICAgICAgICB4MSA9ICh4aSArIDIgKiB4MSkgLyAzO1xuICAgICAgICAgICAgICAgICAgICAgICAgeTEgPSAoeWkgKyAyICogeTEpIC8gMztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHgzID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgeTMgPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcG9pbnRzWzBdWzBdID0geDE7XG4gICAgICAgICAgICAgICAgICAgIHBvaW50c1swXVsxXSA9IHkxO1xuICAgICAgICAgICAgICAgICAgICBwb2ludHNbMV1bMF0gPSB4MjtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRzWzFdWzFdID0geTI7XG4gICAgICAgICAgICAgICAgICAgIHBvaW50c1syXVswXSA9IHgzO1xuICAgICAgICAgICAgICAgICAgICBwb2ludHNbMl1bMV0gPSB5MztcblxuICAgICAgICAgICAgICAgICAgICB4aSA9IHgzO1xuICAgICAgICAgICAgICAgICAgICB5aSA9IHkzO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIEE6XG4gICAgICAgICAgICAgICAgICAgIHZhciB4ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHkgPSAwO1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3ggPSAxO1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3kgPSAxO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYW5nbGUgPSAwO1xuICAgICAgICAgICAgICAgICAgICBpZiAobSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRXh0cmFjdCBTUlQgZnJvbSBtYXRyaXhcbiAgICAgICAgICAgICAgICAgICAgICAgIHggPSBtWzRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgeSA9IG1bNV07XG4gICAgICAgICAgICAgICAgICAgICAgICBzeCA9IHNxcnQobVswXSAqIG1bMF0gKyBtWzFdICogbVsxXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzeSA9IHNxcnQobVsyXSAqIG1bMl0gKyBtWzNdICogbVszXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbmdsZSA9IE1hdGguYXRhbjIoLW1bMV0gLyBzeSwgbVswXSAvIHN4KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHZhciBjeCA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGN5ID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcnggPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgIHZhciByeSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXJ0QW5nbGUgPSBkYXRhW2krK10gKyBhbmdsZTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVuZEFuZ2xlID0gZGF0YVtpKytdICsgc3RhcnRBbmdsZSArIGFuZ2xlO1xuICAgICAgICAgICAgICAgICAgICAvLyBGSVhNRVxuICAgICAgICAgICAgICAgICAgICAvLyB2YXIgcHNpID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjbG9ja3dpc2UgPSBkYXRhW2krK107XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHgwID0gY3ggKyBjb3Moc3RhcnRBbmdsZSkgKiByeDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHkwID0gY3kgKyBzaW4oc3RhcnRBbmdsZSkgKiByeTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgeDEgPSBjeCArIGNvcyhlbmRBbmdsZSkgKiByeDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHkxID0gY3kgKyBzaW4oZW5kQW5nbGUpICogcnk7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHR5cGUgPSBjbG9ja3dpc2UgPyAnIHdhICcgOiAnIGF0ICc7XG4gICAgICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyh4MCAtIHgxKSA8IDFlLTEwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJRSB3b24ndCByZW5kZXIgYXJjaGVzIGRyYXduIGNvdW50ZXIgY2xvY2t3aXNlIGlmIHgwID09IHgxLlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKE1hdGguYWJzKGVuZEFuZ2xlIC0gc3RhcnRBbmdsZSkgPiAxZS0yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gT2Zmc2V0IHgwIGJ5IDEvODAgb2YgYSBwaXhlbC4gVXNlIHNvbWV0aGluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoYXQgY2FuIGJlIHJlcHJlc2VudGVkIGluIGJpbmFyeVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjbG9ja3dpc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeDAgKz0gMjcwIC8gWjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBdm9pZCBjYXNlIGRyYXcgZnVsbCBjaXJjbGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoTWF0aC5hYnMoeTAgLSBjeSkgPCAxZS0xMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGNsb2Nrd2lzZSAmJiB4MCA8IGN4KSB8fCAoIWNsb2Nrd2lzZSAmJiB4MCA+IGN4KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeTEgLT0gMjcwIC8gWjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkxICs9IDI3MCAvIFo7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoKGNsb2Nrd2lzZSAmJiB5MCA8IGN5KSB8fCAoIWNsb2Nrd2lzZSAmJiB5MCA+IGN5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4MSArPSAyNzAgLyBaO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeDEgLT0gMjcwIC8gWjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc3RyLnB1c2goXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgcm91bmQoKChjeCAtIHJ4KSAqIHN4ICsgeCkgKiBaIC0gWjIpLCBjb21tYSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdW5kKCgoY3kgLSByeSkgKiBzeSArIHkpICogWiAtIFoyKSwgY29tbWEsXG4gICAgICAgICAgICAgICAgICAgICAgICByb3VuZCgoKGN4ICsgcngpICogc3ggKyB4KSAqIFogLSBaMiksIGNvbW1hLFxuICAgICAgICAgICAgICAgICAgICAgICAgcm91bmQoKChjeSArIHJ5KSAqIHN5ICsgeSkgKiBaIC0gWjIpLCBjb21tYSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdW5kKCh4MCAqIHN4ICsgeCkgKiBaIC0gWjIpLCBjb21tYSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdW5kKCh5MCAqIHN5ICsgeSkgKiBaIC0gWjIpLCBjb21tYSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdW5kKCh4MSAqIHN4ICsgeCkgKiBaIC0gWjIpLCBjb21tYSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdW5kKCh5MSAqIHN5ICsgeSkgKiBaIC0gWjIpXG4gICAgICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAgICAgeGkgPSB4MTtcbiAgICAgICAgICAgICAgICAgICAgeWkgPSB5MTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBDTUQuUjpcbiAgICAgICAgICAgICAgICAgICAgdmFyIHAwID0gcG9pbnRzWzBdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcDEgPSBwb2ludHNbMV07XG4gICAgICAgICAgICAgICAgICAgIC8vIHgwLCB5MFxuICAgICAgICAgICAgICAgICAgICBwMFswXSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgcDBbMV0gPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgIC8vIHgxLCB5MVxuICAgICAgICAgICAgICAgICAgICBwMVswXSA9IHAwWzBdICsgZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICBwMVsxXSA9IHAwWzFdICsgZGF0YVtpKytdO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcHBseVRyYW5zZm9ybShwMCwgcDAsIG0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXBwbHlUcmFuc2Zvcm0ocDEsIHAxLCBtKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHAwWzBdID0gcm91bmQocDBbMF0gKiBaIC0gWjIpO1xuICAgICAgICAgICAgICAgICAgICBwMVswXSA9IHJvdW5kKHAxWzBdICogWiAtIFoyKTtcbiAgICAgICAgICAgICAgICAgICAgcDBbMV0gPSByb3VuZChwMFsxXSAqIFogLSBaMik7XG4gICAgICAgICAgICAgICAgICAgIHAxWzFdID0gcm91bmQocDFbMV0gKiBaIC0gWjIpO1xuICAgICAgICAgICAgICAgICAgICBzdHIucHVzaChcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHgwLCB5MFxuICAgICAgICAgICAgICAgICAgICAgICAgJyBtICcsIHAwWzBdLCBjb21tYSwgcDBbMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB4MSwgeTBcbiAgICAgICAgICAgICAgICAgICAgICAgICcgbCAnLCBwMVswXSwgY29tbWEsIHAwWzFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8geDEsIHkxXG4gICAgICAgICAgICAgICAgICAgICAgICAnIGwgJywgcDFbMF0sIGNvbW1hLCBwMVsxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHgwLCB5MVxuICAgICAgICAgICAgICAgICAgICAgICAgJyBsICcsIHAwWzBdLCBjb21tYSwgcDFbMV1cbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBDTUQuWjpcbiAgICAgICAgICAgICAgICAgICAgLy8gRklYTUUgVXBkYXRlIHhpLCB5aVxuICAgICAgICAgICAgICAgICAgICBzdHIucHVzaCgnIHggJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChuUG9pbnQgPiAwKSB7XG4gICAgICAgICAgICAgICAgc3RyLnB1c2goY21kU3RyKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IG5Qb2ludDsgaysrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwID0gcG9pbnRzW2tdO1xuXG4gICAgICAgICAgICAgICAgICAgIG0gJiYgYXBwbHlUcmFuc2Zvcm0ocCwgcCwgbSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIOS4jSByb3VuZCDkvJrpnZ7luLjmhaJcbiAgICAgICAgICAgICAgICAgICAgc3RyLnB1c2goXG4gICAgICAgICAgICAgICAgICAgICAgICByb3VuZChwWzBdICogWiAtIFoyKSwgY29tbWEsIHJvdW5kKHBbMV0gKiBaIC0gWjIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgayA8IG5Qb2ludCAtIDEgPyBjb21tYSA6ICcnXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHN0ci5qb2luKCcnKTtcbiAgICB9O1xuXG4gICAgLy8gUmV3cml0ZSB0aGUgb3JpZ2luYWwgcGF0aCBtZXRob2RcbiAgICBQYXRoLnByb3RvdHlwZS5icnVzaFZNTCA9IGZ1bmN0aW9uICh2bWxSb290KSB7XG4gICAgICAgIHZhciBzdHlsZSA9IHRoaXMuc3R5bGU7XG5cbiAgICAgICAgdmFyIHZtbEVsID0gdGhpcy5fdm1sRWw7XG4gICAgICAgIGlmICghdm1sRWwpIHtcbiAgICAgICAgICAgIHZtbEVsID0gdm1sQ29yZS5jcmVhdGVOb2RlKCdzaGFwZScpO1xuICAgICAgICAgICAgaW5pdFJvb3RFbFN0eWxlKHZtbEVsKTtcblxuICAgICAgICAgICAgdGhpcy5fdm1sRWwgPSB2bWxFbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHVwZGF0ZUZpbGxBbmRTdHJva2Uodm1sRWwsICdmaWxsJywgc3R5bGUsIHRoaXMpO1xuICAgICAgICB1cGRhdGVGaWxsQW5kU3Ryb2tlKHZtbEVsLCAnc3Ryb2tlJywgc3R5bGUsIHRoaXMpO1xuXG4gICAgICAgIHZhciBtID0gdGhpcy50cmFuc2Zvcm07XG4gICAgICAgIHZhciBuZWVkVHJhbnNmb3JtID0gbSAhPSBudWxsO1xuICAgICAgICB2YXIgc3Ryb2tlRWwgPSB2bWxFbC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnc3Ryb2tlJylbMF07XG4gICAgICAgIGlmIChzdHJva2VFbCkge1xuICAgICAgICAgICAgdmFyIGxpbmVXaWR0aCA9IHN0eWxlLmxpbmVXaWR0aDtcbiAgICAgICAgICAgIC8vIEdldCB0aGUgbGluZSBzY2FsZS5cbiAgICAgICAgICAgIC8vIERldGVybWluYW50IG9mIHRoaXMubV8gbWVhbnMgaG93IG11Y2ggdGhlIGFyZWEgaXMgZW5sYXJnZWQgYnkgdGhlXG4gICAgICAgICAgICAvLyB0cmFuc2Zvcm1hdGlvbi4gU28gaXRzIHNxdWFyZSByb290IGNhbiBiZSB1c2VkIGFzIGEgc2NhbGUgZmFjdG9yXG4gICAgICAgICAgICAvLyBmb3Igd2lkdGguXG4gICAgICAgICAgICBpZiAobmVlZFRyYW5zZm9ybSAmJiAhc3R5bGUuc3Ryb2tlTm9TY2FsZSkge1xuICAgICAgICAgICAgICAgIHZhciBkZXQgPSBtWzBdICogbVszXSAtIG1bMV0gKiBtWzJdO1xuICAgICAgICAgICAgICAgIGxpbmVXaWR0aCAqPSBzcXJ0KGFicyhkZXQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0cm9rZUVsLndlaWdodCA9IGxpbmVXaWR0aCArICdweCc7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcGF0aCA9IHRoaXMucGF0aDtcbiAgICAgICAgaWYgKHRoaXMuX19kaXJ0eVBhdGgpIHtcbiAgICAgICAgICAgIHBhdGguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICB0aGlzLmJ1aWxkUGF0aChwYXRoLCB0aGlzLnNoYXBlKTtcbiAgICAgICAgICAgIHBhdGgudG9TdGF0aWMoKTtcbiAgICAgICAgICAgIHRoaXMuX19kaXJ0eVBhdGggPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZtbEVsLnBhdGggPSBwYXRoRGF0YVRvU3RyaW5nKHBhdGguZGF0YSwgdGhpcy50cmFuc2Zvcm0pO1xuXG4gICAgICAgIHZtbEVsLnN0eWxlLnpJbmRleCA9IGdldFpJbmRleCh0aGlzLnpsZXZlbCwgdGhpcy56LCB0aGlzLnoyKTtcblxuICAgICAgICAvLyBBcHBlbmQgdG8gcm9vdFxuICAgICAgICBhcHBlbmQodm1sUm9vdCwgdm1sRWwpO1xuXG4gICAgICAgIC8vIFRleHRcbiAgICAgICAgaWYgKHN0eWxlLnRleHQpIHtcbiAgICAgICAgICAgIHRoaXMuZHJhd1JlY3RUZXh0KHZtbFJvb3QsIHRoaXMuZ2V0Qm91bmRpbmdSZWN0KCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVSZWN0VGV4dCh2bWxSb290KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBQYXRoLnByb3RvdHlwZS5vblJlbW92ZSA9IGZ1bmN0aW9uICh2bWxSb290KSB7XG4gICAgICAgIHJlbW92ZSh2bWxSb290LCB0aGlzLl92bWxFbCk7XG4gICAgICAgIHRoaXMucmVtb3ZlUmVjdFRleHQodm1sUm9vdCk7XG4gICAgfTtcblxuICAgIFBhdGgucHJvdG90eXBlLm9uQWRkID0gZnVuY3Rpb24gKHZtbFJvb3QpIHtcbiAgICAgICAgYXBwZW5kKHZtbFJvb3QsIHRoaXMuX3ZtbEVsKTtcbiAgICAgICAgdGhpcy5hcHBlbmRSZWN0VGV4dCh2bWxSb290KTtcbiAgICB9O1xuXG4gICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICAqIElNQUdFXG4gICAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAgIHZhciBpc0ltYWdlID0gZnVuY3Rpb24gKGltZykge1xuICAgICAgICAvLyBGSVhNRSBpbWcgaW5zdGFuY2VvZiBJbWFnZSDlpoLmnpwgaW1nIOaYr+S4gOS4quWtl+espuS4sueahOaXtuWAme+8jElFOCDkuIvkvJrmiqXplJlcbiAgICAgICAgcmV0dXJuICh0eXBlb2YgaW1nID09PSAnb2JqZWN0JykgJiYgaW1nLnRhZ05hbWUgJiYgaW1nLnRhZ05hbWUudG9VcHBlckNhc2UoKSA9PT0gJ0lNRyc7XG4gICAgICAgIC8vIHJldHVybiBpbWcgaW5zdGFuY2VvZiBJbWFnZTtcbiAgICB9O1xuXG4gICAgLy8gUmV3cml0ZSB0aGUgb3JpZ2luYWwgcGF0aCBtZXRob2RcbiAgICBaSW1hZ2UucHJvdG90eXBlLmJydXNoVk1MID0gZnVuY3Rpb24gKHZtbFJvb3QpIHtcbiAgICAgICAgdmFyIHN0eWxlID0gdGhpcy5zdHlsZTtcbiAgICAgICAgdmFyIGltYWdlID0gc3R5bGUuaW1hZ2U7XG5cbiAgICAgICAgLy8gSW1hZ2Ugb3JpZ2luYWwgd2lkdGgsIGhlaWdodFxuICAgICAgICB2YXIgb3c7XG4gICAgICAgIHZhciBvaDtcblxuICAgICAgICBpZiAoaXNJbWFnZShpbWFnZSkpIHtcbiAgICAgICAgICAgIHZhciBzcmMgPSBpbWFnZS5zcmM7XG4gICAgICAgICAgICBpZiAoc3JjID09PSB0aGlzLl9pbWFnZVNyYykge1xuICAgICAgICAgICAgICAgIG93ID0gdGhpcy5faW1hZ2VXaWR0aDtcbiAgICAgICAgICAgICAgICBvaCA9IHRoaXMuX2ltYWdlSGVpZ2h0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGltYWdlUnVudGltZVN0eWxlID0gaW1hZ2UucnVudGltZVN0eWxlO1xuICAgICAgICAgICAgICAgIHZhciBvbGRSdW50aW1lV2lkdGggPSBpbWFnZVJ1bnRpbWVTdHlsZS53aWR0aDtcbiAgICAgICAgICAgICAgICB2YXIgb2xkUnVudGltZUhlaWdodCA9IGltYWdlUnVudGltZVN0eWxlLmhlaWdodDtcbiAgICAgICAgICAgICAgICBpbWFnZVJ1bnRpbWVTdHlsZS53aWR0aCA9ICdhdXRvJztcbiAgICAgICAgICAgICAgICBpbWFnZVJ1bnRpbWVTdHlsZS5oZWlnaHQgPSAnYXV0byc7XG5cbiAgICAgICAgICAgICAgICAvLyBnZXQgdGhlIG9yaWdpbmFsIHNpemVcbiAgICAgICAgICAgICAgICBvdyA9IGltYWdlLndpZHRoO1xuICAgICAgICAgICAgICAgIG9oID0gaW1hZ2UuaGVpZ2h0O1xuXG4gICAgICAgICAgICAgICAgLy8gYW5kIHJlbW92ZSBvdmVyaWRlc1xuICAgICAgICAgICAgICAgIGltYWdlUnVudGltZVN0eWxlLndpZHRoID0gb2xkUnVudGltZVdpZHRoO1xuICAgICAgICAgICAgICAgIGltYWdlUnVudGltZVN0eWxlLmhlaWdodCA9IG9sZFJ1bnRpbWVIZWlnaHQ7XG5cbiAgICAgICAgICAgICAgICAvLyBDYWNoaW5nIGltYWdlIG9yaWdpbmFsIHdpZHRoLCBoZWlnaHQgYW5kIHNyY1xuICAgICAgICAgICAgICAgIHRoaXMuX2ltYWdlU3JjID0gc3JjO1xuICAgICAgICAgICAgICAgIHRoaXMuX2ltYWdlV2lkdGggPSBvdztcbiAgICAgICAgICAgICAgICB0aGlzLl9pbWFnZUhlaWdodCA9IG9oO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW1hZ2UgPSBzcmM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoaW1hZ2UgPT09IHRoaXMuX2ltYWdlU3JjKSB7XG4gICAgICAgICAgICAgICAgb3cgPSB0aGlzLl9pbWFnZVdpZHRoO1xuICAgICAgICAgICAgICAgIG9oID0gdGhpcy5faW1hZ2VIZWlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpbWFnZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHggPSBzdHlsZS54IHx8IDA7XG4gICAgICAgIHZhciB5ID0gc3R5bGUueSB8fCAwO1xuXG4gICAgICAgIHZhciBkdyA9IHN0eWxlLndpZHRoO1xuICAgICAgICB2YXIgZGggPSBzdHlsZS5oZWlnaHQ7XG5cbiAgICAgICAgdmFyIHN3ID0gc3R5bGUuc1dpZHRoO1xuICAgICAgICB2YXIgc2ggPSBzdHlsZS5zSGVpZ2h0O1xuICAgICAgICB2YXIgc3ggPSBzdHlsZS5zeCB8fCAwO1xuICAgICAgICB2YXIgc3kgPSBzdHlsZS5zeSB8fCAwO1xuXG4gICAgICAgIHZhciBoYXNDcm9wID0gc3cgJiYgc2g7XG5cbiAgICAgICAgdmFyIHZtbEVsID0gdGhpcy5fdm1sRWw7XG4gICAgICAgIGlmICghdm1sRWwpIHtcbiAgICAgICAgICAgIC8vIEZJWE1FIOS9v+eUqCBncm91cCDlnKggbGVmdCwgdG9wIOmDveS4jeaYryAwIOeahOaXtuWAmeWwseaXoOazleaYvuekuuS6huOAglxuICAgICAgICAgICAgLy8gdm1sRWwgPSB2bWxDb3JlLmNyZWF0ZU5vZGUoJ2dyb3VwJyk7XG4gICAgICAgICAgICB2bWxFbCA9IHZtbENvcmUuZG9jLmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgaW5pdFJvb3RFbFN0eWxlKHZtbEVsKTtcblxuICAgICAgICAgICAgdGhpcy5fdm1sRWwgPSB2bWxFbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB2bWxFbFN0eWxlID0gdm1sRWwuc3R5bGU7XG4gICAgICAgIHZhciBoYXNSb3RhdGlvbiA9IGZhbHNlO1xuICAgICAgICB2YXIgbTtcbiAgICAgICAgdmFyIHNjYWxlWCA9IDE7XG4gICAgICAgIHZhciBzY2FsZVkgPSAxO1xuICAgICAgICBpZiAodGhpcy50cmFuc2Zvcm0pIHtcbiAgICAgICAgICAgIG0gPSB0aGlzLnRyYW5zZm9ybTtcbiAgICAgICAgICAgIHNjYWxlWCA9IHNxcnQobVswXSAqIG1bMF0gKyBtWzFdICogbVsxXSk7XG4gICAgICAgICAgICBzY2FsZVkgPSBzcXJ0KG1bMl0gKiBtWzJdICsgbVszXSAqIG1bM10pO1xuXG4gICAgICAgICAgICBoYXNSb3RhdGlvbiA9IG1bMV0gfHwgbVsyXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGFzUm90YXRpb24pIHtcbiAgICAgICAgICAgIC8vIElmIGZpbHRlcnMgYXJlIG5lY2Vzc2FyeSAocm90YXRpb24gZXhpc3RzKSwgY3JlYXRlIHRoZW1cbiAgICAgICAgICAgIC8vIGZpbHRlcnMgYXJlIGJvZy1zbG93LCBzbyBvbmx5IGNyZWF0ZSB0aGVtIGlmIGFiYnNvbHV0ZWx5IG5lY2Vzc2FyeVxuICAgICAgICAgICAgLy8gVGhlIGZvbGxvd2luZyBjaGVjayBkb2Vzbid0IGFjY291bnQgZm9yIHNrZXdzICh3aGljaCBkb24ndCBleGlzdFxuICAgICAgICAgICAgLy8gaW4gdGhlIGNhbnZhcyBzcGVjICh5ZXQpIGFueXdheS5cbiAgICAgICAgICAgIC8vIEZyb20gZXhjYW52YXNcbiAgICAgICAgICAgIHZhciBwMCA9IFt4LCB5XTtcbiAgICAgICAgICAgIHZhciBwMSA9IFt4ICsgZHcsIHldO1xuICAgICAgICAgICAgdmFyIHAyID0gW3gsIHkgKyBkaF07XG4gICAgICAgICAgICB2YXIgcDMgPSBbeCArIGR3LCB5ICsgZGhdO1xuICAgICAgICAgICAgYXBwbHlUcmFuc2Zvcm0ocDAsIHAwLCBtKTtcbiAgICAgICAgICAgIGFwcGx5VHJhbnNmb3JtKHAxLCBwMSwgbSk7XG4gICAgICAgICAgICBhcHBseVRyYW5zZm9ybShwMiwgcDIsIG0pO1xuICAgICAgICAgICAgYXBwbHlUcmFuc2Zvcm0ocDMsIHAzLCBtKTtcblxuICAgICAgICAgICAgdmFyIG1heFggPSBtYXRoTWF4KHAwWzBdLCBwMVswXSwgcDJbMF0sIHAzWzBdKTtcbiAgICAgICAgICAgIHZhciBtYXhZID0gbWF0aE1heChwMFsxXSwgcDFbMV0sIHAyWzFdLCBwM1sxXSk7XG5cbiAgICAgICAgICAgIHZhciB0cmFuc2Zvcm1GaWx0ZXIgPSBbXTtcbiAgICAgICAgICAgIHRyYW5zZm9ybUZpbHRlci5wdXNoKCdNMTE9JywgbVswXSAvIHNjYWxlWCwgY29tbWEsXG4gICAgICAgICAgICAgICAgICAgICAgICAnTTEyPScsIG1bMl0gLyBzY2FsZVksIGNvbW1hLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ00yMT0nLCBtWzFdIC8gc2NhbGVYLCBjb21tYSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdNMjI9JywgbVszXSAvIHNjYWxlWSwgY29tbWEsXG4gICAgICAgICAgICAgICAgICAgICAgICAnRHg9Jywgcm91bmQoeCAqIHNjYWxlWCArIG1bNF0pLCBjb21tYSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdEeT0nLCByb3VuZCh5ICogc2NhbGVZICsgbVs1XSkpO1xuXG4gICAgICAgICAgICB2bWxFbFN0eWxlLnBhZGRpbmcgPSAnMCAnICsgcm91bmQobWF4WCkgKyAncHggJyArIHJvdW5kKG1heFkpICsgJ3B4IDAnO1xuICAgICAgICAgICAgLy8gRklYTUUgRFhJbWFnZVRyYW5zZm9ybSDlnKggSUUxMSDnmoTlhbzlrrnmqKHlvI/kuIvkuI3otbfkvZznlKhcbiAgICAgICAgICAgIHZtbEVsU3R5bGUuZmlsdGVyID0gaW1hZ2VUcmFuc2Zvcm1QcmVmaXggKyAnLk1hdHJpeCgnXG4gICAgICAgICAgICAgICAgKyB0cmFuc2Zvcm1GaWx0ZXIuam9pbignJykgKyAnLCBTaXppbmdNZXRob2Q9Y2xpcCknO1xuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAobSkge1xuICAgICAgICAgICAgICAgIHggPSB4ICogc2NhbGVYICsgbVs0XTtcbiAgICAgICAgICAgICAgICB5ID0geSAqIHNjYWxlWSArIG1bNV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2bWxFbFN0eWxlLmZpbHRlciA9ICcnO1xuICAgICAgICAgICAgdm1sRWxTdHlsZS5sZWZ0ID0gcm91bmQoeCkgKyAncHgnO1xuICAgICAgICAgICAgdm1sRWxTdHlsZS50b3AgPSByb3VuZCh5KSArICdweCc7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaW1hZ2VFbCA9IHRoaXMuX2ltYWdlRWw7XG4gICAgICAgIHZhciBjcm9wRWwgPSB0aGlzLl9jcm9wRWw7XG5cbiAgICAgICAgaWYgKCFpbWFnZUVsKSB7XG4gICAgICAgICAgICBpbWFnZUVsID0gdm1sQ29yZS5kb2MuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICB0aGlzLl9pbWFnZUVsID0gaW1hZ2VFbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaW1hZ2VFTFN0eWxlID0gaW1hZ2VFbC5zdHlsZTtcbiAgICAgICAgaWYgKGhhc0Nyb3ApIHtcbiAgICAgICAgICAgIC8vIE5lZWRzIGtub3cgaW1hZ2Ugb3JpZ2luYWwgd2lkdGggYW5kIGhlaWdodFxuICAgICAgICAgICAgaWYgKCEgKG93ICYmIG9oKSkge1xuICAgICAgICAgICAgICAgIHZhciB0bXBJbWFnZSA9IG5ldyBJbWFnZSgpO1xuICAgICAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgICAgICB0bXBJbWFnZS5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRtcEltYWdlLm9ubG9hZCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIG93ID0gdG1wSW1hZ2Uud2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIG9oID0gdG1wSW1hZ2UuaGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAvLyBBZGp1c3QgaW1hZ2Ugd2lkdGggYW5kIGhlaWdodCB0byBmaXQgdGhlIHJhdGlvIGRlc3RpbmF0aW9uU2l6ZSAvIHNvdXJjZVNpemVcbiAgICAgICAgICAgICAgICAgICAgaW1hZ2VFTFN0eWxlLndpZHRoID0gcm91bmQoc2NhbGVYICogb3cgKiBkdyAvIHN3KSArICdweCc7XG4gICAgICAgICAgICAgICAgICAgIGltYWdlRUxTdHlsZS5oZWlnaHQgPSByb3VuZChzY2FsZVkgKiBvaCAqIGRoIC8gc2gpICsgJ3B4JztcblxuICAgICAgICAgICAgICAgICAgICAvLyBDYWNoaW5nIGltYWdlIG9yaWdpbmFsIHdpZHRoLCBoZWlnaHQgYW5kIHNyY1xuICAgICAgICAgICAgICAgICAgICBzZWxmLl9pbWFnZVdpZHRoID0gb3c7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuX2ltYWdlSGVpZ2h0ID0gb2g7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuX2ltYWdlU3JjID0gaW1hZ2U7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB0bXBJbWFnZS5zcmMgPSBpbWFnZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGltYWdlRUxTdHlsZS53aWR0aCA9IHJvdW5kKHNjYWxlWCAqIG93ICogZHcgLyBzdykgKyAncHgnO1xuICAgICAgICAgICAgICAgIGltYWdlRUxTdHlsZS5oZWlnaHQgPSByb3VuZChzY2FsZVkgKiBvaCAqIGRoIC8gc2gpICsgJ3B4JztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCEgY3JvcEVsKSB7XG4gICAgICAgICAgICAgICAgY3JvcEVsID0gdm1sQ29yZS5kb2MuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICAgICAgY3JvcEVsLnN0eWxlLm92ZXJmbG93ID0gJ2hpZGRlbic7XG4gICAgICAgICAgICAgICAgdGhpcy5fY3JvcEVsID0gY3JvcEVsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGNyb3BFbFN0eWxlID0gY3JvcEVsLnN0eWxlO1xuICAgICAgICAgICAgY3JvcEVsU3R5bGUud2lkdGggPSByb3VuZCgoZHcgKyBzeCAqIGR3IC8gc3cpICogc2NhbGVYKTtcbiAgICAgICAgICAgIGNyb3BFbFN0eWxlLmhlaWdodCA9IHJvdW5kKChkaCArIHN5ICogZGggLyBzaCkgKiBzY2FsZVkpO1xuICAgICAgICAgICAgY3JvcEVsU3R5bGUuZmlsdGVyID0gaW1hZ2VUcmFuc2Zvcm1QcmVmaXggKyAnLk1hdHJpeChEeD0nXG4gICAgICAgICAgICAgICAgICAgICsgKC1zeCAqIGR3IC8gc3cgKiBzY2FsZVgpICsgJyxEeT0nICsgKC1zeSAqIGRoIC8gc2ggKiBzY2FsZVkpICsgJyknO1xuXG4gICAgICAgICAgICBpZiAoISBjcm9wRWwucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgIHZtbEVsLmFwcGVuZENoaWxkKGNyb3BFbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaW1hZ2VFbC5wYXJlbnROb2RlICE9IGNyb3BFbCkge1xuICAgICAgICAgICAgICAgIGNyb3BFbC5hcHBlbmRDaGlsZChpbWFnZUVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGltYWdlRUxTdHlsZS53aWR0aCA9IHJvdW5kKHNjYWxlWCAqIGR3KSArICdweCc7XG4gICAgICAgICAgICBpbWFnZUVMU3R5bGUuaGVpZ2h0ID0gcm91bmQoc2NhbGVZICogZGgpICsgJ3B4JztcblxuICAgICAgICAgICAgdm1sRWwuYXBwZW5kQ2hpbGQoaW1hZ2VFbCk7XG5cbiAgICAgICAgICAgIGlmIChjcm9wRWwgJiYgY3JvcEVsLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICB2bWxFbC5yZW1vdmVDaGlsZChjcm9wRWwpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2Nyb3BFbCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZmlsdGVyU3RyID0gJyc7XG4gICAgICAgIHZhciBhbHBoYSA9IHN0eWxlLm9wYWNpdHk7XG4gICAgICAgIGlmIChhbHBoYSA8IDEpIHtcbiAgICAgICAgICAgIGZpbHRlclN0ciArPSAnLkFscGhhKG9wYWNpdHk9JyArIHJvdW5kKGFscGhhICogMTAwKSArICcpICc7XG4gICAgICAgIH1cbiAgICAgICAgZmlsdGVyU3RyICs9IGltYWdlVHJhbnNmb3JtUHJlZml4ICsgJy5BbHBoYUltYWdlTG9hZGVyKHNyYz0nICsgaW1hZ2UgKyAnLCBTaXppbmdNZXRob2Q9c2NhbGUpJztcblxuICAgICAgICBpbWFnZUVMU3R5bGUuZmlsdGVyID0gZmlsdGVyU3RyO1xuXG4gICAgICAgIHZtbEVsLnN0eWxlLnpJbmRleCA9IGdldFpJbmRleCh0aGlzLnpsZXZlbCwgdGhpcy56LCB0aGlzLnoyKTtcblxuICAgICAgICAvLyBBcHBlbmQgdG8gcm9vdFxuICAgICAgICBhcHBlbmQodm1sUm9vdCwgdm1sRWwpO1xuXG4gICAgICAgIC8vIFRleHRcbiAgICAgICAgaWYgKHN0eWxlLnRleHQpIHtcbiAgICAgICAgICAgIHRoaXMuZHJhd1JlY3RUZXh0KHZtbFJvb3QsIHRoaXMuZ2V0Qm91bmRpbmdSZWN0KCkpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIFpJbWFnZS5wcm90b3R5cGUub25SZW1vdmUgPSBmdW5jdGlvbiAodm1sUm9vdCkge1xuICAgICAgICByZW1vdmUodm1sUm9vdCwgdGhpcy5fdm1sRWwpO1xuXG4gICAgICAgIHRoaXMuX3ZtbEVsID0gbnVsbDtcbiAgICAgICAgdGhpcy5fY3JvcEVsID0gbnVsbDtcbiAgICAgICAgdGhpcy5faW1hZ2VFbCA9IG51bGw7XG5cbiAgICAgICAgdGhpcy5yZW1vdmVSZWN0VGV4dCh2bWxSb290KTtcbiAgICB9O1xuXG4gICAgWkltYWdlLnByb3RvdHlwZS5vbkFkZCA9IGZ1bmN0aW9uICh2bWxSb290KSB7XG4gICAgICAgIGFwcGVuZCh2bWxSb290LCB0aGlzLl92bWxFbCk7XG4gICAgICAgIHRoaXMuYXBwZW5kUmVjdFRleHQodm1sUm9vdCk7XG4gICAgfTtcblxuXG4gICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICAqIFRFWFRcbiAgICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICB2YXIgREVGQVVMVF9TVFlMRV9OT1JNQUwgPSAnbm9ybWFsJztcblxuICAgIHZhciBmb250U3R5bGVDYWNoZSA9IHt9O1xuICAgIHZhciBmb250U3R5bGVDYWNoZUNvdW50ID0gMDtcbiAgICB2YXIgTUFYX0ZPTlRfQ0FDSEVfU0laRSA9IDEwMDtcbiAgICB2YXIgZm9udEVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cbiAgICB2YXIgZ2V0Rm9udFN0eWxlID0gZnVuY3Rpb24gKGZvbnRTdHJpbmcpIHtcbiAgICAgICAgdmFyIGZvbnRTdHlsZSA9IGZvbnRTdHlsZUNhY2hlW2ZvbnRTdHJpbmddO1xuICAgICAgICBpZiAoIWZvbnRTdHlsZSkge1xuICAgICAgICAgICAgLy8gQ2xlYXIgY2FjaGVcbiAgICAgICAgICAgIGlmIChmb250U3R5bGVDYWNoZUNvdW50ID4gTUFYX0ZPTlRfQ0FDSEVfU0laRSkge1xuICAgICAgICAgICAgICAgIGZvbnRTdHlsZUNhY2hlQ291bnQgPSAwO1xuICAgICAgICAgICAgICAgIGZvbnRTdHlsZUNhY2hlID0ge307XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBzdHlsZSA9IGZvbnRFbC5zdHlsZTtcbiAgICAgICAgICAgIHZhciBmb250RmFtaWx5O1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBzdHlsZS5mb250ID0gZm9udFN0cmluZztcbiAgICAgICAgICAgICAgICBmb250RmFtaWx5ID0gc3R5bGUuZm9udEZhbWlseS5zcGxpdCgnLCcpWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9udFN0eWxlID0ge1xuICAgICAgICAgICAgICAgIHN0eWxlOiBzdHlsZS5mb250U3R5bGUgfHwgREVGQVVMVF9TVFlMRV9OT1JNQUwsXG4gICAgICAgICAgICAgICAgdmFyaWFudDogc3R5bGUuZm9udFZhcmlhbnQgfHwgREVGQVVMVF9TVFlMRV9OT1JNQUwsXG4gICAgICAgICAgICAgICAgd2VpZ2h0OiBzdHlsZS5mb250V2VpZ2h0IHx8IERFRkFVTFRfU1RZTEVfTk9STUFMLFxuICAgICAgICAgICAgICAgIHNpemU6IHBhcnNlRmxvYXQoc3R5bGUuZm9udFNpemUgfHwgMTIpIHwgMCxcbiAgICAgICAgICAgICAgICBmYW1pbHk6IGZvbnRGYW1pbHkgfHwgJ01pY3Jvc29mdCBZYUhlaSdcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGZvbnRTdHlsZUNhY2hlW2ZvbnRTdHJpbmddID0gZm9udFN0eWxlO1xuICAgICAgICAgICAgZm9udFN0eWxlQ2FjaGVDb3VudCsrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmb250U3R5bGU7XG4gICAgfTtcblxuICAgIHZhciB0ZXh0TWVhc3VyZUVsO1xuICAgIC8vIE92ZXJ3cml0ZSBtZWFzdXJlIHRleHQgbWV0aG9kXG4gICAgdGV4dENvbnRhaW4ubWVhc3VyZVRleHQgPSBmdW5jdGlvbiAodGV4dCwgdGV4dEZvbnQpIHtcbiAgICAgICAgdmFyIGRvYyA9IHZtbENvcmUuZG9jO1xuICAgICAgICBpZiAoIXRleHRNZWFzdXJlRWwpIHtcbiAgICAgICAgICAgIHRleHRNZWFzdXJlRWwgPSBkb2MuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICB0ZXh0TWVhc3VyZUVsLnN0eWxlLmNzc1RleHQgPSAncG9zaXRpb246YWJzb2x1dGU7dG9wOi0yMDAwMHB4O2xlZnQ6MDsnXG4gICAgICAgICAgICAgICAgKyAncGFkZGluZzowO21hcmdpbjowO2JvcmRlcjpub25lO3doaXRlLXNwYWNlOnByZTsnO1xuICAgICAgICAgICAgdm1sQ29yZS5kb2MuYm9keS5hcHBlbmRDaGlsZCh0ZXh0TWVhc3VyZUVsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0ZXh0TWVhc3VyZUVsLnN0eWxlLmZvbnQgPSB0ZXh0Rm9udDtcbiAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICAgIC8vIElnbm9yZSBmYWlsdXJlcyB0byBzZXQgdG8gaW52YWxpZCBmb250LlxuICAgICAgICB9XG4gICAgICAgIHRleHRNZWFzdXJlRWwuaW5uZXJIVE1MID0gJyc7XG4gICAgICAgIC8vIERvbid0IHVzZSBpbm5lckhUTUwgb3IgaW5uZXJUZXh0IGJlY2F1c2UgdGhleSBhbGxvdyBtYXJrdXAvd2hpdGVzcGFjZS5cbiAgICAgICAgdGV4dE1lYXN1cmVFbC5hcHBlbmRDaGlsZChkb2MuY3JlYXRlVGV4dE5vZGUodGV4dCkpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgd2lkdGg6IHRleHRNZWFzdXJlRWwub2Zmc2V0V2lkdGhcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgdmFyIHRtcFJlY3QgPSBuZXcgQm91bmRpbmdSZWN0KCk7XG5cbiAgICB2YXIgZHJhd1JlY3RUZXh0ID0gZnVuY3Rpb24gKHZtbFJvb3QsIHJlY3QsIHRleHRSZWN0LCBmcm9tVGV4dEVsKSB7XG5cbiAgICAgICAgdmFyIHN0eWxlID0gdGhpcy5zdHlsZTtcbiAgICAgICAgdmFyIHRleHQgPSBzdHlsZS50ZXh0O1xuICAgICAgICBpZiAoIXRleHQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB4O1xuICAgICAgICB2YXIgeTtcbiAgICAgICAgdmFyIGFsaWduID0gc3R5bGUudGV4dEFsaWduO1xuICAgICAgICB2YXIgZm9udFN0eWxlID0gZ2V0Rm9udFN0eWxlKHN0eWxlLnRleHRGb250KTtcbiAgICAgICAgLy8gRklYTUUgZW5jb2RlSHRtbEF0dHJpYnV0ZSA/XG4gICAgICAgIHZhciBmb250ID0gZm9udFN0eWxlLnN0eWxlICsgJyAnICsgZm9udFN0eWxlLnZhcmlhbnQgKyAnICcgKyBmb250U3R5bGUud2VpZ2h0ICsgJyAnXG4gICAgICAgICAgICArIGZvbnRTdHlsZS5zaXplICsgJ3B4IFwiJyArIGZvbnRTdHlsZS5mYW1pbHkgKyAnXCInO1xuXG4gICAgICAgIHZhciBiYXNlbGluZSA9IHN0eWxlLnRleHRCYXNlbGluZTtcbiAgICAgICAgdmFyIHZlcnRpY2FsQWxpZ24gPSBzdHlsZS50ZXh0VmVydGljYWxBbGlnbjtcblxuICAgICAgICB0ZXh0UmVjdCA9IHRleHRSZWN0IHx8IHRleHRDb250YWluLmdldEJvdW5kaW5nUmVjdCh0ZXh0LCBmb250LCBhbGlnbiwgYmFzZWxpbmUpO1xuXG4gICAgICAgIC8vIFRyYW5zZm9ybSByZWN0IHRvIHZpZXcgc3BhY2VcbiAgICAgICAgdmFyIG0gPSB0aGlzLnRyYW5zZm9ybTtcbiAgICAgICAgLy8gSWdub3JlIHRyYW5zZm9ybSBmb3IgdGV4dCBpbiBvdGhlciBlbGVtZW50XG4gICAgICAgIGlmIChtICYmICFmcm9tVGV4dEVsKSB7XG4gICAgICAgICAgICB0bXBSZWN0LmNvcHkocmVjdCk7XG4gICAgICAgICAgICB0bXBSZWN0LmFwcGx5VHJhbnNmb3JtKG0pO1xuICAgICAgICAgICAgcmVjdCA9IHRtcFJlY3Q7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWZyb21UZXh0RWwpIHtcbiAgICAgICAgICAgIHZhciB0ZXh0UG9zaXRpb24gPSBzdHlsZS50ZXh0UG9zaXRpb247XG4gICAgICAgICAgICB2YXIgZGlzdGFuY2UgPSBzdHlsZS50ZXh0RGlzdGFuY2U7XG4gICAgICAgICAgICAvLyBUZXh0IHBvc2l0aW9uIHJlcHJlc2VudGVkIGJ5IGNvb3JkXG4gICAgICAgICAgICBpZiAodGV4dFBvc2l0aW9uIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgICAgICB4ID0gcmVjdC54ICsgcGFyc2VQZXJjZW50KHRleHRQb3NpdGlvblswXSwgcmVjdC53aWR0aCk7XG4gICAgICAgICAgICAgICAgeSA9IHJlY3QueSArIHBhcnNlUGVyY2VudCh0ZXh0UG9zaXRpb25bMV0sIHJlY3QuaGVpZ2h0KTtcblxuICAgICAgICAgICAgICAgIGFsaWduID0gYWxpZ24gfHwgJ2xlZnQnO1xuICAgICAgICAgICAgICAgIGJhc2VsaW5lID0gYmFzZWxpbmUgfHwgJ3RvcCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzID0gdGV4dENvbnRhaW4uYWRqdXN0VGV4dFBvc2l0aW9uT25SZWN0KFxuICAgICAgICAgICAgICAgICAgICB0ZXh0UG9zaXRpb24sIHJlY3QsIHRleHRSZWN0LCBkaXN0YW5jZVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgeCA9IHJlcy54O1xuICAgICAgICAgICAgICAgIHkgPSByZXMueTtcblxuICAgICAgICAgICAgICAgIC8vIERlZmF1bHQgYWxpZ24gYW5kIGJhc2VsaW5lIHdoZW4gaGFzIHRleHRQb3NpdGlvblxuICAgICAgICAgICAgICAgIGFsaWduID0gYWxpZ24gfHwgcmVzLnRleHRBbGlnbjtcbiAgICAgICAgICAgICAgICBiYXNlbGluZSA9IGJhc2VsaW5lIHx8IHJlcy50ZXh0QmFzZWxpbmU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB4ID0gcmVjdC54O1xuICAgICAgICAgICAgeSA9IHJlY3QueTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmVydGljYWxBbGlnbikge1xuICAgICAgICAgICAgc3dpdGNoICh2ZXJ0aWNhbEFsaWduKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnbWlkZGxlJzpcbiAgICAgICAgICAgICAgICAgICAgeSAtPSB0ZXh0UmVjdC5oZWlnaHQgLyAyO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdib3R0b20nOlxuICAgICAgICAgICAgICAgICAgICB5IC09IHRleHRSZWN0LmhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgLy8gJ3RvcCdcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElnbm9yZSBiYXNlbGluZVxuICAgICAgICAgICAgYmFzZWxpbmUgPSAndG9wJztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBmb250U2l6ZSA9IGZvbnRTdHlsZS5zaXplO1xuICAgICAgICAvLyAxLjc1IGlzIGFuIGFyYml0cmFyeSBudW1iZXIsIGFzIHRoZXJlIGlzIG5vIGluZm8gYWJvdXQgdGhlIHRleHQgYmFzZWxpbmVcbiAgICAgICAgc3dpdGNoIChiYXNlbGluZSkge1xuICAgICAgICAgICAgY2FzZSAnaGFuZ2luZyc6XG4gICAgICAgICAgICBjYXNlICd0b3AnOlxuICAgICAgICAgICAgICAgIHkgKz0gZm9udFNpemUgLyAxLjc1O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbWlkZGxlJzpcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAvLyBjYXNlIG51bGw6XG4gICAgICAgICAgICAvLyBjYXNlICdhbHBoYWJldGljJzpcbiAgICAgICAgICAgIC8vIGNhc2UgJ2lkZW9ncmFwaGljJzpcbiAgICAgICAgICAgIC8vIGNhc2UgJ2JvdHRvbSc6XG4gICAgICAgICAgICAgICAgeSAtPSBmb250U2l6ZSAvIDIuMjU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChhbGlnbikge1xuICAgICAgICAgICAgY2FzZSAnbGVmdCc6XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdjZW50ZXInOlxuICAgICAgICAgICAgICAgIHggLT0gdGV4dFJlY3Qud2lkdGggLyAyO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICAgICAgICAgIHggLT0gdGV4dFJlY3Qud2lkdGg7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAvLyBjYXNlICdlbmQnOlxuICAgICAgICAgICAgICAgIC8vIGFsaWduID0gZWxlbWVudFN0eWxlLmRpcmVjdGlvbiA9PSAnbHRyJyA/ICdyaWdodCcgOiAnbGVmdCc7XG4gICAgICAgICAgICAgICAgLy8gYnJlYWs7XG4gICAgICAgICAgICAvLyBjYXNlICdzdGFydCc6XG4gICAgICAgICAgICAgICAgLy8gYWxpZ24gPSBlbGVtZW50U3R5bGUuZGlyZWN0aW9uID09ICdydGwnID8gJ3JpZ2h0JyA6ICdsZWZ0JztcbiAgICAgICAgICAgICAgICAvLyBicmVhaztcbiAgICAgICAgICAgIC8vIGRlZmF1bHQ6XG4gICAgICAgICAgICAvLyAgICAgYWxpZ24gPSAnbGVmdCc7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY3JlYXRlTm9kZSA9IHZtbENvcmUuY3JlYXRlTm9kZTtcblxuICAgICAgICB2YXIgdGV4dFZtbEVsID0gdGhpcy5fdGV4dFZtbEVsO1xuICAgICAgICB2YXIgcGF0aEVsO1xuICAgICAgICB2YXIgdGV4dFBhdGhFbDtcbiAgICAgICAgdmFyIHNrZXdFbDtcbiAgICAgICAgaWYgKCF0ZXh0Vm1sRWwpIHtcbiAgICAgICAgICAgIHRleHRWbWxFbCA9IGNyZWF0ZU5vZGUoJ2xpbmUnKTtcbiAgICAgICAgICAgIHBhdGhFbCA9IGNyZWF0ZU5vZGUoJ3BhdGgnKTtcbiAgICAgICAgICAgIHRleHRQYXRoRWwgPSBjcmVhdGVOb2RlKCd0ZXh0cGF0aCcpO1xuICAgICAgICAgICAgc2tld0VsID0gY3JlYXRlTm9kZSgnc2tldycpO1xuXG4gICAgICAgICAgICAvLyBGSVhNRSBXaHkgaGVyZSBpcyBub3QgY2FtbWVsIGNhc2VcbiAgICAgICAgICAgIC8vIEFsaWduICdjZW50ZXInIHNlZW1zIHdyb25nXG4gICAgICAgICAgICB0ZXh0UGF0aEVsLnN0eWxlWyd2LXRleHQtYWxpZ24nXSA9ICdsZWZ0JztcblxuICAgICAgICAgICAgaW5pdFJvb3RFbFN0eWxlKHRleHRWbWxFbCk7XG5cbiAgICAgICAgICAgIHBhdGhFbC50ZXh0cGF0aG9rID0gdHJ1ZTtcbiAgICAgICAgICAgIHRleHRQYXRoRWwub24gPSB0cnVlO1xuXG4gICAgICAgICAgICB0ZXh0Vm1sRWwuZnJvbSA9ICcwIDAnO1xuICAgICAgICAgICAgdGV4dFZtbEVsLnRvID0gJzEwMDAgMC4wNSc7XG5cbiAgICAgICAgICAgIGFwcGVuZCh0ZXh0Vm1sRWwsIHNrZXdFbCk7XG4gICAgICAgICAgICBhcHBlbmQodGV4dFZtbEVsLCBwYXRoRWwpO1xuICAgICAgICAgICAgYXBwZW5kKHRleHRWbWxFbCwgdGV4dFBhdGhFbCk7XG5cbiAgICAgICAgICAgIHRoaXMuX3RleHRWbWxFbCA9IHRleHRWbWxFbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIOi/memHjOaYr+WcqOWJjemdoiBhcHBlbmRDaGlsZCDkv53or4Hpobrluo/nmoTliY3mj5DkuItcbiAgICAgICAgICAgIHNrZXdFbCA9IHRleHRWbWxFbC5maXJzdENoaWxkO1xuICAgICAgICAgICAgcGF0aEVsID0gc2tld0VsLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgdGV4dFBhdGhFbCA9IHBhdGhFbC5uZXh0U2libGluZztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjb29yZHMgPSBbeCwgeV07XG4gICAgICAgIHZhciB0ZXh0Vm1sRWxTdHlsZSA9IHRleHRWbWxFbC5zdHlsZTtcbiAgICAgICAgLy8gSWdub3JlIHRyYW5zZm9ybSBmb3IgdGV4dCBpbiBvdGhlciBlbGVtZW50XG4gICAgICAgIGlmIChtICYmIGZyb21UZXh0RWwpIHtcbiAgICAgICAgICAgIGFwcGx5VHJhbnNmb3JtKGNvb3JkcywgY29vcmRzLCBtKTtcblxuICAgICAgICAgICAgc2tld0VsLm9uID0gdHJ1ZTtcblxuICAgICAgICAgICAgc2tld0VsLm1hdHJpeCA9IG1bMF0udG9GaXhlZCgzKSArIGNvbW1hICsgbVsyXS50b0ZpeGVkKDMpICsgY29tbWEgK1xuICAgICAgICAgICAgbVsxXS50b0ZpeGVkKDMpICsgY29tbWEgKyBtWzNdLnRvRml4ZWQoMykgKyAnLDAsMCc7XG5cbiAgICAgICAgICAgIC8vIFRleHQgcG9zaXRpb25cbiAgICAgICAgICAgIHNrZXdFbC5vZmZzZXQgPSAocm91bmQoY29vcmRzWzBdKSB8fCAwKSArICcsJyArIChyb3VuZChjb29yZHNbMV0pIHx8IDApO1xuICAgICAgICAgICAgLy8gTGVmdCB0b3AgcG9pbnQgYXMgb3JpZ2luXG4gICAgICAgICAgICBza2V3RWwub3JpZ2luID0gJzAgMCc7XG5cbiAgICAgICAgICAgIHRleHRWbWxFbFN0eWxlLmxlZnQgPSAnMHB4JztcbiAgICAgICAgICAgIHRleHRWbWxFbFN0eWxlLnRvcCA9ICcwcHgnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2tld0VsLm9uID0gZmFsc2U7XG4gICAgICAgICAgICB0ZXh0Vm1sRWxTdHlsZS5sZWZ0ID0gcm91bmQoeCkgKyAncHgnO1xuICAgICAgICAgICAgdGV4dFZtbEVsU3R5bGUudG9wID0gcm91bmQoeSkgKyAncHgnO1xuICAgICAgICB9XG5cbiAgICAgICAgdGV4dFBhdGhFbC5zdHJpbmcgPSBlbmNvZGVIdG1sQXR0cmlidXRlKHRleHQpO1xuICAgICAgICAvLyBUT0RPXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0ZXh0UGF0aEVsLnN0eWxlLmZvbnQgPSBmb250O1xuICAgICAgICB9XG4gICAgICAgIC8vIEVycm9yIGZvbnQgZm9ybWF0XG4gICAgICAgIGNhdGNoIChlKSB7fVxuXG4gICAgICAgIHVwZGF0ZUZpbGxBbmRTdHJva2UodGV4dFZtbEVsLCAnZmlsbCcsIHtcbiAgICAgICAgICAgIGZpbGw6IGZyb21UZXh0RWwgPyBzdHlsZS5maWxsIDogc3R5bGUudGV4dEZpbGwsXG4gICAgICAgICAgICBvcGFjaXR5OiBzdHlsZS5vcGFjaXR5XG4gICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB1cGRhdGVGaWxsQW5kU3Ryb2tlKHRleHRWbWxFbCwgJ3N0cm9rZScsIHtcbiAgICAgICAgICAgIHN0cm9rZTogZnJvbVRleHRFbCA/IHN0eWxlLnN0cm9rZSA6IHN0eWxlLnRleHRTdHJva2UsXG4gICAgICAgICAgICBvcGFjaXR5OiBzdHlsZS5vcGFjaXR5LFxuICAgICAgICAgICAgbGluZURhc2g6IHN0eWxlLmxpbmVEYXNoXG4gICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgIHRleHRWbWxFbC5zdHlsZS56SW5kZXggPSBnZXRaSW5kZXgodGhpcy56bGV2ZWwsIHRoaXMueiwgdGhpcy56Mik7XG5cbiAgICAgICAgLy8gQXR0YWNoZWQgdG8gcm9vdFxuICAgICAgICBhcHBlbmQodm1sUm9vdCwgdGV4dFZtbEVsKTtcbiAgICB9O1xuXG4gICAgdmFyIHJlbW92ZVJlY3RUZXh0ID0gZnVuY3Rpb24gKHZtbFJvb3QpIHtcbiAgICAgICAgcmVtb3ZlKHZtbFJvb3QsIHRoaXMuX3RleHRWbWxFbCk7XG4gICAgICAgIHRoaXMuX3RleHRWbWxFbCA9IG51bGw7XG4gICAgfTtcblxuICAgIHZhciBhcHBlbmRSZWN0VGV4dCA9IGZ1bmN0aW9uICh2bWxSb290KSB7XG4gICAgICAgIGFwcGVuZCh2bWxSb290LCB0aGlzLl90ZXh0Vm1sRWwpO1xuICAgIH07XG5cbiAgICB2YXIgbGlzdCA9IFtSZWN0VGV4dCwgRGlzcGxheWFibGUsIFpJbWFnZSwgUGF0aCwgVGV4dF07XG5cbiAgICAvLyBJbiBjYXNlIERpc3BsYXlhYmxlIGhhcyBiZWVuIG1peGVkIGluIFJlY3RUZXh0XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBwcm90byA9IGxpc3RbaV0ucHJvdG90eXBlO1xuICAgICAgICBwcm90by5kcmF3UmVjdFRleHQgPSBkcmF3UmVjdFRleHQ7XG4gICAgICAgIHByb3RvLnJlbW92ZVJlY3RUZXh0ID0gcmVtb3ZlUmVjdFRleHQ7XG4gICAgICAgIHByb3RvLmFwcGVuZFJlY3RUZXh0ID0gYXBwZW5kUmVjdFRleHQ7XG4gICAgfVxuXG4gICAgVGV4dC5wcm90b3R5cGUuYnJ1c2hWTUwgPSBmdW5jdGlvbiAodm1sUm9vdCkge1xuICAgICAgICB2YXIgc3R5bGUgPSB0aGlzLnN0eWxlO1xuICAgICAgICBpZiAoc3R5bGUudGV4dCkge1xuICAgICAgICAgICAgdGhpcy5kcmF3UmVjdFRleHQodm1sUm9vdCwge1xuICAgICAgICAgICAgICAgIHg6IHN0eWxlLnggfHwgMCwgeTogc3R5bGUueSB8fCAwLFxuICAgICAgICAgICAgICAgIHdpZHRoOiAwLCBoZWlnaHQ6IDBcbiAgICAgICAgICAgIH0sIHRoaXMuZ2V0Qm91bmRpbmdSZWN0KCksIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVSZWN0VGV4dCh2bWxSb290KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBUZXh0LnByb3RvdHlwZS5vblJlbW92ZSA9IGZ1bmN0aW9uICh2bWxSb290KSB7XG4gICAgICAgIHRoaXMucmVtb3ZlUmVjdFRleHQodm1sUm9vdCk7XG4gICAgfTtcblxuICAgIFRleHQucHJvdG90eXBlLm9uQWRkID0gZnVuY3Rpb24gKHZtbFJvb3QpIHtcbiAgICAgICAgdGhpcy5hcHBlbmRSZWN0VGV4dCh2bWxSb290KTtcbiAgICB9O1xufVxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34venJlbmRlci9saWIvdm1sL2dyYXBoaWMuanNcbiAqKiBtb2R1bGUgaWQgPSAxMThcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlxuXG5pZiAoIXJlcXVpcmUoJy4uL2NvcmUvZW52JykuY2FudmFzU3VwcG9ydGVkKSB7XG4gICAgdmFyIHVybiA9ICd1cm46c2NoZW1hcy1taWNyb3NvZnQtY29tOnZtbCc7XG5cbiAgICB2YXIgY3JlYXRlTm9kZTtcbiAgICB2YXIgd2luID0gd2luZG93O1xuICAgIHZhciBkb2MgPSB3aW4uZG9jdW1lbnQ7XG5cbiAgICB2YXIgdm1sSW5pdGVkID0gZmFsc2U7XG5cbiAgICB0cnkge1xuICAgICAgICAhZG9jLm5hbWVzcGFjZXMuenJ2bWwgJiYgZG9jLm5hbWVzcGFjZXMuYWRkKCd6cnZtbCcsIHVybik7XG4gICAgICAgIGNyZWF0ZU5vZGUgPSBmdW5jdGlvbiAodGFnTmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIGRvYy5jcmVhdGVFbGVtZW50KCc8enJ2bWw6JyArIHRhZ05hbWUgKyAnIGNsYXNzPVwienJ2bWxcIj4nKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgY3JlYXRlTm9kZSA9IGZ1bmN0aW9uICh0YWdOYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gZG9jLmNyZWF0ZUVsZW1lbnQoJzwnICsgdGFnTmFtZSArICcgeG1sbnM9XCInICsgdXJuICsgJ1wiIGNsYXNzPVwienJ2bWxcIj4nKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBGcm9tIHJhcGhhZWxcbiAgICB2YXIgaW5pdFZNTCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHZtbEluaXRlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZtbEluaXRlZCA9IHRydWU7XG5cbiAgICAgICAgdmFyIHN0eWxlU2hlZXRzID0gZG9jLnN0eWxlU2hlZXRzO1xuICAgICAgICBpZiAoc3R5bGVTaGVldHMubGVuZ3RoIDwgMzEpIHtcbiAgICAgICAgICAgIGRvYy5jcmVhdGVTdHlsZVNoZWV0KCkuYWRkUnVsZSgnLnpydm1sJywgJ2JlaGF2aW9yOnVybCgjZGVmYXVsdCNWTUwpJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvbXM1MzExOTQlMjhWUy44NSUyOS5hc3B4XG4gICAgICAgICAgICBzdHlsZVNoZWV0c1swXS5hZGRSdWxlKCcuenJ2bWwnLCAnYmVoYXZpb3I6dXJsKCNkZWZhdWx0I1ZNTCknKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBOb3QgdXNlaW5nIHJldHVybiB0byBhdm9pZCBlcnJvciB3aGVuIGNvbnZlcnRpbmcgdG8gQ29tbW9uSlMgbW9kdWxlXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgICAgIGRvYzogZG9jLFxuICAgICAgICBpbml0Vk1MOiBpbml0Vk1MLFxuICAgICAgICBjcmVhdGVOb2RlOiBjcmVhdGVOb2RlXG4gICAgfTtcbn1cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3pyZW5kZXIvbGliL3ZtbC9jb3JlLmpzXG4gKiogbW9kdWxlIGlkID0gMTE5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIFZNTCBQYWludGVyLlxuICpcbiAqIEBtb2R1bGUgenJlbmRlci92bWwvUGFpbnRlclxuICovXG5cblxuXG4gICAgdmFyIHpyTG9nID0gcmVxdWlyZSgnLi4vY29yZS9sb2cnKTtcbiAgICB2YXIgdm1sQ29yZSA9IHJlcXVpcmUoJy4vY29yZScpO1xuXG4gICAgZnVuY3Rpb24gcGFyc2VJbnQxMCh2YWwpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlSW50KHZhbCwgMTApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBhbGlhcyBtb2R1bGU6enJlbmRlci92bWwvUGFpbnRlclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFZNTFBhaW50ZXIocm9vdCwgc3RvcmFnZSkge1xuXG4gICAgICAgIHZtbENvcmUuaW5pdFZNTCgpO1xuXG4gICAgICAgIHRoaXMucm9vdCA9IHJvb3Q7XG5cbiAgICAgICAgdGhpcy5zdG9yYWdlID0gc3RvcmFnZTtcblxuICAgICAgICB2YXIgdm1sVmlld3BvcnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblxuICAgICAgICB2YXIgdm1sUm9vdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXG4gICAgICAgIHZtbFZpZXdwb3J0LnN0eWxlLmNzc1RleHQgPSAnZGlzcGxheTppbmxpbmUtYmxvY2s7b3ZlcmZsb3c6aGlkZGVuO3Bvc2l0aW9uOnJlbGF0aXZlO3dpZHRoOjMwMHB4O2hlaWdodDoxNTBweDsnO1xuXG4gICAgICAgIHZtbFJvb3Quc3R5bGUuY3NzVGV4dCA9ICdwb3NpdGlvbjphYnNvbHV0ZTtsZWZ0OjA7dG9wOjA7JztcblxuICAgICAgICByb290LmFwcGVuZENoaWxkKHZtbFZpZXdwb3J0KTtcblxuICAgICAgICB0aGlzLl92bWxSb290ID0gdm1sUm9vdDtcbiAgICAgICAgdGhpcy5fdm1sVmlld3BvcnQgPSB2bWxWaWV3cG9ydDtcblxuICAgICAgICB0aGlzLnJlc2l6ZSgpO1xuXG4gICAgICAgIC8vIE1vZGlmeSBzdG9yYWdlXG4gICAgICAgIHZhciBvbGREZWxGcm9tTWFwID0gc3RvcmFnZS5kZWxGcm9tTWFwO1xuICAgICAgICB2YXIgb2xkQWRkVG9NYXAgPSBzdG9yYWdlLmFkZFRvTWFwO1xuICAgICAgICBzdG9yYWdlLmRlbEZyb21NYXAgPSBmdW5jdGlvbiAoZWxJZCkge1xuICAgICAgICAgICAgdmFyIGVsID0gc3RvcmFnZS5nZXQoZWxJZCk7XG5cbiAgICAgICAgICAgIG9sZERlbEZyb21NYXAuY2FsbChzdG9yYWdlLCBlbElkKTtcblxuICAgICAgICAgICAgaWYgKGVsKSB7XG4gICAgICAgICAgICAgICAgZWwub25SZW1vdmUgJiYgZWwub25SZW1vdmUodm1sUm9vdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgc3RvcmFnZS5hZGRUb01hcCA9IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgLy8gRGlzcGxheWFibGUgYWxyZWFkeSBoYXMgYSB2bWwgbm9kZVxuICAgICAgICAgICAgZWwub25BZGQgJiYgZWwub25BZGQodm1sUm9vdCk7XG5cbiAgICAgICAgICAgIG9sZEFkZFRvTWFwLmNhbGwoc3RvcmFnZSwgZWwpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuX2ZpcnN0UGFpbnQgPSB0cnVlO1xuICAgIH1cblxuICAgIFZNTFBhaW50ZXIucHJvdG90eXBlID0ge1xuXG4gICAgICAgIGNvbnN0cnVjdG9yOiBWTUxQYWludGVyLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHtIVE1MRGl2RWxlbWVudH1cbiAgICAgICAgICovXG4gICAgICAgIGdldFZpZXdwb3J0Um9vdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3ZtbFZpZXdwb3J0O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDliLfmlrBcbiAgICAgICAgICovXG4gICAgICAgIHJlZnJlc2g6IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAgICAgdmFyIGxpc3QgPSB0aGlzLnN0b3JhZ2UuZ2V0RGlzcGxheUxpc3QodHJ1ZSwgdHJ1ZSk7XG5cbiAgICAgICAgICAgIHRoaXMuX3BhaW50TGlzdChsaXN0KTtcbiAgICAgICAgfSxcblxuICAgICAgICBfcGFpbnRMaXN0OiBmdW5jdGlvbiAobGlzdCkge1xuICAgICAgICAgICAgdmFyIHZtbFJvb3QgPSB0aGlzLl92bWxSb290O1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVsID0gbGlzdFtpXTtcbiAgICAgICAgICAgICAgICBpZiAoZWwuaW52aXNpYmxlIHx8IGVsLmlnbm9yZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWVsLl9fYWxyZWFkeU5vdFZpc2libGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsLm9uUmVtb3ZlKHZtbFJvb3QpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFNldCBhcyBhbHJlYWR5IGludmlzaWJsZVxuICAgICAgICAgICAgICAgICAgICBlbC5fX2FscmVhZHlOb3RWaXNpYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbC5fX2FscmVhZHlOb3RWaXNpYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbC5vbkFkZCh2bWxSb290KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbC5fX2FscmVhZHlOb3RWaXNpYmxlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbC5fX2RpcnR5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbC5iZWZvcmVCcnVzaCAmJiBlbC5iZWZvcmVCcnVzaCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgKGVsLmJydXNoVk1MIHx8IGVsLmJydXNoKS5jYWxsKGVsLCB2bWxSb290KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsLmFmdGVyQnJ1c2ggJiYgZWwuYWZ0ZXJCcnVzaCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsLl9fZGlydHkgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMuX2ZpcnN0UGFpbnQpIHtcbiAgICAgICAgICAgICAgICAvLyBEZXRhY2hlZCBmcm9tIGRvY3VtZW50IGF0IGZpcnN0IHRpbWVcbiAgICAgICAgICAgICAgICAvLyB0byBhdm9pZCBwYWdlIHJlZnJlc2hpbmcgdG9vIG1hbnkgdGltZXNcblxuICAgICAgICAgICAgICAgIC8vIEZJWE1FIOWmguaenOavj+asoemDveWFiCByZW1vdmVDaGlsZCDlj6/og73kvJrlr7zoh7TkuIDkupvloavlhYXlkozmj4/ovrnnmoTmlYjmnpzmlLnlj5hcbiAgICAgICAgICAgICAgICB0aGlzLl92bWxWaWV3cG9ydC5hcHBlbmRDaGlsZCh2bWxSb290KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9maXJzdFBhaW50ID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVzaXplOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgd2lkdGggPSB0aGlzLl9nZXRXaWR0aCgpO1xuICAgICAgICAgICAgdmFyIGhlaWdodCA9IHRoaXMuX2dldEhlaWdodCgpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5fd2lkdGggIT0gd2lkdGggJiYgdGhpcy5faGVpZ2h0ICE9IGhlaWdodCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3dpZHRoID0gd2lkdGg7XG4gICAgICAgICAgICAgICAgdGhpcy5faGVpZ2h0ID0gaGVpZ2h0O1xuXG4gICAgICAgICAgICAgICAgdmFyIHZtbFZpZXdwb3J0U3R5bGUgPSB0aGlzLl92bWxWaWV3cG9ydC5zdHlsZTtcbiAgICAgICAgICAgICAgICB2bWxWaWV3cG9ydFN0eWxlLndpZHRoID0gd2lkdGggKyAncHgnO1xuICAgICAgICAgICAgICAgIHZtbFZpZXdwb3J0U3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgJ3B4JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBkaXNwb3NlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLnJvb3QuaW5uZXJIVE1MID0gJyc7XG5cbiAgICAgICAgICAgIHRoaXMuX3ZtbFJvb3QgPVxuICAgICAgICAgICAgdGhpcy5fdm1sVmlld3BvcnQgPVxuICAgICAgICAgICAgdGhpcy5zdG9yYWdlID0gbnVsbDtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXRXaWR0aDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dpZHRoO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldEhlaWdodDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2hlaWdodDtcbiAgICAgICAgfSxcblxuICAgICAgICBjbGVhcjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5yb290LnJlbW92ZUNoaWxkKHRoaXMudm1sVmlld3BvcnQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9nZXRXaWR0aDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHJvb3QgPSB0aGlzLnJvb3Q7XG4gICAgICAgICAgICB2YXIgc3RsID0gcm9vdC5jdXJyZW50U3R5bGU7XG5cbiAgICAgICAgICAgIHJldHVybiAoKHJvb3QuY2xpZW50V2lkdGggfHwgcGFyc2VJbnQxMChzdGwud2lkdGgpKVxuICAgICAgICAgICAgICAgICAgICAtIHBhcnNlSW50MTAoc3RsLnBhZGRpbmdMZWZ0KVxuICAgICAgICAgICAgICAgICAgICAtIHBhcnNlSW50MTAoc3RsLnBhZGRpbmdSaWdodCkpIHwgMDtcbiAgICAgICAgfSxcblxuICAgICAgICBfZ2V0SGVpZ2h0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcm9vdCA9IHRoaXMucm9vdDtcbiAgICAgICAgICAgIHZhciBzdGwgPSByb290LmN1cnJlbnRTdHlsZTtcblxuICAgICAgICAgICAgcmV0dXJuICgocm9vdC5jbGllbnRIZWlnaHQgfHwgcGFyc2VJbnQxMChzdGwuaGVpZ2h0KSlcbiAgICAgICAgICAgICAgICAgICAgLSBwYXJzZUludDEwKHN0bC5wYWRkaW5nVG9wKVxuICAgICAgICAgICAgICAgICAgICAtIHBhcnNlSW50MTAoc3RsLnBhZGRpbmdCb3R0b20pKSB8IDA7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gTm90IHN1cHBvcnRlZCBtZXRob2RzXG4gICAgZnVuY3Rpb24gY3JlYXRlTWV0aG9kTm90U3VwcG9ydChtZXRob2QpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHpyTG9nKCdJbiBJRTguMCBWTUwgbW9kZSBwYWludGVyIG5vdCBzdXBwb3J0IG1ldGhvZCBcIicgKyBtZXRob2QgKyAnXCInKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgbm90U3VwcG9ydGVkTWV0aG9kcyA9IFtcbiAgICAgICAgJ2dldExheWVyJywgJ2luc2VydExheWVyJywgJ2VhY2hMYXllcicsICdlYWNoQnVpbGRpbkxheWVyJywgJ2VhY2hPdGhlckxheWVyJywgJ2dldExheWVycycsXG4gICAgICAgICdtb2RMYXllcicsICdkZWxMYXllcicsICdjbGVhckxheWVyJywgJ3RvRGF0YVVSTCcsICdwYXRoVG9JbWFnZSdcbiAgICBdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub3RTdXBwb3J0ZWRNZXRob2RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBuYW1lID0gbm90U3VwcG9ydGVkTWV0aG9kc1tpXTtcbiAgICAgICAgVk1MUGFpbnRlci5wcm90b3R5cGVbbmFtZV0gPSBjcmVhdGVNZXRob2ROb3RTdXBwb3J0KG5hbWUpO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gVk1MUGFpbnRlcjtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3pyZW5kZXIvbGliL3ZtbC9QYWludGVyLmpzXG4gKiogbW9kdWxlIGlkID0gMTIwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9