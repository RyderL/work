(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["fishTopoFlow"] = factory();
	else
		root["fishTopoFlow"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(1);


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Export fishTopo as CommonJS module
	 */
	module.exports = __webpack_require__(2);
	//兼容IE8 引入VML 如果不需要兼容IE8请删除
	__webpack_require__(96);


/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * 流程对象
	 * @class fish.topo.FishTopoFlow
	 */
	
	/**
	 * @event click
	 * 节点或者线段的click事件
	 * @param {Object} event 事件 event.target为目标对象 event.target.model为目标对象的业务数据
	 *
	 * **使用范例**：
	 *
	 *      @example
	 *          this.fishTopo.on("click", function(event) {
	 *              console.log("点击的是：" + event.target.model.get('elementType'));
	 *          });
	 */
	
	/**
	 * @event dblclick
	 * 节点或者线段的双击事件
	 * @param {Object} event 事件 event.target为目标对象 event.target.model为目标对象的业务数据
	 *
	 * **使用范例**：
	 *
	 *      @example
	 *          this.fishTopo.on("dblclick", function(event) {
	 *              console.log("双击的是：" + event.target.model.get('elementType'));
	 *          });
	 */
	
	/**
	 * @event create
	 * 节点与线段创建完毕的事件
	 * @param {Object} event 事件 event.target为目标对象 event.target.model为目标对象的业务数据
	 *
	 * **使用范例**：
	 *
	 *      @example
	 *          this.fishTopo.on("create", function(e) {
	 *               if (me.fishTopo.Flow.isLink(e.target.model)) {
	 *                  console.log("线段创建完毕：" + e.target.model);
	 *               }
	 *          });
	 */
	
	/**
	 * @event delete
	 * 节点与线段创建完毕的事件
	 * @param {Object} event 事件 event.target为目标对象 event.target.model为目标对象的业务数据
	 *
	 * **使用范例**：
	 *
	 *      @example
	 *          //节点删除完毕事件
	 *          this.fishTopo.on("delete", function(event) {
	 *              console.log("删除的是：" + event.target.model.get('elementType'));
	 *          });
	 */
	
	/**
	 * @event mousedown
	 * 节点与线段鼠标按下事件
	 * @param {Object} event 事件 node为节点
	 *
	 * **使用范例**：
	 *
	 *      @example
	 *          node.on("mousedown", function(){
	 *              node.attr("style",{text:"mousedown"});
	 *          });
	 */
	
	/**
	 * @event mouseup
	 * 节点与线段鼠标抬起事件
	 * @param {Object} event 事件 node为节点
	 *
	 * **使用范例**：
	 *
	 *      @example
	 *          node.on("mouseup", function(){
	 *              node.attr("style",{text:"mouseup"});
	 *          });
	 */
	
	/**
	 * @event mouseover
	 * 节点与线段鼠标悬浮事件
	 * @param {Object} event 事件 node为节点
	 *
	 * **使用范例**：
	 *
	 *      @example
	 *          node.on("mouseover", function(){
	 *              node.attr("style",{text:"mouseover"});
	 *          });
	 */
	
	/**
	 * @event mousemove
	 * 节点与线段鼠标移动事件
	 * @param {Object} event 事件 node为节点
	 *
	 * **使用范例**：
	 *
	 *      @example
	 *          node.on("mousemove", function(){
	 *              node.attr("style",{text:"mousemove"});
	 *          });
	 */
	
	/**
	 * @event mouseout
	 * 节点与线段鼠标离开事件
	 * @param {Object} event 事件 node为节点
	 *
	 * **使用范例**：
	 *
	 *      @example
	 *          node.on("mouseout", function(){
	 *              node.attr("style",{text:"mouseout"});
	 *          });
	 */
	
	
	/**
	 * @method setStyle
	 * 节点与线段更改style里的属性
	 * @param {String} name 节点或者线段style里的某个属性名称
	 * @param {String} string 节点或者线段style里的某个属性名称对应的值
	 * **使用范例**：
	 *
	 *      @example
	 *          //节点设置文字
	 *         node.setStyle("text","例子");
	 */
	
	/**
	 * @method setShape
	 * 节点更改shape里的属性
	 * @param {String} name 节点shape里的某个属性名称
	 * @param {String} string 节点shape里的某个属性名称对应的值
	 * **使用范例**：
	 *
	 *      @example
	 *          //矩形节点设置宽
	 *         node.setShape("width",100);
	 */
	
	
	
	
	
	    var graphic = __webpack_require__(3);
	    var Minimap = __webpack_require__(58);
	    var util = __webpack_require__(59);
	    var Point = __webpack_require__(60);
	    var ExtensionAPI = __webpack_require__(62);
	    var Eventful = __webpack_require__(11);
	    var zrender = __webpack_require__(63);
	    var zrUtil = __webpack_require__(4);
	    var GroupNode = __webpack_require__(75);
	    var OperationNode = __webpack_require__(82);
	    var FlowConnectionManager = __webpack_require__(83);
	    var forceInstance = __webpack_require__(89);
	    var treeLayout = __webpack_require__(91);
	    var FlowUtil = __webpack_require__(92);
	    var Constants = __webpack_require__(86);
	    var Model = __webpack_require__(87);
	    var eventTool = __webpack_require__(69);
	    var Connector = __webpack_require__(77);
	    var LineOperationManager = __webpack_require__(93);
	    var Flow = __webpack_require__(94);
	    var textContain = __webpack_require__(23);
	    var ImagePool = __webpack_require__(95);
	
	    function FishTopoFlow(dom, opts) {
	        this.id;
	        this.group;
	        this._dom = dom;
	        this.nowZoom = 1;
	        this.canScale = true;
	        this.eagleEye = false;
	        this.eagleEyeNode;
	        this.initScaleRatio;
	        this.operationNode;
	        this.selectedNode = null;
	        this.allNodes = [];
	        this.minimap;
	        this._layoutTimeout = null;
	        this._zr = zrender.init(dom, {
	            renderer: opts.renderer || 'canvas',
	            devicePixelRatio: opts.devicePixelRatio
	        });
	
	        this._api = new ExtensionAPI(this);
	        this.Shape = graphic;
	        this.model = new Model({});
	        this.model.set(Constants.ELEMENT_TYPE, "scene");
	        this.model.set(Constants.MODE, "normal");
	        this.options = opts;
	        Eventful.call(this);
	    }
	
	    var fishTopoProto = FishTopoFlow.prototype;
	
	    fishTopoProto.forceInstance = forceInstance;
	    fishTopoProto.treeLayout = treeLayout;
	    /**
	     * 获取 fishTopo 实例容器的 dom 节点
	     * @return {HTMLElement}
	     */
	    fishTopoProto.getDom = function() {
	        return this._dom;
	    };
	
	    /**
	     * @private
	     */
	    fishTopoProto.getZr = function() {
	        return this._zr;
	    };
	    /**
	     * 获取 fishTopo 实例容器的宽度。
	     * @return {number}
	     */
	    fishTopoProto.getWidth = function() {
	        return this._zr.getWidth();
	    };
	
	    /**
	     * 获取 fishTopo 实例容器的高度。
	     * @return {number}
	     */
	    fishTopoProto.getHeight = function() {
	        return this._zr.getHeight();
	    };
	
	
	    /**
	     * 当前实例是否已经被释放。
	     * @return {boolean}
	     */
	    fishTopoProto.isDisposed = function() {
	        return this._disposed;
	    };
	
	    /**
	     * Dispose instance
	     */
	    fishTopoProto.dispose = function() {
	        this._disposed = true;
	
	        this._zr.dispose();
	
	        instances[this.id] = null;
	    };
	
	
	    /**
	     * 调整尺寸  在窗口大小发生改变时需要手工调用
	     * @param {number} width 宽度
	     * @param {number} height 高度
	     */
	    fishTopoProto.resize = function() {
	        this._zr.resize();
	
	    };
	
	    /**
	     * @private
	     * 初始化
	     */
	    fishTopoProto.init = function() {
	        var that = this;
	        this.group = new graphic.Group();
	        this.group.isBg = true;
	        this.groupDrag(this.group);
	        this._zr.add(this.group);
	        this.zrScale();
	        FlowConnectionManager.connectors = [];
	        //mouseup 会在各个node或线的click事件之点执行  在选中节点或线前 先清空选中效果
	        this._zr.on("mouseup", function(e) {
	            clearSelect(e);
	        });
	        that._zr.on("globalout", function(e) {
	            clearSelect(e);
	        });
	        function clearSelect(e){
	            if (that.operationNode) {
	                that.group.remove(that.operationNode);
	                that.operationNode = null;
	            }
	            var shape = e.target;
	            if (shape && shape.model && Flow.isLink(shape.model)) {
	                return;
	            }
	            FlowConnectionManager.clearSelectCon();
	            if (shape && shape.operation && shape.operation == true) {
	                return;
	            }
	            LineOperationManager.hideAllLineOperation();
	        }
	        this._zr.on("click", function(e) {
	
	            var shape = e.target.model;
	            if ((shape && Flow.isLink(shape)) || (shape && Flow.isNode(shape))) {
	                return;
	            }
	            var params = {};
	            params.event = e;
	            params.type = "click";
	            params.target = that;
	            that._api.trigger(params.type, params);
	        });
	        this.on('conPointsGroup:click', function(argument) {
	            LineOperationManager.bindOperation(argument.lineNode);
	        });
	
	        //polyfill remove
	        if (!('remove' in Element.prototype)) {
	            Element.prototype.remove = function() {
	                if (this.parentNode) {
	                    this.parentNode.removeChild(this);
	                }
	            };
	        }
	    };
	
	    /**
	     * 导出json
	     * @return {Object} json对象
	     */
	    fishTopoProto.toJson = function() {
	        return FlowUtil.toJson(this.model, this.group);
	    };
	
	    /**
	     * 导入json
	     * @param  {Object} json对象
	     */
	    fishTopoProto.fromJson = function(json) {
	        this.clear();
	        var model = new Model(json);
	        this.setBackground(model.get(Constants.BACKGROUND));
	        var layoutRootNode = [];
	        FlowUtil.fromJson(this, this.group, model.get(Constants.CHILDS), false, layoutRootNode);
	        for(var i = 0; i < layoutRootNode.length; i++){
	            console.log(layoutRootNode)
	            this.layoutNode("tree", {
	                "node": layoutRootNode[i],
	                "type":layoutRootNode[i].treeType
	            });
	        }
	    };
	
	    /**
	     * 添加节点
	     * @method addNode
	     * @param {Object} node creatNode返回的对象
	     */
	    fishTopoProto.addNode = function(node) {
	        if (node instanceof GroupNode) {
	            node.setProperties({
	                shape: {
	                    width: node.getBoundingRect().width,
	                    height: node.getBoundingRect().height
	                }
	            });
	        }
	        this.group.add(node);
	    };
	
	    /**
	     * 清空当前实例，会移除实例中所有的节点与线
	     * @method clear
	     */
	    fishTopoProto.clear = function() {
	        for (var i = 0; i < this.allNodes.length; i++) {
	            var parentZr;
	            if (this.allNodes.parent) {
	                parentZr = this.allNodes.parent;
	            } else {
	                parentZr = this._zr;
	            }
	            FlowConnectionManager.deleteSelectCon(this.allNodes[i], parentZr)
	        }
	        FlowConnectionManager.connectorMap.clear();
	        this.allNodes = [];
	        this.operationNode = null;
	        this.selectedNode = null;
	        FlowConnectionManager.connectors = [];
	        this._zr.clear();
	        this.group = new graphic.Group();
	        this.group.isBg = true;
	        this._zr.add(this.group);
	    };
	
	    /**
	     * 创建连线的小图标操作
	     * @param {string} key 小图标的名称
	     * @param {Object} options 小图标的相关参数
	     * @param {String} [options.icon] 小图标路径
	     * @param {Object} [options.lineNode] 线段实例
	     * @param {Function} [options.callback] 点击后的回调
	     *
	     * **使用范例**：
	     *
	     *      @example
	     *                  this.fishTopo.addIcon("icon1", {
	     *                      icon: "https://ss0.bdstatic.com/5aV1bjqh_Q23odCf/static/superman/img/logo_top_ca79a146.png",
	     *                      lineNode: lineNode,
	     *                      callback: function(lineNode) {
	     *                          alert(JSON.stringify(lineNode))
	     *                      },
	     *                  });
	     */
	    fishTopoProto.addIcon = function(key, options) {
	        LineOperationManager.addIcon(key, options, this.group, this._api);
	    };
	
	    /**
	     * 创建连线的默认删除操作
	     * @param  {Object} lineNode 线
	     *
	     *  **使用范例**：
	     *
	     *      @example
	     *      fishTopo.lineDefaultIcon(lineNode);
	     */
	    fishTopoProto.lineDefaultIcon = function(lineNode) {
	        this.addLineDeleteIcon(lineNode);
	        this.addLineChangeIcon(lineNode);
	    };
	
	    /**
	     * @private
	     * 添加线的删除图标
	     */
	    fishTopoProto.addLineDeleteIcon = function(lineNode) {
	        var that = this;
	        var parentZr;
	        if (lineNode.parent) {
	            parentZr = lineNode.parent;
	        } else {
	            parentZr = this.group;
	        }
	        //创建删除
	        var lineOperation = LineOperationManager.addIcon("delete", LineOperationManager.deleteIconObj(parentZr, lineNode), parentZr, this._api);
	        if (lineOperation) {
	            lineOperation.on("click", function() {
	                that._triggerDeleteEvent(lineNode);
	            });
	        }
	    };
	
	    /**
	     * @private
	     * 添加线的切换图标
	     */
	    fishTopoProto.addLineChangeIcon = function(lineNode) {
	        var that = this;
	        var parentZr;
	        if (lineNode.parent) {
	            parentZr = lineNode.parent;
	        } else {
	            parentZr = this.group;
	        }
	        var arrLineType = [Connector.TYPE_STRAIGHT, Connector.TYPE_JAGGED, Connector.TYPE_CURVE];
	
	        function modifyNextLineType(line) {
	            var index = zrUtil.indexOf(arrLineType, line.options.style.lineType);
	            var nextLineType = arrLineType[(index + 1) % arrLineType.length];
	            //FlowConnectionManager.setModel(line,{style:{lineType:nextLineType}});
	            var startNode = line.startNode;
	            var endNode = line.endNode;
	
	            FlowConnectionManager.deleteLine(parentZr);
	            LineOperationManager.hideAllLineOperation();
	
	            var nextLine = that._createConnectorByNodes(startNode, endNode, nextLineType);
	            nextLine.icons = line.icons;
	            nextLine.on('click', function() {
	                LineOperationManager.bindOperation(nextLine);
	            });
	            return nextLine;
	        }
	
	        //创建切换
	        LineOperationManager.addIcon("change", {
	            icon: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABcAAAAPBAMAAAD9gUllAAAABGdBTUEAALGPC/xhBQAAAAFzUkdCAK7OHOkAAAAqUExURQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAoTzogAAAAOdFJOUwD+CC3uuR7gVXeeFEnMRIEDJwAAAGRJREFUCNdjYOCZwIAA7YuUQADM1nQsDQWBBBBnoSAYiBiAOGeROWwLIzpAYANEE7JpDBtQKAiYqQCmlI1BYOFqMMfcBQQERcEGmkBMFwwAcWzLQcBRCuwItTQQWD4JybQ5DAwAO74b0S83OyMAAAAASUVORK5CYII=",
	            width: 15,
	            height: 15,
	            lineNode: lineNode,
	            callback: function() {
	
	                var selectedLine = modifyNextLineType(FlowConnectionManager.selConnector);
	                //.  LineOperationManager.bindOperation(selectedLine);
	            }
	        }, parentZr, this._api);
	    };
	
	    /**
	     * @private
	     * 初始化 操作的虚线框
	     */
	    fishTopoProto.initOperationNode = function(node) {
	        var that = this;
	        this.operationNode = new OperationNode(node, this.group);
	
	        this.operationNode.on(OperationNode.ARROW_DRAGSTART, function(e) {
	            var x = (e.event.offsetX - that.group.position[0]) / that.nowZoom;
	            var y = (e.event.offsetY - that.group.position[1]) / that.nowZoom;
	            //拖拽开始先把 箭头图标 给隐藏
	            var arrow = e.event.target;
	            arrow.hide();
	            var rEndPoint = new Point(x, y);
	            var connector = FlowConnectionManager.manageTempConnector(that.selectedNode, rEndPoint, arrow.lineType);
	            that.group.add(connector);
	            e.cancelBubble = true;
	        });
	
	        // 侦听 箭头 拖拽事件
	        this.operationNode.on(OperationNode.ARROW_DRAG, function(e) {
	            var x = (e.event.offsetX - that.group.position[0]) / that.nowZoom;
	            var y = (e.event.offsetY - that.group.position[1]) / that.nowZoom;
	            var arrow = e.event.target;
	            var rEndPoint = new Point(x, y);
	            FlowConnectionManager.manageTempConnector(that.selectedNode, rEndPoint, arrow.lineType);
	            e.cancelBubble = true;
	        });
	
	        //侦听 箭头 拖拽结束事件 画线
	        this.operationNode.on(OperationNode.ARROW_DRAGEND, function(e) {
	            e.cancelBubble = true;
	            var x = e.event.offsetX;
	            var y = e.event.offsetY;
	            var targetNode = null;
	            //拖拽结束先把 箭头图标 给显示
	            var arrow = e.event.target;
	            arrow.show();
	            //删除临时线
	            FlowConnectionManager.removeTempConnector(that.group);
	
	            //1.如果是子节点 内 节点拖拽 则 增加排除子节点的参数
	            targetNode = findHover(that.allNodes, x, y);
	
	            function isHover(node, x, y) {
	                var cx, cy;
	                return node.rectContain(x, y);
	            }
	
	            function findHover(list, x, y, excludes) {
	                for (var i = list.length - 1; i >= 0; i--) {
	                    if (isExclude(excludes, list[i]) //list[i] !== exclude
	                        // getDisplayList may include ignored item in VML mode
	                        && !list[i].ignore && isHover(list[i], x, y)) {
	                        return list[i];
	                    }
	                }
	            }
	
	            function isExclude(excludes, node) {
	                return zrUtil.indexOf(excludes, node) == -1;
	            }
	
	            //2.如果找到目标结点 则画线
	            if (targetNode && (that.selectedNode != targetNode)) {
	                that._createConnectorByNodes(that.selectedNode, targetNode, arrow.lineType);
	            }
	        });
	
	        //删除按钮点击事件
	        this.operationNode.on(OperationNode.DELETE_CLICK, function() {
	            that._triggerDeleteEvent(that.selectedNode);
	            that.removeNode(that.selectedNode);
	            if (that.selectedNode.cmsImage) {
	                that._triggerDeleteEvent(that.selectedNode.cmsImage);
	                that.removeNode(that.selectedNode.cmsImage);
	            }
	        });
	        this.group.add(this.operationNode);
	    };
	
	    /**
	     * 移除场景中的某个节点
	     * @param  {Object} selectedNode 待删除的节点
	     */
	    fishTopoProto.removeNode = function(selectedNode) {
	        var that = this;
	        //1.如果是子节点 内 节点  则 调用子节点的删除
	        if (selectedNode.parent) {
	            selectedNode.parent.remove(selectedNode);
	        } else {
	            that.group.remove(selectedNode);
	        }
	        //2.从allNodes数组中删除
	        for (var i = 0; i < that.allNodes.length; i++) {
	            if (selectedNode.id == that.allNodes[i].id) {
	                that.allNodes.splice(i, 1);
	            }
	        }
	        FlowConnectionManager.deleteSelectCon(selectedNode, that.group);
	    };
	
	    /**
	     * @private
	     * 派发delete事件
	     */
	    fishTopoProto._triggerDeleteEvent = function(target) {
	        var eventParams = {};
	        eventParams.type = "delete";
	        eventParams.target = target;
	        this._api.trigger(eventParams.type, eventParams);
	    };
	
	    /**
	     * @private
	     */
	    fishTopoProto._createConnectorByNodes = function(startNode, endNode, lineType) {
	        var that = this;
	        var connector = FlowConnectionManager.connectorCreate(startNode, endNode, {
	            style: {
	                lineType: lineType
	            }
	        }, this._api);
	        if (startNode.parent && endNode.parent) {
	            endNode.parent.add(connector);
	        } else {
	            this.group.add(connector);
	        }
	
	        connector.on("mousedown", zrUtil.bind(function() {
	            FlowConnectionManager.connectorForbidEdit(!this.options.linkModify);
	            this.isNode = false;
	        }, this));
	        connector.on("dblclick", function() {
	            if (that.options.isAllowEdit) {
	                that.connectorEdit(this);
	            }
	        });
	
	        this._triggerCreateEvent(connector);
	        return connector;
	    };
	
	    /**
	     * @private
	     * 派发创建完成事件
	     */
	    fishTopoProto._triggerCreateEvent = function(target) {
	        var eventParams = {};
	        eventParams.type = "create";
	        eventParams.target = target;
	        this._api.trigger(eventParams.type, eventParams);
	    };
	
	    /**
	     * @private
	     * 鼠标点下 将操作框 移到对应的节点上
	     * @param  {Object} node [description]
	     * @param  {Object} sX   [description]
	     * @param  {Object} sY   [description]
	     * @return {Object}      [description]
	     */
	    fishTopoProto.nodeClickHandler = function(node, sX, sY) {
	        var that = this;
	        var node = node;
	        if (node.noSelected == true) {
	            return;
	        }
	        if (node.fromCmsImage) {
	            node = node.fromCmsImage;
	        }
	        // if(node instanceof GroupNode){
	        //     node = node.childOfName("Rect");
	        // }
	        this.selectedNode = node;
	        var shapeRect = util.getRect(node);
	        if (!this.operationNode) {
	            this.initOperationNode(node);
	        }
	        // 在存在子流程的情况下 需要把node也传递一下
	        this.operationNode.refreshPostion(node, shapeRect);
	    };
	
	    /**
	     * @private
	     * flow中最外层的group移动操作
	     */
	    fishTopoProto.groupDrag = function() {
	        var that = this;
	        that._zr.on("mousedown", function(e) {
	            if ((e.target&&e.target.model) || (e.target && e.target.lineType && e.target.parent)) {
	                return;
	            } else {
	                groupDragFunction(e);
	            }
	        });
	
	        function groupDragFunction(e) {
	            var startX = e.event.clientX;
	            var startY = e.event.clientY;
	            var moveFunction = function(e) {
	                moveDrag(e);
	            };
	            var nowGroupPosition = that.group.position;
	            var groupPositionX = that.group.position[0];
	            var groupPositionY = that.group.position[1];
	
	            function moveDrag(e) {
	                var width = that.group.getBoundingRect().width * that.nowZoom;
	                var height = that.group.getBoundingRect().height * that.nowZoom;
	                var gx = that.group.getBoundingRect().x * that.nowZoom;
	                var gy = that.group.getBoundingRect().y * that.nowZoom;
	                var min = [10 - (width + gx), 10 - (height + gy)];
	                var max = [(that._zr.getWidth() - gx) - 10, (that._zr.getHeight() - gy) - 10];
	                var sX = (e.event.clientX - startX);
	                var sY = (e.event.clientY - startY);
	                nowGroupPosition[0] = groupPositionX + (sX);
	                nowGroupPosition[1] = groupPositionY + (sY);
	                if (nowGroupPosition[0] > max[0] || nowGroupPosition[1] > max[1] || nowGroupPosition[0] < min[0] || nowGroupPosition[1] < min[1]) {
	                    return;
	                } else {
	                    that.group.attr("position", nowGroupPosition);
	                    if (that.eagleEye == true) {
	                        that.minimap.updataSelectionPosition(nowGroupPosition, that.nowZoom);
	                    }
	
	                }
	            }
	
	            that._zr.on('mousemove', moveFunction);
	            var upFunction = function(e) {
	                endDrag(e);
	            };
	
	            function endDrag() {
	                that._zr.off('mousemove', moveFunction);
	                that._zr.off('mouseup', upFunction);
	                that._zr.off("globalout", upFunction);
	            }
	
	            that._zr.on('mouseup', upFunction);
	            that._zr.on("globalout", upFunction);
	        }
	    };
	
	    /**
	     * @private
	     * 节点的移动操作
	     */
	    fishTopoProto.drag = function(node) {
	        var that = this;
	        node.on("mousedown", function(e) {
	            if (this.isdraggable == false) {
	                return;
	            }
	            groupDragFunction(e);
	            e.cancelBubble = true;
	        });
	
	        function groupDragFunction(e) {
	            var isMove = 0;
	            node.startX = e.event.clientX;
	            node.startY = e.event.clientY;
	            var moveFunction = function(e) {
	                moveDrag(e);
	            };
	            var nowGroupPosition = node.position;
	            var groupPositionX = node.position[0];
	            var groupPositionY = node.position[1];
	
	            function moveDrag(e) {
	                e.cancelBubble = true;
	                var sX = (e.event.clientX - node.startX) / (that.nowZoom);
	                var sY = (e.event.clientY - node.startY) / (that.nowZoom);
	                // node.startX = e.event.clientX;
	                // node.startY = e.event.clientY;
	                if (sX > 0 || sY) {
	                    isMove = 1;
	                }
	                // node.drift(sX, sY, e);
	                if (node.parent && node.parent instanceof GroupNode) {
	                    //放入node现有数值，用于重绘group
	                    var nodeMessage = {
	                        width: node.shape.width,
	                        height: node.shape.height,
	                        position: node.position,
	                        nodeXY: [node.shape.x, node.shape.y],
	                        movePosition: [groupPositionX, groupPositionY],
	                        moveX: sX,
	                        moveY: sY
	                    };
	                    var groupNode = node.parent;
	                    groupNode.reDraw(nodeMessage, node);
	                }
	                nowGroupPosition[0] = groupPositionX + sX;
	                nowGroupPosition[1] = groupPositionY + sY;
	                node.attr("position", nowGroupPosition);
	                if (node.alarm) {
	                    var newAlarmPosition = [nowGroupPosition[0] + node.getBoundingRect().width - (node.alarm.getBoundingRect().width - 6), nowGroupPosition[1] - node.alarm.getBoundingRect().height - 3];
	                    node.alarm.attr("position", newAlarmPosition);
	                }
	                if (node.cmsImage) {
	                    var newAlarmPosition1 = [nowGroupPosition[0], nowGroupPosition[1] - 8];
	                    node.cmsImage.attr("position", newAlarmPosition1);
	                }
	                if (node.fromCmsImage) {
	                    var newAlarmPosition2 = [nowGroupPosition[0], nowGroupPosition[1] + 8];
	                    node.fromCmsImage.attr("position", newAlarmPosition2);
	                }
	                that.nodeClickHandler(node, e.event.clientX, e.event.clientY);
	                FlowConnectionManager.refreshLineByNode(node);
	                if (node.fromCmsImage) {
	                    FlowConnectionManager.refreshLineByNode(node.fromCmsImage);
	                }
	                // if(that.eagleEye == true){
	                //     that.openEagleEye(that.eagleEyeNode);
	                // }
	            }
	
	            that._zr.on('mousemove', moveFunction);
	            var upFunction = function(e) {
	                endDrag(e);
	            };
	            //拖拽结束
	            function endDrag() {
	                if (node.model) {
	                    node.model.set("options.position", node.position);
	                }
	
	                that._zr.off('mousemove', moveFunction);
	                that._zr.off('mouseup', upFunction);
	                that._zr.off("globalout", upFunction);
	                //布局重新计算
	                if (node.layout) {
	                    that.layoutNode("tree", {
	                        "node": node,
	                        "type":node.treeType
	                    });
	                }
	                if (that.forceLayoutOption && (!that.forceLayoutOption.once)) {
	                    var nodes = that.forceLayoutOption.allNodes;
	                    if (zrUtil.indexOf(nodes, node) != -1) {
	                        that.layoutNode("force", this.forceLayoutOption);
	                    }
	                }
	                if (isMove == 1) {
	                    if (that.eagleEye == true) {
	                        that.openEagleEye(that.eagleEyeNode);
	                    }
	                }
	
	            }
	
	            that._zr.on('mouseup', upFunction);
	            that._zr.on("globalout", upFunction);
	        }
	    };
	
	    /**
	     * 创建节点
	     * @param  {String} type 类型 eg. 'Rect'、'Circle'、'Image'、'Group'、'Text'等
	     * @param  {Object} opt 节点选项
	     * @param {Array}  [opt.position] 节点的位置 eg. [x,y]
	     * @param {Object} [opt.style] 节点的样式
	     * @param {String} [opt.style.text] 节点下方（默认）显示的文字
	     * @param {String} [opt.style.fill] 节点的填充颜色值 eg. '#157cff'  'rgb(122,122,122)'
	     * @param {String} [opt.style.stroke] 节点的描边颜色值 eg. '#157cff'  'rgb(122,122,122)'
	     * @param {String} [opt.style.textFont] 设置文字的字体信息 eg. '14px Microsoft YaHei'
	     * @param {String} [opt.style.textFill] 设置文字的颜色值 eg. '#ffffff'
	     * @param {String} [opt.style.textPosition] 设置文字在节点中的位置 eg. 'top','right','bottom', 'left','inside'
	     * @param {String} [opt.mergedImage] 组合并后显示的图片（组特有的属性）
	     * @param {Object} [opt.layout] 节点tree布局属性（tree布局的节点才需要）
	     * @param {Number} [opt.layout.width] 结点的子节点之间的距离
	     * @param {Number} [opt.layout.height] 结点的子节点到结点的距离
	     * @param {Object} [opt.shape] 每种形状的值不一样 eg. 'Rect' shape:{width:100,height:100}
	     * @param {Array}  [opt.operationIcons] 设置选中节点时 显示的操作小图标， 默认提供了 删除(删除支持自定义回调方法)、直线、折线、曲线4种图标，也可以自定图标 eg.
	     * <pre>
	     *          operationIcons: [{ name: 'DEL' },
	     *              { name: 'STRAIGHT' },
	     *              { name: 'JAGGED' },
	     *              { name: 'CURVE' },
	     *              {
	     *                  name: "custom1",
	     *                  iconPath: "img/host.png",
	     *                  callback: function(e) { alert(e.data.name + " clicked") }  //e.node是当前的节点
	     *              }
	     *          ]
	     * </pre>
	     * @param {Object} userData 用户传递的业务数据
	     * @return {Object} 创建的节点对象
	     *
	     * **使用范例**：
	     *
	     *      @example
	     *      var rect = this.fishTopo.creatNode("Rect", { //矩形
	     *          shape: {
	     *              width: 100,
	     *              height: 60,
	     *          },
	     *          style: {
	     *              text: "基本矩形",
	     *              fill: "#167CFF",
	     *              stroke: "rgb(255,255,255)",
	     *              textFont: '14px Microsoft YaHei'
	     *          },
	     *          position: [180, 100],
	     *          operationIcons: [{ name: 'DEL' },
	     *              { name: 'STRAIGHT' },
	     *              { name: 'JAGGED' },
	     *              { name: 'CURVE' },
	     *              {
	     *                  name: "custom1",
	     *                  iconPath: "img/host.png",
	     *                  callback: function(e) { alert(e.data.name + " clicked") }  //e.node是当前的节点
	     *              }
	     *          ]
	     *      });
	     */
	    fishTopoProto.creatNode = function(type, opt, userData) {
	        var that = this;
	        //设置模型 给json序列化用
	        var model = new Model({});
	        model.set(Constants.ELEMENT_TYPE, type);
	        model.set(Constants.OPTIONS, zrUtil.clone(opt));
	        model.set(Constants.USERDATA, zrUtil.clone(userData));
	        if ("draggable" in opt) {
	            opt.isdraggable = opt.draggable;
	            delete opt.draggable;
	        }
	
	        if (!opt.z) {
	            opt.z = 1; //节点Z为1 线段为0;
	        }
	        var node = null;
	        //根据参数dom不同创建不同的节点
	        switch (type) {
	            case "Rect":
	                node = new this.Shape.Rect(opt);
	                break;
	            case "Group":
	                node = new GroupNode(opt);
	                if (opt.mergedImage) {
	                    var imageShape = new this.Shape.Image({
	                        style: {
	                            image: opt.mergedImage,
	                            // width: width,
	                            // height: height,
	                            text: opt.style.text,
	                            textPosition: 'bottom'
	                        },
	                        position: [-5000, -5000]
	
	                    });
	                    this.drag(imageShape);
	                    node.relationImage = imageShape;
	                    that.group.add(imageShape);
	                    setTimeout(function() {
	                        imageShape.hide();
	                    }, 300);
	
	                    node.on("dblclick", function(e) {
	                        node.merged(e)
	                    });
	                }
	                break;
	            case "Image":
	                node = new this.Shape.Image(opt);
	                break;
	            case "Text":
	                node = new this.Shape.Text(opt);
	                break;
	            case "Circle":
	                node = new this.Shape.Circle(opt);
	                break;
	            case "Sector":
	                node = new this.Shape.Sector(opt);
	                break;
	            case "Ring":
	                node = new this.Shape.Ring(opt);
	                break;
	            case "Polygon":
	                node = new this.Shape.Polygon(opt);
	                break;
	            case "Polyline":
	                node = new this.Shape.Polyline(opt);
	                break;
	            case "Line":
	                node = new this.Shape.Line(opt);
	                break;
	            case "BezierCurve":
	                node = new this.Shape.BezierCurve(opt);
	                break;
	            case "Arc":
	                node = new this.Shape.Arc(opt);
	                break;
	        }
	        this.drag(node);
	
	        node.attr("operationIcons", opt.operationIcons);
	
	        //侦听节点的click dblclick事件，选中，并派发出去
	        node.on('click', function(e) {
	            var nowNode;
	            if (node.fromCmsImage) {
	                nowNode = node.fromCmsImage;
	            } else {
	                nowNode = this;
	            }
	            that.nodeClickHandler(nowNode, e.event.clientX, e.event.clientY);
	
	            var params = {};
	            params.event = e;
	            params.type = 'click';
	            params.target = nowNode;
	            that._api.trigger(params.type, params);
	
	            e.cancelBubble = true;
	        });
	        node.on('dblclick', function(e) {
	            var nowNode;
	            if (node.fromCmsImage) {
	                nowNode = node.fromCmsImage;
	            } else {
	                nowNode = this;
	            }
	            if (typeof nowNode.style.isAllowEdit == "undefined") {
	                if (that.options.isAllowEdit) {
	                    that.nodeEdit(nowNode);
	                }
	            } else {
	                if (nowNode.style.isAllowEdit) {
	                    that.nodeEdit(nowNode);
	                }
	            }
	            var params = {};
	            params.event = e;
	            params.type = 'dblclick';
	            params.target = node;
	            that._api.trigger(params.type, params);
	
	            e.cancelBubble = true;
	        });
	
	        this.allNodes.push(node);
	        if (opt.id) {
	            model.set(Constants.ID, opt.id);
	        } else {
	            model.set(Constants.ID, util.getUUID());
	        }
	
	        node.model = model;
	
	        this._triggerCreateEvent(node);
	        return node;
	    };
	
	    /**
	     * 根据name获取节点
	     * @param  {String} name 在创建节点中  name属性设置的值
	     * @return {Object}      name对应的节点
	     */
	    fishTopoProto.childOfName = function(name) {
	        var arrResult = [];
	        var childrenNode = this.allNodes;
	        var childrenLine = FlowConnectionManager.connectors;
	        for (var i = 0; i < childrenNode.length; i++) {
	            if (childrenNode[i].model.get("options.name") && childrenNode[i].model.get("options.name") == name) {
	                arrResult.push(childrenNode[i]);
	            } else if (childrenNode[i].model.get("userData.name") == name) {
	                arrResult.push(childrenNode[i]);
	            }
	        }
	        for (var j = 0; j < childrenLine.length; j++) {
	            if (childrenLine[j].model.get("options.name") && childrenLine[j].model.get("options.name") == name) {
	                arrResult.push(childrenLine[j]);
	            } else if (childrenLine[j].model.get("userData.name") == name) {
	                arrResult.push(childrenLine[j]);
	            }
	        }
	        if (arrResult.length > 1) {
	            return arrResult;
	        } else {
	            return arrResult[0];
	        }
	    };
	
	    /**
	     * 查找场景中的对象   例如: x坐标大于100的节点 findElements(function(e){ return e.position[0] > 100; });
	     * @param  {Function} cb      回调函数
	     * @param  {Object}   context 回调函数执行的上下文
	     * @return {Array}           返回查找到的对象
	     */
	    fishTopoProto.findElements = function(cb, context) {
	        var childrenNode = this.allNodes;
	        var childrenLine = FlowConnectionManager.connectors;
	        var arr = [];
	        for (var i = 0; i < childrenNode.length; i++) {
	            var child = childrenNode[i];
	            if (cb.call(context, child, i)) {
	                arr.push(child);
	            }
	        }
	        for (var j = 0; j < childrenLine.length; j++) {
	            var childL = childrenLine[j];
	            if (cb.call(context, childL, j)) {
	                arr.push(childL);
	            }
	        }
	        return arr;
	    };
	
	    /**
	     * 设置背景色  或 背景图片
	     * @param {string} imageUrl 背景色  或 背景图片 eg. 'img/bg.jpg'
	     */
	    fishTopoProto.setBackground = function(imageUrl) {
	        var that = this;
	        if (imageUrl && imageUrl.length > 0) {
	            this.model.set(Constants.BACKGROUND, imageUrl);
	            if (imageUrl.substr(0, 1) == "#" || imageUrl.substr(0, 4) == "rgba") { //如果是颜色创建rect为背景
	                if (!document.createElement('canvas').getContext) {
	                    that._dom.style.backgroundColor = imageUrl;
	                } else {
	                    var imageShape = new this.Shape.Rect({
	                        shape: {
	                            width: that._zr.getWidth(),
	                            height: that._zr.getHeight()
	                        },
	                        style: {
	                            fill: imageUrl
	                        },
	                        cursor: 'default',
	                        z: -1
	                    });
	                    that._zr.add(imageShape);
	                }
	
	            } else {
	                if (!document.createElement('canvas').getContext) {
	                    that._dom.style.backgroundImage = "url(" + imageUrl + ")";
	                    that._dom.style.backgroundRepeat = "repeat";
	                } else {
	                    var imageShape1 = new this.Shape.Image({ //如果是图片创建image为背景
	                        position: [0, 0],
	                        scale: [1, 1],
	                        style: {
	                            x: 0,
	                            y: 0,
	                            image: imageUrl,
	                            width: this._zr.getWidth(),
	                            height: this._zr.getHeight()
	                        },
	                        cursor: 'default',
	                        z: -1
	                    });
	                    that._zr.add(imageShape1);
	                }
	
	            }
	
	        }
	
	    };
	
	    /**
	     * 创建线段
	     * @method creatLink
	     * @param  {Object} startNode 开始节点
	     * @param  {Object} endNode   结束节点
	     * @param  {Object} options 线段选项
	     * @param {Object} [options.style] 节点的样式
	     * @param {Number} [options.style.lineWidth=1] 线段的宽度
	     * @param {String} [options.style.lineType='straight'] 线段的类型 eg. 'straight', 'jagged','curve'
	     * @param {String} [options.style.stroke="#000000"] 线段的颜色值 eg. '#157cff'  'rgb(122,122,122)'
	     * @param {Array}  [options.style.lineDash] 虚线的间隔 eg. [3,3]
	     * @param {Object} [options.symbol] 线段的箭头
	     * @param {String} [options.symbol.type='arrow'] 线段的箭头的类型 可选值为： 'circle', 'rect', 'roundRect', 'triangle', 'diamond', 'pin', 'arrow'
	     * @param {Number} [options.symbol.size=10] 线段的箭头的尺寸
	     * @param {String} [options.symbol.color='#000000'] 线段的箭头的颜色
	     * @param {Object} [options.text] 线段上的文字
	     * @param {String} [options.text.text] 线段上的文字内容
	     * @param {String} [options.text.color] 线段上的文字颜色
	     * @param {String} [options.text.textPos] 文字位置可选值 'start','center','end',默认值为center
	     * @param {String} [options.text.xOffset] 文字位置x偏移量
	     * @param {String} [options.pos] 指定线段起始与终止 在节点的什么位置 默认值为'left,right'  可取值四个方向top,bottom,left,right 方向可加偏移量如如 "left+10,top"
	     * @param {String} [options.position] 指定线段位置
	     * @param {Object} [options.effect] 线上动态效果
	     * @param {String} [options.effect.show] 是否显示箭头动效
	     * @param {Number} [options.effect.period] 动效移动速度
	     * @param {String} [options.position.escapeDistance] 指定线段第一条折线的长度，最后一条折线的长度
	     * @param {String} [options.position.points] 不使用自动计算 指定连线的折点位置数组
	     * @param {Object} userData 用户传递的业务数据
	     * @return {Object} 创建的线段对象
	     *
	     * **使用范例**：
	     *
	     *      @example
	     *      var link = me.fishTopo.creatLink(startNode, endNode, {
	     *              symbol: { type: 'arrow', size: 10, color: "rgb(0,200,255)" }, //箭头  可选值为： 'circle', 'rect', 'roundRect', 'triangle', 'diamond', 'pin', 'arrow'
	     *              style: { lineWidth: 3, stroke: "rgb(0,200,255)", lineDash: [3,3], lineType: "jagged"  }, //样式
	     *              text: {
	     *                  text: text,
	     *                  color: '#ffffff',
	     *                  textPos:textPos,//文字位置可选值 'start','center','end',默认值为center
	     *                  xOffset:10, //文字位置x偏移量
	     *              },
	     *              pos:'right,left',
	     *              effect: {
	                        show: true,//是否显示箭头动效
	                        period: 6,//箭头速度
	                    },
	     *              position:{
	     *                    escapeDistance:[50,30],  //第一条折线的长度，最后一条折线的长度
	     *                    points:["x1,y1","x2,y2"]  不使用自动计算 指定连线的位置数组
	     *              }
	     *          });
	     */
	    fishTopoProto.creatLink = function(startNode, endNode, options, userData) {
	        var that = this;
	        options.isEdit = !!this.options.linkModify;
	        var connector = FlowConnectionManager.connectorCreate(startNode, endNode, options, this._api);
	        connector.model.set(Constants.USERDATA, zrUtil.clone(userData));
	        connector.on("dblclick", function() {
	            if (typeof this.options.text.isAllowEdit == "undefined") {
	                if (that.options.isAllowEdit) {
	                    that.connectorEdit(this);
	                }
	            } else {
	                if (this.options.text.isAllowEdit) {
	                    that.connectorEdit(this);
	                }
	            }
	
	            // if(this.style.isAllowEdit){
	            //     that.connectorEdit(this);
	            // }else if(that.options.isAllowEdit){
	            //     that.connectorEdit(this);
	            // }
	            // if(this.style.isAllowEdit ? this.style.isAllowEdit : that.options.isAllowEdit){
	            //     that.connectorEdit(this);
	            // }
	        });
	        return connector;
	    };
	
	    /**
	     * @private
	     * 线上文字编辑
	     */
	    fishTopoProto.connectorEdit = function(thisConnector) {
	        var that = this;
	        var lineText = thisConnector.childOfName('lineText');
	        if (!lineText) {
	            return;
	        }
	        var textarea = that.creatTextArea();
	        textarea.style.width = 1.1 * util.getRect(lineText).width * that.nowZoom + "px";
	        textarea.style.height = (util.getRect(lineText).height || 12) * that.nowZoom + "px";
	        textarea.innerHTML = lineText.style.text;
	        that._dom.appendChild(textarea);
	        that._dom.style.position = "relative";
	        var textRect = textContain.getBoundingRect(lineText.style.text, lineText.style.textFont);
	        textarea.style.lineHeight = (textRect.lineHeight || 14) + "px";
	        textarea.style.top = (lineText.position[1] - util.getRect(lineText).height) * that.nowZoom + that.group.position[1] + "px";
	        textarea.style.left = (lineText.position[0] - 0.05 * util.getRect(lineText).width) * that.nowZoom + that.group.position[0] + "px";
	        textarea.focus();
	        $(textarea).on("keyup", zrUtil.bind(function(e) {
	            var textRect = textContain.getBoundingRect(lineText.style.text, lineText.style.textFont);
	            that.textareaResize(textRect, textarea, e);
	        }, this));
	        $(textarea).on("focusout", zrUtil.bind(function() {
	            if (textarea.value !== lineText.style.text) {
	                thisConnector.setStyle({
	                    text: {
	                        text: textarea.value || ""
	                    }
	                })
	            }
	            textarea.remove();
	        }, this))
	    };
	    /**
	     * @private
	     * 节点上文字编辑
	     */
	    fishTopoProto.nodeEdit = function(thisNode) {
	        var that = this;
	        var textarea = that.creatTextArea();
	        var nodeText = thisNode.style.text;
	        var textRect = textContain.getBoundingRect(nodeText, thisNode.style.textFont);
	        textarea.style.width = 1.1 * textRect.width * that.nowZoom + "px";
	        textarea.style.height = (textRect.height||12) * that.nowZoom + "px";
	        var nodeRect = util.getRect(thisNode);
	        textarea.style.maxWidth = 1.1*nodeRect.width * that.nowZoom + "px";
	        textarea.style.lineHeight = (textRect.lineHeight || 12) + "px";
	        textarea.innerHTML = thisNode.style.text;
	        that._dom.appendChild(textarea);
	        that._dom.style.position = "relative";
	        var offestI = 1;
	        if (thisNode.style.textAlign == "left") {
	            offestI = 0;
	        }
	        if (thisNode.style.textAlign == "right") {
	            offestI = 2;
	        }
	        textarea.style.top = (nodeRect.y - textRect.height / 2) * that.nowZoom + that.group.position[1] + "px";
	        textarea.style.left = (nodeRect.x - offestI * textRect.width / 2 - 0.05 * textRect.width) * that.nowZoom + that.group.position[0] + "px";
	        textarea.focus();
	        $(textarea).on("keyup", zrUtil.bind(function(e) {
	            var textRect = textContain.getBoundingRect(textarea.value, thisNode.style.textFont);
	            that.textareaResize(textRect, textarea, e);
	        }, this))
	        $(textarea).on("focusout", zrUtil.bind(function() {
	            if (textarea.value !== nodeText) {
	                var text = that.handleWrap(textarea.value, textarea.style.maxWidth);
	                thisNode.attr("style", {
	                    text: text
	                })
	                thisNode.model.set("options.style.text",text)
	            }
	            ;
	            textarea.remove();
	        }, this))
	    };
	
	    /**
	     * @private
	     * 创建文本域
	     */
	    fishTopoProto.creatTextArea = function() {
	        var textarea = document.createElement("textarea");
	        textarea.style.position = "absolute";
	        textarea.style.overflow = "hidden";
	        textarea.style.border = "0";
	        textarea.style.padding = "0";
	        textarea.style.resize = "none";
	        return textarea;
	    };
	
	    /**
	     * @private
	     * 处理textarea自动换行
	     */
	    fishTopoProto.handleWrap = function(value, width) {
	        var spanNode = document.createElement("span");
	        spanNode.id = "spanNodeId";
	        spanNode.style.position = "absolute";
	        spanNode.style.overflow = "hidden";
	        spanNode.style.border = "0";
	        spanNode.style.padding = "0";
	        this._dom.appendChild(spanNode);
	        var content = value.split("\n");
	        var result = "";
	        $.each(content, function(i, val) {
	            var valLength = val.length;
	            if (valLength == 0) {
	                //result += "\n";
	            } else {
	                var pre = "",
	                    innerVal, tempWidth, conWidth;
	                for (var innerI = 0; innerI < valLength; innerI++) {
	                    innerVal = val.charAt(innerI);
	                    $("#spanNodeId").text($("#spanNodeId").text() + innerVal);
	                    tempWidth = $("#spanNodeId").width(); //获取添加字符后隐藏域的宽度
	                    conWidth = Number(width.substring(0, width.length - 2));
	                    if (tempWidth > conWidth) {
	                        result += pre; //如果追加字符后隐藏域宽度大于TextArea宽度，则表明该字符为下一行字符，
	                        result += "\n";
	                        $("#spanNodeId").text(innerVal);
	                        pre = innerVal;
	                    } else if (innerI == valLength - 1) {
	                        result += pre + innerVal; //最后一个字符
	                        result += "\n";
	                        $("#spanNodeId").text("");
	                        pre = "";
	                    } else {
	                        pre += innerVal; //依次追加到pre变量中
	                    }
	
	                }
	            }
	        });
	        this._dom.removeChild(spanNode);
	        return result;
	    };
	
	    /**
	     * @private
	     * 文本域自适应高宽
	     */
	    fishTopoProto.textareaResize = function(textRect, textarea) {
	        var that = this;
	        textarea.style.width = 0;
	        textarea.style.width = (1.1 * textRect.width) * that.nowZoom + "px";
	        if (textRect.width <= 0) {
	            textarea.style.width = "12px";
	        }
	        textarea.style.height = "0px";
	        textarea.style.height = textarea.scrollHeight + 'px';
	        if (textarea.scrollHeight <= 0) {
	            textarea.style.height = "12px";
	        }
	    }
	
	    /**
	     * 创建节点上面的警告
	     * @method creatAlarm
	     * @param  {Object} node 节点
	     * @param  {Object} opt  选项值
	     * @param  {Object} [opt.text] 警告的文字
	     * @param  {Object} [opt.textFont] 警告的文字的字体
	     * @param  {Object} [opt.textFill] 警告的文字的颜色
	     * @param  {Object} [opt.textBackground] 警告的背景的颜色
	     * @return {Object} 返回节点上的警告
	     *
	     * **使用范例**：
	     *
	     *      @example
	     *          this.fishTopo.creatAlarm(s1,{
	     *          text:"2 W",
	     *          textFont:"4px Microsoft YaHei",
	     *          textFill:"#FFFFFF",
	     *          textBackground:"rgba(255,0,0,0.6)"
	     *      });//创建小图片和节点绑定
	     */
	    fishTopoProto.creatAlarm = function(node, opt) {
	        var group = this.creatNode("Group", {
	            style: {
	                fill: 'rgba(0,0,0,0)',
	                stroke: 'rgba(0,0,0,0)'
	            }
	        });
	        group.isdraggable = false;
	        var text = this.creatNode("Text", { //文字
	            style: {
	                text: opt.text,
	                textFont: opt.textFont,
	                fill: opt.textFill,
	                textBaseline: "top" //垂直对齐,
	            },
	            noSelected: true,
	            position: [2, 0],
	            z: 2
	        });
	        text.isdraggable = false;
	        group.add(text);
	        if (node.parent && node.parent instanceof GroupNode) {
	            node.parent.add(group);
	        } else {
	            this.group.add(group);
	        }
	        var groupWidth = group.getBoundingRect().width + 2;
	        var groupHeight = group.getBoundingRect().height + 6;
	        var points = [
	            [0, 0],
	            [groupWidth, 0],
	            [groupWidth, groupHeight],
	            [groupWidth - 3, groupHeight],
	            [groupWidth - 6, groupHeight + 3],
	            [groupWidth - 9, groupHeight],
	            [0, groupHeight],
	            [0, 0]
	        ];
	        var Polyline = this.creatNode("Polyline", {
	            shape: {
	                points: points
	            },
	            style: {
	                fill: opt.textBackground,
	                stroke: opt.textBackground
	            },
	            noSelected: true,
	            z: 1
	        });
	        Polyline.isdraggable = false;
	        group.add(Polyline);
	        var groupPosition = [node.position[0] + node.getBoundingRect().width - (group.getBoundingRect().width - 6), node.position[1] - group.getBoundingRect().height - 3];
	        group.attr("position", groupPosition);
	        node.alarm = group;
	        //设置模型 给json序列化用
	        var model = new Model({});
	        model.set(Constants.ELEMENT_TYPE, Constants.ALARM);
	        model.set(Constants.OPTIONS, zrUtil.clone(opt));
	        model.set(Constants.RELATIONID, node.model.get(Constants.ID));
	        group.model = model;
	        return group;
	    };
	
	    /**
	     * 创建Cms节点
	     * @method creatCmsRect
	     * @param  {Object} node 节点
	     */
	    fishTopoProto.creatCmsRect = function(node) {
	        var that = this;
	        //node.noSelected = true;
	        var width, height;
	        if (node.style) {
	            width = node.style.width || 40;
	            height = node.style.height || 48;
	        } else {
	            width = node.options.style.width || 40;
	            height = node.options.style.height || 48;
	        }
	        var rect = this.creatNode("Rect", { //矩形
	            shape: {
	                width: 100 + width,
	                height: height - 8,
	                r: 5
	            },
	            style: {
	                isAllowEdit: true,
	                text: node.model.get("options.style.text"),
	                fill: "#FFFFFF",
	                textFont: node.model.get("options.style.textFont") || '14px Microsoft YaHei',
	                textAlign: "left"
	            },
	            z: 1,
	            position: [node.position[0], node.position[1] + 8],
	            draggable: node.draggable, //禁止拖动
	            operationIcons: node.operationIcons
	        });
	        var nodeText = node.childOfName('Rect');
	        nodeText.attr("style", {
	            "text": ""
	        });
	        node.attr("z", 2);
	        node.attr("draggable", false);
	        node.operationIcons = null;
	        this.addNode(rect);
	        rect.cmsImage = node;
	        node.fromCmsImage = rect;
	        node._children[1].fromCmsImage = rect;
	    };
	
	    /**
	     * 自动布局
	     * @param  {String} type 节点
	     * @param  {Object} option 选项
	     * @param  {Object} [option.node] tree布局为起点的节点（只有tree布局有）
	     * @param  {String} [option.type] tree布局的类型，horizontal为横向，vertical为竖向，默认为vertical
	     * @param  {Number} [option.repulsion] 力导向布局的类型，节点之间的斥力因子。该值越大节点之间的斥力越大，两个节点间的距离也会越远，默认为100
	     * @param  {Number} [option.gravity] 力导向布局的类型，节点受到的向中心的引力因子。该值越大节点越往中心点靠拢。默认为0.1
	     * @param  {Number} [option.gravity] 力导向布局的类型，边的两个节点之间的距离，这个距离也会受 repulsion。 默认为30
	     * @param  {Number} [option.width] 力导向布局的类型, 布局画布的宽度 默认为整个画布的宽度
	     * @param  {Number} [option.height] 力导向布局的类型, 布局画布的高度 默认为整个画布的高度
	     * @param  {Boolean} [option.once] 只执行一次布局，移动节点不自动布局，默认为false（只有力导向布局有）
	     */
	    fishTopoProto.layoutNode = function(type, option) {
	        if (type == "tree") {
	            if (option.node.parent && option.node.parent instanceof GroupNode) {
	                option.node.parent.eachChild(function(child) {
	                    child.isdraggable = false;
	                });
	            }
	            this.treeLayout(option);
	        } else if (type == "force") {
	            var defaultOptions = {
	                allNodes: this.allNodes,
	                allCons: FlowConnectionManager.connectors,
	                repulsion: 100,
	                gravity: 0.1,
	                edgeLength: 30,
	                once: false,
	                width: this.getWidth(),
	                height: this.getHeight(),
	                forceLayout: null,
	                preservedPoints: {}
	            };
	
	            this.forceLayoutOption = zrUtil.defaults(defaultOptions, option, true);
	            this.forceLayoutOption.rect = new graphic.BoundingRect(0, 0, this.forceLayoutOption.width, this.forceLayoutOption.height);
	
	            this.forceInstance(this.forceLayoutOption);
	
	            this.startForceLayoutIteration(this.forceLayoutOption.forceLayout, true);
	
	        }
	
	    };
	
	    /**
	     * 开始进行力导向迭代
	     * @param  {Object} forceLayout     [力导向对象]
	     * @param  {Boolean} layoutAnimation [是否动画]
	     * @return {void}
	     */
	    fishTopoProto.startForceLayoutIteration = function(forceLayout, layoutAnimation) {
	        var self = this;
	        (function step() {
	            forceLayout.step(function (stopped) {
	                self._layouting = !stopped;
	                if (self._layouting) {
	                    if (layoutAnimation) {
	                        self._layoutTimeout = setTimeout(step, 16)
	                    } else {
	                        step();
	                    }
	                }
	            })
	        })();
	    };
	    /**
	     * @private
	     * 返回当前画布的数据
	     */
	    fishTopoProto.toDataURL = function(opts) {
	        return FlowUtil.toDataURL(this._zr, opts);
	    };
	
	    /**
	     * @private
	     * 初始化缩放
	     */
	    fishTopoProto.initScale = function() {
	        var that = this;
	        var groupMaxWidth = that.group.getBoundingRect().width;
	        var groupMaxHeight = that.group.getBoundingRect().height;
	        var rangeWidth = that.getWidth();
	        var rangeHeight = that.getHeight();
	        var initRatio = 1,
	            pos = [];
	        if (groupMaxWidth / groupMaxHeight > rangeWidth / rangeHeight) {
	            if (groupMaxWidth > rangeWidth) {
	                initRatio = rangeWidth / groupMaxWidth;
	            }
	        } else {
	            if (groupMaxHeight > rangeHeight) {
	                initRatio = rangeHeight / groupMaxHeight;
	            }
	        }
	        pos[0] = Math.abs(that.group.getBoundingRect().x) * initRatio;
	        pos[1] = Math.abs(that.group.getBoundingRect().y) * initRatio;
	        that.group.attr("position", [pos[0], pos[1]]);
	        that.group.attr("scale", [initRatio, initRatio]);
	        that.initScaleRatio = initRatio;
	        var distance = [pos[0], pos[1], that.initScaleRatio, groupMaxWidth, groupMaxHeight];
	        return distance;
	    };
	
	    /**
	     * 放大或者缩小
	     * @param  {String|Number} type 当为字符串时 "enlarge"放大  "narrowing"缩小  当为数值时 缩放的比例  建议0.3-1.7
	     */
	    fishTopoProto.zrScale = function(type) {
	        if (type) {
	            if (type == "narrowing") {
	                var zoomDelta1 = -0.07;
	                this.zoom(zoomDelta1, this._zr.getWidth() / 2, this._zr.getHeight() / 2);
	            }
	            if (type == "enlarge") {
	                var zoomDelta = 0.07;
	                this.zoom(zoomDelta, this._zr.getWidth() / 2, this._zr.getHeight() / 2);
	            }
	            if (!isNaN(type)) {
	                var target = this.group;
	                if (target) {
	                    var zoomScale = type;
	                    this._zoom = type;
	                    this.nowZoom = type;
	                    this.setScale(this._zr.getWidth() / 2, this._zr.getHeight() / 2, zoomScale);
	                }
	            }
	        } else {
	            this._zr.on('mousewheel', zrUtil.bind(function(e) {
	                eventTool.stop(e.event);
	                var zoomDelta = e.wheelDelta > 0 ? 0.07 : -0.07;
	                this.zoom(zoomDelta, this._zr.getWidth() / 2, this._zr.getHeight() / 2);
	            }, this));
	        }
	    };
	
	    /**
	     * @private
	     */
	    fishTopoProto.zoom = function(zoomDelta, zoomX, zoomY) {
	        if (this.canScale == false) {
	            return;
	        }
	        var target = this.group;
	        if (target) {
	
	            var newZoom = this._zoom = this._zoom || 1;
	            newZoom += zoomDelta;
	
	            newZoom = Number(newZoom.toFixed(2));
	            var zoomScale = newZoom / this._zoom;
	            if (newZoom > 1.7 || newZoom < 0.3) {
	                return;
	            }
	            this._zoom = newZoom;
	
	            this.nowZoom = newZoom;
	            this.setScale(zoomX, zoomY, zoomScale);
	        }
	    };
	
	    /**
	     * @private
	     */
	    fishTopoProto.setScale = function(zoomX, zoomY, zoomScale) {
	        var target = this.group;
	        var pos = target.position;
	        var scale = target.scale;
	        // Keep the mouse center when scaling
	        pos[0] -= (zoomX - pos[0]) * (zoomScale - 1);
	        pos[1] -= (zoomY - pos[1]) * (zoomScale - 1);
	        scale[0] *= zoomScale;
	        scale[1] *= zoomScale;
	        target.attr("position", [pos[0], pos[1]]);
	        target.attr("scale", [scale[0], scale[1]]);
	        if (this.eagleEye == true) {
	            this.minimap.updataSelection(pos[0], pos[1], zoomScale, this.nowZoom);
	        }
	    };
	
	    /**
	     * 鹰眼图
	     * @param  {HTMLElement} eagleEyeNode 显示鹰眼图的div元素
	     */
	    fishTopoProto.openEagleEye = function(eagleEyeNode) {
	        var that = this;
	        this.eagleEye = true;
	        this.eagleEyeNode = eagleEyeNode;
	        var groupPosition = zrUtil.clone(this.group.position);
	        var groupScale = zrUtil.clone(this.group.scale);
	        this.group.attr("position", [0, 0]);
	        this.group.attr("scale", [1, 1]);
	        var distance = this.initScale();
	        var imgSrc = this.toDataURL();
	        this.group.attr("position", groupPosition);
	        this.group.attr("scale", groupScale);
	        if (this.minimap) {
	            this.minimap.updataMap(imgSrc, this.group.getBoundingRect());
	        } else {
	            this.minimap = new Minimap(this, this.group.position, this.group.getBoundingRect(), eagleEyeNode, distance, imgSrc);
	            setTimeout(zrUtil.bind(function() {
	                this.openEagleEye(that.eagleEyeNode)
	            }, this), 10);
	        }
	        that.minimap.selection.addEventListener("mousedown", function(e) {
	            var startX = e.clientX;
	            var startY = e.clientY;
	            var minimapLeft = Number(that.minimap.selection.style.left.substring(0, that.minimap.selection.style.left.length - 2));
	            var minimapTop = Number(that.minimap.selection.style.top.substring(0, that.minimap.selection.style.top.length - 2));
	            var moveFunction = function(e) {
	                eagleEyeMove(e);
	            };
	
	            function eagleEyeMove(e) {
	                var offsetX = e.clientX - startX;
	                var offsetY = e.clientY - startY;
	                that.minimap.selection.style.left = minimapLeft + offsetX + "px";
	                that.minimap.selection.style.top = minimapTop + offsetY + "px";
	                that.minimap.updataGroupPosition(that.group, that.nowZoom);
	            }
	
	            that.minimap.selection.addEventListener("mousemove", moveFunction);
	            var upFunction = function(e) {
	                eagleEyeUp(e);
	            };
	
	            function eagleEyeUp() {
	                that.minimap.selection.removeEventListener("mousemove", moveFunction);
	                that.minimap.selection.removeEventListener("mouseup", moveFunction);
	            }
	
	            that.minimap.selection.addEventListener("mouseup", upFunction);
	        })
	
	
	    };
	    zrUtil.mixin(FishTopoFlow, Eventful);
	
	    // ---------对外暴露fishTopoFlow------------------
	    var idBase = new Date() - 0;
	    var instances = {};
	    var DOM_ATTRIBUTE_KEY = '_fishTopoFlow_instance_';
	
	    /**
	     * fishTopoFlow全局对象，如果是amd方式加载，则直接返回
	     * @class fishTopoFlow
	     * @singleton
	     */
	    var fishTopoFlow = {
	        /**
	         * 版本号
	         * @type {String}
	         */
	        version: '1.3.0',
	        dependencies: {
	            zrender: '3.0.4'
	        }
	    };
	
	    /**
	     * 初始化dom元素为 flow对象
	     * @member fishTopoFlow
	     * @param {HTMLElement} dom  一个div元素
	     * @param {Object} opts  传递的选项参数
	     * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg' or 'vml'
	     * @param {number} [opts.devicePixelRatio=1] retina 屏幕优化
	     * @param {number} [opts.linkModify=false] 是否允许调整线段
	     * @return {fish.topo.FishTopoFlow}
	     */
	    fishTopoFlow.init = function(dom, opts) {
	        if (!dom) {
	            throw new Error('Initialize failed: invalid dom.');
	        }
	
	        opts = opts || {};
	        // Default value
	        zrUtil.defaults(opts, {
	            type: "flow",
	            devicePixelRatio: 1,
	            linkModify: false,
	            isAllowEdit: false
	        });
	
	        var fishTopoFlow = new FishTopoFlow(dom, opts);
	        fishTopoFlow.init();
	        fishTopoFlow.Flow = Flow;
	        fishTopoFlow.id = 'ft_' + idBase++;
	        instances[fishTopoFlow.id] = fishTopoFlow;
	
	        dom.setAttribute && dom.setAttribute(DOM_ATTRIBUTE_KEY, fishTopoFlow.id);
	
	        return fishTopoFlow;
	    };
	
	
	    /**
	     * 获取 dom 容器上的实例。
	     * @member fishTopoFlow
	     * @param  {HTMLElement} dom 一个div元素
	     * @return {fish.topo.FishTopoFlow}
	     */
	    fishTopoFlow.getInstanceByDom = function(dom) {
	        var key = dom.getAttribute(DOM_ATTRIBUTE_KEY);
	        return instances[key];
	    };
	
	    /**
	     * 销毁实例，实例销毁后无法再被使用。
	     *
	     * @member fishTopoFlow
	     * @param  {Object|string} chart fishTopoBpmn实例 或 fishTopoBpmn的id
	     */
	    fishTopoFlow.dispose = function(chart) {
	        var topo;
	        if (zrUtil.isDom(chart)) {
	            topo = fishTopoFlow.getInstanceByDom(chart);
	        } else if (typeof chart === 'string') {
	            topo = instances[chart];
	        }
	        if ((topo instanceof fishTopoFlow) && !topo.isDisposed()) {
	            topo.dispose();
	        }
	        clearTimeout(this._layoutTimeout);
	    };
	
	    //暴露出去的类
	    fishTopoFlow.util = {};
	    fishTopoFlow.util['initImagePool'] = ImagePool.initImagePool;
	    zrUtil.each([
	            'map', 'each', 'filter', 'indexOf', 'inherits',
	            'reduce', 'filter', 'bind', 'curry', 'isArray',
	            'isString', 'isObject', 'isFunction', 'extend'
	        ],
	        function(name) {
	            fishTopoFlow.util[name] = zrUtil[name];
	        }
	    );
	
	    module.exports = fishTopoFlow;
	


/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	
	    var zrUtil = __webpack_require__(4);
	
	    var pathTool = __webpack_require__(5);
	    var round = Math.round;
	    var Path = __webpack_require__(6);
	    var colorTool = __webpack_require__(19);
	    var matrix = __webpack_require__(13);
	    var vector = __webpack_require__(14);
	    var Gradient = __webpack_require__(37);
	    var Draggable = __webpack_require__(38);
	
	    var graphic = {};
	    graphic.Util = zrUtil;
	    graphic.Group = __webpack_require__(39);
	
	    graphic.Image = __webpack_require__(40);
	
	    graphic.Text = __webpack_require__(42);
	
	    graphic.textContain = __webpack_require__(23);
	
	    graphic.Circle = __webpack_require__(43);
	
	    graphic.Sector = __webpack_require__(44);
	
	    graphic.Ring = __webpack_require__(45);
	
	    graphic.Polygon = __webpack_require__(46);
	
	    graphic.Polyline = __webpack_require__(50);
	
	    graphic.Rect = __webpack_require__(51);
	
	    graphic.Line = __webpack_require__(53);
	
	    graphic.BezierCurve = __webpack_require__(54);
	
	    graphic.Arc = __webpack_require__(55);
	
	    graphic.LinearGradient = __webpack_require__(56);
	
	    graphic.RadialGradient = __webpack_require__(57);
	
	    graphic.BoundingRect = __webpack_require__(24);
	
	    /**
	     * Extend shape with parameters
	     */
	    graphic.extendShape = function (opts) {
	        return Path.extend(opts);
	    };
	
	    /**
	     * Extend path
	     */
	    graphic.extendPath = function (pathData, opts) {
	        return pathTool.extendFromString(pathData, opts);
	    };
	
	    /**
	     * Create a path element from path data string
	     * @param {string} pathData
	     * @param {Object} opts
	     * @param {module:zrender/core/BoundingRect} rect
	     * @param {string} [layout=cover] 'center' or 'cover'
	     */
	    graphic.makePath = function (pathData, opts, rect, layout) {
	        var path = pathTool.createFromString(pathData, opts);
	        Draggable.call(path);
	        var boundingRect = path.getBoundingRect();
	        if (rect) {
	            var aspect = boundingRect.width / boundingRect.height;
	
	            if (layout === 'center') {
	                // Set rect to center, keep width / height ratio.
	                var width = rect.height * aspect;
	                var height;
	                if (width <= rect.width) {
	                    height = rect.height;
	                }
	                else {
	                    width = rect.width;
	                    height = width / aspect;
	                }
	                var cx = rect.x + rect.width / 2;
	                var cy = rect.y + rect.height / 2;
	
	                rect.x = cx - width / 2;
	                rect.y = cy - height / 2;
	                rect.width = width;
	                rect.height = height;
	            }
	
	            this.resizePath(path, rect);
	        }
	
	        zrUtil.inherits(path, Draggable);
	        return path;
	    };
	
	    graphic.mergePath = pathTool.mergePath;
	
	    /**
	     * Resize a path to fit the rect
	     * @param {module:zrender/graphic/Path} path
	     * @param {Object} rect
	     */
	    graphic.resizePath = function (path, rect) {
	        if (!path.applyTransform) {
	            return;
	        }
	
	        var pathRect = path.getBoundingRect();
	
	        var m = pathRect.calculateTransform(rect);
	
	        path.applyTransform(m);
	    };
	
	    /**
	     * Sub pixel optimize line for canvas
	     *
	     * @param {Object} param
	     * @param {Object} [param.shape]
	     * @param {number} [param.shape.x1]
	     * @param {number} [param.shape.y1]
	     * @param {number} [param.shape.x2]
	     * @param {number} [param.shape.y2]
	     * @param {Object} [param.style]
	     * @param {number} [param.style.lineWidth]
	     * @return {Object} Modified param
	     */
	    graphic.subPixelOptimizeLine = function (param) {
	        var subPixelOptimize = graphic.subPixelOptimize;
	        var shape = param.shape;
	        var lineWidth = param.style.lineWidth;
	
	        if (round(shape.x1 * 2) === round(shape.x2 * 2)) {
	            shape.x1 = shape.x2 = subPixelOptimize(shape.x1, lineWidth, true);
	        }
	        if (round(shape.y1 * 2) === round(shape.y2 * 2)) {
	            shape.y1 = shape.y2 = subPixelOptimize(shape.y1, lineWidth, true);
	        }
	        return param;
	    };
	
	    /**
	     * Sub pixel optimize rect for canvas
	     *
	     * @param {Object} param
	     * @param {Object} [param.shape]
	     * @param {number} [param.shape.x]
	     * @param {number} [param.shape.y]
	     * @param {number} [param.shape.width]
	     * @param {number} [param.shape.height]
	     * @param {Object} [param.style]
	     * @param {number} [param.style.lineWidth]
	     * @return {Object} Modified param
	     */
	    graphic.subPixelOptimizeRect = function (param) {
	        var subPixelOptimize = graphic.subPixelOptimize;
	        var shape = param.shape;
	        var lineWidth = param.style.lineWidth;
	        var originX = shape.x;
	        var originY = shape.y;
	        var originWidth = shape.width;
	        var originHeight = shape.height;
	        shape.x = subPixelOptimize(shape.x, lineWidth, true);
	        shape.y = subPixelOptimize(shape.y, lineWidth, true);
	        shape.width = Math.max(
	            subPixelOptimize(originX + originWidth, lineWidth, false) - shape.x,
	            originWidth === 0 ? 0 : 1
	        );
	        shape.height = Math.max(
	            subPixelOptimize(originY + originHeight, lineWidth, false) - shape.y,
	            originHeight === 0 ? 0 : 1
	        );
	        return param;
	    };
	
	    /**
	     * Sub pixel optimize for canvas
	     *
	     * @param {number} position Coordinate, such as x, y
	     * @param {number} lineWidth Should be nonnegative integer.
	     * @param {boolean=} positiveOrNegative Default false (negative).
	     * @return {number} Optimized position.
	     */
	    graphic.subPixelOptimize = function (position, lineWidth, positiveOrNegative) {
	        // Assure that (position + lineWidth / 2) is near integer edge,
	        // otherwise line will be fuzzy in canvas.
	        var doubledPosition = round(position * 2);
	        return (doubledPosition + round(lineWidth)) % 2 === 0
	            ? doubledPosition / 2
	            : (doubledPosition + (positiveOrNegative ? 1 : -1)) / 2;
	    };
	
	    /**
	     * @private
	     */
	    function doSingleEnterHover(el) {
	        if (el.__isHover) {
	            return;
	        }
	        if (el.__hoverStlDirty) {
	            var stroke = el.style.stroke;
	            var fill = el.style.fill;
	
	            // Create hoverStyle on mouseover
	            var hoverStyle = el.__hoverStl;
	            var lift = colorTool.lift;
	            hoverStyle.fill = hoverStyle.fill
	                || (fill && (fill instanceof Gradient ? fill : lift(fill, -0.1)));
	            hoverStyle.stroke = hoverStyle.stroke
	                || (stroke && (stroke instanceof Gradient ? stroke : lift(stroke, -0.1)));
	
	            var normalStyle = {};
	            for (var name in hoverStyle) {
	                if (hoverStyle.hasOwnProperty(name)) {
	                    normalStyle[name] = el.style[name];
	                }
	            }
	
	            el.__normalStl = normalStyle;
	
	            el.__hoverStlDirty = false;
	        }
	        el.setStyle(el.__hoverStl);
	        el.z2 += 1;
	
	        el.__isHover = true;
	    }
	
	    /**
	     * @inner
	     */
	    function doSingleLeaveHover(el) {
	        if (!el.__isHover) {
	            return;
	        }
	
	        var normalStl = el.__normalStl;
	        normalStl && el.setStyle(normalStl);
	        el.z2 -= 1;
	
	        el.__isHover = false;
	    }
	
	    /**
	     * @inner
	     */
	    function doEnterHover(el) {
	        el.type === 'group'
	            ? el.traverse(function (child) {
	                if (child.type !== 'group') {
	                    doSingleEnterHover(child);
	                }
	            })
	            : doSingleEnterHover(el);
	    }
	    graphic.doEnterHover = doEnterHover;
	    function doLeaveHover(el) {
	        el.type === 'group'
	            ? el.traverse(function (child) {
	                if (child.type !== 'group') {
	                    doSingleLeaveHover(child);
	                }
	            })
	            : doSingleLeaveHover(el);
	    }
	    graphic.doLeaveHover = doLeaveHover;
	    /**
	     * @inner
	     */
	    function setElementHoverStl(el, hoverStl) {
	        // If element has sepcified hoverStyle, then use it instead of given hoverStyle
	        // Often used when item group has a label element and it's hoverStyle is different
	        el.__hoverStl = el.hoverStyle || hoverStl || {};
	        el.__hoverStlDirty = true;
	    }
	    graphic.setElementHoverStl = setElementHoverStl;
	    /**
	     * @inner
	     */
	    function onElementMouseOver() {
	        // Only if element is not in emphasis status
	        !this.__isEmphasis && doEnterHover(this);
	    }
	
	    /**
	     * @inner
	     */
	    function onElementMouseOut() {
	        // Only if element is not in emphasis status
	        !this.__isEmphasis && doLeaveHover(this);
	    }
	
	    /**
	     * @inner
	     */
	    function enterEmphasis() {
	        this.__isEmphasis = true;
	        doEnterHover(this);
	    }
	
	    /**
	     * @inner
	     */
	    function leaveEmphasis() {
	        this.__isEmphasis = false;
	        doLeaveHover(this);
	    }
	
	    /**
	     * Set hover style of element
	     * @param {module:zrender/Element} el
	     * @param {Object} [hoverStyle]
	     */
	    graphic.setHoverStyle = function (el, hoverStyle) {
	        el.type === 'group'
	            ? el.traverse(function (child) {
	                if (child.type !== 'group') {
	                    setElementHoverStl(child, hoverStyle);
	                }
	            })
	            : setElementHoverStl(el, hoverStyle);
	        // Remove previous bound handlers
	        el.on('mouseover', onElementMouseOver)
	          .on('mouseout', onElementMouseOut);
	
	        // Emphasis, normal can be triggered manually
	        el.on('emphasis', enterEmphasis)
	          .on('normal', leaveEmphasis);
	    };
	
	    graphic.setNormalStyle = function(el, options) {
	        if (el.__normalStl) {
	            for (var name in options) {
	                if (el.__normalStl.hasOwnProperty(name)) {
	                    el.__normalStl[name] = options[name];
	                }
	            }
	        }
	    };
	
	    /**
	     * Set text option in the style
	     * @param {Object} textStyle
	     * @param {module:echarts/model/Model} labelModel
	     * @param {string} color
	     */
	    graphic.setText = function (textStyle, labelModel, color) {
	        var labelPosition = labelModel.getShallow('position') || 'inside';
	        var labelColor = labelPosition.indexOf('inside') >= 0 ? 'white' : color;
	        var textStyleModel = labelModel.getModel('textStyle');
	        zrUtil.extend(textStyle, {
	            textDistance: labelModel.getShallow('distance') || 5,
	            textFont: textStyleModel.getFont(),
	            textPosition: labelPosition,
	            textFill: textStyleModel.getTextColor() || labelColor
	        });
	    };
	
	    function animateOrSetProps(isUpdate, el, props, animatableModel, cb) {
	        var postfix = isUpdate ? 'Update' : '';
	        var duration = animatableModel
	            && animatableModel.getShallow('animationDuration' + postfix);
	        var animationEasing = animatableModel
	            && animatableModel.getShallow('animationEasing' + postfix);
	
	        animatableModel && animatableModel.getShallow('animation')
	            ? el.animateTo(props, duration, animationEasing, cb)
	            : (el.attr(props), cb && cb());
	    }
	    /**
	     * Update graphic element properties with or without animation according to the configuration in series
	     * @param {module:zrender/Element} el
	     * @param {Object} props
	     * @param {module:echarts/model/Model} [animatableModel]
	     * @param {Function} cb
	     */
	    graphic.updateProps = zrUtil.curry(animateOrSetProps, true);
	
	    /**
	     * Init graphic element properties with or without animation according to the configuration in series
	     * @param {module:zrender/Element} el
	     * @param {Object} props
	     * @param {module:echarts/model/Model} [animatableModel]
	     * @param {Function} cb
	     */
	    graphic.initProps = zrUtil.curry(animateOrSetProps, false);
	
	    /**
	     * Get transform matrix of target (param target),
	     * in coordinate of its ancestor (param ancestor)
	     *
	     * @param {module:zrender/mixin/Transformable} target
	     * @param {module:zrender/mixin/Transformable} ancestor
	     */
	    graphic.getTransform = function (target, ancestor) {
	        var mat = matrix.identity([]);
	
	        while (target && target !== ancestor) {
	            matrix.mul(mat, target.getLocalTransform(), mat);
	            target = target.parent;
	        }
	
	        return mat;
	    };
	
	    /**
	     * Apply transform to an vertex.
	     * @param {Array.<number>} vertex [x, y]
	     * @param {Array.<number>} transform Transform matrix: like [1, 0, 0, 1, 0, 0]
	     * @param {boolean=} invert Whether use invert matrix.
	     * @return {Array.<number>} [x, y]
	     */
	    graphic.applyTransform = function (vertex, transform, invert) {
	        if (invert) {
	            transform = matrix.invert([], transform);
	        }
	        return vector.applyTransform([], vertex, transform);
	    };
	
	    /**
	     * @param {string} direction 'left' 'right' 'top' 'bottom'
	     * @param {Array.<number>} transform Transform matrix: like [1, 0, 0, 1, 0, 0]
	     * @param {boolean=} invert Whether use invert matrix.
	     * @return {string} Transformed direction. 'left' 'right' 'top' 'bottom'
	     */
	    graphic.transformDirection = function (direction, transform, invert) {
	
	        // Pick a base, ensure that transform result will not be (0, 0).
	        var hBase = (transform[4] === 0 || transform[5] === 0 || transform[0] === 0)
	            ? 1 : Math.abs(2 * transform[4] / transform[0]);
	        var vBase = (transform[4] === 0 || transform[5] === 0 || transform[2] === 0)
	            ? 1 : Math.abs(2 * transform[4] / transform[2]);
	
	        var vertex = [
	            direction === 'left' ? -hBase : direction === 'right' ? hBase : 0,
	            direction === 'top' ? -vBase : direction === 'bottom' ? vBase : 0
	        ];
	
	        vertex = graphic.applyTransform(vertex, transform, invert);
	
	        return Math.abs(vertex[0]) > Math.abs(vertex[1])
	            ? (vertex[0] > 0 ? 'right' : 'left')
	            : (vertex[1] > 0 ? 'bottom' : 'top');
	    };
	
	    module.exports = graphic;
	


/***/ },
/* 4 */
/***/ function(module, exports) {

	/**
	 * @module zrender/core/util
	 */
	
	
	    // 用于处理merge时无法遍历Date等对象的问题
	    var BUILTIN_OBJECT = {
	        '[object Function]': 1,
	        '[object RegExp]': 1,
	        '[object Date]': 1,
	        '[object Error]': 1,
	        '[object CanvasGradient]': 1,
	        '[object CanvasPattern]': 1,
	        // In node-canvas Image can be Canvas.Image
	        '[object Image]': 1
	    };
	
	    var objToString = Object.prototype.toString;
	
	    var arrayProto = Array.prototype;
	    var nativeForEach = arrayProto.forEach;
	    var nativeFilter = arrayProto.filter;
	    var nativeSlice = arrayProto.slice;
	    var nativeMap = arrayProto.map;
	    var nativeReduce = arrayProto.reduce;
	
	    /**
	     * @param {*} source
	     * @return {*} 拷贝后的新对象
	     */
	    function clone(source) {
	        if (typeof source == 'object' && source !== null) {
	            var result = source;
	            if (source instanceof Array) {
	                result = [];
	                for (var i = 0, len = source.length; i < len; i++) {
	                    result[i] = clone(source[i]);
	                }
	            }
	            else if (
	                !isBuildInObject(source)
	                // 是否为 dom 对象
	                && !isDom(source)
	            ) {
	                result = {};
	                for (var key in source) {
	                    if (source.hasOwnProperty(key)) {
	                        result[key] = clone(source[key]);
	                    }
	                }
	            }
	
	            return result;
	        }
	
	        return source;
	    }
	
	    /**
	     * @memberOf module:zrender/core/util
	     * @param {*} target
	     * @param {*} source
	     * @param {boolean} [overwrite=false]
	     */
	    function merge(target, source, overwrite) {
	        // We should escapse that source is string
	        // and enter for ... in ...
	        if (!isObject(source) || !isObject(target)) {
	            return overwrite ? clone(source) : target;
	        }
	
	        for (var key in source) {
	            if (source.hasOwnProperty(key)) {
	                var targetProp = target[key];
	                var sourceProp = source[key];
	
	                if (isObject(sourceProp)
	                    && isObject(targetProp)
	                    && !isArray(sourceProp)
	                    && !isArray(targetProp)
	                    && !isDom(sourceProp)
	                    && !isDom(targetProp)
	                    && !isBuildInObject(sourceProp)
	                    && !isBuildInObject(targetProp)
	                ) {
	                    // 如果需要递归覆盖，就递归调用merge
	                    merge(targetProp, sourceProp, overwrite);
	                }
	                else if (overwrite || !(key in target)) {
	                    // 否则只处理overwrite为true，或者在目标对象中没有此属性的情况
	                    // NOTE，在 target[key] 不存在的时候也是直接覆盖
	                    target[key] = clone(source[key], true);
	                }
	            }
	        }
	
	        return target;
	    }
	
	    /**
	     * @param {Array} targetAndSources The first item is target, and the rests are source.
	     * @param {boolean} [overwrite=false]
	     * @return {*} target
	     */
	    function mergeAll(targetAndSources, overwrite) {
	        var result = targetAndSources[0];
	        for (var i = 1, len = targetAndSources.length; i < len; i++) {
	            result = merge(result, targetAndSources[i], overwrite);
	        }
	        return result;
	    }
	
	    /**
	     * @param {*} target
	     * @param {*} source
	     * @memberOf module:zrender/core/util
	     */
	    function extend(target, source) {
	        for (var key in source) {
	            if (source.hasOwnProperty(key)) {
	                target[key] = source[key];
	            }
	        }
	        return target;
	    }
	
	    /**
	     * @param {*} target
	     * @param {*} source
	     * @param {boolen} [overlay=false]
	     * @memberOf module:zrender/core/util
	     */
	    function defaults(target, source, overlay) {
	        for (var key in source) {
	            if (source.hasOwnProperty(key)
	                && (overlay ? source[key] != null : target[key] == null)
	            ) {
	                target[key] = source[key];
	            }
	        }
	        return target;
	    }
	
	    function createCanvas() {
	        return document.createElement('canvas');
	    }
	    // FIXME
	    var _ctx;
	    function getContext() {
	        if (!_ctx) {
	            // Use util.createCanvas instead of createCanvas
	            // because createCanvas may be overwritten in different environment
	            _ctx = util.createCanvas().getContext('2d');
	        }
	        return _ctx;
	    }
	
	    /**
	     * 查询数组中元素的index
	     * @memberOf module:zrender/core/util
	     */
	    function indexOf(array, value) {
	        if (array) {
	            if (array.indexOf) {
	                return array.indexOf(value);
	            }
	            for (var i = 0, len = array.length; i < len; i++) {
	                if (array[i] === value) {
	                    return i;
	                }
	            }
	        }
	        return -1;
	    }
	
	    /**
	     * 构造类继承关系
	     *
	     * @memberOf module:zrender/core/util
	     * @param {Function} clazz 源类
	     * @param {Function} baseClazz 基类
	     */
	    function inherits(clazz, baseClazz) {
	        var clazzPrototype = clazz.prototype;
	        function F() {}
	        F.prototype = baseClazz.prototype;
	        clazz.prototype = new F();
	
	        for (var prop in clazzPrototype) {
	            clazz.prototype[prop] = clazzPrototype[prop];
	        }
	        clazz.prototype.constructor = clazz;
	        clazz.superClass = baseClazz;
	    }
	
	    /**
	     * @memberOf module:zrender/core/util
	     * @param {Object|Function} target
	     * @param {Object|Function} sorce
	     * @param {boolean} overlay
	     */
	    function mixin(target, source, overlay) {
	        target = 'prototype' in target ? target.prototype : target;
	        source = 'prototype' in source ? source.prototype : source;
	
	        defaults(target, source, overlay);
	    }
	
	    /**
	     * @param {Array|TypedArray} data
	     */
	    function isArrayLike(data) {
	        if (! data) {
	            return;
	        }
	        if (typeof data == 'string') {
	            return false;
	        }
	        return typeof data.length == 'number';
	    }
	
	    /**
	     * 数组或对象遍历
	     * @memberOf module:zrender/core/util
	     * @param {Object|Array} obj
	     * @param {Function} cb
	     * @param {*} [context]
	     */
	    function each(obj, cb, context) {
	        if (!(obj && cb)) {
	            return;
	        }
	        if (obj.forEach && obj.forEach === nativeForEach) {
	            obj.forEach(cb, context);
	        }
	        else if (obj.length === +obj.length) {
	            for (var i = 0, len = obj.length; i < len; i++) {
	                cb.call(context, obj[i], i, obj);
	            }
	        }
	        else {
	            for (var key in obj) {
	                if (obj.hasOwnProperty(key)) {
	                    cb.call(context, obj[key], key, obj);
	                }
	            }
	        }
	    }
	
	    /**
	     * 数组映射
	     * @memberOf module:zrender/core/util
	     * @param {Array} obj
	     * @param {Function} cb
	     * @param {*} [context]
	     * @return {Array}
	     */
	    function map(obj, cb, context) {
	        if (!(obj && cb)) {
	            return;
	        }
	        if (obj.map && obj.map === nativeMap) {
	            return obj.map(cb, context);
	        }
	        else {
	            var result = [];
	            for (var i = 0, len = obj.length; i < len; i++) {
	                result.push(cb.call(context, obj[i], i, obj));
	            }
	            return result;
	        }
	    }
	
	    /**
	     * @memberOf module:zrender/core/util
	     * @param {Array} obj
	     * @param {Function} cb
	     * @param {Object} [memo]
	     * @param {*} [context]
	     * @return {Array}
	     */
	    function reduce(obj, cb, memo, context) {
	        if (!(obj && cb)) {
	            return;
	        }
	        if (obj.reduce && obj.reduce === nativeReduce) {
	            return obj.reduce(cb, memo, context);
	        }
	        else {
	            for (var i = 0, len = obj.length; i < len; i++) {
	                memo = cb.call(context, memo, obj[i], i, obj);
	            }
	            return memo;
	        }
	    }
	
	    /**
	     * 数组过滤
	     * @memberOf module:zrender/core/util
	     * @param {Array} obj
	     * @param {Function} cb
	     * @param {*} [context]
	     * @return {Array}
	     */
	    function filter(obj, cb, context) {
	        if (!(obj && cb)) {
	            return;
	        }
	        if (obj.filter && obj.filter === nativeFilter) {
	            return obj.filter(cb, context);
	        }
	        else {
	            var result = [];
	            for (var i = 0, len = obj.length; i < len; i++) {
	                if (cb.call(context, obj[i], i, obj)) {
	                    result.push(obj[i]);
	                }
	            }
	            return result;
	        }
	    }
	
	    /**
	     * 数组项查找
	     * @memberOf module:zrender/core/util
	     * @param {Array} obj
	     * @param {Function} cb
	     * @param {*} [context]
	     * @return {Array}
	     */
	    function find(obj, cb, context) {
	        if (!(obj && cb)) {
	            return;
	        }
	        for (var i = 0, len = obj.length; i < len; i++) {
	            if (cb.call(context, obj[i], i, obj)) {
	                return obj[i];
	            }
	        }
	    }
	
	    /**
	     * @memberOf module:zrender/core/util
	     * @param {Function} func
	     * @param {*} context
	     * @return {Function}
	     */
	    function bind(func, context) {
	        var args = nativeSlice.call(arguments, 2);
	        return function () {
	            return func.apply(context, args.concat(nativeSlice.call(arguments)));
	        };
	    }
	
	    /**
	     * @memberOf module:zrender/core/util
	     * @param {Function} func
	     * @return {Function}
	     */
	    function curry(func) {
	        var args = nativeSlice.call(arguments, 1);
	        return function () {
	            return func.apply(this, args.concat(nativeSlice.call(arguments)));
	        };
	    }
	
	    /**
	     * @memberOf module:zrender/core/util
	     * @param {*} value
	     * @return {boolean}
	     */
	    function isArray(value) {
	        return objToString.call(value) === '[object Array]';
	    }
	
	    /**
	     * @memberOf module:zrender/core/util
	     * @param {*} value
	     * @return {boolean}
	     */
	    function isFunction(value) {
	        return typeof value === 'function';
	    }
	
	    /**
	     * @memberOf module:zrender/core/util
	     * @param {*} value
	     * @return {boolean}
	     */
	    function isString(value) {
	        return objToString.call(value) === '[object String]';
	    }
	
	    /**
	     * @memberOf module:zrender/core/util
	     * @param {*} value
	     * @return {boolean}
	     */
	    function isObject(value) {
	        // Avoid a V8 JIT bug in Chrome 19-20.
	        // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
	        var type = typeof value;
	        return type === 'function' || (!!value && type == 'object');
	    }
	
	    /**
	     * @memberOf module:zrender/core/util
	     * @param {*} value
	     * @return {boolean}
	     */
	    function isBuildInObject(value) {
	        return !!BUILTIN_OBJECT[objToString.call(value)];
	    }
	
	    /**
	     * @memberOf module:zrender/core/util
	     * @param {*} value
	     * @return {boolean}
	     */
	    function isDom(value) {
	        return value && value.nodeType === 1
	               && typeof(value.nodeName) == 'string';
	    }
	
	    /**
	     * If value1 is not null, then return value1, otherwise judget rest of values.
	     * @memberOf module:zrender/core/util
	     * @return {*} Final value
	     */
	    function retrieve(values) {
	        for (var i = 0, len = arguments.length; i < len; i++) {
	            if (arguments[i] != null) {
	                return arguments[i];
	            }
	        }
	    }
	
	    /**
	     * @memberOf module:zrender/core/util
	     * @param {Array} arr
	     * @param {number} startIndex
	     * @param {number} endIndex
	     * @return {Array}
	     */
	    function slice() {
	        return Function.call.apply(nativeSlice, arguments);
	    }
	
	    /**
	     * @memberOf module:zrender/core/util
	     * @param {boolean} condition
	     * @param {string} message
	     */
	    function assert(condition, message) {
	        if (!condition) {
	            throw new Error(message);
	        }
	    }
	
	    var util = {
	        inherits: inherits,
	        mixin: mixin,
	        clone: clone,
	        merge: merge,
	        mergeAll: mergeAll,
	        extend: extend,
	        defaults: defaults,
	        getContext: getContext,
	        createCanvas: createCanvas,
	        indexOf: indexOf,
	        slice: slice,
	        find: find,
	        isArrayLike: isArrayLike,
	        each: each,
	        map: map,
	        reduce: reduce,
	        filter: filter,
	        bind: bind,
	        curry: curry,
	        isArray: isArray,
	        isString: isString,
	        isObject: isObject,
	        isFunction: isFunction,
	        isBuildInObject: isBuildInObject,
	        isDom: isDom,
	        retrieve: retrieve,
	        assert: assert,
	        noop: function () {}
	    };
	    module.exports = util;
	


/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	
	
	    var Path = __webpack_require__(6);
	    var PathProxy = __webpack_require__(25);
	    var transformPath = __webpack_require__(36);
	    var matrix = __webpack_require__(13);
	
	    // command chars
	    var cc = [
	        'm', 'M', 'l', 'L', 'v', 'V', 'h', 'H', 'z', 'Z',
	        'c', 'C', 'q', 'Q', 't', 'T', 's', 'S', 'a', 'A'
	    ];
	
	    var mathSqrt = Math.sqrt;
	    var mathSin = Math.sin;
	    var mathCos = Math.cos;
	    var PI = Math.PI;
	
	    var vMag = function(v) {
	        return Math.sqrt(v[0] * v[0] + v[1] * v[1]);
	    };
	    var vRatio = function(u, v) {
	        return (u[0] * v[0] + u[1] * v[1]) / (vMag(u) * vMag(v));
	    };
	    var vAngle = function(u, v) {
	        return (u[0] * v[1] < u[1] * v[0] ? -1 : 1)
	                * Math.acos(vRatio(u, v));
	    };
	
	    function processArc(x1, y1, x2, y2, fa, fs, rx, ry, psiDeg, cmd, path) {
	        var psi = psiDeg * (PI / 180.0);
	        var xp = mathCos(psi) * (x1 - x2) / 2.0
	                 + mathSin(psi) * (y1 - y2) / 2.0;
	        var yp = -1 * mathSin(psi) * (x1 - x2) / 2.0
	                 + mathCos(psi) * (y1 - y2) / 2.0;
	
	        var lambda = (xp * xp) / (rx * rx) + (yp * yp) / (ry * ry);
	
	        if (lambda > 1) {
	            rx *= mathSqrt(lambda);
	            ry *= mathSqrt(lambda);
	        }
	
	        var f = (fa === fs ? -1 : 1)
	            * mathSqrt((((rx * rx) * (ry * ry))
	                    - ((rx * rx) * (yp * yp))
	                    - ((ry * ry) * (xp * xp))) / ((rx * rx) * (yp * yp)
	                    + (ry * ry) * (xp * xp))
	                ) || 0;
	
	        var cxp = f * rx * yp / ry;
	        var cyp = f * -ry * xp / rx;
	
	        var cx = (x1 + x2) / 2.0
	                 + mathCos(psi) * cxp
	                 - mathSin(psi) * cyp;
	        var cy = (y1 + y2) / 2.0
	                + mathSin(psi) * cxp
	                + mathCos(psi) * cyp;
	
	        var theta = vAngle([ 1, 0 ], [ (xp - cxp) / rx, (yp - cyp) / ry ]);
	        var u = [ (xp - cxp) / rx, (yp - cyp) / ry ];
	        var v = [ (-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry ];
	        var dTheta = vAngle(u, v);
	
	        if (vRatio(u, v) <= -1) {
	            dTheta = PI;
	        }
	        if (vRatio(u, v) >= 1) {
	            dTheta = 0;
	        }
	        if (fs === 0 && dTheta > 0) {
	            dTheta = dTheta - 2 * PI;
	        }
	        if (fs === 1 && dTheta < 0) {
	            dTheta = dTheta + 2 * PI;
	        }
	
	        path.addData(cmd, cx, cy, rx, ry, theta, dTheta, psi, fs);
	    }
	
	    function createPathProxyFromString(data) {
	        if (!data) {
	            return [];
	        }
	
	        // command string
	        var cs = data.replace(/-/g, ' -')
	            .replace(/  /g, ' ')
	            .replace(/ /g, ',')
	            .replace(/,,/g, ',');
	
	        var n;
	        // create pipes so that we can split the data
	        for (n = 0; n < cc.length; n++) {
	            cs = cs.replace(new RegExp(cc[n], 'g'), '|' + cc[n]);
	        }
	
	        // create array
	        var arr = cs.split('|');
	        // init context point
	        var cpx = 0;
	        var cpy = 0;
	
	        var path = new PathProxy();
	        var CMD = PathProxy.CMD;
	
	        var prevCmd;
	        for (n = 1; n < arr.length; n++) {
	            var str = arr[n];
	            var c = str.charAt(0);
	            var off = 0;
	            var p = str.slice(1).replace(/e,-/g, 'e-').split(',');
	            var cmd;
	
	            if (p.length > 0 && p[0] === '') {
	                p.shift();
	            }
	
	            for (var i = 0; i < p.length; i++) {
	                p[i] = parseFloat(p[i]);
	            }
	            while (off < p.length && !isNaN(p[off])) {
	                if (isNaN(p[0])) {
	                    break;
	                }
	                var ctlPtx;
	                var ctlPty;
	
	                var rx;
	                var ry;
	                var psi;
	                var fa;
	                var fs;
	
	                var x1 = cpx;
	                var y1 = cpy;
	
	                // convert l, H, h, V, and v to L
	                switch (c) {
	                    case 'l':
	                        cpx += p[off++];
	                        cpy += p[off++];
	                        cmd = CMD.L;
	                        path.addData(cmd, cpx, cpy);
	                        break;
	                    case 'L':
	                        cpx = p[off++];
	                        cpy = p[off++];
	                        cmd = CMD.L;
	                        path.addData(cmd, cpx, cpy);
	                        break;
	                    case 'm':
	                        cpx += p[off++];
	                        cpy += p[off++];
	                        cmd = CMD.M;
	                        path.addData(cmd, cpx, cpy);
	                        c = 'l';
	                        break;
	                    case 'M':
	                        cpx = p[off++];
	                        cpy = p[off++];
	                        cmd = CMD.M;
	                        path.addData(cmd, cpx, cpy);
	                        c = 'L';
	                        break;
	                    case 'h':
	                        cpx += p[off++];
	                        cmd = CMD.L;
	                        path.addData(cmd, cpx, cpy);
	                        break;
	                    case 'H':
	                        cpx = p[off++];
	                        cmd = CMD.L;
	                        path.addData(cmd, cpx, cpy);
	                        break;
	                    case 'v':
	                        cpy += p[off++];
	                        cmd = CMD.L;
	                        path.addData(cmd, cpx, cpy);
	                        break;
	                    case 'V':
	                        cpy = p[off++];
	                        cmd = CMD.L;
	                        path.addData(cmd, cpx, cpy);
	                        break;
	                    case 'C':
	                        cmd = CMD.C;
	                        path.addData(
	                            cmd, p[off++], p[off++], p[off++], p[off++], p[off++], p[off++]
	                        );
	                        cpx = p[off - 2];
	                        cpy = p[off - 1];
	                        break;
	                    case 'c':
	                        cmd = CMD.C;
	                        path.addData(
	                            cmd,
	                            p[off++] + cpx, p[off++] + cpy,
	                            p[off++] + cpx, p[off++] + cpy,
	                            p[off++] + cpx, p[off++] + cpy
	                        );
	                        cpx += p[off - 2];
	                        cpy += p[off - 1];
	                        break;
	                    case 'S':
	                        ctlPtx = cpx;
	                        ctlPty = cpy;
	                        var len = path.len();
	                        var pathData = path.data;
	                        if (prevCmd === CMD.C) {
	                            ctlPtx += cpx - pathData[len - 4];
	                            ctlPty += cpy - pathData[len - 3];
	                        }
	                        cmd = CMD.C;
	                        x1 = p[off++];
	                        y1 = p[off++];
	                        cpx = p[off++];
	                        cpy = p[off++];
	                        path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);
	                        break;
	                    case 's':
	                        ctlPtx = cpx;
	                        ctlPty = cpy;
	                        var len = path.len();
	                        var pathData = path.data;
	                        if (prevCmd === CMD.C) {
	                            ctlPtx += cpx - pathData[len - 4];
	                            ctlPty += cpy - pathData[len - 3];
	                        }
	                        cmd = CMD.C;
	                        x1 = cpx + p[off++];
	                        y1 = cpy + p[off++];
	                        cpx += p[off++];
	                        cpy += p[off++];
	                        path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);
	                        break;
	                    case 'Q':
	                        x1 = p[off++];
	                        y1 = p[off++];
	                        cpx = p[off++];
	                        cpy = p[off++];
	                        cmd = CMD.Q;
	                        path.addData(cmd, x1, y1, cpx, cpy);
	                        break;
	                    case 'q':
	                        x1 = p[off++] + cpx;
	                        y1 = p[off++] + cpy;
	                        cpx += p[off++];
	                        cpy += p[off++];
	                        cmd = CMD.Q;
	                        path.addData(cmd, x1, y1, cpx, cpy);
	                        break;
	                    case 'T':
	                        ctlPtx = cpx;
	                        ctlPty = cpy;
	                        var len = path.len();
	                        var pathData = path.data;
	                        if (prevCmd === CMD.Q) {
	                            ctlPtx += cpx - pathData[len - 4];
	                            ctlPty += cpy - pathData[len - 3];
	                        }
	                        cpx = p[off++];
	                        cpy = p[off++];
	                        cmd = CMD.Q;
	                        path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);
	                        break;
	                    case 't':
	                        ctlPtx = cpx;
	                        ctlPty = cpy;
	                        var len = path.len();
	                        var pathData = path.data;
	                        if (prevCmd === CMD.Q) {
	                            ctlPtx += cpx - pathData[len - 4];
	                            ctlPty += cpy - pathData[len - 3];
	                        }
	                        cpx += p[off++];
	                        cpy += p[off++];
	                        cmd = CMD.Q;
	                        path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);
	                        break;
	                    case 'A':
	                        rx = p[off++];
	                        ry = p[off++];
	                        psi = p[off++];
	                        fa = p[off++];
	                        fs = p[off++];
	
	                        x1 = cpx, y1 = cpy;
	                        cpx = p[off++];
	                        cpy = p[off++];
	                        cmd = CMD.A;
	                        processArc(
	                            x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path
	                        );
	                        break;
	                    case 'a':
	                        rx = p[off++];
	                        ry = p[off++];
	                        psi = p[off++];
	                        fa = p[off++];
	                        fs = p[off++];
	
	                        x1 = cpx, y1 = cpy;
	                        cpx += p[off++];
	                        cpy += p[off++];
	                        cmd = CMD.A;
	                        processArc(
	                            x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path
	                        );
	                        break;
	                }
	            }
	
	            if (c === 'z' || c === 'Z') {
	                cmd = CMD.Z;
	                path.addData(cmd);
	            }
	
	            prevCmd = cmd;
	        }
	
	        path.toStatic();
	
	        return path;
	    }
	
	    // TODO Optimize double memory cost problem
	    function createPathOptions(str, opts) {
	        var pathProxy = createPathProxyFromString(str);
	        var transform;
	        opts = opts || {};
	        opts.buildPath = function (path) {
	            path.setData(pathProxy.data);
	            transform && transformPath(path, transform);
	            // Svg and vml renderer don't have context
	            var ctx = path.getContext();
	            if (ctx) {
	                path.rebuildPath(ctx);
	            }
	        };
	
	        opts.applyTransform = function (m) {
	            if (!transform) {
	                transform = matrix.create();
	            }
	            matrix.mul(transform, m, transform);
	            this.dirty(true);
	        };
	
	        return opts;
	    }
	
	    module.exports = {
	        /**
	         * Create a Path object from path string data
	         * http://www.w3.org/TR/SVG/paths.html#PathData
	         * @param  {Object} opts Other options
	         */
	        createFromString: function (str, opts) {
	            return new Path(createPathOptions(str, opts));
	        },
	
	        /**
	         * Create a Path class from path string data
	         * @param  {string} str
	         * @param  {Object} opts Other options
	         */
	        extendFromString: function (str, opts) {
	            return Path.extend(createPathOptions(str, opts));
	        },
	
	        /**
	         * Merge multiple paths
	         */
	        // TODO Apply transform
	        // TODO stroke dash
	        // TODO Optimize double memory cost problem
	        mergePath: function (pathEls, opts) {
	            var pathList = [];
	            var len = pathEls.length;
	            for (var i = 0; i < len; i++) {
	                var pathEl = pathEls[i];
	                if (pathEl.__dirty) {
	                    pathEl.buildPath(pathEl.path, pathEl.shape, true);
	                }
	                pathList.push(pathEl.path);
	            }
	
	            var pathBundle = new Path(opts);
	            pathBundle.buildPath = function (path) {
	                path.appendPath(pathList);
	                // Svg and vml renderer don't have context
	                var ctx = path.getContext();
	                if (ctx) {
	                    path.rebuildPath(ctx);
	                }
	            };
	
	            return pathBundle;
	        }
	    };


/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Path element
	 * @module zrender/graphic/Path
	 */
	
	
	
	    var Displayable = __webpack_require__(7);
	    var zrUtil = __webpack_require__(4);
	    var PathProxy = __webpack_require__(25);
	    var pathContain = __webpack_require__(28);
	
	    var Pattern = __webpack_require__(35);
	    var getCanvasPattern = Pattern.prototype.getCanvasPattern;
	
	    var abs = Math.abs;
	
	    /**
	     * @alias module:zrender/graphic/Path
	     * @extends module:zrender/graphic/Displayable
	     * @constructor
	     * @param {Object} opts
	     */
	    function Path(opts) {
	        Displayable.call(this, opts);
	
	        /**
	         * @type {module:zrender/core/PathProxy}
	         * @readOnly
	         */
	        this.path = new PathProxy();
	    }
	
	    Path.prototype = {
	
	        constructor: Path,
	
	        type: 'path',
	
	        __dirtyPath: true,
	
	        strokeContainThreshold: 5,
	
	        brush: function (ctx, prevEl) {
	            var style = this.style;
	            var path = this.path;
	            var hasStroke = style.hasStroke();
	            var hasFill = style.hasFill();
	            var fill = style.fill;
	            var stroke = style.stroke;
	            var hasFillGradient = hasFill && !!(fill.colorStops);
	            var hasStrokeGradient = hasStroke && !!(stroke.colorStops);
	            var hasFillPattern = hasFill && !!(fill.image);
	            var hasStrokePattern = hasStroke && !!(stroke.image);
	
	            style.bind(ctx, this, prevEl);
	            this.setTransform(ctx);
	
	            if (this.__dirty) {
	                var rect = this.getBoundingRect();
	                // Update gradient because bounding rect may changed
	                if (hasFillGradient) {
	                    this._fillGradient = style.getGradient(ctx, fill, rect);
	                }
	                if (hasStrokeGradient) {
	                    this._strokeGradient = style.getGradient(ctx, stroke, rect);
	                }
	            }
	            // Use the gradient or pattern
	            if (hasFillGradient) {
	                // PENDING If may have affect the state
	                ctx.fillStyle = this._fillGradient;
	            }
	            else if (hasFillPattern) {
	                ctx.fillStyle = getCanvasPattern.call(fill, ctx);
	            }
	            if (hasStrokeGradient) {
	                ctx.strokeStyle = this._strokeGradient;
	            }
	            else if (hasStrokePattern) {
	                ctx.strokeStyle = getCanvasPattern.call(stroke, ctx);
	            }
	
	            var lineDash = style.lineDash;
	            var lineDashOffset = style.lineDashOffset;
	
	            var ctxLineDash = !!ctx.setLineDash;
	
	            // Update path sx, sy
	            var scale = this.getGlobalScale();
	            path.setScale(scale[0], scale[1]);
	
	            // Proxy context
	            // Rebuild path in following 2 cases
	            // 1. Path is dirty
	            // 2. Path needs javascript implemented lineDash stroking.
	            //    In this case, lineDash information will not be saved in PathProxy
	            if (this.__dirtyPath || (
	                lineDash && !ctxLineDash && hasStroke
	            )) {
	                path = this.path.beginPath(ctx);
	
	                // Setting line dash before build path
	                if (lineDash && !ctxLineDash) {
	                    path.setLineDash(lineDash);
	                    path.setLineDashOffset(lineDashOffset);
	                }
	
	                this.buildPath(path, this.shape, false);
	
	                // Clear path dirty flag
	                this.__dirtyPath = false;
	            }
	            else {
	                // Replay path building
	                ctx.beginPath();
	                this.path.rebuildPath(ctx);
	            }
	
	            hasFill && path.fill(ctx);
	
	            if (lineDash && ctxLineDash) {
	                ctx.setLineDash(lineDash);
	                ctx.lineDashOffset = lineDashOffset;
	            }
	
	            hasStroke && path.stroke(ctx);
	
	            if (lineDash && ctxLineDash) {
	                // PENDING
	                // Remove lineDash
	                ctx.setLineDash([]);
	            }
	
	
	            this.restoreTransform(ctx);
	
	            // Draw rect text
	            if (style.text || style.text === 0) {
	                // var rect = this.getBoundingRect();
	                this.drawRectText(ctx, this.getBoundingRect());
	            }
	        },
	
	        // When bundling path, some shape may decide if use moveTo to begin a new subpath or closePath
	        // Like in circle
	        buildPath: function (ctx, shapeCfg, inBundle) {},
	
	        getBoundingRect: function () {
	            var rect = this._rect;
	            var style = this.style;
	            var needsUpdateRect = !rect;
	            if (needsUpdateRect) {
	                var path = this.path;
	                if (this.__dirtyPath) {
	                    path.beginPath();
	                    this.buildPath(path, this.shape, false);
	                }
	                rect = path.getBoundingRect();
	            }
	            this._rect = rect;
	
	            if (style.hasStroke()) {
	                // Needs update rect with stroke lineWidth when
	                // 1. Element changes scale or lineWidth
	                // 2. Shape is changed
	                var rectWithStroke = this._rectWithStroke || (this._rectWithStroke = rect.clone());
	                if (this.__dirty || needsUpdateRect) {
	                    rectWithStroke.copy(rect);
	                    // FIXME Must after updateTransform
	                    var w = style.lineWidth;
	                    // PENDING, Min line width is needed when line is horizontal or vertical
	                    var lineScale = style.strokeNoScale ? this.getLineScale() : 1;
	
	                    // Only add extra hover lineWidth when there are no fill
	                    if (!style.hasFill()) {
	                        w = Math.max(w, this.strokeContainThreshold || 4);
	                    }
	                    // Consider line width
	                    // Line scale can't be 0;
	                    if (lineScale > 1e-10) {
	                        rectWithStroke.width += w / lineScale;
	                        rectWithStroke.height += w / lineScale;
	                        rectWithStroke.x -= w / lineScale / 2;
	                        rectWithStroke.y -= w / lineScale / 2;
	                    }
	                }
	
	                // Return rect with stroke
	                return rectWithStroke;
	            }
	
	            return rect;
	        },
	
	        contain: function (x, y) {
	            var localPos = this.transformCoordToLocal(x, y);
	            var rect = this.getBoundingRect();
	            var style = this.style;
	            x = localPos[0];
	            y = localPos[1];
	
	            if (rect.contain(x, y)) {
	                var pathData = this.path.data;
	                if (style.hasStroke()) {
	                    var lineWidth = style.lineWidth;
	                    var lineScale = style.strokeNoScale ? this.getLineScale() : 1;
	                    // Line scale can't be 0;
	                    if (lineScale > 1e-10) {
	                        // Only add extra hover lineWidth when there are no fill
	                        if (!style.hasFill()) {
	                            lineWidth = Math.max(lineWidth, this.strokeContainThreshold);
	                        }
	                        if (pathContain.containStroke(
	                            pathData, lineWidth / lineScale, x, y
	                        )) {
	                            return true;
	                        }
	                    }
	                }
	                if (style.hasFill()) {
	                    return pathContain.contain(pathData, x, y);
	                }
	            }
	            return false;
	        },
	
	        /**
	         * @param  {boolean} dirtyPath
	         */
	        dirty: function (dirtyPath) {
	            if (dirtyPath == null) {
	                dirtyPath = true;
	            }
	            // Only mark dirty, not mark clean
	            if (dirtyPath) {
	                this.__dirtyPath = dirtyPath;
	                this._rect = null;
	            }
	
	            this.__dirty = true;
	
	            this.__zr && this.__zr.refresh();
	
	            // Used as a clipping path
	            if (this.__clipTarget) {
	                this.__clipTarget.dirty();
	            }
	        },
	
	        /**
	         * Alias for animate('shape')
	         * @param {boolean} loop
	         */
	        animateShape: function (loop) {
	            return this.animate('shape', loop);
	        },
	
	        // Overwrite attrKV
	        attrKV: function (key, value) {
	            // FIXME
	            if (key === 'shape') {
	                this.setShape(value);
	                this.__dirtyPath = true;
	                this._rect = null;
	            }
	            else {
	                Displayable.prototype.attrKV.call(this, key, value);
	            }
	        },
	
	        /**
	         * @param {Object|string} key
	         * @param {*} value
	         */
	        setShape: function (key, value) {
	            var shape = this.shape;
	            // Path from string may not have shape
	            if (shape) {
	                if (zrUtil.isObject(key)) {
	                    for (var name in key) {
	                        shape[name] = key[name];
	                    }
	                }
	                else {
	                    shape[key] = value;
	                }
	                this.dirty(true);
	            }
	            return this;
	        },
	
	        getLineScale: function () {
	            var m = this.transform;
	            // Get the line scale.
	            // Determinant of `m` means how much the area is enlarged by the
	            // transformation. So its square root can be used as a scale factor
	            // for width.
	            return m && abs(m[0] - 1) > 1e-10 && abs(m[3] - 1) > 1e-10
	                ? Math.sqrt(abs(m[0] * m[3] - m[2] * m[1]))
	                : 1;
	        }
	    };
	
	    /**
	     * 扩展一个 Path element, 比如星形，圆等。
	     * Extend a path element
	     * @param {Object} props
	     * @param {string} props.type Path type
	     * @param {Function} props.init Initialize
	     * @param {Function} props.buildPath Overwrite buildPath method
	     * @param {Object} [props.style] Extended default style config
	     * @param {Object} [props.shape] Extended default shape config
	     */
	    Path.extend = function (defaults) {
	        var Sub = function (opts) {
	            Path.call(this, opts);
	
	            if (defaults.style) {
	                // Extend default style
	                this.style.extendFrom(defaults.style, false);
	            }
	
	            // Extend default shape
	            var defaultShape = defaults.shape;
	            if (defaultShape) {
	                this.shape = this.shape || {};
	                var thisShape = this.shape;
	                for (var name in defaultShape) {
	                    if (
	                        ! thisShape.hasOwnProperty(name)
	                        && defaultShape.hasOwnProperty(name)
	                    ) {
	                        thisShape[name] = defaultShape[name];
	                    }
	                }
	            }
	
	            defaults.init && defaults.init.call(this, opts);
	        };
	
	        zrUtil.inherits(Sub, Path);
	
	        // FIXME 不能 extend position, rotation 等引用对象
	        for (var name in defaults) {
	            // Extending prototype values and methods
	            if (name !== 'style' && name !== 'shape') {
	                Sub.prototype[name] = defaults[name];
	            }
	        }
	
	        return Sub;
	    };
	
	    zrUtil.inherits(Path, Displayable);
	
	    module.exports = Path;


/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * 可绘制的图形基类
	 * Base class of all displayable graphic objects
	 * @module zrender/graphic/Displayable
	 */
	
	
	
	    var zrUtil = __webpack_require__(4);
	
	    var Style = __webpack_require__(8);
	
	    var Element = __webpack_require__(9);
	    var RectText = __webpack_require__(22);
	    // var Stateful = require('./mixin/Stateful');
	
	    /**
	     * @alias module:zrender/graphic/Displayable
	     * @extends module:zrender/Element
	     * @extends module:zrender/graphic/mixin/RectText
	     */
	    function Displayable(opts) {
	
	        opts = opts || {};
	
	        Element.call(this, opts);
	
	        // Extend properties
	        for (var name in opts) {
	            if (
	                opts.hasOwnProperty(name) &&
	                name !== 'style'
	            ) {
	                this[name] = opts[name];
	            }
	        }
	
	        /**
	         * @type {module:zrender/graphic/Style}
	         */
	        this.style = new Style(opts.style);
	
	        this._rect = null;
	        // Shapes for cascade clipping.
	        this.__clipPaths = [];
	
	        // FIXME Stateful must be mixined after style is setted
	        // Stateful.call(this, opts);
	    }
	
	    Displayable.prototype = {
	
	        constructor: Displayable,
	
	        type: 'displayable',
	
	        /**
	         * Displayable 是否为脏，Painter 中会根据该标记判断是否需要是否需要重新绘制
	         * Dirty flag. From which painter will determine if this displayable object needs brush
	         * @name module:zrender/graphic/Displayable#__dirty
	         * @type {boolean}
	         */
	        __dirty: true,
	
	        /**
	         * 图形是否可见，为true时不绘制图形，但是仍能触发鼠标事件
	         * If ignore drawing of the displayable object. Mouse event will still be triggered
	         * @name module:/zrender/graphic/Displayable#invisible
	         * @type {boolean}
	         * @default false
	         */
	        invisible: false,
	
	        /**
	         * @name module:/zrender/graphic/Displayable#z
	         * @type {number}
	         * @default 0
	         */
	        z: 0,
	
	        /**
	         * @name module:/zrender/graphic/Displayable#z
	         * @type {number}
	         * @default 0
	         */
	        z2: 0,
	
	        /**
	         * z层level，决定绘画在哪层canvas中
	         * @name module:/zrender/graphic/Displayable#zlevel
	         * @type {number}
	         * @default 0
	         */
	        zlevel: 0,
	
	        /**
	         * 是否可拖拽
	         * @name module:/zrender/graphic/Displayable#draggable
	         * @type {boolean}
	         * @default false
	         */
	        draggable: false,
	
	        /**
	         * 是否正在拖拽
	         * @name module:/zrender/graphic/Displayable#draggable
	         * @type {boolean}
	         * @default false
	         */
	        dragging: false,
	
	        /**
	         * 是否相应鼠标事件
	         * @name module:/zrender/graphic/Displayable#silent
	         * @type {boolean}
	         * @default false
	         */
	        silent: false,
	
	        /**
	         * If enable culling
	         * @type {boolean}
	         * @default false
	         */
	        culling: false,
	
	        /**
	         * Mouse cursor when hovered
	         * @name module:/zrender/graphic/Displayable#cursor
	         * @type {string}
	         */
	        cursor: 'pointer',
	
	        /**
	         * If hover area is bounding rect
	         * @name module:/zrender/graphic/Displayable#rectHover
	         * @type {string}
	         */
	        rectHover: false,
	
	        /**
	         * Render the element progressively when the value >= 0,
	         * usefull for large data.
	         * @type {number}
	         */
	        progressive: -1,
	
	        beforeBrush: function (ctx) {},
	
	        afterBrush: function (ctx) {},
	
	        /**
	         * 图形绘制方法
	         * @param {Canvas2DRenderingContext} ctx
	         */
	        // Interface
	        brush: function (ctx, prevEl) {},
	
	        /**
	         * 获取最小包围盒
	         * @return {module:zrender/core/BoundingRect}
	         */
	        // Interface
	        getBoundingRect: function () {},
	
	        /**
	         * 判断坐标 x, y 是否在图形上
	         * If displayable element contain coord x, y
	         * @param  {number} x
	         * @param  {number} y
	         * @return {boolean}
	         */
	        contain: function (x, y) {
	            return this.rectContain(x, y);
	        },
	
	        /**
	         * @param  {Function} cb
	         * @param  {}   context
	         */
	        traverse: function (cb, context) {
	            cb.call(context, this);
	        },
	
	        /**
	         * 判断坐标 x, y 是否在图形的包围盒上
	         * If bounding rect of element contain coord x, y
	         * @param  {number} x
	         * @param  {number} y
	         * @return {boolean}
	         */
	        rectContain: function (x, y) {
	            var coord = this.transformCoordToLocal(x, y);
	            var rect = this.getBoundingRect();
	            return rect.contain(coord[0], coord[1]);
	        },
	
	        /**
	         * 标记图形元素为脏，并且在下一帧重绘
	         * Mark displayable element dirty and refresh next frame
	         */
	        dirty: function () {
	            this.__dirty = true;
	
	            this._rect = null;
	
	            this.__zr && this.__zr.refresh();
	        },
	
	        /**
	         * 图形是否会触发事件
	         * If displayable object binded any event
	         * @return {boolean}
	         */
	        // TODO, 通过 bind 绑定的事件
	        // isSilent: function () {
	        //     return !(
	        //         this.hoverable || this.draggable
	        //         || this.onmousemove || this.onmouseover || this.onmouseout
	        //         || this.onmousedown || this.onmouseup || this.onclick
	        //         || this.ondragenter || this.ondragover || this.ondragleave
	        //         || this.ondrop
	        //     );
	        // },
	        /**
	         * Alias for animate('style')
	         * @param {boolean} loop
	         */
	        animateStyle: function (loop) {
	            return this.animate('style', loop);
	        },
	
	        attrKV: function (key, value) {
	            if (key !== 'style') {
	                Element.prototype.attrKV.call(this, key, value);
	            }
	            else {
	                this.style.set(value);
	            }
	        },
	
	        /**
	         * @param {Object|string} key
	         * @param {*} value
	         */
	        setStyle: function (key, value) {
	            this.style.set(key, value);
	            this.dirty(false);
	            return this;
	        },
	
	        /**
	         * Use given style object
	         * @param  {Object} obj
	         */
	        useStyle: function (obj) {
	            this.style = new Style(obj);
	            this.dirty(false);
	            return this;
	        }
	    };
	
	    zrUtil.inherits(Displayable, Element);
	
	    zrUtil.mixin(Displayable, RectText);
	    // zrUtil.mixin(Displayable, Stateful);
	
	    module.exports = Displayable;


/***/ },
/* 8 */
/***/ function(module, exports) {

	/**
	 * @module zrender/graphic/Style
	 */
	
	
	    var STYLE_COMMON_PROPS = [
	        ['shadowBlur', 0], ['shadowOffsetX', 0], ['shadowOffsetY', 0], ['shadowColor', '#000'],
	        ['lineCap', 'butt'], ['lineJoin', 'miter'], ['miterLimit', 10]
	    ];
	
	    // var SHADOW_PROPS = STYLE_COMMON_PROPS.slice(0, 4);
	    // var LINE_PROPS = STYLE_COMMON_PROPS.slice(4);
	
	    var Style = function (opts) {
	        this.extendFrom(opts);
	    };
	
	    function createLinearGradient(ctx, obj, rect) {
	        // var size =
	        var x = obj.x;
	        var x2 = obj.x2;
	        var y = obj.y;
	        var y2 = obj.y2;
	
	        if (!obj.global) {
	            x = x * rect.width + rect.x;
	            x2 = x2 * rect.width + rect.x;
	            y = y * rect.height + rect.y;
	            y2 = y2 * rect.height + rect.y;
	        }
	
	        var canvasGradient = ctx.createLinearGradient(x, y, x2, y2);
	
	        return canvasGradient;
	    }
	
	    function createRadialGradient(ctx, obj, rect) {
	        var width = rect.width;
	        var height = rect.height;
	        var min = Math.min(width, height);
	
	        var x = obj.x;
	        var y = obj.y;
	        var r = obj.r;
	        if (!obj.global) {
	            x = x * width + rect.x;
	            y = y * height + rect.y;
	            r = r * min;
	        }
	
	        var canvasGradient = ctx.createRadialGradient(x, y, 0, x, y, r);
	
	        return canvasGradient;
	    }
	
	
	    Style.prototype = {
	
	        constructor: Style,
	
	        /**
	         * @type {string}
	         */
	        fill: '#000000',
	
	        /**
	         * @type {string}
	         */
	        stroke: null,
	
	        /**
	         * @type {number}
	         */
	        opacity: 1,
	
	        /**
	         * @type {Array.<number>}
	         */
	        lineDash: null,
	
	        /**
	         * @type {number}
	         */
	        lineDashOffset: 0,
	
	        /**
	         * @type {number}
	         */
	        shadowBlur: 0,
	
	        /**
	         * @type {number}
	         */
	        shadowOffsetX: 0,
	
	        /**
	         * @type {number}
	         */
	        shadowOffsetY: 0,
	
	        /**
	         * @type {number}
	         */
	        lineWidth: 1,
	
	        /**
	         * If stroke ignore scale
	         * @type {Boolean}
	         */
	        strokeNoScale: false,
	
	        // Bounding rect text configuration
	        // Not affected by element transform
	        /**
	         * @type {string}
	         */
	        text: null,
	
	        /**
	         * @type {string}
	         */
	        textFill: '#000',
	
	        /**
	         * @type {string}
	         */
	        textStroke: null,
	
	        /**
	         * 'inside', 'left', 'right', 'top', 'bottom'
	         * [x, y]
	         * @type {string|Array.<number>}
	         * @default 'inside'
	         */
	        textPosition: 'inside',
	
	        /**
	         * @type {string}
	         */
	        textBaseline: null,
	
	        /**
	         * @type {string}
	         */
	        textAlign: null,
	
	        /**
	         * @type {string}
	         */
	        textVerticalAlign: null,
	
	        /**
	         * Only useful in Path and Image element
	         * @type {number}
	         */
	        textDistance: 5,
	
	        /**
	         * Only useful in Path and Image element
	         * @type {number}
	         */
	        textShadowBlur: 0,
	
	        /**
	         * Only useful in Path and Image element
	         * @type {number}
	         */
	        textShadowOffsetX: 0,
	
	        /**
	         * Only useful in Path and Image element
	         * @type {number}
	         */
	        textShadowOffsetY: 0,
	
	        /**
	         * If transform text
	         * Only useful in Path and Image element
	         * @type {boolean}
	         */
	        textTransform: false,
	
	        /**
	         * Text rotate around position of Path or Image
	         * Only useful in Path and Image element and textTransform is false.
	         */
	        textRotation: 0,
	
	        /**
	         * @type {string}
	         * https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation
	         */
	        blend: null,
	
	        /**
	         * @param {CanvasRenderingContext2D} ctx
	         */
	        bind: function (ctx, el, prevEl) {
	            var style = this;
	            var prevStyle = prevEl && prevEl.style;
	            var firstDraw = !prevStyle;
	
	            for (var i = 0; i < STYLE_COMMON_PROPS.length; i++) {
	                var prop = STYLE_COMMON_PROPS[i];
	                var styleName = prop[0];
	
	                if (firstDraw || style[styleName] !== prevStyle[styleName]) {
	                    // FIXME Invalid property value will cause style leak from previous element.
	                    ctx[styleName] = style[styleName] || prop[1];
	                }
	            }
	
	            if ((firstDraw || style.fill !== prevStyle.fill)) {
	                ctx.fillStyle = style.fill;
	            }
	            if ((firstDraw || style.stroke !== prevStyle.stroke)) {
	                ctx.strokeStyle = style.stroke;
	            }
	            if ((firstDraw || style.opacity !== prevStyle.opacity)) {
	                ctx.globalAlpha = style.opacity == null ? 1 : style.opacity;
	            }
	
	            if ((firstDraw || style.blend !== prevStyle.blend)) {
	                ctx.globalCompositeOperation = style.blend || 'source-over';
	            }
	            if (this.hasStroke()) {
	                var lineWidth = style.lineWidth;
	                ctx.lineWidth = lineWidth / (
	                    (this.strokeNoScale && el && el.getLineScale) ? el.getLineScale() : 1
	                );
	            }
	        },
	
	        hasFill: function () {
	            var fill = this.fill;
	            return fill != null && fill !== 'none';
	        },
	
	        hasStroke: function () {
	            var stroke = this.stroke;
	            return stroke != null && stroke !== 'none' && this.lineWidth > 0;
	        },
	
	        /**
	         * Extend from other style
	         * @param {zrender/graphic/Style} otherStyle
	         * @param {boolean} overwrite
	         */
	        extendFrom: function (otherStyle, overwrite) {
	            if (otherStyle) {
	                var target = this;
	                for (var name in otherStyle) {
	                    if (otherStyle.hasOwnProperty(name)
	                        && (overwrite || ! target.hasOwnProperty(name))
	                    ) {
	                        target[name] = otherStyle[name];
	                    }
	                }
	            }
	        },
	
	        /**
	         * Batch setting style with a given object
	         * @param {Object|string} obj
	         * @param {*} [obj]
	         */
	        set: function (obj, value) {
	            if (typeof obj === 'string') {
	                this[obj] = value;
	            }
	            else {
	                this.extendFrom(obj, true);
	            }
	        },
	
	        /**
	         * Clone
	         * @return {zrender/graphic/Style} [description]
	         */
	        clone: function () {
	            var newStyle = new this.constructor();
	            newStyle.extendFrom(this, true);
	            return newStyle;
	        },
	
	        getGradient: function (ctx, obj, rect) {
	            var method = obj.type === 'radial' ? createRadialGradient : createLinearGradient;
	            var canvasGradient = method(ctx, obj, rect);
	            var colorStops = obj.colorStops;
	            for (var i = 0; i < colorStops.length; i++) {
	                canvasGradient.addColorStop(
	                    colorStops[i].offset, colorStops[i].color
	                );
	            }
	            return canvasGradient;
	        }
	    };
	
	    var styleProto = Style.prototype;
	    for (var i = 0; i < STYLE_COMMON_PROPS.length; i++) {
	        var prop = STYLE_COMMON_PROPS[i];
	        if (!(prop[0] in styleProto)) {
	            styleProto[prop[0]] = prop[1];
	        }
	    }
	
	    // Provide for others
	    Style.getGradient = styleProto.getGradient;
	
	    module.exports = Style;


/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	/**
	 * @module zrender/Element
	 */
	
	
	    var guid = __webpack_require__(10);
	    var Eventful = __webpack_require__(11);
	    var Transformable = __webpack_require__(12);
	    var Animatable = __webpack_require__(15);
	    var zrUtil = __webpack_require__(4);
	
	    /**
	     * @alias module:zrender/Element
	     * @constructor
	     * @extends {module:zrender/mixin/Animatable}
	     * @extends {module:zrender/mixin/Transformable}
	     * @extends {module:zrender/mixin/Eventful}
	     */
	    var Element = function (opts) {
	
	        Transformable.call(this, opts);
	        Eventful.call(this, opts);
	        Animatable.call(this, opts);
	
	        /**
	         * 画布元素ID
	         * @type {string}
	         */
	        this.id = opts.id || guid();
	    };
	
	    Element.prototype = {
	
	        /**
	         * 元素类型
	         * Element type
	         * @type {string}
	         */
	        type: 'element',
	
	        /**
	         * 元素名字
	         * Element name
	         * @type {string}
	         */
	        name: '',
	
	        /**
	         * ZRender 实例对象，会在 element 添加到 zrender 实例中后自动赋值
	         * ZRender instance will be assigned when element is associated with zrender
	         * @name module:/zrender/Element#__zr
	         * @type {module:zrender/ZRender}
	         */
	        __zr: null,
	
	        /**
	         * 图形是否忽略，为true时忽略图形的绘制以及事件触发
	         * If ignore drawing and events of the element object
	         * @name module:/zrender/Element#ignore
	         * @type {boolean}
	         * @default false
	         */
	        ignore: false,
	
	        /**
	         * 用于裁剪的路径(shape)，所有 Group 内的路径在绘制时都会被这个路径裁剪
	         * 该路径会继承被裁减对象的变换
	         * @type {module:zrender/graphic/Path}
	         * @see http://www.w3.org/TR/2dcontext/#clipping-region
	         * @readOnly
	         */
	        clipPath: null,
	
	        /**
	         * Drift element
	         * @param  {number} dx dx on the global space
	         * @param  {number} dy dy on the global space
	         */
	        drift: function (dx, dy) {
	            switch (this.draggable) {
	                case 'horizontal':
	                    dy = 0;
	                    break;
	                case 'vertical':
	                    dx = 0;
	                    break;
	            }
	
	            var m = this.transform;
	            if (!m) {
	                m = this.transform = [1, 0, 0, 1, 0, 0];
	            }
	            m[4] += dx;
	            m[5] += dy;
	
	            this.decomposeTransform();
	            this.dirty(false);
	        },
	
	        /**
	         * Hook before update
	         */
	        beforeUpdate: function () {},
	        /**
	         * Hook after update
	         */
	        afterUpdate: function () {},
	        /**
	         * Update each frame
	         */
	        update: function () {
	            this.updateTransform();
	        },
	
	        /**
	         * @param  {Function} cb
	         * @param  {}   context
	         */
	        traverse: function (cb, context) {},
	
	        /**
	         * @protected
	         */
	        attrKV: function (key, value) {
	            if (key === 'position' || key === 'scale' || key === 'origin') {
	                // Copy the array
	                if (value) {
	                    var target = this[key];
	                    if (!target) {
	                        target = this[key] = [];
	                    }
	                    target[0] = value[0];
	                    target[1] = value[1];
	                }
	            }
	            else {
	                this[key] = value;
	            }
	        },
	
	        /**
	         * Hide the element
	         */
	        hide: function () {
	            this.ignore = true;
	            this.__zr && this.__zr.refresh();
	        },
	
	        /**
	         * Show the element
	         */
	        show: function () {
	            this.ignore = false;
	            this.__zr && this.__zr.refresh();
	        },
	
	        /**
	         * @param {string|Object} key
	         * @param {*} value
	         */
	        attr: function (key, value) {
	            if (typeof key === 'string') {
	                this.attrKV(key, value);
	            }
	            else if (zrUtil.isObject(key)) {
	                for (var name in key) {
	                    if (key.hasOwnProperty(name)) {
	                        this.attrKV(name, key[name]);
	                    }
	                }
	            }
	
	            this.dirty(false);
	
	            return this;
	        },
	
	        /**
	         * @param {module:zrender/graphic/Path} clipPath
	         */
	        setClipPath: function (clipPath) {
	            var zr = this.__zr;
	            if (zr) {
	                clipPath.addSelfToZr(zr);
	            }
	
	            // Remove previous clip path
	            if (this.clipPath && this.clipPath !== clipPath) {
	                this.removeClipPath();
	            }
	
	            this.clipPath = clipPath;
	            clipPath.__zr = zr;
	            clipPath.__clipTarget = this;
	
	            this.dirty(false);
	        },
	
	        /**
	         */
	        removeClipPath: function () {
	            var clipPath = this.clipPath;
	            if (clipPath) {
	                if (clipPath.__zr) {
	                    clipPath.removeSelfFromZr(clipPath.__zr);
	                }
	
	                clipPath.__zr = null;
	                clipPath.__clipTarget = null;
	                this.clipPath = null;
	
	                this.dirty(false);
	            }
	        },
	
	        /**
	         * Add self from zrender instance.
	         * Not recursively because it will be invoked when element added to storage.
	         * @param {module:zrender/ZRender} zr
	         */
	        addSelfToZr: function (zr) {
	            this.__zr = zr;
	            // 添加动画
	            var animators = this.animators;
	            if (animators) {
	                for (var i = 0; i < animators.length; i++) {
	                    zr.animation.addAnimator(animators[i]);
	                }
	            }
	
	            if (this.clipPath) {
	                this.clipPath.addSelfToZr(zr);
	            }
	        },
	
	        /**
	         * Remove self from zrender instance.
	         * Not recursively because it will be invoked when element added to storage.
	         * @param {module:zrender/ZRender} zr
	         */
	        removeSelfFromZr: function (zr) {
	            this.__zr = null;
	            // 移除动画
	            var animators = this.animators;
	            if (animators) {
	                for (var i = 0; i < animators.length; i++) {
	                    zr.animation.removeAnimator(animators[i]);
	                }
	            }
	
	            if (this.clipPath) {
	                this.clipPath.removeSelfFromZr(zr);
	            }
	        }
	    };
	
	    zrUtil.mixin(Element, Animatable);
	    zrUtil.mixin(Element, Transformable);
	    zrUtil.mixin(Element, Eventful);
	
	    module.exports = Element;


/***/ },
/* 10 */
/***/ function(module, exports) {

	/**
	 * zrender: 生成唯一id
	 *
	 * @author errorrik (errorrik@gmail.com)
	 */
	
	
	    var idStart = 0x0907;
	
	    module.exports = function () {
	        return idStart++;
	    };
	


/***/ },
/* 11 */
/***/ function(module, exports) {

	/**
	 * 事件扩展
	 * @module zrender/mixin/Eventful
	 * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)
	 *         pissang (https://www.github.com/pissang)
	 */
	
	
	    var arrySlice = Array.prototype.slice;
	
	    /**
	     * 事件分发器
	     * @alias module:zrender/mixin/Eventful
	     * @constructor
	     */
	    var Eventful = function () {
	        this._$handlers = {};
	    };
	
	    Eventful.prototype = {
	
	        constructor: Eventful,
	
	        /**
	         * 单次触发绑定，trigger后销毁
	         *
	         * @param {string} event 事件名
	         * @param {Function} handler 响应函数
	         * @param {Object} context
	         */
	        one: function (event, handler, context) {
	            var _h = this._$handlers;
	
	            if (!handler || !event) {
	                return this;
	            }
	
	            if (!_h[event]) {
	                _h[event] = [];
	            }
	
	            for (var i = 0; i < _h[event].length; i++) {
	                if (_h[event][i].h === handler) {
	                    return this;
	                }
	            }
	
	            _h[event].push({
	                h: handler,
	                one: true,
	                ctx: context || this
	            });
	
	            return this;
	        },
	
	        /**
	         * 绑定事件
	         * @param {string} event 事件名
	         * @param {Function} handler 事件处理函数
	         * @param {Object} [context]
	         */
	        on: function (event, handler, context) {
	            var _h = this._$handlers;
	
	            if (!handler || !event) {
	                return this;
	            }
	
	            if (!_h[event]) {
	                _h[event] = [];
	            }
	
	            for (var i = 0; i < _h[event].length; i++) {
	                if (_h[event][i].h === handler) {
	                    return this;
	                }
	            }
	
	            _h[event].push({
	                h: handler,
	                one: false,
	                ctx: context || this
	            });
	
	            return this;
	        },
	
	        /**
	         * 是否绑定了事件
	         * @param  {string}  event
	         * @return {boolean}
	         */
	        isSilent: function (event) {
	            var _h = this._$handlers;
	            return _h[event] && _h[event].length;
	        },
	
	        /**
	         * 解绑事件
	         * @param {string} event 事件名
	         * @param {Function} [handler] 事件处理函数
	         */
	        off: function (event, handler) {
	            var _h = this._$handlers;
	
	            if (!event) {
	                this._$handlers = {};
	                return this;
	            }
	
	            if (handler) {
	                if (_h[event]) {
	                    var newList = [];
	                    for (var i = 0, l = _h[event].length; i < l; i++) {
	                        if (_h[event][i]['h'] != handler) {
	                            newList.push(_h[event][i]);
	                        }
	                    }
	                    _h[event] = newList;
	                }
	
	                if (_h[event] && _h[event].length === 0) {
	                    delete _h[event];
	                }
	            }
	            else {
	                delete _h[event];
	            }
	
	            return this;
	        },
	
	        /**
	         * 事件分发
	         *
	         * @param {string} type 事件类型
	         */
	        trigger: function (type) {
	            if (this._$handlers[type]) {
	                var args = arguments;
	                var argLen = args.length;
	
	                if (argLen > 3) {
	                    args = arrySlice.call(args, 1);
	                }
	
	                var _h = this._$handlers[type];
	                var len = _h.length;
	                for (var i = 0; i < len;) {
	                    // Optimize advise from backbone
	                    switch (argLen) {
	                        case 1:
	                            _h[i]['h'].call(_h[i]['ctx']);
	                            break;
	                        case 2:
	                            _h[i]['h'].call(_h[i]['ctx'], args[1]);
	                            break;
	                        case 3:
	                            _h[i]['h'].call(_h[i]['ctx'], args[1], args[2]);
	                            break;
	                        default:
	                            // have more than 2 given arguments
	                            _h[i]['h'].apply(_h[i]['ctx'], args);
	                            break;
	                    }
	
	                    if (_h[i]['one']) {
	                        _h.splice(i, 1);
	                        len--;
	                    }
	                    else {
	                        i++;
	                    }
	                }
	            }
	
	            return this;
	        },
	
	        /**
	         * 带有context的事件分发, 最后一个参数是事件回调的context
	         * @param {string} type 事件类型
	         */
	        triggerWithContext: function (type) {
	            if (this._$handlers[type]) {
	                var args = arguments;
	                var argLen = args.length;
	
	                if (argLen > 4) {
	                    args = arrySlice.call(args, 1, args.length - 1);
	                }
	                var ctx = args[args.length - 1];
	
	                var _h = this._$handlers[type];
	                var len = _h.length;
	                for (var i = 0; i < len;) {
	                    // Optimize advise from backbone
	                    switch (argLen) {
	                        case 1:
	                            _h[i]['h'].call(ctx);
	                            break;
	                        case 2:
	                            _h[i]['h'].call(ctx, args[1]);
	                            break;
	                        case 3:
	                            _h[i]['h'].call(ctx, args[1], args[2]);
	                            break;
	                        default:
	                            // have more than 2 given arguments
	                            _h[i]['h'].apply(ctx, args);
	                            break;
	                    }
	
	                    if (_h[i]['one']) {
	                        _h.splice(i, 1);
	                        len--;
	                    }
	                    else {
	                        i++;
	                    }
	                }
	            }
	
	            return this;
	        }
	    };
	
	    // 对象可以通过 onxxxx 绑定事件
	    /**
	     * @event module:zrender/mixin/Eventful#onclick
	     * @type {Function}
	     * @default null
	     */
	    /**
	     * @event module:zrender/mixin/Eventful#onmouseover
	     * @type {Function}
	     * @default null
	     */
	    /**
	     * @event module:zrender/mixin/Eventful#onmouseout
	     * @type {Function}
	     * @default null
	     */
	    /**
	     * @event module:zrender/mixin/Eventful#onmousemove
	     * @type {Function}
	     * @default null
	     */
	    /**
	     * @event module:zrender/mixin/Eventful#onmousewheel
	     * @type {Function}
	     * @default null
	     */
	    /**
	     * @event module:zrender/mixin/Eventful#onmousedown
	     * @type {Function}
	     * @default null
	     */
	    /**
	     * @event module:zrender/mixin/Eventful#onmouseup
	     * @type {Function}
	     * @default null
	     */
	    /**
	     * @event module:zrender/mixin/Eventful#ondragstart
	     * @type {Function}
	     * @default null
	     */
	    /**
	     * @event module:zrender/mixin/Eventful#ondragend
	     * @type {Function}
	     * @default null
	     */
	    /**
	     * @event module:zrender/mixin/Eventful#ondragenter
	     * @type {Function}
	     * @default null
	     */
	    /**
	     * @event module:zrender/mixin/Eventful#ondragleave
	     * @type {Function}
	     * @default null
	     */
	    /**
	     * @event module:zrender/mixin/Eventful#ondragover
	     * @type {Function}
	     * @default null
	     */
	    /**
	     * @event module:zrender/mixin/Eventful#ondrop
	     * @type {Function}
	     * @default null
	     */
	
	    module.exports = Eventful;
	


/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	/**
	 * 提供变换扩展
	 * @module zrender/mixin/Transformable
	 * @author pissang (https://www.github.com/pissang)
	 */
	
	
	    var matrix = __webpack_require__(13);
	    var vector = __webpack_require__(14);
	    var mIdentity = matrix.identity;
	
	    var EPSILON = 5e-5;
	
	    function isNotAroundZero(val) {
	        return val > EPSILON || val < -EPSILON;
	    }
	
	    /**
	     * @alias module:zrender/mixin/Transformable
	     * @constructor
	     */
	    var Transformable = function (opts) {
	        opts = opts || {};
	        // If there are no given position, rotation, scale
	        if (!opts.position) {
	            /**
	             * 平移
	             * @type {Array.<number>}
	             * @default [0, 0]
	             */
	            this.position = [0, 0];
	        }
	        if (opts.rotation == null) {
	            /**
	             * 旋转
	             * @type {Array.<number>}
	             * @default 0
	             */
	            this.rotation = 0;
	        }
	        if (!opts.scale) {
	            /**
	             * 缩放
	             * @type {Array.<number>}
	             * @default [1, 1]
	             */
	            this.scale = [1, 1];
	        }
	        /**
	         * 旋转和缩放的原点
	         * @type {Array.<number>}
	         * @default null
	         */
	        this.origin = this.origin || null;
	    };
	
	    var transformableProto = Transformable.prototype;
	    transformableProto.transform = null;
	
	    /**
	     * 判断是否需要有坐标变换
	     * 如果有坐标变换, 则从position, rotation, scale以及父节点的transform计算出自身的transform矩阵
	     */
	    transformableProto.needLocalTransform = function () {
	        return isNotAroundZero(this.rotation)
	            || isNotAroundZero(this.position[0])
	            || isNotAroundZero(this.position[1])
	            || isNotAroundZero(this.scale[0] - 1)
	            || isNotAroundZero(this.scale[1] - 1);
	    };
	
	    transformableProto.updateTransform = function () {
	        var parent = this.parent;
	        var parentHasTransform = parent && parent.transform;
	        var needLocalTransform = this.needLocalTransform();
	
	        var m = this.transform;
	        if (!(needLocalTransform || parentHasTransform)) {
	            m && mIdentity(m);
	            return;
	        }
	
	        m = m || matrix.create();
	
	        if (needLocalTransform) {
	            this.getLocalTransform(m);
	        }
	        else {
	            mIdentity(m);
	        }
	
	        // 应用父节点变换
	        if (parentHasTransform) {
	            if (needLocalTransform) {
	                matrix.mul(m, parent.transform, m);
	            }
	            else {
	                matrix.copy(m, parent.transform);
	            }
	        }
	        // 保存这个变换矩阵
	        this.transform = m;
	
	        this.invTransform = this.invTransform || matrix.create();
	        matrix.invert(this.invTransform, m);
	    };
	
	    transformableProto.getLocalTransform = function (m) {
	        m = m || [];
	        mIdentity(m);
	
	        var origin = this.origin;
	
	        var scale = this.scale;
	        var rotation = this.rotation;
	        var position = this.position;
	        if (origin) {
	            // Translate to origin
	            m[4] -= origin[0];
	            m[5] -= origin[1];
	        }
	        matrix.scale(m, m, scale);
	        if (rotation) {
	            matrix.rotate(m, m, rotation);
	        }
	        if (origin) {
	            // Translate back from origin
	            m[4] += origin[0];
	            m[5] += origin[1];
	        }
	
	        m[4] += position[0];
	        m[5] += position[1];
	
	        return m;
	    };
	    /**
	     * 将自己的transform应用到context上
	     * @param {Context2D} ctx
	     */
	    transformableProto.setTransform = function (ctx) {
	        var m = this.transform;
	        var dpr = ctx.dpr || 1;
	        if (m) {
	            ctx.setTransform(dpr * m[0], dpr * m[1], dpr * m[2], dpr * m[3], dpr * m[4], dpr * m[5]);
	        }
	        else {
	            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
	        }
	    };
	
	    transformableProto.restoreTransform = function (ctx) {
	        var m = this.transform;
	        var dpr = ctx.dpr || 1;
	        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
	    }
	
	    var tmpTransform = [];
	
	    /**
	     * 分解`transform`矩阵到`position`, `rotation`, `scale`
	     */
	    transformableProto.decomposeTransform = function () {
	        if (!this.transform) {
	            return;
	        }
	        var parent = this.parent;
	        var m = this.transform;
	        if (parent && parent.transform) {
	            // Get local transform and decompose them to position, scale, rotation
	            matrix.mul(tmpTransform, parent.invTransform, m);
	            m = tmpTransform;
	        }
	        var sx = m[0] * m[0] + m[1] * m[1];
	        var sy = m[2] * m[2] + m[3] * m[3];
	        var position = this.position;
	        var scale = this.scale;
	        if (isNotAroundZero(sx - 1)) {
	            sx = Math.sqrt(sx);
	        }
	        if (isNotAroundZero(sy - 1)) {
	            sy = Math.sqrt(sy);
	        }
	        if (m[0] < 0) {
	            sx = -sx;
	        }
	        if (m[3] < 0) {
	            sy = -sy;
	        }
	        position[0] = m[4];
	        position[1] = m[5];
	        scale[0] = sx;
	        scale[1] = sy;
	        this.rotation = Math.atan2(-m[1] / sy, m[0] / sx);
	    };
	
	    /**
	     * Get global scale
	     * @return {Array.<number>}
	     */
	    transformableProto.getGlobalScale = function () {
	        var m = this.transform;
	        if (!m) {
	            return [1, 1];
	        }
	        var sx = Math.sqrt(m[0] * m[0] + m[1] * m[1]);
	        var sy = Math.sqrt(m[2] * m[2] + m[3] * m[3]);
	        if (m[0] < 0) {
	            sx = -sx;
	        }
	        if (m[3] < 0) {
	            sy = -sy;
	        }
	        return [sx, sy];
	    };
	    /**
	     * 变换坐标位置到 shape 的局部坐标空间
	     * @method
	     * @param {number} x
	     * @param {number} y
	     * @return {Array.<number>}
	     */
	    transformableProto.transformCoordToLocal = function (x, y) {
	        var v2 = [x, y];
	        var invTransform = this.invTransform;
	        if (invTransform) {
	            vector.applyTransform(v2, v2, invTransform);
	        }
	        return v2;
	    };
	
	    /**
	     * 变换局部坐标位置到全局坐标空间
	     * @method
	     * @param {number} x
	     * @param {number} y
	     * @return {Array.<number>}
	     */
	    transformableProto.transformCoordToGlobal = function (x, y) {
	        var v2 = [x, y];
	        var transform = this.transform;
	        if (transform) {
	            vector.applyTransform(v2, v2, transform);
	        }
	        return v2;
	    };
	
	    module.exports = Transformable;
	


/***/ },
/* 13 */
/***/ function(module, exports) {

	
	    var ArrayCtor = typeof Float32Array === 'undefined'
	        ? Array
	        : Float32Array;
	    /**
	     * 3x2矩阵操作类
	     * @exports zrender/tool/matrix
	     */
	    var matrix = {
	        /**
	         * 创建一个单位矩阵
	         * @return {Float32Array|Array.<number>}
	         */
	        create : function() {
	            var out = new ArrayCtor(6);
	            matrix.identity(out);
	
	            return out;
	        },
	        /**
	         * 设置矩阵为单位矩阵
	         * @param {Float32Array|Array.<number>} out
	         */
	        identity : function(out) {
	            out[0] = 1;
	            out[1] = 0;
	            out[2] = 0;
	            out[3] = 1;
	            out[4] = 0;
	            out[5] = 0;
	            return out;
	        },
	        /**
	         * 复制矩阵
	         * @param {Float32Array|Array.<number>} out
	         * @param {Float32Array|Array.<number>} m
	         */
	        copy: function(out, m) {
	            out[0] = m[0];
	            out[1] = m[1];
	            out[2] = m[2];
	            out[3] = m[3];
	            out[4] = m[4];
	            out[5] = m[5];
	            return out;
	        },
	        /**
	         * 矩阵相乘
	         * @param {Float32Array|Array.<number>} out
	         * @param {Float32Array|Array.<number>} m1
	         * @param {Float32Array|Array.<number>} m2
	         */
	        mul : function (out, m1, m2) {
	            // Consider matrix.mul(m, m2, m);
	            // where out is the same as m2.
	            // So use temp variable to escape error.
	            var out0 = m1[0] * m2[0] + m1[2] * m2[1];
	            var out1 = m1[1] * m2[0] + m1[3] * m2[1];
	            var out2 = m1[0] * m2[2] + m1[2] * m2[3];
	            var out3 = m1[1] * m2[2] + m1[3] * m2[3];
	            var out4 = m1[0] * m2[4] + m1[2] * m2[5] + m1[4];
	            var out5 = m1[1] * m2[4] + m1[3] * m2[5] + m1[5];
	            out[0] = out0;
	            out[1] = out1;
	            out[2] = out2;
	            out[3] = out3;
	            out[4] = out4;
	            out[5] = out5;
	            return out;
	        },
	        /**
	         * 平移变换
	         * @param {Float32Array|Array.<number>} out
	         * @param {Float32Array|Array.<number>} a
	         * @param {Float32Array|Array.<number>} v
	         */
	        translate : function(out, a, v) {
	            out[0] = a[0];
	            out[1] = a[1];
	            out[2] = a[2];
	            out[3] = a[3];
	            out[4] = a[4] + v[0];
	            out[5] = a[5] + v[1];
	            return out;
	        },
	        /**
	         * 旋转变换
	         * @param {Float32Array|Array.<number>} out
	         * @param {Float32Array|Array.<number>} a
	         * @param {number} rad
	         */
	        rotate : function(out, a, rad) {
	            var aa = a[0];
	            var ac = a[2];
	            var atx = a[4];
	            var ab = a[1];
	            var ad = a[3];
	            var aty = a[5];
	            var st = Math.sin(rad);
	            var ct = Math.cos(rad);
	
	            out[0] = aa * ct + ab * st;
	            out[1] = -aa * st + ab * ct;
	            out[2] = ac * ct + ad * st;
	            out[3] = -ac * st + ct * ad;
	            out[4] = ct * atx + st * aty;
	            out[5] = ct * aty - st * atx;
	            return out;
	        },
	        /**
	         * 缩放变换
	         * @param {Float32Array|Array.<number>} out
	         * @param {Float32Array|Array.<number>} a
	         * @param {Float32Array|Array.<number>} v
	         */
	        scale : function(out, a, v) {
	            var vx = v[0];
	            var vy = v[1];
	            out[0] = a[0] * vx;
	            out[1] = a[1] * vy;
	            out[2] = a[2] * vx;
	            out[3] = a[3] * vy;
	            out[4] = a[4] * vx;
	            out[5] = a[5] * vy;
	            return out;
	        },
	        /**
	         * 求逆矩阵
	         * @param {Float32Array|Array.<number>} out
	         * @param {Float32Array|Array.<number>} a
	         */
	        invert : function(out, a) {
	
	            var aa = a[0];
	            var ac = a[2];
	            var atx = a[4];
	            var ab = a[1];
	            var ad = a[3];
	            var aty = a[5];
	
	            var det = aa * ad - ab * ac;
	            if (!det) {
	                return null;
	            }
	            det = 1.0 / det;
	
	            out[0] = ad * det;
	            out[1] = -ab * det;
	            out[2] = -ac * det;
	            out[3] = aa * det;
	            out[4] = (ac * aty - ad * atx) * det;
	            out[5] = (ab * atx - aa * aty) * det;
	            return out;
	        }
	    };
	
	    module.exports = matrix;
	


/***/ },
/* 14 */
/***/ function(module, exports) {

	
	    var ArrayCtor = typeof Float32Array === 'undefined'
	        ? Array
	        : Float32Array;
	
	    /**
	     * @typedef {Float32Array|Array.<number>} Vector2
	     */
	    /**
	     * 二维向量类
	     * @exports zrender/tool/vector
	     */
	    var vector = {
	        /**
	         * 创建一个向量
	         * @param {number} [x=0]
	         * @param {number} [y=0]
	         * @return {Vector2}
	         */
	        create: function (x, y) {
	            var out = new ArrayCtor(2);
	            if (x == null) {
	                x = 0;
	            }
	            if (y == null) {
	                y = 0;
	            }
	            out[0] = x;
	            out[1] = y;
	            return out;
	        },
	
	        /**
	         * 复制向量数据
	         * @param {Vector2} out
	         * @param {Vector2} v
	         * @return {Vector2}
	         */
	        copy: function (out, v) {
	            out[0] = v[0];
	            out[1] = v[1];
	            return out;
	        },
	
	        /**
	         * 克隆一个向量
	         * @param {Vector2} v
	         * @return {Vector2}
	         */
	        clone: function (v) {
	            var out = new ArrayCtor(2);
	            out[0] = v[0];
	            out[1] = v[1];
	            return out;
	        },
	
	        /**
	         * 设置向量的两个项
	         * @param {Vector2} out
	         * @param {number} a
	         * @param {number} b
	         * @return {Vector2} 结果
	         */
	        set: function (out, a, b) {
	            out[0] = a;
	            out[1] = b;
	            return out;
	        },
	
	        /**
	         * 向量相加
	         * @param {Vector2} out
	         * @param {Vector2} v1
	         * @param {Vector2} v2
	         */
	        add: function (out, v1, v2) {
	            out[0] = v1[0] + v2[0];
	            out[1] = v1[1] + v2[1];
	            return out;
	        },
	
	        /**
	         * 向量缩放后相加
	         * @param {Vector2} out
	         * @param {Vector2} v1
	         * @param {Vector2} v2
	         * @param {number} a
	         */
	        scaleAndAdd: function (out, v1, v2, a) {
	            out[0] = v1[0] + v2[0] * a;
	            out[1] = v1[1] + v2[1] * a;
	            return out;
	        },
	
	        /**
	         * 向量相减
	         * @param {Vector2} out
	         * @param {Vector2} v1
	         * @param {Vector2} v2
	         */
	        sub: function (out, v1, v2) {
	            out[0] = v1[0] - v2[0];
	            out[1] = v1[1] - v2[1];
	            return out;
	        },
	
	        /**
	         * 向量长度
	         * @param {Vector2} v
	         * @return {number}
	         */
	        len: function (v) {
	            return Math.sqrt(this.lenSquare(v));
	        },
	
	        /**
	         * 向量长度平方
	         * @param {Vector2} v
	         * @return {number}
	         */
	        lenSquare: function (v) {
	            return v[0] * v[0] + v[1] * v[1];
	        },
	
	        /**
	         * 向量乘法
	         * @param {Vector2} out
	         * @param {Vector2} v1
	         * @param {Vector2} v2
	         */
	        mul: function (out, v1, v2) {
	            out[0] = v1[0] * v2[0];
	            out[1] = v1[1] * v2[1];
	            return out;
	        },
	
	        /**
	         * 向量除法
	         * @param {Vector2} out
	         * @param {Vector2} v1
	         * @param {Vector2} v2
	         */
	        div: function (out, v1, v2) {
	            out[0] = v1[0] / v2[0];
	            out[1] = v1[1] / v2[1];
	            return out;
	        },
	
	        /**
	         * 向量点乘
	         * @param {Vector2} v1
	         * @param {Vector2} v2
	         * @return {number}
	         */
	        dot: function (v1, v2) {
	            return v1[0] * v2[0] + v1[1] * v2[1];
	        },
	
	        /**
	         * 向量缩放
	         * @param {Vector2} out
	         * @param {Vector2} v
	         * @param {number} s
	         */
	        scale: function (out, v, s) {
	            out[0] = v[0] * s;
	            out[1] = v[1] * s;
	            return out;
	        },
	
	        /**
	         * 向量归一化
	         * @param {Vector2} out
	         * @param {Vector2} v
	         */
	        normalize: function (out, v) {
	            var d = vector.len(v);
	            if (d === 0) {
	                out[0] = 0;
	                out[1] = 0;
	            }
	            else {
	                out[0] = v[0] / d;
	                out[1] = v[1] / d;
	            }
	            return out;
	        },
	
	        /**
	         * 计算向量间距离
	         * @param {Vector2} v1
	         * @param {Vector2} v2
	         * @return {number}
	         */
	        distance: function (v1, v2) {
	            return Math.sqrt(
	                (v1[0] - v2[0]) * (v1[0] - v2[0])
	                + (v1[1] - v2[1]) * (v1[1] - v2[1])
	            );
	        },
	
	        /**
	         * 向量距离平方
	         * @param {Vector2} v1
	         * @param {Vector2} v2
	         * @return {number}
	         */
	        distanceSquare: function (v1, v2) {
	            return (v1[0] - v2[0]) * (v1[0] - v2[0])
	                + (v1[1] - v2[1]) * (v1[1] - v2[1]);
	        },
	
	        /**
	         * 求负向量
	         * @param {Vector2} out
	         * @param {Vector2} v
	         */
	        negate: function (out, v) {
	            out[0] = -v[0];
	            out[1] = -v[1];
	            return out;
	        },
	
	        /**
	         * 插值两个点
	         * @param {Vector2} out
	         * @param {Vector2} v1
	         * @param {Vector2} v2
	         * @param {number} t
	         */
	        lerp: function (out, v1, v2, t) {
	            out[0] = v1[0] + t * (v2[0] - v1[0]);
	            out[1] = v1[1] + t * (v2[1] - v1[1]);
	            return out;
	        },
	
	        /**
	         * 矩阵左乘向量
	         * @param {Vector2} out
	         * @param {Vector2} v
	         * @param {Vector2} m
	         */
	        applyTransform: function (out, v, m) {
	            var x = v[0];
	            var y = v[1];
	            out[0] = m[0] * x + m[2] * y + m[4];
	            out[1] = m[1] * x + m[3] * y + m[5];
	            return out;
	        },
	        /**
	         * 求两个向量最小值
	         * @param  {Vector2} out
	         * @param  {Vector2} v1
	         * @param  {Vector2} v2
	         */
	        min: function (out, v1, v2) {
	            out[0] = Math.min(v1[0], v2[0]);
	            out[1] = Math.min(v1[1], v2[1]);
	            return out;
	        },
	        /**
	         * 求两个向量最大值
	         * @param  {Vector2} out
	         * @param  {Vector2} v1
	         * @param  {Vector2} v2
	         */
	        max: function (out, v1, v2) {
	            out[0] = Math.max(v1[0], v2[0]);
	            out[1] = Math.max(v1[1], v2[1]);
	            return out;
	        }
	    };
	
	    vector.length = vector.len;
	    vector.lengthSquare = vector.lenSquare;
	    vector.dist = vector.distance;
	    vector.distSquare = vector.distanceSquare;
	
	    module.exports = vector;
	


/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	/**
	 * @module zrender/mixin/Animatable
	 */
	
	
	    var Animator = __webpack_require__(16);
	    var util = __webpack_require__(4);
	    var isString = util.isString;
	    var isFunction = util.isFunction;
	    var isObject = util.isObject;
	    var log = __webpack_require__(20);
	
	    /**
	     * @alias modue:zrender/mixin/Animatable
	     * @constructor
	     */
	    var Animatable = function () {
	
	        /**
	         * @type {Array.<module:zrender/animation/Animator>}
	         * @readOnly
	         */
	        this.animators = [];
	    };
	
	    Animatable.prototype = {
	
	        constructor: Animatable,
	
	        /**
	         * 动画
	         *
	         * @param {string} path 需要添加动画的属性获取路径，可以通过a.b.c来获取深层的属性
	         * @param {boolean} [loop] 动画是否循环
	         * @return {module:zrender/animation/Animator}
	         * @example:
	         *     el.animate('style', false)
	         *         .when(1000, {x: 10} )
	         *         .done(function(){ // Animation done })
	         *         .start()
	         */
	        animate: function (path, loop) {
	            var target;
	            var animatingShape = false;
	            var el = this;
	            var zr = this.__zr;
	            if (path) {
	                var pathSplitted = path.split('.');
	                var prop = el;
	                // If animating shape
	                animatingShape = pathSplitted[0] === 'shape';
	                for (var i = 0, l = pathSplitted.length; i < l; i++) {
	                    if (!prop) {
	                        continue;
	                    }
	                    prop = prop[pathSplitted[i]];
	                }
	                if (prop) {
	                    target = prop;
	                }
	            }
	            else {
	                target = el;
	            }
	
	            if (!target) {
	                log(
	                    'Property "'
	                    + path
	                    + '" is not existed in element '
	                    + el.id
	                );
	                return;
	            }
	
	            var animators = el.animators;
	
	            var animator = new Animator(target, loop);
	
	            animator.during(function (target) {
	                el.dirty(animatingShape);
	            })
	            .done(function () {
	                // FIXME Animator will not be removed if use `Animator#stop` to stop animation
	                animators.splice(util.indexOf(animators, animator), 1);
	            });
	
	            animators.push(animator);
	
	            // If animate after added to the zrender
	            if (zr) {
	                zr.animation.addAnimator(animator);
	            }
	
	            return animator;
	        },
	
	        /**
	         * 停止动画
	         * @param {boolean} forwardToLast If move to last frame before stop
	         */
	        stopAnimation: function (forwardToLast) {
	            var animators = this.animators;
	            var len = animators.length;
	            for (var i = 0; i < len; i++) {
	                animators[i].stop(forwardToLast);
	            }
	            animators.length = 0;
	
	            return this;
	        },
	
	        /**
	         * @param {Object} target
	         * @param {number} [time=500] Time in ms
	         * @param {string} [easing='linear']
	         * @param {number} [delay=0]
	         * @param {Function} [callback]
	         *
	         * @example
	         *  // Animate position
	         *  el.animateTo({
	         *      position: [10, 10]
	         *  }, function () { // done })
	         *
	         *  // Animate shape, style and position in 100ms, delayed 100ms, with cubicOut easing
	         *  el.animateTo({
	         *      shape: {
	         *          width: 500
	         *      },
	         *      style: {
	         *          fill: 'red'
	         *      }
	         *      position: [10, 10]
	         *  }, 100, 100, 'cubicOut', function () { // done })
	         */
	         // TODO Return animation key
	        animateTo: function (target, time, delay, easing, callback) {
	            // animateTo(target, time, easing, callback);
	            if (isString(delay)) {
	                callback = easing;
	                easing = delay;
	                delay = 0;
	            }
	            // animateTo(target, time, delay, callback);
	            else if (isFunction(easing)) {
	                callback = easing;
	                easing = 'linear';
	                delay = 0;
	            }
	            // animateTo(target, time, callback);
	            else if (isFunction(delay)) {
	                callback = delay;
	                delay = 0;
	            }
	            // animateTo(target, callback)
	            else if (isFunction(time)) {
	                callback = time;
	                time = 500;
	            }
	            // animateTo(target)
	            else if (!time) {
	                time = 500;
	            }
	            // Stop all previous animations
	            this.stopAnimation();
	            this._animateToShallow('', this, target, time, delay, easing, callback);
	
	            // Animators may be removed immediately after start
	            // if there is nothing to animate
	            var animators = this.animators.slice();
	            var count = animators.length;
	            function done() {
	                count--;
	                if (!count) {
	                    callback && callback();
	                }
	            }
	
	            // No animators. This should be checked before animators[i].start(),
	            // because 'done' may be executed immediately if no need to animate.
	            if (!count) {
	                callback && callback();
	            }
	            // Start after all animators created
	            // Incase any animator is done immediately when all animation properties are not changed
	            for (var i = 0; i < animators.length; i++) {
	                animators[i]
	                    .done(done)
	                    .start(easing);
	            }
	        },
	
	        /**
	         * @private
	         * @param {string} path=''
	         * @param {Object} source=this
	         * @param {Object} target
	         * @param {number} [time=500]
	         * @param {number} [delay=0]
	         *
	         * @example
	         *  // Animate position
	         *  el._animateToShallow({
	         *      position: [10, 10]
	         *  })
	         *
	         *  // Animate shape, style and position in 100ms, delayed 100ms
	         *  el._animateToShallow({
	         *      shape: {
	         *          width: 500
	         *      },
	         *      style: {
	         *          fill: 'red'
	         *      }
	         *      position: [10, 10]
	         *  }, 100, 100)
	         */
	        _animateToShallow: function (path, source, target, time, delay) {
	            var objShallow = {};
	            var propertyCount = 0;
	            for (var name in target) {
	                if (source[name] != null) {
	                    if (isObject(target[name]) && !util.isArrayLike(target[name])) {
	                        this._animateToShallow(
	                            path ? path + '.' + name : name,
	                            source[name],
	                            target[name],
	                            time,
	                            delay
	                        );
	                    }
	                    else {
	                        objShallow[name] = target[name];
	                        propertyCount++;
	                    }
	                }
	                else if (target[name] != null) {
	                    // Attr directly if not has property
	                    // FIXME, if some property not needed for element ?
	                    if (!path) {
	                        this.attr(name, target[name]);
	                    }
	                    else {  // Shape or style
	                        var props = {};
	                        props[path] = {};
	                        props[path][name] = target[name];
	                        this.attr(props);
	                    }
	                }
	            }
	
	            if (propertyCount > 0) {
	                this.animate(path, false)
	                    .when(time == null ? 500 : time, objShallow)
	                    .delay(delay || 0);
	            }
	
	            return this;
	        }
	    };
	
	    module.exports = Animatable;


/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @module echarts/animation/Animator
	 */
	
	
	    var Clip = __webpack_require__(17);
	    var color = __webpack_require__(19);
	    var util = __webpack_require__(4);
	    var isArrayLike = util.isArrayLike;
	
	    var arraySlice = Array.prototype.slice;
	
	    function defaultGetter(target, key) {
	        return target[key];
	    }
	
	    function defaultSetter(target, key, value) {
	        target[key] = value;
	    }
	
	    /**
	     * @param  {number} p0
	     * @param  {number} p1
	     * @param  {number} percent
	     * @return {number}
	     */
	    function interpolateNumber(p0, p1, percent) {
	        return (p1 - p0) * percent + p0;
	    }
	
	    /**
	     * @param  {string} p0
	     * @param  {string} p1
	     * @param  {number} percent
	     * @return {string}
	     */
	    function interpolateString(p0, p1, percent) {
	        return percent > 0.5 ? p1 : p0;
	    }
	
	    /**
	     * @param  {Array} p0
	     * @param  {Array} p1
	     * @param  {number} percent
	     * @param  {Array} out
	     * @param  {number} arrDim
	     */
	    function interpolateArray(p0, p1, percent, out, arrDim) {
	        var len = p0.length;
	        if (arrDim == 1) {
	            for (var i = 0; i < len; i++) {
	                out[i] = interpolateNumber(p0[i], p1[i], percent);
	            }
	        }
	        else {
	            var len2 = p0[0].length;
	            for (var i = 0; i < len; i++) {
	                for (var j = 0; j < len2; j++) {
	                    out[i][j] = interpolateNumber(
	                        p0[i][j], p1[i][j], percent
	                    );
	                }
	            }
	        }
	    }
	
	    // arr0 is source array, arr1 is target array.
	    // Do some preprocess to avoid error happened when interpolating from arr0 to arr1
	    function fillArr(arr0, arr1, arrDim) {
	        var arr0Len = arr0.length;
	        var arr1Len = arr1.length;
	        if (arr0Len !== arr1Len) {
	            // FIXME Not work for TypedArray
	            var isPreviousLarger = arr0Len > arr1Len;
	            if (isPreviousLarger) {
	                // Cut the previous
	                arr0.length = arr1Len;
	            }
	            else {
	                // Fill the previous
	                for (var i = arr0Len; i < arr1Len; i++) {
	                    arr0.push(
	                        arrDim === 1 ? arr1[i] : arraySlice.call(arr1[i])
	                    );
	                }
	            }
	        }
	        // Handling NaN value
	        var len2 = arr0[0] && arr0[0].length;
	        for (var i = 0; i < arr0.length; i++) {
	            if (arrDim === 1) {
	                if (isNaN(arr0[i])) {
	                    arr0[i] = arr1[i];
	                }
	            }
	            else {
	                for (var j = 0; j < len2; j++) {
	                    if (isNaN(arr0[i][j])) {
	                        arr0[i][j] = arr1[i][j];
	                    }
	                }
	            }
	        }
	    }
	
	    /**
	     * @param  {Array} arr0
	     * @param  {Array} arr1
	     * @param  {number} arrDim
	     * @return {boolean}
	     */
	    function isArraySame(arr0, arr1, arrDim) {
	        if (arr0 === arr1) {
	            return true;
	        }
	        var len = arr0.length;
	        if (len !== arr1.length) {
	            return false;
	        }
	        if (arrDim === 1) {
	            for (var i = 0; i < len; i++) {
	                if (arr0[i] !== arr1[i]) {
	                    return false;
	                }
	            }
	        }
	        else {
	            var len2 = arr0[0].length;
	            for (var i = 0; i < len; i++) {
	                for (var j = 0; j < len2; j++) {
	                    if (arr0[i][j] !== arr1[i][j]) {
	                        return false;
	                    }
	                }
	            }
	        }
	        return true;
	    }
	
	    /**
	     * Catmull Rom interpolate array
	     * @param  {Array} p0
	     * @param  {Array} p1
	     * @param  {Array} p2
	     * @param  {Array} p3
	     * @param  {number} t
	     * @param  {number} t2
	     * @param  {number} t3
	     * @param  {Array} out
	     * @param  {number} arrDim
	     */
	    function catmullRomInterpolateArray(
	        p0, p1, p2, p3, t, t2, t3, out, arrDim
	    ) {
	        var len = p0.length;
	        if (arrDim == 1) {
	            for (var i = 0; i < len; i++) {
	                out[i] = catmullRomInterpolate(
	                    p0[i], p1[i], p2[i], p3[i], t, t2, t3
	                );
	            }
	        }
	        else {
	            var len2 = p0[0].length;
	            for (var i = 0; i < len; i++) {
	                for (var j = 0; j < len2; j++) {
	                    out[i][j] = catmullRomInterpolate(
	                        p0[i][j], p1[i][j], p2[i][j], p3[i][j],
	                        t, t2, t3
	                    );
	                }
	            }
	        }
	    }
	
	    /**
	     * Catmull Rom interpolate number
	     * @param  {number} p0
	     * @param  {number} p1
	     * @param  {number} p2
	     * @param  {number} p3
	     * @param  {number} t
	     * @param  {number} t2
	     * @param  {number} t3
	     * @return {number}
	     */
	    function catmullRomInterpolate(p0, p1, p2, p3, t, t2, t3) {
	        var v0 = (p2 - p0) * 0.5;
	        var v1 = (p3 - p1) * 0.5;
	        return (2 * (p1 - p2) + v0 + v1) * t3
	                + (-3 * (p1 - p2) - 2 * v0 - v1) * t2
	                + v0 * t + p1;
	    }
	
	    function cloneValue(value) {
	        if (isArrayLike(value)) {
	            var len = value.length;
	            if (isArrayLike(value[0])) {
	                var ret = [];
	                for (var i = 0; i < len; i++) {
	                    ret.push(arraySlice.call(value[i]));
	                }
	                return ret;
	            }
	
	            return arraySlice.call(value);
	        }
	
	        return value;
	    }
	
	    function rgba2String(rgba) {
	        rgba[0] = Math.floor(rgba[0]);
	        rgba[1] = Math.floor(rgba[1]);
	        rgba[2] = Math.floor(rgba[2]);
	
	        return 'rgba(' + rgba.join(',') + ')';
	    }
	
	    function createTrackClip (animator, easing, oneTrackDone, keyframes, propName) {
	        var getter = animator._getter;
	        var setter = animator._setter;
	        var useSpline = easing === 'spline';
	
	        var trackLen = keyframes.length;
	        if (!trackLen) {
	            return;
	        }
	        // Guess data type
	        var firstVal = keyframes[0].value;
	        var isValueArray = isArrayLike(firstVal);
	        var isValueColor = false;
	        var isValueString = false;
	
	        // For vertices morphing
	        var arrDim = (
	                isValueArray
	                && isArrayLike(firstVal[0])
	            )
	            ? 2 : 1;
	        var trackMaxTime;
	        // Sort keyframe as ascending
	        keyframes.sort(function(a, b) {
	            return a.time - b.time;
	        });
	
	        trackMaxTime = keyframes[trackLen - 1].time;
	        // Percents of each keyframe
	        var kfPercents = [];
	        // Value of each keyframe
	        var kfValues = [];
	        var prevValue = keyframes[0].value;
	        var isAllValueEqual = true;
	        for (var i = 0; i < trackLen; i++) {
	            kfPercents.push(keyframes[i].time / trackMaxTime);
	            // Assume value is a color when it is a string
	            var value = keyframes[i].value;
	
	            // Check if value is equal, deep check if value is array
	            if (!((isValueArray && isArraySame(value, prevValue, arrDim))
	                || (!isValueArray && value === prevValue))) {
	                isAllValueEqual = false;
	            }
	            prevValue = value;
	
	            // Try converting a string to a color array
	            if (typeof value == 'string') {
	                var colorArray = color.parse(value);
	                if (colorArray) {
	                    value = colorArray;
	                    isValueColor = true;
	                }
	                else {
	                    isValueString = true;
	                }
	            }
	            kfValues.push(value);
	        }
	        if (isAllValueEqual) {
	            return;
	        }
	
	        var lastValue = kfValues[trackLen - 1];
	        // Polyfill array and NaN value
	        for (var i = 0; i < trackLen - 1; i++) {
	            if (isValueArray) {
	                fillArr(kfValues[i], lastValue, arrDim);
	            }
	            else {
	                if (isNaN(kfValues[i]) && !isNaN(lastValue) && !isValueString && !isValueColor) {
	                    kfValues[i] = lastValue;
	                }
	            }
	        }
	        isValueArray && fillArr(getter(animator._target, propName), lastValue, arrDim);
	
	        // Cache the key of last frame to speed up when
	        // animation playback is sequency
	        var lastFrame = 0;
	        var lastFramePercent = 0;
	        var start;
	        var w;
	        var p0;
	        var p1;
	        var p2;
	        var p3;
	
	        if (isValueColor) {
	            var rgba = [0, 0, 0, 0];
	        }
	
	        var onframe = function (target, percent) {
	            // Find the range keyframes
	            // kf1-----kf2---------current--------kf3
	            // find kf2 and kf3 and do interpolation
	            var frame;
	            // In the easing function like elasticOut, percent may less than 0
	            if (percent < 0) {
	                frame = 0;
	            }
	            else if (percent < lastFramePercent) {
	                // Start from next key
	                // PENDING start from lastFrame ?
	                start = Math.min(lastFrame + 1, trackLen - 1);
	                for (frame = start; frame >= 0; frame--) {
	                    if (kfPercents[frame] <= percent) {
	                        break;
	                    }
	                }
	                // PENDING really need to do this ?
	                frame = Math.min(frame, trackLen - 2);
	            }
	            else {
	                for (frame = lastFrame; frame < trackLen; frame++) {
	                    if (kfPercents[frame] > percent) {
	                        break;
	                    }
	                }
	                frame = Math.min(frame - 1, trackLen - 2);
	            }
	            lastFrame = frame;
	            lastFramePercent = percent;
	
	            var range = (kfPercents[frame + 1] - kfPercents[frame]);
	            if (range === 0) {
	                return;
	            }
	            else {
	                w = (percent - kfPercents[frame]) / range;
	            }
	            if (useSpline) {
	                p1 = kfValues[frame];
	                p0 = kfValues[frame === 0 ? frame : frame - 1];
	                p2 = kfValues[frame > trackLen - 2 ? trackLen - 1 : frame + 1];
	                p3 = kfValues[frame > trackLen - 3 ? trackLen - 1 : frame + 2];
	                if (isValueArray) {
	                    catmullRomInterpolateArray(
	                        p0, p1, p2, p3, w, w * w, w * w * w,
	                        getter(target, propName),
	                        arrDim
	                    );
	                }
	                else {
	                    var value;
	                    if (isValueColor) {
	                        value = catmullRomInterpolateArray(
	                            p0, p1, p2, p3, w, w * w, w * w * w,
	                            rgba, 1
	                        );
	                        value = rgba2String(rgba);
	                    }
	                    else if (isValueString) {
	                        // String is step(0.5)
	                        return interpolateString(p1, p2, w);
	                    }
	                    else {
	                        value = catmullRomInterpolate(
	                            p0, p1, p2, p3, w, w * w, w * w * w
	                        );
	                    }
	                    setter(
	                        target,
	                        propName,
	                        value
	                    );
	                }
	            }
	            else {
	                if (isValueArray) {
	                    interpolateArray(
	                        kfValues[frame], kfValues[frame + 1], w,
	                        getter(target, propName),
	                        arrDim
	                    );
	                }
	                else {
	                    var value;
	                    if (isValueColor) {
	                        interpolateArray(
	                            kfValues[frame], kfValues[frame + 1], w,
	                            rgba, 1
	                        );
	                        value = rgba2String(rgba);
	                    }
	                    else if (isValueString) {
	                        // String is step(0.5)
	                        return interpolateString(kfValues[frame], kfValues[frame + 1], w);
	                    }
	                    else {
	                        value = interpolateNumber(kfValues[frame], kfValues[frame + 1], w);
	                    }
	                    setter(
	                        target,
	                        propName,
	                        value
	                    );
	                }
	            }
	        };
	
	        var clip = new Clip({
	            target: animator._target,
	            life: trackMaxTime,
	            loop: animator._loop,
	            delay: animator._delay,
	            onframe: onframe,
	            ondestroy: oneTrackDone
	        });
	
	        if (easing && easing !== 'spline') {
	            clip.easing = easing;
	        }
	
	        return clip;
	    }
	
	    /**
	     * @alias module:zrender/animation/Animator
	     * @constructor
	     * @param {Object} target
	     * @param {boolean} loop
	     * @param {Function} getter
	     * @param {Function} setter
	     */
	    var Animator = function(target, loop, getter, setter) {
	        this._tracks = {};
	        this._target = target;
	
	        this._loop = loop || false;
	
	        this._getter = getter || defaultGetter;
	        this._setter = setter || defaultSetter;
	
	        this._clipCount = 0;
	
	        this._delay = 0;
	
	        this._doneList = [];
	
	        this._onframeList = [];
	
	        this._clipList = [];
	    };
	
	    Animator.prototype = {
	        /**
	         * 设置动画关键帧
	         * @param  {number} time 关键帧时间，单位是ms
	         * @param  {Object} props 关键帧的属性值，key-value表示
	         * @return {module:zrender/animation/Animator}
	         */
	        when: function(time /* ms */, props) {
	            var tracks = this._tracks;
	            for (var propName in props) {
	                if (!tracks[propName]) {
	                    tracks[propName] = [];
	                    // Invalid value
	                    var value = this._getter(this._target, propName);
	                    if (value == null) {
	                        // zrLog('Invalid property ' + propName);
	                        continue;
	                    }
	                    // If time is 0
	                    //  Then props is given initialize value
	                    // Else
	                    //  Initialize value from current prop value
	                    if (time !== 0) {
	                        tracks[propName].push({
	                            time: 0,
	                            value: cloneValue(value)
	                        });
	                    }
	                }
	                tracks[propName].push({
	                    time: time,
	                    value: props[propName]
	                });
	            }
	            return this;
	        },
	        /**
	         * 添加动画每一帧的回调函数
	         * @param  {Function} callback
	         * @return {module:zrender/animation/Animator}
	         */
	        during: function (callback) {
	            this._onframeList.push(callback);
	            return this;
	        },
	
	        _doneCallback: function () {
	            // Clear all tracks
	            this._tracks = {};
	            // Clear all clips
	            this._clipList.length = 0;
	
	            var doneList = this._doneList;
	            var len = doneList.length;
	            for (var i = 0; i < len; i++) {
	                doneList[i].call(this);
	            }
	        },
	        /**
	         * 开始执行动画
	         * @param  {string|Function} easing
	         *         动画缓动函数，详见{@link module:zrender/animation/easing}
	         * @return {module:zrender/animation/Animator}
	         */
	        start: function (easing) {
	
	            var self = this;
	            var clipCount = 0;
	
	            var oneTrackDone = function() {
	                clipCount--;
	                if (!clipCount) {
	                    self._doneCallback();
	                }
	            };
	
	            var lastClip;
	            for (var propName in this._tracks) {
	                var clip = createTrackClip(
	                    this, easing, oneTrackDone,
	                    this._tracks[propName], propName
	                );
	                if (clip) {
	                    this._clipList.push(clip);
	                    clipCount++;
	
	                    // If start after added to animation
	                    if (this.animation) {
	                        this.animation.addClip(clip);
	                    }
	
	                    lastClip = clip;
	                }
	            }
	
	            // Add during callback on the last clip
	            if (lastClip) {
	                var oldOnFrame = lastClip.onframe;
	                lastClip.onframe = function (target, percent) {
	                    oldOnFrame(target, percent);
	
	                    for (var i = 0; i < self._onframeList.length; i++) {
	                        self._onframeList[i](target, percent);
	                    }
	                };
	            }
	
	            if (!clipCount) {
	                this._doneCallback();
	            }
	            return this;
	        },
	        /**
	         * 停止动画
	         * @param {boolean} forwardToLast If move to last frame before stop
	         */
	        stop: function (forwardToLast) {
	            var clipList = this._clipList;
	            var animation = this.animation;
	            for (var i = 0; i < clipList.length; i++) {
	                var clip = clipList[i];
	                if (forwardToLast) {
	                    // Move to last frame before stop
	                    clip.onframe(this._target, 1);
	                }
	                animation && animation.removeClip(clip);
	            }
	            clipList.length = 0;
	        },
	        /**
	         * 设置动画延迟开始的时间
	         * @param  {number} time 单位ms
	         * @return {module:zrender/animation/Animator}
	         */
	        delay: function (time) {
	            this._delay = time;
	            return this;
	        },
	        /**
	         * 添加动画结束的回调
	         * @param  {Function} cb
	         * @return {module:zrender/animation/Animator}
	         */
	        done: function(cb) {
	            if (cb) {
	                this._doneList.push(cb);
	            }
	            return this;
	        },
	
	        /**
	         * @return {Array.<module:zrender/animation/Clip>}
	         */
	        getClips: function () {
	            return this._clipList;
	        }
	    };
	
	    module.exports = Animator;


/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * 动画主控制器
	 * @config target 动画对象，可以是数组，如果是数组的话会批量分发onframe等事件
	 * @config life(1000) 动画时长
	 * @config delay(0) 动画延迟时间
	 * @config loop(true)
	 * @config gap(0) 循环的间隔时间
	 * @config onframe
	 * @config easing(optional)
	 * @config ondestroy(optional)
	 * @config onrestart(optional)
	 *
	 * TODO pause
	 */
	
	
	    var easingFuncs = __webpack_require__(18);
	
	    function Clip(options) {
	
	        this._target = options.target;
	
	        // 生命周期
	        this._life = options.life || 1000;
	        // 延时
	        this._delay = options.delay || 0;
	        // 开始时间
	        // this._startTime = new Date().getTime() + this._delay;// 单位毫秒
	        this._initialized = false;
	
	        // 是否循环
	        this.loop = options.loop == null ? false : options.loop;
	
	        this.gap = options.gap || 0;
	
	        this.easing = options.easing || 'Linear';
	
	        this.onframe = options.onframe;
	        this.ondestroy = options.ondestroy;
	        this.onrestart = options.onrestart;
	    }
	
	    Clip.prototype = {
	
	        constructor: Clip,
	
	        step: function (globalTime) {
	            // Set startTime on first step, or _startTime may has milleseconds different between clips
	            // PENDING
	            if (!this._initialized) {
	                this._startTime = globalTime + this._delay;
	                this._initialized = true;
	            }
	
	            var percent = (globalTime - this._startTime) / this._life;
	
	            // 还没开始
	            if (percent < 0) {
	                return;
	            }
	
	            percent = Math.min(percent, 1);
	
	            var easing = this.easing;
	            var easingFunc = typeof easing == 'string' ? easingFuncs[easing] : easing;
	            var schedule = typeof easingFunc === 'function'
	                ? easingFunc(percent)
	                : percent;
	
	            this.fire('frame', schedule);
	
	            // 结束
	            if (percent == 1) {
	                if (this.loop) {
	                    this.restart (globalTime);
	                    // 重新开始周期
	                    // 抛出而不是直接调用事件直到 stage.update 后再统一调用这些事件
	                    return 'restart';
	                }
	
	                // 动画完成将这个控制器标识为待删除
	                // 在Animation.update中进行批量删除
	                this._needsRemove = true;
	                return 'destroy';
	            }
	
	            return null;
	        },
	
	        restart: function (globalTime) {
	            var remainder = (globalTime - this._startTime) % this._life;
	            this._startTime = globalTime - remainder + this.gap;
	
	            this._needsRemove = false;
	        },
	
	        fire: function(eventType, arg) {
	            eventType = 'on' + eventType;
	            if (this[eventType]) {
	                this[eventType](this._target, arg);
	            }
	        }
	    };
	
	    module.exports = Clip;
	


/***/ },
/* 18 */
/***/ function(module, exports) {

	/**
	 * 缓动代码来自 https://github.com/sole/tween.js/blob/master/src/Tween.js
	 * @see http://sole.github.io/tween.js/examples/03_graphs.html
	 * @exports zrender/animation/easing
	 */
	
	    var easing = {
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        linear: function (k) {
	            return k;
	        },
	
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        quadraticIn: function (k) {
	            return k * k;
	        },
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        quadraticOut: function (k) {
	            return k * (2 - k);
	        },
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        quadraticInOut: function (k) {
	            if ((k *= 2) < 1) {
	                return 0.5 * k * k;
	            }
	            return -0.5 * (--k * (k - 2) - 1);
	        },
	
	        // 三次方的缓动（t^3）
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        cubicIn: function (k) {
	            return k * k * k;
	        },
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        cubicOut: function (k) {
	            return --k * k * k + 1;
	        },
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        cubicInOut: function (k) {
	            if ((k *= 2) < 1) {
	                return 0.5 * k * k * k;
	            }
	            return 0.5 * ((k -= 2) * k * k + 2);
	        },
	
	        // 四次方的缓动（t^4）
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        quarticIn: function (k) {
	            return k * k * k * k;
	        },
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        quarticOut: function (k) {
	            return 1 - (--k * k * k * k);
	        },
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        quarticInOut: function (k) {
	            if ((k *= 2) < 1) {
	                return 0.5 * k * k * k * k;
	            }
	            return -0.5 * ((k -= 2) * k * k * k - 2);
	        },
	
	        // 五次方的缓动（t^5）
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        quinticIn: function (k) {
	            return k * k * k * k * k;
	        },
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        quinticOut: function (k) {
	            return --k * k * k * k * k + 1;
	        },
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        quinticInOut: function (k) {
	            if ((k *= 2) < 1) {
	                return 0.5 * k * k * k * k * k;
	            }
	            return 0.5 * ((k -= 2) * k * k * k * k + 2);
	        },
	
	        // 正弦曲线的缓动（sin(t)）
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        sinusoidalIn: function (k) {
	            return 1 - Math.cos(k * Math.PI / 2);
	        },
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        sinusoidalOut: function (k) {
	            return Math.sin(k * Math.PI / 2);
	        },
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        sinusoidalInOut: function (k) {
	            return 0.5 * (1 - Math.cos(Math.PI * k));
	        },
	
	        // 指数曲线的缓动（2^t）
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        exponentialIn: function (k) {
	            return k === 0 ? 0 : Math.pow(1024, k - 1);
	        },
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        exponentialOut: function (k) {
	            return k === 1 ? 1 : 1 - Math.pow(2, -10 * k);
	        },
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        exponentialInOut: function (k) {
	            if (k === 0) {
	                return 0;
	            }
	            if (k === 1) {
	                return 1;
	            }
	            if ((k *= 2) < 1) {
	                return 0.5 * Math.pow(1024, k - 1);
	            }
	            return 0.5 * (-Math.pow(2, -10 * (k - 1)) + 2);
	        },
	
	        // 圆形曲线的缓动（sqrt(1-t^2)）
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        circularIn: function (k) {
	            return 1 - Math.sqrt(1 - k * k);
	        },
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        circularOut: function (k) {
	            return Math.sqrt(1 - (--k * k));
	        },
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        circularInOut: function (k) {
	            if ((k *= 2) < 1) {
	                return -0.5 * (Math.sqrt(1 - k * k) - 1);
	            }
	            return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);
	        },
	
	        // 创建类似于弹簧在停止前来回振荡的动画
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        elasticIn: function (k) {
	            var s;
	            var a = 0.1;
	            var p = 0.4;
	            if (k === 0) {
	                return 0;
	            }
	            if (k === 1) {
	                return 1;
	            }
	            if (!a || a < 1) {
	                a = 1; s = p / 4;
	            }
	            else {
	                s = p * Math.asin(1 / a) / (2 * Math.PI);
	            }
	            return -(a * Math.pow(2, 10 * (k -= 1)) *
	                        Math.sin((k - s) * (2 * Math.PI) / p));
	        },
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        elasticOut: function (k) {
	            var s;
	            var a = 0.1;
	            var p = 0.4;
	            if (k === 0) {
	                return 0;
	            }
	            if (k === 1) {
	                return 1;
	            }
	            if (!a || a < 1) {
	                a = 1; s = p / 4;
	            }
	            else {
	                s = p * Math.asin(1 / a) / (2 * Math.PI);
	            }
	            return (a * Math.pow(2, -10 * k) *
	                    Math.sin((k - s) * (2 * Math.PI) / p) + 1);
	        },
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        elasticInOut: function (k) {
	            var s;
	            var a = 0.1;
	            var p = 0.4;
	            if (k === 0) {
	                return 0;
	            }
	            if (k === 1) {
	                return 1;
	            }
	            if (!a || a < 1) {
	                a = 1; s = p / 4;
	            }
	            else {
	                s = p * Math.asin(1 / a) / (2 * Math.PI);
	            }
	            if ((k *= 2) < 1) {
	                return -0.5 * (a * Math.pow(2, 10 * (k -= 1))
	                    * Math.sin((k - s) * (2 * Math.PI) / p));
	            }
	            return a * Math.pow(2, -10 * (k -= 1))
	                    * Math.sin((k - s) * (2 * Math.PI) / p) * 0.5 + 1;
	
	        },
	
	        // 在某一动画开始沿指示的路径进行动画处理前稍稍收回该动画的移动
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        backIn: function (k) {
	            var s = 1.70158;
	            return k * k * ((s + 1) * k - s);
	        },
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        backOut: function (k) {
	            var s = 1.70158;
	            return --k * k * ((s + 1) * k + s) + 1;
	        },
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        backInOut: function (k) {
	            var s = 1.70158 * 1.525;
	            if ((k *= 2) < 1) {
	                return 0.5 * (k * k * ((s + 1) * k - s));
	            }
	            return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);
	        },
	
	        // 创建弹跳效果
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        bounceIn: function (k) {
	            return 1 - easing.bounceOut(1 - k);
	        },
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        bounceOut: function (k) {
	            if (k < (1 / 2.75)) {
	                return 7.5625 * k * k;
	            }
	            else if (k < (2 / 2.75)) {
	                return 7.5625 * (k -= (1.5 / 2.75)) * k + 0.75;
	            }
	            else if (k < (2.5 / 2.75)) {
	                return 7.5625 * (k -= (2.25 / 2.75)) * k + 0.9375;
	            }
	            else {
	                return 7.5625 * (k -= (2.625 / 2.75)) * k + 0.984375;
	            }
	        },
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        bounceInOut: function (k) {
	            if (k < 0.5) {
	                return easing.bounceIn(k * 2) * 0.5;
	            }
	            return easing.bounceOut(k * 2 - 1) * 0.5 + 0.5;
	        }
	    };
	
	    module.exports = easing;
	
	


/***/ },
/* 19 */
/***/ function(module, exports) {

	/**
	 * @module zrender/tool/color
	 */
	
	
	    var kCSSColorTable = {
	        'transparent': [0,0,0,0], 'aliceblue': [240,248,255,1],
	        'antiquewhite': [250,235,215,1], 'aqua': [0,255,255,1],
	        'aquamarine': [127,255,212,1], 'azure': [240,255,255,1],
	        'beige': [245,245,220,1], 'bisque': [255,228,196,1],
	        'black': [0,0,0,1], 'blanchedalmond': [255,235,205,1],
	        'blue': [0,0,255,1], 'blueviolet': [138,43,226,1],
	        'brown': [165,42,42,1], 'burlywood': [222,184,135,1],
	        'cadetblue': [95,158,160,1], 'chartreuse': [127,255,0,1],
	        'chocolate': [210,105,30,1], 'coral': [255,127,80,1],
	        'cornflowerblue': [100,149,237,1], 'cornsilk': [255,248,220,1],
	        'crimson': [220,20,60,1], 'cyan': [0,255,255,1],
	        'darkblue': [0,0,139,1], 'darkcyan': [0,139,139,1],
	        'darkgoldenrod': [184,134,11,1], 'darkgray': [169,169,169,1],
	        'darkgreen': [0,100,0,1], 'darkgrey': [169,169,169,1],
	        'darkkhaki': [189,183,107,1], 'darkmagenta': [139,0,139,1],
	        'darkolivegreen': [85,107,47,1], 'darkorange': [255,140,0,1],
	        'darkorchid': [153,50,204,1], 'darkred': [139,0,0,1],
	        'darksalmon': [233,150,122,1], 'darkseagreen': [143,188,143,1],
	        'darkslateblue': [72,61,139,1], 'darkslategray': [47,79,79,1],
	        'darkslategrey': [47,79,79,1], 'darkturquoise': [0,206,209,1],
	        'darkviolet': [148,0,211,1], 'deeppink': [255,20,147,1],
	        'deepskyblue': [0,191,255,1], 'dimgray': [105,105,105,1],
	        'dimgrey': [105,105,105,1], 'dodgerblue': [30,144,255,1],
	        'firebrick': [178,34,34,1], 'floralwhite': [255,250,240,1],
	        'forestgreen': [34,139,34,1], 'fuchsia': [255,0,255,1],
	        'gainsboro': [220,220,220,1], 'ghostwhite': [248,248,255,1],
	        'gold': [255,215,0,1], 'goldenrod': [218,165,32,1],
	        'gray': [128,128,128,1], 'green': [0,128,0,1],
	        'greenyellow': [173,255,47,1], 'grey': [128,128,128,1],
	        'honeydew': [240,255,240,1], 'hotpink': [255,105,180,1],
	        'indianred': [205,92,92,1], 'indigo': [75,0,130,1],
	        'ivory': [255,255,240,1], 'khaki': [240,230,140,1],
	        'lavender': [230,230,250,1], 'lavenderblush': [255,240,245,1],
	        'lawngreen': [124,252,0,1], 'lemonchiffon': [255,250,205,1],
	        'lightblue': [173,216,230,1], 'lightcoral': [240,128,128,1],
	        'lightcyan': [224,255,255,1], 'lightgoldenrodyellow': [250,250,210,1],
	        'lightgray': [211,211,211,1], 'lightgreen': [144,238,144,1],
	        'lightgrey': [211,211,211,1], 'lightpink': [255,182,193,1],
	        'lightsalmon': [255,160,122,1], 'lightseagreen': [32,178,170,1],
	        'lightskyblue': [135,206,250,1], 'lightslategray': [119,136,153,1],
	        'lightslategrey': [119,136,153,1], 'lightsteelblue': [176,196,222,1],
	        'lightyellow': [255,255,224,1], 'lime': [0,255,0,1],
	        'limegreen': [50,205,50,1], 'linen': [250,240,230,1],
	        'magenta': [255,0,255,1], 'maroon': [128,0,0,1],
	        'mediumaquamarine': [102,205,170,1], 'mediumblue': [0,0,205,1],
	        'mediumorchid': [186,85,211,1], 'mediumpurple': [147,112,219,1],
	        'mediumseagreen': [60,179,113,1], 'mediumslateblue': [123,104,238,1],
	        'mediumspringgreen': [0,250,154,1], 'mediumturquoise': [72,209,204,1],
	        'mediumvioletred': [199,21,133,1], 'midnightblue': [25,25,112,1],
	        'mintcream': [245,255,250,1], 'mistyrose': [255,228,225,1],
	        'moccasin': [255,228,181,1], 'navajowhite': [255,222,173,1],
	        'navy': [0,0,128,1], 'oldlace': [253,245,230,1],
	        'olive': [128,128,0,1], 'olivedrab': [107,142,35,1],
	        'orange': [255,165,0,1], 'orangered': [255,69,0,1],
	        'orchid': [218,112,214,1], 'palegoldenrod': [238,232,170,1],
	        'palegreen': [152,251,152,1], 'paleturquoise': [175,238,238,1],
	        'palevioletred': [219,112,147,1], 'papayawhip': [255,239,213,1],
	        'peachpuff': [255,218,185,1], 'peru': [205,133,63,1],
	        'pink': [255,192,203,1], 'plum': [221,160,221,1],
	        'powderblue': [176,224,230,1], 'purple': [128,0,128,1],
	        'red': [255,0,0,1], 'rosybrown': [188,143,143,1],
	        'royalblue': [65,105,225,1], 'saddlebrown': [139,69,19,1],
	        'salmon': [250,128,114,1], 'sandybrown': [244,164,96,1],
	        'seagreen': [46,139,87,1], 'seashell': [255,245,238,1],
	        'sienna': [160,82,45,1], 'silver': [192,192,192,1],
	        'skyblue': [135,206,235,1], 'slateblue': [106,90,205,1],
	        'slategray': [112,128,144,1], 'slategrey': [112,128,144,1],
	        'snow': [255,250,250,1], 'springgreen': [0,255,127,1],
	        'steelblue': [70,130,180,1], 'tan': [210,180,140,1],
	        'teal': [0,128,128,1], 'thistle': [216,191,216,1],
	        'tomato': [255,99,71,1], 'turquoise': [64,224,208,1],
	        'violet': [238,130,238,1], 'wheat': [245,222,179,1],
	        'white': [255,255,255,1], 'whitesmoke': [245,245,245,1],
	        'yellow': [255,255,0,1], 'yellowgreen': [154,205,50,1]
	    };
	
	    function clampCssByte(i) {  // Clamp to integer 0 .. 255.
	        i = Math.round(i);  // Seems to be what Chrome does (vs truncation).
	        return i < 0 ? 0 : i > 255 ? 255 : i;
	    }
	
	    function clampCssAngle(i) {  // Clamp to integer 0 .. 360.
	        i = Math.round(i);  // Seems to be what Chrome does (vs truncation).
	        return i < 0 ? 0 : i > 360 ? 360 : i;
	    }
	
	    function clampCssFloat(f) {  // Clamp to float 0.0 .. 1.0.
	        return f < 0 ? 0 : f > 1 ? 1 : f;
	    }
	
	    function parseCssInt(str) {  // int or percentage.
	        if (str.length && str.charAt(str.length - 1) === '%') {
	            return clampCssByte(parseFloat(str) / 100 * 255);
	        }
	        return clampCssByte(parseInt(str, 10));
	    }
	
	    function parseCssFloat(str) {  // float or percentage.
	        if (str.length && str.charAt(str.length - 1) === '%') {
	            return clampCssFloat(parseFloat(str) / 100);
	        }
	        return clampCssFloat(parseFloat(str));
	    }
	
	    function cssHueToRgb(m1, m2, h) {
	        if (h < 0) {
	            h += 1;
	        }
	        else if (h > 1) {
	            h -= 1;
	        }
	
	        if (h * 6 < 1) {
	            return m1 + (m2 - m1) * h * 6;
	        }
	        if (h * 2 < 1) {
	            return m2;
	        }
	        if (h * 3 < 2) {
	            return m1 + (m2 - m1) * (2/3 - h) * 6;
	        }
	        return m1;
	    }
	
	    function lerp(a, b, p) {
	        return a + (b - a) * p;
	    }
	
	    /**
	     * @param {string} colorStr
	     * @return {Array.<number>}
	     * @memberOf module:zrender/util/color
	     */
	    function parse(colorStr) {
	        if (!colorStr) {
	            return;
	        }
	        // colorStr may be not string
	        colorStr = colorStr + '';
	        // Remove all whitespace, not compliant, but should just be more accepting.
	        var str = colorStr.replace(/ /g, '').toLowerCase();
	
	        // Color keywords (and transparent) lookup.
	        if (str in kCSSColorTable) {
	            return kCSSColorTable[str].slice();  // dup.
	        }
	
	        // #abc and #abc123 syntax.
	        if (str.charAt(0) === '#') {
	            if (str.length === 4) {
	                var iv = parseInt(str.substr(1), 16);  // TODO(deanm): Stricter parsing.
	                if (!(iv >= 0 && iv <= 0xfff)) {
	                    return;  // Covers NaN.
	                }
	                return [
	                    ((iv & 0xf00) >> 4) | ((iv & 0xf00) >> 8),
	                    (iv & 0xf0) | ((iv & 0xf0) >> 4),
	                    (iv & 0xf) | ((iv & 0xf) << 4),
	                    1
	                ];
	            }
	            else if (str.length === 7) {
	                var iv = parseInt(str.substr(1), 16);  // TODO(deanm): Stricter parsing.
	                if (!(iv >= 0 && iv <= 0xffffff)) {
	                    return;  // Covers NaN.
	                }
	                return [
	                    (iv & 0xff0000) >> 16,
	                    (iv & 0xff00) >> 8,
	                    iv & 0xff,
	                    1
	                ];
	            }
	
	            return;
	        }
	        var op = str.indexOf('('), ep = str.indexOf(')');
	        if (op !== -1 && ep + 1 === str.length) {
	            var fname = str.substr(0, op);
	            var params = str.substr(op + 1, ep - (op + 1)).split(',');
	            var alpha = 1;  // To allow case fallthrough.
	            switch (fname) {
	                case 'rgba':
	                    if (params.length !== 4) {
	                        return;
	                    }
	                    alpha = parseCssFloat(params.pop()); // jshint ignore:line
	                // Fall through.
	                case 'rgb':
	                    if (params.length !== 3) {
	                        return;
	                    }
	                    return [
	                        parseCssInt(params[0]),
	                        parseCssInt(params[1]),
	                        parseCssInt(params[2]),
	                        alpha
	                    ];
	                case 'hsla':
	                    if (params.length !== 4) {
	                        return;
	                    }
	                    params[3] = parseCssFloat(params[3]);
	                    return hsla2rgba(params);
	                case 'hsl':
	                    if (params.length !== 3) {
	                        return;
	                    }
	                    return hsla2rgba(params);
	                default:
	                    return;
	            }
	        }
	
	        return;
	    }
	
	    /**
	     * @param {Array.<number>} hsla
	     * @return {Array.<number>} rgba
	     */
	    function hsla2rgba(hsla) {
	        var h = (((parseFloat(hsla[0]) % 360) + 360) % 360) / 360;  // 0 .. 1
	        // NOTE(deanm): According to the CSS spec s/l should only be
	        // percentages, but we don't bother and let float or percentage.
	        var s = parseCssFloat(hsla[1]);
	        var l = parseCssFloat(hsla[2]);
	        var m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;
	        var m1 = l * 2 - m2;
	
	        var rgba = [
	            clampCssByte(cssHueToRgb(m1, m2, h + 1 / 3) * 255),
	            clampCssByte(cssHueToRgb(m1, m2, h) * 255),
	            clampCssByte(cssHueToRgb(m1, m2, h - 1 / 3) * 255)
	        ];
	
	        if (hsla.length === 4) {
	            rgba[3] = hsla[3];
	        }
	
	        return rgba;
	    }
	
	    /**
	     * @param {Array.<number>} rgba
	     * @return {Array.<number>} hsla
	     */
	    function rgba2hsla(rgba) {
	        if (!rgba) {
	            return;
	        }
	
	        // RGB from 0 to 255
	        var R = rgba[0] / 255;
	        var G = rgba[1] / 255;
	        var B = rgba[2] / 255;
	
	        var vMin = Math.min(R, G, B); // Min. value of RGB
	        var vMax = Math.max(R, G, B); // Max. value of RGB
	        var delta = vMax - vMin; // Delta RGB value
	
	        var L = (vMax + vMin) / 2;
	        var H;
	        var S;
	        // HSL results from 0 to 1
	        if (delta === 0) {
	            H = 0;
	            S = 0;
	        }
	        else {
	            if (L < 0.5) {
	                S = delta / (vMax + vMin);
	            }
	            else {
	                S = delta / (2 - vMax - vMin);
	            }
	
	            var deltaR = (((vMax - R) / 6) + (delta / 2)) / delta;
	            var deltaG = (((vMax - G) / 6) + (delta / 2)) / delta;
	            var deltaB = (((vMax - B) / 6) + (delta / 2)) / delta;
	
	            if (R === vMax) {
	                H = deltaB - deltaG;
	            }
	            else if (G === vMax) {
	                H = (1 / 3) + deltaR - deltaB;
	            }
	            else if (B === vMax) {
	                H = (2 / 3) + deltaG - deltaR;
	            }
	
	            if (H < 0) {
	                H += 1;
	            }
	
	            if (H > 1) {
	                H -= 1;
	            }
	        }
	
	        var hsla = [H * 360, S, L];
	
	        if (rgba[3] != null) {
	            hsla.push(rgba[3]);
	        }
	
	        return hsla;
	    }
	
	    /**
	     * @param {string} color
	     * @param {number} level
	     * @return {string}
	     * @memberOf module:zrender/util/color
	     */
	    function lift(color, level) {
	        var colorArr = parse(color);
	        if (colorArr) {
	            for (var i = 0; i < 3; i++) {
	                if (level < 0) {
	                    colorArr[i] = colorArr[i] * (1 - level) | 0;
	                }
	                else {
	                    colorArr[i] = ((255 - colorArr[i]) * level + colorArr[i]) | 0;
	                }
	            }
	            return stringify(colorArr, colorArr.length === 4 ? 'rgba' : 'rgb');
	        }
	    }
	
	    /**
	     * @param {string} color
	     * @return {string}
	     * @memberOf module:zrender/util/color
	     */
	    function toHex(color, level) {
	        var colorArr = parse(color);
	        if (colorArr) {
	            return ((1 << 24) + (colorArr[0] << 16) + (colorArr[1] << 8) + (+colorArr[2])).toString(16).slice(1);
	        }
	    }
	
	    /**
	     * Map value to color. Faster than mapToColor methods because color is represented by rgba array
	     * @param {number} normalizedValue A float between 0 and 1.
	     * @param {Array.<Array.<number>>} colors List of rgba color array
	     * @param {Array.<number>} [out] Mapped gba color array
	     * @return {Array.<number>}
	     */
	    function fastMapToColor(normalizedValue, colors, out) {
	        if (!(colors && colors.length)
	            || !(normalizedValue >= 0 && normalizedValue <= 1)
	        ) {
	            return;
	        }
	        out = out || [0, 0, 0, 0];
	        var value = normalizedValue * (colors.length - 1);
	        var leftIndex = Math.floor(value);
	        var rightIndex = Math.ceil(value);
	        var leftColor = colors[leftIndex];
	        var rightColor = colors[rightIndex];
	        var dv = value - leftIndex;
	        out[0] = clampCssByte(lerp(leftColor[0], rightColor[0], dv));
	        out[1] = clampCssByte(lerp(leftColor[1], rightColor[1], dv));
	        out[2] = clampCssByte(lerp(leftColor[2], rightColor[2], dv));
	        out[3] = clampCssByte(lerp(leftColor[3], rightColor[3], dv));
	        return out;
	    }
	    /**
	     * @param {number} normalizedValue A float between 0 and 1.
	     * @param {Array.<string>} colors Color list.
	     * @param {boolean=} fullOutput Default false.
	     * @return {(string|Object)} Result color. If fullOutput,
	     *                           return {color: ..., leftIndex: ..., rightIndex: ..., value: ...},
	     * @memberOf module:zrender/util/color
	     */
	    function mapToColor(normalizedValue, colors, fullOutput) {
	        if (!(colors && colors.length)
	            || !(normalizedValue >= 0 && normalizedValue <= 1)
	        ) {
	            return;
	        }
	
	        var value = normalizedValue * (colors.length - 1);
	        var leftIndex = Math.floor(value);
	        var rightIndex = Math.ceil(value);
	        var leftColor = parse(colors[leftIndex]);
	        var rightColor = parse(colors[rightIndex]);
	        var dv = value - leftIndex;
	
	        var color = stringify(
	            [
	                clampCssByte(lerp(leftColor[0], rightColor[0], dv)),
	                clampCssByte(lerp(leftColor[1], rightColor[1], dv)),
	                clampCssByte(lerp(leftColor[2], rightColor[2], dv)),
	                clampCssFloat(lerp(leftColor[3], rightColor[3], dv))
	            ],
	            'rgba'
	        );
	
	        return fullOutput
	            ? {
	                color: color,
	                leftIndex: leftIndex,
	                rightIndex: rightIndex,
	                value: value
	            }
	            : color;
	    }
	
	    /**
	     * @param {string} color
	     * @param {number=} h 0 ~ 360, ignore when null.
	     * @param {number=} s 0 ~ 1, ignore when null.
	     * @param {number=} l 0 ~ 1, ignore when null.
	     * @return {string} Color string in rgba format.
	     * @memberOf module:zrender/util/color
	     */
	    function modifyHSL(color, h, s, l) {
	        color = parse(color);
	
	        if (color) {
	            color = rgba2hsla(color);
	            h != null && (color[0] = clampCssAngle(h));
	            s != null && (color[1] = parseCssFloat(s));
	            l != null && (color[2] = parseCssFloat(l));
	
	            return stringify(hsla2rgba(color), 'rgba');
	        }
	    }
	
	    /**
	     * @param {string} color
	     * @param {number=} alpha 0 ~ 1
	     * @return {string} Color string in rgba format.
	     * @memberOf module:zrender/util/color
	     */
	    function modifyAlpha(color, alpha) {
	        color = parse(color);
	
	        if (color && alpha != null) {
	            color[3] = clampCssFloat(alpha);
	            return stringify(color, 'rgba');
	        }
	    }
	
	    /**
	     * @param {Array.<string>} colors Color list.
	     * @param {string} type 'rgba', 'hsva', ...
	     * @return {string} Result color.
	     */
	    function stringify(arrColor, type) {
	        var colorStr = arrColor[0] + ',' + arrColor[1] + ',' + arrColor[2];
	        if (type === 'rgba' || type === 'hsva' || type === 'hsla') {
	            colorStr += ',' + arrColor[3];
	        }
	        return type + '(' + colorStr + ')';
	    }
	
	    module.exports = {
	        parse: parse,
	        lift: lift,
	        toHex: toHex,
	        fastMapToColor: fastMapToColor,
	        mapToColor: mapToColor,
	        modifyHSL: modifyHSL,
	        modifyAlpha: modifyAlpha,
	        stringify: stringify
	    };
	
	


/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	
	        var config = __webpack_require__(21);
	
	        /**
	         * @exports zrender/tool/log
	         * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)
	         */
	        module.exports = function() {
	            if (config.debugMode === 0) {
	                return;
	            }
	            else if (config.debugMode == 1) {
	                for (var k in arguments) {
	                    throw new Error(arguments[k]);
	                }
	            }
	            else if (config.debugMode > 1) {
	                for (var k in arguments) {
	                    console.log(arguments[k]);
	                }
	            }
	        };
	
	        /* for debug
	        return function(mes) {
	            document.getElementById('wrong-message').innerHTML =
	                mes + ' ' + (new Date() - 0)
	                + '<br/>' 
	                + document.getElementById('wrong-message').innerHTML;
	        };
	        */
	    


/***/ },
/* 21 */
/***/ function(module, exports) {

	
	    var dpr = 1;
	    // If in browser environment
	    if (typeof window !== 'undefined') {
	        dpr = Math.max(window.devicePixelRatio || 1, 1);
	    }
	    /**
	     * config默认配置项
	     * @exports zrender/config
	     * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)
	     */
	    var config = {
	        /**
	         * debug日志选项：catchBrushException为true下有效
	         * 0 : 不生成debug数据，发布用
	         * 1 : 异常抛出，调试用
	         * 2 : 控制台输出，调试用
	         */
	        debugMode: 0,
	
	        // retina 屏幕优化
	        devicePixelRatio: dpr
	    };
	    module.exports = config;
	
	


/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Mixin for drawing text in a element bounding rect
	 * @module zrender/mixin/RectText
	 */
	
	
	
	    var textContain = __webpack_require__(23);
	    var BoundingRect = __webpack_require__(24);
	
	    var tmpRect = new BoundingRect();
	
	    var RectText = function () {};
	
	    function parsePercent(value, maxValue) {
	        if (typeof value === 'string') {
	            if (value.lastIndexOf('%') >= 0) {
	                return parseFloat(value) / 100 * maxValue;
	            }
	            return parseFloat(value);
	        }
	        return value;
	    }
	
	    RectText.prototype = {
	
	        constructor: RectText,
	
	        /**
	         * Draw text in a rect with specified position.
	         * @param  {CanvasRenderingContext} ctx
	         * @param  {Object} rect Displayable rect
	         * @return {Object} textRect Alternative precalculated text bounding rect
	         */
	        drawRectText: function (ctx, rect, textRect) {
	            var style = this.style;
	            var text = style.text;
	            // Convert to string
	            text != null && (text += '');
	            if (!text) {
	                return;
	            }
	
	            // FIXME
	            ctx.save();
	
	            var x;
	            var y;
	            var textPosition = style.textPosition;
	            var distance = style.textDistance;
	            var align = style.textAlign;
	            var font = style.textFont || style.font;
	            var baseline = style.textBaseline;
	            var verticalAlign = style.textVerticalAlign;
	
	            textRect = textRect || textContain.getBoundingRect(text, font, align, baseline);
	
	            // Transform rect to view space
	            var transform = this.transform;
	            if (!style.textTransform) {
	                if (transform) {
	                    tmpRect.copy(rect);
	                    tmpRect.applyTransform(transform);
	                    rect = tmpRect;
	                }
	            }
	            else {
	                this.setTransform(ctx);
	            }
	
	            // Text position represented by coord
	            if (textPosition instanceof Array) {
	                // Percent
	                x = rect.x + parsePercent(textPosition[0], rect.width);
	                y = rect.y + parsePercent(textPosition[1], rect.height);
	                align = align || 'left';
	                baseline = baseline || 'top';
	
	                if (verticalAlign) {
	                    switch (verticalAlign) {
	                        case 'middle':
	                            y -= textRect.height / 2 - textRect.lineHeight / 2;
	                            break;
	                        case 'bottom':
	                            y -= textRect.height - textRect.lineHeight / 2;
	                            break;
	                        default:
	                            y += textRect.lineHeight / 2;
	                    }
	                    // Force bseline to be middle
	                    baseline = 'middle';
	                }
	            }
	            else {
	                var res = textContain.adjustTextPositionOnRect(
	                    textPosition, rect, textRect, distance
	                );
	                x = res.x;
	                y = res.y;
	                // Default align and baseline when has textPosition
	                align = align || res.textAlign;
	                baseline = baseline || res.textBaseline;
	            }
	
	            // Use canvas default left textAlign. Giving invalid value will cause state not change
	            ctx.textAlign = align || 'left';
	            // Use canvas default alphabetic baseline
	            ctx.textBaseline = baseline || 'alphabetic';
	
	            var textFill = style.textFill;
	            var textStroke = style.textStroke;
	            textFill && (ctx.fillStyle = textFill);
	            textStroke && (ctx.strokeStyle = textStroke);
	
	            // TODO Invalid font
	            ctx.font = font || '12px sans-serif';
	
	            // Text shadow
	            // Always set shadowBlur and shadowOffset to avoid leak from displayable
	            ctx.shadowBlur = style.textShadowBlur;
	            ctx.shadowColor = style.textShadowColor || 'transparent';
	            ctx.shadowOffsetX = style.textShadowOffsetX;
	            ctx.shadowOffsetY = style.textShadowOffsetY;
	
	            var textLines = text.split('\n');
	
	            if (style.textRotation) {
	                transform && ctx.translate(transform[4], transform[5]);
	                ctx.rotate(style.textRotation);
	                transform && ctx.translate(-transform[4], -transform[5]);
	            }
	
	            for (var i = 0; i < textLines.length; i++) {
	                textFill && ctx.fillText(textLines[i], x, y);
	                textStroke && ctx.strokeText(textLines[i], x, y);
	                y += textRect.lineHeight;
	            }
	
	            ctx.restore();
	        }
	    };
	
	    module.exports = RectText;


/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	
	
	    var textWidthCache = {};
	    var textWidthCacheCounter = 0;
	    var TEXT_CACHE_MAX = 5000;
	
	    var util = __webpack_require__(4);
	    var BoundingRect = __webpack_require__(24);
	    var retrieve = util.retrieve;
	
	    function getTextWidth(text, textFont) {
	        var key = text + ':' + textFont;
	        if (textWidthCache[key]) {
	            return textWidthCache[key];
	        }
	
	        var textLines = (text + '').split('\n');
	        var width = 0;
	
	        for (var i = 0, l = textLines.length; i < l; i++) {
	            // measureText 可以被覆盖以兼容不支持 Canvas 的环境
	            width = Math.max(textContain.measureText(textLines[i], textFont).width, width);
	        }
	
	        if (textWidthCacheCounter > TEXT_CACHE_MAX) {
	            textWidthCacheCounter = 0;
	            textWidthCache = {};
	        }
	        textWidthCacheCounter++;
	        textWidthCache[key] = width;
	
	        return width;
	    }
	
	    function getTextRect(text, textFont, textAlign, textBaseline) {
	        var textLineLen = ((text || '') + '').split('\n').length;
	
	        var width = getTextWidth(text, textFont);
	        // FIXME 高度计算比较粗暴
	        var lineHeight = getTextWidth('国', textFont);
	        var height = textLineLen * lineHeight;
	
	        var rect = new BoundingRect(0, 0, width, height);
	        // Text has a special line height property
	        rect.lineHeight = lineHeight;
	
	        switch (textBaseline) {
	            case 'bottom':
	            case 'alphabetic':
	                rect.y -= lineHeight;
	                break;
	            case 'middle':
	                rect.y -= lineHeight / 2;
	                break;
	            // case 'hanging':
	            // case 'top':
	        }
	
	        // FIXME Right to left language
	        switch (textAlign) {
	            case 'end':
	            case 'right':
	                rect.x -= rect.width;
	                break;
	            case 'center':
	                rect.x -= rect.width / 2;
	                break;
	            // case 'start':
	            // case 'left':
	        }
	
	        return rect;
	    }
	
	    function adjustTextPositionOnRect(textPosition, rect, textRect, distance) {
	
	        var x = rect.x;
	        var y = rect.y;
	
	        var height = rect.height;
	        var width = rect.width;
	
	        var textHeight = textRect.height;
	
	        var halfHeight = height / 2 - textHeight / 2;
	
	        var textAlign = 'left';
	
	        switch (textPosition) {
	            case 'left':
	                x -= distance;
	                y += halfHeight;
	                textAlign = 'right';
	                break;
	            case 'right':
	                x += distance + width;
	                y += halfHeight;
	                textAlign = 'left';
	                break;
	            case 'top':
	                x += width / 2;
	                y -= distance + textHeight;
	                textAlign = 'center';
	                break;
	            case 'bottom':
	                x += width / 2;
	                y += height + distance;
	                textAlign = 'center';
	                break;
	            case 'inside':
	                x += width / 2;
	                y += halfHeight;
	                textAlign = 'center';
	                break;
	            case 'insideLeft':
	                x += distance;
	                y += halfHeight;
	                textAlign = 'left';
	                break;
	            case 'insideRight':
	                x += width - distance;
	                y += halfHeight;
	                textAlign = 'right';
	                break;
	            case 'insideTop':
	                x += width / 2;
	                y += distance;
	                textAlign = 'center';
	                break;
	            case 'insideBottom':
	                x += width / 2;
	                y += height - textHeight - distance;
	                textAlign = 'center';
	                break;
	            case 'insideTopLeft':
	                x += distance;
	                y += distance;
	                textAlign = 'left';
	                break;
	            case 'insideTopRight':
	                x += width - distance;
	                y += distance;
	                textAlign = 'right';
	                break;
	            case 'insideBottomLeft':
	                x += distance;
	                y += height - textHeight - distance;
	                break;
	            case 'insideBottomRight':
	                x += width - distance;
	                y += height - textHeight - distance;
	                textAlign = 'right';
	                break;
	        }
	
	        return {
	            x: x,
	            y: y,
	            textAlign: textAlign,
	            textBaseline: 'top'
	        };
	    }
	
	    /**
	     * Show ellipsis if overflow.
	     *
	     * @param  {string} text
	     * @param  {string} containerWidth
	     * @param  {string} textFont
	     * @param  {number} [ellipsis='...']
	     * @param  {Object} [options]
	     * @param  {number} [options.maxIterations=3]
	     * @param  {number} [options.minChar=0] If truncate result are less
	     *                  then minChar, ellipsis will not show, which is
	     *                  better for user hint in some cases.
	     * @param  {number} [options.placeholder=''] When all truncated, use the placeholder.
	     * @return {string}
	     */
	    function truncateText(text, containerWidth, textFont, ellipsis, options) {
	        if (!containerWidth) {
	            return '';
	        }
	
	        options = options || {};
	
	        ellipsis = retrieve(ellipsis, '...');
	        var maxIterations = retrieve(options.maxIterations, 2);
	        var minChar = retrieve(options.minChar, 0);
	        // FIXME
	        // Other languages?
	        var cnCharWidth = getTextWidth('国', textFont);
	        // FIXME
	        // Consider proportional font?
	        var ascCharWidth = getTextWidth('a', textFont);
	        var placeholder = retrieve(options.placeholder, '');
	
	        // Example 1: minChar: 3, text: 'asdfzxcv', truncate result: 'asdf', but not: 'a...'.
	        // Example 2: minChar: 3, text: '维度', truncate result: '维', but not: '...'.
	        var contentWidth = containerWidth = Math.max(0, containerWidth - 1); // Reserve some gap.
	        for (var i = 0; i < minChar && contentWidth >= ascCharWidth; i++) {
	            contentWidth -= ascCharWidth;
	        }
	
	        var ellipsisWidth = getTextWidth(ellipsis);
	        if (ellipsisWidth > contentWidth) {
	            ellipsis = '';
	            ellipsisWidth = 0;
	        }
	
	        contentWidth = containerWidth - ellipsisWidth;
	
	        var textLines = (text + '').split('\n');
	
	        for (var i = 0, len = textLines.length; i < len; i++) {
	            var textLine = textLines[i];
	            var lineWidth = getTextWidth(textLine, textFont);
	
	            if (lineWidth <= containerWidth) {
	                continue;
	            }
	
	            for (var j = 0;; j++) {
	                if (lineWidth <= contentWidth || j >= maxIterations) {
	                    textLine += ellipsis;
	                    break;
	                }
	
	                var subLength = j === 0
	                    ? estimateLength(textLine, contentWidth, ascCharWidth, cnCharWidth)
	                    : lineWidth > 0
	                    ? Math.floor(textLine.length * contentWidth / lineWidth)
	                    : 0;
	
	                textLine = textLine.substr(0, subLength);
	                lineWidth = getTextWidth(textLine, textFont);
	            }
	
	            if (textLine === '') {
	                textLine = placeholder;
	            }
	
	            textLines[i] = textLine;
	        }
	
	        return textLines.join('\n');
	    }
	
	    function estimateLength(text, contentWidth, ascCharWidth, cnCharWidth) {
	        var width = 0;
	        var i = 0;
	        for (var len = text.length; i < len && width < contentWidth; i++) {
	            var charCode = text.charCodeAt(i);
	            width += (0 <= charCode && charCode <= 127) ? ascCharWidth : cnCharWidth;
	        }
	        return i;
	    }
	
	    var textContain = {
	
	        getWidth: getTextWidth,
	
	        getBoundingRect: getTextRect,
	
	        adjustTextPositionOnRect: adjustTextPositionOnRect,
	
	        truncateText: truncateText,
	
	        measureText: function (text, textFont) {
	            var ctx = util.getContext();
	            ctx.font = textFont || '12px sans-serif';
	            return ctx.measureText(text);
	        }
	    };
	
	    module.exports = textContain;


/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	/**
	 * @module echarts/core/BoundingRect
	 */
	
	
	    var vec2 = __webpack_require__(14);
	    var matrix = __webpack_require__(13);
	
	    var v2ApplyTransform = vec2.applyTransform;
	    var mathMin = Math.min;
	    var mathAbs = Math.abs;
	    var mathMax = Math.max;
	    /**
	     * @alias module:echarts/core/BoundingRect
	     */
	    function BoundingRect(x, y, width, height) {
	        /**
	         * @type {number}
	         */
	        this.x = x;
	        /**
	         * @type {number}
	         */
	        this.y = y;
	        /**
	         * @type {number}
	         */
	        this.width = width;
	        /**
	         * @type {number}
	         */
	        this.height = height;
	    }
	
	    BoundingRect.prototype = {
	
	        constructor: BoundingRect,
	
	        /**
	         * @param {module:echarts/core/BoundingRect} other
	         */
	        union: function (other) {
	            var x = mathMin(other.x, this.x);
	            var y = mathMin(other.y, this.y);
	
	            this.width = mathMax(
	                    other.x + other.width,
	                    this.x + this.width
	                ) - x;
	            this.height = mathMax(
	                    other.y + other.height,
	                    this.y + this.height
	                ) - y;
	            this.x = x;
	            this.y = y;
	        },
	
	        /**
	         * @param {Array.<number>} m
	         * @methods
	         */
	        applyTransform: (function () {
	            var min = [];
	            var max = [];
	            return function (m) {
	                // In case usage like this
	                // el.getBoundingRect().applyTransform(el.transform)
	                // And element has no transform
	                if (!m) {
	                    return;
	                }
	                min[0] = this.x;
	                min[1] = this.y;
	                max[0] = this.x + this.width;
	                max[1] = this.y + this.height;
	
	                v2ApplyTransform(min, min, m);
	                v2ApplyTransform(max, max, m);
	
	                this.x = mathMin(min[0], max[0]);
	                this.y = mathMin(min[1], max[1]);
	                this.width = mathAbs(max[0] - min[0]);
	                this.height = mathAbs(max[1] - min[1]);
	            };
	        })(),
	
	        /**
	         * Calculate matrix of transforming from self to target rect
	         * @param  {module:zrender/core/BoundingRect} b
	         * @return {Array.<number>}
	         */
	        calculateTransform: function (b) {
	            var a = this;
	            var sx = b.width / a.width;
	            var sy = b.height / a.height;
	
	            var m = matrix.create();
	
	            // 矩阵右乘
	            matrix.translate(m, m, [-a.x, -a.y]);
	            matrix.scale(m, m, [sx, sy]);
	            matrix.translate(m, m, [b.x, b.y]);
	
	            return m;
	        },
	
	        /**
	         * @param {(module:echarts/core/BoundingRect|Object)} b
	         * @return {boolean}
	         */
	        intersect: function (b) {
	            var a = this;
	            var ax0 = a.x;
	            var ax1 = a.x + a.width;
	            var ay0 = a.y;
	            var ay1 = a.y + a.height;
	
	            var bx0 = b.x;
	            var bx1 = b.x + b.width;
	            var by0 = b.y;
	            var by1 = b.y + b.height;
	
	            return ! (ax1 < bx0 || bx1 < ax0 || ay1 < by0 || by1 < ay0);
	        },
	
	        contain: function (x, y) {
	            var rect = this;
	            return x >= rect.x
	                && x <= (rect.x + rect.width)
	                && y >= rect.y
	                && y <= (rect.y + rect.height);
	        },
	
	        /**
	         * @return {module:echarts/core/BoundingRect}
	         */
	        clone: function () {
	            return new BoundingRect(this.x, this.y, this.width, this.height);
	        },
	
	        /**
	         * Copy from another rect
	         */
	        copy: function (other) {
	            this.x = other.x;
	            this.y = other.y;
	            this.width = other.width;
	            this.height = other.height;
	        }
	    };
	
	    module.exports = BoundingRect;


/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	/**
	 * Path 代理，可以在`buildPath`中用于替代`ctx`, 会保存每个path操作的命令到pathCommands属性中
	 * 可以用于 isInsidePath 判断以及获取boundingRect
	 *
	 * @module zrender/core/PathProxy
	 * @author Yi Shen (http://www.github.com/pissang)
	 */
	
	 // TODO getTotalLength, getPointAtLength
	
	
	    var curve = __webpack_require__(26);
	    var vec2 = __webpack_require__(14);
	    var bbox = __webpack_require__(27);
	    var BoundingRect = __webpack_require__(24);
	    var dpr = __webpack_require__(21).devicePixelRatio;
	
	    var CMD = {
	        M: 1,
	        L: 2,
	        C: 3,
	        Q: 4,
	        A: 5,
	        Z: 6,
	        // Rect
	        R: 7
	    };
	
	    var min = [];
	    var max = [];
	    var min2 = [];
	    var max2 = [];
	    var mathMin = Math.min;
	    var mathMax = Math.max;
	    var mathCos = Math.cos;
	    var mathSin = Math.sin;
	    var mathSqrt = Math.sqrt;
	    var mathAbs = Math.abs;
	
	    var hasTypedArray = typeof Float32Array != 'undefined';
	
	    /**
	     * @alias module:zrender/core/PathProxy
	     * @constructor
	     */
	    var PathProxy = function () {
	
	        /**
	         * Path data. Stored as flat array
	         * @type {Array.<Object>}
	         */
	        this.data = [];
	
	        this._len = 0;
	
	        this._ctx = null;
	
	        this._xi = 0;
	        this._yi = 0;
	
	        this._x0 = 0;
	        this._y0 = 0;
	
	        // Unit x, Unit y. Provide for avoiding drawing that too short line segment
	        this._ux = 0;
	        this._uy = 0;
	    };
	
	    /**
	     * 快速计算Path包围盒（并不是最小包围盒）
	     * @return {Object}
	     */
	    PathProxy.prototype = {
	
	        constructor: PathProxy,
	
	        _lineDash: null,
	
	        _dashOffset: 0,
	
	        _dashIdx: 0,
	
	        _dashSum: 0,
	
	        /**
	         * @readOnly
	         */
	        setScale: function (sx, sy) {
	            this._ux = mathAbs(1 / dpr / sx) || 0;
	            this._uy = mathAbs(1 / dpr / sy) || 0;
	        },
	
	        getContext: function () {
	            return this._ctx;
	        },
	
	        /**
	         * @param  {CanvasRenderingContext2D} ctx
	         * @return {module:zrender/core/PathProxy}
	         */
	        beginPath: function (ctx) {
	
	            this._ctx = ctx;
	
	            ctx && ctx.beginPath();
	
	            ctx && (this.dpr = ctx.dpr);
	
	            // Reset
	            this._len = 0;
	
	            if (this._lineDash) {
	                this._lineDash = null;
	
	                this._dashOffset = 0;
	            }
	
	            return this;
	        },
	
	        /**
	         * @param  {number} x
	         * @param  {number} y
	         * @return {module:zrender/core/PathProxy}
	         */
	        moveTo: function (x, y) {
	            this.addData(CMD.M, x, y);
	            this._ctx && this._ctx.moveTo(x, y);
	
	            // x0, y0, xi, yi 是记录在 _dashedXXXXTo 方法中使用
	            // xi, yi 记录当前点, x0, y0 在 closePath 的时候回到起始点。
	            // 有可能在 beginPath 之后直接调用 lineTo，这时候 x0, y0 需要
	            // 在 lineTo 方法中记录，这里先不考虑这种情况，dashed line 也只在 IE10- 中不支持
	            this._x0 = x;
	            this._y0 = y;
	
	            this._xi = x;
	            this._yi = y;
	
	            return this;
	        },
	
	        /**
	         * @param  {number} x
	         * @param  {number} y
	         * @return {module:zrender/core/PathProxy}
	         */
	        lineTo: function (x, y) {
	            var exceedUnit = mathAbs(x - this._xi) > this._ux
	                || mathAbs(y - this._yi) > this._uy
	                // Force draw the first segment
	                || this._len < 5;
	
	            this.addData(CMD.L, x, y);
	
	            if (this._ctx && exceedUnit) {
	                this._needsDash() ? this._dashedLineTo(x, y)
	                    : this._ctx.lineTo(x, y);
	            }
	            if (exceedUnit) {
	                this._xi = x;
	                this._yi = y;
	            }
	
	            return this;
	        },
	
	        /**
	         * @param  {number} x1
	         * @param  {number} y1
	         * @param  {number} x2
	         * @param  {number} y2
	         * @param  {number} x3
	         * @param  {number} y3
	         * @return {module:zrender/core/PathProxy}
	         */
	        bezierCurveTo: function (x1, y1, x2, y2, x3, y3) {
	            this.addData(CMD.C, x1, y1, x2, y2, x3, y3);
	            if (this._ctx) {
	                this._needsDash() ? this._dashedBezierTo(x1, y1, x2, y2, x3, y3)
	                    : this._ctx.bezierCurveTo(x1, y1, x2, y2, x3, y3);
	            }
	            this._xi = x3;
	            this._yi = y3;
	            return this;
	        },
	
	        /**
	         * @param  {number} x1
	         * @param  {number} y1
	         * @param  {number} x2
	         * @param  {number} y2
	         * @return {module:zrender/core/PathProxy}
	         */
	        quadraticCurveTo: function (x1, y1, x2, y2) {
	            this.addData(CMD.Q, x1, y1, x2, y2);
	            if (this._ctx) {
	                this._needsDash() ? this._dashedQuadraticTo(x1, y1, x2, y2)
	                    : this._ctx.quadraticCurveTo(x1, y1, x2, y2);
	            }
	            this._xi = x2;
	            this._yi = y2;
	            return this;
	        },
	
	        /**
	         * @param  {number} cx
	         * @param  {number} cy
	         * @param  {number} r
	         * @param  {number} startAngle
	         * @param  {number} endAngle
	         * @param  {boolean} anticlockwise
	         * @return {module:zrender/core/PathProxy}
	         */
	        arc: function (cx, cy, r, startAngle, endAngle, anticlockwise) {
	            this.addData(
	                CMD.A, cx, cy, r, r, startAngle, endAngle - startAngle, 0, anticlockwise ? 0 : 1
	            );
	            this._ctx && this._ctx.arc(cx, cy, r, startAngle, endAngle, anticlockwise);
	
	            this._xi = mathCos(endAngle) * r + cx;
	            this._xi = mathSin(endAngle) * r + cx;
	            return this;
	        },
	
	        // TODO
	        arcTo: function (x1, y1, x2, y2, radius) {
	            if (this._ctx) {
	                this._ctx.arcTo(x1, y1, x2, y2, radius);
	            }
	            return this;
	        },
	
	        // TODO
	        rect: function (x, y, w, h) {
	            this._ctx && this._ctx.rect(x, y, w, h);
	            this.addData(CMD.R, x, y, w, h);
	            return this;
	        },
	
	        /**
	         * @return {module:zrender/core/PathProxy}
	         */
	        closePath: function () {
	            this.addData(CMD.Z);
	
	            var ctx = this._ctx;
	            var x0 = this._x0;
	            var y0 = this._y0;
	            if (ctx) {
	                this._needsDash() && this._dashedLineTo(x0, y0);
	                ctx.closePath();
	            }
	
	            this._xi = x0;
	            this._yi = y0;
	            return this;
	        },
	
	        /**
	         * Context 从外部传入，因为有可能是 rebuildPath 完之后再 fill。
	         * stroke 同样
	         * @param {CanvasRenderingContext2D} ctx
	         * @return {module:zrender/core/PathProxy}
	         */
	        fill: function (ctx) {
	            ctx && ctx.fill();
	            this.toStatic();
	        },
	
	        /**
	         * @param {CanvasRenderingContext2D} ctx
	         * @return {module:zrender/core/PathProxy}
	         */
	        stroke: function (ctx) {
	            ctx && ctx.stroke();
	            this.toStatic();
	        },
	
	        /**
	         * 必须在其它绘制命令前调用
	         * Must be invoked before all other path drawing methods
	         * @return {module:zrender/core/PathProxy}
	         */
	        setLineDash: function (lineDash) {
	            if (lineDash instanceof Array) {
	                this._lineDash = lineDash;
	
	                this._dashIdx = 0;
	
	                var lineDashSum = 0;
	                for (var i = 0; i < lineDash.length; i++) {
	                    lineDashSum += lineDash[i];
	                }
	                this._dashSum = lineDashSum;
	            }
	            return this;
	        },
	
	        /**
	         * 必须在其它绘制命令前调用
	         * Must be invoked before all other path drawing methods
	         * @return {module:zrender/core/PathProxy}
	         */
	        setLineDashOffset: function (offset) {
	            this._dashOffset = offset;
	            return this;
	        },
	
	        /**
	         *
	         * @return {boolean}
	         */
	        len: function () {
	            return this._len;
	        },
	
	        /**
	         * 直接设置 Path 数据
	         */
	        setData: function (data) {
	
	            var len = data.length;
	
	            if (! (this.data && this.data.length == len) && hasTypedArray) {
	                this.data = new Float32Array(len);
	            }
	
	            for (var i = 0; i < len; i++) {
	                this.data[i] = data[i];
	            }
	
	            this._len = len;
	        },
	
	        /**
	         * 添加子路径
	         * @param {module:zrender/core/PathProxy|Array.<module:zrender/core/PathProxy>} path
	         */
	        appendPath: function (path) {
	            if (!(path instanceof Array)) {
	                path = [path];
	            }
	            var len = path.length;
	            var appendSize = 0;
	            var offset = this._len;
	            for (var i = 0; i < len; i++) {
	                appendSize += path[i].len();
	            }
	            if (hasTypedArray && (this.data instanceof Float32Array)) {
	                this.data = new Float32Array(offset + appendSize);
	            }
	            for (var i = 0; i < len; i++) {
	                var appendPathData = path[i].data;
	                for (var k = 0; k < appendPathData.length; k++) {
	                    this.data[offset++] = appendPathData[k];
	                }
	            }
	            this._len = offset;
	        },
	
	        /**
	         * 填充 Path 数据。
	         * 尽量复用而不申明新的数组。大部分图形重绘的指令数据长度都是不变的。
	         */
	        addData: function (cmd) {
	            var data = this.data;
	            if (this._len + arguments.length > data.length) {
	                // 因为之前的数组已经转换成静态的 Float32Array
	                // 所以不够用时需要扩展一个新的动态数组
	                this._expandData();
	                data = this.data;
	            }
	            for (var i = 0; i < arguments.length; i++) {
	                data[this._len++] = arguments[i];
	            }
	
	            this._prevCmd = cmd;
	        },
	
	        _expandData: function () {
	            // Only if data is Float32Array
	            if (!(this.data instanceof Array)) {
	                var newData = [];
	                for (var i = 0; i < this._len; i++) {
	                    newData[i] = this.data[i];
	                }
	                this.data = newData;
	            }
	        },
	
	        /**
	         * If needs js implemented dashed line
	         * @return {boolean}
	         * @private
	         */
	        _needsDash: function () {
	            return this._lineDash;
	        },
	
	        _dashedLineTo: function (x1, y1) {
	            var dashSum = this._dashSum;
	            var offset = this._dashOffset;
	            var lineDash = this._lineDash;
	            var ctx = this._ctx;
	
	            var x0 = this._xi;
	            var y0 = this._yi;
	            var dx = x1 - x0;
	            var dy = y1 - y0;
	            var dist = mathSqrt(dx * dx + dy * dy);
	            var x = x0;
	            var y = y0;
	            var dash;
	            var nDash = lineDash.length;
	            var idx;
	            dx /= dist;
	            dy /= dist;
	
	            if (offset < 0) {
	                // Convert to positive offset
	                offset = dashSum + offset;
	            }
	            offset %= dashSum;
	            x -= offset * dx;
	            y -= offset * dy;
	
	            while ((dx > 0 && x <= x1) || (dx < 0 && x >= x1)
	            || (dx == 0 && ((dy > 0 && y <= y1) || (dy < 0 && y >= y1)))) {
	                idx = this._dashIdx;
	                dash = lineDash[idx];
	                x += dx * dash;
	                y += dy * dash;
	                this._dashIdx = (idx + 1) % nDash;
	                // Skip positive offset
	                if ((dx > 0 && x < x0) || (dx < 0 && x > x0) || (dy > 0 && y < y0) || (dy < 0 && y > y0)) {
	                    continue;
	                }
	                ctx[idx % 2 ? 'moveTo' : 'lineTo'](
	                    dx >= 0 ? mathMin(x, x1) : mathMax(x, x1),
	                    dy >= 0 ? mathMin(y, y1) : mathMax(y, y1)
	                );
	            }
	            // Offset for next lineTo
	            dx = x - x1;
	            dy = y - y1;
	            this._dashOffset = -mathSqrt(dx * dx + dy * dy);
	        },
	
	        // Not accurate dashed line to
	        _dashedBezierTo: function (x1, y1, x2, y2, x3, y3) {
	            var dashSum = this._dashSum;
	            var offset = this._dashOffset;
	            var lineDash = this._lineDash;
	            var ctx = this._ctx;
	
	            var x0 = this._xi;
	            var y0 = this._yi;
	            var t;
	            var dx;
	            var dy;
	            var cubicAt = curve.cubicAt;
	            var bezierLen = 0;
	            var idx = this._dashIdx;
	            var nDash = lineDash.length;
	
	            var x;
	            var y;
	
	            var tmpLen = 0;
	
	            if (offset < 0) {
	                // Convert to positive offset
	                offset = dashSum + offset;
	            }
	            offset %= dashSum;
	            // Bezier approx length
	            for (t = 0; t < 1; t += 0.1) {
	                dx = cubicAt(x0, x1, x2, x3, t + 0.1)
	                    - cubicAt(x0, x1, x2, x3, t);
	                dy = cubicAt(y0, y1, y2, y3, t + 0.1)
	                    - cubicAt(y0, y1, y2, y3, t);
	                bezierLen += mathSqrt(dx * dx + dy * dy);
	            }
	
	            // Find idx after add offset
	            for (; idx < nDash; idx++) {
	                tmpLen += lineDash[idx];
	                if (tmpLen > offset) {
	                    break;
	                }
	            }
	            t = (tmpLen - offset) / bezierLen;
	
	            while (t <= 1) {
	
	                x = cubicAt(x0, x1, x2, x3, t);
	                y = cubicAt(y0, y1, y2, y3, t);
	
	                // Use line to approximate dashed bezier
	                // Bad result if dash is long
	                idx % 2 ? ctx.moveTo(x, y)
	                    : ctx.lineTo(x, y);
	
	                t += lineDash[idx] / bezierLen;
	
	                idx = (idx + 1) % nDash;
	            }
	
	            // Finish the last segment and calculate the new offset
	            (idx % 2 !== 0) && ctx.lineTo(x3, y3);
	            dx = x3 - x;
	            dy = y3 - y;
	            this._dashOffset = -mathSqrt(dx * dx + dy * dy);
	        },
	
	        _dashedQuadraticTo: function (x1, y1, x2, y2) {
	            // Convert quadratic to cubic using degree elevation
	            var x3 = x2;
	            var y3 = y2;
	            x2 = (x2 + 2 * x1) / 3;
	            y2 = (y2 + 2 * y1) / 3;
	            x1 = (this._xi + 2 * x1) / 3;
	            y1 = (this._yi + 2 * y1) / 3;
	
	            this._dashedBezierTo(x1, y1, x2, y2, x3, y3);
	        },
	
	        /**
	         * 转成静态的 Float32Array 减少堆内存占用
	         * Convert dynamic array to static Float32Array
	         */
	        toStatic: function () {
	            var data = this.data;
	            if (data instanceof Array) {
	                data.length = this._len;
	                if (hasTypedArray) {
	                    this.data = new Float32Array(data);
	                }
	            }
	        },
	
	        /**
	         * @return {module:zrender/core/BoundingRect}
	         */
	        getBoundingRect: function () {
	            min[0] = min[1] = min2[0] = min2[1] = Number.MAX_VALUE;
	            max[0] = max[1] = max2[0] = max2[1] = -Number.MAX_VALUE;
	
	            var data = this.data;
	            var xi = 0;
	            var yi = 0;
	            var x0 = 0;
	            var y0 = 0;
	
	            for (var i = 0; i < data.length;) {
	                var cmd = data[i++];
	
	                if (i == 1) {
	                    // 如果第一个命令是 L, C, Q
	                    // 则 previous point 同绘制命令的第一个 point
	                    //
	                    // 第一个命令为 Arc 的情况下会在后面特殊处理
	                    xi = data[i];
	                    yi = data[i + 1];
	
	                    x0 = xi;
	                    y0 = yi;
	                }
	
	                switch (cmd) {
	                    case CMD.M:
	                        // moveTo 命令重新创建一个新的 subpath, 并且更新新的起点
	                        // 在 closePath 的时候使用
	                        x0 = data[i++];
	                        y0 = data[i++];
	                        xi = x0;
	                        yi = y0;
	                        min2[0] = x0;
	                        min2[1] = y0;
	                        max2[0] = x0;
	                        max2[1] = y0;
	                        break;
	                    case CMD.L:
	                        bbox.fromLine(xi, yi, data[i], data[i + 1], min2, max2);
	                        xi = data[i++];
	                        yi = data[i++];
	                        break;
	                    case CMD.C:
	                        bbox.fromCubic(
	                            xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1],
	                            min2, max2
	                        );
	                        xi = data[i++];
	                        yi = data[i++];
	                        break;
	                    case CMD.Q:
	                        bbox.fromQuadratic(
	                            xi, yi, data[i++], data[i++], data[i], data[i + 1],
	                            min2, max2
	                        );
	                        xi = data[i++];
	                        yi = data[i++];
	                        break;
	                    case CMD.A:
	                        // TODO Arc 判断的开销比较大
	                        var cx = data[i++];
	                        var cy = data[i++];
	                        var rx = data[i++];
	                        var ry = data[i++];
	                        var startAngle = data[i++];
	                        var endAngle = data[i++] + startAngle;
	                        // TODO Arc 旋转
	                        var psi = data[i++];
	                        var anticlockwise = 1 - data[i++];
	
	                        if (i == 1) {
	                            // 直接使用 arc 命令
	                            // 第一个命令起点还未定义
	                            x0 = mathCos(startAngle) * rx + cx;
	                            y0 = mathSin(startAngle) * ry + cy;
	                        }
	
	                        bbox.fromArc(
	                            cx, cy, rx, ry, startAngle, endAngle,
	                            anticlockwise, min2, max2
	                        );
	
	                        xi = mathCos(endAngle) * rx + cx;
	                        yi = mathSin(endAngle) * ry + cy;
	                        break;
	                    case CMD.R:
	                        x0 = xi = data[i++];
	                        y0 = yi = data[i++];
	                        var width = data[i++];
	                        var height = data[i++];
	                        // Use fromLine
	                        bbox.fromLine(x0, y0, x0 + width, y0 + height, min2, max2);
	                        break;
	                    case CMD.Z:
	                        xi = x0;
	                        yi = y0;
	                        break;
	                }
	
	                // Union
	                vec2.min(min, min, min2);
	                vec2.max(max, max, max2);
	            }
	
	            // No data
	            if (i === 0) {
	                min[0] = min[1] = max[0] = max[1] = 0;
	            }
	
	            return new BoundingRect(
	                min[0], min[1], max[0] - min[0], max[1] - min[1]
	            );
	        },
	
	        /**
	         * Rebuild path from current data
	         * Rebuild path will not consider javascript implemented line dash.
	         * @param {CanvasRenderingContext} ctx
	         */
	        rebuildPath: function (ctx) {
	            var d = this.data;
	            var x0, y0;
	            var xi, yi;
	            var x, y;
	            var ux = this._ux;
	            var uy = this._uy;
	            var len = this._len;
	            for (var i = 0; i < len;) {
	                var cmd = d[i++];
	
	                if (i == 1) {
	                    // 如果第一个命令是 L, C, Q
	                    // 则 previous point 同绘制命令的第一个 point
	                    //
	                    // 第一个命令为 Arc 的情况下会在后面特殊处理
	                    xi = d[i];
	                    yi = d[i + 1];
	
	                    x0 = xi;
	                    y0 = yi;
	                }
	                switch (cmd) {
	                    case CMD.M:
	                        x0 = xi = d[i++];
	                        y0 = yi = d[i++];
	                        ctx.moveTo(xi, yi);
	                        break;
	                    case CMD.L:
	                        x = d[i++];
	                        y = d[i++];
	                        // Not draw too small seg between
	                        if (mathAbs(x - xi) > ux || mathAbs(y - yi) > uy || i === len - 1) {
	                            ctx.lineTo(x, y);
	                            xi = x;
	                            yi = y;
	                        }
	                        break;
	                    case CMD.C:
	                        ctx.bezierCurveTo(
	                            d[i++], d[i++], d[i++], d[i++], d[i++], d[i++]
	                        );
	                        xi = d[i - 2];
	                        yi = d[i - 1];
	                        break;
	                    case CMD.Q:
	                        ctx.quadraticCurveTo(d[i++], d[i++], d[i++], d[i++]);
	                        xi = d[i - 2];
	                        yi = d[i - 1];
	                        break;
	                    case CMD.A:
	                        var cx = d[i++];
	                        var cy = d[i++];
	                        var rx = d[i++];
	                        var ry = d[i++];
	                        var theta = d[i++];
	                        var dTheta = d[i++];
	                        var psi = d[i++];
	                        var fs = d[i++];
	                        var r = (rx > ry) ? rx : ry;
	                        var scaleX = (rx > ry) ? 1 : rx / ry;
	                        var scaleY = (rx > ry) ? ry / rx : 1;
	                        var isEllipse = Math.abs(rx - ry) > 1e-3;
	                        var endAngle = theta + dTheta;
	                        if (isEllipse) {
	                            ctx.translate(cx, cy);
	                            ctx.rotate(psi);
	                            ctx.scale(scaleX, scaleY);
	                            ctx.arc(0, 0, r, theta, endAngle, 1 - fs);
	                            ctx.scale(1 / scaleX, 1 / scaleY);
	                            ctx.rotate(-psi);
	                            ctx.translate(-cx, -cy);
	                        }
	                        else {
	                            ctx.arc(cx, cy, r, theta, endAngle, 1 - fs);
	                        }
	
	                        if (i == 1) {
	                            // 直接使用 arc 命令
	                            // 第一个命令起点还未定义
	                            x0 = mathCos(theta) * rx + cx;
	                            y0 = mathSin(theta) * ry + cy;
	                        }
	                        xi = mathCos(endAngle) * rx + cx;
	                        yi = mathSin(endAngle) * ry + cy;
	                        break;
	                    case CMD.R:
	                        x0 = xi = d[i];
	                        y0 = yi = d[i + 1];
	                        ctx.rect(d[i++], d[i++], d[i++], d[i++]);
	                        break;
	                    case CMD.Z:
	                        ctx.closePath();
	                        xi = x0;
	                        yi = y0;
	                }
	            }
	        }
	    };
	
	    PathProxy.CMD = CMD;
	
	    module.exports = PathProxy;


/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	/**
	 * 曲线辅助模块
	 * @module zrender/core/curve
	 * @author pissang(https://www.github.com/pissang)
	 */
	
	
	    var vec2 = __webpack_require__(14);
	    var v2Create = vec2.create;
	    var v2DistSquare = vec2.distSquare;
	    var mathPow = Math.pow;
	    var mathSqrt = Math.sqrt;
	
	    var EPSILON = 1e-8;
	    var EPSILON_NUMERIC = 1e-4;
	
	    var THREE_SQRT = mathSqrt(3);
	    var ONE_THIRD = 1 / 3;
	
	    // 临时变量
	    var _v0 = v2Create();
	    var _v1 = v2Create();
	    var _v2 = v2Create();
	    // var _v3 = vec2.create();
	
	    function isAroundZero(val) {
	        return val > -EPSILON && val < EPSILON;
	    }
	    function isNotAroundZero(val) {
	        return val > EPSILON || val < -EPSILON;
	    }
	    /**
	     * 计算三次贝塞尔值
	     * @memberOf module:zrender/core/curve
	     * @param  {number} p0
	     * @param  {number} p1
	     * @param  {number} p2
	     * @param  {number} p3
	     * @param  {number} t
	     * @return {number}
	     */
	    function cubicAt(p0, p1, p2, p3, t) {
	        var onet = 1 - t;
	        return onet * onet * (onet * p0 + 3 * t * p1)
	             + t * t * (t * p3 + 3 * onet * p2);
	    }
	
	    /**
	     * 计算三次贝塞尔导数值
	     * @memberOf module:zrender/core/curve
	     * @param  {number} p0
	     * @param  {number} p1
	     * @param  {number} p2
	     * @param  {number} p3
	     * @param  {number} t
	     * @return {number}
	     */
	    function cubicDerivativeAt(p0, p1, p2, p3, t) {
	        var onet = 1 - t;
	        return 3 * (
	            ((p1 - p0) * onet + 2 * (p2 - p1) * t) * onet
	            + (p3 - p2) * t * t
	        );
	    }
	
	    /**
	     * 计算三次贝塞尔方程根，使用盛金公式
	     * @memberOf module:zrender/core/curve
	     * @param  {number} p0
	     * @param  {number} p1
	     * @param  {number} p2
	     * @param  {number} p3
	     * @param  {number} val
	     * @param  {Array.<number>} roots
	     * @return {number} 有效根数目
	     */
	    function cubicRootAt(p0, p1, p2, p3, val, roots) {
	        // Evaluate roots of cubic functions
	        var a = p3 + 3 * (p1 - p2) - p0;
	        var b = 3 * (p2 - p1 * 2 + p0);
	        var c = 3 * (p1  - p0);
	        var d = p0 - val;
	
	        var A = b * b - 3 * a * c;
	        var B = b * c - 9 * a * d;
	        var C = c * c - 3 * b * d;
	
	        var n = 0;
	
	        if (isAroundZero(A) && isAroundZero(B)) {
	            if (isAroundZero(b)) {
	                roots[0] = 0;
	            }
	            else {
	                var t1 = -c / b;  //t1, t2, t3, b is not zero
	                if (t1 >= 0 && t1 <= 1) {
	                    roots[n++] = t1;
	                }
	            }
	        }
	        else {
	            var disc = B * B - 4 * A * C;
	
	            if (isAroundZero(disc)) {
	                var K = B / A;
	                var t1 = -b / a + K;  // t1, a is not zero
	                var t2 = -K / 2;  // t2, t3
	                if (t1 >= 0 && t1 <= 1) {
	                    roots[n++] = t1;
	                }
	                if (t2 >= 0 && t2 <= 1) {
	                    roots[n++] = t2;
	                }
	            }
	            else if (disc > 0) {
	                var discSqrt = mathSqrt(disc);
	                var Y1 = A * b + 1.5 * a * (-B + discSqrt);
	                var Y2 = A * b + 1.5 * a * (-B - discSqrt);
	                if (Y1 < 0) {
	                    Y1 = -mathPow(-Y1, ONE_THIRD);
	                }
	                else {
	                    Y1 = mathPow(Y1, ONE_THIRD);
	                }
	                if (Y2 < 0) {
	                    Y2 = -mathPow(-Y2, ONE_THIRD);
	                }
	                else {
	                    Y2 = mathPow(Y2, ONE_THIRD);
	                }
	                var t1 = (-b - (Y1 + Y2)) / (3 * a);
	                if (t1 >= 0 && t1 <= 1) {
	                    roots[n++] = t1;
	                }
	            }
	            else {
	                var T = (2 * A * b - 3 * a * B) / (2 * mathSqrt(A * A * A));
	                var theta = Math.acos(T) / 3;
	                var ASqrt = mathSqrt(A);
	                var tmp = Math.cos(theta);
	
	                var t1 = (-b - 2 * ASqrt * tmp) / (3 * a);
	                var t2 = (-b + ASqrt * (tmp + THREE_SQRT * Math.sin(theta))) / (3 * a);
	                var t3 = (-b + ASqrt * (tmp - THREE_SQRT * Math.sin(theta))) / (3 * a);
	                if (t1 >= 0 && t1 <= 1) {
	                    roots[n++] = t1;
	                }
	                if (t2 >= 0 && t2 <= 1) {
	                    roots[n++] = t2;
	                }
	                if (t3 >= 0 && t3 <= 1) {
	                    roots[n++] = t3;
	                }
	            }
	        }
	        return n;
	    }
	
	    /**
	     * 计算三次贝塞尔方程极限值的位置
	     * @memberOf module:zrender/core/curve
	     * @param  {number} p0
	     * @param  {number} p1
	     * @param  {number} p2
	     * @param  {number} p3
	     * @param  {Array.<number>} extrema
	     * @return {number} 有效数目
	     */
	    function cubicExtrema(p0, p1, p2, p3, extrema) {
	        var b = 6 * p2 - 12 * p1 + 6 * p0;
	        var a = 9 * p1 + 3 * p3 - 3 * p0 - 9 * p2;
	        var c = 3 * p1 - 3 * p0;
	
	        var n = 0;
	        if (isAroundZero(a)) {
	            if (isNotAroundZero(b)) {
	                var t1 = -c / b;
	                if (t1 >= 0 && t1 <=1) {
	                    extrema[n++] = t1;
	                }
	            }
	        }
	        else {
	            var disc = b * b - 4 * a * c;
	            if (isAroundZero(disc)) {
	                extrema[0] = -b / (2 * a);
	            }
	            else if (disc > 0) {
	                var discSqrt = mathSqrt(disc);
	                var t1 = (-b + discSqrt) / (2 * a);
	                var t2 = (-b - discSqrt) / (2 * a);
	                if (t1 >= 0 && t1 <= 1) {
	                    extrema[n++] = t1;
	                }
	                if (t2 >= 0 && t2 <= 1) {
	                    extrema[n++] = t2;
	                }
	            }
	        }
	        return n;
	    }
	
	    /**
	     * 细分三次贝塞尔曲线
	     * @memberOf module:zrender/core/curve
	     * @param  {number} p0
	     * @param  {number} p1
	     * @param  {number} p2
	     * @param  {number} p3
	     * @param  {number} t
	     * @param  {Array.<number>} out
	     */
	    function cubicSubdivide(p0, p1, p2, p3, t, out) {
	        var p01 = (p1 - p0) * t + p0;
	        var p12 = (p2 - p1) * t + p1;
	        var p23 = (p3 - p2) * t + p2;
	
	        var p012 = (p12 - p01) * t + p01;
	        var p123 = (p23 - p12) * t + p12;
	
	        var p0123 = (p123 - p012) * t + p012;
	        // Seg0
	        out[0] = p0;
	        out[1] = p01;
	        out[2] = p012;
	        out[3] = p0123;
	        // Seg1
	        out[4] = p0123;
	        out[5] = p123;
	        out[6] = p23;
	        out[7] = p3;
	    }
	
	    /**
	     * 投射点到三次贝塞尔曲线上，返回投射距离。
	     * 投射点有可能会有一个或者多个，这里只返回其中距离最短的一个。
	     * @param {number} x0
	     * @param {number} y0
	     * @param {number} x1
	     * @param {number} y1
	     * @param {number} x2
	     * @param {number} y2
	     * @param {number} x3
	     * @param {number} y3
	     * @param {number} x
	     * @param {number} y
	     * @param {Array.<number>} [out] 投射点
	     * @return {number}
	     */
	    function cubicProjectPoint(
	        x0, y0, x1, y1, x2, y2, x3, y3,
	        x, y, out
	    ) {
	        // http://pomax.github.io/bezierinfo/#projections
	        var t;
	        var interval = 0.005;
	        var d = Infinity;
	        var prev;
	        var next;
	        var d1;
	        var d2;
	
	        _v0[0] = x;
	        _v0[1] = y;
	
	        // 先粗略估计一下可能的最小距离的 t 值
	        // PENDING
	        for (var _t = 0; _t < 1; _t += 0.05) {
	            _v1[0] = cubicAt(x0, x1, x2, x3, _t);
	            _v1[1] = cubicAt(y0, y1, y2, y3, _t);
	            d1 = v2DistSquare(_v0, _v1);
	            if (d1 < d) {
	                t = _t;
	                d = d1;
	            }
	        }
	        d = Infinity;
	
	        // At most 32 iteration
	        for (var i = 0; i < 32; i++) {
	            if (interval < EPSILON_NUMERIC) {
	                break;
	            }
	            prev = t - interval;
	            next = t + interval;
	            // t - interval
	            _v1[0] = cubicAt(x0, x1, x2, x3, prev);
	            _v1[1] = cubicAt(y0, y1, y2, y3, prev);
	
	            d1 = v2DistSquare(_v1, _v0);
	
	            if (prev >= 0 && d1 < d) {
	                t = prev;
	                d = d1;
	            }
	            else {
	                // t + interval
	                _v2[0] = cubicAt(x0, x1, x2, x3, next);
	                _v2[1] = cubicAt(y0, y1, y2, y3, next);
	                d2 = v2DistSquare(_v2, _v0);
	
	                if (next <= 1 && d2 < d) {
	                    t = next;
	                    d = d2;
	                }
	                else {
	                    interval *= 0.5;
	                }
	            }
	        }
	        // t
	        if (out) {
	            out[0] = cubicAt(x0, x1, x2, x3, t);
	            out[1] = cubicAt(y0, y1, y2, y3, t);
	        }
	        // console.log(interval, i);
	        return mathSqrt(d);
	    }
	
	    /**
	     * 计算二次方贝塞尔值
	     * @param  {number} p0
	     * @param  {number} p1
	     * @param  {number} p2
	     * @param  {number} t
	     * @return {number}
	     */
	    function quadraticAt(p0, p1, p2, t) {
	        var onet = 1 - t;
	        return onet * (onet * p0 + 2 * t * p1) + t * t * p2;
	    }
	
	    /**
	     * 计算二次方贝塞尔导数值
	     * @param  {number} p0
	     * @param  {number} p1
	     * @param  {number} p2
	     * @param  {number} t
	     * @return {number}
	     */
	    function quadraticDerivativeAt(p0, p1, p2, t) {
	        return 2 * ((1 - t) * (p1 - p0) + t * (p2 - p1));
	    }
	
	    /**
	     * 计算二次方贝塞尔方程根
	     * @param  {number} p0
	     * @param  {number} p1
	     * @param  {number} p2
	     * @param  {number} t
	     * @param  {Array.<number>} roots
	     * @return {number} 有效根数目
	     */
	    function quadraticRootAt(p0, p1, p2, val, roots) {
	        var a = p0 - 2 * p1 + p2;
	        var b = 2 * (p1 - p0);
	        var c = p0 - val;
	
	        var n = 0;
	        if (isAroundZero(a)) {
	            if (isNotAroundZero(b)) {
	                var t1 = -c / b;
	                if (t1 >= 0 && t1 <= 1) {
	                    roots[n++] = t1;
	                }
	            }
	        }
	        else {
	            var disc = b * b - 4 * a * c;
	            if (isAroundZero(disc)) {
	                var t1 = -b / (2 * a);
	                if (t1 >= 0 && t1 <= 1) {
	                    roots[n++] = t1;
	                }
	            }
	            else if (disc > 0) {
	                var discSqrt = mathSqrt(disc);
	                var t1 = (-b + discSqrt) / (2 * a);
	                var t2 = (-b - discSqrt) / (2 * a);
	                if (t1 >= 0 && t1 <= 1) {
	                    roots[n++] = t1;
	                }
	                if (t2 >= 0 && t2 <= 1) {
	                    roots[n++] = t2;
	                }
	            }
	        }
	        return n;
	    }
	
	    /**
	     * 计算二次贝塞尔方程极限值
	     * @memberOf module:zrender/core/curve
	     * @param  {number} p0
	     * @param  {number} p1
	     * @param  {number} p2
	     * @return {number}
	     */
	    function quadraticExtremum(p0, p1, p2) {
	        var divider = p0 + p2 - 2 * p1;
	        if (divider === 0) {
	            // p1 is center of p0 and p2
	            return 0.5;
	        }
	        else {
	            return (p0 - p1) / divider;
	        }
	    }
	
	    /**
	     * 细分二次贝塞尔曲线
	     * @memberOf module:zrender/core/curve
	     * @param  {number} p0
	     * @param  {number} p1
	     * @param  {number} p2
	     * @param  {number} t
	     * @param  {Array.<number>} out
	     */
	    function quadraticSubdivide(p0, p1, p2, t, out) {
	        var p01 = (p1 - p0) * t + p0;
	        var p12 = (p2 - p1) * t + p1;
	        var p012 = (p12 - p01) * t + p01;
	
	        // Seg0
	        out[0] = p0;
	        out[1] = p01;
	        out[2] = p012;
	
	        // Seg1
	        out[3] = p012;
	        out[4] = p12;
	        out[5] = p2;
	    }
	
	    /**
	     * 投射点到二次贝塞尔曲线上，返回投射距离。
	     * 投射点有可能会有一个或者多个，这里只返回其中距离最短的一个。
	     * @param {number} x0
	     * @param {number} y0
	     * @param {number} x1
	     * @param {number} y1
	     * @param {number} x2
	     * @param {number} y2
	     * @param {number} x
	     * @param {number} y
	     * @param {Array.<number>} out 投射点
	     * @return {number}
	     */
	    function quadraticProjectPoint(
	        x0, y0, x1, y1, x2, y2,
	        x, y, out
	    ) {
	        // http://pomax.github.io/bezierinfo/#projections
	        var t;
	        var interval = 0.005;
	        var d = Infinity;
	
	        _v0[0] = x;
	        _v0[1] = y;
	
	        // 先粗略估计一下可能的最小距离的 t 值
	        // PENDING
	        for (var _t = 0; _t < 1; _t += 0.05) {
	            _v1[0] = quadraticAt(x0, x1, x2, _t);
	            _v1[1] = quadraticAt(y0, y1, y2, _t);
	            var d1 = v2DistSquare(_v0, _v1);
	            if (d1 < d) {
	                t = _t;
	                d = d1;
	            }
	        }
	        d = Infinity;
	
	        // At most 32 iteration
	        for (var i = 0; i < 32; i++) {
	            if (interval < EPSILON_NUMERIC) {
	                break;
	            }
	            var prev = t - interval;
	            var next = t + interval;
	            // t - interval
	            _v1[0] = quadraticAt(x0, x1, x2, prev);
	            _v1[1] = quadraticAt(y0, y1, y2, prev);
	
	            var d1 = v2DistSquare(_v1, _v0);
	
	            if (prev >= 0 && d1 < d) {
	                t = prev;
	                d = d1;
	            }
	            else {
	                // t + interval
	                _v2[0] = quadraticAt(x0, x1, x2, next);
	                _v2[1] = quadraticAt(y0, y1, y2, next);
	                var d2 = v2DistSquare(_v2, _v0);
	                if (next <= 1 && d2 < d) {
	                    t = next;
	                    d = d2;
	                }
	                else {
	                    interval *= 0.5;
	                }
	            }
	        }
	        // t
	        if (out) {
	            out[0] = quadraticAt(x0, x1, x2, t);
	            out[1] = quadraticAt(y0, y1, y2, t);
	        }
	        // console.log(interval, i);
	        return mathSqrt(d);
	    }
	
	    module.exports = {
	
	        cubicAt: cubicAt,
	
	        cubicDerivativeAt: cubicDerivativeAt,
	
	        cubicRootAt: cubicRootAt,
	
	        cubicExtrema: cubicExtrema,
	
	        cubicSubdivide: cubicSubdivide,
	
	        cubicProjectPoint: cubicProjectPoint,
	
	        quadraticAt: quadraticAt,
	
	        quadraticDerivativeAt: quadraticDerivativeAt,
	
	        quadraticRootAt: quadraticRootAt,
	
	        quadraticExtremum: quadraticExtremum,
	
	        quadraticSubdivide: quadraticSubdivide,
	
	        quadraticProjectPoint: quadraticProjectPoint
	    };


/***/ },
/* 27 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @author Yi Shen(https://github.com/pissang)
	 */
	
	
	    var vec2 = __webpack_require__(14);
	    var curve = __webpack_require__(26);
	
	    var bbox = {};
	    var mathMin = Math.min;
	    var mathMax = Math.max;
	    var mathSin = Math.sin;
	    var mathCos = Math.cos;
	
	    var start = vec2.create();
	    var end = vec2.create();
	    var extremity = vec2.create();
	
	    var PI2 = Math.PI * 2;
	    /**
	     * 从顶点数组中计算出最小包围盒，写入`min`和`max`中
	     * @module zrender/core/bbox
	     * @param {Array<Object>} points 顶点数组
	     * @param {number} min
	     * @param {number} max
	     */
	    bbox.fromPoints = function(points, min, max) {
	        if (points.length === 0) {
	            return;
	        }
	        var p = points[0];
	        var left = p[0];
	        var right = p[0];
	        var top = p[1];
	        var bottom = p[1];
	        var i;
	
	        for (i = 1; i < points.length; i++) {
	            p = points[i];
	            left = mathMin(left, p[0]);
	            right = mathMax(right, p[0]);
	            top = mathMin(top, p[1]);
	            bottom = mathMax(bottom, p[1]);
	        }
	
	        min[0] = left;
	        min[1] = top;
	        max[0] = right;
	        max[1] = bottom;
	    };
	
	    /**
	     * @memberOf module:zrender/core/bbox
	     * @param {number} x0
	     * @param {number} y0
	     * @param {number} x1
	     * @param {number} y1
	     * @param {Array.<number>} min
	     * @param {Array.<number>} max
	     */
	    bbox.fromLine = function (x0, y0, x1, y1, min, max) {
	        min[0] = mathMin(x0, x1);
	        min[1] = mathMin(y0, y1);
	        max[0] = mathMax(x0, x1);
	        max[1] = mathMax(y0, y1);
	    };
	
	    var xDim = [];
	    var yDim = [];
	    /**
	     * 从三阶贝塞尔曲线(p0, p1, p2, p3)中计算出最小包围盒，写入`min`和`max`中
	     * @memberOf module:zrender/core/bbox
	     * @param {number} x0
	     * @param {number} y0
	     * @param {number} x1
	     * @param {number} y1
	     * @param {number} x2
	     * @param {number} y2
	     * @param {number} x3
	     * @param {number} y3
	     * @param {Array.<number>} min
	     * @param {Array.<number>} max
	     */
	    bbox.fromCubic = function(
	        x0, y0, x1, y1, x2, y2, x3, y3, min, max
	    ) {
	        var cubicExtrema = curve.cubicExtrema;
	        var cubicAt = curve.cubicAt;
	        var i;
	        var n = cubicExtrema(x0, x1, x2, x3, xDim);
	        min[0] = Infinity;
	        min[1] = Infinity;
	        max[0] = -Infinity;
	        max[1] = -Infinity;
	
	        for (i = 0; i < n; i++) {
	            var x = cubicAt(x0, x1, x2, x3, xDim[i]);
	            min[0] = mathMin(x, min[0]);
	            max[0] = mathMax(x, max[0]);
	        }
	        n = cubicExtrema(y0, y1, y2, y3, yDim);
	        for (i = 0; i < n; i++) {
	            var y = cubicAt(y0, y1, y2, y3, yDim[i]);
	            min[1] = mathMin(y, min[1]);
	            max[1] = mathMax(y, max[1]);
	        }
	
	        min[0] = mathMin(x0, min[0]);
	        max[0] = mathMax(x0, max[0]);
	        min[0] = mathMin(x3, min[0]);
	        max[0] = mathMax(x3, max[0]);
	
	        min[1] = mathMin(y0, min[1]);
	        max[1] = mathMax(y0, max[1]);
	        min[1] = mathMin(y3, min[1]);
	        max[1] = mathMax(y3, max[1]);
	    };
	
	    /**
	     * 从二阶贝塞尔曲线(p0, p1, p2)中计算出最小包围盒，写入`min`和`max`中
	     * @memberOf module:zrender/core/bbox
	     * @param {number} x0
	     * @param {number} y0
	     * @param {number} x1
	     * @param {number} y1
	     * @param {number} x2
	     * @param {number} y2
	     * @param {Array.<number>} min
	     * @param {Array.<number>} max
	     */
	    bbox.fromQuadratic = function(x0, y0, x1, y1, x2, y2, min, max) {
	        var quadraticExtremum = curve.quadraticExtremum;
	        var quadraticAt = curve.quadraticAt;
	        // Find extremities, where derivative in x dim or y dim is zero
	        var tx =
	            mathMax(
	                mathMin(quadraticExtremum(x0, x1, x2), 1), 0
	            );
	        var ty =
	            mathMax(
	                mathMin(quadraticExtremum(y0, y1, y2), 1), 0
	            );
	
	        var x = quadraticAt(x0, x1, x2, tx);
	        var y = quadraticAt(y0, y1, y2, ty);
	
	        min[0] = mathMin(x0, x2, x);
	        min[1] = mathMin(y0, y2, y);
	        max[0] = mathMax(x0, x2, x);
	        max[1] = mathMax(y0, y2, y);
	    };
	
	    /**
	     * 从圆弧中计算出最小包围盒，写入`min`和`max`中
	     * @method
	     * @memberOf module:zrender/core/bbox
	     * @param {number} x
	     * @param {number} y
	     * @param {number} rx
	     * @param {number} ry
	     * @param {number} startAngle
	     * @param {number} endAngle
	     * @param {number} anticlockwise
	     * @param {Array.<number>} min
	     * @param {Array.<number>} max
	     */
	    bbox.fromArc = function (
	        x, y, rx, ry, startAngle, endAngle, anticlockwise, min, max
	    ) {
	        var vec2Min = vec2.min;
	        var vec2Max = vec2.max;
	
	        var diff = Math.abs(startAngle - endAngle);
	
	
	        if (diff % PI2 < 1e-4 && diff > 1e-4) {
	            // Is a circle
	            min[0] = x - rx;
	            min[1] = y - ry;
	            max[0] = x + rx;
	            max[1] = y + ry;
	            return;
	        }
	
	        start[0] = mathCos(startAngle) * rx + x;
	        start[1] = mathSin(startAngle) * ry + y;
	
	        end[0] = mathCos(endAngle) * rx + x;
	        end[1] = mathSin(endAngle) * ry + y;
	
	        vec2Min(min, start, end);
	        vec2Max(max, start, end);
	
	        // Thresh to [0, Math.PI * 2]
	        startAngle = startAngle % (PI2);
	        if (startAngle < 0) {
	            startAngle = startAngle + PI2;
	        }
	        endAngle = endAngle % (PI2);
	        if (endAngle < 0) {
	            endAngle = endAngle + PI2;
	        }
	
	        if (startAngle > endAngle && !anticlockwise) {
	            endAngle += PI2;
	        }
	        else if (startAngle < endAngle && anticlockwise) {
	            startAngle += PI2;
	        }
	        if (anticlockwise) {
	            var tmp = endAngle;
	            endAngle = startAngle;
	            startAngle = tmp;
	        }
	
	        // var number = 0;
	        // var step = (anticlockwise ? -Math.PI : Math.PI) / 2;
	        for (var angle = 0; angle < endAngle; angle += Math.PI / 2) {
	            if (angle > startAngle) {
	                extremity[0] = mathCos(angle) * rx + x;
	                extremity[1] = mathSin(angle) * ry + y;
	
	                vec2Min(min, extremity, min);
	                vec2Max(max, extremity, max);
	            }
	        }
	    };
	
	    module.exports = bbox;
	


/***/ },
/* 28 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	
	    var CMD = __webpack_require__(25).CMD;
	    var line = __webpack_require__(29);
	    var cubic = __webpack_require__(30);
	    var quadratic = __webpack_require__(31);
	    var arc = __webpack_require__(32);
	    var normalizeRadian = __webpack_require__(33).normalizeRadian;
	    var curve = __webpack_require__(26);
	
	    var windingLine = __webpack_require__(34);
	
	    var containStroke = line.containStroke;
	
	    var PI2 = Math.PI * 2;
	
	    var EPSILON = 1e-4;
	
	    function isAroundEqual(a, b) {
	        return Math.abs(a - b) < EPSILON;
	    }
	
	    // 临时数组
	    var roots = [-1, -1, -1];
	    var extrema = [-1, -1];
	
	    function swapExtrema() {
	        var tmp = extrema[0];
	        extrema[0] = extrema[1];
	        extrema[1] = tmp;
	    }
	
	    function windingCubic(x0, y0, x1, y1, x2, y2, x3, y3, x, y) {
	        // Quick reject
	        if (
	            (y > y0 && y > y1 && y > y2 && y > y3)
	            || (y < y0 && y < y1 && y < y2 && y < y3)
	        ) {
	            return 0;
	        }
	        var nRoots = curve.cubicRootAt(y0, y1, y2, y3, y, roots);
	        if (nRoots === 0) {
	            return 0;
	        }
	        else {
	            var w = 0;
	            var nExtrema = -1;
	            var y0_, y1_;
	            for (var i = 0; i < nRoots; i++) {
	                var t = roots[i];
	
	                // Avoid winding error when intersection point is the connect point of two line of polygon
	                var unit = (t === 0 || t === 1) ? 0.5 : 1;
	
	                var x_ = curve.cubicAt(x0, x1, x2, x3, t);
	                if (x_ < x) { // Quick reject
	                    continue;
	                }
	                if (nExtrema < 0) {
	                    nExtrema = curve.cubicExtrema(y0, y1, y2, y3, extrema);
	                    if (extrema[1] < extrema[0] && nExtrema > 1) {
	                        swapExtrema();
	                    }
	                    y0_ = curve.cubicAt(y0, y1, y2, y3, extrema[0]);
	                    if (nExtrema > 1) {
	                        y1_ = curve.cubicAt(y0, y1, y2, y3, extrema[1]);
	                    }
	                }
	                if (nExtrema == 2) {
	                    // 分成三段单调函数
	                    if (t < extrema[0]) {
	                        w += y0_ < y0 ? unit : -unit;
	                    }
	                    else if (t < extrema[1]) {
	                        w += y1_ < y0_ ? unit : -unit;
	                    }
	                    else {
	                        w += y3 < y1_ ? unit : -unit;
	                    }
	                }
	                else {
	                    // 分成两段单调函数
	                    if (t < extrema[0]) {
	                        w += y0_ < y0 ? unit : -unit;
	                    }
	                    else {
	                        w += y3 < y0_ ? unit : -unit;
	                    }
	                }
	            }
	            return w;
	        }
	    }
	
	    function windingQuadratic(x0, y0, x1, y1, x2, y2, x, y) {
	        // Quick reject
	        if (
	            (y > y0 && y > y1 && y > y2)
	            || (y < y0 && y < y1 && y < y2)
	        ) {
	            return 0;
	        }
	        var nRoots = curve.quadraticRootAt(y0, y1, y2, y, roots);
	        if (nRoots === 0) {
	            return 0;
	        }
	        else {
	            var t = curve.quadraticExtremum(y0, y1, y2);
	            if (t >= 0 && t <= 1) {
	                var w = 0;
	                var y_ = curve.quadraticAt(y0, y1, y2, t);
	                for (var i = 0; i < nRoots; i++) {
	                    // Remove one endpoint.
	                    var unit = (roots[i] === 0 || roots[i] === 1) ? 0.5 : 1;
	
	                    var x_ = curve.quadraticAt(x0, x1, x2, roots[i]);
	                    if (x_ < x) {   // Quick reject
	                        continue;
	                    }
	                    if (roots[i] < t) {
	                        w += y_ < y0 ? unit : -unit;
	                    }
	                    else {
	                        w += y2 < y_ ? unit : -unit;
	                    }
	                }
	                return w;
	            }
	            else {
	                // Remove one endpoint.
	                var unit = (roots[0] === 0 || roots[0] === 1) ? 0.5 : 1;
	
	                var x_ = curve.quadraticAt(x0, x1, x2, roots[0]);
	                if (x_ < x) {   // Quick reject
	                    return 0;
	                }
	                return y2 < y0 ? unit : -unit;
	            }
	        }
	    }
	
	    // TODO
	    // Arc 旋转
	    function windingArc(
	        cx, cy, r, startAngle, endAngle, anticlockwise, x, y
	    ) {
	        y -= cy;
	        if (y > r || y < -r) {
	            return 0;
	        }
	        var tmp = Math.sqrt(r * r - y * y);
	        roots[0] = -tmp;
	        roots[1] = tmp;
	
	        var diff = Math.abs(startAngle - endAngle);
	        if (diff < 1e-4) {
	            return 0;
	        }
	        if (diff % PI2 < 1e-4) {
	            // Is a circle
	            startAngle = 0;
	            endAngle = PI2;
	            var dir = anticlockwise ? 1 : -1;
	            if (x >= roots[0] + cx && x <= roots[1] + cx) {
	                return dir;
	            } else {
	                return 0;
	            }
	        }
	
	        if (anticlockwise) {
	            var tmp = startAngle;
	            startAngle = normalizeRadian(endAngle);
	            endAngle = normalizeRadian(tmp);
	        }
	        else {
	            startAngle = normalizeRadian(startAngle);
	            endAngle = normalizeRadian(endAngle);
	        }
	        if (startAngle > endAngle) {
	            endAngle += PI2;
	        }
	
	        var w = 0;
	        for (var i = 0; i < 2; i++) {
	            var x_ = roots[i];
	            if (x_ + cx > x) {
	                var angle = Math.atan2(y, x_);
	                var dir = anticlockwise ? 1 : -1;
	                if (angle < 0) {
	                    angle = PI2 + angle;
	                }
	                if (
	                    (angle >= startAngle && angle <= endAngle)
	                    || (angle + PI2 >= startAngle && angle + PI2 <= endAngle)
	                ) {
	                    if (angle > Math.PI / 2 && angle < Math.PI * 1.5) {
	                        dir = -dir;
	                    }
	                    w += dir;
	                }
	            }
	        }
	        return w;
	    }
	
	    function containPath(data, lineWidth, isStroke, x, y) {
	        var w = 0;
	        var xi = 0;
	        var yi = 0;
	        var x0 = 0;
	        var y0 = 0;
	
	        for (var i = 0; i < data.length;) {
	            var cmd = data[i++];
	            // Begin a new subpath
	            if (cmd === CMD.M && i > 1) {
	                // Close previous subpath
	                if (!isStroke) {
	                    w += windingLine(xi, yi, x0, y0, x, y);
	                }
	                // 如果被任何一个 subpath 包含
	                // if (w !== 0) {
	                //     return true;
	                // }
	            }
	
	            if (i == 1) {
	                // 如果第一个命令是 L, C, Q
	                // 则 previous point 同绘制命令的第一个 point
	                //
	                // 第一个命令为 Arc 的情况下会在后面特殊处理
	                xi = data[i];
	                yi = data[i + 1];
	
	                x0 = xi;
	                y0 = yi;
	            }
	
	            switch (cmd) {
	                case CMD.M:
	                    // moveTo 命令重新创建一个新的 subpath, 并且更新新的起点
	                    // 在 closePath 的时候使用
	                    x0 = data[i++];
	                    y0 = data[i++];
	                    xi = x0;
	                    yi = y0;
	                    break;
	                case CMD.L:
	                    if (isStroke) {
	                        if (containStroke(xi, yi, data[i], data[i + 1], lineWidth, x, y)) {
	                            return true;
	                        }
	                    }
	                    else {
	                        // NOTE 在第一个命令为 L, C, Q 的时候会计算出 NaN
	                        w += windingLine(xi, yi, data[i], data[i + 1], x, y) || 0;
	                    }
	                    xi = data[i++];
	                    yi = data[i++];
	                    break;
	                case CMD.C:
	                    if (isStroke) {
	                        if (cubic.containStroke(xi, yi,
	                            data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1],
	                            lineWidth, x, y
	                        )) {
	                            return true;
	                        }
	                    }
	                    else {
	                        w += windingCubic(
	                            xi, yi,
	                            data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1],
	                            x, y
	                        ) || 0;
	                    }
	                    xi = data[i++];
	                    yi = data[i++];
	                    break;
	                case CMD.Q:
	                    if (isStroke) {
	                        if (quadratic.containStroke(xi, yi,
	                            data[i++], data[i++], data[i], data[i + 1],
	                            lineWidth, x, y
	                        )) {
	                            return true;
	                        }
	                    }
	                    else {
	                        w += windingQuadratic(
	                            xi, yi,
	                            data[i++], data[i++], data[i], data[i + 1],
	                            x, y
	                        ) || 0;
	                    }
	                    xi = data[i++];
	                    yi = data[i++];
	                    break;
	                case CMD.A:
	                    // TODO Arc 判断的开销比较大
	                    var cx = data[i++];
	                    var cy = data[i++];
	                    var rx = data[i++];
	                    var ry = data[i++];
	                    var theta = data[i++];
	                    var dTheta = data[i++];
	                    // TODO Arc 旋转
	                    var psi = data[i++];
	                    var anticlockwise = 1 - data[i++];
	                    var x1 = Math.cos(theta) * rx + cx;
	                    var y1 = Math.sin(theta) * ry + cy;
	                    // 不是直接使用 arc 命令
	                    if (i > 1) {
	                        w += windingLine(xi, yi, x1, y1, x, y);
	                    }
	                    else {
	                        // 第一个命令起点还未定义
	                        x0 = x1;
	                        y0 = y1;
	                    }
	                    // zr 使用scale来模拟椭圆, 这里也对x做一定的缩放
	                    var _x = (x - cx) * ry / rx + cx;
	                    if (isStroke) {
	                        if (arc.containStroke(
	                            cx, cy, ry, theta, theta + dTheta, anticlockwise,
	                            lineWidth, _x, y
	                        )) {
	                            return true;
	                        }
	                    }
	                    else {
	                        w += windingArc(
	                            cx, cy, ry, theta, theta + dTheta, anticlockwise,
	                            _x, y
	                        );
	                    }
	                    xi = Math.cos(theta + dTheta) * rx + cx;
	                    yi = Math.sin(theta + dTheta) * ry + cy;
	                    break;
	                case CMD.R:
	                    x0 = xi = data[i++];
	                    y0 = yi = data[i++];
	                    var width = data[i++];
	                    var height = data[i++];
	                    var x1 = x0 + width;
	                    var y1 = y0 + height;
	                    if (isStroke) {
	                        if (containStroke(x0, y0, x1, y0, lineWidth, x, y)
	                          || containStroke(x1, y0, x1, y1, lineWidth, x, y)
	                          || containStroke(x1, y1, x0, y1, lineWidth, x, y)
	                          || containStroke(x0, y1, x0, y0, lineWidth, x, y)
	                        ) {
	                            return true;
	                        }
	                    }
	                    else {
	                        // FIXME Clockwise ?
	                        w += windingLine(x1, y0, x1, y1, x, y);
	                        w += windingLine(x0, y1, x0, y0, x, y);
	                    }
	                    break;
	                case CMD.Z:
	                    if (isStroke) {
	                        if (containStroke(
	                            xi, yi, x0, y0, lineWidth, x, y
	                        )) {
	                            return true;
	                        }
	                    }
	                    else {
	                        // Close a subpath
	                        w += windingLine(xi, yi, x0, y0, x, y);
	                        // 如果被任何一个 subpath 包含
	                        // FIXME subpaths may overlap
	                        // if (w !== 0) {
	                        //     return true;
	                        // }
	                    }
	                    xi = x0;
	                    yi = y0;
	                    break;
	            }
	        }
	        if (!isStroke && !isAroundEqual(yi, y0)) {
	            w += windingLine(xi, yi, x0, y0, x, y) || 0;
	        }
	        return w !== 0;
	    }
	
	    module.exports = {
	        contain: function (pathData, x, y) {
	            return containPath(pathData, 0, false, x, y);
	        },
	
	        containStroke: function (pathData, lineWidth, x, y) {
	            return containPath(pathData, lineWidth, true, x, y);
	        }
	    };


/***/ },
/* 29 */
/***/ function(module, exports) {

	
	    module.exports = {
	        /**
	         * 线段包含判断
	         * @param  {number}  x0
	         * @param  {number}  y0
	         * @param  {number}  x1
	         * @param  {number}  y1
	         * @param  {number}  lineWidth
	         * @param  {number}  x
	         * @param  {number}  y
	         * @return {boolean}
	         */
	        containStroke: function (x0, y0, x1, y1, lineWidth, x, y) {
	            if (lineWidth === 0) {
	                return false;
	            }
	            var _l = lineWidth;
	            var _a = 0;
	            var _b = x0;
	            // Quick reject
	            if (
	                (y > y0 + _l && y > y1 + _l)
	                || (y < y0 - _l && y < y1 - _l)
	                || (x > x0 + _l && x > x1 + _l)
	                || (x < x0 - _l && x < x1 - _l)
	            ) {
	                return false;
	            }
	
	            if (x0 !== x1) {
	                _a = (y0 - y1) / (x0 - x1);
	                _b = (x0 * y1 - x1 * y0) / (x0 - x1) ;
	            }
	            else {
	                return Math.abs(x - x0) <= _l / 2;
	            }
	            var tmp = _a * x - y + _b;
	            var _s = tmp * tmp / (_a * _a + 1);
	            return _s <= _l / 2 * _l / 2;
	        }
	    };


/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

	
	
	    var curve = __webpack_require__(26);
	
	    module.exports = {
	        /**
	         * 三次贝塞尔曲线描边包含判断
	         * @param  {number}  x0
	         * @param  {number}  y0
	         * @param  {number}  x1
	         * @param  {number}  y1
	         * @param  {number}  x2
	         * @param  {number}  y2
	         * @param  {number}  x3
	         * @param  {number}  y3
	         * @param  {number}  lineWidth
	         * @param  {number}  x
	         * @param  {number}  y
	         * @return {boolean}
	         */
	        containStroke: function(x0, y0, x1, y1, x2, y2, x3, y3, lineWidth, x, y) {
	            if (lineWidth === 0) {
	                return false;
	            }
	            var _l = lineWidth;
	            // Quick reject
	            if (
	                (y > y0 + _l && y > y1 + _l && y > y2 + _l && y > y3 + _l)
	                || (y < y0 - _l && y < y1 - _l && y < y2 - _l && y < y3 - _l)
	                || (x > x0 + _l && x > x1 + _l && x > x2 + _l && x > x3 + _l)
	                || (x < x0 - _l && x < x1 - _l && x < x2 - _l && x < x3 - _l)
	            ) {
	                return false;
	            }
	            var d = curve.cubicProjectPoint(
	                x0, y0, x1, y1, x2, y2, x3, y3,
	                x, y, null
	            );
	            return d <= _l / 2;
	        }
	    };


/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	
	
	    var curve = __webpack_require__(26);
	
	    module.exports = {
	        /**
	         * 二次贝塞尔曲线描边包含判断
	         * @param  {number}  x0
	         * @param  {number}  y0
	         * @param  {number}  x1
	         * @param  {number}  y1
	         * @param  {number}  x2
	         * @param  {number}  y2
	         * @param  {number}  lineWidth
	         * @param  {number}  x
	         * @param  {number}  y
	         * @return {boolean}
	         */
	        containStroke: function (x0, y0, x1, y1, x2, y2, lineWidth, x, y) {
	            if (lineWidth === 0) {
	                return false;
	            }
	            var _l = lineWidth;
	            // Quick reject
	            if (
	                (y > y0 + _l && y > y1 + _l && y > y2 + _l)
	                || (y < y0 - _l && y < y1 - _l && y < y2 - _l)
	                || (x > x0 + _l && x > x1 + _l && x > x2 + _l)
	                || (x < x0 - _l && x < x1 - _l && x < x2 - _l)
	            ) {
	                return false;
	            }
	            var d = curve.quadraticProjectPoint(
	                x0, y0, x1, y1, x2, y2,
	                x, y, null
	            );
	            return d <= _l / 2;
	        }
	    };


/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

	
	
	    var normalizeRadian = __webpack_require__(33).normalizeRadian;
	    var PI2 = Math.PI * 2;
	
	    module.exports = {
	        /**
	         * 圆弧描边包含判断
	         * @param  {number}  cx
	         * @param  {number}  cy
	         * @param  {number}  r
	         * @param  {number}  startAngle
	         * @param  {number}  endAngle
	         * @param  {boolean}  anticlockwise
	         * @param  {number} lineWidth
	         * @param  {number}  x
	         * @param  {number}  y
	         * @return {Boolean}
	         */
	        containStroke: function (
	            cx, cy, r, startAngle, endAngle, anticlockwise,
	            lineWidth, x, y
	        ) {
	
	            if (lineWidth === 0) {
	                return false;
	            }
	            var _l = lineWidth;
	
	            x -= cx;
	            y -= cy;
	            var d = Math.sqrt(x * x + y * y);
	
	            if ((d - _l > r) || (d + _l < r)) {
	                return false;
	            }
	            if (Math.abs(startAngle - endAngle) % PI2 < 1e-4) {
	                // Is a circle
	                return true;
	            }
	            if (anticlockwise) {
	                var tmp = startAngle;
	                startAngle = normalizeRadian(endAngle);
	                endAngle = normalizeRadian(tmp);
	            } else {
	                startAngle = normalizeRadian(startAngle);
	                endAngle = normalizeRadian(endAngle);
	            }
	            if (startAngle > endAngle) {
	                endAngle += PI2;
	            }
	
	            var angle = Math.atan2(y, x);
	            if (angle < 0) {
	                angle += PI2;
	            }
	            return (angle >= startAngle && angle <= endAngle)
	                || (angle + PI2 >= startAngle && angle + PI2 <= endAngle);
	        }
	    };


/***/ },
/* 33 */
/***/ function(module, exports) {

	
	
	    var PI2 = Math.PI * 2;
	    module.exports = {
	        normalizeRadian: function(angle) {
	            angle %= PI2;
	            if (angle < 0) {
	                angle += PI2;
	            }
	            return angle;
	        }
	    };


/***/ },
/* 34 */
/***/ function(module, exports) {

	
	    module.exports = function windingLine(x0, y0, x1, y1, x, y) {
	        if ((y > y0 && y > y1) || (y < y0 && y < y1)) {
	            return 0;
	        }
	        // Ignore horizontal line
	        if (y1 === y0) {
	            return 0;
	        }
	        var dir = y1 < y0 ? 1 : -1;
	        var t = (y - y0) / (y1 - y0);
	
	        // Avoid winding error when intersection point is the connect point of two line of polygon
	        if (t === 1 || t === 0) {
	            dir = y1 < y0 ? 0.5 : -0.5;
	        }
	
	        var x_ = t * (x1 - x0) + x0;
	
	        return x_ > x ? dir : 0;
	    };


/***/ },
/* 35 */
/***/ function(module, exports) {

	
	
	    var Pattern = function (image, repeat) {
	        this.image = image;
	        this.repeat = repeat;
	
	        // Can be cloned
	        this.type = 'pattern';
	    };
	
	    Pattern.prototype.getCanvasPattern = function (ctx) {
	
	        return this._canvasPattern
	            || (this._canvasPattern = ctx.createPattern(this.image, this.repeat));
	    };
	
	    module.exports = Pattern;


/***/ },
/* 36 */
/***/ function(module, exports, __webpack_require__) {

	
	
	    var CMD = __webpack_require__(25).CMD;
	    var vec2 = __webpack_require__(14);
	    var v2ApplyTransform = vec2.applyTransform;
	
	    var points = [[], [], []];
	    var mathSqrt = Math.sqrt;
	    var mathAtan2 = Math.atan2;
	    function transformPath(path, m) {
	        var data = path.data;
	        var cmd;
	        var nPoint;
	        var i;
	        var j;
	        var k;
	        var p;
	
	        var M = CMD.M;
	        var C = CMD.C;
	        var L = CMD.L;
	        var R = CMD.R;
	        var A = CMD.A;
	        var Q = CMD.Q;
	
	        for (i = 0, j = 0; i < data.length;) {
	            cmd = data[i++];
	            j = i;
	            nPoint = 0;
	
	            switch (cmd) {
	                case M:
	                    nPoint = 1;
	                    break;
	                case L:
	                    nPoint = 1;
	                    break;
	                case C:
	                    nPoint = 3;
	                    break;
	                case Q:
	                    nPoint = 2;
	                    break;
	                case A:
	                    var x = m[4];
	                    var y = m[5];
	                    var sx = mathSqrt(m[0] * m[0] + m[1] * m[1]);
	                    var sy = mathSqrt(m[2] * m[2] + m[3] * m[3]);
	                    var angle = mathAtan2(-m[1] / sy, m[0] / sx);
	                    // cx
	                    data[i++] += x;
	                    // cy
	                    data[i++] += y;
	                    // Scale rx and ry
	                    // FIXME Assume psi is 0 here
	                    data[i++] *= sx;
	                    data[i++] *= sy;
	
	                    // Start angle
	                    data[i++] += angle;
	                    // end angle
	                    data[i++] += angle;
	                    // FIXME psi
	                    i += 2;
	                    j = i;
	                    break;
	                case R:
	                    // x0, y0
	                    p[0] = data[i++];
	                    p[1] = data[i++];
	                    v2ApplyTransform(p, p, m);
	                    data[j++] = p[0];
	                    data[j++] = p[1];
	                    // x1, y1
	                    p[0] += data[i++];
	                    p[1] += data[i++];
	                    v2ApplyTransform(p, p, m);
	                    data[j++] = p[0];
	                    data[j++] = p[1];
	            }
	
	            for (k = 0; k < nPoint; k++) {
	                var p = points[k];
	                p[0] = data[i++];
	                p[1] = data[i++];
	
	                v2ApplyTransform(p, p, m);
	                // Write back
	                data[j++] = p[0];
	                data[j++] = p[1];
	            }
	        }
	    }
	
	    module.exports = transformPath;


/***/ },
/* 37 */
/***/ function(module, exports) {

	
	
	    /**
	     * @param {Array.<Object>} colorStops
	     */
	    var Gradient = function (colorStops) {
	
	        this.colorStops = colorStops || [];
	    };
	
	    Gradient.prototype = {
	
	        constructor: Gradient,
	
	        addColorStop: function (offset, color) {
	            this.colorStops.push({
	
	                offset: offset,
	
	                color: color
	            });
	        }
	    };
	
	    module.exports = Gradient;


/***/ },
/* 38 */
/***/ function(module, exports) {

	// TODO Draggable for group
	// FIXME Draggable on element which has parent rotation or scale
	
	    function Draggable() {
	
	        this.on('mousedown', this._dragStart, this);
	        this.on('mousemove', this._drag, this);
	        this.on('mouseup', this._dragEnd, this);
	        this.on('globalout', this._dragEnd, this);
	        // this._dropTarget = null;
	        // this._draggingTarget = null;
	
	        // this._x = 0;
	        // this._y = 0;
	    }
	
	    Draggable.prototype = {
	
	        constructor: Draggable,
	
	        _dragStart: function (e) {
	            var draggingTarget = e.target;
	            if (draggingTarget && draggingTarget.draggable) {
	                this._draggingTarget = draggingTarget;
	                draggingTarget.dragging = true;
	                this._x = e.offsetX;
	                this._y = e.offsetY;
	
	                this.dispatchToElement(draggingTarget, 'dragstart', e.event);
	            }
	        },
	
	        _drag: function (e) {
	            var draggingTarget = this._draggingTarget;
	            if (draggingTarget) {
	
	                var x = e.offsetX;
	                var y = e.offsetY;
	
	                var dx = x - this._x;
	                var dy = y - this._y;
	                this._x = x;
	                this._y = y;
	
	                draggingTarget.drift(dx, dy, e);
	                this.dispatchToElement(draggingTarget, 'drag', e.event);
	
	                var dropTarget = this.findHover(x, y, draggingTarget);
	                var lastDropTarget = this._dropTarget;
	                this._dropTarget = dropTarget;
	
	                if (draggingTarget !== dropTarget) {
	                    if (lastDropTarget && dropTarget !== lastDropTarget) {
	                        this.dispatchToElement(lastDropTarget, 'dragleave', e.event);
	                    }
	                    if (dropTarget && dropTarget !== lastDropTarget) {
	                        this.dispatchToElement(dropTarget, 'dragenter', e.event);
	                    }
	                }
	            }
	        },
	
	        _dragEnd: function (e) {
	            var draggingTarget = this._draggingTarget;
	
	            if (draggingTarget) {
	                draggingTarget.dragging = false;
	            }
	
	            this.dispatchToElement(draggingTarget, 'dragend', e.event);
	
	            if (this._dropTarget) {
	                this.dispatchToElement(this._dropTarget, 'drop', e.event);
	            }
	
	            this._draggingTarget = null;
	            this._dropTarget = null;
	        }
	
	    };
	
	    module.exports = Draggable;


/***/ },
/* 39 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Group是一个容器，可以插入子节点，Group的变换也会被应用到子节点上
	 * @module zrender/graphic/Group
	 * @example
	 *     var Group = require('zrender/lib/container/Group');
	 *     var Circle = require('zrender/lib/graphic/shape/Circle');
	 *     var g = new Group();
	 *     g.position[0] = 100;
	 *     g.position[1] = 100;
	 *     g.add(new Circle({
	 *         style: {
	 *             x: 100,
	 *             y: 100,
	 *             r: 20,
	 *         }
	 *     }));
	 *     zr.add(g);
	 */
	
	
	    var zrUtil = __webpack_require__(4);
	    var Element = __webpack_require__(9);
	    var BoundingRect = __webpack_require__(24);
	
	    /**
	     * @alias module:zrender/graphic/Group
	     * @constructor
	     * @extends module:zrender/mixin/Transformable
	     * @extends module:zrender/mixin/Eventful
	     */
	    var Group = function (opts) {
	
	        opts = opts || {};
	
	        Element.call(this, opts);
	
	        for (var key in opts) {
	            this[key] = opts[key];
	        }
	
	        this._children = [];
	
	        this.__storage = null;
	
	        this.__dirty = true;
	    };
	
	    Group.prototype = {
	
	        constructor: Group,
	
	        isGroup: true,
	
	        /**
	         * @type {string}
	         */
	        type: 'group',
	
	        /**
	         * 所有子孙元素是否响应鼠标事件
	         * @name module:/zrender/container/Group#silent
	         * @type {boolean}
	         * @default false
	         */
	        silent: false,
	
	        /**
	         * @return {Array.<module:zrender/Element>}
	         */
	        children: function () {
	            return this._children.slice();
	        },
	
	        /**
	         * 获取指定 index 的儿子节点
	         * @param  {number} idx
	         * @return {module:zrender/Element}
	         */
	        childAt: function (idx) {
	            return this._children[idx];
	        },
	
	        /**
	         * 获取指定名字的儿子节点
	         * @param  {string} name
	         * @return {module:zrender/Element}
	         */
	        childOfName: function (name) {
	            var children = this._children;
	            for (var i = 0; i < children.length; i++) {
	                if (children[i].name === name) {
	                    return children[i];
	                }
	             }
	        },
	
	        /**
	         * @return {number}
	         */
	        childCount: function () {
	            return this._children.length;
	        },
	
	        /**
	         * 添加子节点到最后
	         * @param {module:zrender/Element} child
	         */
	        add: function (child) {
	            if (child && child !== this && child.parent !== this) {
	
	                this._children.push(child);
	
	                this._doAdd(child);
	            }
	
	            return this;
	        },
	
	        /**
	         * 添加子节点在 nextSibling 之前
	         * @param {module:zrender/Element} child
	         * @param {module:zrender/Element} nextSibling
	         */
	        addBefore: function (child, nextSibling) {
	            if (child && child !== this && child.parent !== this
	                && nextSibling && nextSibling.parent === this) {
	
	                var children = this._children;
	                var idx = children.indexOf(nextSibling);
	
	                if (idx >= 0) {
	                    children.splice(idx, 0, child);
	                    this._doAdd(child);
	                }
	            }
	
	            return this;
	        },
	
	        _doAdd: function (child) {
	            if (child.parent) {
	                child.parent.remove(child);
	            }
	
	            child.parent = this;
	
	            var storage = this.__storage;
	            var zr = this.__zr;
	            if (storage && storage !== child.__storage) {
	
	                storage.addToMap(child);
	
	                if (child instanceof Group) {
	                    child.addChildrenToStorage(storage);
	                }
	            }
	
	            zr && zr.refresh();
	        },
	
	        /**
	         * 移除子节点
	         * @param {module:zrender/Element} child
	         */
	        remove: function (child) {
	            var zr = this.__zr;
	            var storage = this.__storage;
	            var children = this._children;
	
	            var idx = zrUtil.indexOf(children, child);
	            if (idx < 0) {
	                return this;
	            }
	            children.splice(idx, 1);
	
	            child.parent = null;
	
	            if (storage) {
	
	                storage.delFromMap(child.id);
	
	                if (child instanceof Group) {
	                    child.delChildrenFromStorage(storage);
	                }
	            }
	
	            zr && zr.refresh();
	
	            return this;
	        },
	
	        /**
	         * 移除所有子节点
	         */
	        removeAll: function () {
	            var children = this._children;
	            var storage = this.__storage;
	            var child;
	            var i;
	            for (i = 0; i < children.length; i++) {
	                child = children[i];
	                if (storage) {
	                    storage.delFromMap(child.id);
	                    if (child instanceof Group) {
	                        child.delChildrenFromStorage(storage);
	                    }
	                }
	                child.parent = null;
	            }
	            children.length = 0;
	
	            return this;
	        },
	
	        /**
	         * 遍历所有子节点
	         * @param  {Function} cb
	         * @param  {}   context
	         */
	        eachChild: function (cb, context) {
	            var children = this._children;
	            for (var i = 0; i < children.length; i++) {
	                var child = children[i];
	                cb.call(context, child, i);
	            }
	            return this;
	        },
	
	        /**
	         * 深度优先遍历所有子孙节点
	         * @param  {Function} cb
	         * @param  {}   context
	         */
	        traverse: function (cb, context) {
	            for (var i = 0; i < this._children.length; i++) {
	                var child = this._children[i];
	                cb.call(context, child);
	
	                if (child.type === 'group') {
	                    child.traverse(cb, context);
	                }
	            }
	            return this;
	        },
	
	        addChildrenToStorage: function (storage) {
	            for (var i = 0; i < this._children.length; i++) {
	                var child = this._children[i];
	                storage.addToMap(child);
	                if (child instanceof Group) {
	                    child.addChildrenToStorage(storage);
	                }
	            }
	        },
	
	        delChildrenFromStorage: function (storage) {
	            for (var i = 0; i < this._children.length; i++) {
	                var child = this._children[i];
	                storage.delFromMap(child.id);
	                if (child instanceof Group) {
	                    child.delChildrenFromStorage(storage);
	                }
	            }
	        },
	
	        dirty: function () {
	            this.__dirty = true;
	            this.__zr && this.__zr.refresh();
	            return this;
	        },
	
	        /**
	         * @return {module:zrender/core/BoundingRect}
	         */
	        getBoundingRect: function (includeChildren) {
	            // TODO Caching
	            // TODO Transform
	            var rect = null;
	            var tmpRect = new BoundingRect(0, 0, 0, 0);
	            var children = includeChildren || this._children;
	            var tmpMat = [];
	
	            for (var i = 0; i < children.length; i++) {
	                var child = children[i];
	                if (child.ignore || child.invisible) {
	                    continue;
	                }
	
	                var childRect = child.getBoundingRect();
	                var transform = child.getLocalTransform(tmpMat);
	                if (transform) {
	                    tmpRect.copy(childRect);
	                    tmpRect.applyTransform(transform);
	                    rect = rect || tmpRect.clone();
	                    rect.union(tmpRect);
	                }
	                else {
	                    rect = rect || childRect.clone();
	                    rect.union(childRect);
	                }
	            }
	            return rect || tmpRect;
	        }
	    };
	
	    zrUtil.inherits(Group, Element);
	
	    module.exports = Group;


/***/ },
/* 40 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Image element
	 * @module zrender/graphic/Image
	 */
	
	
	
	    var Displayable = __webpack_require__(7);
	    var BoundingRect = __webpack_require__(24);
	    var zrUtil = __webpack_require__(4);
	
	    var LRU = __webpack_require__(41);
	    var globalImageCache = new LRU(50);
	    /**
	     * @alias zrender/graphic/Image
	     * @extends module:zrender/graphic/Displayable
	     * @constructor
	     * @param {Object} opts
	     */
	    function ZImage(opts) {
	        Displayable.call(this, opts);
	    }
	
	    ZImage.prototype = {
	
	        constructor: ZImage,
	
	        type: 'image',
	
	        brush: function (ctx, prevEl) {
	            var style = this.style;
	            var src = style.image;
	            var image;
	
	            // Must bind each time
	            style.bind(ctx, this, prevEl);
	            // style.image is a url string
	            if (typeof src === 'string') {
	                image = this._image;
	            }
	            // style.image is an HTMLImageElement or HTMLCanvasElement or Canvas
	            else {
	                image = src;
	            }
	            // FIXME Case create many images with src
	            if (!image && src) {
	                // Try get from global image cache
	                var cachedImgObj = globalImageCache.get(src);
	                if (!cachedImgObj) {
	                    // Create a new image
	                    image = new Image();
	                    image.onload = function () {
	                        image.onload = null;
	                        for (var i = 0; i < cachedImgObj.pending.length; i++) {
	                            cachedImgObj.pending[i].dirty();
	                        }
	                    };
	                    cachedImgObj = {
	                        image: image,
	                        pending: [this]
	                    };
	                    image.src = src;
	                    globalImageCache.put(src, cachedImgObj);
	                    this._image = image;
	                    return;
	                }
	                else {
	                    image = cachedImgObj.image;
	                    this._image = image;
	                    // Image is not complete finish, add to pending list
	                    if (!image.width || !image.height) {
	                        cachedImgObj.pending.push(this);
	                        return;
	                    }
	                }
	            }
	
	            if (image) {
	                // 图片已经加载完成
	                // if (image.nodeName.toUpperCase() == 'IMG') {
	                //     if (!image.complete) {
	                //         return;
	                //     }
	                // }
	                // Else is canvas
	
	                var width = style.width || image.width;
	                var height = style.height || image.height;
	                var x = style.x || 0;
	                var y = style.y || 0;
	                // 图片加载失败
	                if (!image.width || !image.height) {
	                    return;
	                }
	
	                // 设置transform
	                this.setTransform(ctx);
	
	
	                if (style.sWidth && style.sHeight) {
	                    var sx = style.sx || 0;
	                    var sy = style.sy || 0;
	                    ctx.drawImage(
	                        image,
	                        sx, sy, style.sWidth, style.sHeight,
	                        x, y, width, height
	                    );
	                }
	                else if (style.sx && style.sy) {
	                    var sx = style.sx;
	                    var sy = style.sy;
	                    var sWidth = width - sx;
	                    var sHeight = height - sy;
	                    ctx.drawImage(
	                        image,
	                        sx, sy, sWidth, sHeight,
	                        x, y, width, height
	                    );
	                }
	                else {
	                    ctx.drawImage(image, x, y, width, height);
	                }
	
	                // 如果没设置宽和高的话自动根据图片宽高设置
	                if (style.width == null) {
	                    style.width = width;
	                }
	                if (style.height == null) {
	                    style.height = height;
	                }
	
	                this.restoreTransform(ctx);
	
	                // Draw rect text
	                if (style.text != null) {
	                    this.drawRectText(ctx, this.getBoundingRect());
	                }
	
	            }
	        },
	
	        getBoundingRect: function () {
	            var style = this.style;
	            if (! this._rect) {
	                this._rect = new BoundingRect(
	                    style.x || 0, style.y || 0, style.width || 0, style.height || 0
	                );
	            }
	            return this._rect;
	        }
	    };
	
	    zrUtil.inherits(ZImage, Displayable);
	
	    module.exports = ZImage;


/***/ },
/* 41 */
/***/ function(module, exports) {

	// Simple LRU cache use doubly linked list
	// @module zrender/core/LRU
	
	
	    /**
	     * Simple double linked list. Compared with array, it has O(1) remove operation.
	     * @constructor
	     */
	    var LinkedList = function() {
	
	        /**
	         * @type {module:zrender/core/LRU~Entry}
	         */
	        this.head = null;
	
	        /**
	         * @type {module:zrender/core/LRU~Entry}
	         */
	        this.tail = null;
	
	        this._len = 0;
	    };
	
	    var linkedListProto = LinkedList.prototype;
	    /**
	     * Insert a new value at the tail
	     * @param  {} val
	     * @return {module:zrender/core/LRU~Entry}
	     */
	    linkedListProto.insert = function(val) {
	        var entry = new Entry(val);
	        this.insertEntry(entry);
	        return entry;
	    };
	
	    /**
	     * Insert an entry at the tail
	     * @param  {module:zrender/core/LRU~Entry} entry
	     */
	    linkedListProto.insertEntry = function(entry) {
	        if (!this.head) {
	            this.head = this.tail = entry;
	        }
	        else {
	            this.tail.next = entry;
	            entry.prev = this.tail;
	            this.tail = entry;
	        }
	        this._len++;
	    };
	
	    /**
	     * Remove entry.
	     * @param  {module:zrender/core/LRU~Entry} entry
	     */
	    linkedListProto.remove = function(entry) {
	        var prev = entry.prev;
	        var next = entry.next;
	        if (prev) {
	            prev.next = next;
	        }
	        else {
	            // Is head
	            this.head = next;
	        }
	        if (next) {
	            next.prev = prev;
	        }
	        else {
	            // Is tail
	            this.tail = prev;
	        }
	        entry.next = entry.prev = null;
	        this._len--;
	    };
	
	    /**
	     * @return {number}
	     */
	    linkedListProto.len = function() {
	        return this._len;
	    };
	
	    /**
	     * @constructor
	     * @param {} val
	     */
	    var Entry = function(val) {
	        /**
	         * @type {}
	         */
	        this.value = val;
	
	        /**
	         * @type {module:zrender/core/LRU~Entry}
	         */
	        this.next;
	
	        /**
	         * @type {module:zrender/core/LRU~Entry}
	         */
	        this.prev;
	    };
	
	    /**
	     * LRU Cache
	     * @constructor
	     * @alias module:zrender/core/LRU
	     */
	    var LRU = function(maxSize) {
	
	        this._list = new LinkedList();
	
	        this._map = {};
	
	        this._maxSize = maxSize || 10;
	    };
	
	    var LRUProto = LRU.prototype;
	
	    /**
	     * @param  {string} key
	     * @param  {} value
	     */
	    LRUProto.put = function(key, value) {
	        var list = this._list;
	        var map = this._map;
	        if (map[key] == null) {
	            var len = list.len();
	            if (len >= this._maxSize && len > 0) {
	                // Remove the least recently used
	                var leastUsedEntry = list.head;
	                list.remove(leastUsedEntry);
	                delete map[leastUsedEntry.key];
	            }
	
	            var entry = list.insert(value);
	            entry.key = key;
	            map[key] = entry;
	        }
	    };
	
	    /**
	     * @param  {string} key
	     * @return {}
	     */
	    LRUProto.get = function(key) {
	        var entry = this._map[key];
	        var list = this._list;
	        if (entry != null) {
	            // Put the latest used entry in the tail
	            if (entry !== list.tail) {
	                list.remove(entry);
	                list.insertEntry(entry);
	            }
	
	            return entry.value;
	        }
	    };
	
	    /**
	     * Clear the cache
	     */
	    LRUProto.clear = function() {
	        this._list.clear();
	        this._map = {};
	    };
	
	    module.exports = LRU;


/***/ },
/* 42 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Text element
	 * @module zrender/graphic/Text
	 *
	 * TODO Wrapping
	 *
	 * Text not support gradient
	 */
	
	
	
	    var Displayable = __webpack_require__(7);
	    var zrUtil = __webpack_require__(4);
	    var textContain = __webpack_require__(23);
	
	    /**
	     * @alias zrender/graphic/Text
	     * @extends module:zrender/graphic/Displayable
	     * @constructor
	     * @param {Object} opts
	     */
	    var Text = function (opts) {
	        Displayable.call(this, opts);
	    };
	
	    Text.prototype = {
	
	        constructor: Text,
	
	        type: 'text',
	
	        brush: function (ctx, prevEl) {
	            var style = this.style;
	            var x = style.x || 0;
	            var y = style.y || 0;
	            // Convert to string
	            var text = style.text;
	
	            // Convert to string
	            text != null && (text += '');
	
	            // Always bind style
	            style.bind(ctx, this, prevEl);
	
	            if (text) {
	
	                this.setTransform(ctx);
	
	                var textBaseline;
	                var textAlign = style.textAlign;
	                var font = style.textFont || style.font;
	                if (style.textVerticalAlign) {
	                    var rect = textContain.getBoundingRect(
	                        text, font, style.textAlign, 'top'
	                    );
	                    // Ignore textBaseline
	                    textBaseline = 'middle';
	                    switch (style.textVerticalAlign) {
	                        case 'middle':
	                            y -= rect.height / 2 - rect.lineHeight / 2;
	                            break;
	                        case 'bottom':
	                            y -= rect.height - rect.lineHeight / 2;
	                            break;
	                        default:
	                            y += rect.lineHeight / 2;
	                    }
	                }
	                else {
	                    textBaseline = style.textBaseline;
	                }
	
	                // TODO Invalid font
	                ctx.font = font || '12px sans-serif';
	                ctx.textAlign = textAlign || 'left';
	                // Use canvas default left textAlign. Giving invalid value will cause state not change
	                if (ctx.textAlign !== textAlign) {
	                    ctx.textAlign = 'left';
	                }
	                ctx.textBaseline = textBaseline || 'alphabetic';
	                // Use canvas default alphabetic baseline
	                if (ctx.textBaseline !== textBaseline) {
	                    ctx.textBaseline = 'alphabetic';
	                }
	
	                var lineHeight = textContain.measureText('国', ctx.font).width;
	
	                var textLines = text.split('\n');
	                for (var i = 0; i < textLines.length; i++) {
	                    style.hasFill() && ctx.fillText(textLines[i], x, y);
	                    style.hasStroke() && ctx.strokeText(textLines[i], x, y);
	                    y += lineHeight;
	                }
	
	                this.restoreTransform(ctx);
	            }
	        },
	
	        getBoundingRect: function () {
	            if (!this._rect) {
	                var style = this.style;
	                var textVerticalAlign = style.textVerticalAlign;
	                var rect = textContain.getBoundingRect(
	                    style.text + '', style.textFont || style.font, style.textAlign,
	                    textVerticalAlign ? 'top' : style.textBaseline
	                );
	                switch (textVerticalAlign) {
	                    case 'middle':
	                        rect.y -= rect.height / 2;
	                        break;
	                    case 'bottom':
	                        rect.y -= rect.height;
	                        break;
	                }
	                rect.x += style.x || 0;
	                rect.y += style.y || 0;
	                this._rect = rect;
	            }
	            return this._rect;
	        }
	    };
	
	    zrUtil.inherits(Text, Displayable);
	
	    module.exports = Text;


/***/ },
/* 43 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	/**
	 * 圆形
	 * @module zrender/shape/Circle
	 */
	
	
	
	    module.exports = __webpack_require__(6).extend({
	
	        type: 'circle',
	
	        shape: {
	            cx: 0,
	            cy: 0,
	            r: 0
	        },
	
	
	        buildPath : function (ctx, shape, inBundle) {
	            // Better stroking in ShapeBundle
	            // Always do it may have performence issue ( fill may be 2x more cost)
	            if (inBundle) {
	                ctx.moveTo(shape.cx + shape.r, shape.cy);
	            }
	            // Better stroking in ShapeBundle
	            // ctx.moveTo(shape.cx + shape.r, shape.cy);
	            ctx.arc(shape.cx, shape.cy, shape.r, 0, Math.PI * 2, true);
	        }
	    });
	


/***/ },
/* 44 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * 扇形
	 * @module zrender/graphic/shape/Sector
	 */
	
	
	
	    module.exports = __webpack_require__(6).extend({
	
	        type: 'sector',
	
	        shape: {
	
	            cx: 0,
	
	            cy: 0,
	
	            r0: 0,
	
	            r: 0,
	
	            startAngle: 0,
	
	            endAngle: Math.PI * 2,
	
	            clockwise: true
	        },
	
	        buildPath: function (ctx, shape) {
	
	            var x = shape.cx;
	            var y = shape.cy;
	            var r0 = Math.max(shape.r0 || 0, 0);
	            var r = Math.max(shape.r, 0);
	            var startAngle = shape.startAngle;
	            var endAngle = shape.endAngle;
	            var clockwise = shape.clockwise;
	
	            var unitX = Math.cos(startAngle);
	            var unitY = Math.sin(startAngle);
	
	            ctx.moveTo(unitX * r0 + x, unitY * r0 + y);
	
	            ctx.lineTo(unitX * r + x, unitY * r + y);
	
	            ctx.arc(x, y, r, startAngle, endAngle, !clockwise);
	
	            ctx.lineTo(
	                Math.cos(endAngle) * r0 + x,
	                Math.sin(endAngle) * r0 + y
	            );
	
	            if (r0 !== 0) {
	                ctx.arc(x, y, r0, endAngle, startAngle, clockwise);
	            }
	
	            ctx.closePath();
	        }
	    });
	


/***/ },
/* 45 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * 圆环
	 * @module zrender/graphic/shape/Ring
	 */
	
	
	    module.exports = __webpack_require__(6).extend({
	
	        type: 'ring',
	
	        shape: {
	            cx: 0,
	            cy: 0,
	            r: 0,
	            r0: 0
	        },
	
	        buildPath: function (ctx, shape) {
	            var x = shape.cx;
	            var y = shape.cy;
	            var PI2 = Math.PI * 2;
	            ctx.moveTo(x + shape.r, y);
	            ctx.arc(x, y, shape.r, 0, PI2, false);
	            ctx.moveTo(x + shape.r0, y);
	            ctx.arc(x, y, shape.r0, 0, PI2, true);
	        }
	    });
	


/***/ },
/* 46 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * 多边形
	 * @module zrender/shape/Polygon
	 */
	
	
	    var polyHelper = __webpack_require__(47);
	
	    module.exports = __webpack_require__(6).extend({
	        
	        type: 'polygon',
	
	        shape: {
	            points: null,
	
	            smooth: false,
	
	            smoothConstraint: null
	        },
	
	        buildPath: function (ctx, shape) {
	            polyHelper.buildPath(ctx, shape, true);
	        }
	    });


/***/ },
/* 47 */
/***/ function(module, exports, __webpack_require__) {

	
	
	    var smoothSpline = __webpack_require__(48);
	    var smoothBezier = __webpack_require__(49);
	
	    module.exports = {
	        buildPath: function (ctx, shape, closePath) {
	            var points = shape.points;
	            var smooth = shape.smooth;
	            if (points && points.length >= 2) {
	                if (smooth && smooth !== 'spline') {
	                    var controlPoints = smoothBezier(
	                        points, smooth, closePath, shape.smoothConstraint
	                    );
	
	                    ctx.moveTo(points[0][0], points[0][1]);
	                    var len = points.length;
	                    for (var i = 0; i < (closePath ? len : len - 1); i++) {
	                        var cp1 = controlPoints[i * 2];
	                        var cp2 = controlPoints[i * 2 + 1];
	                        var p = points[(i + 1) % len];
	                        ctx.bezierCurveTo(
	                            cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]
	                        );
	                    }
	                }
	                else {
	                    if (smooth === 'spline') {
	                        points = smoothSpline(points, closePath);
	                    }
	
	                    ctx.moveTo(points[0][0], points[0][1]);
	                    for (var i = 1, l = points.length; i < l; i++) {
	                        ctx.lineTo(points[i][0], points[i][1]);
	                    }
	                }
	
	                closePath && ctx.closePath();
	            }
	        }
	    };


/***/ },
/* 48 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Catmull-Rom spline 插值折线
	 * @module zrender/shape/util/smoothSpline
	 * @author pissang (https://www.github.com/pissang)
	 *         Kener (@Kener-林峰, kener.linfeng@gmail.com)
	 *         errorrik (errorrik@gmail.com)
	 */
	
	    var vec2 = __webpack_require__(14);
	
	    /**
	     * @inner
	     */
	    function interpolate(p0, p1, p2, p3, t, t2, t3) {
	        var v0 = (p2 - p0) * 0.5;
	        var v1 = (p3 - p1) * 0.5;
	        return (2 * (p1 - p2) + v0 + v1) * t3
	                + (-3 * (p1 - p2) - 2 * v0 - v1) * t2
	                + v0 * t + p1;
	    }
	
	    /**
	     * @alias module:zrender/shape/util/smoothSpline
	     * @param {Array} points 线段顶点数组
	     * @param {boolean} isLoop
	     * @return {Array}
	     */
	    module.exports = function (points, isLoop) {
	        var len = points.length;
	        var ret = [];
	
	        var distance = 0;
	        for (var i = 1; i < len; i++) {
	            distance += vec2.distance(points[i - 1], points[i]);
	        }
	
	        var segs = distance / 2;
	        segs = segs < len ? len : segs;
	        for (var i = 0; i < segs; i++) {
	            var pos = i / (segs - 1) * (isLoop ? len : len - 1);
	            var idx = Math.floor(pos);
	
	            var w = pos - idx;
	
	            var p0;
	            var p1 = points[idx % len];
	            var p2;
	            var p3;
	            if (!isLoop) {
	                p0 = points[idx === 0 ? idx : idx - 1];
	                p2 = points[idx > len - 2 ? len - 1 : idx + 1];
	                p3 = points[idx > len - 3 ? len - 1 : idx + 2];
	            }
	            else {
	                p0 = points[(idx - 1 + len) % len];
	                p2 = points[(idx + 1) % len];
	                p3 = points[(idx + 2) % len];
	            }
	
	            var w2 = w * w;
	            var w3 = w * w2;
	
	            ret.push([
	                interpolate(p0[0], p1[0], p2[0], p3[0], w, w2, w3),
	                interpolate(p0[1], p1[1], p2[1], p3[1], w, w2, w3)
	            ]);
	        }
	        return ret;
	    };
	


/***/ },
/* 49 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * 贝塞尔平滑曲线
	 * @module zrender/shape/util/smoothBezier
	 * @author pissang (https://www.github.com/pissang)
	 *         Kener (@Kener-林峰, kener.linfeng@gmail.com)
	 *         errorrik (errorrik@gmail.com)
	 */
	
	
	    var vec2 = __webpack_require__(14);
	    var v2Min = vec2.min;
	    var v2Max = vec2.max;
	    var v2Scale = vec2.scale;
	    var v2Distance = vec2.distance;
	    var v2Add = vec2.add;
	
	    /**
	     * 贝塞尔平滑曲线
	     * @alias module:zrender/shape/util/smoothBezier
	     * @param {Array} points 线段顶点数组
	     * @param {number} smooth 平滑等级, 0-1
	     * @param {boolean} isLoop
	     * @param {Array} constraint 将计算出来的控制点约束在一个包围盒内
	     *                           比如 [[0, 0], [100, 100]], 这个包围盒会与
	     *                           整个折线的包围盒做一个并集用来约束控制点。
	     * @param {Array} 计算出来的控制点数组
	     */
	    module.exports = function (points, smooth, isLoop, constraint) {
	        var cps = [];
	
	        var v = [];
	        var v1 = [];
	        var v2 = [];
	        var prevPoint;
	        var nextPoint;
	
	        var min, max;
	        if (constraint) {
	            min = [Infinity, Infinity];
	            max = [-Infinity, -Infinity];
	            for (var i = 0, len = points.length; i < len; i++) {
	                v2Min(min, min, points[i]);
	                v2Max(max, max, points[i]);
	            }
	            // 与指定的包围盒做并集
	            v2Min(min, min, constraint[0]);
	            v2Max(max, max, constraint[1]);
	        }
	
	        for (var i = 0, len = points.length; i < len; i++) {
	            var point = points[i];
	
	            if (isLoop) {
	                prevPoint = points[i ? i - 1 : len - 1];
	                nextPoint = points[(i + 1) % len];
	            }
	            else {
	                if (i === 0 || i === len - 1) {
	                    cps.push(vec2.clone(points[i]));
	                    continue;
	                }
	                else {
	                    prevPoint = points[i - 1];
	                    nextPoint = points[i + 1];
	                }
	            }
	
	            vec2.sub(v, nextPoint, prevPoint);
	
	            // use degree to scale the handle length
	            v2Scale(v, v, smooth);
	
	            var d0 = v2Distance(point, prevPoint);
	            var d1 = v2Distance(point, nextPoint);
	            var sum = d0 + d1;
	            if (sum !== 0) {
	                d0 /= sum;
	                d1 /= sum;
	            }
	
	            v2Scale(v1, v, -d0);
	            v2Scale(v2, v, d1);
	            var cp0 = v2Add([], point, v1);
	            var cp1 = v2Add([], point, v2);
	            if (constraint) {
	                v2Max(cp0, cp0, min);
	                v2Min(cp0, cp0, max);
	                v2Max(cp1, cp1, min);
	                v2Min(cp1, cp1, max);
	            }
	            cps.push(cp0);
	            cps.push(cp1);
	        }
	
	        if (isLoop) {
	            cps.push(cps.shift());
	        }
	
	        return cps;
	    };
	


/***/ },
/* 50 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @module zrender/graphic/shape/Polyline
	 */
	
	
	    var polyHelper = __webpack_require__(47);
	
	    module.exports = __webpack_require__(6).extend({
	        
	        type: 'polyline',
	
	        shape: {
	            points: null,
	
	            smooth: false,
	
	            smoothConstraint: null
	        },
	
	        style: {
	            stroke: '#000',
	
	            fill: null
	        },
	
	        buildPath: function (ctx, shape) {
	            polyHelper.buildPath(ctx, shape, false);
	        }
	    });


/***/ },
/* 51 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * 矩形
	 * @module zrender/graphic/shape/Rect
	 */
	
	
	    var roundRectHelper = __webpack_require__(52);
	
	    module.exports = __webpack_require__(6).extend({
	
	        type: 'rect',
	
	        shape: {
	            // 左上、右上、右下、左下角的半径依次为r1、r2、r3、r4
	            // r缩写为1         相当于 [1, 1, 1, 1]
	            // r缩写为[1]       相当于 [1, 1, 1, 1]
	            // r缩写为[1, 2]    相当于 [1, 2, 1, 2]
	            // r缩写为[1, 2, 3] 相当于 [1, 2, 3, 2]
	            r: 0,
	
	            x: 0,
	            y: 0,
	            width: 0,
	            height: 0
	        },
	
	        buildPath: function (ctx, shape) {
	            var x = shape.x;
	            var y = shape.y;
	            var width = shape.width;
	            var height = shape.height;
	            if (!shape.r) {
	                ctx.rect(x, y, width, height);
	            }
	            else {
	                roundRectHelper.buildPath(ctx, shape);
	            }
	            ctx.closePath();
	            return;
	        }
	    });
	


/***/ },
/* 52 */
/***/ function(module, exports) {

	
	
	    module.exports = {
	        buildPath: function (ctx, shape) {
	            var x = shape.x;
	            var y = shape.y;
	            var width = shape.width;
	            var height = shape.height;
	            var r = shape.r;
	            var r1;
	            var r2;
	            var r3;
	            var r4;
	
	            // Convert width and height to positive for better borderRadius
	            if (width < 0) {
	                x = x + width;
	                width = -width;
	            }
	            if (height < 0) {
	                y = y + height;
	                height = -height;
	            }
	
	            if (typeof r === 'number') {
	                r1 = r2 = r3 = r4 = r;
	            }
	            else if (r instanceof Array) {
	                if (r.length === 1) {
	                    r1 = r2 = r3 = r4 = r[0];
	                }
	                else if (r.length === 2) {
	                    r1 = r3 = r[0];
	                    r2 = r4 = r[1];
	                }
	                else if (r.length === 3) {
	                    r1 = r[0];
	                    r2 = r4 = r[1];
	                    r3 = r[2];
	                }
	                else {
	                    r1 = r[0];
	                    r2 = r[1];
	                    r3 = r[2];
	                    r4 = r[3];
	                }
	            }
	            else {
	                r1 = r2 = r3 = r4 = 0;
	            }
	
	            var total;
	            if (r1 + r2 > width) {
	                total = r1 + r2;
	                r1 *= width / total;
	                r2 *= width / total;
	            }
	            if (r3 + r4 > width) {
	                total = r3 + r4;
	                r3 *= width / total;
	                r4 *= width / total;
	            }
	            if (r2 + r3 > height) {
	                total = r2 + r3;
	                r2 *= height / total;
	                r3 *= height / total;
	            }
	            if (r1 + r4 > height) {
	                total = r1 + r4;
	                r1 *= height / total;
	                r4 *= height / total;
	            }
	            ctx.moveTo(x + r1, y);
	            ctx.lineTo(x + width - r2, y);
	            r2 !== 0 && ctx.quadraticCurveTo(
	                x + width, y, x + width, y + r2
	            );
	            ctx.lineTo(x + width, y + height - r3);
	            r3 !== 0 && ctx.quadraticCurveTo(
	                x + width, y + height, x + width - r3, y + height
	            );
	            ctx.lineTo(x + r4, y + height);
	            r4 !== 0 && ctx.quadraticCurveTo(
	                x, y + height, x, y + height - r4
	            );
	            ctx.lineTo(x, y + r1);
	            r1 !== 0 && ctx.quadraticCurveTo(x, y, x + r1, y);
	        }
	    };


/***/ },
/* 53 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * 直线
	 * @module zrender/graphic/shape/Line
	 */
	
	    module.exports = __webpack_require__(6).extend({
	
	        type: 'line',
	
	        shape: {
	            // Start point
	            x1: 0,
	            y1: 0,
	            // End point
	            x2: 0,
	            y2: 0,
	
	            percent: 1
	        },
	
	        style: {
	            stroke: '#000',
	            fill: null
	        },
	
	        buildPath: function (ctx, shape) {
	            var x1 = shape.x1;
	            var y1 = shape.y1;
	            var x2 = shape.x2;
	            var y2 = shape.y2;
	            var percent = shape.percent;
	
	            if (percent === 0) {
	                return;
	            }
	
	            ctx.moveTo(x1, y1);
	
	            if (percent < 1) {
	                x2 = x1 * (1 - percent) + x2 * percent;
	                y2 = y1 * (1 - percent) + y2 * percent;
	            }
	            ctx.lineTo(x2, y2);
	        },
	
	        /**
	         * Get point at percent
	         * @param  {number} percent
	         * @return {Array.<number>}
	         */
	        pointAt: function (p) {
	            var shape = this.shape;
	            return [
	                shape.x1 * (1 - p) + shape.x2 * p,
	                shape.y1 * (1 - p) + shape.y2 * p
	            ];
	        }
	    });
	


/***/ },
/* 54 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	/**
	 * 贝塞尔曲线
	 * @module zrender/shape/BezierCurve
	 */
	
	
	    var curveTool = __webpack_require__(26);
	    var vec2 = __webpack_require__(14);
	    var quadraticSubdivide = curveTool.quadraticSubdivide;
	    var cubicSubdivide = curveTool.cubicSubdivide;
	    var quadraticAt = curveTool.quadraticAt;
	    var cubicAt = curveTool.cubicAt;
	    var quadraticDerivativeAt = curveTool.quadraticDerivativeAt;
	    var cubicDerivativeAt = curveTool.cubicDerivativeAt;
	
	    var out = [];
	
	    function someVectorAt(shape, t, isTangent) {
	        var cpx2 = shape.cpx2;
	        var cpy2 = shape.cpy2;
	        if (cpx2 === null || cpy2 === null) {
	            return [
	                (isTangent ? cubicDerivativeAt : cubicAt)(shape.x1, shape.cpx1, shape.cpx2, shape.x2, t),
	                (isTangent ? cubicDerivativeAt : cubicAt)(shape.y1, shape.cpy1, shape.cpy2, shape.y2, t)
	            ];
	        }
	        else {
	            return [
	                (isTangent ? quadraticDerivativeAt : quadraticAt)(shape.x1, shape.cpx1, shape.x2, t),
	                (isTangent ? quadraticDerivativeAt : quadraticAt)(shape.y1, shape.cpy1, shape.y2, t)
	            ];
	        }
	    }
	    module.exports = __webpack_require__(6).extend({
	
	        type: 'bezier-curve',
	
	        shape: {
	            x1: 0,
	            y1: 0,
	            x2: 0,
	            y2: 0,
	            cpx1: 0,
	            cpy1: 0,
	            // cpx2: 0,
	            // cpy2: 0
	
	            // Curve show percent, for animating
	            percent: 1
	        },
	
	        style: {
	            stroke: '#000',
	            fill: null
	        },
	
	        buildPath: function (ctx, shape) {
	            var x1 = shape.x1;
	            var y1 = shape.y1;
	            var x2 = shape.x2;
	            var y2 = shape.y2;
	            var cpx1 = shape.cpx1;
	            var cpy1 = shape.cpy1;
	            var cpx2 = shape.cpx2;
	            var cpy2 = shape.cpy2;
	            var percent = shape.percent;
	            if (percent === 0) {
	                return;
	            }
	
	            ctx.moveTo(x1, y1);
	
	            if (cpx2 == null || cpy2 == null) {
	                if (percent < 1) {
	                    quadraticSubdivide(
	                        x1, cpx1, x2, percent, out
	                    );
	                    cpx1 = out[1];
	                    x2 = out[2];
	                    quadraticSubdivide(
	                        y1, cpy1, y2, percent, out
	                    );
	                    cpy1 = out[1];
	                    y2 = out[2];
	                }
	
	                ctx.quadraticCurveTo(
	                    cpx1, cpy1,
	                    x2, y2
	                );
	            }
	            else {
	                if (percent < 1) {
	                    cubicSubdivide(
	                        x1, cpx1, cpx2, x2, percent, out
	                    );
	                    cpx1 = out[1];
	                    cpx2 = out[2];
	                    x2 = out[3];
	                    cubicSubdivide(
	                        y1, cpy1, cpy2, y2, percent, out
	                    );
	                    cpy1 = out[1];
	                    cpy2 = out[2];
	                    y2 = out[3];
	                }
	                ctx.bezierCurveTo(
	                    cpx1, cpy1,
	                    cpx2, cpy2,
	                    x2, y2
	                );
	            }
	        },
	
	        /**
	         * Get point at percent
	         * @param  {number} t
	         * @return {Array.<number>}
	         */
	        pointAt: function (t) {
	            return someVectorAt(this.shape, t, false);
	        },
	
	        /**
	         * Get tangent at percent
	         * @param  {number} t
	         * @return {Array.<number>}
	         */
	        tangentAt: function (t) {
	            var p = someVectorAt(this.shape, t, true);
	            return vec2.normalize(p, p);
	        }
	    });
	


/***/ },
/* 55 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * 圆弧
	 * @module zrender/graphic/shape/Arc
	 */
	 
	
	    module.exports = __webpack_require__(6).extend({
	
	        type: 'arc',
	
	        shape: {
	
	            cx: 0,
	
	            cy: 0,
	
	            r: 0,
	
	            startAngle: 0,
	
	            endAngle: Math.PI * 2,
	
	            clockwise: true
	        },
	
	        style: {
	
	            stroke: '#000',
	
	            fill: null
	        },
	
	        buildPath: function (ctx, shape) {
	
	            var x = shape.cx;
	            var y = shape.cy;
	            var r = Math.max(shape.r, 0);
	            var startAngle = shape.startAngle;
	            var endAngle = shape.endAngle;
	            var clockwise = shape.clockwise;
	
	            var unitX = Math.cos(startAngle);
	            var unitY = Math.sin(startAngle);
	
	            ctx.moveTo(unitX * r + x, unitY * r + y);
	            ctx.arc(x, y, r, startAngle, endAngle, !clockwise);
	        }
	    });


/***/ },
/* 56 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	
	    var zrUtil = __webpack_require__(4);
	
	    var Gradient = __webpack_require__(37);
	
	    /**
	     * x, y, x2, y2 are all percent from 0 to 1
	     * @param {number} [x=0]
	     * @param {number} [y=0]
	     * @param {number} [x2=1]
	     * @param {number} [y2=0]
	     * @param {Array.<Object>} colorStops
	     * @param {boolean} [globalCoord=false]
	     */
	    var LinearGradient = function (x, y, x2, y2, colorStops, globalCoord) {
	        this.x = x == null ? 0 : x;
	
	        this.y = y == null ? 0 : y;
	
	        this.x2 = x2 == null ? 1 : x2;
	
	        this.y2 = y2 == null ? 0 : y2;
	
	        // Can be cloned
	        this.type = 'linear';
	
	        // If use global coord
	        this.global = globalCoord || false;
	
	        Gradient.call(this, colorStops);
	    };
	
	    LinearGradient.prototype = {
	
	        constructor: LinearGradient
	    };
	
	    zrUtil.inherits(LinearGradient, Gradient);
	
	    module.exports = LinearGradient;


/***/ },
/* 57 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	
	    var zrUtil = __webpack_require__(4);
	
	    var Gradient = __webpack_require__(37);
	
	    /**
	     * x, y, r are all percent from 0 to 1
	     * @param {number} [x=0.5]
	     * @param {number} [y=0.5]
	     * @param {number} [r=0.5]
	     * @param {Array.<Object>} [colorStops]
	     * @param {boolean} [globalCoord=false]
	     */
	    var RadialGradient = function (x, y, r, colorStops, globalCoord) {
	        this.x = x == null ? 0.5 : x;
	
	        this.y = y == null ? 0.5 : y;
	
	        this.r = r == null ? 0.5 : r;
	
	        // Can be cloned
	        this.type = 'radial';
	
	        // If use global coord
	        this.global = globalCoord || false;
	
	        Gradient.call(this, colorStops);
	    };
	
	    RadialGradient.prototype = {
	
	        constructor: RadialGradient
	    };
	
	    zrUtil.inherits(RadialGradient, Gradient);
	
	    module.exports = RadialGradient;


/***/ },
/* 58 */
/***/ function(module, exports, __webpack_require__) {

	
	    var zrUtil = __webpack_require__(4);
	    var BoundingRect = __webpack_require__(24);
	    function Minimap(bigCanvas,groupPosition, group,eagleEyeNode,distance,imgSrc) {
	
	        this.bigCanvas = bigCanvas;
	        this.eagleEyeNode = eagleEyeNode;
	        this.distance = distance;
	        this.imgSrc = imgSrc;
	        this.ratio;
	        this.groupRatio;
	        this.group = group;
	        this.img = document.createElement("img");
	        this.selection = document.createElement('div');
	        this.groupPosition = zrUtil.clone(groupPosition);
	        this.selectPosition = [0,0];
	        this.render();
	    }
	
	    Minimap.prototype.render = function() {
	        var that = this;
	        that.ratio = 0.12;
	        var eagleEyeNodeWidth = that.group.width  * that.ratio;
	        var eagleEyeNodeHeight = that.group.height  * that.ratio;
	        that.eagleEyeNode.style.width = eagleEyeNodeWidth+"px";
	        that.eagleEyeNode.style.height = eagleEyeNodeHeight+"px";
	        that.eagleEyeNode.style.marginTop = -eagleEyeNodeHeight+"px";
	        that.eagleEyeNode.style.marginLeft = that.bigCanvas.getWidth()-eagleEyeNodeWidth+"px";
	        that.eagleEyeNode.style.position="relative";
	        that.eagleEyeNode.style.background = "url("+that.imgSrc+") no-repeat";
	        that.eagleEyeNode.style.backgroundSize = eagleEyeNodeWidth/(that.group.width*that.distance[2]/that.bigCanvas.getWidth())+"px";
	        that.backgroundSize = zrUtil.clone(that.eagleEyeNode.style.backgroundSize);
	        that.eagleEyeNode.innerHTML = "";
	        that.selection.style.border = "1px solid #ff0000";
	        that.selection.style.cursor = "pointer";
	        that.selection.style.width = that.bigCanvas.getWidth()/that.group.width*eagleEyeNodeWidth+"px";
	        that.selection.style.height = that.bigCanvas.getHeight()/that.group.height*eagleEyeNodeHeight+"px";
	        that.selectWidth = that.selection.style.width;
	        that.selectHeight = that.selection.style.height;
	        that.selection.style.position="absolute";
	        that.selection.style.top = 0+"px";
	        that.selection.style.left = 0+"px";
	        that.eagleEyeNode.appendChild(this.selection);
	    };
	    Minimap.prototype.updataSelection = function(offectLeft,offectTop,zoomScale,nowZoom){
	        var that = this;
	        that.zoomScale = zoomScale;
	        this.selection.style.width = this.selection.style.width.replace("px","")/zoomScale+"px";
	        this.selection.style.height = this.selection.style.height.replace("px","")/zoomScale+"px";
	        that.selectPosition[0] = zrUtil.clone(offectLeft)*that.ratio/nowZoom;
	        that.selectPosition[1] = zrUtil.clone(offectTop)*that.ratio/nowZoom;
	        this.selection.style.left = -that.selectPosition[0]+"px";
	        this.selection.style.top = -that.selectPosition[1]+"px";
	    };
	    Minimap.prototype.updataMap = function(imgSrc,newGroup){
	        var that = this;
	        that.eagleEyeNode.style.backgroundImage = "url("+imgSrc+")";
	        var eagleEyeNodeWidth = newGroup.width  * that.ratio;
	        var eagleEyeNodeHeight = newGroup.height  * that.ratio;
	        that.eagleEyeNode.style.width = eagleEyeNodeWidth+"px";
	        that.eagleEyeNode.style.height = eagleEyeNodeHeight+"px";
	        that.eagleEyeNode.style.marginTop = -eagleEyeNodeHeight+"px";
	        that.eagleEyeNode.style.marginLeft = that.bigCanvas.getWidth()-eagleEyeNodeWidth+"px";
	    };
	    Minimap.prototype.updataSelectionPosition = function(nowGroupPosition,nowZoom){
	        var that = this;
	        that.selectPosition[0] = zrUtil.clone(nowGroupPosition[0])*that.ratio/nowZoom;
	        that.selectPosition[1] = zrUtil.clone(nowGroupPosition[1])*that.ratio/nowZoom;
	        this.selection.style.left = -that.selectPosition[0]+"px";
	        this.selection.style.top = -that.selectPosition[1]+"px";
	    };
	    Minimap.prototype.updataGroupPosition = function(group,nowZoom){
	        var that = this;
	        var positionX = -Number(that.selection.style.left.substring(0,that.selection.style.left.length-2))/that.ratio*nowZoom;
	        var positionY = -Number(that.selection.style.top.substring(0,that.selection.style.top.length-2))/that.ratio*nowZoom;
	        group.attr("position",[positionX,positionY]);
	    };
	
	    module.exports = Minimap;
	


/***/ },
/* 59 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * 工具方法类
	 * @author wang.xiaohu
	 */
	
	    var Point = __webpack_require__(60);
	    var Line = __webpack_require__(61);
	    var graphic = __webpack_require__(3);
	    var BoundingRect = __webpack_require__(24);
	    var zrUtil = __webpack_require__(4);
	    /**
	     * 构造类继承关系
	     *
	     * @param {Function} clazz 源类
	     * @param {Function} baseClazz 基类
	     */
	    function inherits(clazz, baseClazz) {
	        var clazzPrototype = clazz.prototype;
	
	        function F() {}
	        F.prototype = baseClazz.prototype;
	        clazz.prototype = new F();
	
	        for (var prop in clazzPrototype) {
	            clazz.prototype[prop] = clazzPrototype[prop];
	        }
	        clazz.prototype.constructor = clazz;
	        clazz.superClass = baseClazz;
	    }
	
	    function getUUID() {
	        var chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split(''),
	            uuid = new Array(36),
	            rnd = 0,
	            r;
	        for (var i = 0; i < 36; i++) {
	            if (i == 8 || i == 13 || i == 18 || i == 23) {
	                uuid[i] = '-';
	            } else if (i == 14) {
	                uuid[i] = '4';
	            } else {
	                if (rnd <= 0x02) rnd = 0x2000000 + (Math.random() * 0x1000000) | 0;
	                r = rnd & 0xf;
	                rnd = rnd >> 4;
	                uuid[i] = chars[(i == 19) ? (r & 0x3) | 0x8 : r];
	            }
	        }
	        return "sid-" + uuid.join('');
	    }
	
	
	    /**
	     * 计算两点之间的距离
	     *@param {Point} p1 - first {Point}
	     *@param {Point} p2 - second {Point}
	     *@return {Number} - the distance between those 2 points. It is always positive.
	     **/
	    function distance(p1, p2) {
	        return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
	    }
	
	    /**
	     * 返回一条折线 最长的两个点
	     * @param  {[type]} points [description]
	     * @return {[type]}        [description]
	     */
	    function getMaxLineLength(points) {
	        var m = distance(points[0], points[1]);
	        var result = [points[0], points[1]];
	        for (var i = 1; i < points.length - 1; i++) {
	
	            if (m < distance(points[i], points[i + 1])) {
	                m = distance(points[i], points[i + 1])
	                result = [points[i], points[i + 1]];
	            }
	        }
	
	        return result;
	    }
	
	    /**Returns the length of a Polyline that would be created with a set of points
	     *@param {Array} v - an {Array} of {Points}
	     *@return {Number} - a positive number equal with total length*/
	    function getPolylineLength(v) {
	        var l = 0;
	        for (var i = 0; i < v.length - 1; i++) {
	            l += distance(v[i], v[i + 1]);
	        }
	
	        return l;
	    }
	
	
	    /**Returns the max of a vector
	     *@param {Array} v - vector of {Number}s
	     *@return {Number} - the maximum number from the vector or NaN if vector is empty
	     **/
	    function max(v) {
	        if (v.lenght == 0) {
	            return NaN;
	        } else {
	            var m = v[0];
	            for (var i = 0; i < v.length; i++) {
	                if (m < v[i]) {
	                    m = v[i];
	                }
	            }
	
	            return m;
	        }
	    }
	
	
	    /**Returns the min of a vector
	     *@param {Array} v - vector of {Number}s
	     *@return {Number} - the minimum number from the vector or NaN if vector is empty
	     *@author alex@scriptoid.com
	     **/
	    function min(v) {
	        if (v.lenght == 0) {
	            return NaN;
	        } else {
	            var m = v[0];
	            for (var i = 0; i < v.length; i++) {
	                if (m > v[i]) {
	                    m = v[i];
	                }
	            }
	
	            return m;
	        }
	    }
	
	    /**
	     * 判断 点数组 是否正交直线路径
	     *Tests if a vector of points is an orthogonal path (moving in multiples of 90 degrees)
	     *@param {Array} v - an {Array} of {Point}s
	     *@return {Boolean} - true if path is valid, false otherwise
	     **/
	    function orthogonalPath(v) {
	        if (v.length <= 1) {
	            return true;
	        }
	
	        for (var i = 0; i < v.length - 1; i++) {
	            if (v[i].x != v[i + 1].x && v[i].y != v[i + 1].y) {
	                return false;
	            }
	        }
	
	        return true;
	    }
	
	
	    /**
	     *Test to see if 2 {Line}s intersects. They are considered finite segments
	     *and not the infinite lines from geometry
	     *@param {Line} l1 - fist line/segment
	     *@param {Line} l2 - last line/segment
	     *@return {Boolean} true - if the lines intersect or false if not
	     **/
	    function lineIntersectsLine(l1, l2) {
	        // check for two vertical lines
	        if (l1.startPoint.x == l1.endPoint.x && l2.startPoint.x == l2.endPoint.x) {
	            return l1.startPoint.x == l2.startPoint.x ? // if 'infinite 'lines do coincide,
	                // then check segment bounds for overlapping
	                l1.contains(l2.startPoint.x, l2.startPoint.y) ||
	                l1.contains(l2.endPoint.x, l2.endPoint.y) :
	                // lines are paralel
	                false;
	        }
	        // if one line is vertical, and another line is not vertical
	        else if (l1.startPoint.x == l1.endPoint.x || l2.startPoint.x == l2.endPoint.x) {
	            // let assume l2 is vertical, otherwise exchange them
	            if (l1.startPoint.x == l1.endPoint.x) {
	                var l = l1;
	                l1 = l2;
	                l2 = l;
	            }
	            // finding intersection of 'infinite' lines
	            // equation of the first line is y = ax + b, second: x = c
	            var a = (l1.endPoint.y - l1.startPoint.y) / (l1.endPoint.x - l1.startPoint.x);
	            var b = l1.startPoint.y - a * l1.startPoint.x;
	            var x0 = l2.startPoint.x;
	            var y0 = a * x0 + b;
	            return l1.contains(x0, y0) && l2.contains(x0, y0);
	        }
	
	        // check normal case - both lines are not vertical
	        else {
	            //line equation is : y = a*x + b, b = y - a * x
	            var a1 = (l1.endPoint.y - l1.startPoint.y) / (l1.endPoint.x - l1.startPoint.x);
	            var b1 = l1.startPoint.y - a1 * l1.startPoint.x;
	
	            var a2 = (l2.endPoint.y - l2.startPoint.y) / (l2.endPoint.x - l2.startPoint.x);
	            var b2 = l2.startPoint.y - a2 * l2.startPoint.x;
	
	            if (a1 == a2) { //paralel lines
	                return b1 == b2 ?
	                    // for coincide lines, check for segment bounds overlapping
	                    l1.contains(l2.startPoint.x, l2.startPoint.y) || l1.contains(l2.endPoint.x, l2.endPoint.y) :
	                    // not coincide paralel lines have no chance to intersect
	                    false;
	            } else { //usual case - non paralel, the 'infinite' lines intersects...we only need to know if inside the segment
	
	                /*
	                 * if one of the lines are vertical, then x0 is equal to their x,
	                 * otherwise:
	                 * y1 = a1 * x + b1
	                 * y2 = a2 * x + b2
	                 * => x0 = (b2 - b1) / (a1 - a2)
	                 * => y0 = a1 * x0 + b1
	                 **/
	                x0 = (b2 - b1) / (a1 - a2);
	                y0 = a1 * x0 + b1;
	                return l1.contains(x0, y0) && l2.contains(x0, y0);
	            }
	        }
	    }
	
	    /**
	     *
	     *Tests if a a polyline defined by a set of points intersects a rectangle
	     *@param {Array} points - and {Array} of {Point}s
	     *@param {Array} bounds - the bounds of the rectangle defined by (x1, y1, x2, y2)
	     *@param {Boolean} closedPolyline - incase polyline is closed figure then true, else false
	     *
	     *@return true - if line intersects the rectangle, false - if not
	     **/
	    function polylineIntersectsRectangle(points, bounds, closedPolyline) {
	
	
	        //get the 4 lines/segments represented by the bounds
	        var lines = [];
	        lines.push(new Line(new Point(bounds[0], bounds[1]), new Point(bounds[2], bounds[1])));
	        lines.push(new Line(new Point(bounds[2], bounds[1]), new Point(bounds[2], bounds[3])));
	        lines.push(new Line(new Point(bounds[2], bounds[3]), new Point(bounds[0], bounds[3])));
	        lines.push(new Line(new Point(bounds[0], bounds[3]), new Point(bounds[0], bounds[1])));
	
	        for (var k = 0; k < points.length - 1; k++) {
	            //create a line out of each 2 consecutive points
	            var tempLine = new Line(points[k], points[k + 1]);
	
	            //see if that line intersect any of the line on bounds border
	            for (var i = 0; i < lines.length; i++) {
	                if (lineIntersectsLine(tempLine, lines[i])) {
	                    return true;
	                }
	            }
	        }
	
	        //check the closed figure - that is last point connected to the first
	        if (closedPolyline) {
	            //create a line out of each 2 consecutive points
	            var tempLine1 = new Line(points[points.length - 1], points[0]);
	
	            //see if that line intersect any of the line on bounds border
	            for (var j = 0; j < lines.length; j++) {
	                if (lineIntersectsLine(tempLine1, lines[j])) {
	                    return true;
	                }
	            }
	        }
	
	        return false;
	    }
	
	    /**
	     * 计算路径的分数
	     * Score a ortogonal path made out of Points
	     *Iterates over a set of points (minimum 3)
	     *For each 3 points (i, i+1, i+2) :
	     *  - if the 3rd one is after the 2nd on the same line we add +1
	     *  - if the 3rd is up or down related to the 2nd we do not do anything +0
	     *  - if the 3rd goes back we imediatelly return -1
	     *@param {Array} v - an array of {Point}s
	     *@return {Number} - -1 if the path is wrong (goes back) or something >= 0 if is fine
	     *  The bigger the number the smooth the path is
	     **/
	    function scorePath(v) {
	        if (v.length <= 2) {
	            return -1;
	        }
	
	        var score = 0;
	        for (var i = 1; i < v.length - 1; i++) {
	            if (v[i - 1].x == v[i].x && v[i].x == v[i + 1].x) { //on the same vertical
	                if (signum(v[i + 1].y - v[i].y) == signum(v[i].y - v[i - 1].y)) { //same direction
	                    score++;
	                } else { //going back - no good
	                    return -1;
	                }
	            } else if (v[i - 1].y == v[i].y && v[i].y == v[i + 1].y) { //on the same horizontal
	                if (signum(v[i + 1].x - v[i].x) == signum(v[i].x - v[i - 1].x)) { //same direction
	                    score++;
	                } else { //going back - no good
	                    return -1;
	                }
	            } else { //not on same vertical nor horizontal
	                score--;
	            }
	        }
	
	        return score;
	    }
	
	    /**
	     * 返回数字符号（+ -)
	     * Returns the sign of a number
	     *@param {Number} x - the number
	     *@returns {Number}
	     *@see <a href="http://en.wikipedia.org/wiki/Sign_function">http://en.wikipedia.org/wiki/Sign_function</a>
	     **/
	    function signum(x) {
	        if (x > 0)
	            return 1;
	        else if (x < 0)
	            return -1;
	        else
	            return 0;
	    }
	
	    /**
	     * 判断 点数组 是不是有效路径（没有回路）
	     *Tests if a vector of points is a valid path (not going back)
	     *There are a few problems here. If you have p1, p2, p3 and p4 and p2 = p3 you need to ignore that
	     *@param {Array} v - an {Array} of {Point}s
	     *@return {Boolean} - true if path is valid, false otherwise
	     **/
	    function forwardPath(v) {
	        if (v.length <= 2) {
	            return true;
	        }
	
	        for (var i = 0; i < v.length - 2; i++) {
	            if (v[i].x == v[i + 1].x && v[i + 1].x == v[i + 2].x) { //on the same vertical
	                if (signum(v[i + 1].y - v[i].y) != 0) { //test only we have a progressing path
	                    if (signum(v[i + 1].y - v[i].y) == -1 * signum(v[i + 2].y - v[i + 1].y)) { //going back (ignore zero)
	                        return false;
	                    }
	                }
	            } else if (v[i].y == v[i + 1].y && v[i + 1].y == v[i + 2].y) { //on the same horizontal
	                if (signum(v[i + 1].x - v[i].x) != 0) { //test only we have a progressing path
	                    if (signum(v[i + 1].x - v[i].x) == -1 * signum(v[i + 2].x - v[i + 1].x)) { //going back (ignore zero)
	                        return false;
	                    }
	                }
	            }
	        }
	
	        return true;
	    }
	
	    /**
	     * 将[x:0,y:0]转化为[0, 0]  给zrender使用
	     * @param  {[type]} points [description]
	     * @param  {[type]} isRevert [description]
	     * @return {[type]}        [description]
	     */
	    function traslatePoints(points, isRevert) {
	        var newPoints = [];
	        if (isRevert) {
	            for (var i = 0; i < points.length; i++) {
	                var point = points[i];
	                newPoints.push(new Point(point[0], point[1]));
	            }
	            return newPoints;
	        } else {
	            for (var j = 0; j < points.length; j++) {
	                var point1 = points[j];
	                newPoints.push([point1.x, point1.y]);
	            }
	            return newPoints;
	        }
	
	
	    }
	
	    function rotationMatrix(angle) {
	        var mReturn = [
	            [Math.cos(angle), -Math.sin(angle), 0],
	            [Math.sin(angle), Math.cos(angle), 0],
	            [0, 0, 1]
	        ];
	        return mReturn;
	    }
	
	    function translationMatrix(dx, dy) {
	        return [
	            [1, 0, dx],
	            [0, 1, dy],
	            [0, 0, 1]
	        ];
	    }
	
	    function scaleMatrix(sx, sy) {
	        if (sy == null) {
	            sy = sx;
	        }
	        return [
	            [sx, 0, 0],
	            [0, sy, 0],
	            [0, 0, 1]
	        ];
	    }
	
	    /** It will return the end point of a line on a given angle (clockwise).
	     * @param {Point} startPoint - the start of the line
	     * @param {Number} length - the length of the line
	     * @param {Number} angle - the angle of the line in radians
	     * @return {Point} - the endPoint of the line
	     */
	    function getEndPoint(startPoint, length, angle) {
	        var endPoint = startPoint.clone();
	        endPoint.transform(translationMatrix(-startPoint.x, -startPoint.y));
	        endPoint.y -= length;
	        endPoint.transform(rotationMatrix(angle));
	        endPoint.transform(translationMatrix(startPoint.x, startPoint.y));
	        return endPoint;
	    }
	
	    /**
	     * 获取获取两个图形的外面四个连接点
	     * @param  {[type]} node [description]
	     * @return {[type]}      [description]
	     */
	    function getConnectorPoints(node) {
	        return {
	            left: new Point(node.x, node.y + node.height / 2), //矩形 左中的位置
	            top: new Point(node.x + node.width / 2, node.y), //矩形 上中的位置
	            right: new Point(node.x + node.width, node.y + node.height / 2), //矩形 右中的位置
	            bottom: new Point(node.x + node.width / 2, node.y + node.height), //矩形 下中的位置
	            center: new Point(node.x + node.width / 2, node.y + node.height / 2) //中间位置
	
	        };
	    }
	
	    /**
	     * 获取获取两个图形的外面四个连接点
	     * @param  {[type]} node [description]
	     * @return {[type]}      [description]
	     */
	    function getSoltPoints(node) {
	        return [
	            //top
	            [Math.round(node.getRect().width / 3 /10)*10, 0 ],
	            [Math.round(2*node.getRect().width / 3 /10)*10, 0 ],
	            //right
	            [node.getRect().width, Math.round(node.getRect().height / 3 /10)*10 ],
	            [node.getRect().width, Math.round(2*node.getRect().height / 3 /10)*10 ],
	            //bottom
	            [Math.round(node.getRect().width / 3 /10)*10, node.getRect().height ],
	            [Math.round(2*node.getRect().width / 3 /10)*10, node.getRect().height ],
	            //left
	            [0, Math.round(node.getRect().height / 3 /10)*10 ],
	            [0, Math.round(2*node.getRect().height / 3 /10)*10 ]
	
	        ]
	    }
	
	    /**
	     * 计算 p1 p2两点所连接的直线的角度
	     * @param  {[type]} p1 [description]
	     * @param  {[type]} p2 [description]
	     * @return {[type]}    [description]
	     */
	    function tangentRotation(p1, p2) {
	        return -Math.PI / 2 - Math.atan2(
	            p2.y - p1.y, p2.x - p1.x
	        );
	    }
	
	    /**
	     * 判断3点是否在一条直线上
	     * Tests if 3 points are coliniar with matrix determinants.
	     * If the determinat of matrix
	     * /         \
	     * | x1 y1 1 |
	     * | x2 y2 1 |
	     * | x3 y3 1 |
	     * \         /
	     * is zero it means that the points are colinear
	     *@param {Point} p1 - first point
	     *@param {Point} p2 - second point
	     *@param {Point} p3 - third point
	     * @param {Number} precission
	     *@return {Boolean} - true if coliniar and false if not
	     *@author Alex
	     *@see http://en.wikipedia.org/wiki/Determinant
	     *@see https://people.richland.edu/james/lecture/m116/matrices/applications.html
	     **/
	    function collinearity(p1, p2, p3, precission) {
	        var determinant = (p1.x * p2.y + p1.y * p3.x + p2.x * p3.y) - (p2.y * p3.x + p1.y * p2.x + p1.x * p3.y);
	
	        if (precission) {
	            return Math.abs(determinant) <= precission;
	        } else {
	            return determinant === 0;
	        }
	    }
	
	
	    /**
	     * 四舍五入 保存decimals的小数
	     **/
	    function enhancedRound(number, decimals) {
	        return Math.round(number * Math.pow(10, decimals)) / Math.pow(10, decimals);
	    }
	
	    /**
	     * 获取两点之间的长度
	     **/
	    function getLength(startPoint, endPoint) {
	        return Math.sqrt(Math.pow(startPoint.x - endPoint.x, 2) + Math.pow(startPoint.y - endPoint.y, 2));
	    }
	
	    /**
	     * 获取角度
	     * @param  {[type]} centerPoint  [description]
	     * @param  {[type]} outsidePoint [description]
	     * @param  {[type]} round        [description]
	     * @return {[type]}              [description]
	     */
	    function getAngle(centerPoint, outsidePoint, round) {
	        centerPoint.x = enhancedRound(centerPoint.x, 5);
	        centerPoint.y = enhancedRound(centerPoint.y, 5);
	        outsidePoint.x = enhancedRound(outsidePoint.x, 5);
	        outsidePoint.y = enhancedRound(outsidePoint.y, 5);
	        var angle = Math.atan((outsidePoint.x - centerPoint.x) / (outsidePoint.y - centerPoint.y));
	        angle = -angle;
	
	        //endAngle+=90;
	        if (outsidePoint.x >= centerPoint.x && outsidePoint.y >= centerPoint.y) {
	            angle += Math.PI;
	        } else if (outsidePoint.x <= centerPoint.x && outsidePoint.y >= centerPoint.y) {
	            angle += Math.PI;
	        } else if (outsidePoint.x <= centerPoint.x && outsidePoint.y <= centerPoint.y) {
	            angle += Math.PI * 2;
	        }
	        while (angle >= Math.PI * 2) {
	            angle -= Math.PI * 2;
	        }
	        if (isNaN(angle)) { //Nan
	            angle = 0; //we are at center point;
	        }
	        if (round) {
	            angle = Math.round(angle / round) * round
	        }
	        return angle;
	    }
	
	    function getRect(node) {
	        var boundingRect = node.getBoundingRect();
	        //创建最小包围盒虚线
	        var points = [];
	        points[0] = [-boundingRect.width / 2, -boundingRect.height / 2];
	        points[1] = [boundingRect.width / 2, -boundingRect.height / 2];
	        points[2] = [boundingRect.width / 2, boundingRect.height / 2];
	        points[3] = [-boundingRect.width / 2, boundingRect.height / 2];
	        points[4] = [-boundingRect.width / 2, -boundingRect.height / 2];
	
	        var boundRect, cx, cy;
	        if (node instanceof graphic.Circle) {
	            //注: 因事件为圆形  所以 x y 为圆心的位置  包围矩形要减去宽度一半
	            boundRect = new BoundingRect(Number(node.position[0]) - Number(boundingRect.width / 2),
	                Number(node.position[1]) - Number(boundingRect.height / 2),
	                Number(boundingRect.width), Number(boundingRect.height));
	            cx = Number(node.position[0]);
	            cy = Number(node.position[1]);
	        } else {
	            boundRect = new BoundingRect(Number(node.position[0]),
	                Number(node.position[1]),
	                Number(boundingRect.width), Number(boundingRect.height));
	            cx = Number(node.position[0]) + Number(boundingRect.width) / 2;
	            cy = Number(node.position[1]) + Number(boundingRect.height) / 2;
	        }
	        return {
	            x: Number(cx),
	            y: Number(cy),
	            width: Number(boundingRect.width),
	            height: Number(boundingRect.height),
	            points: points,
	            boundingRect: boundRect
	        };
	    }
	
	    var StackedMap = {
	        createNew: function() {
	            var stack = [];
	
	            return {
	                add: function(key, value) {
	                    var arrKey = this.get(key);
	                    arrKey.push(value)
	
	                },
	                get: function(key) {
	                    for (var i = 0; i < stack.length; i++) {
	                        if (key == stack[i].key) {
	                            return stack[i].value;
	                        }
	                    }
	                    //如果没有找到的话，则创建一个新的数组
	                    var value = [];
	                    stack.push({ key: key, value: value });
	                    return value;
	                },
	                keys: function() {
	                    var keys = [];
	                    for (var i = 0; i < stack.length; i++) {
	                        keys.push(stack[i].key);
	                    }
	                    return keys;
	                },
	                top: function() {
	                    return stack[stack.length - 1];
	                },
	                remove: function(key) {
	                    var idx = -1;
	                    for (var i = 0; i < stack.length; i++) {
	                        if (key == stack[i].key) {
	                            idx = i;
	                            break;
	                        }
	                    }
	                    return stack.splice(idx, 1)[0];
	                },
	                removeItem: function(key, item) {
	                    var arrKey = this.get(key);
	                    var index = zrUtil.indexOf(arrKey, item);
	                    arrKey.splice(index, 1);
	
	                },
	                removeTop: function() {
	                    return stack.splice(stack.length - 1, 1)[0];
	                },
	                length: function() {
	                    return stack.length;
	                },
	                clear: function() {
	                    stack.splice(0, stack.length);
	                }
	            };
	        }
	    };
	
	    function randomColor() {
	        var arrHex = ["0", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d"],
	            strHex = "#",
	            index;
	        for (var i = 0; i < 6; i++) {
	            index = Math.round(Math.random() * 15);
	            strHex += arrHex[index];
	        }
	        return strHex;
	    }
	
	    function isUndefined(obj) {
	        return obj === void 0;
	    }
	
	    function collinearReduction (v) {
	        var r = [];
	
	        if(v.length < 3){
	            return Point.cloneArray(v);
	        }
	
	        r.push( v[0].clone() );
	        for(var i=1; i < v.length-1; i++){
	            if( (v[i-1].x == v[i].x && v[i].x == v[i+1].x)  ||  (v[i-1].y == v[i].y && v[i].y == v[i+1].y) )
	            {
	                continue;
	            }
	            else{
	                r.push( v[i].clone() );
	            }
	        }
	        r.push( v[v.length-1].clone() );
	
	        return r;
	    }
	
	    // By default, Underscore uses ERB-style template delimiters, change the
	    // following template settings to use alternative delimiters.
	    var templateSettings = {
	        evaluate: /<%([\s\S]+?)%>/g,
	        interpolate: /<%=([\s\S]+?)%>/g,
	        escape: /<%-([\s\S]+?)%>/g
	    };
	
	    // When customizing `templateSettings`, if you don't want to define an
	    // interpolation, evaluation or escaping regex, we need one that is
	    // guaranteed not to match.
	    var noMatch = /(.)^/;
	
	    // Certain characters need to be escaped so that they can be put into a
	    // string literal.
	    var escapes = {
	        "'": "'",
	        '\\': '\\',
	        '\r': 'r',
	        '\n': 'n',
	        '\u2028': 'u2028',
	        '\u2029': 'u2029'
	    };
	
	    var escaper = /\\|'|\r|\n|\u2028|\u2029/g;
	
	    var escapeChar = function(match) {
	        return '\\' + escapes[match];
	    };
	
	    // JavaScript micro-templating, similar to John Resig's implementation.
	    // Underscore templating handles arbitrary delimiters, preserves whitespace,
	    // and correctly escapes quotes within interpolated code.
	    // NB: `oldSettings` only exists for backwards compatibility.
	    function template(text, settings, oldSettings) {
	        if (!settings && oldSettings) settings = oldSettings;
	        settings = settings || {};
	        settings = zrUtil.defaults(settings, templateSettings, true);
	
	        // Combine delimiters into one regular expression via alternation.
	        var matcher = RegExp([
	            (settings.escape || noMatch).source,
	            (settings.interpolate || noMatch).source,
	            (settings.evaluate || noMatch).source
	        ].join('|') + '|$', 'g');
	
	        // Compile the template source, escaping string literals appropriately.
	        var index = 0;
	        var source = "__p+='";
	        text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
	            source += text.slice(index, offset).replace(escaper, escapeChar);
	            index = offset + match.length;
	
	            if (escape) {
	                source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
	            } else if (interpolate) {
	                source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
	            } else if (evaluate) {
	                source += "';\n" + evaluate + "\n__p+='";
	            }
	
	            // Adobe VMs need the match returned to produce the correct offest.
	            return match;
	        });
	        source += "';\n";
	
	        // If a variable is not specified, place data values in local scope.
	        if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';
	
	        source = "var __t,__p='',__j=Array.prototype.join," +
	            "print=function(){__p+=__j.call(arguments,'');};\n" +
	            source + 'return __p;\n';
	
	        try {
	            var render = new Function(settings.variable || 'obj', source);
	        } catch (e) {
	            e.source = source;
	            throw e;
	        }
	
	        var template = function(data) {
	            return render.call(this, data);
	        };
	
	        // Provide the compiled source as a convenience for precompilation.
	        var argument = settings.variable || 'obj';
	        template.source = 'function(' + argument + '){\n' + source + '}';
	
	        return template;
	    }
	
	    function isEmpty(obj) {
	        if (obj == null) return true;
	        if (zrUtil.isArrayLike(obj) && (zrUtil.isArray(obj) || zrUtil.isString(obj))) return obj.length === 0;
	    }
	
	    module.exports = {
	        inherits: inherits,
	        getUUID: getUUID,
	        distance: distance,
	        getPolylineLength: getPolylineLength,
	        max: max,
	        min: min,
	        isEmpty: isEmpty,
	        orthogonalPath: orthogonalPath,
	        polylineIntersectsRectangle: polylineIntersectsRectangle,
	        scorePath: scorePath,
	        forwardPath: forwardPath,
	        traslatePoints: traslatePoints,
	        getEndPoint: getEndPoint,
	        getConnectorPoints: getConnectorPoints,
	        tangentRotation: tangentRotation,
	        collinearity: collinearity,
	        translationMatrix: translationMatrix,
	        scaleMatrix: scaleMatrix,
	        round: enhancedRound,
	        getLength: getLength,
	        getAngle: getAngle,
	        getRect: getRect,
	        StackedMap: StackedMap,
	        getMaxLineLength: getMaxLineLength,
	        randomColor: randomColor,
	        template: template,
	        isUndefined: isUndefined,
	        getSoltPoints:getSoltPoints,
	        collinearReduction: collinearReduction
	    };
	


/***/ },
/* 60 */
/***/ function(module, exports) {

	
	
	    /**
	      * Creates an instance of Point
	      *
	      *
	      * @constructor
	      * @this {Point}
	      * @param {Number} x The x coordinate of point.
	      * @param {Number} y The y coordinate of point.
	      * Note: Even if it is named Point this class should be named Dot as Dot is closer
	      * then Point from math perspective.
	      **/
	    function Point(x, y){
	        /**The x coordinate of point*/
	        this.x = x;
	        
	        /**The y coordinate of point*/
	        this.y = y;
	        
	
	    }
	
	    /**Creates a {Point} out of JSON parsed object
	     *@param {JSONObject} o - the JSON parsed object
	     *@return {Point} a newly constructed Point
	     **/
	    Point.load = function(o){
	        var newPoint = new Point(Number(o.x), Number(o.y));
	        return newPoint;
	    };
	
	
	    /**Creates an array of points from an array of {JSONObject}s
	     *@param {Array} v - the array of JSONObjects
	     *@return an {Array} of {Point}s
	     **/
	    Point.loadArray = function(v){
	        var newPoints = [];
	        for(var i=0; i< v.length; i++){
	            newPoints.push(Point.load(v[i]));
	        }
	        return newPoints;
	    };
	
	
	    /**Clones an array of points
	     *@param {Array} v - the array of {Point}s
	     *@return an {Array} of {Point}s
	     **/
	    Point.cloneArray = function(v){
	        var newPoints = [];
	        for(var i=0; i< v.length; i++){
	            newPoints.push(v[i].clone());
	        }
	        return newPoints;
	    };
	
	    Point.prototype = {
	        constructor : Point,
	        
	        transform:function(matrix){
	            var oldX = this.x;
	            var oldY = this.y;
	            this.x = matrix[0][0] * oldX + matrix[0][1] * oldY + matrix[0][2];
	            this.y = matrix[1][0] * oldX + matrix[1][1] * oldY + matrix[1][2];
	        },
	        
	        /**Tests if this point is similar to other point
	         *@param {Point} anotherPoint - the other point
	         **/
	        equals:function(anotherPoint){
	            if(! (anotherPoint instanceof Point) ){
	                return false;
	            }
	            return (this.x == anotherPoint.x)
	            && (this.y == anotherPoint.y)
	        },
	
	        /**Clone current Point
	         **/
	        clone: function(){
	            var newPoint = new Point(this.x, this.y);
	            return newPoint;
	        },
	
	        /**Tests to see if a point (x, y) is within a range of current Point
	         *@param {Numeric} x - the x coordinate of tested point
	         *@param {Numeric} y - the x coordinate of tested point
	         *@param {Numeric} radius - the radius of the vicinity
	         **/
	        near:function(x, y, radius){
	            var distance = Math.sqrt(Math.pow(this.x - x, 2) + Math.pow(this.y - y, 2));
	
	            return (distance <= radius);
	        },
	
	        contains: function(x,y){
	            return this.x == x && this.y == y;
	        },
	
	        toString:function(){
	            return '[' + this.x + ',' + this.y + ']';
	        },
	
	        getPoints:function(){
	            return [this];
	        }
	    };
	    module.exports = Point;
	    

/***/ },
/* 61 */
/***/ function(module, exports) {

	
	
	    /**
	      * Creates an instance of a Line. A Line is actually a segment and not a pure
	      * geometrical Line
	      *
	      * @constructor
	      * @this {Line}
	      * @param {Point} startPoint - starting point of the line
	      * @param {Point} endPoint - the ending point of the line
	      **/
	    function Line(startPoint, endPoint){
	        /**Starting {@link Point} of the line*/
	        this.startPoint = startPoint;
	
	        /**Ending {@link Point} of the line*/
	        this.endPoint = endPoint;
	
	        /**Serialization type*/
	        this.oType = 'Line'; //object type used for JSON deserialization
	    }
	
	    /**Creates a {Line} out of JSON parsed object
	     *@param {JSONObject} o - the JSON parsed object
	     *@return {Line} a newly constructed Line
	     **/
	    Line.load = function(o){
	        var newLine = new Line(
	            Point.load(o.startPoint),
	            Point.load(o.endPoint)
	        );
	
	        return newLine;
	    };
	
	    Line.prototype = {
	        contructor: Line,
	
	
	
	        clone:function(){
	            var ret = new Line(this.startPoint.clone(), this.endPoint.clone());
	            return ret;
	        },
	
	        equals:function(anotherLine){
	            if(!anotherLine instanceof Line){
	                return false;
	            }
	            return this.startPoint.equals(anotherLine.startPoint)
	            && this.endPoint.equals(anotherLine.endPoint)
	        },
	
	        /** Tests to see if a point belongs to this line (not as infinite line but more like a segment)
	         * Algorithm: Compute line's equation and see if (x, y) verifies it.
	         * @param {Number} x - the X coordinates
	         * @param {Number} y - the Y coordinates
	         **/
	        contains: function(x, y){
	            // if the point is inside rectangle bounds of the segment
	            if (Math.min(this.startPoint.x, this.endPoint.x) <= x
	                && x <= Math.max(this.startPoint.x, this.endPoint.x)
	                && Math.min(this.startPoint.y, this.endPoint.y) <= y
	                && y <= Math.max(this.startPoint.y, this.endPoint.y)) {
	
	                // check for vertical line
	                if (this.startPoint.x == this.endPoint.x) {
	                    return x == this.startPoint.x;
	                } else { // usual (not vertical) line can be represented as y = a * x + b
	                    var a = (this.endPoint.y - this.startPoint.y) / (this.endPoint.x - this.startPoint.x);
	                    var b = this.startPoint.y - a * this.startPoint.x;
	                    return y == a * x + b;
	                }
	            } else {
	                return false;
	            }
	        },
	
	        /*
	         *See if we are near a {Line} by a certain radius (also includes the extremities into computation)
	         *@param {Number} x - the x coordinates
	         *@param {Number} y - the y coordinates
	         *@param {Number} radius - the radius to search for
	         *@see http://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line
	         *@see "Mathematics for Computer Graphics, 2nd Ed., by John Vice, page 227"
	         **/
	        near:function(x,y,radius){
	
	            if(this.endPoint.x === this.startPoint.x){ //Vertical line, so the vicinity area is a rectangle
	                return ( (this.startPoint.y-radius<=y && this.endPoint.y+radius>=y)
	                        || (this.endPoint.y-radius<=y && this.startPoint.y+radius>=y))
	                && x > this.startPoint.x - radius && x < this.startPoint.x + radius ;
	            }
	
	            if(this.startPoint.y === this.endPoint.y){ //Horizontal line, so the vicinity area is a rectangle
	                return ( (this.startPoint.x - radius<=x && this.endPoint.x+radius>=x)
	                        || (this.endPoint.x-radius<=x && this.startPoint.x+radius>=x))
	                        && y>this.startPoint.y-radius && y<this.startPoint.y+radius ;
	            }
	
	
	            var startX = Math.min(this.endPoint.x,this.startPoint.x);
	            var startY = Math.min(this.endPoint.y,this.startPoint.y);
	            var endX = Math.max(this.endPoint.x,this.startPoint.x);
	            var endY = Math.max(this.endPoint.y,this.startPoint.y);
	
	            /*We will compute the distance from point to the line
	             * by using the algorithm from
	             * http://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line
	             * */
	
	            //First we need to find a,b,c of the line equation ax + by + c = 0
	            var a = this.endPoint.y - this.startPoint.y;
	            var b = this.startPoint.x - this.endPoint.x;
	            var c = -(this.startPoint.x * this.endPoint.y - this.endPoint.x * this.startPoint.y);
	
	            //Secondly we get the distance "Mathematics for Computer Graphics, 2nd Ed., by John Vice, page 227"
	            var d = Math.abs( (a*x + b*y + c) / Math.sqrt(Math.pow(a,2) + Math.pow(b,2)) );
	
	            //Thirdly we get coordinates of closest line's point to target point
	            //http://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line#Cartesian_coordinates
	            var closestX = (b * (b*x - a*y) - a*c) / ( Math.pow(a,2) + Math.pow(b,2) );
	            var closestY = (a * (-b*x + a*y) - b*c) / ( Math.pow(a,2) + Math.pow(b,2) );
	
	            var r = ( d <= radius && endX>=closestX && closestX>=startX && endY>=closestY && closestY>=startY ) //the projection of the point falls INSIDE of the segment
	                || this.startPoint.near(x,y,radius) || this.endPoint.near(x,y,radius); //the projection of the point falls OUTSIDE of the segment
	
	            return  r;
	
	        },
	
	        /**we need to create a new array each time, or we will affect the actual shape*/
	        getPoints:function(){
	            var points = [];
	            points.push(this.startPoint);
	            points.push(this.endPoint);
	            return points;
	        },
	
	        /**Return the {Point} corresponding the t certain t value
	         * @param {Number} t the value of parameter t, where t in [0,1], t is like a percent*/
	        getPoint: function(t){
	            var Xp = t * (this.endPoint.x - this.startPoint.x) + this.startPoint.x;
	            var Yp = t * (this.endPoint.y - this.startPoint.y) + this.startPoint.y;
	
	            return new Point(Xp, Yp);
	        },
	
	        // /**
	        //  * Returns the middle of the line
	        //  * @return {Point} the middle point
	        //  * */
	        // getMiddle : function(){
	        //     return Util.getMiddle(this.startPoint, this.endPoint);
	        // },
	
	
	        // getLength : function(){
	        //     return Util.getLength(this.startPoint, this.endPoint);
	        // },
	
	        // /**
	        //  *Get bounds for this line
	        //  *@author Alex Gheorghiu <alex@scriptoid.com>
	        //  **/
	        // getBounds:function(){
	        //     return Util.getBounds(this.getPoints());
	        // },
	
	        /**String representation*/
	        toString:function(){
	            return 'line(' + this.startPoint + ',' + this.endPoint + ')';
	        }
	    };
	    module.exports = Line;
	


/***/ },
/* 62 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	
	    var zrUtil = __webpack_require__(4);
	
	    var apiList = [
	        'getDom', 'getZr', 'getWidth', 'getHeight', 'dispatchAction',
	        'on', 'off', 'trigger', 'getDataURL', 'getConnectedDataURL', 'getModel', 'getOption'
	    ];
	
	    function ExtensionAPI(instance) {
	        zrUtil.each(apiList, function (name) {
	            this[name] = zrUtil.bind(instance[name], instance);
	        }, this);
	    }
	
	    module.exports = ExtensionAPI;
	


/***/ },
/* 63 */
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * ZRender, a high performance 2d drawing library.
	 *
	 * Copyright (c) 2013, Baidu Inc.
	 * All rights reserved.
	 *
	 * LICENSE
	 * https://github.com/ecomfe/zrender/blob/master/LICENSE.txt
	 */
	// Global defines
	
	    var guid = __webpack_require__(10);
	    var env = __webpack_require__(64);
	
	    var Handler = __webpack_require__(65);
	    var Storage = __webpack_require__(66);
	    var Animation = __webpack_require__(68);
	    var HandlerProxy = __webpack_require__(71);
	
	    var useVML = !env.canvasSupported;
	
	    var painterCtors = {
	        canvas: __webpack_require__(73)
	    };
	
	    var instances = {};    // ZRender实例map索引
	
	    var zrender = {};
	    /**
	     * @type {string}
	     */
	    zrender.version = '3.1.3';
	
	    /**
	     * Initializing a zrender instance
	     * @param {HTMLElement} dom
	     * @param {Object} opts
	     * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg'
	     * @param {number} [opts.devicePixelRatio]
	     * @return {module:zrender/ZRender}
	     */
	    zrender.init = function(dom, opts) {
	        var zr = new ZRender(guid(), dom, opts);
	        instances[zr.id] = zr;
	        return zr;
	    };
	
	    /**
	     * Dispose zrender instance
	     * @param {module:zrender/ZRender} zr
	     */
	    zrender.dispose = function (zr) {
	        if (zr) {
	            zr.dispose();
	        }
	        else {
	            for (var key in instances) {
	                instances[key].dispose();
	            }
	            instances = {};
	        }
	
	        return zrender;
	    };
	
	    /**
	     * Get zrender instance by id
	     * @param {string} id zrender instance id
	     * @return {module:zrender/ZRender}
	     */
	    zrender.getInstance = function (id) {
	        return instances[id];
	    };
	
	    zrender.registerPainter = function (name, Ctor) {
	        painterCtors[name] = Ctor;
	    };
	
	    function delInstance(id) {
	        delete instances[id];
	    }
	
	    /**
	     * @module zrender/ZRender
	     */
	    /**
	     * @constructor
	     * @alias module:zrender/ZRender
	     * @param {string} id
	     * @param {HTMLDomElement} dom
	     * @param {Object} opts
	     * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg'
	     * @param {number} [opts.devicePixelRatio]
	     */
	    var ZRender = function(id, dom, opts) {
	
	        opts = opts || {};
	
	        /**
	         * @type {HTMLDomElement}
	         */
	        this.dom = dom;
	
	        /**
	         * @type {string}
	         */
	        this.id = id;
	
	        var self = this;
	        var storage = new Storage();
	
	        var rendererType = opts.renderer;
	        if (useVML) {
	            if (!painterCtors.vml) {
	                throw new Error('You need to require \'zrender/vml/vml\' to support IE8');
	            }
	            rendererType = 'vml';
	        }
	        else if (!rendererType || !painterCtors[rendererType]) {
	            rendererType = 'canvas';
	        }
	        var painter = new painterCtors[rendererType](dom, storage, opts);
	
	        this.storage = storage;
	        this.painter = painter;
	
	        var handerProxy = !env.node ? new HandlerProxy(painter.getViewportRoot()) : null;
	        this.handler = new Handler(storage, painter, handerProxy);
	
	        /**
	         * @type {module:zrender/animation/Animation}
	         */
	        this.animation = new Animation({
	            stage: {
	                update: function () {
	                    if (self._needsRefresh) {
	                        self.refreshImmediately();
	                    }
	                    if (self._needsRefreshHover) {
	                        self.refreshHoverImmediately();
	                    }
	                }
	            }
	        });
	        this.animation.start();
	
	        /**
	         * @type {boolean}
	         * @private
	         */
	        this._needsRefresh;
	
	        // 修改 storage.delFromMap, 每次删除元素之前删除动画
	        // FIXME 有点ugly
	        var oldDelFromMap = storage.delFromMap;
	        var oldAddToMap = storage.addToMap;
	
	        storage.delFromMap = function (elId) {
	            var el = storage.get(elId);
	
	            oldDelFromMap.call(storage, elId);
	
	            el && el.removeSelfFromZr(self);
	        };
	
	        storage.addToMap = function (el) {
	            oldAddToMap.call(storage, el);
	
	            el.addSelfToZr(self);
	        };
	    };
	
	    ZRender.prototype = {
	
	        constructor: ZRender,
	        /**
	         * 获取实例唯一标识
	         * @return {string}
	         */
	        getId: function () {
	            return this.id;
	        },
	
	        /**
	         * 添加元素
	         * @param  {module:zrender/Element} el
	         */
	        add: function (el) {
	            this.storage.addRoot(el);
	            this._needsRefresh = true;
	        },
	
	        /**
	         * 删除元素
	         * @param  {module:zrender/Element} el
	         */
	        remove: function (el) {
	            this.storage.delRoot(el);
	            this._needsRefresh = true;
	        },
	
	        /**
	         * Change configuration of layer
	         * @param {string} zLevel
	         * @param {Object} config
	         * @param {string} [config.clearColor=0] Clear color
	         * @param {string} [config.motionBlur=false] If enable motion blur
	         * @param {number} [config.lastFrameAlpha=0.7] Motion blur factor. Larger value cause longer trailer
	        */
	        configLayer: function (zLevel, config) {
	            this.painter.configLayer(zLevel, config);
	            this._needsRefresh = true;
	        },
	
	        /**
	         * Repaint the canvas immediately
	         */
	        refreshImmediately: function () {
	            // Clear needsRefresh ahead to avoid something wrong happens in refresh
	            // Or it will cause zrender refreshes again and again.
	            this._needsRefresh = false;
	            this.painter.refresh();
	            /**
	             * Avoid trigger zr.refresh in Element#beforeUpdate hook
	             */
	            this._needsRefresh = false;
	        },
	
	        /**
	         * Mark and repaint the canvas in the next frame of browser
	         */
	        refresh: function() {
	            this._needsRefresh = true;
	        },
	
	        /**
	         * Add element to hover layer
	         * @param  {module:zrender/Element} el
	         * @param {Object} style
	         */
	        addHover: function (el, style) {
	            if (this.painter.addHover) {
	                this.painter.addHover(el, style);
	                this.refreshHover();
	            }
	        },
	
	        /**
	         * Add element from hover layer
	         * @param  {module:zrender/Element} el
	         */
	        removeHover: function (el) {
	            if (this.painter.removeHover) {
	                this.painter.removeHover(el);
	                this.refreshHover();
	            }
	        },
	
	        /**
	         * Clear all hover elements in hover layer
	         * @param  {module:zrender/Element} el
	         */
	        clearHover: function () {
	            if (this.painter.clearHover) {
	                this.painter.clearHover();
	                this.refreshHover();
	            }
	        },
	
	        /**
	         * Refresh hover in next frame
	         */
	        refreshHover: function () {
	            this._needsRefreshHover = true;
	        },
	
	        /**
	         * Refresh hover immediately
	         */
	        refreshHoverImmediately: function () {
	            this._needsRefreshHover = false;
	            this.painter.refreshHover && this.painter.refreshHover();
	        },
	
	        /**
	         * Resize the canvas.
	         * Should be invoked when container size is changed
	         */
	        resize: function() {
	            this.painter.resize();
	            this.handler.resize();
	        },
	
	        /**
	         * Stop and clear all animation immediately
	         */
	        clearAnimation: function () {
	            this.animation.clear();
	        },
	
	        /**
	         * Get container width
	         */
	        getWidth: function() {
	            return this.painter.getWidth();
	        },
	
	        /**
	         * Get container height
	         */
	        getHeight: function() {
	            return this.painter.getHeight();
	        },
	
	        /**
	         * Export the canvas as Base64 URL
	         * @param {string} type
	         * @param {string} [backgroundColor='#fff']
	         * @return {string} Base64 URL
	         */
	        // toDataURL: function(type, backgroundColor) {
	        //     return this.painter.getRenderedCanvas({
	        //         backgroundColor: backgroundColor
	        //     }).toDataURL(type);
	        // },
	
	        /**
	         * Converting a path to image.
	         * It has much better performance of drawing image rather than drawing a vector path.
	         * @param {module:zrender/graphic/Path} e
	         * @param {number} width
	         * @param {number} height
	         */
	        pathToImage: function(e, width, height) {
	            var id = guid();
	            return this.painter.pathToImage(id, e, width, height);
	        },
	
	        /**
	         * Set default cursor
	         * @param {string} [cursorStyle='default'] 例如 crosshair
	         */
	        setCursorStyle: function (cursorStyle) {
	            this.handler.setCursorStyle(cursorStyle);
	        },
	
	        /**
	         * Bind event
	         *
	         * @param {string} eventName Event name
	         * @param {Function} eventHandler Handler function
	         * @param {Object} [context] Context object
	         */
	        on: function(eventName, eventHandler, context) {
	            this.handler.on(eventName, eventHandler, context);
	        },
	
	        /**
	         * Unbind event
	         * @param {string} eventName Event name
	         * @param {Function} [eventHandler] Handler function
	         */
	        off: function(eventName, eventHandler) {
	            this.handler.off(eventName, eventHandler);
	        },
	
	        /**
	         * Trigger event manually
	         *
	         * @param {string} eventName Event name
	         * @param {event=} event Event object
	         */
	        trigger: function (eventName, event) {
	            this.handler.trigger(eventName, event);
	        },
	
	
	        /**
	         * Clear all objects and the canvas.
	         */
	        clear: function () {
	            this.storage.delRoot();
	            this.painter.clear();
	        },
	
	        /**
	         * Dispose self.
	         */
	        dispose: function () {
	            this.animation.stop();
	
	            this.clear();
	            this.storage.dispose();
	            this.painter.dispose();
	            this.handler.dispose();
	
	            this.animation =
	            this.storage =
	            this.painter =
	            this.handler = null;
	
	            delInstance(this.id);
	        }
	    };
	
	    module.exports = zrender;
	


/***/ },
/* 64 */
/***/ function(module, exports) {

	/**
	 * echarts设备环境识别
	 *
	 * @desc echarts基于Canvas，纯Javascript图表库，提供直观，生动，可交互，可个性化定制的数据统计图表。
	 * @author firede[firede@firede.us]
	 * @desc thanks zepto.
	 */
	
	    var env = {};
	    if (typeof navigator === 'undefined') {
	        // In node
	        env = {
	            browser: {},
	            os: {},
	            node: true,
	            // Assume canvas is supported
	            canvasSupported: true
	        };
	    }
	    else {
	        env = detect(navigator.userAgent);
	    }
	
	    module.exports = env;
	
	    // Zepto.js
	    // (c) 2010-2013 Thomas Fuchs
	    // Zepto.js may be freely distributed under the MIT license.
	
	    function detect(ua) {
	        var os = {};
	        var browser = {};
	        // var webkit = ua.match(/Web[kK]it[\/]{0,1}([\d.]+)/);
	        // var android = ua.match(/(Android);?[\s\/]+([\d.]+)?/);
	        // var ipad = ua.match(/(iPad).*OS\s([\d_]+)/);
	        // var ipod = ua.match(/(iPod)(.*OS\s([\d_]+))?/);
	        // var iphone = !ipad && ua.match(/(iPhone\sOS)\s([\d_]+)/);
	        // var webos = ua.match(/(webOS|hpwOS)[\s\/]([\d.]+)/);
	        // var touchpad = webos && ua.match(/TouchPad/);
	        // var kindle = ua.match(/Kindle\/([\d.]+)/);
	        // var silk = ua.match(/Silk\/([\d._]+)/);
	        // var blackberry = ua.match(/(BlackBerry).*Version\/([\d.]+)/);
	        // var bb10 = ua.match(/(BB10).*Version\/([\d.]+)/);
	        // var rimtabletos = ua.match(/(RIM\sTablet\sOS)\s([\d.]+)/);
	        // var playbook = ua.match(/PlayBook/);
	        // var chrome = ua.match(/Chrome\/([\d.]+)/) || ua.match(/CriOS\/([\d.]+)/);
	        var firefox = ua.match(/Firefox\/([\d.]+)/);
	        // var safari = webkit && ua.match(/Mobile\//) && !chrome;
	        // var webview = ua.match(/(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/) && !chrome;
	        var ie = ua.match(/MSIE\s([\d.]+)/)
	            // IE 11 Trident/7.0; rv:11.0
	            || ua.match(/Trident\/.+?rv:(([\d.]+))/);
	        var edge = ua.match(/Edge\/([\d.]+)/); // IE 12 and 12+
	
	        // Todo: clean this up with a better OS/browser seperation:
	        // - discern (more) between multiple browsers on android
	        // - decide if kindle fire in silk mode is android or not
	        // - Firefox on Android doesn't specify the Android version
	        // - possibly devide in os, device and browser hashes
	
	        // if (browser.webkit = !!webkit) browser.version = webkit[1];
	
	        // if (android) os.android = true, os.version = android[2];
	        // if (iphone && !ipod) os.ios = os.iphone = true, os.version = iphone[2].replace(/_/g, '.');
	        // if (ipad) os.ios = os.ipad = true, os.version = ipad[2].replace(/_/g, '.');
	        // if (ipod) os.ios = os.ipod = true, os.version = ipod[3] ? ipod[3].replace(/_/g, '.') : null;
	        // if (webos) os.webos = true, os.version = webos[2];
	        // if (touchpad) os.touchpad = true;
	        // if (blackberry) os.blackberry = true, os.version = blackberry[2];
	        // if (bb10) os.bb10 = true, os.version = bb10[2];
	        // if (rimtabletos) os.rimtabletos = true, os.version = rimtabletos[2];
	        // if (playbook) browser.playbook = true;
	        // if (kindle) os.kindle = true, os.version = kindle[1];
	        // if (silk) browser.silk = true, browser.version = silk[1];
	        // if (!silk && os.android && ua.match(/Kindle Fire/)) browser.silk = true;
	        // if (chrome) browser.chrome = true, browser.version = chrome[1];
	        if (firefox) browser.firefox = true, browser.version = firefox[1];
	        // if (safari && (ua.match(/Safari/) || !!os.ios)) browser.safari = true;
	        // if (webview) browser.webview = true;
	        if (ie) {
	            browser.ie = true; browser.version = ie[1];
	        }
	        if (ie) {
	            browser.ie = true;
	            browser.version = ie[1];
	        }
	        if (edge) {
	            browser.edge = true;
	            browser.version = edge[1];
	        }
	
	        // os.tablet = !!(ipad || playbook || (android && !ua.match(/Mobile/)) ||
	        //     (firefox && ua.match(/Tablet/)) || (ie && !ua.match(/Phone/) && ua.match(/Touch/)));
	        // os.phone  = !!(!os.tablet && !os.ipod && (android || iphone || webos ||
	        //     (chrome && ua.match(/Android/)) || (chrome && ua.match(/CriOS\/([\d.]+)/)) ||
	        //     (firefox && ua.match(/Mobile/)) || (ie && ua.match(/Touch/))));
	
	        return {
	            browser: browser,
	            os: os,
	            node: false,
	            // 原生canvas支持，改极端点了
	            // canvasSupported : !(browser.ie && parseFloat(browser.version) < 9)
	            canvasSupported : document.createElement('canvas').getContext ? true : false,
	            // @see <http://stackoverflow.com/questions/4817029/whats-the-best-way-to-detect-a-touch-screen-device-using-javascript>
	            // works on most browsers
	            // IE10/11 does not support touch event, and MS Edge supports them but not by
	            // default, so we dont check navigator.maxTouchPoints for them here.
	            touchEventsSupported: 'ontouchstart' in window && !browser.ie && !browser.edge,
	            // <http://caniuse.com/#search=pointer%20event>.
	            pointerEventsSupported: 'onpointerdown' in window
	                // Firefox supports pointer but not by default,
	                // only MS browsers are reliable on pointer events currently.
	                && (browser.edge || (browser.ie && browser.version >= 10))
	        };
	    }


/***/ },
/* 65 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	/**
	 * Handler
	 * @module zrender/Handler
	 * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)
	 *         errorrik (errorrik@gmail.com)
	 *         pissang (shenyi.914@gmail.com)
	 */
	
	
	    var util = __webpack_require__(4);
	    var Draggable = __webpack_require__(38);
	
	    var Eventful = __webpack_require__(11);
	
	    function makeEventPacket(eveType, target, event) {
	        return {
	            type: eveType,
	            event: event,
	            target: target,
	            cancelBubble: false,
	            offsetX: event.zrX,
	            offsetY: event.zrY,
	            gestureEvent: event.gestureEvent,
	            pinchX: event.pinchX,
	            pinchY: event.pinchY,
	            pinchScale: event.pinchScale,
	            wheelDelta: event.zrDelta
	        };
	    }
	
	    function EmptyProxy () {}
	    EmptyProxy.prototype.dispose = function () {};
	
	    var handlerNames = [
	        'click', 'dblclick', 'mousewheel', 'mouseout',
	        'mouseup', 'mousedown', 'mousemove'
	    ];
	    /**
	     * @alias module:zrender/Handler
	     * @constructor
	     * @extends module:zrender/mixin/Eventful
	     * @param {HTMLElement} root Main HTML element for painting.
	     * @param {module:zrender/Storage} storage Storage instance.
	     * @param {module:zrender/Painter} painter Painter instance.
	     */
	    var Handler = function(storage, painter, proxy) {
	        Eventful.call(this);
	
	        this.storage = storage;
	
	        this.painter = painter;
	
	        proxy = proxy || new EmptyProxy();
	        /**
	         * Proxy of event. can be Dom, WebGLSurface, etc.
	         */
	        this.proxy = proxy;
	
	        // Attach handler
	        proxy.handler = this;
	
	        /**
	         * @private
	         * @type {boolean}
	         */
	        this._hovered;
	
	        /**
	         * @private
	         * @type {Date}
	         */
	        this._lastTouchMoment;
	
	        /**
	         * @private
	         * @type {number}
	         */
	        this._lastX;
	
	        /**
	         * @private
	         * @type {number}
	         */
	        this._lastY;
	
	
	        Draggable.call(this);
	
	        util.each(handlerNames, function (name) {
	            proxy.on && proxy.on(name, this[name], this);
	        }, this);
	    };
	
	    Handler.prototype = {
	
	        constructor: Handler,
	
	        mousemove: function (event) {
	            var x = event.zrX;
	            var y = event.zrY;
	
	            var hovered = this.findHover(x, y, null);
	            var lastHovered = this._hovered;
	            var proxy = this.proxy;
	
	            this._hovered = hovered;
	
	            proxy.setCursor && proxy.setCursor(hovered ? hovered.cursor : 'default');
	
	            // Mouse out on previous hovered element
	            if (lastHovered && hovered !== lastHovered && lastHovered.__zr) {
	                this.dispatchToElement(lastHovered, 'mouseout', event);
	            }
	
	            // Mouse moving on one element
	            this.dispatchToElement(hovered, 'mousemove', event);
	
	            // Mouse over on a new element
	            if (hovered && hovered !== lastHovered) {
	                this.dispatchToElement(hovered, 'mouseover', event);
	            }
	        },
	
	        mouseout: function (event) {
	            this.dispatchToElement(this._hovered, 'mouseout', event);
	
	            this.trigger('globalout', {
	                event: event
	            });
	        },
	
	        /**
	         * Resize
	         */
	        resize: function (event) {
	            this._hovered = null;
	        },
	
	        /**
	         * Dispatch event
	         * @param {string} eventName
	         * @param {event=} eventArgs
	         */
	        dispatch: function (eventName, eventArgs) {
	            var handler = this[eventName];
	            handler && handler.call(this, eventArgs);
	        },
	
	        /**
	         * Dispose
	         */
	        dispose: function () {
	
	            this.proxy.dispose();
	
	            this.storage =
	            this.proxy =
	            this.painter = null;
	        },
	
	        /**
	         * 设置默认的cursor style
	         * @param {string} [cursorStyle='default'] 例如 crosshair
	         */
	        setCursorStyle: function (cursorStyle) {
	            var proxy = this.proxy;
	            proxy.setCursor && proxy.setCursor(cursorStyle);
	        },
	
	        /**
	         * 事件分发代理
	         *
	         * @private
	         * @param {Object} targetEl 目标图形元素
	         * @param {string} eventName 事件名称
	         * @param {Object} event 事件对象
	         */
	        dispatchToElement: function (targetEl, eventName, event) {
	            var eventHandler = 'on' + eventName;
	            var eventPacket = makeEventPacket(eventName, targetEl, event);
	
	            var el = targetEl;
	
	            while (el) {
	                el[eventHandler]
	                    && (eventPacket.cancelBubble = el[eventHandler].call(el, eventPacket));
	
	                el.trigger(eventName, eventPacket);
	
	                el = el.parent;
	
	                if (eventPacket.cancelBubble) {
	                    break;
	                }
	            }
	
	            if (!eventPacket.cancelBubble) {
	                // 冒泡到顶级 zrender 对象
	                this.trigger(eventName, eventPacket);
	                // 分发事件到用户自定义层
	                // 用户有可能在全局 click 事件中 dispose，所以需要判断下 painter 是否存在
	                this.painter && this.painter.eachOtherLayer(function (layer) {
	                    if (typeof(layer[eventHandler]) == 'function') {
	                        layer[eventHandler].call(layer, eventPacket);
	                    }
	                    if (layer.trigger) {
	                        layer.trigger(eventName, eventPacket);
	                    }
	                });
	            }
	        },
	
	        /**
	         * @private
	         * @param {number} x
	         * @param {number} y
	         * @param {module:zrender/graphic/Displayable} exclude
	         * @method
	         */
	        findHover: function(x, y, exclude) {
	            var list = this.storage.getDisplayList();
	            for (var i = list.length - 1; i >= 0 ; i--) {
	                if (!list[i].silent
	                 && list[i] !== exclude
	                 // getDisplayList may include ignored item in VML mode
	                 && !list[i].ignore
	                 && isHover(list[i], x, y)) {
	                    return list[i];
	                }
	            }
	        }
	    };
	
	    // Common handlers
	    util.each(['click', 'mousedown', 'mouseup', 'mousewheel', 'dblclick'], function (name) {
	        Handler.prototype[name] = function (event) {
	            // Find hover again to avoid click event is dispatched manually. Or click is triggered without mouseover
	            var hovered = this.findHover(event.zrX, event.zrY, null);
	
	            if (name === 'mousedown') {
	                this._downel = hovered;
	                // In case click triggered before mouseup
	                this._upel = hovered;
	            }
	            else if (name === 'mosueup') {
	                this._upel = hovered;
	            }
	            else if (name === 'click') {
	                if (this._downel !== this._upel) {
	                    return;
	                }
	            }
	
	            this.dispatchToElement(hovered, name, event);
	        };
	    });
	
	    function isHover(displayable, x, y) {
	        if (displayable[displayable.rectHover ? 'rectContain' : 'contain'](x, y)) {
	            var el = displayable;
	            while (el) {
	                // If ancestor is silent or clipped by ancestor
	                if (el.silent || (el.clipPath && !el.clipPath.contain(x, y)))  {
	                    return false;
	                }
	                el = el.parent;
	            }
	            return true;
	        }
	
	        return false;
	    }
	
	    util.mixin(Handler, Eventful);
	    util.mixin(Handler, Draggable);
	
	    module.exports = Handler;


/***/ },
/* 66 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	/**
	 * Storage内容仓库模块
	 * @module zrender/Storage
	 * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)
	 * @author errorrik (errorrik@gmail.com)
	 * @author pissang (https://github.com/pissang/)
	 */
	
	
	    var util = __webpack_require__(4);
	    var env = __webpack_require__(64);
	
	    var Group = __webpack_require__(39);
	
	    // Use timsort because in most case elements are partially sorted
	    // https://jsfiddle.net/pissang/jr4x7mdm/8/
	    var timsort = __webpack_require__(67);
	
	    function shapeCompareFunc(a, b) {
	        if (a.zlevel === b.zlevel) {
	            if (a.z === b.z) {
	                // if (a.z2 === b.z2) {
	                //     // FIXME Slow has renderidx compare
	                //     // http://stackoverflow.com/questions/20883421/sorting-in-javascript-should-every-compare-function-have-a-return-0-statement
	                //     // https://github.com/v8/v8/blob/47cce544a31ed5577ffe2963f67acb4144ee0232/src/js/array.js#L1012
	                //     return a.__renderidx - b.__renderidx;
	                // }
	                return a.z2 - b.z2;
	            }
	            return a.z - b.z;
	        }
	        return a.zlevel - b.zlevel;
	    }
	    /**
	     * 内容仓库 (M)
	     * @alias module:zrender/Storage
	     * @constructor
	     */
	    var Storage = function () {
	        // 所有常规形状，id索引的map
	        this._elements = {};
	
	        this._roots = [];
	
	        this._displayList = [];
	
	        this._displayListLen = 0;
	    };
	
	    Storage.prototype = {
	
	        constructor: Storage,
	
	        /**
	         * @param  {Function} cb
	         *
	         */
	        traverse: function (cb, context) {
	            for (var i = 0; i < this._roots.length; i++) {
	                this._roots[i].traverse(cb, context);
	            }
	        },
	
	        /**
	         * 返回所有图形的绘制队列
	         * @param {boolean} [update=false] 是否在返回前更新该数组
	         * @param {boolean} [includeIgnore=false] 是否包含 ignore 的数组, 在 update 为 true 的时候有效
	         *
	         * 详见{@link module:zrender/graphic/Displayable.prototype.updateDisplayList}
	         * @return {Array.<module:zrender/graphic/Displayable>}
	         */
	        getDisplayList: function (update, includeIgnore) {
	            includeIgnore = includeIgnore || false;
	            if (update) {
	                this.updateDisplayList(includeIgnore);
	            }
	            return this._displayList;
	        },
	
	        /**
	         * 更新图形的绘制队列。
	         * 每次绘制前都会调用，该方法会先深度优先遍历整个树，更新所有Group和Shape的变换并且把所有可见的Shape保存到数组中，
	         * 最后根据绘制的优先级（zlevel > z > 插入顺序）排序得到绘制队列
	         * @param {boolean} [includeIgnore=false] 是否包含 ignore 的数组
	         */
	        updateDisplayList: function (includeIgnore) {
	            this._displayListLen = 0;
	            var roots = this._roots;
	            var displayList = this._displayList;
	            for (var i = 0, len = roots.length; i < len; i++) {
	                this._updateAndAddDisplayable(roots[i], null, includeIgnore);
	            }
	            displayList.length = this._displayListLen;
	
	            // for (var i = 0, len = displayList.length; i < len; i++) {
	            //     displayList[i].__renderidx = i;
	            // }
	
	            // displayList.sort(shapeCompareFunc);
	            env.canvasSupported && timsort(displayList, shapeCompareFunc);
	        },
	
	        _updateAndAddDisplayable: function (el, clipPaths, includeIgnore) {
	
	            if (el.ignore && !includeIgnore) {
	                return;
	            }
	
	            el.beforeUpdate();
	
	            if (el.__dirty) {
	
	                el.update();
	
	            }
	
	            el.afterUpdate();
	
	            var clipPath = el.clipPath;
	            if (clipPath) {
	                // clipPath 的变换是基于 group 的变换
	                clipPath.parent = el;
	                clipPath.updateTransform();
	
	                // FIXME 效率影响
	                if (clipPaths) {
	                    clipPaths = clipPaths.slice();
	                    clipPaths.push(clipPath);
	                }
	                else {
	                    clipPaths = [clipPath];
	                }
	            }
	
	            if (el.isGroup) {
	                var children = el._children;
	
	                for (var i = 0; i < children.length; i++) {
	                    var child = children[i];
	
	                    // Force to mark as dirty if group is dirty
	                    // FIXME __dirtyPath ?
	                    if (el.__dirty) {
	                        child.__dirty = true;
	                    }
	
	                    this._updateAndAddDisplayable(child, clipPaths, includeIgnore);
	                }
	
	                // Mark group clean here
	                el.__dirty = false;
	
	            }
	            else {
	                el.__clipPaths = clipPaths;
	
	                this._displayList[this._displayListLen++] = el;
	            }
	        },
	
	        /**
	         * 添加图形(Shape)或者组(Group)到根节点
	         * @param {module:zrender/Element} el
	         */
	        addRoot: function (el) {
	            // Element has been added
	            if (this._elements[el.id]) {
	                return;
	            }
	
	            if (el instanceof Group) {
	                el.addChildrenToStorage(this);
	            }
	
	            this.addToMap(el);
	            this._roots.push(el);
	        },
	
	        /**
	         * 删除指定的图形(Shape)或者组(Group)
	         * @param {string|Array.<string>} [elId] 如果为空清空整个Storage
	         */
	        delRoot: function (elId) {
	            if (elId == null) {
	                // 不指定elId清空
	                for (var i = 0; i < this._roots.length; i++) {
	                    var root = this._roots[i];
	                    if (root instanceof Group) {
	                        root.delChildrenFromStorage(this);
	                    }
	                }
	
	                this._elements = {};
	                this._roots = [];
	                this._displayList = [];
	                this._displayListLen = 0;
	
	                return;
	            }
	
	            if (elId instanceof Array) {
	                for (var i = 0, l = elId.length; i < l; i++) {
	                    this.delRoot(elId[i]);
	                }
	                return;
	            }
	
	            var el;
	            if (typeof(elId) == 'string') {
	                el = this._elements[elId];
	            }
	            else {
	                el = elId;
	            }
	
	            var idx = util.indexOf(this._roots, el);
	            if (idx >= 0) {
	                this.delFromMap(el.id);
	                this._roots.splice(idx, 1);
	                if (el instanceof Group) {
	                    el.delChildrenFromStorage(this);
	                }
	            }
	        },
	
	        addToMap: function (el) {
	            if (el instanceof Group) {
	                el.__storage = this;
	            }
	            el.dirty(false);
	
	            this._elements[el.id] = el;
	
	            return this;
	        },
	
	        get: function (elId) {
	            return this._elements[elId];
	        },
	
	        delFromMap: function (elId) {
	            var elements = this._elements;
	            var el = elements[elId];
	            if (el) {
	                delete elements[elId];
	                if (el instanceof Group) {
	                    el.__storage = null;
	                }
	            }
	
	            return this;
	        },
	
	        /**
	         * 清空并且释放Storage
	         */
	        dispose: function () {
	            this._elements =
	            this._renderList =
	            this._roots = null;
	        },
	
	        displayableSortFunc: shapeCompareFunc
	    };
	
	    module.exports = Storage;
	


/***/ },
/* 67 */
/***/ function(module, exports) {

	// https://github.com/mziccard/node-timsort
	
	    var DEFAULT_MIN_MERGE = 32;
	
	    var DEFAULT_MIN_GALLOPING = 7;
	
	    var DEFAULT_TMP_STORAGE_LENGTH = 256;
	
	    function minRunLength(n) {
	        var r = 0;
	
	        while (n >= DEFAULT_MIN_MERGE) {
	            r |= n & 1;
	            n >>= 1;
	        }
	
	        return n + r;
	    }
	
	    function makeAscendingRun(array, lo, hi, compare) {
	        var runHi = lo + 1;
	
	        if (runHi === hi) {
	            return 1;
	        }
	
	        if (compare(array[runHi++], array[lo]) < 0) {
	            while (runHi < hi && compare(array[runHi], array[runHi - 1]) < 0) {
	                runHi++;
	            }
	
	            reverseRun(array, lo, runHi);
	        }
	        else {
	            while (runHi < hi && compare(array[runHi], array[runHi - 1]) >= 0) {
	                runHi++;
	            }
	        }
	
	        return runHi - lo;
	    }
	
	    function reverseRun(array, lo, hi) {
	        hi--;
	
	        while (lo < hi) {
	            var t = array[lo];
	            array[lo++] = array[hi];
	            array[hi--] = t;
	        }
	    }
	
	    function binaryInsertionSort(array, lo, hi, start, compare) {
	        if (start === lo) {
	            start++;
	        }
	
	        for (; start < hi; start++) {
	            var pivot = array[start];
	
	            var left = lo;
	            var right = start;
	            var mid;
	
	            while (left < right) {
	                mid = left + right >>> 1;
	
	                if (compare(pivot, array[mid]) < 0) {
	                    right = mid;
	                }
	                else {
	                    left = mid + 1;
	                }
	            }
	
	            var n = start - left;
	
	            switch (n) {
	                case 3:
	                    array[left + 3] = array[left + 2];
	
	                case 2:
	                    array[left + 2] = array[left + 1];
	
	                case 1:
	                    array[left + 1] = array[left];
	                    break;
	                default:
	                    while (n > 0) {
	                        array[left + n] = array[left + n - 1];
	                        n--;
	                    }
	            }
	
	            array[left] = pivot;
	        }
	    }
	
	    function gallopLeft(value, array, start, length, hint, compare) {
	        var lastOffset = 0;
	        var maxOffset = 0;
	        var offset = 1;
	
	        if (compare(value, array[start + hint]) > 0) {
	            maxOffset = length - hint;
	
	            while (offset < maxOffset && compare(value, array[start + hint + offset]) > 0) {
	                lastOffset = offset;
	                offset = (offset << 1) + 1;
	
	                if (offset <= 0) {
	                    offset = maxOffset;
	                }
	            }
	
	            if (offset > maxOffset) {
	                offset = maxOffset;
	            }
	
	            lastOffset += hint;
	            offset += hint;
	        }
	        else {
	            maxOffset = hint + 1;
	            while (offset < maxOffset && compare(value, array[start + hint - offset]) <= 0) {
	                lastOffset = offset;
	                offset = (offset << 1) + 1;
	
	                if (offset <= 0) {
	                    offset = maxOffset;
	                }
	            }
	            if (offset > maxOffset) {
	                offset = maxOffset;
	            }
	
	            var tmp = lastOffset;
	            lastOffset = hint - offset;
	            offset = hint - tmp;
	        }
	
	        lastOffset++;
	        while (lastOffset < offset) {
	            var m = lastOffset + (offset - lastOffset >>> 1);
	
	            if (compare(value, array[start + m]) > 0) {
	                lastOffset = m + 1;
	            }
	            else {
	                offset = m;
	            }
	        }
	        return offset;
	    }
	
	    function gallopRight(value, array, start, length, hint, compare) {
	        var lastOffset = 0;
	        var maxOffset = 0;
	        var offset = 1;
	
	        if (compare(value, array[start + hint]) < 0) {
	            maxOffset = hint + 1;
	
	            while (offset < maxOffset && compare(value, array[start + hint - offset]) < 0) {
	                lastOffset = offset;
	                offset = (offset << 1) + 1;
	
	                if (offset <= 0) {
	                    offset = maxOffset;
	                }
	            }
	
	            if (offset > maxOffset) {
	                offset = maxOffset;
	            }
	
	            var tmp = lastOffset;
	            lastOffset = hint - offset;
	            offset = hint - tmp;
	        }
	        else {
	            maxOffset = length - hint;
	
	            while (offset < maxOffset && compare(value, array[start + hint + offset]) >= 0) {
	                lastOffset = offset;
	                offset = (offset << 1) + 1;
	
	                if (offset <= 0) {
	                    offset = maxOffset;
	                }
	            }
	
	            if (offset > maxOffset) {
	                offset = maxOffset;
	            }
	
	            lastOffset += hint;
	            offset += hint;
	        }
	
	        lastOffset++;
	
	        while (lastOffset < offset) {
	            var m = lastOffset + (offset - lastOffset >>> 1);
	
	            if (compare(value, array[start + m]) < 0) {
	                offset = m;
	            }
	            else {
	                lastOffset = m + 1;
	            }
	        }
	
	        return offset;
	    }
	
	    function TimSort(array, compare) {
	        var minGallop = DEFAULT_MIN_GALLOPING;
	        var length = 0;
	        var tmpStorageLength = DEFAULT_TMP_STORAGE_LENGTH;
	        var stackLength = 0;
	        var runStart;
	        var runLength;
	        var stackSize = 0;
	
	        length = array.length;
	
	        if (length < 2 * DEFAULT_TMP_STORAGE_LENGTH) {
	            tmpStorageLength = length >>> 1;
	        }
	
	        var tmp = [];
	
	        stackLength = length < 120 ? 5 : length < 1542 ? 10 : length < 119151 ? 19 : 40;
	
	        runStart = [];
	        runLength = [];
	
	        function pushRun(_runStart, _runLength) {
	            runStart[stackSize] = _runStart;
	            runLength[stackSize] = _runLength;
	            stackSize += 1;
	        }
	
	        function mergeRuns() {
	            while (stackSize > 1) {
	                var n = stackSize - 2;
	
	                if (n >= 1 && runLength[n - 1] <= runLength[n] + runLength[n + 1] || n >= 2 && runLength[n - 2] <= runLength[n] + runLength[n - 1]) {
	                    if (runLength[n - 1] < runLength[n + 1]) {
	                        n--;
	                    }
	                }
	                else if (runLength[n] > runLength[n + 1]) {
	                    break;
	                }
	                mergeAt(n);
	            }
	        }
	
	        function forceMergeRuns() {
	            while (stackSize > 1) {
	                var n = stackSize - 2;
	
	                if (n > 0 && runLength[n - 1] < runLength[n + 1]) {
	                    n--;
	                }
	
	                mergeAt(n);
	            }
	        }
	
	        function mergeAt(i) {
	            var start1 = runStart[i];
	            var length1 = runLength[i];
	            var start2 = runStart[i + 1];
	            var length2 = runLength[i + 1];
	
	            runLength[i] = length1 + length2;
	
	            if (i === stackSize - 3) {
	                runStart[i + 1] = runStart[i + 2];
	                runLength[i + 1] = runLength[i + 2];
	            }
	
	            stackSize--;
	
	            var k = gallopRight(array[start2], array, start1, length1, 0, compare);
	            start1 += k;
	            length1 -= k;
	
	            if (length1 === 0) {
	                return;
	            }
	
	            length2 = gallopLeft(array[start1 + length1 - 1], array, start2, length2, length2 - 1, compare);
	
	            if (length2 === 0) {
	                return;
	            }
	
	            if (length1 <= length2) {
	                mergeLow(start1, length1, start2, length2);
	            }
	            else {
	                mergeHigh(start1, length1, start2, length2);
	            }
	        }
	
	        function mergeLow(start1, length1, start2, length2) {
	            var i = 0;
	
	            for (i = 0; i < length1; i++) {
	                tmp[i] = array[start1 + i];
	            }
	
	            var cursor1 = 0;
	            var cursor2 = start2;
	            var dest = start1;
	
	            array[dest++] = array[cursor2++];
	
	            if (--length2 === 0) {
	                for (i = 0; i < length1; i++) {
	                    array[dest + i] = tmp[cursor1 + i];
	                }
	                return;
	            }
	
	            if (length1 === 1) {
	                for (i = 0; i < length2; i++) {
	                    array[dest + i] = array[cursor2 + i];
	                }
	                array[dest + length2] = tmp[cursor1];
	                return;
	            }
	
	            var _minGallop = minGallop;
	            var count1, count2, exit;
	
	            while (1) {
	                count1 = 0;
	                count2 = 0;
	                exit = false;
	
	                do {
	                    if (compare(array[cursor2], tmp[cursor1]) < 0) {
	                        array[dest++] = array[cursor2++];
	                        count2++;
	                        count1 = 0;
	
	                        if (--length2 === 0) {
	                            exit = true;
	                            break;
	                        }
	                    }
	                    else {
	                        array[dest++] = tmp[cursor1++];
	                        count1++;
	                        count2 = 0;
	                        if (--length1 === 1) {
	                            exit = true;
	                            break;
	                        }
	                    }
	                } while ((count1 | count2) < _minGallop);
	
	                if (exit) {
	                    break;
	                }
	
	                do {
	                    count1 = gallopRight(array[cursor2], tmp, cursor1, length1, 0, compare);
	
	                    if (count1 !== 0) {
	                        for (i = 0; i < count1; i++) {
	                            array[dest + i] = tmp[cursor1 + i];
	                        }
	
	                        dest += count1;
	                        cursor1 += count1;
	                        length1 -= count1;
	                        if (length1 <= 1) {
	                            exit = true;
	                            break;
	                        }
	                    }
	
	                    array[dest++] = array[cursor2++];
	
	                    if (--length2 === 0) {
	                        exit = true;
	                        break;
	                    }
	
	                    count2 = gallopLeft(tmp[cursor1], array, cursor2, length2, 0, compare);
	
	                    if (count2 !== 0) {
	                        for (i = 0; i < count2; i++) {
	                            array[dest + i] = array[cursor2 + i];
	                        }
	
	                        dest += count2;
	                        cursor2 += count2;
	                        length2 -= count2;
	
	                        if (length2 === 0) {
	                            exit = true;
	                            break;
	                        }
	                    }
	                    array[dest++] = tmp[cursor1++];
	
	                    if (--length1 === 1) {
	                        exit = true;
	                        break;
	                    }
	
	                    _minGallop--;
	                } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);
	
	                if (exit) {
	                    break;
	                }
	
	                if (_minGallop < 0) {
	                    _minGallop = 0;
	                }
	
	                _minGallop += 2;
	            }
	
	            minGallop = _minGallop;
	
	            minGallop < 1 && (minGallop = 1);
	
	            if (length1 === 1) {
	                for (i = 0; i < length2; i++) {
	                    array[dest + i] = array[cursor2 + i];
	                }
	                array[dest + length2] = tmp[cursor1];
	            }
	            else if (length1 === 0) {
	                throw new Error();
	                // throw new Error('mergeLow preconditions were not respected');
	            }
	            else {
	                for (i = 0; i < length1; i++) {
	                    array[dest + i] = tmp[cursor1 + i];
	                }
	            }
	        }
	
	        function mergeHigh (start1, length1, start2, length2) {
	            var i = 0;
	
	            for (i = 0; i < length2; i++) {
	                tmp[i] = array[start2 + i];
	            }
	
	            var cursor1 = start1 + length1 - 1;
	            var cursor2 = length2 - 1;
	            var dest = start2 + length2 - 1;
	            var customCursor = 0;
	            var customDest = 0;
	
	            array[dest--] = array[cursor1--];
	
	            if (--length1 === 0) {
	                customCursor = dest - (length2 - 1);
	
	                for (i = 0; i < length2; i++) {
	                    array[customCursor + i] = tmp[i];
	                }
	
	                return;
	            }
	
	            if (length2 === 1) {
	                dest -= length1;
	                cursor1 -= length1;
	                customDest = dest + 1;
	                customCursor = cursor1 + 1;
	
	                for (i = length1 - 1; i >= 0; i--) {
	                    array[customDest + i] = array[customCursor + i];
	                }
	
	                array[dest] = tmp[cursor2];
	                return;
	            }
	
	            var _minGallop = minGallop;
	
	            while (true) {
	                var count1 = 0;
	                var count2 = 0;
	                var exit = false;
	
	                do {
	                    if (compare(tmp[cursor2], array[cursor1]) < 0) {
	                        array[dest--] = array[cursor1--];
	                        count1++;
	                        count2 = 0;
	                        if (--length1 === 0) {
	                            exit = true;
	                            break;
	                        }
	                    }
	                    else {
	                        array[dest--] = tmp[cursor2--];
	                        count2++;
	                        count1 = 0;
	                        if (--length2 === 1) {
	                            exit = true;
	                            break;
	                        }
	                    }
	                } while ((count1 | count2) < _minGallop);
	
	                if (exit) {
	                    break;
	                }
	
	                do {
	                    count1 = length1 - gallopRight(tmp[cursor2], array, start1, length1, length1 - 1, compare);
	
	                    if (count1 !== 0) {
	                        dest -= count1;
	                        cursor1 -= count1;
	                        length1 -= count1;
	                        customDest = dest + 1;
	                        customCursor = cursor1 + 1;
	
	                        for (i = count1 - 1; i >= 0; i--) {
	                            array[customDest + i] = array[customCursor + i];
	                        }
	
	                        if (length1 === 0) {
	                            exit = true;
	                            break;
	                        }
	                    }
	
	                    array[dest--] = tmp[cursor2--];
	
	                    if (--length2 === 1) {
	                        exit = true;
	                        break;
	                    }
	
	                    count2 = length2 - gallopLeft(array[cursor1], tmp, 0, length2, length2 - 1, compare);
	
	                    if (count2 !== 0) {
	                        dest -= count2;
	                        cursor2 -= count2;
	                        length2 -= count2;
	                        customDest = dest + 1;
	                        customCursor = cursor2 + 1;
	
	                        for (i = 0; i < count2; i++) {
	                            array[customDest + i] = tmp[customCursor + i];
	                        }
	
	                        if (length2 <= 1) {
	                            exit = true;
	                            break;
	                        }
	                    }
	
	                    array[dest--] = array[cursor1--];
	
	                    if (--length1 === 0) {
	                        exit = true;
	                        break;
	                    }
	
	                    _minGallop--;
	                } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);
	
	                if (exit) {
	                    break;
	                }
	
	                if (_minGallop < 0) {
	                    _minGallop = 0;
	                }
	
	                _minGallop += 2;
	            }
	
	            minGallop = _minGallop;
	
	            if (minGallop < 1) {
	                minGallop = 1;
	            }
	
	            if (length2 === 1) {
	                dest -= length1;
	                cursor1 -= length1;
	                customDest = dest + 1;
	                customCursor = cursor1 + 1;
	
	                for (i = length1 - 1; i >= 0; i--) {
	                    array[customDest + i] = array[customCursor + i];
	                }
	
	                array[dest] = tmp[cursor2];
	            }
	            else if (length2 === 0) {
	                throw new Error();
	                // throw new Error('mergeHigh preconditions were not respected');
	            }
	            else {
	                customCursor = dest - (length2 - 1);
	                for (i = 0; i < length2; i++) {
	                    array[customCursor + i] = tmp[i];
	                }
	            }
	        }
	
	        this.mergeRuns = mergeRuns;
	        this.forceMergeRuns = forceMergeRuns;
	        this.pushRun = pushRun;
	    }
	
	    function sort(array, compare, lo, hi) {
	        if (!lo) {
	            lo = 0;
	        }
	        if (!hi) {
	            hi = array.length;
	        }
	
	        var remaining = hi - lo;
	
	        if (remaining < 2) {
	            return;
	        }
	
	        var runLength = 0;
	
	        if (remaining < DEFAULT_MIN_MERGE) {
	            runLength = makeAscendingRun(array, lo, hi, compare);
	            binaryInsertionSort(array, lo, hi, lo + runLength, compare);
	            return;
	        }
	
	        var ts = new TimSort(array, compare);
	
	        var minRun = minRunLength(remaining);
	
	        do {
	            runLength = makeAscendingRun(array, lo, hi, compare);
	            if (runLength < minRun) {
	                var force = remaining;
	                if (force > minRun) {
	                    force = minRun;
	                }
	
	                binaryInsertionSort(array, lo, lo + force, lo + runLength, compare);
	                runLength = force;
	            }
	
	            ts.pushRun(lo, runLength);
	            ts.mergeRuns();
	
	            remaining -= runLength;
	            lo += runLength;
	        } while (remaining !== 0);
	
	        ts.forceMergeRuns();
	    }
	
	    module.exports = sort;


/***/ },
/* 68 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	/**
	 * 动画主类, 调度和管理所有动画控制器
	 *
	 * @module zrender/animation/Animation
	 * @author pissang(https://github.com/pissang)
	 */
	// TODO Additive animation
	// http://iosoteric.com/additive-animations-animatewithduration-in-ios-8/
	// https://developer.apple.com/videos/wwdc2014/#236
	
	
	    var util = __webpack_require__(4);
	    var Dispatcher = __webpack_require__(69).Dispatcher;
	
	    var requestAnimationFrame = __webpack_require__(70);
	
	    var Animator = __webpack_require__(16);
	    /**
	     * @typedef {Object} IZRenderStage
	     * @property {Function} update
	     */
	
	    /**
	     * @alias module:zrender/animation/Animation
	     * @constructor
	     * @param {Object} [options]
	     * @param {Function} [options.onframe]
	     * @param {IZRenderStage} [options.stage]
	     * @example
	     *     var animation = new Animation();
	     *     var obj = {
	     *         x: 100,
	     *         y: 100
	     *     };
	     *     animation.animate(node.position)
	     *         .when(1000, {
	     *             x: 500,
	     *             y: 500
	     *         })
	     *         .when(2000, {
	     *             x: 100,
	     *             y: 100
	     *         })
	     *         .start('spline');
	     */
	    var Animation = function (options) {
	
	        options = options || {};
	
	        this.stage = options.stage || {};
	
	        this.onframe = options.onframe || function() {};
	
	        // private properties
	        this._clips = [];
	
	        this._running = false;
	
	        this._time;
	
	        this._pausedTime;
	
	        this._pauseStart;
	
	        this._paused = false;
	
	        Dispatcher.call(this);
	    };
	
	    Animation.prototype = {
	
	        constructor: Animation,
	        /**
	         * 添加 clip
	         * @param {module:zrender/animation/Clip} clip
	         */
	        addClip: function (clip) {
	            this._clips.push(clip);
	        },
	        /**
	         * 添加 animator
	         * @param {module:zrender/animation/Animator} animator
	         */
	        addAnimator: function (animator) {
	            animator.animation = this;
	            var clips = animator.getClips();
	            for (var i = 0; i < clips.length; i++) {
	                this.addClip(clips[i]);
	            }
	        },
	        /**
	         * 删除动画片段
	         * @param {module:zrender/animation/Clip} clip
	         */
	        removeClip: function(clip) {
	            var idx = util.indexOf(this._clips, clip);
	            if (idx >= 0) {
	                this._clips.splice(idx, 1);
	            }
	        },
	
	        /**
	         * 删除动画片段
	         * @param {module:zrender/animation/Animator} animator
	         */
	        removeAnimator: function (animator) {
	            var clips = animator.getClips();
	            for (var i = 0; i < clips.length; i++) {
	                this.removeClip(clips[i]);
	            }
	            animator.animation = null;
	        },
	
	        _update: function() {
	
	            var time = new Date().getTime() - this._pausedTime;
	            var delta = time - this._time;
	            var clips = this._clips;
	            var len = clips.length;
	
	            var deferredEvents = [];
	            var deferredClips = [];
	            for (var i = 0; i < len; i++) {
	                var clip = clips[i];
	                var e = clip.step(time);
	                // Throw out the events need to be called after
	                // stage.update, like destroy
	                if (e) {
	                    deferredEvents.push(e);
	                    deferredClips.push(clip);
	                }
	            }
	
	            // Remove the finished clip
	            for (var i = 0; i < len;) {
	                if (clips[i]._needsRemove) {
	                    clips[i] = clips[len - 1];
	                    clips.pop();
	                    len--;
	                }
	                else {
	                    i++;
	                }
	            }
	
	            len = deferredEvents.length;
	            for (var i = 0; i < len; i++) {
	                deferredClips[i].fire(deferredEvents[i]);
	            }
	
	            this._time = time;
	
	            this.onframe(delta);
	
	            this.trigger('frame', delta);
	
	            if (this.stage.update) {
	                this.stage.update();
	            }
	        },
	
	        _startLoop: function () {
	            var self = this;
	
	            this._running = true;
	
	            function step() {
	                if (self._running) {
	
	                    requestAnimationFrame(step);
	
	                    !self._paused && self._update();
	                }
	            }
	
	            requestAnimationFrame(step);
	        },
	
	        /**
	         * 开始运行动画
	         */
	        start: function () {
	
	            this._time = new Date().getTime();
	            this._pausedTime = 0;
	
	            this._startLoop();
	        },
	        /**
	         * 停止运行动画
	         */
	        stop: function () {
	            this._running = false;
	        },
	
	        /**
	         * Pause
	         */
	        pause: function () {
	            if (!this._paused) {
	                this._pauseStart = new Date().getTime();
	                this._paused = true;
	            }
	        },
	
	        /**
	         * Resume
	         */
	        resume: function () {
	            if (this._paused) {
	                this._pausedTime += (new Date().getTime()) - this._pauseStart;
	                this._paused = false;
	            }
	        },
	
	        /**
	         * 清除所有动画片段
	         */
	        clear: function () {
	            this._clips = [];
	        },
	        /**
	         * 对一个目标创建一个animator对象，可以指定目标中的属性使用动画
	         * @param  {Object} target
	         * @param  {Object} options
	         * @param  {boolean} [options.loop=false] 是否循环播放动画
	         * @param  {Function} [options.getter=null]
	         *         如果指定getter函数，会通过getter函数取属性值
	         * @param  {Function} [options.setter=null]
	         *         如果指定setter函数，会通过setter函数设置属性值
	         * @return {module:zrender/animation/Animation~Animator}
	         */
	        // TODO Gap
	        animate: function (target, options) {
	            options = options || {};
	            var animator = new Animator(
	                target,
	                options.loop,
	                options.getter,
	                options.setter
	            );
	
	            return animator;
	        }
	    };
	
	    util.mixin(Animation, Dispatcher);
	
	    module.exports = Animation;
	


/***/ },
/* 69 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	/**
	 * 事件辅助类
	 * @module zrender/core/event
	 * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)
	 */
	
	
	    var Eventful = __webpack_require__(11);
	
	    var isDomLevel2 = (typeof window !== 'undefined') && !!window.addEventListener;
	
	    function getBoundingClientRect(el) {
	        // BlackBerry 5, iOS 3 (original iPhone) don't have getBoundingRect
	        return el.getBoundingClientRect ? el.getBoundingClientRect() : {left: 0, top: 0};
	    }
	
	    function clientToLocal(el, e, out) {
	        // clientX/clientY is according to view port.
	        var box = getBoundingClientRect(el);
	        out = out || {};
	        out.zrX = e.clientX - box.left;
	        out.zrY = e.clientY - box.top;
	        return out;
	    }
	
	    /**
	     * 如果存在第三方嵌入的一些dom触发的事件，或touch事件，需要转换一下事件坐标
	     */
	    function normalizeEvent(el, e) {
	
	        e = e || window.event;
	
	        if (e.zrX != null) {
	            return e;
	        }
	
	        var eventType = e.type;
	        var isTouch = eventType && eventType.indexOf('touch') >= 0;
	
	        if (!isTouch) {
	            clientToLocal(el, e, e);
	            e.zrDelta = (e.wheelDelta) ? e.wheelDelta / 120 : -(e.detail || 0) / 3;
	        }
	        else {
	            var touch = eventType != 'touchend'
	                ? e.targetTouches[0]
	                : e.changedTouches[0];
	            touch && clientToLocal(el, touch, e);
	        }
	
	        return e;
	    }
	
	    function addEventListener(el, name, handler) {
	        if (isDomLevel2) {
	            el.addEventListener(name, handler);
	        }
	        else {
	            el.attachEvent('on' + name, handler);
	        }
	    }
	
	    function removeEventListener(el, name, handler) {
	        if (isDomLevel2) {
	            el.removeEventListener(name, handler);
	        }
	        else {
	            el.detachEvent('on' + name, handler);
	        }
	    }
	
	    /**
	     * 停止冒泡和阻止默认行为
	     * @memberOf module:zrender/core/event
	     * @method
	     * @param {Event} e : event对象
	     */
	    var stop = isDomLevel2
	        ? function (e) {
	            e.preventDefault();
	            e.stopPropagation();
	            e.cancelBubble = true;
	        }
	        : function (e) {
	            e.returnValue = false;
	            e.cancelBubble = true;
	        };
	
	    module.exports = {
	        clientToLocal: clientToLocal,
	        normalizeEvent: normalizeEvent,
	        addEventListener: addEventListener,
	        removeEventListener: removeEventListener,
	
	        stop: stop,
	        // 做向上兼容
	        Dispatcher: Eventful
	    };
	


/***/ },
/* 70 */
/***/ function(module, exports) {

	
	
	    module.exports = (typeof window !== 'undefined' &&
	                                    (window.requestAnimationFrame
	                                    || window.msRequestAnimationFrame
	                                    || window.mozRequestAnimationFrame
	                                    || window.webkitRequestAnimationFrame))
	                                || function (func) {
	                                    setTimeout(func, 16);
	                                };
	


/***/ },
/* 71 */
/***/ function(module, exports, __webpack_require__) {

	
	
	    var eventTool = __webpack_require__(69);
	    var zrUtil = __webpack_require__(4);
	    var Eventful = __webpack_require__(11);
	    var env = __webpack_require__(64);
	    var GestureMgr = __webpack_require__(72);
	
	    var addEventListener = eventTool.addEventListener;
	    var removeEventListener = eventTool.removeEventListener;
	    var normalizeEvent = eventTool.normalizeEvent;
	
	    var TOUCH_CLICK_DELAY = 300;
	
	    var mouseHandlerNames = [
	        'click', 'dblclick', 'mousewheel', 'mouseout',
	        'mouseup', 'mousedown', 'mousemove'
	    ];
	
	    var touchHandlerNames = [
	        'touchstart', 'touchend', 'touchmove'
	    ];
	
	    function eventNameFix(name) {
	        return (name === 'mousewheel' && env.browser.firefox) ? 'DOMMouseScroll' : name;
	    }
	
	    function processGesture(proxy, event, stage) {
	        var gestureMgr = proxy._gestureMgr;
	
	        stage === 'start' && gestureMgr.clear();
	
	        var gestureInfo = gestureMgr.recognize(
	            event,
	            proxy.handler.findHover(event.zrX, event.zrY, null),
	            proxy.dom
	        );
	
	        stage === 'end' && gestureMgr.clear();
	
	        if (gestureInfo) {
	            // eventTool.stop(event);
	            var type = gestureInfo.type;
	            event.gestureEvent = type;
	
	            proxy.handler.dispatchToElement(gestureInfo.target, type, gestureInfo.event);
	        }
	    }
	
	    /**
	     * Prevent mouse event from being dispatched after Touch Events action
	     * @see <https://github.com/deltakosh/handjs/blob/master/src/hand.base.js>
	     * 1. Mobile browsers dispatch mouse events 300ms after touchend.
	     * 2. Chrome for Android dispatch mousedown for long-touch about 650ms
	     * Result: Blocking Mouse Events for 700ms.
	     */
	    function setTouchTimer(instance) {
	        instance._touching = true;
	        clearTimeout(instance._touchTimer);
	        instance._touchTimer = setTimeout(function () {
	            instance._touching = false;
	        }, 700);
	    }
	
	    function useTouchEvent() {
	        return env.touchEventsSupported;
	    }
	
	    var domHandlers = {
	        /**
	         * Mouse move handler
	         * @inner
	         * @param {Event} event
	         */
	        mousemove: function (event) {
	            event = normalizeEvent(this.dom, event);
	
	            this.trigger('mousemove', event);
	        },
	
	        /**
	         * Mouse out handler
	         * @inner
	         * @param {Event} event
	         */
	        mouseout: function (event) {
	            event = normalizeEvent(this.dom, event);
	
	            var element = event.toElement || event.relatedTarget;
	            if (element != this.dom) {
	                while (element && element.nodeType != 9) {
	                    // 忽略包含在root中的dom引起的mouseOut
	                    if (element === this.dom) {
	                        return;
	                    }
	
	                    element = element.parentNode;
	                }
	            }
	
	            this.trigger('mouseout', event);
	        },
	
	        /**
	         * Touch开始响应函数
	         * @inner
	         * @param {Event} event
	         */
	        touchstart: function (event) {
	            // Default mouse behaviour should not be disabled here.
	            // For example, page may needs to be slided.
	
	            event = normalizeEvent(this.dom, event);
	
	            this._lastTouchMoment = new Date();
	
	            processGesture(this, event, 'start');
	
	            // 平板补充一次findHover
	            // this._mobileFindFixed(event);
	            // Trigger mousemove and mousedown
	            domHandlers.mousemove.call(this, event);
	
	            domHandlers.mousedown.call(this, event);
	
	            setTouchTimer(this);
	        },
	
	        /**
	         * Touch移动响应函数
	         * @inner
	         * @param {Event} event
	         */
	        touchmove: function (event) {
	
	            event = normalizeEvent(this.dom, event);
	
	            processGesture(this, event, 'change');
	
	            // Mouse move should always be triggered no matter whether
	            // there is gestrue event, because mouse move and pinch may
	            // be used at the same time.
	            domHandlers.mousemove.call(this, event);
	
	            setTouchTimer(this);
	        },
	
	        /**
	         * Touch结束响应函数
	         * @inner
	         * @param {Event} event
	         */
	        touchend: function (event) {
	
	            event = normalizeEvent(this.dom, event);
	
	            processGesture(this, event, 'end');
	
	            domHandlers.mouseup.call(this, event);
	
	            // click event should always be triggered no matter whether
	            // there is gestrue event. System click can not be prevented.
	            if (+new Date() - this._lastTouchMoment < TOUCH_CLICK_DELAY) {
	                domHandlers.click.call(this, event);
	            }
	
	            setTouchTimer(this);
	        }
	    };
	
	    // Common handlers
	    zrUtil.each(['click', 'mousedown', 'mouseup', 'mousewheel', 'dblclick'], function (name) {
	        domHandlers[name] = function (event) {
	            event = normalizeEvent(this.dom, event);
	            this.trigger(name, event);
	        };
	    });
	
	    /**
	     * 为控制类实例初始化dom 事件处理函数
	     *
	     * @inner
	     * @param {module:zrender/Handler} instance 控制类实例
	     */
	    function initDomHandler(instance) {
	        for (var i = 0; i < touchHandlerNames.length; i++) {
	            var name = touchHandlerNames[i];
	            instance._handlers[name] = zrUtil.bind(domHandlers[name], instance);
	        }
	
	        for (var i = 0; i < mouseHandlerNames.length; i++) {
	            var name = mouseHandlerNames[i];
	            instance._handlers[name] = makeMouseHandler(domHandlers[name], instance);
	        }
	
	        function makeMouseHandler(fn, instance) {
	            return function () {
	                if (instance._touching) {
	                    return;
	                }
	                return fn.apply(instance, arguments);
	            };
	        }
	    }
	
	
	    function HandlerDomProxy(dom) {
	        Eventful.call(this);
	
	        this.dom = dom;
	
	        /**
	         * @private
	         * @type {boolean}
	         */
	        this._touching = false;
	
	        /**
	         * @private
	         * @type {number}
	         */
	        this._touchTimer;
	
	        /**
	         * @private
	         * @type {module:zrender/core/GestureMgr}
	         */
	        this._gestureMgr = new GestureMgr();
	
	        this._handlers = {};
	
	        initDomHandler(this);
	
	        if (useTouchEvent()) {
	            mountHandlers(touchHandlerNames, this);
	
	            // Handler of 'mouseout' event is needed in touch mode, which will be mounted below.
	            // addEventListener(root, 'mouseout', this._mouseoutHandler);
	        }
	
	        // Considering some devices that both enable touch and mouse event (like MS Surface
	        // and lenovo X240, @see #2350), we make mouse event be always listened, otherwise
	        // mouse event can not be handle in those devices.
	        mountHandlers(mouseHandlerNames, this);
	
	        function mountHandlers(handlerNames, instance) {
	            zrUtil.each(handlerNames, function (name) {
	                addEventListener(dom, eventNameFix(name), instance._handlers[name]);
	            }, instance);
	        }
	    }
	
	    var handlerDomProxyProto = HandlerDomProxy.prototype;
	    handlerDomProxyProto.dispose = function () {
	        var handlerNames = mouseHandlerNames.concat(touchHandlerNames);
	
	        for (var i = 0; i < handlerNames.length; i++) {
	            var name = handlerNames[i];
	            removeEventListener(this.dom, eventNameFix(name), this._handlers[name]);
	        }
	    };
	
	    handlerDomProxyProto.setCursor = function (cursorStyle) {
	        this.dom.style.cursor = cursorStyle || 'default';
	    };
	
	    zrUtil.mixin(HandlerDomProxy, Eventful);
	
	    module.exports = HandlerDomProxy;


/***/ },
/* 72 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	/**
	 * Only implements needed gestures for mobile.
	 */
	
	
	    var eventUtil = __webpack_require__(69);
	
	    var GestureMgr = function () {
	
	        /**
	         * @private
	         * @type {Array.<Object>}
	         */
	        this._track = [];
	    };
	
	    GestureMgr.prototype = {
	
	        constructor: GestureMgr,
	
	        recognize: function (event, target, root) {
	            this._doTrack(event, target, root);
	            return this._recognize(event);
	        },
	
	        clear: function () {
	            this._track.length = 0;
	            return this;
	        },
	
	        _doTrack: function (event, target, root) {
	            var touches = event.touches;
	
	            if (!touches) {
	                return;
	            }
	
	            var trackItem = {
	                points: [],
	                touches: [],
	                target: target,
	                event: event
	            };
	
	            for (var i = 0, len = touches.length; i < len; i++) {
	                var touch = touches[i];
	                var pos = eventUtil.clientToLocal(root, touch);
	                trackItem.points.push([pos.zrX, pos.zrY]);
	                trackItem.touches.push(touch);
	            }
	
	            this._track.push(trackItem);
	        },
	
	        _recognize: function (event) {
	            for (var eventName in recognizers) {
	                if (recognizers.hasOwnProperty(eventName)) {
	                    var gestureInfo = recognizers[eventName](this._track, event);
	                    if (gestureInfo) {
	                        return gestureInfo;
	                    }
	                }
	            }
	        }
	    };
	
	    function dist(pointPair) {
	        var dx = pointPair[1][0] - pointPair[0][0];
	        var dy = pointPair[1][1] - pointPair[0][1];
	
	        return Math.sqrt(dx * dx + dy * dy);
	    }
	
	    function center(pointPair) {
	        return [
	            (pointPair[0][0] + pointPair[1][0]) / 2,
	            (pointPair[0][1] + pointPair[1][1]) / 2
	        ];
	    }
	
	    var recognizers = {
	
	        pinch: function (track, event) {
	            var trackLen = track.length;
	
	            if (!trackLen) {
	                return;
	            }
	
	            var pinchEnd = (track[trackLen - 1] || {}).points;
	            var pinchPre = (track[trackLen - 2] || {}).points || pinchEnd;
	
	            if (pinchPre
	                && pinchPre.length > 1
	                && pinchEnd
	                && pinchEnd.length > 1
	            ) {
	                var pinchScale = dist(pinchEnd) / dist(pinchPre);
	                !isFinite(pinchScale) && (pinchScale = 1);
	
	                event.pinchScale = pinchScale;
	
	                var pinchCenter = center(pinchEnd);
	                event.pinchX = pinchCenter[0];
	                event.pinchY = pinchCenter[1];
	
	                return {
	                    type: 'pinch',
	                    target: track[0].target,
	                    event: event
	                };
	            }
	        }
	
	        // Only pinch currently.
	    };
	
	    module.exports = GestureMgr;
	


/***/ },
/* 73 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	/**
	 * Default canvas painter
	 * @module zrender/Painter
	 * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)
	 *         errorrik (errorrik@gmail.com)
	 *         pissang (https://www.github.com/pissang)
	 */
	 
	
	    var config = __webpack_require__(21);
	    var util = __webpack_require__(4);
	    var log = __webpack_require__(20);
	    var BoundingRect = __webpack_require__(24);
	    var timsort = __webpack_require__(67);
	
	    var Layer = __webpack_require__(74);
	
	    var requestAnimationFrame = __webpack_require__(70);
	
	    // PENDIGN
	    // Layer exceeds MAX_PROGRESSIVE_LAYER_NUMBER may have some problem when flush directly second time.
	    //
	    // Maximum progressive layer. When exceeding this number. All elements will be drawed in the last layer.
	    var MAX_PROGRESSIVE_LAYER_NUMBER = 5;
	
	    function parseInt10(val) {
	        return parseInt(val, 10);
	    }
	
	    function isLayerValid(layer) {
	        if (!layer) {
	            return false;
	        }
	
	        if (layer.isBuildin) {
	            return true;
	        }
	
	        if (typeof(layer.resize) !== 'function'
	            || typeof(layer.refresh) !== 'function'
	        ) {
	            return false;
	        }
	
	        return true;
	    }
	
	    function preProcessLayer(layer) {
	        layer.__unusedCount++;
	    }
	
	    function postProcessLayer(layer) {
	        if (layer.__unusedCount == 1) {
	            layer.clear();
	        }
	    }
	
	    var tmpRect = new BoundingRect(0, 0, 0, 0);
	    var viewRect = new BoundingRect(0, 0, 0, 0);
	    function isDisplayableCulled(el, width, height) {
	        tmpRect.copy(el.getBoundingRect());
	        if (el.transform) {
	            tmpRect.applyTransform(el.transform);
	        }
	        viewRect.width = width;
	        viewRect.height = height;
	        return !tmpRect.intersect(viewRect);
	    }
	
	    function isClipPathChanged(clipPaths, prevClipPaths) {
	        if (clipPaths == prevClipPaths) { // Can both be null or undefined
	            return false;
	        }
	
	        if (!clipPaths || !prevClipPaths || (clipPaths.length !== prevClipPaths.length)) {
	            return true;
	        }
	        for (var i = 0; i < clipPaths.length; i++) {
	            if (clipPaths[i] !== prevClipPaths[i]) {
	                return true;
	            }
	        }
	    }
	
	    function doClip(clipPaths, ctx) {
	        for (var i = 0; i < clipPaths.length; i++) {
	            var clipPath = clipPaths[i];
	            var path = clipPath.path;
	
	            clipPath.setTransform(ctx);
	            path.beginPath(ctx);
	            clipPath.buildPath(path, clipPath.shape);
	            ctx.clip();
	            // Transform back
	            clipPath.restoreTransform(ctx);
	        }
	    }
	
	    function createRoot(width, height) {
	        var domRoot = document.createElement('div');
	        var domRootStyle = domRoot.style;
	
	        // domRoot.onselectstart = returnFalse; // 避免页面选中的尴尬
	        domRootStyle.position = 'relative';
	        domRootStyle.overflow = 'hidden';
	        domRootStyle.width = width + 'px';
	        domRootStyle.height = height + 'px';
	        return domRoot;
	    }
	
	    /**
	     * @alias module:zrender/Painter
	     * @constructor
	     * @param {HTMLElement} root 绘图容器
	     * @param {module:zrender/Storage} storage
	     * @param {Ojbect} opts
	     */
	    var Painter = function (root, storage, opts) {
	        // In node environment using node-canvas
	        var singleCanvas = !root.nodeName // In node ?
	            || root.nodeName.toUpperCase() === 'CANVAS';
	
	        opts = opts || {};
	
	        /**
	         * @type {number}
	         */
	        this.dpr = opts.devicePixelRatio || config.devicePixelRatio;
	        /**
	         * @type {boolean}
	         * @private
	         */
	        this._singleCanvas = singleCanvas;
	        /**
	         * 绘图容器
	         * @type {HTMLElement}
	         */
	        this.root = root;
	
	        var rootStyle = root.style;
	
	        if (rootStyle) {
	            rootStyle['-webkit-tap-highlight-color'] = 'transparent';
	            rootStyle['-webkit-user-select'] =
	            rootStyle['user-select'] =
	            rootStyle['-webkit-touch-callout'] = 'none';
	
	            root.innerHTML = '';
	        }
	
	        /**
	         * @type {module:zrender/Storage}
	         */
	        this.storage = storage;
	
	        /**
	         * @type {Array.<number>}
	         * @private
	         */
	        var zlevelList = this._zlevelList = [];
	
	        /**
	         * @type {Object.<string, module:zrender/Layer>}
	         * @private
	         */
	        var layers = this._layers = {};
	
	        /**
	         * @type {Object.<string, Object>}
	         * @type {private}
	         */
	        this._layerConfig = {};
	
	        if (!singleCanvas) {
	            this._width = this._getWidth();
	            this._height = this._getHeight();
	
	            var domRoot = this._domRoot = createRoot(
	                this._width, this._height
	            );
	            root.appendChild(domRoot);
	        }
	        else {
	            // Use canvas width and height directly
	            var width = root.width;
	            var height = root.height;
	            this._width = width;
	            this._height = height;
	
	            // Create layer if only one given canvas
	            // Device pixel ratio is fixed to 1 because given canvas has its specified width and height
	            var mainLayer = new Layer(root, this, 1);
	            mainLayer.initContext();
	            // FIXME Use canvas width and height
	            // mainLayer.resize(width, height);
	            layers[0] = mainLayer;
	            zlevelList.push(0);
	        }
	
	        this.pathToImage = this._createPathToImage();
	
	        // Layers for progressive rendering
	        this._progressiveLayers = [];
	
	        /**
	         * @type {module:zrender/Layer}
	         * @private
	         */
	        this._hoverlayer;
	
	        this._hoverElements = [];
	    };
	
	    Painter.prototype = {
	
	        constructor: Painter,
	
	        /**
	         * If painter use a single canvas
	         * @return {boolean}
	         */
	        isSingleCanvas: function () {
	            return this._singleCanvas;
	        },
	        /**
	         * @return {HTMLDivElement}
	         */
	        getViewportRoot: function () {
	            return this._singleCanvas ? this._layers[0].dom : this._domRoot;
	        },
	
	        /**
	         * 刷新
	         * @param {boolean} [paintAll=false] 强制绘制所有displayable
	         */
	        refresh: function (paintAll) {
	
	            var list = this.storage.getDisplayList(true);
	
	            var zlevelList = this._zlevelList;
	
	            this._paintList(list, paintAll);
	
	            // Paint custum layers
	            for (var i = 0; i < zlevelList.length; i++) {
	                var z = zlevelList[i];
	                var layer = this._layers[z];
	                if (!layer.isBuildin && layer.refresh) {
	                    layer.refresh();
	                }
	            }
	
	            this.refreshHover();
	
	            if (this._progressiveLayers.length) {
	                this._startProgessive();
	            }
	
	            return this;
	        },
	
	        addHover: function (el, hoverStyle) {
	            if (el.__hoverMir) {
	                return;
	            }
	            var elMirror = new el.constructor({
	                style: el.style,
	                shape: el.shape
	            });
	            elMirror.__from = el;
	            el.__hoverMir = elMirror;
	            elMirror.setStyle(hoverStyle);
	            this._hoverElements.push(elMirror);
	        },
	
	        removeHover: function (el) {
	            var elMirror = el.__hoverMir;
	            var hoverElements = this._hoverElements;
	            var idx = util.indexOf(hoverElements, elMirror);
	            if (idx >= 0) {
	                hoverElements.splice(idx, 1);
	            }
	            el.__hoverMir = null;
	        },
	
	        clearHover: function (el) {
	            var hoverElements = this._hoverElements;
	            for (var i = 0; i < hoverElements.length; i++) {
	                var from = hoverElements[i].__from;
	                if (from) {
	                    from.__hoverMir = null;
	                }
	            }
	            hoverElements.length = 0;
	        },
	
	        refreshHover: function () {
	            var hoverElements = this._hoverElements;
	            var len = hoverElements.length;
	            var hoverLayer = this._hoverlayer;
	            hoverLayer && hoverLayer.clear();
	
	            if (!len) {
	                return;
	            }
	            timsort(hoverElements, this.storage.displayableSortFunc);
	
	            // Use a extream large zlevel
	            // FIXME?
	            if (!hoverLayer) {
	                hoverLayer = this._hoverlayer = this.getLayer(1e5);
	            }
	
	            var scope = {};
	            hoverLayer.ctx.save();
	            for (var i = 0; i < len;) {
	                var el = hoverElements[i];
	                var originalEl = el.__from;
	                // Original el is removed
	                // PENDING
	                if (!(originalEl && originalEl.__zr)) {
	                    hoverElements.splice(i, 1);
	                    originalEl.__hoverMir = null;
	                    len--;
	                    continue;
	                }
	                i++;
	
	                // Use transform
	                // FIXME style and shape ?
	                if (!originalEl.invisible) {
	                    el.transform = originalEl.transform;
	                    el.invTransform = originalEl.invTransform;
	                    el.__clipPaths = originalEl.__clipPaths;
	                    // el.
	                    this._doPaintEl(el, hoverLayer, true, scope);
	                }
	            }
	            hoverLayer.ctx.restore();
	        },
	
	        _startProgessive: function () {
	            var self = this;
	
	            if (!self._furtherProgressive) {
	                return;
	            }
	
	            // Use a token to stop progress steps triggered by
	            // previous zr.refresh calling.
	            var token = self._progressiveToken = +new Date();
	
	            self._progress++;
	            requestAnimationFrame(step);
	
	            function step() {
	                // In case refreshed or disposed
	                if (token === self._progressiveToken && self.storage) {
	
	                    self._doPaintList(self.storage.getDisplayList());
	
	                    if (self._furtherProgressive) {
	                        self._progress++;
	                        requestAnimationFrame(step);
	                    }
	                    else {
	                        self._progressiveToken = -1;
	                    }
	                }
	            }
	        },
	
	        _clearProgressive: function () {
	            this._progressiveToken = -1;
	            this._progress = 0;
	            util.each(this._progressiveLayers, function (layer) {
	                layer.__dirty && layer.clear();
	            });
	        },
	
	        _paintList: function (list, paintAll) {
	
	            if (paintAll == null) {
	                paintAll = false;
	            }
	
	            this._updateLayerStatus(list);
	
	            this._clearProgressive();
	
	            this.eachBuildinLayer(preProcessLayer);
	
	            this._doPaintList(list, paintAll);
	
	            this.eachBuildinLayer(postProcessLayer);
	        },
	
	        _doPaintList: function (list, paintAll) {
	            var currentLayer;
	            var currentZLevel;
	            var ctx;
	
	            // var invTransform = [];
	            var scope;
	
	            var progressiveLayerIdx = 0;
	            var currentProgressiveLayer;
	
	            var width = this._width;
	            var height = this._height;
	            var layerProgress;
	            var frame = this._progress;
	            function flushProgressiveLayer(layer) {
	                var dpr = ctx.dpr || 1;
	                ctx.save();
	                ctx.globalAlpha = 1;
	                ctx.shadowBlur = 0;
	                // Avoid layer don't clear in next progressive frame
	                currentLayer.__dirty = true;
	                ctx.setTransform(1, 0, 0, 1, 0, 0);
	                ctx.drawImage(layer.dom, 0, 0, width * dpr, height * dpr);
	                ctx.restore();
	            }
	
	            for (var i = 0, l = list.length; i < l; i++) {
	                var el = list[i];
	                var elZLevel = this._singleCanvas ? 0 : el.zlevel;
	
	                var elFrame = el.__frame;
	
	                // Flush at current context
	                // PENDING
	                if (elFrame < 0 && currentProgressiveLayer) {
	                    flushProgressiveLayer(currentProgressiveLayer);
	                    currentProgressiveLayer = null;
	                }
	
	                // Change draw layer
	                if (currentZLevel !== elZLevel) {
	                    if (ctx) {
	                        ctx.restore();
	                    }
	
	                    // Reset scope
	                    scope = {};
	
	                    // Only 0 zlevel if only has one canvas
	                    currentZLevel = elZLevel;
	                    currentLayer = this.getLayer(currentZLevel);
	
	                    if (!currentLayer.isBuildin) {
	                        log(
	                            'ZLevel ' + currentZLevel
	                            + ' has been used by unkown layer ' + currentLayer.id
	                        );
	                    }
	
	                    ctx = currentLayer.ctx;
	                    ctx.save();
	
	                    // Reset the count
	                    currentLayer.__unusedCount = 0;
	
	                    if (currentLayer.__dirty || paintAll) {
	                        currentLayer.clear();
	                    }
	                }
	
	                if (!(currentLayer.__dirty || paintAll)) {
	                    continue;
	                }
	
	                if (elFrame >= 0) {
	                    // Progressive layer changed
	                    if (!currentProgressiveLayer) {
	                        currentProgressiveLayer = this._progressiveLayers[
	                            Math.min(progressiveLayerIdx++, MAX_PROGRESSIVE_LAYER_NUMBER - 1)
	                        ];
	
	                        currentProgressiveLayer.ctx.save();
	                        currentProgressiveLayer.renderScope = {};
	
	                        if (currentProgressiveLayer
	                            && (currentProgressiveLayer.__progress > currentProgressiveLayer.__maxProgress)
	                        ) {
	                            // flushProgressiveLayer(currentProgressiveLayer);
	                            // Quick jump all progressive elements
	                            // All progressive element are not dirty, jump over and flush directly
	                            i = currentProgressiveLayer.__nextIdxNotProg - 1;
	                            // currentProgressiveLayer = null;
	                            continue;
	                        }
	
	                        layerProgress = currentProgressiveLayer.__progress;
	
	                        if (!currentProgressiveLayer.__dirty) {
	                            // Keep rendering
	                            frame = layerProgress;
	                        }
	
	                        currentProgressiveLayer.__progress = frame + 1;
	                    }
	
	                    if (elFrame === frame) {
	                        this._doPaintEl(el, currentProgressiveLayer, true, currentProgressiveLayer.renderScope);
	                    }
	                }
	                else {
	                    this._doPaintEl(el, currentLayer, paintAll, scope);
	                }
	
	                el.__dirty = false;
	            }
	
	            if (currentProgressiveLayer) {
	                flushProgressiveLayer(currentProgressiveLayer);
	            }
	
	            // Restore the lastLayer ctx
	            ctx && ctx.restore();
	            // If still has clipping state
	            // if (scope.prevElClipPaths) {
	            //     ctx.restore();
	            // }
	
	            this._furtherProgressive = false;
	            util.each(this._progressiveLayers, function (layer) {
	                if (layer.__maxProgress >= layer.__progress) {
	                    this._furtherProgressive = true;
	                }
	            }, this);
	        },
	
	        _doPaintEl: function (el, currentLayer, forcePaint, scope) {
	            var ctx = currentLayer.ctx;
	            var m = el.transform;
	            if (
	                (currentLayer.__dirty || forcePaint)
	                // Ignore invisible element
	                && !el.invisible
	                // Ignore transparent element
	                && el.style.opacity !== 0
	                // Ignore scale 0 element, in some environment like node-canvas
	                // Draw a scale 0 element can cause all following draw wrong
	                // And setTransform with scale 0 will cause set back transform failed.
	                && !(m && !m[0] && !m[3])
	                // Ignore culled element
	                && !(el.culling && isDisplayableCulled(el, this._width, this._height))
	            ) {
	
	                var clipPaths = el.__clipPaths;
	
	                // Optimize when clipping on group with several elements
	                if (scope.prevClipLayer !== currentLayer
	                    || isClipPathChanged(clipPaths, scope.prevElClipPaths)
	                ) {
	                    // If has previous clipping state, restore from it
	                    if (scope.prevElClipPaths) {
	                        scope.prevClipLayer.ctx.restore();
	                        scope.prevClipLayer = scope.prevElClipPaths = null;
	
	                        // Reset prevEl since context has been restored
	                        scope.prevEl = null;
	                    }
	                    // New clipping state
	                    if (clipPaths) {
	                        ctx.save();
	                        doClip(clipPaths, ctx);
	                        scope.prevClipLayer = currentLayer;
	                        scope.prevElClipPaths = clipPaths;
	                    }
	                }
	                el.beforeBrush && el.beforeBrush(ctx);
	
	                el.brush(ctx, scope.prevEl || null);
	                scope.prevEl = el;
	
	                el.afterBrush && el.afterBrush(ctx);
	            }
	        },
	
	        /**
	         * 获取 zlevel 所在层，如果不存在则会创建一个新的层
	         * @param {number} zlevel
	         * @return {module:zrender/Layer}
	         */
	        getLayer: function (zlevel) {
	            if (this._singleCanvas) {
	                return this._layers[0];
	            }
	
	            var layer = this._layers[zlevel];
	            if (!layer) {
	                // Create a new layer
	                layer = new Layer('zr_' + zlevel, this, this.dpr);
	                layer.isBuildin = true;
	
	                if (this._layerConfig[zlevel]) {
	                    util.merge(layer, this._layerConfig[zlevel], true);
	                }
	
	                this.insertLayer(zlevel, layer);
	
	                // Context is created after dom inserted to document
	                // Or excanvas will get 0px clientWidth and clientHeight
	                layer.initContext();
	            }
	
	            return layer;
	        },
	
	        insertLayer: function (zlevel, layer) {
	
	            var layersMap = this._layers;
	            var zlevelList = this._zlevelList;
	            var len = zlevelList.length;
	            var prevLayer = null;
	            var i = -1;
	            var domRoot = this._domRoot;
	
	            if (layersMap[zlevel]) {
	                log('ZLevel ' + zlevel + ' has been used already');
	                return;
	            }
	            // Check if is a valid layer
	            if (!isLayerValid(layer)) {
	                log('Layer of zlevel ' + zlevel + ' is not valid');
	                return;
	            }
	
	            if (len > 0 && zlevel > zlevelList[0]) {
	                for (i = 0; i < len - 1; i++) {
	                    if (
	                        zlevelList[i] < zlevel
	                        && zlevelList[i + 1] > zlevel
	                    ) {
	                        break;
	                    }
	                }
	                prevLayer = layersMap[zlevelList[i]];
	            }
	            zlevelList.splice(i + 1, 0, zlevel);
	
	            if (prevLayer) {
	                var prevDom = prevLayer.dom;
	                if (prevDom.nextSibling) {
	                    domRoot.insertBefore(
	                        layer.dom,
	                        prevDom.nextSibling
	                    );
	                }
	                else {
	                    domRoot.appendChild(layer.dom);
	                }
	            }
	            else {
	                if (domRoot.firstChild) {
	                    domRoot.insertBefore(layer.dom, domRoot.firstChild);
	                }
	                else {
	                    domRoot.appendChild(layer.dom);
	                }
	            }
	
	            layersMap[zlevel] = layer;
	        },
	
	        // Iterate each layer
	        eachLayer: function (cb, context) {
	            var zlevelList = this._zlevelList;
	            var z;
	            var i;
	            for (i = 0; i < zlevelList.length; i++) {
	                z = zlevelList[i];
	                cb.call(context, this._layers[z], z);
	            }
	        },
	
	        // Iterate each buildin layer
	        eachBuildinLayer: function (cb, context) {
	            var zlevelList = this._zlevelList;
	            var layer;
	            var z;
	            var i;
	            for (i = 0; i < zlevelList.length; i++) {
	                z = zlevelList[i];
	                layer = this._layers[z];
	                if (layer.isBuildin) {
	                    cb.call(context, layer, z);
	                }
	            }
	        },
	
	        // Iterate each other layer except buildin layer
	        eachOtherLayer: function (cb, context) {
	            var zlevelList = this._zlevelList;
	            var layer;
	            var z;
	            var i;
	            for (i = 0; i < zlevelList.length; i++) {
	                z = zlevelList[i];
	                layer = this._layers[z];
	                if (! layer.isBuildin) {
	                    cb.call(context, layer, z);
	                }
	            }
	        },
	
	        /**
	         * 获取所有已创建的层
	         * @param {Array.<module:zrender/Layer>} [prevLayer]
	         */
	        getLayers: function () {
	            return this._layers;
	        },
	
	        _updateLayerStatus: function (list) {
	
	            var layers = this._layers;
	            var progressiveLayers = this._progressiveLayers;
	
	            var elCountsLastFrame = {};
	            var progressiveElCountsLastFrame = {};
	
	            this.eachBuildinLayer(function (layer, z) {
	                elCountsLastFrame[z] = layer.elCount;
	                layer.elCount = 0;
	                layer.__dirty = false;
	            });
	
	            util.each(progressiveLayers, function (layer, idx) {
	                progressiveElCountsLastFrame[idx] = layer.elCount;
	                layer.elCount = 0;
	                layer.__dirty = false;
	            });
	
	            var progressiveLayerCount = 0;
	            var currentProgressiveLayer;
	            var lastProgressiveKey;
	            var frameCount = 0;
	            for (var i = 0, l = list.length; i < l; i++) {
	                var el = list[i];
	                var zlevel = this._singleCanvas ? 0 : el.zlevel;
	                var layer = layers[zlevel];
	                var elProgress = el.progressive;
	                if (layer) {
	                    layer.elCount++;
	                    layer.__dirty = layer.__dirty || el.__dirty;
	                }
	
	                /////// Update progressive
	                if (elProgress >= 0) {
	                    // Fix wrong progressive sequence problem.
	                    if (lastProgressiveKey !== elProgress) {
	                        lastProgressiveKey = elProgress;
	                        frameCount++;
	                    }
	                    var elFrame = el.__frame = frameCount - 1;
	                    if (!currentProgressiveLayer) {
	                        var idx = Math.min(progressiveLayerCount, MAX_PROGRESSIVE_LAYER_NUMBER - 1);
	                        currentProgressiveLayer = progressiveLayers[idx];
	                        if (!currentProgressiveLayer) {
	                            currentProgressiveLayer = progressiveLayers[idx] = new Layer(
	                                'progressive', this, this.dpr
	                            );
	                            currentProgressiveLayer.initContext();
	                        }
	                        currentProgressiveLayer.__maxProgress = 0;
	                    }
	                    currentProgressiveLayer.__dirty = currentProgressiveLayer.__dirty || el.__dirty;
	                    currentProgressiveLayer.elCount++;
	
	                    currentProgressiveLayer.__maxProgress = Math.max(
	                        currentProgressiveLayer.__maxProgress, elFrame
	                    );
	
	                    if (currentProgressiveLayer.__maxProgress >= currentProgressiveLayer.__progress) {
	                        // Should keep rendering this  layer because progressive rendering is not finished yet
	                        layer.__dirty = true;
	                    }
	                }
	                else {
	                    el.__frame = -1;
	
	                    if (currentProgressiveLayer) {
	                        currentProgressiveLayer.__nextIdxNotProg = i;
	                        progressiveLayerCount++;
	                        currentProgressiveLayer = null;
	                    }
	                }
	            }
	
	            if (currentProgressiveLayer) {
	                progressiveLayerCount++;
	                currentProgressiveLayer.__nextIdxNotProg = i;
	            }
	
	            // 层中的元素数量有发生变化
	            this.eachBuildinLayer(function (layer, z) {
	                if (elCountsLastFrame[z] !== layer.elCount) {
	                    layer.__dirty = true;
	                }
	            });
	
	            progressiveLayers.length = Math.min(progressiveLayerCount, MAX_PROGRESSIVE_LAYER_NUMBER);
	            util.each(progressiveLayers, function (layer, idx) {
	                if (progressiveElCountsLastFrame[idx] !== layer.elCount) {
	                    el.__dirty = true;
	                }
	                if (layer.__dirty) {
	                    layer.__progress = 0;
	                }
	            });
	        },
	
	        /**
	         * 清除hover层外所有内容
	         */
	        clear: function () {
	            this.eachBuildinLayer(this._clearLayer);
	            return this;
	        },
	
	        _clearLayer: function (layer) {
	            layer.clear();
	        },
	
	        /**
	         * 修改指定zlevel的绘制参数
	         *
	         * @param {string} zlevel
	         * @param {Object} config 配置对象
	         * @param {string} [config.clearColor=0] 每次清空画布的颜色
	         * @param {string} [config.motionBlur=false] 是否开启动态模糊
	         * @param {number} [config.lastFrameAlpha=0.7]
	         *                 在开启动态模糊的时候使用，与上一帧混合的alpha值，值越大尾迹越明显
	         */
	        configLayer: function (zlevel, config) {
	            if (config) {
	                var layerConfig = this._layerConfig;
	                if (!layerConfig[zlevel]) {
	                    layerConfig[zlevel] = config;
	                }
	                else {
	                    util.merge(layerConfig[zlevel], config, true);
	                }
	
	                var layer = this._layers[zlevel];
	
	                if (layer) {
	                    util.merge(layer, layerConfig[zlevel], true);
	                }
	            }
	        },
	
	        /**
	         * 删除指定层
	         * @param {number} zlevel 层所在的zlevel
	         */
	        delLayer: function (zlevel) {
	            var layers = this._layers;
	            var zlevelList = this._zlevelList;
	            var layer = layers[zlevel];
	            if (!layer) {
	                return;
	            }
	            layer.dom.parentNode.removeChild(layer.dom);
	            delete layers[zlevel];
	
	            zlevelList.splice(util.indexOf(zlevelList, zlevel), 1);
	        },
	
	        /**
	         * 区域大小变化后重绘
	         */
	        resize: function (width, height) {
	            var domRoot = this._domRoot;
	            // FIXME Why ?
	            domRoot.style.display = 'none';
	
	            width = width || this._getWidth();
	            height = height || this._getHeight();
	
	            domRoot.style.display = '';
	
	            // 优化没有实际改变的resize
	            if (this._width != width || height != this._height) {
	                domRoot.style.width = width + 'px';
	                domRoot.style.height = height + 'px';
	
	                for (var id in this._layers) {
	                    this._layers[id].resize(width, height);
	                }
	
	                this.refresh(true);
	            }
	
	            this._width = width;
	            this._height = height;
	
	            return this;
	        },
	
	        /**
	         * 清除单独的一个层
	         * @param {number} zlevel
	         */
	        clearLayer: function (zlevel) {
	            var layer = this._layers[zlevel];
	            if (layer) {
	                layer.clear();
	            }
	        },
	
	        /**
	         * 释放
	         */
	        dispose: function () {
	            this.root.innerHTML = '';
	
	            this.root =
	            this.storage =
	
	            this._domRoot =
	            this._layers = null;
	        },
	
	        /**
	         * Get canvas which has all thing rendered
	         * @param {Object} opts
	         * @param {string} [opts.backgroundColor]
	         */
	        getRenderedCanvas: function (opts) {
	            opts = opts || {};
	            if (this._singleCanvas) {
	                return this._layers[0].dom;
	            }
	
	            var imageLayer = new Layer('image', this, opts.pixelRatio || this.dpr);
	            imageLayer.initContext();
	
	            imageLayer.clearColor = opts.backgroundColor;
	            imageLayer.clear();
	
	            var displayList = this.storage.getDisplayList(true);
	
	            var scope = {};
	            for (var i = 0; i < displayList.length; i++) {
	                var el = displayList[i];
	                this._doPaintEl(el, imageLayer, true, scope);
	            }
	
	            return imageLayer.dom;
	        },
	        /**
	         * 获取绘图区域宽度
	         */
	        getWidth: function () {
	            return this._width;
	        },
	
	        /**
	         * 获取绘图区域高度
	         */
	        getHeight: function () {
	            return this._height;
	        },
	
	        _getWidth: function () {
	            var root = this.root;
	            var stl = document.defaultView.getComputedStyle(root);
	
	            // FIXME Better way to get the width and height when element has not been append to the document
	            return ((root.clientWidth || parseInt10(stl.width) || parseInt10(root.style.width))
	                    - (parseInt10(stl.paddingLeft) || 0)
	                    - (parseInt10(stl.paddingRight) || 0)) | 0;
	        },
	
	        _getHeight: function () {
	            var root = this.root;
	            var stl = document.defaultView.getComputedStyle(root);
	
	            return ((root.clientHeight || parseInt10(stl.height) || parseInt10(root.style.height))
	                    - (parseInt10(stl.paddingTop) || 0)
	                    - (parseInt10(stl.paddingBottom) || 0)) | 0;
	        },
	
	        _pathToImage: function (id, path, width, height, dpr) {
	            var canvas = document.createElement('canvas');
	            var ctx = canvas.getContext('2d');
	
	            canvas.width = width * dpr;
	            canvas.height = height * dpr;
	
	            ctx.clearRect(0, 0, width * dpr, height * dpr);
	
	            var pathTransform = {
	                position: path.position,
	                rotation: path.rotation,
	                scale: path.scale
	            };
	            path.position = [0, 0, 0];
	            path.rotation = 0;
	            path.scale = [1, 1];
	            if (path) {
	                path.brush(ctx);
	            }
	
	            var ImageShape = __webpack_require__(40);
	            var imgShape = new ImageShape({
	                id: id,
	                style: {
	                    x: 0,
	                    y: 0,
	                    image: canvas
	                }
	            });
	
	            if (pathTransform.position != null) {
	                imgShape.position = path.position = pathTransform.position;
	            }
	
	            if (pathTransform.rotation != null) {
	                imgShape.rotation = path.rotation = pathTransform.rotation;
	            }
	
	            if (pathTransform.scale != null) {
	                imgShape.scale = path.scale = pathTransform.scale;
	            }
	
	            return imgShape;
	        },
	
	        _createPathToImage: function () {
	            var me = this;
	
	            return function (id, e, width, height) {
	                return me._pathToImage(
	                    id, e, width, height, me.dpr
	                );
	            };
	        }
	    };
	
	    module.exports = Painter;
	


/***/ },
/* 74 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @module zrender/Layer
	 * @author pissang(https://www.github.com/pissang)
	 */
	
	
	    var util = __webpack_require__(4);
	    var config = __webpack_require__(21);
	    var Style = __webpack_require__(8);
	    var Pattern = __webpack_require__(35);
	
	    function returnFalse() {
	        return false;
	    }
	
	    /**
	     * 创建dom
	     *
	     * @inner
	     * @param {string} id dom id 待用
	     * @param {string} type dom type，such as canvas, div etc.
	     * @param {Painter} painter painter instance
	     * @param {number} number
	     */
	    function createDom(id, type, painter, dpr) {
	        var newDom = document.createElement(type);
	        var width = painter.getWidth();
	        var height = painter.getHeight();
	
	        var newDomStyle = newDom.style;
	        // 没append呢，请原谅我这样写，清晰~
	        newDomStyle.position = 'absolute';
	        newDomStyle.left = 0;
	        newDomStyle.top = 0;
	        newDomStyle.width = width + 'px';
	        newDomStyle.height = height + 'px';
	        newDom.width = width * dpr;
	        newDom.height = height * dpr;
	
	        // id不作为索引用，避免可能造成的重名，定义为私有属性
	        newDom.setAttribute('data-zr-dom-id', id);
	        return newDom;
	    }
	
	    /**
	     * @alias module:zrender/Layer
	     * @constructor
	     * @extends module:zrender/mixin/Transformable
	     * @param {string} id
	     * @param {module:zrender/Painter} painter
	     * @param {number} [dpr]
	     */
	    var Layer = function(id, painter, dpr) {
	        var dom;
	        dpr = dpr || config.devicePixelRatio;
	        if (typeof id === 'string') {
	            dom = createDom(id, 'canvas', painter, dpr);
	        }
	        // Not using isDom because in node it will return false
	        else if (util.isObject(id)) {
	            dom = id;
	            id = dom.id;
	        }
	        this.id = id;
	        this.dom = dom;
	
	        var domStyle = dom.style;
	        if (domStyle) { // Not in node
	            dom.onselectstart = returnFalse; // 避免页面选中的尴尬
	            domStyle['-webkit-user-select'] = 'none';
	            domStyle['user-select'] = 'none';
	            domStyle['-webkit-touch-callout'] = 'none';
	            domStyle['-webkit-tap-highlight-color'] = 'rgba(0,0,0,0)';
	        }
	
	        this.domBack = null;
	        this.ctxBack = null;
	
	        this.painter = painter;
	
	        this.config = null;
	
	        // Configs
	        /**
	         * 每次清空画布的颜色
	         * @type {string}
	         * @default 0
	         */
	        this.clearColor = 0;
	        /**
	         * 是否开启动态模糊
	         * @type {boolean}
	         * @default false
	         */
	        this.motionBlur = false;
	        /**
	         * 在开启动态模糊的时候使用，与上一帧混合的alpha值，值越大尾迹越明显
	         * @type {number}
	         * @default 0.7
	         */
	        this.lastFrameAlpha = 0.7;
	
	        /**
	         * Layer dpr
	         * @type {number}
	         */
	        this.dpr = dpr;
	    };
	
	    Layer.prototype = {
	
	        constructor: Layer,
	
	        elCount: 0,
	
	        __dirty: true,
	
	        initContext: function () {
	            this.ctx = this.dom.getContext('2d');
	
	            this.ctx.dpr = this.dpr;
	        },
	
	        createBackBuffer: function () {
	            var dpr = this.dpr;
	
	            this.domBack = createDom('back-' + this.id, 'canvas', this.painter, dpr);
	            this.ctxBack = this.domBack.getContext('2d');
	
	            if (dpr != 1) {
	                this.ctxBack.scale(dpr, dpr);
	            }
	        },
	
	        /**
	         * @param  {number} width
	         * @param  {number} height
	         */
	        resize: function (width, height) {
	            var dpr = this.dpr;
	
	            var dom = this.dom;
	            var domStyle = dom.style;
	            var domBack = this.domBack;
	
	            domStyle.width = width + 'px';
	            domStyle.height = height + 'px';
	
	            dom.width = width * dpr;
	            dom.height = height * dpr;
	
	            if (domBack) {
	                domBack.width = width * dpr;
	                domBack.height = height * dpr;
	
	                if (dpr != 1) {
	                    this.ctxBack.scale(dpr, dpr);
	                }
	            }
	        },
	
	        /**
	         * 清空该层画布
	         * @param {boolean} clearAll Clear all with out motion blur
	         */
	        clear: function (clearAll) {
	            var dom = this.dom;
	            var ctx = this.ctx;
	            var width = dom.width;
	            var height = dom.height;
	
	            var clearColor = this.clearColor;
	            var haveMotionBLur = this.motionBlur && !clearAll;
	            var lastFrameAlpha = this.lastFrameAlpha;
	
	            var dpr = this.dpr;
	
	            if (haveMotionBLur) {
	                if (!this.domBack) {
	                    this.createBackBuffer();
	                }
	
	                this.ctxBack.globalCompositeOperation = 'copy';
	                this.ctxBack.drawImage(
	                    dom, 0, 0,
	                    width / dpr,
	                    height / dpr
	                );
	            }
	
	            ctx.clearRect(0, 0, width, height);
	            if (clearColor) {
	                var clearColorGradientOrPattern;
	                // Gradient
	                if (clearColor.colorStops) {
	                    // Cache canvas gradient
	                    clearColorGradientOrPattern = clearColor.__canvasGradient || Style.getGradient(ctx, clearColor, {
	                        x: 0,
	                        y: 0,
	                        width: width,
	                        height: height
	                    });
	
	                    clearColor.__canvasGradient = clearColorGradientOrPattern;
	                }
	                // Pattern
	                else if (clearColor.image) {
	                    clearColorGradientOrPattern = Pattern.prototype.getCanvasPattern.call(clearColor, ctx);
	                }
	                ctx.save();
	                ctx.fillStyle = clearColorGradientOrPattern || clearColor;
	                ctx.fillRect(0, 0, width, height);
	                ctx.restore();
	            }
	
	            if (haveMotionBLur) {
	                var domBack = this.domBack;
	                ctx.save();
	                ctx.globalAlpha = lastFrameAlpha;
	                ctx.drawImage(domBack, 0, 0, width, height);
	                ctx.restore();
	            }
	        }
	    };
	
	    module.exports = Layer;


/***/ },
/* 75 */
/***/ function(module, exports, __webpack_require__) {

	
	    var Node = __webpack_require__(76);
	    var zrUtil = __webpack_require__(4);
	    var BoundingRect = __webpack_require__(24);
	    var graphic = __webpack_require__(3);
	    var util = __webpack_require__(59);
	    var Connector = __webpack_require__(77);
	    //创建Node类 所有形状都继承Node
	    //
	    function GroupNode(model, api) {
	
	        Node.call(this, model, api);
	        this.bpmnInfo = {type: -1, name:"GroupNode" };    //节点信息
	        this.model = model;
	        var defaultOptions = {
	                shape: {
	                    width:0,
	                    height:0,
	                    r: 7
	                },
	                style: {
	                    fill: '#f9f9f9',
	                    stroke: '#bbbbbb'
	                },
	                position:[0,0]
	            };
	        this.options = zrUtil.extend(defaultOptions, model);
	        this.isdraggable = this.options.isdraggable;
	        this.max = [1024,960];
	        this.render(this.options);
	    }
	
	    GroupNode.prototype.render = function(model) {
	        var rect = new graphic.Rect({
	            shape: model.shape,
	            style: model.style
	        });
	        rect.name = "Rect";
	        this.add(rect);
	        this.position = model.position;
	        this.mergedImage = model.mergedImage;
	    };
	
	    GroupNode.prototype.fromJSON = function(json) {
	        // body...
	
	
	    };
	
	    GroupNode.prototype.rectContain = function(x, y) {
	        var rect = util.getRect(this);
	        return rect.boundingRect.contain(x,y);
	    };
	
	    GroupNode.prototype.getRect = function() {
	        // body...
	        var boundingRect = this.getBoundingRect();
	        //创建最小包围盒虚线
	        var points = [];
	        points[0] =[-boundingRect.width/2,-boundingRect.height/2];
	        points[1] =[boundingRect.width/2,-boundingRect.height/2];
	        points[2] =[boundingRect.width/2,boundingRect.height/2];
	        points[3] =[-boundingRect.width/2,boundingRect.height/2];
	        points[4] =[-boundingRect.width/2,-boundingRect.height/2];
	
	        var boundRect = new BoundingRect(this.position[0] ,
	                                         this.position[1],
	                                         boundingRect.width, boundingRect.height);
	        return {
	            x: this.position[0]+boundingRect.width/2,
	            y: this.position[1]+boundingRect.height/2,
	            width: boundingRect.width,
	            height: boundingRect.height,
	            points: points,
	            boundingRect: boundRect
	        };
	    };
	
	    GroupNode.prototype.reDraw = function(nodeMessage,node,nowGroupPosition) {
	        //重置背景rect 的长宽
	        var minLength = this.options.shape.r;
	        this.setProperties({
	            shape:{
	                    width:minLength,
	                    height:minLength,
	                    r: minLength
	            }
	        });
	        var groupPosition = zrUtil.clone(this.position);
	        var rect = this.childOfName("Rect");
	        var width = this.getBoundingRect().width;
	        var height = this.getBoundingRect().height;
	        var rx = rect.shape.x,ry = rect.shape.y;
	        //取group中所有节点最靠上边和最高左边的值，不包括背景rect的值
	        var minX = this._children[1].position[0],minY = this._children[1].position[1];
	        var maxX = this._children[1].position[0],maxY = this._children[1].position[1];
	        var lineNode = [];
	        var nowGroupPosition = zrUtil.clone(nodeMessage.position);
	        for(var i = 1; i<this._children.length;i++){
	            if(this._children[i] instanceof Connector || this._children[i].isIcon == true){
	                continue;
	            }else{
	                if(minX>this._children[i].position[0]){
	                    minX = this._children[i].position[0];
	                }
	                if(maxX<this._children[i].position[0]){
	                    maxX = this._children[i].position[0];
	                }
	            }
	
	        }
	        for(var j = 1; j<this._children.length;j++){
	            if(this._children[j] instanceof Connector || this._children[j].isIcon == true){
	                continue;
	            }else{
	                if(minY>this._children[j].position[1]){
	                    minY = this._children[j].position[1];
	                }
	                if(maxY<this._children[j].position[1]){
	                    maxY = this._children[j].position[1];
	                }
	            }
	        }
	        if(width > this.max[0]){
	            width = this.max[0]-2;
	            if(nodeMessage.position[0]>minX){
	                nowGroupPosition[0] = minX+this.max[0]-nodeMessage.width;
	            }else{
	                nowGroupPosition[0] = maxX-this.max[0]+nodeMessage.width;
	            }
	        }else{
	            //移动节点改变group中背景rect的x位置，不超过最小的值
	            rx = this.childOfName("Rect").position[0]+(nodeMessage.position[0]);
	            if(rx>minX){
	                rx = minX;
	            }
	            nowGroupPosition[0] = nodeMessage.movePosition[0]+nodeMessage.moveX;
	            if(nodeMessage.position[0]>minX){
	                if(nowGroupPosition[0]>minX+this.max[0]-nodeMessage.width){
	                    nowGroupPosition[0] = minX+this.max[0]-nodeMessage.width;
	                }
	            }else{
	                if(nowGroupPosition[0] < maxX-this.max[0]+nodeMessage.width){
	                    nowGroupPosition[0] = maxX-this.max[0]+nodeMessage.width
	                }
	            }
	        }
	        if(height > this.max[1]){
	            height = this.max[1]-2;
	            if(nodeMessage.position[1]>minY){
	                nowGroupPosition[1] = minY+this.max[1]-nodeMessage.height;
	            }else{
	                nowGroupPosition[1] = maxY-this.max[1]+nodeMessage.height;
	            }
	        }else{
	            //移动节点改变group中背景rect的y位置，不超过最小的值
	            ry = this.childOfName("Rect").position[1]+(nodeMessage.position[1]);
	            if(ry>minY){
	                ry = minY;
	            }
	            nowGroupPosition[1] = nodeMessage.movePosition[1]+nodeMessage.moveY;
	            if(nodeMessage.position[1]>minY){
	                if(nowGroupPosition[1]>minY+this.max[1]-nodeMessage.height){
	                    nowGroupPosition[1] = minY+this.max[1]-nodeMessage.height;
	                }
	            }else{
	                if(nowGroupPosition[1] < maxY-this.max[1]+nodeMessage.height){
	                    nowGroupPosition[1] = maxY-this.max[1]+nodeMessage.height
	                }
	            }
	        }
	        if(node.alarm){
	            var newAlarmPosition = [nowGroupPosition[0]+node.getBoundingRect().width-(node.alarm.getBoundingRect().width-6),nowGroupPosition[1]-node.alarm.getBoundingRect().height-3];
	            node.alarm.attr("position",newAlarmPosition);
	        }
	        //改变背景rect的长宽和位置
	        this.setProperties({
	            shape:{
	                width:width,
	                height:height,
	                x:rx,
	                y:ry
	            }
	        });
	
	    };
	    GroupNode.prototype.setProperties = function(opt) {
	        var rect = this.childOfName("Rect");
	        rect.setShape(opt.shape);
	        rect.attr("style",opt.style);
	        this.attr('position',opt.position);
	        this.attr("shape",opt.shape);
	    };
	
	    //组的合并与放开
	    GroupNode.prototype.merged = function() {
	        var that = this;
	        if(!this.mergedImage){
	            return;
	        }
	        //保留group的初始位置
	        var groupPosition = zrUtil.clone(this.position);
	        //给小图片设置属性，隐藏group
	        var width = this.relationImage.getBoundingRect().width;
	        var height = this.relationImage.getBoundingRect().height;
	        //计算合并后的小图片的position
	        var relationImagePosition = [this.position[0]+this.childOfName("Rect").shape.x+(this.getBoundingRect().width/2-width/2),this.position[1]+this.childOfName("Rect").shape.y+(this.getBoundingRect().height/2-height/2)];
	        //将小图片的位置保留下来
	        var cloneImagePosition = zrUtil.clone(relationImagePosition);
	        this.relationImage.attr("style",{image:this.mergedImage,width:width,height:height});
	        this.relationImage.attr("position",relationImagePosition);
	        if(width>0&&height>0){
	            this.hide();
	            this.relationImage.show();
	        }
	
	        //双击图片放出组
	        this.relationImage.on("dblclick",function(){
	            that.setProperties({
	                //设置组的位置根据小图片的偏移量来计算
	                position:[groupPosition[0]+(this.position[0]-cloneImagePosition[0]),groupPosition[1]+(this.position[1]-cloneImagePosition[1])]
	            });
	            this.hide();
	            that.show();
	        });
	        return this.relationImage;
	    };
	
	    zrUtil.inherits(GroupNode,Node);
	    module.exports = GroupNode;
	


/***/ },
/* 76 */
/***/ function(module, exports, __webpack_require__) {

	
	    var graphic = __webpack_require__(3);
	    var util = __webpack_require__(59)
	    //创建Node类 所有形状都继承Node  包括fromJSON toJSON
	    function Node() {
	        this.resourceId = util.getUUID(); // 生成节点ID
	        graphic.Group.call(this);
	    }
	
	    /**
	     * 由父类实现
	     * @return {[type]} [description]
	     */
	    Node.prototype.render = function() {};
	
	    /**
	     * 由父类实现
	     * @param  {[type]} json [description]
	     * @return {[type]}      [description]
	     */
	    Node.prototype.getRect = function(json) {};
	
	    /**
	     * drawText
	     * @description 画一个文本
	     * @param {string} name
	     * @param {string} color
	     */
	    Node.prototype.drawText = function(name,color) {
	        var textName = this.bpmnInfo.name;
	        if(name != null){
	            textName = name;
	        }
	        var text = new graphic.Text({
	            style: {
	                text: textName,
	                color: color ? color : this.options.text.color,
	                textFont: '12px Microsoft YaHei'
	            },
	            zlevel: 20
	        });
	        //文字绘制的位置  
	        //x = 中心点.x - 起始位置.x - 文字宽度的一半
	        var x = this.getRect().x - this.position[0] - text.getBoundingRect().width / 2;
	        //y = 中心点.y - 起始位置.y + 节点高度的一半 + 偏移值（6）
	        var y = this.getRect().y - this.position[1] + this.getBoundingRect().height / 2 + text.getBoundingRect().height + 6;
	        text.attr("style", { x: x, y: y });
	        return {
	            text: text,
	            rect: text.getBoundingRect()
	        };
	    };
	    /**
	     * refreshText
	     * @description 刷新文本
	     */
	    Node.prototype.refreshText = function() {
	        var text = this.childOfName("Title");
	        var x = this.getRect().x - this.position[0] - text.getBoundingRect().width / 2;
	        var y = this.getRect().y - this.position[1] + this.getBoundingRect().height / 2 + text.getBoundingRect().height + 6;
	        text.attr("style", { x: x, y: y });
	    };
	    /**
	     * 由父类实现
	     * @return {[type]} [description]
	     */
	    Node.prototype.toJSON = function() {};
	
	    graphic.Util.inherits(Node, graphic.Group);
	    module.exports = Node;
	


/***/ },
/* 77 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * 连接线
	 * @author wang.xiaohu
	 */
	
	    var Util = __webpack_require__(59);
	    var zrUtil = __webpack_require__(4);
	    var graphic = __webpack_require__(3);
	    var Node = __webpack_require__(76);
	    var symbolUtil = __webpack_require__(78);
	    var Handle = __webpack_require__(79);
	    var EffectLine = __webpack_require__(80);
	    var ConnectionPoint = __webpack_require__(81);
	    var Point = __webpack_require__(60);
	    /**
	     * 构造函数
	     * @param {[type]} options [description]
	     */
	    function Connector(options) {
	        Node.call(this);
	        this.resourceId = Util.getUUID();  // 生成节点ID
	        var defaultOptions = {
	            symbol: {type:"arrow" , size: 10, color:"#000000"},  //箭头  可选值为： 'circle', 'rect', 'roundRect', 'triangle', 'diamond', 'pin', 'arrow'
	            style: {lineWidth:1, stroke:"#000000", lineType:Connector.TYPE_STRAIGHT},    //样式
	            hoverStyle: {lineWidth:2, stroke:"lime"}, //移上去的样式
	            arrowHoverStyle: {fill:"lime"},
	            shape: {points:null, smooth:false, smoothConstraint:null},//形状
	            position: [0,0],
	            isEdit: true,  //是否可编辑
	            text: {
	                text: "",
	                color: '#000000', // 文本颜色
	                textFont: '12px Microsoft YaHei'
	            },
	            z: 0
	        }
	        var opt = options || {};
	        this.options = zrUtil.merge(defaultOptions, opt, true);
	        this.model = options.model;
	        this.handles = [];
	        this.connectionPoints = [];
	        this.conPointsGroup = null;
	        this.startNode = null;
	        this.endNode = null;
	        this.line = null;
	        this.groupCurve = new graphic.Group();
	        this.icons = [];  // 用于存储线段上面的操作图标
	        this.render();
	    }
	
	    Connector.TYPE_STRAIGHT = 'straight';
	
	    Connector.TYPE_JAGGED = 'jagged';
	
	    Connector.TYPE_CURVE = 'curve';
	
	    Connector.RADIUS = 3;
	
	    Connector.START_NODE = "startNode";
	
	    Connector.END_NODE = "endNode";
	
	    Connector.LEFT = "left";
	
	    Connector.RIGHT = "right";
	
	    Connector.TOP = "top";
	
	    Connector.BOTTOM = "bottom";
	
	    Connector.BOTTOM = "bottom";
	
	    Connector.SEPERATOR = "-";
	    /**
	     * 重新画线，如果传空则根据turningPoints 重新画线
	     * @param  {[type]} points [description]
	     * @return {[type]}        [description]
	     */
	    Connector.prototype.refresh = function(points) {
	        if(points) {
	            this.turningPoints = points;
	        }
	        //将[x:0,y:0]转化为[0, 0]  给zrender使用
	        var points = Util.traslatePoints(this.turningPoints);
	
	        if((this.options.style.lineType == Connector.TYPE_CURVE) && (points.length > 2)) {
	            this.modifyCurve(this.turningPoints);
	        } else {
	            this.line.attr('shape', {points: points});
	        }
	
	        var lineText = this.childOfName('lineText');
	        //开始没有创建文本，后来传进来text了，需要先创建文本
	        if (!lineText  && this.options.text.text) {
	            var text = this.drawText("lineText", this.options.text.text,0, 0);
	            this.add(text.text);
	            lineText = this.childOfName('lineText');
	        }
	        if (lineText) {
	            lineText.setStyle("text", this.options.text.text);
	
	            var textPoint = this.getTextPostion(this.options.text);
	
	            // if (this.options.style.lineType == Connector.TYPE_STRAIGHT ) {
	            //     lineText.attr('rotation', this.getTextRotation(textPoint));
	            // }
	
	            lineText.attr("position", textPoint);
	        }
	        var symbolTo = this.childOfName('toSymbol');
	        if(symbolTo) {
	            if(this.options.effect&&this.options.effect.show){
	                new EffectLine(symbolTo,this.options,this.groupCurve,this.polyLine);
	            }else{
	                symbolTo.attr('position', points[points.length -1]);
	                symbolTo.attr('rotation', Util.tangentRotation(this.turningPoints[this.turningPoints.length-2], this.turningPoints[this.turningPoints.length-1]));
	            }
	        }
	   };
	    /**
	     * 渲染
	     * @return {[type]} [description]
	     */
	    Connector.prototype.render = function() {
	        var that = this;
	        //1.创建箭头
	        var symbolTo = this.createSymbol('toSymbol', this.options); //arrow,triangle
	        if (symbolTo) {
	            this.add(symbolTo);
	        }
	
	        //2.创建线
	        this.curveLine = new graphic.BezierCurve({
	            position: this.options.position,
	            style: this.options.style,
	            z: this.options.z
	        });
	        this.groupCurve.add(this.curveLine);
	        this.add(this.groupCurve);
	
	        this.polyLine = new graphic.Polyline({
	            position: this.options.position,
	            shape: this.options.shape,
	            style: this.options.style,
	            z: this.options.z
	        });
	        this.add(this.polyLine);
	
	        if((this.options.style.lineType == Connector.TYPE_CURVE)) {
	            this.line = this.groupCurve;
	            this.createHoverStyle(this.curveLine);
	            this.polyLine.hide();
	        }
	        else {
	            this.line = this.polyLine;
	            this.createHoverStyle(this.polyLine);
	            this.curveLine.hide();
	        }
	
	        //3.侦听线事件
	        var MOUSE_EVENT_NAMES = ['dblclick', 'click'];//'click', 'dblclick', 'mouseover', 'mouseout'
	        zrUtil.each(MOUSE_EVENT_NAMES, function (eveName) {
	            this.line.on(eveName, zrUtil.bind(function (e) {
	                e.cancelBubble = true;
	                var params = {};
	                params.event = e;
	                params.type = "Connector:" + eveName;
	                params.target = that;
	                this.trigger(params.type, params);
	                if(this.options.isEdit == false){return;}
	
	                if(this.options.isEdit && this.connectionPoints.length < 1 && this.turningPoints.length >=2) {
	                    this.createAllconnectionPoint()
	                }
	                if(this.handles.length < 1 ) {
	                    this.shapeSetHandle();
	                }
	            }, this));
	        }, this);
	
	        //3.创建调整线的连接点
	        if(this.options.isEdit) {
	            this.conPointsGroup = new graphic.Group();
	            this.add(this.conPointsGroup);
	        }
	
	        //4.创建线上文本
	        if (this.options.text.text && this.options.text.text != "") {
	            var text = this.drawText("lineText", this.options.text.text,0, 0);
	            this.add(text.text);
	        }
	
	
	    };
	
	    //设置style
	    Connector.prototype.setStyle = function(options) {
	        if(options.color){
	            if(this.options.style.lineType == Connector.TYPE_CURVE){
	                this.groupCurve.eachChild(function(curve) {
	                    curve.attr("style",{stroke:options.color});
	                    graphic.setNormalStyle(curve, {stroke:options.color});
	                });
	            }else{
	                this.polyLine.attr("style",{stroke:options.color});
	                graphic.setNormalStyle(this.polyLine, {stroke:options.color});
	            }
	            var symbolTo = this.childOfName('toSymbol');
	            if (symbolTo) {
	                symbolTo.attr("style",{fill:options.color});
	                graphic.setNormalStyle(symbolTo, {fill:options.color});
	            }
	            this.options.style.stroke = options.color;
	            this.model.set("options.style.stroke", options.color);
	            this.model.set("options.symbol.color", options.color);
	        }
	
	        if(options.text){
	             var lineText = this.childOfName('lineText');
	            //开始没有创建文本，后来传进来text了，需要先创建文本
	            if (!lineText  && options.text.text) {
	                var text = this.drawText("lineText", options.text.text,0, 0);
	                this.add(text.text);
	                lineText = this.childOfName('lineText');
	            }
	
	            if(options.text.text || options.text.text == ""){
	                lineText.setStyle("text", options.text.text);
	                this.options.text.text = options.text.text;
	            }
	            var textPoint = this.getTextPostion(options.text);
	            lineText.attr("position", textPoint);
	            if(options.text.textPos){
	                this.options.text.textPos = options.text.textPos;
	            }else{
	                this.options.text.textPos = 'center';
	            }
	            if(options.text.color){
	                lineText.attr("style",{
	                    fill: options.text.color
	                });
	                this.options.text.color = options.text.color;
	            }
	            this.model.set("options.text", options.text);
	        }
	
	    };
	
	    /**
	     * 获取线段的位置
	     * @param  {Object} text {text:'', color:'', textPos:''}
	     * @return {Object}      {x,y}
	     */
	    Connector.prototype.getTextPostion = function(text) {
	        var textPostion = [];
	        var textWidth = graphic.textContain.getWidth(text.text, text.textFont);
	        if(text&&text.textPos){
	            if(text.textPos == 'start'){
	                var xOffset = text.xOffset || 0;
	                textPostion = [this.turningPoints[0].x + xOffset,this.turningPoints[0].y];
	            }else if(text.textPos == 'end'){
	                if (this.options.style.lineType == Connector.TYPE_STRAIGHT ) {
	                    var points  = Util.getMaxLineLength(this.turningPoints);
	
	                    var angle = Util.getAngle(points[0],points[1]);
	                    var length =  Util.distance(points[0],points[1]) - textWidth;
	                    var newPoint = Util.getEndPoint(points[0], length, angle);
	                    textPostion = [newPoint.x,newPoint.y];
	                }else{
	                    textPostion = [this.turningPoints[this.turningPoints.length-1].x,this.turningPoints[this.turningPoints.length-1].y];
	                }
	            }else{
	                textPostion = this.middle(text);
	            }
	        }else{
	            var position = this.middle(text);
	            textPostion = [position[0]-textWidth/2,position[1]];
	        }
	
	        return textPostion;
	    };
	
	    /**
	     * 获取线段的旋转角度
	     * @param  {Object} textPostion {x,y}
	     * @return {Number}             角度值
	     */
	    Connector.prototype.getTextRotation = function(textPostion) {
	        //计算出极坐标的角度
	        var points  = Util.getMaxLineLength(this.turningPoints);
	        var angle = - Math.atan2(points[1].y - textPostion[1], points[1].x - textPostion[0]);  //,Math.PI/2
	        return angle;
	    };
	
	    Connector.prototype.createHoverStyle = function(el) {
	        if (this.options.hoverStyle) {
	            graphic.setElementHoverStl(el, this.options.hoverStyle);
	
	            var symbolTo = this.childOfName('toSymbol');
	            if(symbolTo){graphic.setElementHoverStl(symbolTo, this.options.arrowHoverStyle);}
	
	            el.on('mouseover', zrUtil.bind(function() {
	                graphic.doEnterHover(el);
	                if(symbolTo){graphic.doEnterHover(symbolTo);}
	
	                this.groupCurve.eachChild(function(line) {
	                    graphic.doEnterHover(line);
	                });
	            },this))
	              .on('mouseout', zrUtil.bind(function() {
	                graphic.doLeaveHover(el);
	                if(symbolTo){graphic.doLeaveHover(symbolTo);}
	                this.groupCurve.eachChild(function(line) {
	                    graphic.doLeaveHover(line);
	                });
	            },this));
	        }
	    };
	    /**
	     * 创建Node的连接点
	     * @private
	     *
	     * @return {[type]} [description]
	     */
	    Connector.prototype.createAllconnectionPoint = function() {
	        var sRect = this.startNode.getRect? this.startNode.getRect().boundingRect : Util.getRect(this.startNode).boundingRect;
	
	        var eRect = this.endNode.getRect? this.endNode.getRect().boundingRect : Util.getRect(this.endNode).boundingRect;
	
	        var sConnectorPoint = Util.getConnectorPoints(sRect);
	        var eConnectorPoint = Util.getConnectorPoints(eRect);
	
	        this.connectionPointCreate(this.startNode, sConnectorPoint.left, Connector.START_NODE + Connector.SEPERATOR + Connector.LEFT);
	        this.connectionPointCreate(this.startNode, sConnectorPoint.right, Connector.START_NODE + Connector.SEPERATOR + Connector.RIGHT);
	        this.connectionPointCreate(this.startNode, sConnectorPoint.top, Connector.START_NODE + Connector.SEPERATOR + Connector.TOP);
	        this.connectionPointCreate(this.startNode, sConnectorPoint.bottom, Connector.START_NODE + Connector.SEPERATOR + Connector.BOTTOM);
	
	        this.connectionPointCreate(this.endNode, eConnectorPoint.left, Connector.END_NODE + Connector.SEPERATOR + Connector.LEFT);
	        this.connectionPointCreate(this.endNode, eConnectorPoint.right, Connector.END_NODE + Connector.SEPERATOR + Connector.RIGHT);
	        this.connectionPointCreate(this.endNode, eConnectorPoint.top, Connector.END_NODE + Connector.SEPERATOR + Connector.TOP);
	        this.connectionPointCreate(this.endNode, eConnectorPoint.bottom, Connector.END_NODE + Connector.SEPERATOR + Connector.BOTTOM);
	
	
	        this.connectionPointCreate(this, this.turningPoints[0].clone(), ConnectionPoint.TYPE_CONNECTOR);
	
	        this.connectionPointCreate(this, this.turningPoints[this.turningPoints.length-1].clone(), ConnectionPoint.TYPE_CONNECTOR);
	    };
	
	    /**
	     * 创建连接点
	     * @private
	     * @param  {[type]} shape [description]
	     * @param  {[type]} point [description]
	     * @param  {[type]} type  [description]
	     * @return {[type]}       [description]
	     */
	    Connector.prototype.connectionPointCreate = function(shape, point, type) {
	        var conPoint = new ConnectionPoint(this, point, type, this.options);
	        this.conPointsGroup.add(conPoint.shape);
	    };
	
	    /**
	     * 清空控制点
	     * @return {[type]} [description]
	     */
	    Connector.prototype.clearHandles = function() {
	        for (var i = 0; i < this.handles.length; i++) {
	            this.remove(this.handles[i].handleShape);
	        }
	        this.handles = [];
	        if (this.conPointsGroup) {
	            this.conPointsGroup.removeAll();
	        }
	    };
	
	    /**
	     * 创建拆线 线断的控制点
	     * @return {[type]} [description]
	     */
	    Connector.prototype.shapeSetHandle = function() {
	        for(var i=1; i<this.turningPoints.length-2; i++){
	            var h;
	            var x, y;
	            //是否在一条线上
	            var isCollineaityFirst = Util.collinearity(this.turningPoints[i-1], this.turningPoints[i], this.turningPoints[i+1]);
	            var isCollineaitySecond = Util.collinearity(this.turningPoints[i], this.turningPoints[i+1], this.turningPoints[i+2]);
	            if( (!isCollineaityFirst && (!isCollineaitySecond || this.turningPoints[i+1].equals(this.turningPoints[i+2])))
	                || ( (!isCollineaityFirst || this.turningPoints[i-1].equals(this.turningPoints[i])) && !isCollineaitySecond )) {
	
	                if(this.turningPoints[i].x === this.turningPoints[i+1].x){ //same vertical
	                    x = this.turningPoints[i].x;
	                    y = (this.turningPoints[i].y + this.turningPoints[i+1].y) / 2;
	
	                    h = new Handle('h',x,y,this);
	
	
	                }
	                else if(this.turningPoints[i].y === this.turningPoints[i+1].y){ // same horizontal
	                    x = (this.turningPoints[i].x +  this.turningPoints[i+1].x) / 2;
	                    y = this.turningPoints[i].y;
	                    h =  new  Handle('v',x,y,this);
	                }
	                if (h) {
	                    this.add(h.handleShape);
	                    this.handles.push(h);
	                }
	
	            }
	        }
	    };
	
	
	    /**
	     * 创建箭头
	     * @param  {[type]} name       [description]
	     * @param  {[type]} options [description]
	     * @return {[type]}            [description]
	     */
	    Connector.prototype.createSymbol = function(name, options) {
	        var symbolType = options.symbol.type;
	        var symbolSize =this.options.symbol.size;
	        if (symbolType === 'none') {
	            return;
	        }
	
	        if (!zrUtil.isArray(symbolSize)) {
	            symbolSize = [symbolSize, symbolSize];
	        }
	        var symbolPath = symbolUtil.createSymbol(
	            symbolType, -symbolSize[0] / 2, -symbolSize[1] / 2,
	            symbolSize[0], symbolSize[1], this.options.symbol.color, this.options.z
	        );
	        symbolPath.name = name;
	
	        return symbolPath;
	    };
	
	    /**
	     * 绘制线段上的文本
	     * @param  {[type]} content [description]
	     * @param  {[type]} name [description]
	     * @param  {[type]} x       [description]
	     * @param  {[type]} y       [description]
	     * @param  {[type]} color   [description]
	     * @return {[type]}         [description]
	     */
	    Connector.prototype.drawText = function (name,content, x, y, color) {
	        var text = new graphic.Text({
	            style: {
	                text: content,
	                x: x,
	                y: y,
	                fill: color ? color : this.options.text.color,
	                textFont: this.options.text.textFont
	            },
	            zlevel: 20
	        });
	        text.name = name;
	        return {
	            text: text,
	            rect: text.getBoundingRect()
	        };
	    };
	
	    /**
	     * 获取线段的中间值
	     * @return {[type]} text
	     */
	    Connector.prototype.middle = function(text){
	
	        if(this.options.style.lineType == Connector.TYPE_STRAIGHT){
	            var points  = Util.getMaxLineLength(this.turningPoints);
	            //如果是求线段上的文字的中间值
	            // if(text) {
	            //     //取出字的长度，计算角度，
	            //     var textWidth = graphic.textContain.getWidth(text.text, text.textFont);
	            //     var angle = Util.getAngle(points[0],points[1]);
	            //     var length =  Util.distance(points[0],points[1])/2 - textWidth/2;
	            //     var newPoint = Util.getEndPoint(points[0], length, angle);
	            //     return [newPoint.x, newPoint.y];
	            // } else {
	            //     var middleX = (points[0].x + points[1].x)/2;
	            //     var middleY = (points[0].y + points[1].y) /2;
	            //     return [middleX, middleY];
	            // }
	            var middleX = (points[0].x + points[1].x)/2;
	            var middleY = (points[0].y + points[1].y) /2;
	            return [middleX, middleY];
	        }
	        else if(this.options.style.lineType == Connector.TYPE_JAGGED){
	
	            //find total distance
	            var distance = this.getLength();
	
	            //find between what turning points the half distance is
	            var index = -1;
	            var ellapsedDistance = 0;
	            for(var i=0; i<this.turningPoints.length-1; i++){
	                index = i;
	                var segment = Util.getLength(this.turningPoints[i], this.turningPoints[i+1]);
	                if(ellapsedDistance + segment < distance /2){
	                    ellapsedDistance += segment;
	                }
	                else{
	                    break;
	                }
	            }
	
	            //we have the middle distance somewhere between i(ndex) and i(ndex)+1
	            if(index != -1){
	                var missingDistance = distance / 2 - ellapsedDistance;
	                if( Util.round(this.turningPoints[index].x, 3) == Util.round(this.turningPoints[index + 1].x, 3) ){ //vertical segment (same x)
	                    return [this.turningPoints[index].x, Math.min(this.turningPoints[index].y, this.turningPoints[index + 1].y) + missingDistance];
	                } else if( Util.round(this.turningPoints[index].y, 3) == Util.round(this.turningPoints[index + 1].y, 3) ) { //horizontal segment (same y)
	                    return [Math.min(this.turningPoints[index].x, this.turningPoints[index + 1].x) + missingDistance, this.turningPoints[index].y];
	                } else{
	                    console.error("Connector:middle() - this should never happen " + this.turningPoints[index] + " " + this.turningPoints[index + 1]
	                        + " nr of points " + this.turningPoints.length
	                        );
	                }
	
	            }
	        }
	        else if(this.options.style.lineType == Connector.TYPE_CURVE){
	            var t = 0.5;
	            var l = this.getLength();
	
	            var walked = 0;
	            for(var j =0; j< this.turningPoints.length-1; j++){
	                if( walked + Util.distance(this.turningPoints[j], this.turningPoints[j+1]) > l * t ){
	                    break;
	                }
	
	                walked += Util.distance(this.turningPoints[j], this.turningPoints[j+1]);
	            }
	
	            var rest = l * t - walked;
	            var currentSegmentLength = Util.distance(this.turningPoints[j], this.turningPoints[j+1]);
	
	            //find the position/ration of the middle of Polyline on current segment
	            var segmentPercent = rest / currentSegmentLength;
	
	            var Xp = segmentPercent * (this.turningPoints[j+1].x - this.turningPoints[j].x) + this.turningPoints[j].x;
	            var Yp = segmentPercent * (this.turningPoints[j+1].y - this.turningPoints[j].y) + this.turningPoints[j].y;
	
	            return [Xp, Yp];
	
	        }
	
	        return null;
	    };
	
	    /**
	     * find total distance
	     * @return {Number} [description]
	     */
	    Connector.prototype.getLength = function() {
	            //find total distance
	        var distance = 0;
	        for(var i=0; i<this.turningPoints.length-1; i++){
	            distance += Util.getLength(this.turningPoints[i], this.turningPoints[i+1]);
	        }
	        return distance;
	    };
	
	    /**
	     * 转JSON对象
	     * @return {[type]} [description]
	     */
	    Connector.prototype.toJSON = function() {
	
	        this.model.set("resourceId", this.resourceId);
	        this.model.set("properties.type", 14);
	
	        this.model.set("bounds.upperLeft.x", this.position[0]);
	        this.model.set("bounds.upperLeft.y", this.position[1]);
	        this.model.set("bounds.lowerRight.x", this.position[0] + this.getBoundingRect().width);
	        this.model.set("bounds.lowerRight.y", this.position[1] + this.getBoundingRect().height);
	        this.model.set("style.sPos", this.sPos);
	        this.model.set("style.ePos", this.ePos);
	        this.model.set("dockers",this.turningPoints);
	        return this.model.option;
	    };
	
	     /**
	     * refreshModel
	     * @return {[type]} [description]
	     */
	    Connector.prototype.refreshModel = function() {
	        this.model.set("options.dockers",this.turningPoints);
	        var icons = [];
	        for(var i = 0;i < this.icons.length;i++){
	            var iconNode = this.icons[i];
	            var option = [iconNode.key,{
	                icon:iconNode.style.image,
	                width: iconNode.style.width,
	                height: iconNode.style.height
	            }];
	            icons.push(option);
	        }
	        this.model.set("icons",icons);
	    };
	
	    /**
	     * 调整曲线的形状
	     * @param  {array} points 点数组
	     * @return {void}
	     */
	    Connector.prototype.modifyCurve = function(points) {
	        var sol = this.getCurvePoint(points);
	
	        // 1. 如果曲线的数量 比数量的中数量要少 则删除多余的线段
	        var willDelCurves = [];
	        for (var j = sol.length, cntCurve = this.groupCurve.childCount(); j < cntCurve ; j++) {
	            willDelCurves.push(this.groupCurve.childAt(j));
	        }
	        zrUtil.each(willDelCurves, function(curve) {
	            this.groupCurve.remove(curve);
	        }, this);
	        // 2. 遍历曲线   如果存在则直接设置形状，否则创建
	        for (var i = 0; i < sol.length; i++) {
	            var line = this.groupCurve.childAt(i);
	            if (line) {
	                line.attr('shape', sol[i]);
	            } else {
	                var cure = new graphic.BezierCurve({
	                    position: this.options.position,
	                    style: this.options.style,
	                    shape: sol[i],
	                    z: this.options.z
	                });
	                this.groupCurve.add(cure);
	                this.createHoverStyle(cure);
	            }
	        }
	    };
	
	
	    /**
	     * 根据传入的点数组计算曲线的点
	     * @param  {array} P 点数组
	     * @return {object}        曲线的点数组
	     */
	    Connector.prototype.getCurvePoint = function(P) {
	        var n = P.length;
	        var sol = [];
	        if (n === 3) {
	            sol.push({x1: P[0].x,
	                   y1: P[0].y,
	                   cpx1: P[1].x,
	                   cpy1: P[1].y,
	                   x2: P[2].x,
	                   y2: P[2].y
	                });
	            return sol;
	        }
	        else if (n === 4) {
	            sol.push({x1: P[0].x,
	                   y1: P[0].y,
	                   cpx1: P[1].x,
	                   cpy1: P[1].y,
	                   cpx2: P[2].x,
	                   cpy2: P[2].y,
	                   x2: P[3].x,
	                   y2: P[3].y
	                });
	            return sol;
	        }
	
	        /**Computes factorial
	         * @param {Number} k the number
	         * */
	        function fact(k){
	            if(k===0 || k===1){
	                return 1;
	            }
	            else{
	                return k * fact(k-1);
	            }
	        }
	
	        /**Computes Bernstain*/
	        function B(i,n,u){
	            return fact(n) / (fact(i) * fact(n-i))* Math.pow(u, i) * Math.pow(1-u, n-i);
	        }
	
	        /**Computes the sum between two point
	         *@param p1 - {Point}
	         *@param p2 - {Point}
	         *@return {Point} the sum of initial points
	         **/
	        function sum(p1, p2){
	            return new Point(p1.x + p2.x, p1.y + p2.y);
	        }
	
	        /**Computes the difference between first {Point} and second {Point}
	         *@param p1 - {Point}
	         *@param p2 - {Point}
	         *@return {Point} the sum of initial points
	         **/
	        function minus(p1, p2){
	            return new Point(p1.x - p2.x, p1.y - p2.y);
	        }
	
	        /**Computes the division of a {Point} by a number
	         *@param p - {Point}
	         *@param nr - {Number}
	         *@return {Point}
	         **/
	        function divide(p, nr){
	            if(nr == 0){
	                throw "Division by zero not allowed (yet :) " + this.callee ;
	            }
	            return new Point(p.x/nr, p.y/nr);
	        }
	
	        /**Computes the multiplication of a {Point} by a number
	         *@param p - {Point}
	         *@param nr - {Number}
	         *@return {Point}
	         **/
	        function multiply(p, nr){
	            return new Point (p.x * nr, p.y * nr);
	        }
	
	
	
	
	        /*
	         *I do not get why first 4 must be 0 and last 3 of same value.....
	         *but otherwise we will get division by zero
	         */
	        var k = [0,0,0];
	
	        var j;
	        for(j=0;j<=n-3;j++){
	            k.push(j);
	        }
	
	        k.push(n-3, n-3);
	
	
	
	        for(i=1; i<=n-3; i++){
	            //q1 - compute start point
	            var q1 = divide( sum( multiply(P[i], k[i+4] - k[i+2]), multiply(P[i+1], k[i+2] - k[i+1]) ), k[i+4] - k[i+1]);
	
	            //q0 - compute 1st controll point
	            var q_01 = (k[i+3] - k[i+2]) / (k[i+3] - k[i+1]);
	            var q_02 = divide( sum( multiply(P[i-1],k[i+3] - k[i+2]), multiply(P[i], k[i+2] - k[i])), k[i+3] - k[i]);
	            var q_03 = multiply(q1, ( k[i+2] - k[i+1])/ (k[i+3] - k[i+1]) );
	            var q0 = sum(multiply(q_02, q_01), q_03);
	
	            //q2 - compute 2nd controll point
	            var q2 = divide( sum( multiply(P[i], k[i+4] - k[i+3]), multiply(P[i+1], k[i+3] - k[i+1]) ), k[i+4] - k[i+1] );
	
	            //q3 - compute end point
	            var q_31 = (k[i+3] - k[i+2]) / (k[i+4] - k[i+2]);
	            var q_32 = divide( sum( multiply(P[i+1], k[i+5] - k[i+3]), multiply(P[i+2], k[i+3] - k[i+2]) ) , k[i+5] - k[i+2]);
	            var q_33 = multiply(q2, (k[i+4] - k[i+3])/(k[i+4] - k[i+2]) );
	            var q3 = sum(multiply(q_32, q_31), q_33);
	
	            //store solution
	            //
	            sol.push({x1: q0.x,
	                   y1: q0.y,
	                   cpx1: q1.x,
	                   cpy1: q1.y,
	                   cpx2: q2.x,
	                   cpy2: q2.y,
	                   x2: q3.x,
	                   y2: q3.y
	                });
	        }
	
	        return sol;
	    };
	
	
	    Util.inherits(Connector,Node);
	
	    module.exports = Connector;
	
	


/***/ },
/* 78 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// Symbol factory
	
	
	    var graphic = __webpack_require__(3);
	    var BoundingRect = __webpack_require__(24);
	    /**
	     * Triangle shape
	     * @inner
	     */
	    var Triangle = graphic.extendShape({
	        type: 'triangle',
	        shape: {
	            cx: 0,
	            cy: 0,
	            width: 0,
	            height: 0
	        },
	        buildPath: function (path, shape) {
	            var cx = shape.cx;
	            var cy = shape.cy;
	            var width = shape.width / 2;
	            var height = shape.height / 2;
	            path.moveTo(cx, cy - height);
	            path.lineTo(cx + width, cy + height);
	            path.lineTo(cx - width, cy + height);
	            path.closePath();
	        }
	    });
	    /**
	     * Diamond shape
	     * @inner
	     */
	    var Diamond = graphic.extendShape({
	        type: 'diamond',
	        shape: {
	            cx: 0,
	            cy: 0,
	            width: 0,
	            height: 0
	        },
	        buildPath: function (path, shape) {
	            var cx = shape.cx;
	            var cy = shape.cy;
	            var width = shape.width / 2;
	            var height = shape.height / 2;
	            path.moveTo(cx, cy - height);
	            path.lineTo(cx + width, cy);
	            path.lineTo(cx, cy + height);
	            path.lineTo(cx - width, cy);
	            path.closePath();
	        }
	    });
	
	    /**
	     * Pin shape
	     * @inner
	     */
	    var Pin = graphic.extendShape({
	        type: 'pin',
	        shape: {
	            // x, y on the cusp
	            x: 0,
	            y: 0,
	            width: 0,
	            height: 0
	        },
	
	        buildPath: function (path, shape) {
	            var x = shape.x;
	            var y = shape.y;
	            var w = shape.width / 5 * 3;
	            // Height must be larger than width
	            var h = Math.max(w, shape.height);
	            var r = w / 2;
	
	            // Dist on y with tangent point and circle center
	            var dy = r * r / (h - r);
	            var cy = y - h + r + dy;
	            var angle = Math.asin(dy / r);
	            // Dist on x with tangent point and circle center
	            var dx = Math.cos(angle) * r;
	
	            var tanX = Math.sin(angle);
	            var tanY = Math.cos(angle);
	
	            path.arc(
	                x, cy, r,
	                Math.PI - angle,
	                Math.PI * 2 + angle
	            );
	
	            var cpLen = r * 0.6;
	            var cpLen2 = r * 0.7;
	            path.bezierCurveTo(
	                x + dx - tanX * cpLen, cy + dy + tanY * cpLen,
	                x, y - cpLen2,
	                x, y
	            );
	            path.bezierCurveTo(
	                x, y - cpLen2,
	                x - dx + tanX * cpLen, cy + dy + tanY * cpLen,
	                x - dx, cy + dy
	            );
	            path.closePath();
	        }
	    });
	
	    /**
	     * Arrow shape
	     * @inner
	     */
	    var Arrow = graphic.extendShape({
	
	        type: 'arrow',
	
	        shape: {
	            x: 0,
	            y: 0,
	            width: 0,
	            height: 0
	        },
	
	        buildPath: function (ctx, shape) {
	            var height = shape.height;
	            var width = shape.width;
	            var x = shape.x;
	            var y = shape.y;
	            var dx = width / 3 * 2;
	            ctx.moveTo(x, y);
	            ctx.lineTo(x + dx, y + height);
	            ctx.lineTo(x, y + height / 4 * 3);
	            ctx.lineTo(x - dx, y + height);
	            ctx.lineTo(x, y);
	            ctx.closePath();
	        }
	    });
	
	    /**
	     * Map of path contructors
	     * @type {Object.<string, module:zrender/graphic/Path>}
	     */
	    var symbolCtors = {
	        line: graphic.Line,
	
	        rect: graphic.Rect,
	
	        roundRect: graphic.Rect,
	
	        square: graphic.Rect,
	
	        circle: graphic.Circle,
	
	        diamond: Diamond,
	
	        pin: Pin,
	
	        arrow: Arrow,
	
	        triangle: Triangle
	    };
	
	    var symbolShapeMakers = {
	
	        line: function (x, y, w, h, shape) {
	            // FIXME
	            shape.x1 = x;
	            shape.y1 = y + h / 2;
	            shape.x2 = x + w;
	            shape.y2 = y + h / 2;
	        },
	
	        rect: function (x, y, w, h, shape) {
	            shape.x = x;
	            shape.y = y;
	            shape.width = w;
	            shape.height = h;
	        },
	
	        roundRect: function (x, y, w, h, shape) {
	            shape.x = x;
	            shape.y = y;
	            shape.width = w;
	            shape.height = h;
	            shape.r = Math.min(w, h) / 4;
	        },
	
	        square: function (x, y, w, h, shape) {
	            var size = Math.min(w, h);
	            shape.x = x;
	            shape.y = y;
	            shape.width = size;
	            shape.height = size;
	        },
	
	        circle: function (x, y, w, h, shape) {
	            // Put circle in the center of square
	            shape.cx = x + w / 2;
	            shape.cy = y + h / 2;
	            shape.r = Math.min(w, h) / 2;
	        },
	
	        diamond: function (x, y, w, h, shape) {
	            shape.cx = x + w / 2;
	            shape.cy = y + h / 2;
	            shape.width = w;
	            shape.height = h;
	        },
	
	        pin: function (x, y, w, h, shape) {
	            shape.x = x + w / 2;
	            shape.y = y + h / 2;
	            shape.width = w;
	            shape.height = h;
	        },
	
	        arrow: function (x, y, w, h, shape) {
	            shape.x = x + w / 2;
	            shape.y = y + h / 2;
	            shape.width = w;
	            shape.height = h;
	        },
	
	        triangle: function (x, y, w, h, shape) {
	            shape.cx = x + w / 2;
	            shape.cy = y + h / 2;
	            shape.width = w;
	            shape.height = h;
	        }
	    };
	
	    var symbolBuildProxies = {};
	    for (var name in symbolCtors) {
	        symbolBuildProxies[name] = new symbolCtors[name]();
	    }
	
	    var Symbol = graphic.extendShape({
	
	        type: 'symbol',
	
	        shape: {
	            symbolType: '',
	            x: 0,
	            y: 0,
	            width: 0,
	            height: 0
	        },
	
	        beforeBrush: function () {
	            var style = this.style;
	            var shape = this.shape;
	            // FIXME
	            if (shape.symbolType === 'pin' && style.textPosition === 'inside') {
	                style.textPosition = ['50%', '40%'];
	                style.textAlign = 'center';
	                style.textVerticalAlign = 'middle';
	            }
	        },
	
	        buildPath: function (ctx, shape) {
	            var symbolType = shape.symbolType;
	            var proxySymbol = symbolBuildProxies[symbolType];
	            if (shape.symbolType !== 'none') {
	                if (!proxySymbol) {
	                    // Default rect
	                    symbolType = 'rect';
	                    proxySymbol = symbolBuildProxies[symbolType];
	                }
	                symbolShapeMakers[symbolType](
	                    shape.x, shape.y, shape.width, shape.height, proxySymbol.shape
	                );
	                proxySymbol.buildPath(ctx, proxySymbol.shape);
	            }
	        }
	    });
	
	    // Provide setColor helper method to avoid determine if set the fill or stroke outside
	    var symbolPathSetColor = function (color) {
	        if (this.type !== 'image') {
	            var symbolStyle = this.style;
	            var symbolShape = this.shape;
	            if (symbolShape && symbolShape.symbolType === 'line') {
	                symbolStyle.stroke = color;
	            }
	            else if (this.__isEmptyBrush) {
	                symbolStyle.stroke = color;
	                symbolStyle.fill = '#fff';
	            }
	            else {
	                // FIXME 判断图形默认是填充还是描边，使用 onlyStroke ?
	                symbolStyle.fill && (symbolStyle.fill = color);
	                symbolStyle.stroke && (symbolStyle.stroke = color);
	            }
	            this.dirty();
	        }
	    };
	
	    var symbolUtil = {
	        /**
	         * Create a symbol element with given symbol configuration: shape, x, y, width, height, color
	         * @param {string} symbolType
	         * @param {number} x
	         * @param {number} y
	         * @param {number} w
	         * @param {number} h
	         * @param {number} z
	         * @param {string} color
	         */
	        createSymbol: function (symbolType, x, y, w, h, color, z) {
	            var isEmpty = symbolType.indexOf('empty') === 0;
	            if (isEmpty) {
	                symbolType = symbolType.substr(5, 1).toLowerCase() + symbolType.substr(6);
	            }
	            var symbolPath;
	
	            if (symbolType.indexOf('image://') === 0) {
	                symbolPath = new graphic.Image({
	                    style: {
	                        image: symbolType.slice(8),
	                        x: x,
	                        y: y,
	                        width: w,
	                        height: h
	                    },
	                    z: z
	                });
	            }
	            else if (symbolType.indexOf('path://') === 0) {
	                symbolPath = graphic.makePath(symbolType.slice(7), {z: z}, new BoundingRect(x, y, w, h));
	            }
	            else {
	                symbolPath = new Symbol({
	                    shape: {
	                        symbolType: symbolType,
	                        x: x,
	                        y: y,
	                        width: w,
	                        height: h
	                    },
	                    z: z
	                });
	            }
	
	            symbolPath.__isEmptyBrush = isEmpty;
	
	            symbolPath.setColor = symbolPathSetColor;
	
	            symbolPath.setColor(color);
	
	            return symbolPath;
	        }
	    };
	
	    module.exports = symbolUtil;
	


/***/ },
/* 79 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * 画句柄
	 * @author wang.xiaohu
	 */
	
	    var graphic = __webpack_require__(3);
	    var Util = __webpack_require__(59);
	    function Handle(type, x, y, connector){
	        this.type = type;
	
	        this.x = x;
	
	        this.y = y;
	
	        this.visible = true;
	
	        this.connector = connector;
	
	        this.handleShape = new graphic.Circle({
	            shape: {
	                cx: x,
	                cy: y,
	                r: Handle.RADIUS
	            },
	
	            style: {
	                fill: "rgb(0,255,0)",
	                stroke:"rgb(0,0,0)"
	            },
	            z : connector.options.z + 2,  //节点Z为1 线段为0;
	            draggable:true
	        });
	
	        var that = this;
	        this.handleShape.on("drag", function(e) {
	            that.actionConnector(e.offsetX,e.offsetY);
	        });
	       // return this.circle;
	    }
	
	    Handle.RADIUS = 4;
	
	    Handle.prototype = {
	
	        constructor : Handle,
	
	        equals : function(anotherHandle){
	            if(!anotherHandle instanceof Handle){
	                return false;
	            }
	
	            return this.type == anotherHandle.type
	            && this.x == anotherHandle.x
	            && this.y == anotherHandle.y
	            && this.visible == anotherHandle.visible;
	        },
	
	        /**
	         * 移动句柄
	         * @param  {[type]} newX [description]
	         * @param  {[type]} newY [description]
	         * @return {[type]}      [description]
	         */
	        actionConnector: function(newX, newY){
	            switch(this.type){
	                case 'v':
	                    var index;
	                    // 找出两个转折点（可移动句柄在这两个转折点中间）
	                    for(var i = 1; i < this.connector.turningPoints.length-1; i++){
	                        if(this.connector.turningPoints[i-1].y == this.connector.turningPoints[i].y
	                            && this.connector.turningPoints[i].y == this.y
	                            && Math.min(this.connector.turningPoints[i].x, this.connector.turningPoints[i-1].x) <= this.x
	                            && Math.max(this.connector.turningPoints[i].x, this.connector.turningPoints[i-1].x) >= this.x)
	                        {
	                            index = i;
	                        }
	                    }
	                    var deltaY = newY - this.y;
	                    var translationMatrix = Util.translationMatrix(0, deltaY);
	
	                    this.connector.turningPoints[index-1].transform(translationMatrix);
	                    this.connector.turningPoints[index].transform(translationMatrix);
	                    this.connector.refresh();
	                    this.y = newY;  //将句柄新的位置赋值给y
	
	                    break;
	
	                case 'h':
	                    var index;
	                    // 找出两个转折点（可移动句柄在这两个转折点中间）
	                    for(var i = 1; i < this.connector.turningPoints.length-1; i++){
	                        if(this.connector.turningPoints[i-1].x == this.connector.turningPoints[i].x
	                            && this.connector.turningPoints[i].x == this.x
	                            && Math.min(this.connector.turningPoints[i].y, this.connector.turningPoints[i-1].y) <= this.y
	                            && Math.max(this.connector.turningPoints[i].y, this.connector.turningPoints[i-1].y) >= this.y)
	                            {
	                            index = i;
	                        }
	                    }
	                    var deltaX = newX-this.x;
	                    var translationMatrix = Util.translationMatrix(deltaX, 0);
	                    this.connector.turningPoints[index-1].transform(translationMatrix);
	                    this.connector.turningPoints[index].transform(translationMatrix);
	                    this.connector.refresh();
	                    this.x = newX; //将句柄新的位置赋值给x
	
	                    break;
	            }
	           //. this.shape.updateMiddleText();
	        }
	    };
	    module.exports = Handle;
	
	
	


/***/ },
/* 80 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * 连线动态效果
	 * @author miao.cunzhi
	 */
	
	    var zrUtil = __webpack_require__(4);
	    var vec2 = __webpack_require__(14);
	    var curveUtil = __webpack_require__(26);
	    var symbolUtil = __webpack_require__(78);
	
	    function EffectLine(symbol, options, groupCurve, polyLine) {
	        this._lastFrame = 0;
	        this._lastFramePercent = 0;
	        this.symbol = symbol;
	        this.groupCurve = groupCurve;
	        this.initSymbol(options, polyLine);
	    }
	    var EffectLineProto = EffectLine.prototype;
	
	    EffectLineProto.initSymbol = function(options, polyLine) {
	        var that = this;
	        this.symbol.z2 = 100;
	        this.symbol.culling = true;
	        var period = options.effect.period * 1000;
	        this.symbol.__t = 0;
	        this.symbol.stopAnimation();
	        if ((options.style.lineType == "curve")) {
	            if (this.groupCurve) {
	                var i = 0;
	                period = period / this.groupCurve._children.length;
	                this.groupCurveAnimate(this.groupCurve._children[0], i, period);
	            }
	
	        } else {
	            this.symbol.animate('', true)
	                .when(period, {
	                    __t: 1
	                })
	                .delay(0)
	                .during(function() {
	                    that.updateSymbolPositionPolyline();
	                })
	                .start();
	            this.setAnimationPointsPolyline(polyLine.shape.points);
	        }
	
	    };
	
	    EffectLineProto.groupCurveAnimate = function(curveLine, i, period) {
	        var that = this;
	        if (curveLine == undefined) {
	            curveLine = this.groupCurve._children[0];
	            i = 0;
	        }
	        var points;
	        var pos = curveLine.shape;
	        points = [
	            [pos.x1, pos.y1],
	            [pos.x2, pos.y2],
	            [pos.cpx1, pos.cpy1],
	            [pos.cpx2, pos.cpy2]
	        ];
	        this.setAnimationPointsBezierCurve(points);
	        this.symbol.animate('')
	            .when(period, {
	                __t: 1
	            })
	            .delay(0)
	            .during(function() {
	                that.updateSymbolPositionBezierCurve();
	            })
	            .done(function() {
	                that.symbol.__t = 0;
	                that.groupCurveAnimate(that.groupCurve._children[i + 1], i + 1, period);
	            })
	            .start();
	
	    };
	
	
	    EffectLineProto.setAnimationPointsBezierCurve = function(points) {
	        this.symbol.__p1 = points[0];
	        this.symbol.__p2 = points[1];
	        this.symbol.__cp1 = points[2] || [
	            (points[0][0] + points[1][0]) / 2,
	            (points[0][1] + points[1][1]) / 2
	        ];
	        this.symbol.__cp2 = points[3];
	    };
	
	    EffectLineProto.updateSymbolPositionBezierCurve = function() {
	        var p1 = this.symbol.__p1;
	        var p2 = this.symbol.__p2;
	        var cp1 = this.symbol.__cp1;
	        var cp2 = this.symbol.__cp2;
	        var t = this.symbol.__t;
	        var pos = this.symbol.position;
	        var tx, ty;
	        if (cp2[0] != undefined) {
	            var cubicAt = curveUtil.cubicAt;
	            var cubicDerivativeAt = curveUtil.cubicDerivativeAt;
	            pos[0] = cubicAt(p1[0], cp1[0], cp2[0], p2[0], t);
	            pos[1] = cubicAt(p1[1], cp1[1], cp2[1], p2[1], t);
	            // Tangent
	            tx = cubicDerivativeAt(p1[0], cp1[0], cp2[0], p2[0], t);
	            ty = cubicDerivativeAt(p1[1], cp1[1], cp2[1], p2[1], t);
	        } else {
	            var quadraticAt = curveUtil.quadraticAt;
	            var quadraticDerivativeAt = curveUtil.quadraticDerivativeAt;
	            pos[0] = quadraticAt(p1[0], cp1[0], p2[0], t);
	            pos[1] = quadraticAt(p1[1], cp1[1], p2[1], t);
	            // Tangent
	            tx = quadraticDerivativeAt(p1[0], cp1[0], p2[0], t);
	            ty = quadraticDerivativeAt(p1[1], cp1[1], p2[1], t);
	        }
	        this.symbol.rotation = -Math.atan2(ty, tx) - Math.PI / 2;
	
	        this.symbol.ignore = false;
	    };
	
	    EffectLineProto.setAnimationPointsPolyline = function(points) {
	        this._points = points;
	        var accLenArr = [0];
	        var len = 0;
	        for (var i = 1; i < points.length; i++) {
	            var p1 = points[i - 1];
	            var p2 = points[i];
	            len += vec2.dist(p1, p2);
	            accLenArr.push(len);
	        }
	        if (len === 0) {
	            return;
	        }
	
	        for (var j = 0; j < accLenArr.length; j++) {
	            accLenArr[j] /= len;
	        }
	        this._offsets = accLenArr;
	        this._length = len;
	        this.symbol._lastFrame = 0;
	        this.symbol.__lastFramePercent = 0;
	    };
	
	    EffectLineProto.updateSymbolPositionPolyline = function() {
	        var t = this.symbol.__t;
	        var points = this._points;
	        var offsets = this._offsets;
	        var len = points.length;
	
	        if (!offsets) {
	            // Has length 0
	            return;
	        }
	
	        var lastFrame = this._lastFrame;
	        var frame;
	
	        if (t < this._lastFramePercent) {
	            // Start from the next frame
	            // PENDING start from lastFrame ?
	            var start = Math.min(lastFrame + 1, len - 1);
	            for (frame = start; frame >= 0; frame--) {
	                if (offsets[frame] <= t) {
	                    break;
	                }
	            }
	            // PENDING really need to do this ?
	            frame = Math.min(frame, len - 2);
	        } else {
	            for (var frame = lastFrame; frame < len; frame++) {
	                if (offsets[frame] > t) {
	                    break;
	                }
	            }
	            frame = Math.min(frame - 1, len - 2);
	        }
	        vec2.lerp(
	            this.symbol.position, points[frame], points[frame + 1],
	            (t - offsets[frame]) / (offsets[frame + 1] - offsets[frame])
	        );
	
	        this._lastFrame = frame;
	        this._lastFramePercent = t;
	        var angle = -Math.atan2(points[frame + 1][1] - points[frame][1], points[frame + 1][0] - points[frame][0]);
	        this.symbol.rotation = angle - Math.PI / 2;
	        this.symbol.ignore = false;
	    };
	    module.exports = EffectLine;
	


/***/ },
/* 81 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * 控制点
	 * @author wang.xiaohu
	 */
	
	    var graphic = __webpack_require__(3);
	    var Util = __webpack_require__(59);
	    function ConnectionPoint(connector, point, type, options){
	        this.connector = connector;
	
	        this.point = point.clone();
	
	        this.type = type;
	
	        this.color = ConnectionPoint.NORMAL_COLOR;
	
	        this.oType = 'ConnectionPoint';
	
	        this.shape = new graphic.Circle({
	            shape: {
	                cx: this.point.x,
	                cy: this.point.y,
	                r: ConnectionPoint.RADIUS
	            },
	
	            style: {
	                fill: this.color,
	                stroke:'#000000'
	            },
	            z : options.z + 2  //节点Z为1 线段为0;
	        });
	        this.shape.type =  this.type;
	
	        this.shape.connector = connector;
	        //return this.circle;
	    }
	
	    ConnectionPoint.NORMAL_COLOR = "#FFFF33"; //yellow.
	
	    ConnectionPoint.OVER_COLOR = "#FF9900"; //orange
	
	    ConnectionPoint.CONNECTED_COLOR = "#ff0000"; //red
	
	    ConnectionPoint.RADIUS = 4;
	
	    ConnectionPoint.TYPE_FIGURE = 'figure';
	
	    ConnectionPoint.TYPE_CONNECTOR = 'connector';
	
	    ConnectionPoint.prototype = {
	
	        constructor : ConnectionPoint,
	
	        equals : function(anotherConnectionPoint){
	            return this.point.equals(anotherConnectionPoint.point)
	            && this.connector == anotherConnectionPoint.connector
	            && this.type == anotherConnectionPoint.type
	            && this.color == anotherConnectionPoint.color
	            && this.radius == anotherConnectionPoint.radius;
	        }
	
	
	    };
	    module.exports = ConnectionPoint;
	
	
	


/***/ },
/* 82 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * 选中节点后，出现的操作框及按钮
	 * @author wang.xiaohu
	 */
	
	    var Node = __webpack_require__(76);
	    var zrUtil = __webpack_require__(4);
	    var graphic = __webpack_require__(3);
	    var Connector = __webpack_require__(77);
	    var env = __webpack_require__(64);
	
	    function OperationNode(node, zr, forbidEdit) {
	        Node.call(this);
	        this.node = node;
	        this.zr = zr;
	        this.forbidEdit = forbidEdit; //
	        this.render();
	    }
	
	    //事件
	    OperationNode.ARROW_DRAGEND = "OperationNode:dragendArrow";
	    OperationNode.ARROW_DRAG = "OperationNode:dragArrow";
	    OperationNode.ARROW_DRAGSTART = "OperationNode:dragstartArrow";
	    OperationNode.DELETE_CLICK = "OperationNode:deleteClick";
	
	    if(!env.canvasSupported) {
	        //内置操作图标的图像
	        OperationNode.opicons = {
	            STRAIGHT: 'M13.961,2.309c-0.051-0.122-0.148-0.22-0.27-0.27L13.5,2h-5C8.224,2,8,2.224,8,2.5S8.224,3,8.5,3h3.793L2.146,13.146c-0.195,0.195-0.195,0.512,0,0.707s0.512,0.195,0.707,0L13,3.707V7.5C13,7.776,13.225,8,13.5,8S14,7.776,14,7.5v-5L13.961,2.309z',
	            JAGGED: 'M96.046,13.604H84.213c-1.104,0-2,0.896-2,2v42.188H38.314v-10.77c0-0.715-0.381-1.375-1-1.732c-0.619-0.357-1.382-0.355-2,0L2.954,63.977c-0.619,0.357-1,1.018-1,1.732s0.381,1.375,1,1.732l32.36,18.687c0.309,0.179,0.655,0.268,1,0.268s0.69-0.089,1-0.268c0.619-0.357,1-1.018,1-1.732V73.625h57.732c1.104,0,2-0.896,2-2V15.604C98.046,14.5,97.151,13.604,96.046,13.604z',
	            CURVE: 'M510.536,268.098c13.541,0,27.078-5.207,37.347-15.6c20.379-20.625,20.18-53.866-0.445-74.245L414.167,46.57c-9.905-9.786-23.325-15.244-37.215-15.154c-13.923,0.083-27.244,5.695-37.03,15.599l-129.912,131.48c-20.379,20.625-20.18,53.866,0.445,74.245c20.625,20.379,53.866,20.18,74.245-0.445l40.618-41.108c0.021,0.464,0.029,0.927,0.062,1.394c4.178,59.008,4.668,119.832,16.633,177.931c23.937,116.232,103.705,191.961,191.489,264.024c47.292,38.823,79.66,94.122,98.601,151.673c9.765,29.669,14.714,77.115,17.215,107.157c2.261,27.161,25.08,47.978,52.333,47.709l1.061-0.01c30.228-0.298,53.81-26.211,51.306-56.336c-2.921-35.15-8.858-89.828-20.925-127.49c-16.283-50.821-40.016-99.463-74.766-140.245c-33.993-39.892-75.456-72.403-113.338-108.373c-47.091-44.713-84.977-95.161-98.006-159.719c-10.541-52.231-12.789-105.215-16.461-158.562l43.118,42.604C483.87,263.053,497.205,268.098,510.536,268.098z',
	            DEL: 'M73.641,45.957l-0.021,0.252c0,0.032,0.021,0.06,0.021,0.088c0,0.065-0.022,0.126-0.026,0.191l-2.685,54.878H70.91c-0.231,4.304-5.166,10.81-31.748,10.81c-26.58,0-31.509-6.506-31.746-10.81H7.41L4.731,46.488c-0.009-0.06-0.028-0.126-0.028-0.191c0-0.032,0.01-0.06,0.01-0.088l-0.01-0.252h0.028c0.099-0.466,0.364-0.919,0.784-1.353c3.439,3.477,17.191,4.051,33.646,4.051s30.221-0.574,33.642-4.051c0.426,0.434,0.711,0.887,0.784,1.353H73.641z M78.335,25.102v6.407c0,1.316-1.34,2.567-3.715,3.696c-6.266,2.936-19.777,4.975-35.459,4.975c-15.666,0-29.189-2.039-35.442-4.975C1.33,34.075,0,32.825,0,31.509v-6.407c0-3.374,8.681-6.286,21.359-7.724V3.929c0-2.16,1.768-3.929,3.93-3.929h26.314c2.164,0,3.938,1.773,3.938,3.938v13.296C68.98,18.606,78.333,21.611,78.335,25.102z M48.416,11.395c0-2.348-0.321-4.27-0.715-4.27c-0.393,0-2.641,0-4.979,0h-8.545c-2.352,0-4.592,0-4.989,0c-0.388,0-0.714,1.922-0.714,4.27v5.367l1.083-0.065c3.067-0.173,6.286-0.27,9.595-0.271c3.202,0,6.292,0.098,9.264,0.252V11.395z'
	        };
	    }else{
	        OperationNode.opicons = {
	            STRAIGHT: 'data:image/png;base64,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',
	            JAGGED: 'data:image/png;base64,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',
	            CURVE: 'data:image/png;base64,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',
	            DEL: 'M73.641,45.957l-0.021,0.252c0,0.032,0.021,0.06,0.021,0.088c0,0.065-0.022,0.126-0.026,0.191l-2.685,54.878H70.91c-0.231,4.304-5.166,10.81-31.748,10.81c-26.58,0-31.509-6.506-31.746-10.81H7.41L4.731,46.488c-0.009-0.06-0.028-0.126-0.028-0.191c0-0.032,0.01-0.06,0.01-0.088l-0.01-0.252h0.028c0.099-0.466,0.364-0.919,0.784-1.353c3.439,3.477,17.191,4.051,33.646,4.051s30.221-0.574,33.642-4.051c0.426,0.434,0.711,0.887,0.784,1.353H73.641z M78.335,25.102v6.407c0,1.316-1.34,2.567-3.715,3.696c-6.266,2.936-19.777,4.975-35.459,4.975c-15.666,0-29.189-2.039-35.442-4.975C1.33,34.075,0,32.825,0,31.509v-6.407c0-3.374,8.681-6.286,21.359-7.724V3.929c0-2.16,1.768-3.929,3.93-3.929h26.314c2.164,0,3.938,1.773,3.938,3.938v13.296C68.98,18.606,78.333,21.611,78.335,25.102z M48.416,11.395c0-2.348-0.321-4.27-0.715-4.27c-0.393,0-2.641,0-4.979,0h-8.545c-2.352,0-4.592,0-4.989,0c-0.388,0-0.714,1.922-0.714,4.27v5.367l1.083-0.065c3.067-0.173,6.286-0.27,9.595-0.271c3.202,0,6.292,0.098,9.264,0.252V11.395z'
	        };
	    }
	
	
	
	
	    OperationNode.prototype.render = function() {
	        this.renderBase();
	        if (!this.forbidEdit) {
	            this.renderOther();
	        }
	
	    };
	
	    OperationNode.prototype.renderBase = function() {
	        this.createOperation();
	    };
	
	    OperationNode.prototype.createOperation = function() {
	        var me = this;
	        this.virtualRect = new graphic.Polyline({ style: { lineDash: [2] } });
	        this.virtualRect.isSelfComputePos = true;  // 自己计算位置
	        this.add(this.virtualRect);
	
	
	
	        if (this.node.operationIcons) {
	            zrUtil.each(this.node.operationIcons, function(item) {
	                //检查是否是内置图标
	                var opIconInstance = null;
	                if (OperationNode.opicons[item.name + ""]) {
	
	                    if (this.forbidEdit) {
	                        return;
	                    }
	                    if (item.name == "DEL") {
	                        //垃圾桶
	                        var rect1 = { x: 0, y: 0, width: 10, height: 15 };
	                        opIconInstance = graphic.makePath(OperationNode.opicons[item.name + ""], { style: { fill: '#000000' } }, rect1);
	                        if(item.callback){
	                            opIconInstance.on("click", function(e) {
	                                e.data = item;
	                                e.node = me.node;  // 将所附的节点也传递出去
	                                if (item.callback) {
	                                    item.callback(e);
	                                }
	                            });
	                        }else{
	                            opIconInstance.on("click", function(e) {
	                                var params = {};
	                                params.event = e;
	                                params.target = this;
	                                params.type = OperationNode.DELETE_CLICK;
	                                me.trigger(params.type, params);
	                            });
	                        }
	
	
	                    } else {
	                        if(!env.canvasSupported){
	                            var rect = { x: 0, y: 0, width: 15, height: 15 };
	                            opIconInstance = graphic.makePath(OperationNode.opicons[item.name + ""], { style: { fill: '#000000' },draggable:true,z:19,lineType: Connector["TYPE_" + item.name] }, rect);
	                        }else{
	                            var imageUrl = document.createElement('img');
	                            imageUrl.src = OperationNode.opicons[item.name + ""];
	                            opIconInstance = new graphic.Image({
	                                style: {
	                                    image:imageUrl,
	                                    cursor: 'default',
	                                    width:15,
	                                    height:15
	                                },
	                                draggable: true,
	                                z: 19, //zIndex 置于最高
	                                lineType: Connector["TYPE_" + item.name] //区分不同的线段
	                            });
	                        }
	
	                        var MOUSE_EVENT_NAMES = ['dragstart', 'drag', 'dragend'];
	                        zrUtil.each(MOUSE_EVENT_NAMES, function(eveName) {
	                            opIconInstance.on(eveName, function(e) {
	                                var params = {};
	                                params.event = e;
	                                params.type = "OperationNode:" + eveName + "Arrow";
	                                me.trigger(params.type, params);
	                            });
	                        });
	                    }
	
	                } else {
	                    //用户自定义的图标放在这里，用户传进来的图标只能响应click事件，其它事件暂不支持
	                    opIconInstance = new graphic.Image({
	                        style: {
	                            image: item.iconPath,
	                            width: item.width || 15,
	                            height: item.height || 15
	                        },
	                        z: 19 //zIndex 置于最高
	                    });
	                    opIconInstance.on("click", function(e) {
	                        e.data = item;
	                        e.node = me.node;  // 将所附的节点也传递出去
	                        if (item.callback) {
	                            item.callback(e);
	                        }
	
	                        //todo 用户自定图标click事件是否要派发到外面
	                    });
	                }
	                opIconInstance.name = item.name;
	                me.add(opIconInstance);
	            });
	        }
	    };
	
	    OperationNode.prototype.refreshPostion = function(node,nodeRect) {
	        var me = this;
	        var i = 0;
	        var rbPoint = nodeRect.points[2]; //取右下角坐标
	        //1.定位虚框
	        this.virtualRect.setShape({ points: nodeRect.points });
	        //2.定位每个小图标
	        this.eachChild(function(nodeItem) {
	            if (!nodeItem.isSelfComputePos) {
	                // 8px是第一个操作按钮图标的距离 靠太近不好看    20px是每个图标的间隔  10px是图标向偏的距离
	                nodeItem.attr("position", [rbPoint[0] + 8 + (i++ * 20), rbPoint[1] - 10]);
	            }
	        });
	
	        this.refreshPositionOther(node,nodeRect);
	    };
	
	    OperationNode.prototype.renderOther = function() {
	        //留给扩展使用
	    };
	    OperationNode.prototype.refreshPositionOther = function(node,nodeRect) {
	        //留给扩展使用
	        //3.定位整个operationNode
	        if (node.parent && node.parent.isBg && node.parent.isBg == true) {
	            this.attr("position", [nodeRect.x, nodeRect.y])
	        } else {
	            this.attr("position", [nodeRect.x + node.parent.position[0]+node.shape.x, nodeRect.y + node.parent.position[1]+node.shape.y])
	        }
	    };
	    zrUtil.inherits(OperationNode, Node);
	    module.exports = OperationNode;
	


/***/ },
/* 83 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * flow连线管理类
	 * @author miao.cunzhi
	 */
	
		var zrUtil = __webpack_require__(4);
		var ConnectionManager = __webpack_require__(84);
		var Connector = __webpack_require__(77);
	    var Util = __webpack_require__(59);
	    var graphic = __webpack_require__(3);
	    var Point = __webpack_require__(60);
	    var Constants = __webpack_require__(86);
	    var Model = __webpack_require__(87);
	    var Log = __webpack_require__(85);
		var connectionManagerExtend = {
	        LineOperations:[],
	        bundleOffset: 30,
	        bundleGap: 20,
	        connectorMap: Util.StackedMap.createNew(),
	        /**
	         * 创建连线
	         * @param  {[type]} startNode [开始节点]
	         * @param  {[type]} endNode   [结束节点]
	         * @param  {[type]} options      [类型]
	         * @param {[type]} [api] [description]
	         * @return {[type]}           [返回连线]
	         */
	        connectorCreate:function(startNode,endNode,options, api){
	            var that = this;
	            var model = options.model;
	            //1.创建线段
	            var connector = new Connector(options);
	            connector.startNode = startNode;
	            connector.endNode = endNode;
	            if (options.pos) {
	                var pos = options.pos.split(",");
	                connector.sPos = pos[0];
	                connector.ePos = pos[1];
	            };
	            this.connectors.push(connector);
	
	            var key = this.getTwoNodeId(startNode,endNode);
	            this.connectorMap.add(key, connector);
	
	            if(connector.conPointsGroup) {
	                connector.conPointsGroup.on("click", function(e) {
	                    var arrSplit = e.target.type.split(Connector.SEPERATOR);
	                    var connector = e.target.connector;
	                    if (arrSplit[0] === Connector.START_NODE) {
	                        connector.sPos = arrSplit[1];
	                    } else if (arrSplit[0] === Connector.END_NODE){
	                        connector.ePos = arrSplit[1];
	                    };
	                    that.refreshConnector(connector,true);
	                    e.cancelBubble = true;
	                    var params = {};
	                    params.event = e;
	                    params.type = "conPointsGroup:click";
	                    params.lineNode = that.selConnector;
	                    api.trigger(params.type, params);
	                });
	            }
	
	
	            var MOUSE_EVENT_NAMES = [ 'click', 'dblclick'];
	            zrUtil.each(MOUSE_EVENT_NAMES, function (eveName) {
	                connector.on("Connector:" + eveName, function(e) {
	
	                    var selected = e.target;
	
	                    if ( that.selConnector !== selected) {
	                        that.selConnector &&  that.refreshConnector(that.selConnector);
	                        that.selConnector = selected;
	                    };
	                    e.cancelBubble = true;
	                    var params = {};
	                    params.event = e;
	                    params.type = eveName;
	                    params.target = that.selConnector;
	                    api.trigger(params.type, params);
	                });
	            });
	
	
	
	            //双击收紧为一条线
	            connector.line.on("dblclick", function(e) {
	                if(connector.options.isShrink == false){return;}
	                var con = this.parent;
	                var startNode = con.startNode;
	                var endNode = con.endNode;
	                //1.获取所有的线段
	                var key = that.getTwoNodeId(startNode,endNode);
	                var cons = that.connectorMap.get(key);
	                if (cons.length == 1) {return};
	                //2.判断线是否处于隐藏状态
	
	                //2.将除中间的一条线进行隐藏
	                var half = parseInt(cons.length / 2);
	                for (var i = 0; i < cons.length; i++) {
	                    if (i != (half )) {
	                        if (cons[i].ignore) {
	                            cons[i].show();
	                        } else {
	                         cons[i].hide();
	                        }
	                    };
	
	                };
	
	                      //  that.refreshConnector(this.parent,true);
	                //alert("abc");
	            });
	
	            this.bundleOffset = options.bundleOffset || this.bundleOffset;
	            this.bundleGap = options.bundleGap || this.bundleGap;
	            //2. 获取这个key对应的线段数组
	            var arrCons = this.connectorMap.get(key);
	            if (arrCons.length == 1) {
	                //两个节点只有一个连线的情况
	                //判断一下 model里有没有dockers，如果有则调用构造point数组  或者调用refreshConnector计算如何画线
	                var dockers = options.dockers;
	                if (dockers && dockers.length >= 2) {
	                    var points = Point.loadArray(dockers);
	                    connector.refresh(points);
	                } else {
	                    if(options.position&&options.position.points){
	                        var arrStartEndPoint = this.getStartEndPoint(connector);
	                        var points = options.position.points;
	                        points.unshift(arrStartEndPoint[0]);
	                        points.push(arrStartEndPoint[1]);
	                        connector.refresh(points);
	                    }else{
	                        this.refreshConnector(arrCons[0],true);
	                    }
	                  
	                }
	
	            }
	            else if (arrCons.length > 1) {
	                //两个节点有多个连线的情况
	                this.refreshCons(arrCons);
	            };
	
	            //3.设置模型
	            var model = new Model({});
	            model.set(Constants.ELEMENT_TYPE, Constants.CONNECTION);
	            model.set(Constants.START_ID, startNode.model.get(Constants.ID));
	            model.set(Constants.END_ID, endNode.model.get(Constants.ID));
	            model.set(Constants.OPTIONS, zrUtil.clone(options));
	            model.set(Constants.DOCKERS, connector.turningPoints);
	            model.set(Constants.STYLE_LINETYPE, options.style.lineType);
	            connector.model = model;
	            return connector;
	        },
	
	        getTwoNodeId: function(startNode,endNode) {
	            return startNode.id + "," + endNode.id;
	        },
	        //处理多条线段
	        refreshCons: function(arrCons) {
	            //如果是折线的话
	            if (arrCons[0].options.style.lineType == Connector.TYPE_JAGGED ) {
	                for (var i = 0; i < arrCons.length; i++) {
	                    this.refreshConnector(arrCons[i],true);
	                };
	            } else{
	                this.refreshConsStraight(arrCons);
	            };
	        },
	
	        //处理多条线段(直线)
	        refreshConsStraight: function(arrCons) {
	            var half = parseInt(arrCons.length / 2);
	            var arrConnectResult = []
	
	            var startNode = arrCons[0].startNode;
	            var endNode = arrCons[0].endNode;
	            var sRect = Util.getRect(startNode).boundingRect;
	            var eRect = Util.getRect(endNode).boundingRect;
	            var sConnectorPoint = Util.getConnectorPoints(sRect);
	            var eConnectorPoint = Util.getConnectorPoints(eRect);
	            //判断如果没有指定位置的话, 判断开始节点在结束结果左边则采用 right-left 否则采用left-right
	
	            if (!arrCons[0].sPos || !arrCons[0].ePos) {
	                if (sRect.x < eRect.x) {
	                    arrCons[0].sPos = "right";
	                    arrCons[0].ePos = "left";
	                } else {
	                    arrCons[0].sPos = "left";
	                    arrCons[0].ePos = "right";
	                }
	            }
	            var startPoint = sConnectorPoint[arrCons[0].sPos];
	            var endPoint = eConnectorPoint[arrCons[0].ePos];
	            var angle = Math.atan2(endPoint.y - startPoint.y , endPoint.x - startPoint.x);
	            for (var i = half; i >= 1; i--) {
	                var points = [];
	                points.push(startPoint);  //
	               // points.push(new Point(startPoint.x + bundleOffset , startPoint.y + i * bundleGap));
	               // points.push(new Point(endPoint.x - bundleOffset , startPoint.y + i * bundleGap)); //startPoint.x + bundleOffset
	                var secondPoint = startPoint.clone();
	
	                //secondPoint.x =  secondPoint.x + this.bundleOffset;
	                secondPoint.transform(Util.translationMatrix(0, this.bundleGap* i));
	                //secondPoint = this.boundOffsetXY(secondPoint, true);
	                //
	                //直角坐标 x, 和 y, 计算出极坐标
	
	
	                //从极坐标计算出直角坐标
	                secondPoint.x =  secondPoint.x + this.bundleOffset * Math.cos(angle);
	                secondPoint.y =  secondPoint.y + this.bundleOffset * Math.sin(angle);
	
	
	
	                //secondPoint.transform(Util.scaleMatrix(0.5));
	                points.push(secondPoint);
	
	                var thirdPoint = endPoint.clone();
	                //thirdPoint.x =  thirdPoint.x - this.bundleOffset;
	
	
	
	                thirdPoint.transform(Util.translationMatrix(0, this.bundleGap*i));
	                //thirdPoint = this.boundOffsetXY(thirdPoint, false);
	                //secondPoint.transform(Util.scaleMatrix(0.5));
	                //
	                //直角坐标 x, 和 y, 计算出极坐标
	
	                //从极坐标计算出直角坐标
	                thirdPoint.x =  thirdPoint.x - this.bundleOffset * Math.cos(angle);
	                thirdPoint.y =  thirdPoint.y - this.bundleOffset * Math.sin(angle);
	
	                points.push(thirdPoint);
	
	                points.push(endPoint);
	                arrConnectResult.push(points);
	            };
	
	            arrConnectResult.push([startPoint, endPoint]);
	
	            var upHalf =  Math.ceil(arrCons.length / 2);
	            for (var i = 1; i < upHalf; i++) {
	                var points = [];
	                points.push(startPoint);
	                var secondPoint = startPoint.clone();
	                //secondPoint.x =  secondPoint.x + this.bundleOffset;
	                secondPoint.transform(Util.translationMatrix(0, - this.bundleGap* i));
	                secondPoint.x =  secondPoint.x + this.bundleOffset * Math.cos(angle);
	                secondPoint.y =  secondPoint.y + this.bundleOffset * Math.sin(angle);
	                points.push(secondPoint);
	
	                var thirdPoint = endPoint.clone();
	                //thirdPoint.x =  thirdPoint.x - this.bundleOffset;
	                thirdPoint.transform(Util.translationMatrix(0, - this.bundleGap*i));
	                //从极坐标计算出直角坐标
	                thirdPoint.x =  thirdPoint.x - this.bundleOffset * Math.cos(angle);
	                thirdPoint.y =  thirdPoint.y - this.bundleOffset * Math.sin(angle);
	                //secondPoint.transform(Util.scaleMatrix(0.5));
	                points.push(thirdPoint);
	
	                points.push(endPoint);
	                arrConnectResult.push(points);
	           };
	
	
	           for (var i = 0; i < arrConnectResult.length; i++) {
	               arrCons[i].refresh(arrConnectResult[i]);
	           };
	
	        },
	        boundOffsetXY: function(point, isPositive) {
	            var resultPoint = point.clone();
	            //直角坐标 x, 和 y, 计算出极坐标
	            var angle = Math.atan2(resultPoint.y , resultPoint.x);
	            var r = Math.sqrt( Math.pow(resultPoint.x, 2) + Math.pow(resultPoint.y, 2));
	            if(isPositive) {
	                r = r + this.bundleOffset;
	            } else {
	                r = r - this.bundleOffset;
	            }
	
	
	            //从极坐标计算出直角坐标
	            resultPoint.x = r * Math.cos(angle);
	            resultPoint.y = r * Math.sin(angle);
	            return resultPoint;
	        },
	
	        /**
	         * 设置线段的模型数据  (类型 文字)
	         * @param {[type]} connector [description]
	         * @param {[type]} option    [description]
	         */
	        setModel: function(connector, option) {
	            var originLineType =  connector.model.get("style.lineType");
	            connector.model.mergeOption(option);
	            if (originLineType !== option.style.lineType) {
	                this.refreshConnector(connector, true);
	            };
	        },
	
	
	        /**
	         * 刷新连接线
	         * @param  {[type]} node [description]
	         * @return {[type]}      [description]
	         */
	        refreshLineByNode: function(node) {
	            // 判断这个节点是否有多条线段
	            var keys = this.connectorMap.keys();
	            for (var i = 0; i < keys.length; i++) {
	                var key = keys[i];
	                if (key.indexOf(node.id) != -1) {
	                    var arrCons = this.connectorMap.get(key);
	                    if (arrCons.length == 1 ) {
	                        //两个节点只有一个连线的情况
	                        this.refreshConnector(arrCons[0],true);
	                    }
	                    else if (arrCons.length > 1) {
	                        //两个节点有多个连线的情况
	                        this.refreshCons(arrCons);
	                    };
	                };
	            };
	        },
		}
	
		var FlowConnectionManager = zrUtil.extend(ConnectionManager, connectionManagerExtend)
		module.exports = FlowConnectionManager;
	


/***/ },
/* 84 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * 连线管理类
	 * @author wang.xiaohu
	 */
	
	    var Node = __webpack_require__(76);
	    var Util = __webpack_require__(59);
	    var graphic = __webpack_require__(3);
	    var Point = __webpack_require__(60);
	    var Connector = __webpack_require__(77);
	    var Log = __webpack_require__(85);
	    var zrUtil = __webpack_require__(4);
	    var ConnectionManager = {
	
	        CLOUD_RADIUS: 12,
	        CLOUD_LINEWIDTH: 3,
	        CLOUD_STROKE_STYLE: "rgba(255, 153, 0, 0.8)", //orange
	        stencilType : "SequenceFlow",
	        connectors: [],
	        selConnector: null,
	        tempConnector: null,
	
	
	
	        /**
	         * 设置线的不可编辑
	         * @param  {[type]} forbidEdit [description]
	         * @return {[type]}            [description]
	         */
	        connectorForbidEdit:function(forbidEdit){
	            var that = this;
	            for(var i = 0;i < this.connectors.length;i++){
	                this.connectors[i].options.isEdit = !forbidEdit;
	            }
	        },
	
	
	        /**
	         * 清空连接线
	         * @return {[type]} [description]
	         */
	        clearSelectCon: function() {
	            if (ConnectionManager.selConnector != null) {
	                this.refreshConnector(this.selConnector);
	            }
	        },
	        /**
	         * 删除连接线
	         * @return {[type]} [description]
	         */
	        deleteSelectCon:function(node,_zr){
	            var deleteLine= [];
	            for(var i = 0; i < this.connectors.length; i++){
	                if(this.connectors[i].startNode == node || this.connectors[i].endNode == node){
	                    //1.将线 所联的startNode的outgoing数据删除
	                    var startNodeOutgoing = this.connectors[i].startNode.model.get("outgoing");
	                    index = zrUtil.indexOf(startNodeOutgoing, this.connectors[i].resourceId);
	                    if(index != -1) {
	                        startNodeOutgoing.splice(index,1);
	                    }
	                    //2.从_zr上删除
	                    _zr.remove(this.connectors[i]);
	                    this.connectors.splice(i, 1);
	                    i--;
	                    this.selConnector = null;
	
	                }
	            }
	        },
	        /**
	         * 删除选定的线
	         * @return {[type]} [description]
	         */
	        deleteLine:function(_zr){
	            //1.将线 所联的startNode的outgoing数据删除
	            var startNodeOutgoing = this.selConnector.startNode.model.get("outgoing");
	            index = zrUtil.indexOf(startNodeOutgoing, this.selConnector.resourceId);
	            if(index != -1) {
	                startNodeOutgoing.splice(index,1);
	            }
	
	            if (this.connectorMap) {
	                var key = this.getTwoNodeId(this.selConnector.startNode, this.selConnector.endNode);
	                this.connectorMap.removeItem(key, this.selConnector);
	            }
	
	            //2.从_zr上删除
	            _zr.remove(this.selConnector);
	
	
	            //3.从线数据中删除
	            var index = zrUtil.indexOf(this.connectors, this.selConnector);
	            if(index != -1) {
	                this.connectors.splice(index,1);
	            }
	            this.selConnector = null;
	        },
	        /**
	         * 重新画线
	         * @param  {[type]} connector          [description]
	         * @param  {[type]} force
	         * @return {[type]}                    [description]
	         */
	        refreshConnector: function (connector, force) {
	            // 只有需要强制刷新  或者 连线为空（<2)时 才进行重新计算重绘
	            if( force || (!connector.turningPoints) || (connector.turningPoints.length < 2))
	            {
	                if (connector.model && connector.model.get("style.lineType")) { connector.options.style.lineType = connector.model.get("style.lineType");}
	                var arrStartEndPoint = this.getStartEndPoint(connector);
	                var escapeDistance = null;
	                if(connector.options.position&&connector.options.position.escapeDistance){
	                    escapeDistance = connector.options.position.escapeDistance;
	                }
	                var solutions = this.connector2Points(connector.options.style.lineType, arrStartEndPoint[0], arrStartEndPoint[1],
	                    arrStartEndPoint[2], arrStartEndPoint[3],escapeDistance);  // TYPE_STRAIGHT TYPE_JAGGED
	
	
	                connector.refresh(solutions[0][2]);
	            }
	
	            connector.clearHandles();  //清空handle
	        },
	
	
	        getStartEndPoint: function(connector) {
	            var startNode = connector.startNode;
	            var endNode = connector.endNode;
	
	            var sRect = startNode.getRect? startNode.getRect().boundingRect : Util.getRect(startNode).boundingRect;
	            var sBounds = [Number(sRect.x), Number(sRect.y), Number(sRect.x) + Number(sRect.width), Number(sRect.y) + Number(sRect.height)];
	
	            var eRect = startNode.getRect? endNode.getRect().boundingRect : Util.getRect(endNode).boundingRect;
	            var eBounds = [Number(eRect.x), Number(eRect.y), Number(eRect.x) + Number(eRect.width), Number(eRect.y) + Number(eRect.height)];
	
	
	            var sConnectorPoint = Util.getConnectorPoints(sRect);
	            var eConnectorPoint = Util.getConnectorPoints(eRect);
	
	            //判断如果没有指定位置的话, 判断开始节点在结束结果左边则采用 right-left 否则采用left-right
	            if (!connector.sPos || !connector.ePos) {
	                if (sRect.x < eRect.x) {
	                    connector.sPos = "right";
	                    connector.ePos = "left";
	                } else {
	                    connector.sPos = "left";
	                    connector.ePos = "right";
	                }
	            }
	            var startPoint =  this.calcPointExpression(connector.sPos, sConnectorPoint);
	            var endPoint =  this.calcPointExpression(connector.ePos, eConnectorPoint);
	            return [startPoint, endPoint,sBounds, eBounds];
	        },
	
	        calcPointExpression: function(pos, point) {
	            var variable = {top:point.top.x,
	                left: point.left.y,
	                right:point.right.y,
	                bottom:point.bottom.x,
	                center:point.center.x
	            };
	
	            var expression =  "<% print(" + pos + ") %>";
	            var val = parseInt(Util.template(expression)(variable));
	            if (pos.indexOf("top")!= -1) {
	                return new Point(val, point.top.y);
	            } else if (pos.indexOf("left")!= -1) {
	                return new Point(point.left.x, val);
	            } else if (pos.indexOf("right")!= -1) {
	                return new Point(point.right.x, val);
	            } else if (pos.indexOf("bottom")!= -1) {
	                return new Point(val, point.bottom.y);
	            } else if (pos.indexOf("center")!= -1) {
	                return new Point(val, point.bottom.y);
	            }else {
	                throw new Error("pos参数错误");
	            }
	        },
	
	        /**
	         * 创建或修改临时线
	         * @param  {[type]} startNode             [description]
	         * @param  {[type]} rEndPoint             [description]
	         * @param  {[type]} lineType [description]
	         * @return {[type]}                       [description]
	         */
	        manageTempConnector: function(startNode, rEndPoint, lineType) {
	
	            var sRect = startNode.getRect? startNode.getRect().boundingRect : Util.getRect(startNode).boundingRect;
	
	            var sBounds = [sRect.x, sRect.y, sRect.x + sRect.width, sRect.y + sRect.height];
	            var sConnectorPoint = Util.getConnectorPoints(sRect);
	
	            if (!ConnectionManager.tempConnector) {
	                ConnectionManager.tempConnector = new Connector({isEdit: false, style: {lineType:lineType}});
	            }
	
	            var connector =  ConnectionManager.tempConnector;
	            //判断如果没有指定位置的话, 判断开始节点在结束结果左边则采用 right-left 否则采用left-right
	            if (sRect.x < rEndPoint.x) {
	                connector.sPos = "right";
	                connector.ePos = "left";
	            } else {
	                connector.sPos = "left";
	                connector.ePos = "right";
	            }
	
	            connector.options.style.lineType = lineType;
	            var solutions = this.connector2Points(lineType, sConnectorPoint[connector.sPos], rEndPoint,
	                sBounds, null);  // TYPE_STRAIGHT TYPE_JAGGED
	
	            connector.refresh(solutions[0][2]);
	            return connector;
	        },
	
	        /**
	         * 删除临时线
	         * @param  {[type]} zr             [description]
	         */
	        removeTempConnector: function(zr) {
	            if (ConnectionManager.tempConnector) {
	                zr.remove(ConnectionManager.tempConnector);
	                ConnectionManager.tempConnector = null;
	            }
	        },
	
	
	        /**
	         * 算出 两个节点 指定两个点如何联线
	         * @param  {[type]} type       [description]
	         * @param  {[type]} startPoint [description]
	         * @param  {[type]} endPoint   [description]
	         * @param  {[type]} sBounds    [description]
	         * @param  {[type]} eBounds    [description]
	         * @return {[type]}            [description]
	         */
	        connector2Points: function(type,  startPoint, endPoint, sBounds, eBounds ,escapeDistance){
	            var  figureEscapeDistance = [30, 30];
	            if (escapeDistance) {
	                if (!zrUtil.isArray(escapeDistance)) {
	                    figureEscapeDistance = [escapeDistance, escapeDistance];
	                } else {
	                    figureEscapeDistance = escapeDistance;
	                }
	            }
	
	            Log.group("connectionManager: connector2Points");
	
	
	            Log.info("ConnectionManager: connector2Points (" + type + ", " + startPoint + ", " + endPoint + ", " + sBounds + ", " + eBounds + ')');
	            var solutions = [];
	
	
	
	            switch(type){
	                case Connector.TYPE_STRAIGHT:  //直线
	                    var points = [startPoint.clone(), endPoint.clone()];
	                    solutions.push( ['straight', 'straight', points] );
	                    break;
	
	                case Connector.TYPE_CURVE:  //曲线
	
	                case Connector.TYPE_JAGGED:    //折线
	                    var startExitPoint = null;
	                    var endExitPoint = null;
	
	                    //find start exit point  寻找开始出口
	                    if(sBounds != null){
	                        var potentialExits = [];
	
	                        potentialExits.push(new Point(startPoint.x, sBounds[1] - figureEscapeDistance[0])); //north 北
	                        potentialExits.push(new Point(sBounds[2] + figureEscapeDistance[0], startPoint.y)); //east  东
	                        potentialExits.push(new Point(startPoint.x, sBounds[3] + figureEscapeDistance[0])); //south  南
	                        potentialExits.push(new Point(sBounds[0] - figureEscapeDistance[0], startPoint.y)); //west  西
	
	                        //pick closest exit point  寻找与 startPoint 最靠近的出口点
	                        startExitPoint = potentialExits[0];
	                        for(var i=1; i < potentialExits.length; i++){
	                            if(Util.distance(startPoint, potentialExits[i]) < Util.distance(startPoint, startExitPoint)){
	                                startExitPoint = potentialExits[i];
	                            }
	                        }
	                    }
	
	
	                    //find end exit point  寻找结束出口
	                    if(eBounds != null){
	                        var potentialExits = [];
	
	                        potentialExits.push(new Point(endPoint.x, eBounds[1] - figureEscapeDistance[1])); //north
	                        potentialExits.push(new Point(eBounds[2] + figureEscapeDistance[1], endPoint.y)); //east
	                        potentialExits.push(new Point(endPoint.x, eBounds[3] + figureEscapeDistance[1])); //south
	                        potentialExits.push(new Point(eBounds[0] - figureEscapeDistance[1], endPoint.y)); //west
	
	                        //pick closest exit point  寻找与 endPoint 最靠近的出口点
	                        endExitPoint = potentialExits[0];
	                        for(var i=1; i < potentialExits.length; i++){
	                            if(Util.distance(endPoint, potentialExits[i]) < Util.distance(endPoint, endExitPoint)){
	                                endExitPoint = potentialExits[i];
	                            }
	                        }
	                    }
	
	                    //Basic solution 最基本的解决方案   为其他解决方案做准备
	                    var s = [startPoint];
	                    var gapIndex = 0; //the index of the gap (where do we need to insert new points) DO NOT CHANGE IT
	                    if(startExitPoint){
	                        s.push(startExitPoint);
	                        gapIndex = 1;
	                    }
	                    if(endExitPoint){
	                        s.push(endExitPoint);
	                    }
	                    s.push(endPoint);
	
	
	
	                    //SO - no additional points     S0 解决方案 不添加任何点  基本不会被采用
	                    var s0 = Point.cloneArray(s);
	                    solutions.push(['s0', 's0', s0]);
	
	
	
	                    //S1   S1 解决方案  只有一个折点
	                    var s1 = Point.cloneArray(s);
	
	                    //first variant   第一个变体 s1 s1_1方案  折线点在 startExitPoint的X 与 endExitPoint的 Y位置
	                    var s1_1 = Point.cloneArray(s1);
	                    s1_1.splice(gapIndex + 1, 0, new Point(s1_1[gapIndex].x , s1_1[gapIndex+1].y) );
	                    solutions.push(['s1', 's1_1', s1_1]);
	
	                    //second variant  第二变体 s1 s1-2方案  折线点在 endExitPoint的X 与  startExitPoint的Y位置
	                    var s1_2 = Point.cloneArray(s1);
	                    s1_2.splice(gapIndex + 1, 0, new Point(s1_2[gapIndex+1].x , s1_2[gapIndex].y) );
	                    solutions.push(['s1', 's1_2', s1_2]);
	
	
	                    //S2  S2 解决方案  添加两个折点
	
	                    //Variant I   s2_1方案
	                    var s2_1 = Point.cloneArray(s);
	                    var s2_1_1 = new Point( (s2_1[gapIndex].x + s2_1[gapIndex+1].x) / 2,  s2_1[gapIndex].y);
	                    var s2_1_2 = new Point( (s2_1[gapIndex].x + s2_1[gapIndex+1].x) / 2,  s2_1[gapIndex+1].y);
	                    s2_1.splice(gapIndex + 1, 0, s2_1_1, s2_1_2);
	                    solutions.push(['s2', 's2_1', s2_1]);
	
	
	                    //Variant II  s2_1方案  1折线点 x: startExitPoint的X 位置 y: startExitPoint的y+endExitPoint的y/2
	                    //1折线点 x:endExitPoint的x  y:startExitPoint的y+endExitPoint的y/2
	                    var s2_2 = Point.cloneArray(s);
	                    var s2_2_1 = new Point( s2_2[gapIndex].x, (s2_2[gapIndex].y + s2_2[gapIndex+1].y)/2 );
	                    var s2_2_2 = new Point( s2_2[gapIndex+1].x, (s2_2[gapIndex].y + s2_2[gapIndex+1].y)/2);
	                    s2_2.splice(gapIndex + 1, 0, s2_2_1, s2_2_2);
	                    solutions.push(['s2', 's2_2', s2_2]);
	
	
	                    //Variant III
	                    var s2_3 = Point.cloneArray(s);
	                    //find the amount (stored in delta) of pixels we need to move right so no intersection with a figure will be present
	                    //!See:  /documents/specs/connected_figures_deltas.jpg file
	
	                    var eastExits = [s2_3[gapIndex].x + 20, s2_3[gapIndex+1].x + 20]; //add points X coordinates to be able to generate Variant III even in the absence of figures :p
	
	                    if(sBounds){
	                        eastExits.push(sBounds[2] + 20);
	                    }
	
	                    if(eBounds){
	                        eastExits.push(eBounds[2] + 20);
	                    }
	
	                    var eastExit = Util.max(eastExits);
	                    var s2_3_1 = new Point( eastExit, s2_3[gapIndex].y );
	                    var s2_3_2 = new Point( eastExit, s2_3[gapIndex+1].y );
	                    s2_3.splice(gapIndex + 1, 0, s2_3_1, s2_3_2);
	                    solutions.push(['s2', 's2_3', s2_3]);
	
	
	                    //Variant IV  s2_4方案
	                    var s2_4 = Point.cloneArray(s);
	                    //find the amount (stored in delta) of pixels we need to move up so no intersection with a figure will be present
	                    //!See:  /documents/specs/connected_figures_deltas.jpg file
	
	                    var northExits = [s2_4[gapIndex].y - 20, s2_4[gapIndex+1].y - 20]; //add points y coordinates to be able to generate Variant III even in the absence of figures :p
	
	                    if(sBounds){
	                        northExits.push(sBounds[1] - 20);
	                    }
	
	                    if(eBounds){
	                        northExits.push(eBounds[1] - 20);
	                    }
	
	                    var northExit = Util.min(northExits);
	                    var s2_4_1 = new Point( s2_4[gapIndex].x, northExit);
	                    var s2_4_2 = new Point( s2_4[gapIndex+1].x, northExit);
	                    s2_4.splice(gapIndex + 1, 0, s2_4_1, s2_4_2);
	                    solutions.push(['s2', 's2_4', s2_4]);
	
	
	                    //Variant V
	                    var s2_5 = Point.cloneArray(s);
	                    //find the amount (stored in delta) of pixels we need to move left so no intersection with a figure will be present
	                    //!See:  /documents/specs/connected_figures_deltas.jpg file
	
	                    var westExits = [s2_5[gapIndex].x - 20, s2_5[gapIndex+1].x - 20]; //add points x coordinates to be able to generate Variant III even in the absence of figures :p
	
	                    if(sBounds){
	                        westExits.push(sBounds[0] - 20);
	                    }
	
	                    if(eBounds){
	                        westExits.push(eBounds[0] - 20);
	                    }
	
	                    var westExit = Util.min(westExits);
	                    var s2_5_1 = new Point( westExit, s2_5[gapIndex].y);
	                    var s2_5_2 = new Point( westExit, s2_5[gapIndex+1].y);
	                    s2_5.splice(gapIndex + 1, 0, s2_5_1, s2_5_2);
	                    solutions.push(['s2', 's2_5', s2_5]);
	
	
	                    //Variant VI
	                    var s2_6 = Point.cloneArray(s);
	                    //find the amount (stored in delta) of pixels we need to move down so no intersection with a figure will be present
	                    //!See:  /documents/specs/connected_figures_deltas.jpg file
	
	                    var southExits = [s2_6[gapIndex].y + 20, s2_6[gapIndex+1].y + 20]; //add points y coordinates to be able to generate Variant III even in the absence of figures :p
	
	                    if(sBounds){
	                        southExits.push(sBounds[3] + 20);
	                    }
	
	                    if(eBounds){
	                        southExits.push(eBounds[3] + 20);
	                    }
	
	                    var southExit = Util.max(southExits);
	                    var s2_6_1 = new Point( s2_6[gapIndex].x, southExit);
	                    var s2_6_2 = new Point( s2_6[gapIndex+1].x, southExit);
	                    s2_6.splice(gapIndex + 1, 0, s2_6_1, s2_6_2);
	                    solutions.push(['s2', 's2_6', s2_6]);
	
	
	
	                    //FILTER solutions
	
	                    /*Algorithm
	                     * 0. solutions are ordered from minimmun nr of points to maximum >:)
	                     * 1. remove all solutions that are not orthogonal (mainly s0 solution)
	                     * 2. remove all solutions that go backward (we will not need them ever)
	                     * 3. remove all solutions with intersections
	                     * 4. pick first class of solutions with same nr of points (ex: 2)
	                     * 5. pick the first solution with 90 degree angles (less turnarounds)
	                     * (not interesteted) sort by length :p
	                     */
	
	                    //1. filter non ortogonal solutions 删除不是正交直线的方案
	                    if(true){
	                        Log.info("Filter orthogonal solutions. Initial number of solutions = " + solutions.length);
	                        var orthogonalSolution = [];
	                        for(var l=0; l<solutions.length; l++){
	                            var solution = solutions[l][2];
	                            if(Util.orthogonalPath(solution)){
	                                orthogonalSolution.push(solutions[l]);
	                            }
	                        }
	                        solutions = orthogonalSolution;
	                        Log.info("\n\tOrthogonalSolutions = " + solutions.length);
	                    }
	
	                    //2. filter backward solutions  过滤 倒退的方案
	                    if(true){
	                        //do not allow start and end points to coincide - ignore them
	                        if(startPoint.equals(endPoint)){
	                            Log.info("Start and end point coincide...skip backward solution. I think we will just fall on s0 :)");
	                        }
	                        else{
	                            Log.info("Filter backward solutions. Initial number of solutions = " + solutions.length);
	                            var forwardSolutions = [];
	                            var temp = '';
	                            for(var l=0; l<solutions.length; l++){
	                                var solution = solutions[l][2];
	                                if(Util.forwardPath(solution)){
	                                    forwardSolutions.push(solutions[l]);
	                                }
	                                else{
	                                    temp = temp +  "\n\t" + solution;
	                                }
	                            }
	                            solutions = forwardSolutions;
	                            Log.info("\n\t ForwardSolutions = " + solutions.length);
	                            if(solutions.length == 0){
	                                Log.info("Discarded solutions: " + temp);
	                            }
	                        }
	                    }
	
	
	                    //3. Filter non intersecting solutions  去除没有交集()的方案
	                    if(true){
	                        Log.info("Filter non intersecting solutions. Initial number of solutions = " + solutions.length);
	                        var nonIntersectionSolutions = []
	                        for(var l=0; l<solutions.length; l++){
	                            var solution = solutions[l][2];
	                            //Log.info("Solution id= " + solutions[l][1] + ' nr points = ' + solution.length + ", points = " + solution);
	                            var intersect = false;
	
	                            var innerLines = solution.slice(); //just a shallow copy
	
	                            /*If any bounds just trim the solution. So we avoid the strange case when a connection
	                             *startes from a point on a figure and ends inside of the same figure, but not on a connection point*/
	                            if(eBounds || sBounds){
	                                //i0nnerLines = innerLines.slice(0, innerLines.length - 1);
	                                innerLines = innerLines.slice(1, innerLines.length - 1);
	                                //Log.info("\t eBounds present,innerLines nr. points = " + innerLines.length + ", points = " + innerLines);
	                            }
	
	
	
	                            //now test for intersection
	                            if(sBounds){
	                                intersect = intersect || Util.polylineIntersectsRectangle(innerLines, sBounds);
	                            }
	                            if(eBounds){
	                                intersect = intersect || Util.polylineIntersectsRectangle(innerLines, eBounds);
	                            }
	
	                            if(!intersect){
	                                nonIntersectionSolutions.push(solutions[l]);
	                            }
	                        }
	
	                        //If all solutions intersect than this is destiny  :) and just ignore the intersection filter
	                        if(nonIntersectionSolutions.length != 0){
	                            //reasign to solutions
	                            solutions = nonIntersectionSolutions;
	                        }
	
	                        Log.info("\n\t nonIntersectionSolutions = " + solutions.length);
	                    }
	
	
	                    //4. get first class of solutions with same nr of points 选择与第一个方案点数一样多的方案（因为第一个方案点数最少）
	                    if(true){
	                        Log.info("Get first class of solutions with same nr of points");
	                        if(solutions.length == 0){
	                            Log.info("This is not possible");
	                        }
	
	                        var firstSolution = solutions[0][2]; //pick first solution
	                        var nrOfPoints = firstSolution.length;
	                        var sameNrPointsSolution = [];
	
	                        for(var l=0; l<solutions.length; l++){
	                            var solution = solutions[l][2];
	                            if(solution.length == nrOfPoints){
	                                sameNrPointsSolution.push(solutions[l]);
	                            }
	                        }
	
	                        solutions = sameNrPointsSolution;
	                    }
	
	
	
	
	                    /*5.  计算路径分数 ，取最分数高的
	                     Pick the first solution with 90 degree angles (less turnarounds)
	                     *in case we have more than one solution in our class
	                     */
	                    if(true){
	                        Log.info("pick the first solution with 90 degree angles (less turnarounds)");
	                        var solIndex = 0;
	                        for(var l=0; l<solutions.length; l++){
	                            var solution = solutions[l][2];
	                            if(Util.scorePath( solutions[solIndex][2] ) < Util.scorePath( solutions[l][2] ) ){
	                                solIndex = l;
	                            }
	                        }
	                        solutions = [solutions[solIndex]];
	                    }
	
	
	                    break;
	            }
	
	            //SMOOTHING curve
	            if(type === Connector.TYPE_CURVE){
	                this.smoothCurve(solutions);
	            }
	            //END SMOOTHING curve
	
	            Log.groupEnd();
	
	            return solutions;
	        },
	
	        smoothCurve: function(solutions){
	            var option = 3;
	
	            switch(option){
	                case 0:
	                    //do nothing
	                    break;
	
	                case 1: //add intermediate points
	                    //Add the middle point for start and end segment so that we "force" the
	                    //curve to both come "perpendicular" on bounds and also make the curve
	                    //"flee" more from bounds (on exit)
	                    for(var s=0; s<solutions.length; s++){
	                        var solTurningPoints = solutions[s][2];
	
	                        //first segment
	                        var a1 = solTurningPoints[0];
	                        var a2 = solTurningPoints[1];
	                        var startMiddlePoint = Util.getMiddle(a1, a2);
	                        solTurningPoints.splice(1,0, startMiddlePoint);
	
	                        //last segment
	                        var a3 = solTurningPoints[solTurningPoints.length - 2];
	                        var a4 = solTurningPoints[solTurningPoints.length - 1];
	                        var endMiddlePoint = Util.getMiddle(a3, a4);
	                        solTurningPoints.splice(solTurningPoints.length - 1, 0, endMiddlePoint);
	                    }
	                    break;
	
	                case 2: //remove points
	                    for(var s=0; s<solutions.length; s++){
	                        var solType= solutions[s][0];
	                        if(solType == 's1' || solType == 's2'){
	                            var solTurningPoints = solutions[s][2];
	                            solTurningPoints.splice(1,1);
	                            solTurningPoints.splice(solTurningPoints.length - 2, 1);
	                        }
	                    }
	                    break;
	
	                case 3:
	                    /*remove colinear point for s1 as it seems that more colinear points do not look good
	                     * on organic solutions >:D*/
	                    for(var s=0; s<solutions.length; s++){
	                        var solType= solutions[s][0];
	                        if(solType == 's1'){
	                            var solTurningPoints = solutions[s][2];
	                            var reducedSolution = Util.collinearReduction(solTurningPoints);
	                            solutions[s][2] = reducedSolution;
	                        }
	                    }
	                    break;
	            }//end switch
	
	        }
	    };
	    module.exports = ConnectionManager;
	


/***/ },
/* 85 */
/***/ function(module, exports) {

	/**
	 * 日志类
	 * @author wang.xiaohu
	 */
	
	
	    var Log  = {
	        LOG_LEVEL_NONE  : 0,
	
	        LOG_LEVEL_DEBUG : 1,
	
	        LOG_LEVEL_INFO : 2,
	
	        LOG_LEVEL_ERROR : 3,
	
	        level : this.LOG_LEVEL_ERROR,
	        
	        /**
	        * The less important of all messages
	        * @param {String} message - the message to be logged
	        **/
	        debug: function (message){
	            if(typeof console !== 'undefined'){
	                if(this.level <= this.LOG_LEVEL_DEBUG){
	                    
	                    //in FF is debug
	                    if(typeof console.debug == 'function'){
	                        console.debug(message);
	                    }
	                    else{//TODO: in IE is log
	    //                    console.info(message);
	                    }
	                }
	            }
	        },
	
	
	        /**
	        * The commonly used log message
	        * @param {String} message - the message to be logged
	        **/
	        info : function (message){
	            if(typeof console !== 'undefined'){
	                if(this.level <= this.LOG_LEVEL_INFO){
	                    console.info(message);
	                }
	            }
	        },
	
	        /**
	        * The worse kind of message. Usually a crash
	        * @param {String} message - the message to be logged
	        **/
	        error : function (message){
	            if(typeof console !== 'undefined'){
	                if(this.level <= this.LOG_LEVEL_ERROR){
	                    console.error(message);
	                }
	            }
	        },
	
	        /**
	         *Start grouping the log messages
	         *@param {String} title - the title of the group
	         *@see <a href="http://getfirebug.com/logging">http://getfirebug.com/logging</a>
	         **/
	        group : function(title){
	            if(this.level <= this.LOG_LEVEL_INFO){ //ignore group if level not debug or info
	                if(typeof console !== 'undefined'){           
	                    /**If we do not test for group() function you will get an error in Opera
	                     *as Opera has it's own console...which does not have a group() function*/
	                    if(typeof console.group === 'function'){
	                        console.group(title);
	                    }
	                }
	            }
	        },
	
	        /**Ends current message grouping*/
	        groupEnd : function(){
	            if(this.level <= this.LOG_LEVEL_INFO){ //ignore group if level not debug or info
	                if(typeof console !== 'undefined'){
	                    /**If we do not test for groupEnd() function you will get an error in Opera
	                     *as Opera has it's own console...which does not have a group() function*/
	                    if(typeof console.groupEnd === 'function'){
	                        console.groupEnd();
	                    }
	                }
	            }
	        }
	
	    };
	
	    //Log.level = Log.LOG_LEVEL_DEBUG; 
	    Log.level = Log.LOG_LEVEL_ERROR; 
	    //Log.level = Log.LOG_LEVEL_ERROR;
	    //Log.level = Log.LOG_LEVEL_NONE;
	    module.exports = Log;
	    


/***/ },
/* 86 */
/***/ function(module, exports) {

	/**
	 * 常量定义
	 */
	
		module.exports = 	{
			ELEMENT_TYPE: "elementType",
			MODE: "mode",
			BACKGROUND: "backgroud",
			OPTIONS: "options",
			USERDATA: "userData",
			ID: "id",
			START_ID: "startNodeId",
			END_ID: "endNodeId",
			ALARM: "Alarm",
			RELATIONID:"relationId",
			RELATION_IMAGE:"relationImage",
			GROUP: "Group",
			CONNECTION: "connection",
			CHILDS: "childs",
			TREE_ROOT: "treeRoot",
			DOCKERS:"options.dockers",
			STYLE_LINETYPE:"style.lineType",
			LINEOPERATIONICON:"LineOperationIcon",
		};
	


/***/ },
/* 87 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * 节点等的模型
	 * 里面存的数据用来处理序列化和反序列化
	 * @class fish.topo.model
	 */
	
	
	    var zrUtil = __webpack_require__(4);
	    var clazzUtil = __webpack_require__(88);
	
	    function Model(option, parentModel,  extraOpt) {
	        this.parentModel = parentModel;
	        this.option = option;
	
	        // Simple optimization
	        if (this.init) {
	            if (arguments.length <= 3) {
	                this.init(option, parentModel,  extraOpt);
	            }
	            else {
	                this.init.apply(this, arguments);
	            }
	        }
	    }
	
	    Model.prototype = {
	
	        constructor: Model,
	
	        /**
	         * Model 的初始化函数
	         * @private
	         * @param {Object} option
	         */
	        init: function (option) {
	            zrUtil.merge(option, this.getDefaultOption());
	        },
	
	        getDefaultOption: function () {
	            if (!this.hasOwnProperty('__defaultOption')) {
	                var optList = [];
	                var Class = this.constructor;
	                while (Class) {
	                    var opt = Class.prototype.defaultOption;
	                    opt && optList.push(opt);
	                    Class = Class.superClass;
	                }
	
	                var defaultOption = {};
	                for (var i = optList.length - 1; i >= 0; i--) {
	                    defaultOption = zrUtil.merge(defaultOption, optList[i], true);
	                }
	                this.__defaultOption = defaultOption;
	            }
	            return this.__defaultOption;
	        },
	
	        /**
	         * @private
	         */
	        mergeOption: function (option) {
	            zrUtil.merge(this.option, option, true);
	        },
	
	        /**
	         * 获取model的某个属性的值
	         * @param {string} path model中的属性
	         * @return {String}
	         *
	         * **使用范例**：
	         *
	         *      @example
	         *          node.model.get("options.text");
	         */
	        get: function (path, ignoreParent) {
	            if (!path) {
	                return this.option;
	            }
	
	            if (typeof path === 'string') {
	                path = path.split('.');
	            }
	
	            var obj = this.option;
	            var parentModel = this.parentModel;
	            for (var i = 0; i < path.length; i++) {
	                // obj could be number/string/... (like 0)
	                obj = (obj && typeof obj === 'object') ? obj[path[i]] : null;
	                if (obj == null) {
	                    break;
	                }
	            }
	            if (obj == null && parentModel && !ignoreParent) {
	                obj = parentModel.get(path);
	            }
	            return obj;
	        },
	
	        /**
	         * 设置model的某个属性的值
	         * @param {string} path model中的属性
	         * @param {String} value 所需要设置的值
	         * @return {String}
	         *
	         * **使用范例**：
	         *
	         *      @example
	         *          node.model.set("options.text","例子");
	         */
	        set: function (path, value) {
	            var obj = this.option;
	
	            if (path.indexOf(".") == -1) {
	                obj[path] = value;
	            } else {
	                var fieldArray  = path.split('.');
	                var n = fieldArray.length;
	                var currentRef = obj;
	                var fieldName;
	
	                for (var i = 0; i < n - 1; i++) {
	                    fieldName = fieldArray[i];
	                    if(currentRef[fieldName] == null) {
	                        currentRef[fieldName] = {};
	                    }
	                    currentRef = currentRef[fieldName];
	                }
	                fieldName = fieldArray[n-1];
	                currentRef[fieldName] = value;
	            }
	        },
	
	        /**
	         * @private
	         */
	        getShallow: function (key, ignoreParent) {
	            var option = this.option;
	            var val = option && option[key];
	            var parentModel = this.parentModel;
	            if (val == null && parentModel && !ignoreParent) {
	                val = parentModel.getShallow(key);
	            }
	            return val;
	        },
	
	        /**
	         * @private
	         */
	        getModel: function (path, parentModel) {
	            var obj = this.get(path, true);
	            var thisParentModel = this.parentModel;
	            var model = new Model(
	                obj, parentModel || (thisParentModel && thisParentModel.getModel(path))
	            );
	            return model;
	        },
	
	        /**
	         *清空model的option
	         * @private
	         */
	        isEmpty: function () {
	            return this.option == null;
	        },
	
	        restoreData: function () {},
	
	        /**
	         * @private
	         */
	        clone: function () {
	            var Ctor = this.constructor;
	            return new Ctor(zrUtil.clone(this.option));
	        }
	    };
	
	    // Enable Model.extend.
	    clazzUtil.enableClassExtend(Model);
	
	    module.exports = Model;
	


/***/ },
/* 88 */
/***/ function(module, exports, __webpack_require__) {

	
	
	    var zrUtil = __webpack_require__(4);
	
	    var clazz = {};
	
	    var TYPE_DELIMITER = '.';
	    var IS_CONTAINER = '___FT__COMPONENT__CONTAINER___';
	    /**
	     * @public
	     */
	    var parseClassType = clazz.parseClassType = function (componentType) {
	        var ret = {main: '', sub: ''};
	        if (componentType) {
	            componentType = componentType.split(TYPE_DELIMITER);
	            ret.main = componentType[0] || '';
	            ret.sub = componentType[1] || '';
	        }
	        return ret;
	    };
	    /**
	     * @public  相比 直接用zrUtil.inherits 好处是  可以直接调用父类的构造函数
	     */
	    clazz.enableClassExtend = function (RootClass, preConstruct) {
	        RootClass.extend = function (proto) {
	            var ExtendedClass = function () {
	                preConstruct && preConstruct.apply(this, arguments);
	                RootClass.apply(this, arguments);
	            };
	
	            zrUtil.extend(ExtendedClass.prototype, proto);
	
	            ExtendedClass.extend = this.extend;
	            ExtendedClass.superCall = superCall;
	            ExtendedClass.superApply = superApply;
	            zrUtil.inherits(ExtendedClass, this);
	            ExtendedClass.superClass = this;
	
	            return ExtendedClass;
	        };
	    };
	
	    // superCall should have class info, which can not be fetch from 'this'.
	    // Consider this case:
	    // class A has method f,
	    // class B inherits class A, overrides method f, f call superApply('f'),
	    // class C inherits class B, do not overrides method f,
	    // then when method of class C is called, dead loop occured.
	    function superCall(context, methodName) {
	        var args = zrUtil.slice(arguments, 2);
	        return this.superClass.prototype[methodName].apply(context, args);
	    }
	
	    function superApply(context, methodName, args) {
	        return this.superClass.prototype[methodName].apply(context, args);
	    }
	
	    /**
	     * @param {Object} entity
	     * @param {Object} options
	     * @param {boolean} [options.registerWhenExtend]
	     * @public
	     */
	    clazz.enableClassManagement = function (entity, options) {
	        options = options || {};
	
	        /**
	         * Component model classes
	         * key: componentType,
	         * value:
	         *     componentClass, when componentType is 'xxx'
	         *     or Object.<subKey, componentClass>, when componentType is 'xxx.yy'
	         * @type {Object}
	         */
	        var storage = {};
	
	        entity.registerClass = function (Clazz, componentType) {
	            if (componentType) {
	                componentType = parseClassType(componentType);
	
	                if (!componentType.sub) {
	                    if (storage[componentType.main]) {
	                        //已经注册过了，直接返回
	                        return;
	                    }
	                    storage[componentType.main] = Clazz;
	                }
	                else if (componentType.sub !== IS_CONTAINER) {
	                    var container = makeContainer(componentType);
	                    container[componentType.sub] = Clazz;
	                }
	            }
	            return Clazz;
	        };
	
	        entity.getClass = function (componentTypeMain, subType, throwWhenNotFound) {
	            var Clazz = storage[componentTypeMain];
	
	            if (Clazz && Clazz[IS_CONTAINER]) {
	                Clazz = subType ? Clazz[subType] : null;
	            }
	
	            if (throwWhenNotFound && !Clazz) {
	                throw new Error(
	                    'Component ' + componentTypeMain + '.' + (subType || '') + ' not exists. Load it first.'
	                );
	            }
	
	            return Clazz;
	        };
	
	        entity.getClassesByMainType = function (componentType) {
	            componentType = parseClassType(componentType);
	
	            var result = [];
	            var obj = storage[componentType.main];
	
	            if (obj && obj[IS_CONTAINER]) {
	                zrUtil.each(obj, function (o, type) {
	                    type !== IS_CONTAINER && result.push(o);
	                });
	            }
	            else {
	                result.push(obj);
	            }
	
	            return result;
	        };
	
	        entity.hasClass = function (componentType) {
	            // Just consider componentType.main.
	            componentType = parseClassType(componentType);
	            return !!storage[componentType.main];
	        };
	
	        /**
	         * @return {Array.<string>} Like ['aa', 'bb'], but can not be ['aa.xx']
	         */
	        entity.getAllClassMainTypes = function () {
	            var types = [];
	            zrUtil.each(storage, function (obj, type) {
	                types.push(type);
	            });
	            return types;
	        };
	
	        /**
	         * If a main type is container and has sub types
	         * @param  {string}  componentType
	         * @return {boolean}
	         */
	        entity.hasSubTypes = function (componentType) {
	            componentType = parseClassType(componentType);
	            var obj = storage[componentType.main];
	            return obj && obj[IS_CONTAINER];
	        };
	
	        entity.parseClassType = parseClassType;
	
	        function makeContainer(componentType) {
	            var container = storage[componentType.main];
	            if (!container || !container[IS_CONTAINER]) {
	                container = storage[componentType.main] = {};
	                container[IS_CONTAINER] = true;
	            }
	            return container;
	        }
	
	        if (options.registerWhenExtend) {
	            var originalExtend = entity.extend;
	            if (originalExtend) {
	                entity.extend = function (proto) {
	                    var ExtendedClass = originalExtend.call(this, proto);
	                    return entity.registerClass(ExtendedClass, proto.type);
	                };
	            }
	        }
	
	        return entity;
	    };
	
	    module.exports = clazz;
	


/***/ },
/* 89 */
/***/ function(module, exports, __webpack_require__) {

	
	
	    var forceHelper = __webpack_require__(90);
	    var vec2 = __webpack_require__(14);
	    var BoundingRect = __webpack_require__(24);
	    var Util = __webpack_require__(59);
	    var ConnectionManager = __webpack_require__(84);
	
	    /**
	     * 力导向布局
	     * @param  {[type]} allNodes   [所有节点]
	     * @param  {[type]} allCons    [所有线]
	     * @param  {[type]} repulsion  [节点之间的斥力因子。该值越大节点之间的斥力越大，两个节点间的距离也会越远。]
	     * @param  {[type]} edgeLength [边的两个节点之间的距离，这个距离也会受 repulsion。]
	     * @param  {[type]} gravity    [节点受到的向中心的引力因子。该值越大节点越往中心点靠拢。]
	     * @return {[type]}            [description]
	     */
	    module.exports = function(forceLayoutOption) {
	        var repulsion = forceLayoutOption.repulsion || 100;
	        var gravity = forceLayoutOption.gravity || 0.1;
	        var edgeLength = forceLayoutOption.edgeLength || 30;
	        var preservedPoints = forceLayoutOption.preservedPoints || {};
	        var allNodes = this.forceLayoutOption.allNodes;
	        var allCons = this.forceLayoutOption.allCons;
	        var rect = this.forceLayoutOption.rect;
	        var nodes = _.map(allNodes, function(node, idx) {
	            var rep = repulsion; node.w = rep; node.rep = rep; node.p = null;
	            return {
	                w: rep,
	                rep: rep,
	                p: null
	            };
	        });
	
	        var edges = _.map(allCons, function(con, idx) {
	            con.n1 = con.startNode;
	            con.n2 = con.endNode;
	            con.d = edgeLength;
	            con.curveness = 0;
	            return {
	                n1: con.startNode,
	                n2: con.endNode,
	                d: edgeLength,
	                curveness: 0
	            };
	        });
	
	        var forceInstance = forceHelper(allNodes, allCons, {
	            rect: rect,
	            gravity: gravity
	        });
	        var oldStep = forceInstance.step;
	        forceInstance.step = function(cb) {
	            for (var i = 0, l = allNodes.length; i < l; i++) {
	                if (nodes[i].fixed) {
	                    // Write back to layout instance
	                    vec2.copy(nodes[i].p, nodes[i].position);
	                }
	            }
	            oldStep(function(allNodes, allCons, stopped) {
	                for (var i = 0, l = allNodes.length; i < l; i++) {
	                    if (!allNodes[i].fixed) {
	                        allNodes[i].attr("position", allNodes[i].p);
	                    }
	                    preservedPoints[i] = allNodes[i].p;
	                }
	                for (var i = 0, l = allCons.length; i < l; i++) {
	                    // var e = allCons[i];
	                    // var p1 = e.n1.p;
	                    // var p2 = e.n2.p;
	                    // var points = [p1, p2];
	                    // if (e.curveness > 0) {
	                    //     points.push([
	                    //         (p1[0] + p2[0]) / 2 - (p1[1] - p2[1]) * e.curveness,
	                    //         (p1[1] + p2[1]) / 2 - (p2[0] - p1[0]) * e.curveness
	                    //     ]);
	                    // }
	                    // var newPoints = Util.traslatePoints(points, true);
	                    // e.refresh(newPoints);
	                    ConnectionManager.refreshConnector(allCons[i], true);
	                }
	                // Update layout
	
	                cb && cb(stopped);
	            });
	        };
	        forceLayoutOption.forceLayout = forceInstance;
	        forceLayoutOption.preservedPoints = preservedPoints;
	        // Step to get the layout
	        forceInstance.step();
	    }
	


/***/ },
/* 90 */
/***/ function(module, exports, __webpack_require__) {

	
	
	    var vec2 = __webpack_require__(14);
	    var scaleAndAdd = vec2.scaleAndAdd;
	
	    // function adjacentNode(n, e) {
	    //     return e.n1 === n ? e.n2 : e.n1;
	    // }
	
	    module.exports = function (nodes, edges, opts) {
	        var rect = opts.rect;
	        var width = rect.width;
	        var height = rect.height;
	        var center = [rect.x + width / 2, rect.y + height / 2];
	        // var scale = opts.scale || 1;
	        var gravity = opts.gravity == null ? 0.1 : opts.gravity;
	
	        // for (var i = 0; i < edges.length; i++) {
	        //     var e = edges[i];
	        //     var n1 = e.n1;
	        //     var n2 = e.n2;
	        //     n1.edges = n1.edges || [];
	        //     n2.edges = n2.edges || [];
	        //     n1.edges.push(e);
	        //     n2.edges.push(e);
	        // }
	        // Init position
	        for (var i = 0; i < nodes.length; i++) {
	            var n = nodes[i];
	            if (!n.p) {
	                // Use the position from first adjecent node with defined position
	                // Or use a random position
	                // From d3
	                // if (n.edges) {
	                //     var j = -1;
	                //     while (++j < n.edges.length) {
	                //         var e = n.edges[j];
	                //         var other = adjacentNode(n, e);
	                //         if (other.p) {
	                //             n.p = vec2.clone(other.p);
	                //             break;
	                //         }
	                //     }
	                // }
	                // if (!n.p) {
	                    n.p = vec2.create(
	                        width * (Math.random() - 0.5) + center[0],
	                        height * (Math.random() - 0.5) + center[1]
	                    );
	                // }
	            }
	            n.pp = vec2.clone(n.p);
	            n.edges = null;
	        }
	
	        // Formula in 'Graph Drawing by Force-directed Placement'
	        // var k = scale * Math.sqrt(width * height / nodes.length);
	        // var k2 = k * k;
	
	        var friction = 0.6;
	
	        return {
	            warmUp: function () {
	                friction = 0.5;
	            },
	
	            setFixed: function (idx) {
	                nodes[idx].fixed = true;
	            },
	
	            setUnfixed: function (idx) {
	                nodes[idx].fixed = false;
	            },
	
	            step: function (cb) {
	                var v12 = [];
	                var nLen = nodes.length;
	                for (var i = 0; i < edges.length; i++) {
	                    var e = edges[i];
	                    var n1 = e.n1;
	                    var n2 = e.n2;
	
	                    vec2.sub(v12, n2.p, n1.p);
	                    var d = vec2.len(v12) - e.d;
	                    var w = n2.w / (n1.w + n2.w);
	                    vec2.normalize(v12, v12);
	
	                    !n1.fixed && scaleAndAdd(n1.p, n1.p, v12, w * d * friction);
	                    !n2.fixed && scaleAndAdd(n2.p, n2.p, v12, -(1 - w) * d * friction);
	                }
	                // Gravity
	                for (var i = 0; i < nLen; i++) {
	                    var n = nodes[i];
	                    if (!n.fixed) {
	                        vec2.sub(v12, center, n.p);
	                        // var d = vec2.len(v12);
	                        // vec2.scale(v12, v12, 1 / d);
	                        // var gravityFactor = gravity;
	                        vec2.scaleAndAdd(n.p, n.p, v12, gravity * friction);
	                    }
	                }
	
	                // Repulsive
	                // PENDING
	                for (var i = 0; i < nLen; i++) {
	                    var n1 = nodes[i];
	                    for (var j = i + 1; j < nLen; j++) {
	                        var n2 = nodes[j];
	                        vec2.sub(v12, n2.p, n1.p);
	                        var d = vec2.len(v12);
	                        if (d === 0) {
	                            // Random repulse
	                            vec2.set(v12, Math.random() - 0.5, Math.random() - 0.5);
	                            d = 1;
	                        }
	                        var repFact = (n1.rep + n2.rep) / d / d;
	                        !n1.fixed && scaleAndAdd(n1.pp, n1.pp, v12, repFact);
	                        !n2.fixed && scaleAndAdd(n2.pp, n2.pp, v12, -repFact);
	                    }
	                }
	                var v = [];
	                for (var i = 0; i < nLen; i++) {
	                    var n = nodes[i];
	                    if (!n.fixed) {
	                        vec2.sub(v, n.p, n.pp);
	                        vec2.scaleAndAdd(n.p, n.p, v, friction);
	                        vec2.copy(n.pp, n.p);
	                    }
	                }
	
	                friction = friction * 0.992;
	
	                cb && cb(nodes, edges, friction < 0.01);
	            }
	        };
	    }
	


/***/ },
/* 91 */
/***/ function(module, exports, __webpack_require__) {

	
	    var graphic = __webpack_require__(3);
	    var ConnectionManager = __webpack_require__(83);
	    module.exports = function (option) {
	        function checkNode(dom){
	            dom.treeType = option.type;
	            dom.model.set("options.treeType",option.type);
	            //1、根据连线  找出起始节点 所有的子结节
	            var childrenNode = [];
	            for(var i = 0;i < ConnectionManager.connectors.length; i++){
	                if(ConnectionManager.connectors[i].startNode == dom){
	                    childrenNode.push(ConnectionManager.connectors[i].endNode);
	                }
	            };
	            if(childrenNode.length > 0){
	
	
	                // 2. 遍历子结点
	                for(var m = 0;m < childrenNode.length;m++){
	                    childrenNode[m].treeType = option.type;
	                    var x,y;
	                    if(option.type == "horizontal"){
	                        var average =dom.layout.height;
	                        // 2.1 父结点 如果圆形 作不同的处理
	                        if(dom instanceof graphic.Circle){
	                            //2.2 子节点 如果是圆形  vv
	                            if(childrenNode[m] instanceof graphic.Circle){
	                                y = dom.position[1]-average*(childrenNode.length-1)/2+average*m;
	                                x = dom.position[0]+dom.layout.width;
	                            }else if(childrenNode[m] instanceof graphic.Image){
	                                y = dom.position[1]-average*(childrenNode.length-1)/2+average*m-childrenNode[m].style.height/2;
	                                x = dom.position[0]+dom.layout.width-childrenNode[m].style.width/2
	                            }else{
	                                y = dom.position[1]-average*(childrenNode.length-1)/2+average*m-childrenNode[m].shape.height/2;
	                                x = dom.position[0]+dom.layout.width-childrenNode[m].shape.width/2
	                            }
	
	                        }else{
	                            if(childrenNode[m] instanceof graphic.Circle){
	                                y = dom.position[1]+dom.shape.height/2-average*(childrenNode.length-1)/2+average*m;
	                                x = dom.position[0]+dom.shape.width/2+dom.layout.width;
	                            }else if(childrenNode[m] instanceof graphic.Image){
	                                y = dom.position[1]+dom.style.height/2-average*(childrenNode.length-1)/2+average*m-childrenNode[m].style.height/2;
	                                x = dom.position[0]+dom.style.width/2+dom.layout.width-childrenNode[m].style.width/2
	                            }else{
	                                y = dom.position[1]+dom.shape.height/2-average*(childrenNode.length-1)/2+average*m-childrenNode[m].shape.height/2;
	                                x = dom.position[0]+dom.shape.width/2+dom.layout.width-childrenNode[m].shape.width/2
	                            }
	                        }
	                    }else{
	                        var average =dom.layout.width;
	                        // 2.1 父结点 如果圆形 作不同的处理
	                        if(dom instanceof graphic.Circle){
	                            //2.2 子节点 如果是圆形  vv
	                            if(childrenNode[m] instanceof graphic.Circle){
	                                x = dom.position[0]-average*(childrenNode.length-1)/2+average*m;
	                                y = dom.position[1]+dom.layout.height;
	                            }else if(childrenNode[m] instanceof graphic.Image){
	                                x = dom.position[0]-average*(childrenNode.length-1)/2+average*m-childrenNode[m].style.width/2;
	                                y = dom.position[1]+dom.layout.height-childrenNode[m].style.height/2
	                            }else{
	                                x = dom.position[0]-average*(childrenNode.length-1)/2+average*m-childrenNode[m].shape.width/2;
	                                y = dom.position[1]+dom.layout.height-childrenNode[m].shape.height/2
	                            }
	
	                        }else{
	                            if(childrenNode[m] instanceof graphic.Circle){
	                                x = dom.position[0]+dom.shape.width/2-average*(childrenNode.length-1)/2+average*m;
	                                y = dom.position[1]+dom.shape.height/2+dom.layout.height;
	                            }else if(childrenNode[m] instanceof graphic.Image){
	                                x = dom.position[0]+dom.style.width/2-average*(childrenNode.length-1)/2+average*m-childrenNode[m].style.width/2;
	                                y = dom.position[1]+dom.style.height/2+dom.layout.height-childrenNode[m].style.height/2
	                            }else{
	                                x = dom.position[0]+dom.shape.width/2-average*(childrenNode.length-1)/2+average*m-childrenNode[m].shape.width/2;
	                                y = dom.position[1]+dom.shape.height/2+dom.layout.height-childrenNode[m].shape.height/2
	                            }
	                        }
	                    }
	
	                    childrenNode[m].attr("position", [x,y]);
	                }
	                // 3. 节点位置变化，刷新线
	                ConnectionManager.refreshLineByNode(dom);
	            }
	            // 4.递归 子节点
	            for(var j = 0;j < childrenNode.length;j++){
	                checkNode(childrenNode[j]);
	            }
	        }
	        checkNode(option.node);
	    }


/***/ },
/* 92 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Flow工具类
	 */
	
	    var Model = __webpack_require__(87);
	    var Constants = __webpack_require__(86);
	    var zrUtil = __webpack_require__(4);
	    var GroupNode = __webpack_require__(75);
	    var Connector = __webpack_require__(77);
	    /**
	     * 根据结点数组 导出JSON格式的数据
	     *
	     * @param {Array} model 总的模型
	     * @return {JSON} JSON格式的数据
	     */
	    function toJson(model, group) {
	        var jsonArr = [];
	        group.eachChild(function(node) {
	            if (node.model) {
	                //如果是组的话
	                if (node instanceof GroupNode) {
	                    var childArr = [];
	                    node.eachChild(function(childNode) {
	                        if (childNode.model) {
	                            childArr.push(childNode.model.option);
	                        };
	                    });
	                    node.model.set(Constants.CHILDS, childArr);
	                };
	                if (node instanceof Connector) {
	                    node.refreshModel();
	                };
	                jsonArr.push(node.model.option);
	
	            }
	
	
	        })
	        model.set(Constants.CHILDS, jsonArr);
	        return model.option;
	    }
	
	    /**
	     * 根据 JSON 生成节点
	     * @param  {[type]} fishTopoflow [description]
	     * @param  {[type]} json         [description]
	     * @return {[type]}              [description]
	     */
	    function fromJson(fishTopoflow, group, childShapes, isChild, layoutRootNode) {
	        // 1.清空画布
	
	        var connectors = [];
	        // 2.先创建节点  遍历形状 获取模型
	
	
	        for (var i = 0; i < childShapes.length; i++) {
	            var shape = childShapes[i];
	            if (shape.elementType === Constants.CONNECTION) {
	                connectors.push(shape);
	            }
	            else if (shape.elementType === Constants.ALARM) {
	                var relationNode = findNodeById(fishTopoflow.group, shape.relationId);
	                fishTopoflow.creatAlarm(relationNode, shape.options);
	            }
	            else if (shape.elementType === Constants.GROUP) {
	                shape.options.id = shape.id;
	                var group = fishTopoflow.creatNode(shape.elementType, shape.options, shape.userData);
	                fromJson(fishTopoflow, group, shape.childs, true, layoutRootNode);
	
	                fishTopoflow.addNode(group);
	
	
	            }
	            else {
	                // 将模型中的id 传递给创建的节点
	                shape.options.id = shape.id;
	                var node = fishTopoflow.creatNode(shape.elementType, shape.options, shape.userData);
	                if (isChild) {
	                    group.add(node);
	                } else {
	                    fishTopoflow.addNode(node);
	                }
	
	                if (shape.options.layout) {
	                    if (shape.options.layout.layout === Constants.TREE_ROOT) {
	                        var node = findNodeById(group, shape.id)
	                        layoutRootNode.push(node);
	                          //  fishTopo.layoutNode("tree",{"node":node});
	                    };
	                };
	
	            };
	
	
	
	        };
	
	        // 3. 再创建线
	        for(var i = 0, len = connectors.length; i < len; i++) {
	            var line = connectors[i];
	            var startNode = findNodeById(group, line.startNodeId);
	            var endNode = findNodeById(group, line.endNodeId);
	            if (startNode && endNode) {
	                var link = fishTopoflow.creatLink(startNode,endNode,line.options,line.userData);
	                if (isChild) {
	                    group.add(link);
	                } else {
	                    fishTopoflow.addNode(link);
	                }
	                // 为了 线上点击之后显示那些附加的小图标
	                link.on("click",function(){
	                    for(var i = 0;i < line.icons.length;i++){
	                        if (line.icons[i][0] == 'delete') {
	                            fishTopoflow.addLineDeleteIcon(link);
	                        }else if(line.icons[i][0] == 'change'){
	                            fishTopoflow.addLineChangeIcon(link);
	                        }else{
	                            fishTopoflow.addIcon(line.icons[i][0],{
	                                icon:line.icons[i][1].icon,
	                                width: line.icons[i][1].width,
	                                height: line.icons[i][1].height,
	                                lineNode:link
	                            })
	                        }
	
	                    }
	                })
	
	            };
	        }
	    }
	
	    /**
	     * 根据id在group中查找
	     * @param  {[type]} group  [description]
	     * @param  {[type]} nodeId [description]
	     * @return {[type]}        [description]
	     */
	    function findNodeById (group, nodeId) {
	        var retNode = null;
	        group.eachChild(function(node) {
	            if (node.model && node.model.get(Constants.ID) === nodeId) {
	                retNode = node;
	            };
	        })
	        return retNode;
	    }
	
	
	    /**
	     * Get canvas which has all thing rendered
	     * @param {Object} opts
	     * @param {string} [opts.backgroundColor]
	     */
	    function getRenderedCanvas(zr, opts) {
	        opts = opts || {};
	        opts.pixelRatio = opts.pixelRatio || 1;
	        opts.backgroundColor = opts.backgroundColor
	            || "#FFFFFF";
	        var list = zr.storage.getDisplayList();
	        // Stop animations
	        zrUtil.each(list, function (el) {
	            el.stopAnimation(true);
	        });
	        return zr.painter.getRenderedCanvas(opts);
	    }
	
	    function toDataURL (zr, opts) {
	        opts = opts || {};
	        var url = getRenderedCanvas(zr, opts).toDataURL(
	            'image/' + (opts && opts.type || 'png')
	        );
	        return url;
	    }
	
	
	    function initNodeEvent (node, api) {
	        var MOUSE_EVENT_NAMES = ['dblclick', 'click'];//'click', 'dblclick', 'mouseover', 'mouseout'
	
	
	        zrUtil.each(MOUSE_EVENT_NAMES, function (eveName) {
	            node.on(eveName, function (e) {
	                var params = {};
	                params.event = e;
	                params.type = eveName;
	                params.target = node;
	                api.trigger(eveName, params);
	            });
	        });
	    }
	
	    module.exports = {
	        toJson: toJson,
	        fromJson: fromJson,
	        toDataURL:toDataURL
	    };
	


/***/ },
/* 93 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * 连线操作类
	 * @author miao.cunzhi
	 */
	
		var Node = __webpack_require__(76);
		var Util = __webpack_require__(59);
		var graphic = __webpack_require__(3);
	    var Point = __webpack_require__(60);
	    var zrUtil = __webpack_require__(4);
	    var ConnectionManager = __webpack_require__(84);
	    var LineOperationManager = {
	        LineOperations:[],
	        isEdit:true,
	        creatOperation:function(key,obj,api){
	            var lineOperation = new graphic.Image({
	                style: {
	                    image:obj.icon,
	                    width: obj.width||15,
	                    height: obj.height||15
	                }
	            });
	            lineOperation.key = key;
	            lineOperation.operation = true;
	            lineOperation.hide();
	            obj.lineNode.icons.push(lineOperation);
	            LineOperationManager.LineOperations.push(lineOperation);
	
	            //小图标 点击事件  如果有回调则调用回调，否则派发事件
	            lineOperation.on("click",function(e){
	                if(obj.callback){
	                    obj.callback(obj.lineNode);
	                } else {
	                    var params = {};
	                    params.event = e;
	                    params.type = "click";
	                    params.elementType = "LineOperationIcon";
	                    api.trigger(params.type, params);
	                }
	
	            });
	            return lineOperation;
	        },
	
	        /**
	         * 计算小图标的位置，并显示
	         * @param  {[type]} connector [description]
	         * @return {[type]}           [description]
	         */
	        bindOperation:function(connector){
	            if(LineOperationManager.isEdit == false){return;}
	            var pointPosition = connector.middle();
	            var length = [];
	            for(var j = 0; j < connector.icons.length; j++){
	                length.push(connector.icons[j].style.width);
	            }
	            var totalLength = 0;
	            for(var m = 0; m < connector.icons.length; m++){
	                    totalLength += length[m]+10;
	            }
	            for(var i = 0; i < connector.icons.length; i++){
	                var connectorPosition = 0;
	                for(var k = 0; k < i; k++){
	                    connectorPosition += length[k]+10;
	                }
	                connector.icons[i].attr("position",[pointPosition[0]+connectorPosition-totalLength/2,pointPosition[1]+5]);
	                connector.icons[i].show();
	            }
	        },
	
	        hideAllLineOperation: function() {
	            for (var li = 0; li < LineOperationManager.LineOperations.length; li++) {
	                var icon =  LineOperationManager.LineOperations[li];
	                icon.hide();
	            }
	        },
	
	        addIcon: function(key, obj, zr, api) {
	            //判断是小图标否存在 ，存在则直接返回
	            if(obj.lineNode.icons){
	                for (var i = 0; i < obj.lineNode.icons.length; i++) {
	                    if (obj.lineNode.icons[i].key == key) {
	                        LineOperationManager.bindOperation(obj.lineNode);
	                        return;
	                    }
	                }
	            }
	
	            var lineOperation = LineOperationManager.creatOperation(key, obj, api);
	            zr.add(lineOperation);
	            LineOperationManager.bindOperation(obj.lineNode);
	            return lineOperation;
	        },
	
	        deleteIconObj: function(parentZr,lineNode) {
	            return {
	                icon:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAwAAAAOBAMAAADpk+DfAAAABGdBTUEAALGPC/xhBQAAAAFzUkdCAK7OHOkAAAAtUExURQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMGgKD4AAAAPdFJOUwDH/g+agESj4Y6zUiRnh7lnwbkAAABLSURBVAjXY2BgYDZgAIEnnkCa7a5cYGwCwwklIOhhMBEEgmIGnlAgOMDAprhQUGgDA5vWdJciXJRGR0dTAgPzQ0FBSaBpzMbGBgwAIoUW3sQ2EdkAAAAASUVORK5CYII=",
	                width: 12,
	                height: 14,
	                lineNode:lineNode,
	                callback:function(e) {
	                    for(var i = 0; i<lineNode.icons.length;i++){
	                        parentZr.remove(lineNode.icons[i])
	                    }
	                    ConnectionManager.deleteLine(parentZr);
	                    LineOperationManager.hideAllLineOperation();
	                    e.cancelBubble = true;
	                }
	            }
	        }
	
	    };
	
		module.exports = LineOperationManager;
	


/***/ },
/* 94 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Flow静态方法类
	 * @class fish.topo.FishTopoFlow.Flow
	 */
	
	
	    var Constants = __webpack_require__(86);
	    var Flow = {
	        FLOW_TYPE: "elementType",
	        LINK: "connection",
	        RECT: "Rect",
	        Group: 'Group',
	        IMAGE: 'Image',
	        TEXT: 'Text',
	        CIRCLE: 'Circle',
	        SECTOR: 'Sector',
	        RING: 'Ring',
	        POLYGON: 'Polygon',
	        POLYLINE: 'Polyline',
	        LINE: 'Line',
	        BEZIERCURVE: 'Beziercurve',
	        ARC: 'Arc',
	        SCENE:'scene',
	
	        /**
	         * @method setUserData
	         * 设置用户数据
	         * @param {Object} node 需要设置数据的节点
	         * @param {Object} obj 数据
	         * **使用范例**：
	         *
	         *      @example
	         *      //设置自定义数据
	         *      this.fishTopo.Flow.setUserData(rect, { customObj: "rect" });
	         */
	        setUserData: function(node, obj) {
	            node.model.set(Constants.USERDATA, obj);
	        },
	        /**
	         * 获取设置的用户数据
	         * @param {Object} node 需要获取数据的节点
	         * @return {String}      数据
	         * **使用范例**：
	         *
	         *      @example
	         *      //获取自定义数据
	         *      this.fishTopo.Flow.getUserData(rect);
	         */
	        getUserData: function(node) {
	            return node.model.get(Constants.USERDATA);
	        },
	        /**
	         * 判断是否是连线
	         * @param {Object} model 对象的model
	         * @return {Boolean}      是 否
	         * **使用范例**：
	         *
	         *      @example
	         *      //判断是否是连线
	         *      var nodeModel = e.target.model;
	         *      if (this.fishTopo.Flow.isLink(nodeModel)) { return true;}
	         */
	        isLink: function(model) {
	            var elementType = model.get(Flow.FLOW_TYPE);
	            return elementType == Flow.LINK;
	        },
	        /**
	         * 判断是否是节点
	         * @param {Object} model 对象的model
	         * @return {Boolean}      是 否
	         * **使用范例**：
	         *
	         *      @example
	         *      //判断是否是节点
	         *      var nodeModel = e.target.model;
	         *      if (this.fishTopo.Flow.isNode(nodeModel)) { return true;}
	         */
	
	        isNode: function(model) {
	            var elementType = model.get(Flow.FLOW_TYPE);
	            var isNode;
	            if(elementType !=  Flow.LINK && elementType !=  Flow.SCENE){
	                isNode = true;
	            }else{
	                isNode = false;
	            }
	            return isNode;
	        },
	
	        /**
	         * 判断节点是否是矩形节点
	         * @param {Object} model 节点的model
	         * @return {Boolean}      是 否
	         * **使用范例**：
	         *
	         *      @example
	         *      //判断是否是矩形节点
	         *      var nodeModel = e.target.model;
	         *      if (this.fishTopo.Flow.isRect(nodeModel)) { return true;}
	         */
	        isRect: function(model) {
	            var elementType = model.get(Flow.FLOW_TYPE);
	            return  elementType == Flow.RECT;
	        },
	        /**
	         * 判断节点是否是图片节点
	         * @param {Object} model 节点的model
	         * @return {Boolean}      是 否
	         * **使用范例**：
	         *
	         *      @example
	         *      //判断是否是图片节点
	         *      var nodeModel = e.target.model;
	         *      if (this.fishTopo.Flow.isImage(nodeModel)) { return true;}
	         */
	        isImage: function(model) {
	            var elementType = model.get(Flow.FLOW_TYPE);
	            return elementType == Flow.IMAGE;
	        },
	        /**
	         * 判断节点是否是文字节点
	         * @param {Object} model 节点的model
	         * @return {Boolean}      是 否
	         * **使用范例**：
	         *
	         *      @example
	         *      //判断是否是文字节点
	         *      var nodeModel = e.target.model;
	         *      if (this.fishTopo.Flow.isText(nodeModel)) { return true;}
	         */
	        isText: function(model) {
	            var elementType = model.get(Flow.FLOW_TYPE);
	            return elementType == Flow.TEXT;
	        },
	        /**
	         * 判断节点是否是圆形节点
	         * @param {Object} model 节点的model
	         * @return {Boolean}      是 否
	         * **使用范例**：
	         *
	         *      @example
	         *      //判断是否是圆形节点
	         *      var nodeModel = e.target.model;
	         *      if (this.fishTopo.Flow.isCircle(nodeModel)) { return true;}
	         */
	        isCircle: function(model) {
	            var elementType = model.get(Flow.FLOW_TYPE);
	            return elementType == Flow.CIRCLE;
	        },
	        /**
	         * 获取节点的类型
	         * @param {Object} model 节点的model
	         * **使用范例**：
	         *
	         *      @example
	         *      //获取节点类型
	         *      var nodeModel = e.target.model;
	         *      return this.fishTopo.Flow.getType(nodeModel);
	         */
	        getType: function(model) {
	            var elementType = model.get(Flow.FLOW_TYPE);
	            return elementType;
	        }
	    };
	
	    module.exports = Flow;
	


/***/ },
/* 95 */
/***/ function(module, exports) {

	
	    //单例
	    var instance = null;
	    var emptyFn = function() {};
	    //初始默认配置
	    var config_default = {
	        //线程池"线程"数量
	        thread: 5,
	        //图片加载失败重试次数
	        //重试2次，加上原有的一次，总共是3次
	        "tries": 2
	    };
	    //工具
	    var _helpers = {
	        //设置dom属性
	        setAttr: (function() {
	            var img = new Image();
	            //判断浏览器是否支持HTML5 dataset
	            if (img.dataset) {
	                return function(dom, name, value) {
	                    dom.dataset[name] = value;
	                    return value;
	                };
	            } else {
	                return function(dom, name, value) {
	                    dom.setAttribute("data-" + name, value);
	                    return value;
	                };
	            }
	        }()),
	        //获取dom属性
	        getAttr: (function() {
	            var img = new Image();
	            //判断浏览器是否支持HTML5 dataset
	            if (img.dataset) {
	                return function(dom, name) {
	                    if(!dom.dataset[name]){
	                        return dom.getAttribute("data-" + name);
	                    }else{
	                        return dom.dataset[name];
	                    }
	                };
	            } else {
	                return function(dom, name) {
	                    return dom.getAttribute("data-" + name);
	                };
	            }
	        }())
	    };
	    /**
	     * 构造方法
	     * @param max 最大连接数。数值。
	     */
	    function ImagePool(max) {
	        //最大并发数量
	        this.max = max || config_default.thread;
	        this.linkHead = null;
	        this.linkNode = null;
	        //加载池
	        //[{img: dom,free: true, node: node}]
	        //node
	        //{src: "", options: {success: "fn",error: "fn", once: true}, tries: 0}
	        this.pool = [];
	    }
	    /**
	     * 初始化
	     */
	    ImagePool.prototype.initPool = function() {
	        var i, img, obj, _s;
	        _s = this;
	        for (i = 0; i < this.max; i++) {
	            obj = {};
	            img = new Image();
	            _helpers.setAttr(img, "id", i);
	            img.onload = function() {
	                var id, src;
	                //回调
	                _s.notice(_s.getNode(this), "success", this);
	                //处理任务
	                _s.executeLink(this);
	            };
	            img.onerror = function() {
	                var node = _s.getNode(this);
	                //判断尝试次数
	                if (node.tries < config_default.tries) {
	                    node.tries = node.tries+1;
	                    //再次追加到任务链表末尾
	                    _s.appendNode(_s.createNode(node.src, node.options, node.notice, node.group, node.tries));
	                } else {
	                    //error回调
	                    //node.options.error.call(null, this.src);
	                    _s.notice(node, "error", this);
	                }
	                //处理任务
	                _s.executeLink(this);
	            };
	            obj.img = img;
	            obj.free = true;
	            this.pool.push(obj);
	        }
	    };
	    /**
	     * 回调封装
	     * @param node 节点。对象。
	     * @param status 状态。字符串。可选值：success(成功)|error(失败)
	     * @param img 图片。
	     */
	    ImagePool.prototype.notice = function(node, status, img) {
	        node.notice(status, img);
	    };
	    /**
	     * 处理链表任务
	     * @param dom 图像dom对象。对象。
	     */
	    ImagePool.prototype.executeLink = function(dom) {
	        //判断链表是否存在节点
	        if (this.linkHead) {
	            //加载下一个图片
	            this.setSrc(dom, this.linkHead);
	            //去除链表头
	            this.shiftNode();
	        } else {
	            //设置自身状态为空闲
	            this.status(dom, true);
	        }
	    };
	    /**
	     * 获取空闲"线程"
	     */
	    ImagePool.prototype.getFree = function() {
	        var length, i;
	        for (i = 0, length = this.pool.length; i < length; i++) {
	            if (this.pool[i].free) {
	                return this.pool[i];
	            }
	        }
	        return null;
	    };
	    /**
	     * 封装src属性设置
	     * 因为改变src属性相当于加载图片，所以把操作封装起来
	     * @param dom 图像dom对象。对象。
	     * @param node 节点。对象。
	     */
	    ImagePool.prototype.setSrc = function(dom, node) {
	        //设置池中的"线程"为非空闲状态
	        this.status(dom, false);
	        //关联节点
	        this.setNode(dom, node);
	        //加载图片
	        dom.src = node.src;
	    };
	    /**
	     * 更新池中的"线程"状态
	     * @param dom 图像dom对象。对象。
	     * @param status 状态。布尔。可选值：true(空闲)|false(非空闲)
	     */
	    ImagePool.prototype.status = function(dom, status) {
	        var id = _helpers.getAttr(dom, "id");
	        if(id){
	            this.pool[id].free = status;
	        }
	        
	        //空闲状态，清除关联的节点
	        if (status) {
	            this.pool[id].node = null;
	        }
	    };
	    /**
	     * 更新池中的"线程"的关联节点
	     * @param dom 图像dom对象。对象。
	     * @param node 节点。对象。
	     */
	    ImagePool.prototype.setNode = function(dom, node) {
	        var id = _helpers.getAttr(dom, "id");
	        if(id){
	            this.pool[id].node = node;
	            return this.pool[id].node === node;
	        }
	        
	    };
	    /**
	     * 获取池中的"线程"的关联节点
	     * @param dom 图像dom对象。对象。
	     */
	    ImagePool.prototype.getNode = function(dom) {
	        var id = _helpers.getAttr(dom, "id");
	        if(id){
	            return this.pool[id].node;
	        }
	        
	    };
	    /**
	     * 对外接口，加载图片
	     * @param src 可以是src字符串，也可以是src字符串数组。
	     * @param options 用户自定义参数。包含：success回调、error回调、once标识。
	     */
	    ImagePool.prototype.load = function(src, options) {
	        var srcs = [],
	            free = null,
	            length = 0,
	            i = 0,
	            //只初始化一次回调策略
	            notice = (function() {
	                if (options.once) {
	                    return function(status, img) {
	                        var g = this.group,
	                            o = this.options;
	                        //记录
	                        g[status].push(img);
	                        //判断改组是否全部处理完成
	                        if (g.success.length + g.error.length === g.count) {
	                            //异步
	                            //实际上是作为另一个任务单独执行，防止回调函数执行时间过长影响图片加载速度
	                            setTimeout(function() {
	                                o.success.call(null, g.success, g.error, g.count);
	                            }, 1);
	                        }
	                    };
	                } else {
	                    return function(status, img) {
	                        var o = this.options;
	                        //直接回调
	                        setTimeout(function() {
	                            o[status].call(null, img);
	                        }, 1);
	                    };
	                }
	            }()),
	            group = {
	                count: 0,
	                success: [],
	                error: []
	            },
	            node = null;
	        options = options || {};
	        options.success = options.success || emptyFn;
	        options.error = options.error || emptyFn;
	        srcs = srcs.concat(src);
	        //设置组元素个数
	        group.count = srcs.length;
	        //遍历需要加载的图片
	        for (i = 0, length = srcs.length; i < length; i++) {
	            //创建节点
	            node = this.createNode(srcs[i], options, notice, group);
	            //判断线程池是否有空闲
	            free = this.getFree();
	            if (free) {
	                //有空闲，则立即加载图片
	                this.setSrc(free.img, node);
	            } else {
	                //没有空闲，将任务添加到链表
	                this.appendNode(node);
	            }
	        }
	    };
	    /**
	     * 获取内部状态信息
	     * @returns {{}}
	     */
	    ImagePool.prototype.info = function() {
	        var info = {},
	            length = 0,
	            i = 0,
	            node = null;
	        //线程
	        info.thread = {};
	        //线程总数量
	        info.thread.count = this.pool.length;
	        //空闲线程数量
	        info.thread.free = 0;
	        //任务
	        info.task = {};
	        //待处理任务数量
	        info.task.count = 0;
	        //获取空闲"线程"数量
	        for (i = 0, length = this.pool.length; i < length; i++) {
	            if (this.pool[i].free) {
	                info.thread.free = info.thread.free + 1;
	            }
	        }
	        //获取任务数量(任务链长度)
	        node = this.linkHead;
	        if (node) {
	            info.task.count = info.task.count + 1;
	            while (node.next) {
	                info.task.count = info.task.count + 1;
	                node = node.next;
	            }
	        }
	        return info;
	    };
	    /**
	     * 创建节点
	     * @param src 图片路径。字符串。
	     * @param options 用户自定义参数。包含：success回调、error回调、once标识。
	     * @param notice 回调策略。 函数。
	     * @param group 组信息。对象。{count: 0, success: [], error: []}
	     * @param tr 出错重试次数。数值。默认为0。
	     * @returns {{}}
	     */
	    ImagePool.prototype.createNode = function(src, options, notice, group, tr) {
	        var node = {};
	        node.src = src;
	        node.options = options;
	        node.notice = notice;
	        node.group = group;
	        node.tries = tr || 0;
	        return node;
	    };
	    /**
	     * 向任务链表末尾追加节点
	     * @param node 节点。对象。
	     */
	    ImagePool.prototype.appendNode = function(node) {
	        //判断链表是否为空
	        if (!this.linkHead) {
	            this.linkHead = node;
	            this.linkNode = node;
	        } else {
	            this.linkNode.next = node;
	            this.linkNode = node;
	        }
	    };
	    /**
	     * 删除链表头
	     */
	    ImagePool.prototype.shiftNode = function() {
	        //判断链表是否存在节点
	        if (this.linkHead) {
	            //修改链表头
	            this.linkHead = this.linkHead.next || null;
	        }
	    };
	    /**
	     * 导出对外接口
	     * @param max 最大连接数。数值。
	     * @returns {{load: Function, info: Function}}
	     */
	    var initImagePool = function(max) {
	        if (!instance) {
	            instance = new ImagePool(max);
	            instance.initPool();
	        }
	        return {
	            /**
	             * 加载图片
	             */
	            load: function() {
	                instance.load.apply(instance, arguments);
	            },
	            /**
	             * 内部信息
	             * @returns {*|any|void}
	             */
	            info: function() {
	                return instance.info.call(instance);
	            }
	        };
	    };
	
	    module.exports = { initImagePool: initImagePool }
	


/***/ },
/* 96 */
/***/ function(module, exports, __webpack_require__) {

	
	    __webpack_require__(97);
	    __webpack_require__(63).registerPainter('vml', __webpack_require__(99));


/***/ },
/* 97 */
/***/ function(module, exports, __webpack_require__) {

	// http://www.w3.org/TR/NOTE-VML
	// TODO Use proxy like svg instead of overwrite brush methods
	
	
	if (!__webpack_require__(64).canvasSupported) {
	    var vec2 = __webpack_require__(14);
	    var BoundingRect = __webpack_require__(24);
	    var CMD = __webpack_require__(25).CMD;
	    var colorTool = __webpack_require__(19);
	    var textContain = __webpack_require__(23);
	    var RectText = __webpack_require__(22);
	    var Displayable = __webpack_require__(7);
	    var ZImage = __webpack_require__(40);
	    var Text = __webpack_require__(42);
	    var Path = __webpack_require__(6);
	
	    var Gradient = __webpack_require__(37);
	
	    var vmlCore = __webpack_require__(98);
	
	    var round = Math.round;
	    var sqrt = Math.sqrt;
	    var abs = Math.abs;
	    var cos = Math.cos;
	    var sin = Math.sin;
	    var mathMax = Math.max;
	
	    var applyTransform = vec2.applyTransform;
	
	    var comma = ',';
	    var imageTransformPrefix = 'progid:DXImageTransform.Microsoft';
	
	    var Z = 21600;
	    var Z2 = Z / 2;
	
	    var ZLEVEL_BASE = 100000;
	    var Z_BASE = 1000;
	
	    var initRootElStyle = function (el) {
	        el.style.cssText = 'position:absolute;left:0;top:0;width:1px;height:1px;';
	        el.coordsize = Z + ','  + Z;
	        el.coordorigin = '0,0';
	    };
	
	    var encodeHtmlAttribute = function (s) {
	        return String(s).replace(/&/g, '&amp;').replace(/"/g, '&quot;');
	    };
	
	    var rgb2Str = function (r, g, b) {
	        return 'rgb(' + [r, g, b].join(',') + ')';
	    };
	
	    var append = function (parent, child) {
	        if (child && parent && child.parentNode !== parent) {
	            parent.appendChild(child);
	        }
	    };
	
	    var remove = function (parent, child) {
	        if (child && parent && child.parentNode === parent) {
	            parent.removeChild(child);
	        }
	    };
	
	    var getZIndex = function (zlevel, z, z2) {
	        // z 的取值范围为 [0, 1000]
	        return (parseFloat(zlevel) || 0) * ZLEVEL_BASE + (parseFloat(z) || 0) * Z_BASE + z2;
	    };
	
	    var parsePercent = function (value, maxValue) {
	        if (typeof value === 'string') {
	            if (value.lastIndexOf('%') >= 0) {
	                return parseFloat(value) / 100 * maxValue;
	            }
	            return parseFloat(value);
	        }
	        return value;
	    };
	
	    /***************************************************
	     * PATH
	     **************************************************/
	
	    var setColorAndOpacity = function (el, color, opacity) {
	        var colorArr = colorTool.parse(color);
	        opacity = +opacity;
	        if (isNaN(opacity)) {
	            opacity = 1;
	        }
	        if (colorArr) {
	            el.color = rgb2Str(colorArr[0], colorArr[1], colorArr[2]);
	            el.opacity = opacity * colorArr[3];
	        }
	    };
	
	    var getColorAndAlpha = function (color) {
	        var colorArr = colorTool.parse(color);
	        return [
	            rgb2Str(colorArr[0], colorArr[1], colorArr[2]),
	            colorArr[3]
	        ];
	    };
	
	    var updateFillNode = function (el, style, zrEl) {
	        // TODO pattern
	        var fill = style.fill;
	        if (fill != null) {
	            // Modified from excanvas
	            if (fill instanceof Gradient) {
	                var gradientType;
	                var angle = 0;
	                var focus = [0, 0];
	                // additional offset
	                var shift = 0;
	                // scale factor for offset
	                var expansion = 1;
	                var rect = zrEl.getBoundingRect();
	                var rectWidth = rect.width;
	                var rectHeight = rect.height;
	                if (fill.type === 'linear') {
	                    gradientType = 'gradient';
	                    var transform = zrEl.transform;
	                    var p0 = [fill.x * rectWidth, fill.y * rectHeight];
	                    var p1 = [fill.x2 * rectWidth, fill.y2 * rectHeight];
	                    if (transform) {
	                        applyTransform(p0, p0, transform);
	                        applyTransform(p1, p1, transform);
	                    }
	                    var dx = p1[0] - p0[0];
	                    var dy = p1[1] - p0[1];
	                    angle = Math.atan2(dx, dy) * 180 / Math.PI;
	                    // The angle should be a non-negative number.
	                    if (angle < 0) {
	                        angle += 360;
	                    }
	
	                    // Very small angles produce an unexpected result because they are
	                    // converted to a scientific notation string.
	                    if (angle < 1e-6) {
	                        angle = 0;
	                    }
	                }
	                else {
	                    gradientType = 'gradientradial';
	                    var p0 = [fill.x * rectWidth, fill.y * rectHeight];
	                    var transform = zrEl.transform;
	                    var scale = zrEl.scale;
	                    var width = rectWidth;
	                    var height = rectHeight;
	                    focus = [
	                        // Percent in bounding rect
	                        (p0[0] - rect.x) / width,
	                        (p0[1] - rect.y) / height
	                    ];
	                    if (transform) {
	                        applyTransform(p0, p0, transform);
	                    }
	
	                    width /= scale[0] * Z;
	                    height /= scale[1] * Z;
	                    var dimension = mathMax(width, height);
	                    shift = 2 * 0 / dimension;
	                    expansion = 2 * fill.r / dimension - shift;
	                }
	
	                // We need to sort the color stops in ascending order by offset,
	                // otherwise IE won't interpret it correctly.
	                var stops = fill.colorStops.slice();
	                stops.sort(function(cs1, cs2) {
	                    return cs1.offset - cs2.offset;
	                });
	
	                var length = stops.length;
	                // Color and alpha list of first and last stop
	                var colorAndAlphaList = [];
	                var colors = [];
	                for (var i = 0; i < length; i++) {
	                    var stop = stops[i];
	                    var colorAndAlpha = getColorAndAlpha(stop.color);
	                    colors.push(stop.offset * expansion + shift + ' ' + colorAndAlpha[0]);
	                    if (i === 0 || i === length - 1) {
	                        colorAndAlphaList.push(colorAndAlpha);
	                    }
	                }
	
	                if (length >= 2) {
	                    var color1 = colorAndAlphaList[0][0];
	                    var color2 = colorAndAlphaList[1][0];
	                    var opacity1 = colorAndAlphaList[0][1] * style.opacity;
	                    var opacity2 = colorAndAlphaList[1][1] * style.opacity;
	
	                    el.type = gradientType;
	                    el.method = 'none';
	                    el.focus = '100%';
	                    el.angle = angle;
	                    el.color = color1;
	                    el.color2 = color2;
	                    el.colors = colors.join(',');
	                    // When colors attribute is used, the meanings of opacity and o:opacity2
	                    // are reversed.
	                    el.opacity = opacity2;
	                    // FIXME g_o_:opacity ?
	                    el.opacity2 = opacity1;
	                }
	                if (gradientType === 'radial') {
	                    el.focusposition = focus.join(',');
	                }
	            }
	            else {
	                // FIXME Change from Gradient fill to color fill
	                setColorAndOpacity(el, fill, style.opacity);
	            }
	        }
	    };
	
	    var updateStrokeNode = function (el, style) {
	        // if (style.lineJoin != null) {
	        //     el.joinstyle = style.lineJoin;
	        // }
	        // if (style.miterLimit != null) {
	        //     el.miterlimit = style.miterLimit * Z;
	        // }
	        // if (style.lineCap != null) {
	        //     el.endcap = style.lineCap;
	        // }
	        if (style.lineDash != null) {
	            el.dashstyle = style.lineDash.join(' ');
	        }
	        if (style.stroke != null && !(style.stroke instanceof Gradient)) {
	            setColorAndOpacity(el, style.stroke, style.opacity);
	        }
	    };
	
	    var updateFillAndStroke = function (vmlEl, type, style, zrEl) {
	        var isFill = type == 'fill';
	        var el = vmlEl.getElementsByTagName(type)[0];
	        // Stroke must have lineWidth
	        if (style[type] != null && style[type] !== 'none' && (isFill || (!isFill && style.lineWidth))) {
	            vmlEl[isFill ? 'filled' : 'stroked'] = 'true';
	            // FIXME Remove before updating, or set `colors` will throw error
	            if (style[type] instanceof Gradient) {
	                remove(vmlEl, el);
	            }
	            if (!el) {
	                el = vmlCore.createNode(type);
	            }
	
	            isFill ? updateFillNode(el, style, zrEl) : updateStrokeNode(el, style);
	            append(vmlEl, el);
	        }
	        else {
	            vmlEl[isFill ? 'filled' : 'stroked'] = 'false';
	            remove(vmlEl, el);
	        }
	    };
	
	    var points = [[], [], []];
	    var pathDataToString = function (data, m) {
	        var M = CMD.M;
	        var C = CMD.C;
	        var L = CMD.L;
	        var A = CMD.A;
	        var Q = CMD.Q;
	
	        var str = [];
	        var nPoint;
	        var cmdStr;
	        var cmd;
	        var i;
	        var xi;
	        var yi;
	        for (i = 0; i < data.length;) {
	            cmd = data[i++];
	            cmdStr = '';
	            nPoint = 0;
	            switch (cmd) {
	                case M:
	                    cmdStr = ' m ';
	                    nPoint = 1;
	                    xi = data[i++];
	                    yi = data[i++];
	                    points[0][0] = xi;
	                    points[0][1] = yi;
	                    break;
	                case L:
	                    cmdStr = ' l ';
	                    nPoint = 1;
	                    xi = data[i++];
	                    yi = data[i++];
	                    points[0][0] = xi;
	                    points[0][1] = yi;
	                    break;
	                case Q:
	                case C:
	                    cmdStr = ' c ';
	                    nPoint = 3;
	                    var x1 = data[i++];
	                    var y1 = data[i++];
	                    var x2 = data[i++];
	                    var y2 = data[i++];
	                    var x3;
	                    var y3;
	                    if (cmd === Q) {
	                        // Convert quadratic to cubic using degree elevation
	                        x3 = x2;
	                        y3 = y2;
	                        x2 = (x2 + 2 * x1) / 3;
	                        y2 = (y2 + 2 * y1) / 3;
	                        x1 = (xi + 2 * x1) / 3;
	                        y1 = (yi + 2 * y1) / 3;
	                    }
	                    else {
	                        x3 = data[i++];
	                        y3 = data[i++];
	                    }
	                    points[0][0] = x1;
	                    points[0][1] = y1;
	                    points[1][0] = x2;
	                    points[1][1] = y2;
	                    points[2][0] = x3;
	                    points[2][1] = y3;
	
	                    xi = x3;
	                    yi = y3;
	                    break;
	                case A:
	                    var x = 0;
	                    var y = 0;
	                    var sx = 1;
	                    var sy = 1;
	                    var angle = 0;
	                    if (m) {
	                        // Extract SRT from matrix
	                        x = m[4];
	                        y = m[5];
	                        sx = sqrt(m[0] * m[0] + m[1] * m[1]);
	                        sy = sqrt(m[2] * m[2] + m[3] * m[3]);
	                        angle = Math.atan2(-m[1] / sy, m[0] / sx);
	                    }
	
	                    var cx = data[i++];
	                    var cy = data[i++];
	                    var rx = data[i++];
	                    var ry = data[i++];
	                    var startAngle = data[i++] + angle;
	                    var endAngle = data[i++] + startAngle + angle;
	                    // FIXME
	                    // var psi = data[i++];
	                    i++;
	                    var clockwise = data[i++];
	
	                    var x0 = cx + cos(startAngle) * rx;
	                    var y0 = cy + sin(startAngle) * ry;
	
	                    var x1 = cx + cos(endAngle) * rx;
	                    var y1 = cy + sin(endAngle) * ry;
	
	                    var type = clockwise ? ' wa ' : ' at ';
	                    if (Math.abs(x0 - x1) < 1e-10) {
	                        // IE won't render arches drawn counter clockwise if x0 == x1.
	                        if (Math.abs(endAngle - startAngle) > 1e-2) {
	                            // Offset x0 by 1/80 of a pixel. Use something
	                            // that can be represented in binary
	                            if (clockwise) {
	                                x0 += 270 / Z;
	                            }
	                        }
	                        else {
	                            // Avoid case draw full circle
	                            if (Math.abs(y0 - cy) < 1e-10) {
	                                if ((clockwise && x0 < cx) || (!clockwise && x0 > cx)) {
	                                    y1 -= 270 / Z;
	                                }
	                                else {
	                                    y1 += 270 / Z;
	                                }
	                            }
	                            else if ((clockwise && y0 < cy) || (!clockwise && y0 > cy)) {
	                                x1 += 270 / Z;
	                            }
	                            else {
	                                x1 -= 270 / Z;
	                            }
	                        }
	                    }
	                    str.push(
	                        type,
	                        round(((cx - rx) * sx + x) * Z - Z2), comma,
	                        round(((cy - ry) * sy + y) * Z - Z2), comma,
	                        round(((cx + rx) * sx + x) * Z - Z2), comma,
	                        round(((cy + ry) * sy + y) * Z - Z2), comma,
	                        round((x0 * sx + x) * Z - Z2), comma,
	                        round((y0 * sy + y) * Z - Z2), comma,
	                        round((x1 * sx + x) * Z - Z2), comma,
	                        round((y1 * sy + y) * Z - Z2)
	                    );
	
	                    xi = x1;
	                    yi = y1;
	                    break;
	                case CMD.R:
	                    var p0 = points[0];
	                    var p1 = points[1];
	                    // x0, y0
	                    p0[0] = data[i++];
	                    p0[1] = data[i++];
	                    // x1, y1
	                    p1[0] = p0[0] + data[i++];
	                    p1[1] = p0[1] + data[i++];
	
	                    if (m) {
	                        applyTransform(p0, p0, m);
	                        applyTransform(p1, p1, m);
	                    }
	
	                    p0[0] = round(p0[0] * Z - Z2);
	                    p1[0] = round(p1[0] * Z - Z2);
	                    p0[1] = round(p0[1] * Z - Z2);
	                    p1[1] = round(p1[1] * Z - Z2);
	                    str.push(
	                        // x0, y0
	                        ' m ', p0[0], comma, p0[1],
	                        // x1, y0
	                        ' l ', p1[0], comma, p0[1],
	                        // x1, y1
	                        ' l ', p1[0], comma, p1[1],
	                        // x0, y1
	                        ' l ', p0[0], comma, p1[1]
	                    );
	                    break;
	                case CMD.Z:
	                    // FIXME Update xi, yi
	                    str.push(' x ');
	            }
	
	            if (nPoint > 0) {
	                str.push(cmdStr);
	                for (var k = 0; k < nPoint; k++) {
	                    var p = points[k];
	
	                    m && applyTransform(p, p, m);
	                    // 不 round 会非常慢
	                    str.push(
	                        round(p[0] * Z - Z2), comma, round(p[1] * Z - Z2),
	                        k < nPoint - 1 ? comma : ''
	                    );
	                }
	            }
	        }
	
	        return str.join('');
	    };
	
	    // Rewrite the original path method
	    Path.prototype.brushVML = function (vmlRoot) {
	        var style = this.style;
	
	        var vmlEl = this._vmlEl;
	        if (!vmlEl) {
	            vmlEl = vmlCore.createNode('shape');
	            initRootElStyle(vmlEl);
	
	            this._vmlEl = vmlEl;
	        }
	
	        updateFillAndStroke(vmlEl, 'fill', style, this);
	        updateFillAndStroke(vmlEl, 'stroke', style, this);
	
	        var m = this.transform;
	        var needTransform = m != null;
	        var strokeEl = vmlEl.getElementsByTagName('stroke')[0];
	        if (strokeEl) {
	            var lineWidth = style.lineWidth;
	            // Get the line scale.
	            // Determinant of this.m_ means how much the area is enlarged by the
	            // transformation. So its square root can be used as a scale factor
	            // for width.
	            if (needTransform && !style.strokeNoScale) {
	                var det = m[0] * m[3] - m[1] * m[2];
	                lineWidth *= sqrt(abs(det));
	            }
	            strokeEl.weight = lineWidth + 'px';
	        }
	
	        var path = this.path;
	        if (this.__dirtyPath) {
	            path.beginPath();
	            this.buildPath(path, this.shape);
	            path.toStatic();
	            this.__dirtyPath = false;
	        }
	
	        vmlEl.path = pathDataToString(path.data, this.transform);
	
	        vmlEl.style.zIndex = getZIndex(this.zlevel, this.z, this.z2);
	
	        // Append to root
	        append(vmlRoot, vmlEl);
	
	        // Text
	        if (style.text) {
	            this.drawRectText(vmlRoot, this.getBoundingRect());
	        }
	        else {
	            this.removeRectText(vmlRoot);
	        }
	    };
	
	    Path.prototype.onRemove = function (vmlRoot) {
	        remove(vmlRoot, this._vmlEl);
	        this.removeRectText(vmlRoot);
	    };
	
	    Path.prototype.onAdd = function (vmlRoot) {
	        append(vmlRoot, this._vmlEl);
	        this.appendRectText(vmlRoot);
	    };
	
	    /***************************************************
	     * IMAGE
	     **************************************************/
	    var isImage = function (img) {
	        // FIXME img instanceof Image 如果 img 是一个字符串的时候，IE8 下会报错
	        return (typeof img === 'object') && img.tagName && img.tagName.toUpperCase() === 'IMG';
	        // return img instanceof Image;
	    };
	
	    // Rewrite the original path method
	    ZImage.prototype.brushVML = function (vmlRoot) {
	        var style = this.style;
	        var image = style.image;
	
	        // Image original width, height
	        var ow;
	        var oh;
	
	        if (isImage(image)) {
	            var src = image.src;
	            if (src === this._imageSrc) {
	                ow = this._imageWidth;
	                oh = this._imageHeight;
	            }
	            else {
	                var imageRuntimeStyle = image.runtimeStyle;
	                var oldRuntimeWidth = imageRuntimeStyle.width;
	                var oldRuntimeHeight = imageRuntimeStyle.height;
	                imageRuntimeStyle.width = 'auto';
	                imageRuntimeStyle.height = 'auto';
	
	                // get the original size
	                ow = image.width;
	                oh = image.height;
	
	                // and remove overides
	                imageRuntimeStyle.width = oldRuntimeWidth;
	                imageRuntimeStyle.height = oldRuntimeHeight;
	
	                // Caching image original width, height and src
	                this._imageSrc = src;
	                this._imageWidth = ow;
	                this._imageHeight = oh;
	            }
	            image = src;
	        }
	        else {
	            if (image === this._imageSrc) {
	                ow = this._imageWidth;
	                oh = this._imageHeight;
	            }
	        }
	        if (!image) {
	            return;
	        }
	
	        var x = style.x || 0;
	        var y = style.y || 0;
	
	        var dw = style.width;
	        var dh = style.height;
	
	        var sw = style.sWidth;
	        var sh = style.sHeight;
	        var sx = style.sx || 0;
	        var sy = style.sy || 0;
	
	        var hasCrop = sw && sh;
	
	        var vmlEl = this._vmlEl;
	        if (!vmlEl) {
	            // FIXME 使用 group 在 left, top 都不是 0 的时候就无法显示了。
	            // vmlEl = vmlCore.createNode('group');
	            vmlEl = vmlCore.doc.createElement('div');
	            initRootElStyle(vmlEl);
	
	            this._vmlEl = vmlEl;
	        }
	
	        var vmlElStyle = vmlEl.style;
	        var hasRotation = false;
	        var m;
	        var scaleX = 1;
	        var scaleY = 1;
	        if (this.transform) {
	            m = this.transform;
	            scaleX = sqrt(m[0] * m[0] + m[1] * m[1]);
	            scaleY = sqrt(m[2] * m[2] + m[3] * m[3]);
	
	            hasRotation = m[1] || m[2];
	        }
	        if (hasRotation) {
	            // If filters are necessary (rotation exists), create them
	            // filters are bog-slow, so only create them if abbsolutely necessary
	            // The following check doesn't account for skews (which don't exist
	            // in the canvas spec (yet) anyway.
	            // From excanvas
	            var p0 = [x, y];
	            var p1 = [x + dw, y];
	            var p2 = [x, y + dh];
	            var p3 = [x + dw, y + dh];
	            applyTransform(p0, p0, m);
	            applyTransform(p1, p1, m);
	            applyTransform(p2, p2, m);
	            applyTransform(p3, p3, m);
	
	            var maxX = mathMax(p0[0], p1[0], p2[0], p3[0]);
	            var maxY = mathMax(p0[1], p1[1], p2[1], p3[1]);
	
	            var transformFilter = [];
	            transformFilter.push('M11=', m[0] / scaleX, comma,
	                        'M12=', m[2] / scaleY, comma,
	                        'M21=', m[1] / scaleX, comma,
	                        'M22=', m[3] / scaleY, comma,
	                        'Dx=', round(x * scaleX + m[4]), comma,
	                        'Dy=', round(y * scaleY + m[5]));
	
	            vmlElStyle.padding = '0 ' + round(maxX) + 'px ' + round(maxY) + 'px 0';
	            // FIXME DXImageTransform 在 IE11 的兼容模式下不起作用
	            vmlElStyle.filter = imageTransformPrefix + '.Matrix('
	                + transformFilter.join('') + ', SizingMethod=clip)';
	
	        }
	        else {
	            if (m) {
	                x = x * scaleX + m[4];
	                y = y * scaleY + m[5];
	            }
	            vmlElStyle.filter = '';
	            vmlElStyle.left = round(x) + 'px';
	            vmlElStyle.top = round(y) + 'px';
	        }
	
	        var imageEl = this._imageEl;
	        var cropEl = this._cropEl;
	
	        if (!imageEl) {
	            imageEl = vmlCore.doc.createElement('div');
	            this._imageEl = imageEl;
	        }
	        var imageELStyle = imageEl.style;
	        if (hasCrop) {
	            // Needs know image original width and height
	            if (! (ow && oh)) {
	                var tmpImage = new Image();
	                var self = this;
	                tmpImage.onload = function () {
	                    tmpImage.onload = null;
	                    ow = tmpImage.width;
	                    oh = tmpImage.height;
	                    // Adjust image width and height to fit the ratio destinationSize / sourceSize
	                    imageELStyle.width = round(scaleX * ow * dw / sw) + 'px';
	                    imageELStyle.height = round(scaleY * oh * dh / sh) + 'px';
	
	                    // Caching image original width, height and src
	                    self._imageWidth = ow;
	                    self._imageHeight = oh;
	                    self._imageSrc = image;
	                };
	                tmpImage.src = image;
	            }
	            else {
	                imageELStyle.width = round(scaleX * ow * dw / sw) + 'px';
	                imageELStyle.height = round(scaleY * oh * dh / sh) + 'px';
	            }
	
	            if (! cropEl) {
	                cropEl = vmlCore.doc.createElement('div');
	                cropEl.style.overflow = 'hidden';
	                this._cropEl = cropEl;
	            }
	            var cropElStyle = cropEl.style;
	            cropElStyle.width = round((dw + sx * dw / sw) * scaleX);
	            cropElStyle.height = round((dh + sy * dh / sh) * scaleY);
	            cropElStyle.filter = imageTransformPrefix + '.Matrix(Dx='
	                    + (-sx * dw / sw * scaleX) + ',Dy=' + (-sy * dh / sh * scaleY) + ')';
	
	            if (! cropEl.parentNode) {
	                vmlEl.appendChild(cropEl);
	            }
	            if (imageEl.parentNode != cropEl) {
	                cropEl.appendChild(imageEl);
	            }
	        }
	        else {
	            imageELStyle.width = round(scaleX * dw) + 'px';
	            imageELStyle.height = round(scaleY * dh) + 'px';
	
	            vmlEl.appendChild(imageEl);
	
	            if (cropEl && cropEl.parentNode) {
	                vmlEl.removeChild(cropEl);
	                this._cropEl = null;
	            }
	        }
	
	        var filterStr = '';
	        var alpha = style.opacity;
	        if (alpha < 1) {
	            filterStr += '.Alpha(opacity=' + round(alpha * 100) + ') ';
	        }
	        filterStr += imageTransformPrefix + '.AlphaImageLoader(src=' + image + ', SizingMethod=scale)';
	
	        imageELStyle.filter = filterStr;
	
	        vmlEl.style.zIndex = getZIndex(this.zlevel, this.z, this.z2);
	
	        // Append to root
	        append(vmlRoot, vmlEl);
	
	        // Text
	        if (style.text) {
	            this.drawRectText(vmlRoot, this.getBoundingRect());
	        }
	    };
	
	    ZImage.prototype.onRemove = function (vmlRoot) {
	        remove(vmlRoot, this._vmlEl);
	
	        this._vmlEl = null;
	        this._cropEl = null;
	        this._imageEl = null;
	
	        this.removeRectText(vmlRoot);
	    };
	
	    ZImage.prototype.onAdd = function (vmlRoot) {
	        append(vmlRoot, this._vmlEl);
	        this.appendRectText(vmlRoot);
	    };
	
	
	    /***************************************************
	     * TEXT
	     **************************************************/
	
	    var DEFAULT_STYLE_NORMAL = 'normal';
	
	    var fontStyleCache = {};
	    var fontStyleCacheCount = 0;
	    var MAX_FONT_CACHE_SIZE = 100;
	    var fontEl = document.createElement('div');
	
	    var getFontStyle = function (fontString) {
	        var fontStyle = fontStyleCache[fontString];
	        if (!fontStyle) {
	            // Clear cache
	            if (fontStyleCacheCount > MAX_FONT_CACHE_SIZE) {
	                fontStyleCacheCount = 0;
	                fontStyleCache = {};
	            }
	
	            var style = fontEl.style;
	            var fontFamily;
	            try {
	                style.font = fontString;
	                fontFamily = style.fontFamily.split(',')[0];
	            }
	            catch (e) {
	            }
	
	            fontStyle = {
	                style: style.fontStyle || DEFAULT_STYLE_NORMAL,
	                variant: style.fontVariant || DEFAULT_STYLE_NORMAL,
	                weight: style.fontWeight || DEFAULT_STYLE_NORMAL,
	                size: parseFloat(style.fontSize || 12) | 0,
	                family: fontFamily || 'Microsoft YaHei'
	            };
	
	            fontStyleCache[fontString] = fontStyle;
	            fontStyleCacheCount++;
	        }
	        return fontStyle;
	    };
	
	    var textMeasureEl;
	    // Overwrite measure text method
	    textContain.measureText = function (text, textFont) {
	        var doc = vmlCore.doc;
	        if (!textMeasureEl) {
	            textMeasureEl = doc.createElement('div');
	            textMeasureEl.style.cssText = 'position:absolute;top:-20000px;left:0;'
	                + 'padding:0;margin:0;border:none;white-space:pre;';
	            vmlCore.doc.body.appendChild(textMeasureEl);
	        }
	
	        try {
	            textMeasureEl.style.font = textFont;
	        } catch (ex) {
	            // Ignore failures to set to invalid font.
	        }
	        textMeasureEl.innerHTML = '';
	        // Don't use innerHTML or innerText because they allow markup/whitespace.
	        textMeasureEl.appendChild(doc.createTextNode(text));
	        return {
	            width: textMeasureEl.offsetWidth
	        };
	    };
	
	    var tmpRect = new BoundingRect();
	
	    var drawRectText = function (vmlRoot, rect, textRect, fromTextEl) {
	
	        var style = this.style;
	        var text = style.text;
	        if (!text) {
	            return;
	        }
	
	        var x;
	        var y;
	        var align = style.textAlign;
	        var fontStyle = getFontStyle(style.textFont);
	        // FIXME encodeHtmlAttribute ?
	        var font = fontStyle.style + ' ' + fontStyle.variant + ' ' + fontStyle.weight + ' '
	            + fontStyle.size + 'px "' + fontStyle.family + '"';
	
	        var baseline = style.textBaseline;
	        var verticalAlign = style.textVerticalAlign;
	
	        textRect = textRect || textContain.getBoundingRect(text, font, align, baseline);
	
	        // Transform rect to view space
	        var m = this.transform;
	        // Ignore transform for text in other element
	        if (m && !fromTextEl) {
	            tmpRect.copy(rect);
	            tmpRect.applyTransform(m);
	            rect = tmpRect;
	        }
	
	        if (!fromTextEl) {
	            var textPosition = style.textPosition;
	            var distance = style.textDistance;
	            // Text position represented by coord
	            if (textPosition instanceof Array) {
	                x = rect.x + parsePercent(textPosition[0], rect.width);
	                y = rect.y + parsePercent(textPosition[1], rect.height);
	
	                align = align || 'left';
	                baseline = baseline || 'top';
	            }
	            else {
	                var res = textContain.adjustTextPositionOnRect(
	                    textPosition, rect, textRect, distance
	                );
	                x = res.x;
	                y = res.y;
	
	                // Default align and baseline when has textPosition
	                align = align || res.textAlign;
	                baseline = baseline || res.textBaseline;
	            }
	        }
	        else {
	            x = rect.x;
	            y = rect.y;
	        }
	        if (verticalAlign) {
	            switch (verticalAlign) {
	                case 'middle':
	                    y -= textRect.height / 2;
	                    break;
	                case 'bottom':
	                    y -= textRect.height;
	                    break;
	                // 'top'
	            }
	            // Ignore baseline
	            baseline = 'top';
	        }
	
	        var fontSize = fontStyle.size;
	        // 1.75 is an arbitrary number, as there is no info about the text baseline
	        switch (baseline) {
	            case 'hanging':
	            case 'top':
	                y += fontSize / 1.75;
	                break;
	            case 'middle':
	                break;
	            default:
	            // case null:
	            // case 'alphabetic':
	            // case 'ideographic':
	            // case 'bottom':
	                y -= fontSize / 2.25;
	                break;
	        }
	        switch (align) {
	            case 'left':
	                break;
	            case 'center':
	                x -= textRect.width / 2;
	                break;
	            case 'right':
	                x -= textRect.width;
	                break;
	            // case 'end':
	                // align = elementStyle.direction == 'ltr' ? 'right' : 'left';
	                // break;
	            // case 'start':
	                // align = elementStyle.direction == 'rtl' ? 'right' : 'left';
	                // break;
	            // default:
	            //     align = 'left';
	        }
	
	        var createNode = vmlCore.createNode;
	
	        var textVmlEl = this._textVmlEl;
	        var pathEl;
	        var textPathEl;
	        var skewEl;
	        if (!textVmlEl) {
	            textVmlEl = createNode('line');
	            pathEl = createNode('path');
	            textPathEl = createNode('textpath');
	            skewEl = createNode('skew');
	
	            // FIXME Why here is not cammel case
	            // Align 'center' seems wrong
	            textPathEl.style['v-text-align'] = 'left';
	
	            initRootElStyle(textVmlEl);
	
	            pathEl.textpathok = true;
	            textPathEl.on = true;
	
	            textVmlEl.from = '0 0';
	            textVmlEl.to = '1000 0.05';
	
	            append(textVmlEl, skewEl);
	            append(textVmlEl, pathEl);
	            append(textVmlEl, textPathEl);
	
	            this._textVmlEl = textVmlEl;
	        }
	        else {
	            // 这里是在前面 appendChild 保证顺序的前提下
	            skewEl = textVmlEl.firstChild;
	            pathEl = skewEl.nextSibling;
	            textPathEl = pathEl.nextSibling;
	        }
	
	        var coords = [x, y];
	        var textVmlElStyle = textVmlEl.style;
	        // Ignore transform for text in other element
	        if (m && fromTextEl) {
	            applyTransform(coords, coords, m);
	
	            skewEl.on = true;
	
	            skewEl.matrix = m[0].toFixed(3) + comma + m[2].toFixed(3) + comma +
	            m[1].toFixed(3) + comma + m[3].toFixed(3) + ',0,0';
	
	            // Text position
	            skewEl.offset = (round(coords[0]) || 0) + ',' + (round(coords[1]) || 0);
	            // Left top point as origin
	            skewEl.origin = '0 0';
	
	            textVmlElStyle.left = '0px';
	            textVmlElStyle.top = '0px';
	        }
	        else {
	            skewEl.on = false;
	            textVmlElStyle.left = round(x) + 'px';
	            textVmlElStyle.top = round(y) + 'px';
	        }
	
	        textPathEl.string = encodeHtmlAttribute(text);
	        // TODO
	        try {
	            textPathEl.style.font = font;
	        }
	        // Error font format
	        catch (e) {}
	
	        updateFillAndStroke(textVmlEl, 'fill', {
	            fill: fromTextEl ? style.fill : style.textFill,
	            opacity: style.opacity
	        }, this);
	        updateFillAndStroke(textVmlEl, 'stroke', {
	            stroke: fromTextEl ? style.stroke : style.textStroke,
	            opacity: style.opacity,
	            lineDash: style.lineDash
	        }, this);
	
	        textVmlEl.style.zIndex = getZIndex(this.zlevel, this.z, this.z2);
	
	        // Attached to root
	        append(vmlRoot, textVmlEl);
	    };
	
	    var removeRectText = function (vmlRoot) {
	        remove(vmlRoot, this._textVmlEl);
	        this._textVmlEl = null;
	    };
	
	    var appendRectText = function (vmlRoot) {
	        append(vmlRoot, this._textVmlEl);
	    };
	
	    var list = [RectText, Displayable, ZImage, Path, Text];
	
	    // In case Displayable has been mixed in RectText
	    for (var i = 0; i < list.length; i++) {
	        var proto = list[i].prototype;
	        proto.drawRectText = drawRectText;
	        proto.removeRectText = removeRectText;
	        proto.appendRectText = appendRectText;
	    }
	
	    Text.prototype.brushVML = function (vmlRoot) {
	        var style = this.style;
	        if (style.text) {
	            this.drawRectText(vmlRoot, {
	                x: style.x || 0, y: style.y || 0,
	                width: 0, height: 0
	            }, this.getBoundingRect(), true);
	        }
	        else {
	            this.removeRectText(vmlRoot);
	        }
	    };
	
	    Text.prototype.onRemove = function (vmlRoot) {
	        this.removeRectText(vmlRoot);
	    };
	
	    Text.prototype.onAdd = function (vmlRoot) {
	        this.appendRectText(vmlRoot);
	    };
	}


/***/ },
/* 98 */
/***/ function(module, exports, __webpack_require__) {

	
	
	if (!__webpack_require__(64).canvasSupported) {
	    var urn = 'urn:schemas-microsoft-com:vml';
	
	    var createNode;
	    var win = window;
	    var doc = win.document;
	
	    var vmlInited = false;
	
	    try {
	        !doc.namespaces.zrvml && doc.namespaces.add('zrvml', urn);
	        createNode = function (tagName) {
	            return doc.createElement('<zrvml:' + tagName + ' class="zrvml">');
	        };
	    }
	    catch (e) {
	        createNode = function (tagName) {
	            return doc.createElement('<' + tagName + ' xmlns="' + urn + '" class="zrvml">');
	        };
	    }
	
	    // From raphael
	    var initVML = function () {
	        if (vmlInited) {
	            return;
	        }
	        vmlInited = true;
	
	        var styleSheets = doc.styleSheets;
	        if (styleSheets.length < 31) {
	            doc.createStyleSheet().addRule('.zrvml', 'behavior:url(#default#VML)');
	        }
	        else {
	            // http://msdn.microsoft.com/en-us/library/ms531194%28VS.85%29.aspx
	            styleSheets[0].addRule('.zrvml', 'behavior:url(#default#VML)');
	        }
	    };
	
	    // Not useing return to avoid error when converting to CommonJS module
	    module.exports = {
	        doc: doc,
	        initVML: initVML,
	        createNode: createNode
	    };
	}


/***/ },
/* 99 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * VML Painter.
	 *
	 * @module zrender/vml/Painter
	 */
	
	
	
	    var zrLog = __webpack_require__(20);
	    var vmlCore = __webpack_require__(98);
	
	    function parseInt10(val) {
	        return parseInt(val, 10);
	    }
	
	    /**
	     * @alias module:zrender/vml/Painter
	     */
	    function VMLPainter(root, storage) {
	
	        vmlCore.initVML();
	
	        this.root = root;
	
	        this.storage = storage;
	
	        var vmlViewport = document.createElement('div');
	
	        var vmlRoot = document.createElement('div');
	
	        vmlViewport.style.cssText = 'display:inline-block;overflow:hidden;position:relative;width:300px;height:150px;';
	
	        vmlRoot.style.cssText = 'position:absolute;left:0;top:0;';
	
	        root.appendChild(vmlViewport);
	
	        this._vmlRoot = vmlRoot;
	        this._vmlViewport = vmlViewport;
	
	        this.resize();
	
	        // Modify storage
	        var oldDelFromMap = storage.delFromMap;
	        var oldAddToMap = storage.addToMap;
	        storage.delFromMap = function (elId) {
	            var el = storage.get(elId);
	
	            oldDelFromMap.call(storage, elId);
	
	            if (el) {
	                el.onRemove && el.onRemove(vmlRoot);
	            }
	        };
	
	        storage.addToMap = function (el) {
	            // Displayable already has a vml node
	            el.onAdd && el.onAdd(vmlRoot);
	
	            oldAddToMap.call(storage, el);
	        };
	
	        this._firstPaint = true;
	    }
	
	    VMLPainter.prototype = {
	
	        constructor: VMLPainter,
	
	        /**
	         * @return {HTMLDivElement}
	         */
	        getViewportRoot: function () {
	            return this._vmlViewport;
	        },
	
	        /**
	         * 刷新
	         */
	        refresh: function () {
	
	            var list = this.storage.getDisplayList(true, true);
	
	            this._paintList(list);
	        },
	
	        _paintList: function (list) {
	            var vmlRoot = this._vmlRoot;
	            for (var i = 0; i < list.length; i++) {
	                var el = list[i];
	                if (el.invisible || el.ignore) {
	                    if (!el.__alreadyNotVisible) {
	                        el.onRemove(vmlRoot);
	                    }
	                    // Set as already invisible
	                    el.__alreadyNotVisible = true;
	                }
	                else {
	                    if (el.__alreadyNotVisible) {
	                        el.onAdd(vmlRoot);
	                    }
	                    el.__alreadyNotVisible = false;
	                    if (el.__dirty) {
	                        el.beforeBrush && el.beforeBrush();
	                        (el.brushVML || el.brush).call(el, vmlRoot);
	                        el.afterBrush && el.afterBrush();
	                    }
	                }
	                el.__dirty = false;
	            }
	
	            if (this._firstPaint) {
	                // Detached from document at first time
	                // to avoid page refreshing too many times
	
	                // FIXME 如果每次都先 removeChild 可能会导致一些填充和描边的效果改变
	                this._vmlViewport.appendChild(vmlRoot);
	                this._firstPaint = false;
	            }
	        },
	
	        resize: function () {
	            var width = this._getWidth();
	            var height = this._getHeight();
	
	            if (this._width != width && this._height != height) {
	                this._width = width;
	                this._height = height;
	
	                var vmlViewportStyle = this._vmlViewport.style;
	                vmlViewportStyle.width = width + 'px';
	                vmlViewportStyle.height = height + 'px';
	            }
	        },
	
	        dispose: function () {
	            this.root.innerHTML = '';
	
	            this._vmlRoot =
	            this._vmlViewport =
	            this.storage = null;
	        },
	
	        getWidth: function () {
	            return this._width;
	        },
	
	        getHeight: function () {
	            return this._height;
	        },
	
	        clear: function () {
	            this.root.removeChild(this.vmlViewport);
	        },
	
	        _getWidth: function () {
	            var root = this.root;
	            var stl = root.currentStyle;
	
	            return ((root.clientWidth || parseInt10(stl.width))
	                    - parseInt10(stl.paddingLeft)
	                    - parseInt10(stl.paddingRight)) | 0;
	        },
	
	        _getHeight: function () {
	            var root = this.root;
	            var stl = root.currentStyle;
	
	            return ((root.clientHeight || parseInt10(stl.height))
	                    - parseInt10(stl.paddingTop)
	                    - parseInt10(stl.paddingBottom)) | 0;
	        }
	    };
	
	    // Not supported methods
	    function createMethodNotSupport(method) {
	        return function () {
	            zrLog('In IE8.0 VML mode painter not support method "' + method + '"');
	        };
	    }
	
	    var notSupportedMethods = [
	        'getLayer', 'insertLayer', 'eachLayer', 'eachBuildinLayer', 'eachOtherLayer', 'getLayers',
	        'modLayer', 'delLayer', 'clearLayer', 'toDataURL', 'pathToImage'
	    ];
	
	    for (var i = 0; i < notSupportedMethods.length; i++) {
	        var name = notSupportedMethods[i];
	        VMLPainter.prototype[name] = createMethodNotSupport(name);
	    }
	
	    module.exports = VMLPainter;


/***/ }
/******/ ])
});
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwid2VicGFjazovLy93ZWJwYWNrL2Jvb3RzdHJhcCAxYTA5NjNhZjY3OGZhNjRiZGZjNSIsIndlYnBhY2s6Ly8vLi9pbmRleC5mbG93LmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tZmxvdy9saWIvRmlzaFRvcG9GbG93LmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tY29yZS9saWIvZ3JhcGhpYy5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2NvcmUvdXRpbC5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL3Rvb2wvcGF0aC5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvUGF0aC5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvRGlzcGxheWFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9ncmFwaGljL1N0eWxlLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvRWxlbWVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2NvcmUvZ3VpZC5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL21peGluL0V2ZW50ZnVsLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvbWl4aW4vVHJhbnNmb3JtYWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2NvcmUvbWF0cml4LmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvY29yZS92ZWN0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9taXhpbi9BbmltYXRhYmxlLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvYW5pbWF0aW9uL0FuaW1hdG9yLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvYW5pbWF0aW9uL0NsaXAuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9hbmltYXRpb24vZWFzaW5nLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvdG9vbC9jb2xvci5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2NvcmUvbG9nLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvY29uZmlnLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvZ3JhcGhpYy9taXhpbi9SZWN0VGV4dC5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2NvbnRhaW4vdGV4dC5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2NvcmUvQm91bmRpbmdSZWN0LmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvY29yZS9QYXRoUHJveHkuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9jb3JlL2N1cnZlLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvY29yZS9iYm94LmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvY29udGFpbi9wYXRoLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvY29udGFpbi9saW5lLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvY29udGFpbi9jdWJpYy5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2NvbnRhaW4vcXVhZHJhdGljLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvY29udGFpbi9hcmMuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9jb250YWluL3V0aWwuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9jb250YWluL3dpbmRpbmdMaW5lLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvZ3JhcGhpYy9QYXR0ZXJuLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvdG9vbC90cmFuc2Zvcm1QYXRoLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvZ3JhcGhpYy9HcmFkaWVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL21peGluL0RyYWdnYWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2NvbnRhaW5lci9Hcm91cC5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvSW1hZ2UuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9jb3JlL0xSVS5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvVGV4dC5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvQ2lyY2xlLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9TZWN0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL1JpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL1BvbHlnb24uanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9ncmFwaGljL2hlbHBlci9wb2x5LmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvZ3JhcGhpYy9oZWxwZXIvc21vb3RoU3BsaW5lLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvZ3JhcGhpYy9oZWxwZXIvc21vb3RoQmV6aWVyLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9Qb2x5bGluZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvUmVjdC5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvaGVscGVyL3JvdW5kUmVjdC5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvTGluZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvQmV6aWVyQ3VydmUuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL0FyYy5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvTGluZWFyR3JhZGllbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9ncmFwaGljL1JhZGlhbEdyYWRpZW50LmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tY29yZS9saWIvbWluaW1hcC5qcyIsIndlYnBhY2s6Ly8vLi9saWIvZmlzaC10b3BvLWNvcmUvbGliL3V0aWwuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1jb3JlL2xpYi9Qb2ludC5qcyIsIndlYnBhY2s6Ly8vLi9saWIvZmlzaC10b3BvLWNvcmUvbGliL0xpbmVTdHJ1Y3QuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1mbG93L2xpYi9FeHRlbnNpb25BcGkuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi96cmVuZGVyLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvY29yZS9lbnYuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9IYW5kbGVyLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvU3RvcmFnZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2NvcmUvdGltc29ydC5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2FuaW1hdGlvbi9BbmltYXRpb24uanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9jb3JlL2V2ZW50LmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvYW5pbWF0aW9uL3JlcXVlc3RBbmltYXRpb25GcmFtZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2RvbS9IYW5kbGVyUHJveHkuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9jb3JlL0dlc3R1cmVNZ3IuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9QYWludGVyLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvTGF5ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1mbG93L2xpYi9ub2RlL0dyb3VwTm9kZS5qcyIsIndlYnBhY2s6Ly8vLi9saWIvZmlzaC10b3BvLWNvcmUvbGliL05vZGUuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1jb3JlL2xpYi9zaGFwZXMvQ29ubmVjdG9yLmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tY29yZS9saWIvc2hhcGVzL1N5bWJvbC5qcyIsIndlYnBhY2s6Ly8vLi9saWIvZmlzaC10b3BvLWNvcmUvbGliL3NoYXBlcy9IYW5kbGUuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1jb3JlL2xpYi9zaGFwZXMvRWZmZWN0TGluZS5qcyIsIndlYnBhY2s6Ly8vLi9saWIvZmlzaC10b3BvLWNvcmUvbGliL3NoYXBlcy9Db25uZWN0aW9uUG9pbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1jb3JlL2xpYi9tYW5hZ2VyL09wZXJhdGlvbk5vZGUuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1mbG93L2xpYi9tYW5hZ2VyL0Zsb3dDb25uZWN0aW9uTWFuYWdlci5qcyIsIndlYnBhY2s6Ly8vLi9saWIvZmlzaC10b3BvLWNvcmUvbGliL21hbmFnZXIvQ29ubmVjdGlvbk1hbmFnZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1jb3JlL2xpYi9Mb2cuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1mbG93L2xpYi91dGlsL0Zsb3dDb25zdGFudHMuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1jb3JlL2xpYi9tb2RlbC5qcyIsIndlYnBhY2s6Ly8vLi9saWIvZmlzaC10b3BvLWNvcmUvbGliL2NsYXp6LmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tZmxvdy9saWIvbGF5b3V0L2ZvcmNlTGF5b3V0LmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tZmxvdy9saWIvbGF5b3V0L2ZvcmNlSGVscGVyLmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tZmxvdy9saWIvbGF5b3V0L3RyZWVMYXlvdXQuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1mbG93L2xpYi91dGlsL0Zsb3dVdGlsLmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tY29yZS9saWIvbWFuYWdlci9MaW5lT3BlcmF0aW9uTWFuYWdlci5qcyIsIndlYnBhY2s6Ly8vLi9saWIvZmlzaC10b3BvLWZsb3cvbGliL0Zsb3cuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1jb3JlL2xpYi9JbWFnZVBvb2wuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi92bWwvdm1sLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvdm1sL2dyYXBoaWMuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi92bWwvY29yZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL3ZtbC9QYWludGVyLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxPO0FDVkE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQWU7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUN0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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Q0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBZ0IsT0FBTztBQUN2QixpQkFBZ0IsT0FBTztBQUN2QixpQkFBZ0IsT0FBTztBQUN2QixpQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWdCLGNBQWM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFnQixZQUFZO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBUzs7O0FBR1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZSxZQUFZO0FBQzNCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsaUJBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWdCLFlBQVk7QUFDNUIsaUJBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBZ0IsY0FBYztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7QUN0MURBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsaUNBQWlDO0FBQ2hELGdCQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWUsNEJBQTRCO0FBQzNDLGdCQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixpQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGlCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsU0FBUztBQUN4QixpQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTJCLFNBQVM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNqWkE7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQSx5REFBd0Q7O0FBRXhEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQSxxQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBLG9CQUFtQixRQUFRO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQSxvQkFBbUIsY0FBYztBQUNqQyxvQkFBbUIsRUFBRTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsU0FBUztBQUN4QixnQkFBZSxTQUFTO0FBQ3hCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7Ozs7OztBQ3BXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBa0I7QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBa0I7QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBa0I7QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1CQUFrQjtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUJBQWtCO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQkFBa0I7QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1CQUFrQjtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFrQjtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUJBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUJBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUJBQWtCO0FBQ2xCO0FBQ0E7O0FBRUEsdUNBQXNDOztBQUV0QyxzQ0FBcUM7O0FBRXJDO0FBQ0E7QUFDQSxvQkFBbUIseUJBQXlCO0FBQzVDO0FBQ0E7QUFDQSx5Q0FBd0M7O0FBRXhDO0FBQ0E7QUFDQSxxQkFBb0I7QUFDcEI7QUFDQTtBQUNBLHdDQUF1Qzs7QUFFdkM7QUFDQTtBQUNBO0FBQ0EscUJBQW9CLE9BQU87QUFDM0IscUJBQW9CLE9BQU87QUFDM0IscUJBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQSxxQkFBb0IsU0FBUztBQUM3QixzQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxxQkFBb0IsT0FBTztBQUMzQixxQkFBb0IsT0FBTztBQUMzQixxQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxxQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFZO0FBQ1o7QUFDQTtBQUNBLG9CQUFtQixRQUFRO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0Esb0JBQW1CLGNBQWM7QUFDakMsb0JBQW1CLEVBQUU7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBLHFCQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUMzUUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOzs7QUFHQTs7QUFFQTs7QUFFQTtBQUNBLG1CQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0EsbUJBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQSxtQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBLG1CQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0EsbUJBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQSxtQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBLG1CQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0EsbUJBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQSxtQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUJBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQSxtQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBLG1CQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1CQUFrQjtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBLG1CQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0EsbUJBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1CQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBa0I7QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW1CLHlCQUF5QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNB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QjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBLG9CQUFtQixPQUFPO0FBQzFCLG9CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwwREFBeUQsT0FBTztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLG9CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQ0FBK0IsU0FBUztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQSxvQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQ0FBK0IsU0FBUztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWM7QUFDZDtBQUNBOztBQUVBOzs7Ozs7OztBQ3ZTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWUsVUFBVTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsaUJBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsaUJBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7O0FDdlBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxvQkFBbUIsNEJBQTRCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0Esb0JBQW1CLDRCQUE0QjtBQUMvQyxvQkFBbUIsNEJBQTRCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0Esb0JBQW1CLDRCQUE0QjtBQUMvQyxvQkFBbUIsNEJBQTRCO0FBQy9DLG9CQUFtQiw0QkFBNEI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxvQkFBbUIsNEJBQTRCO0FBQy9DLG9CQUFtQiw0QkFBNEI7QUFDL0Msb0JBQW1CLDRCQUE0QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLG9CQUFtQiw0QkFBNEI7QUFDL0Msb0JBQW1CLDRCQUE0QjtBQUMvQyxvQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0Esb0JBQW1CLDRCQUE0QjtBQUMvQyxvQkFBbUIsNEJBQTRCO0FBQy9DLG9CQUFtQiw0QkFBNEI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0Esb0JBQW1CLDRCQUE0QjtBQUMvQyxvQkFBbUIsNEJBQTRCO0FBQy9DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7Ozs7QUMzSkE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWlCLDRCQUE0QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW1CLE9BQU87QUFDMUIsb0JBQW1CLE9BQU87QUFDMUIscUJBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBLG9CQUFtQixRQUFRO0FBQzNCLG9CQUFtQixRQUFRO0FBQzNCLHFCQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0Esb0JBQW1CLFFBQVE7QUFDM0IscUJBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBLG9CQUFtQixRQUFRO0FBQzNCLG9CQUFtQixPQUFPO0FBQzFCLG9CQUFtQixPQUFPO0FBQzFCLHFCQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQSxvQkFBbUIsUUFBUTtBQUMzQixvQkFBbUIsUUFBUTtBQUMzQixvQkFBbUIsUUFBUTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0Esb0JBQW1CLFFBQVE7QUFDM0Isb0JBQW1CLFFBQVE7QUFDM0Isb0JBQW1CLFFBQVE7QUFDM0Isb0JBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBLG9CQUFtQixRQUFRO0FBQzNCLG9CQUFtQixRQUFRO0FBQzNCLG9CQUFtQixRQUFRO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQSxvQkFBbUIsUUFBUTtBQUMzQixxQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0Esb0JBQW1CLFFBQVE7QUFDM0IscUJBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBLG9CQUFtQixRQUFRO0FBQzNCLG9CQUFtQixRQUFRO0FBQzNCLG9CQUFtQixRQUFRO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQSxvQkFBbUIsUUFBUTtBQUMzQixvQkFBbUIsUUFBUTtBQUMzQixvQkFBbUIsUUFBUTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0Esb0JBQW1CLFFBQVE7QUFDM0Isb0JBQW1CLFFBQVE7QUFDM0IscUJBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBLG9CQUFtQixRQUFRO0FBQzNCLG9CQUFtQixRQUFRO0FBQzNCLG9CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQSxvQkFBbUIsUUFBUTtBQUMzQixvQkFBbUIsUUFBUTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQSxvQkFBbUIsUUFBUTtBQUMzQixvQkFBbUIsUUFBUTtBQUMzQixxQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0Esb0JBQW1CLFFBQVE7QUFDM0Isb0JBQW1CLFFBQVE7QUFDM0IscUJBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0Esb0JBQW1CLFFBQVE7QUFDM0Isb0JBQW1CLFFBQVE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBLG9CQUFtQixRQUFRO0FBQzNCLG9CQUFtQixRQUFRO0FBQzNCLG9CQUFtQixRQUFRO0FBQzNCLG9CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQSxvQkFBbUIsUUFBUTtBQUMzQixvQkFBbUIsUUFBUTtBQUMzQixvQkFBbUIsUUFBUTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QTtBQUNBO0FBQ0E7QUFDQSx3QkFBdUIsY0FBYztBQUNyQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3QkFBdUIsa0JBQWtCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFtQyxZQUFZO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBdUMsa0JBQWtCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QSxVQUFTO0FBQ1Q7QUFDQSxtQkFBa0IsT0FBTztBQUN6QixvQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0EsbUJBQWtCLE9BQU87QUFDekIsb0JBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBLG1CQUFrQixPQUFPO0FBQ3pCLG9CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQSxtQkFBa0IsT0FBTztBQUN6QixvQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0EsbUJBQWtCLE9BQU87QUFDekIsb0JBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBLG1CQUFrQixPQUFPO0FBQ3pCLG9CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQSxtQkFBa0IsT0FBTztBQUN6QixvQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0EsbUJBQWtCLE9BQU87QUFDekIsb0JBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBLG1CQUFrQixPQUFPO0FBQ3pCLG9CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQSxtQkFBa0IsT0FBTztBQUN6QixvQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0EsbUJBQWtCLE9BQU87QUFDekIsb0JBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBLG1CQUFrQixPQUFPO0FBQ3pCLG9CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQSxtQkFBa0IsT0FBTztBQUN6QixvQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0EsbUJBQWtCLE9BQU87QUFDekIsb0JBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBLG1CQUFrQixPQUFPO0FBQ3pCLG9CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQSxtQkFBa0IsT0FBTztBQUN6QixvQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0EsbUJBQWtCLE9BQU87QUFDekIsb0JBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBLG1CQUFrQixPQUFPO0FBQ3pCLG9CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQSxtQkFBa0IsT0FBTztBQUN6QixvQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0EsbUJBQWtCLE9BQU87QUFDekIsb0JBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBLG1CQUFrQixPQUFPO0FBQ3pCLG9CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0EsbUJBQWtCLE9BQU87QUFDekIsb0JBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQSxtQkFBa0IsT0FBTztBQUN6QixvQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBLG1CQUFrQixPQUFPO0FBQ3pCLG9CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBLG1CQUFrQixPQUFPO0FBQ3pCLG9CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBLG1CQUFrQixPQUFPO0FBQ3pCLG9CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBLG1CQUFrQixPQUFPO0FBQ3pCLG9CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQSxtQkFBa0IsT0FBTztBQUN6QixvQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBLG1CQUFrQixPQUFPO0FBQ3pCLG9CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7Ozs7QUN0VkE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF1QixPQUFPO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFrQixhQUFhO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBLHFCQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRCQUEyQixpQkFBaUI7QUFDNUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxvQkFBbUIsdUJBQXVCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUEyQixTQUFTO0FBQ3BDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7Ozs7OztBQ2h3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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RUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFnQixPQUFPO0FBQ3ZCLGlCQUFnQixPQUFPO0FBQ3ZCLGlCQUFnQixPQUFPO0FBQ3ZCLGlCQUFnQixPQUFPO0FBQ3ZCLGlCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBZ0IsT0FBTztBQUN2QixpQkFBZ0IsT0FBTztBQUN2QixpQkFBZ0IsT0FBTztBQUN2QixpQkFBZ0IsT0FBTztBQUN2QixpQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFnQixPQUFPO0FBQ3ZCLGlCQUFnQixPQUFPO0FBQ3ZCLGlCQUFnQixPQUFPO0FBQ3ZCLGlCQUFnQixPQUFPO0FBQ3ZCLGlCQUFnQixlQUFlO0FBQy9CLGlCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWdCLE9BQU87QUFDdkIsaUJBQWdCLE9BQU87QUFDdkIsaUJBQWdCLE9BQU87QUFDdkIsaUJBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWdCLE9BQU87QUFDdkIsaUJBQWdCLE9BQU87QUFDdkIsaUJBQWdCLE9BQU87QUFDdkIsaUJBQWdCLE9BQU87QUFD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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBK0IsWUFBWTtBQUMzQztBQUNBOztBQUVBO0FBQ0Esa0NBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBdUIsT0FBTztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBdUIsaUJBQWlCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDOVlBO0FBQ0E7QUFDQTtBQUNBLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FDdkNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FDdENBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FDcENBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUJBQW9CLE9BQU87QUFDM0IscUJBQW9CLE9BQU87QUFDM0IscUJBQW9CLE9BQU87QUFDM0IscUJBQW9CLE9BQU87QUFDM0IscUJBQW9CLE9BQU87QUFDM0IscUJBQW9CLFFBQVE7QUFDNUIscUJBQW9CLE9BQU87QUFDM0IscUJBQW9CLE9BQU87QUFDM0IscUJBQW9CLE9BQU87QUFDM0IscUJBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQ3pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOzs7Ozs7Ozs7QUNsQkE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7OztBQ2RBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMEIsaUJBQWlCO0FBQzNDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXVCLFlBQVk7QUFDbkM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7Ozs7QUM1RkE7QUFDQSxnQkFBZSxlQUFlO0FBQzlCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7O0FBRUE7Ozs7Ozs7QUN4QkE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7Ozs7OztBQ2pGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFRO0FBQ1I7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsbUJBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUJBQWtCO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFCQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQSxxQkFBb0IsT0FBTztBQUMzQixxQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0EscUJBQW9CLE9BQU87QUFDM0IscUJBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLDRCQUEyQixxQkFBcUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0EscUJBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBLG9CQUFtQix1QkFBdUI7QUFDMUM7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQSxvQkFBbUIsdUJBQXVCO0FBQzFDLG9CQUFtQix1QkFBdUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQSxvQkFBbUIsdUJBQXVCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF1QixxQkFBcUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQSxxQkFBb0IsU0FBUztBQUM3QixzQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EsNEJBQTJCLHFCQUFxQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBLHFCQUFvQixTQUFTO0FBQzdCLHNCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsNEJBQTJCLDJCQUEyQjtBQUN0RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0EsNEJBQTJCLDJCQUEyQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0EsNEJBQTJCLDJCQUEyQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBLHFCQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRCQUEyQixxQkFBcUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7Ozs7Ozs7QUNuVEE7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF1QyxpQ0FBaUM7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOzs7Ozs7O0FDMUpBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBLG1CQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCLGlCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFnQiw4QkFBOEI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBZ0IsOEJBQThCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0EsbUJBQWtCO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGlCQUFnQixPQUFPO0FBQ3ZCLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDeEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxnQ0FBK0Isc0JBQXNCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7Ozs7Ozs7QUM1SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7O0FBR1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOzs7Ozs7OztBQzdCTDtBQUNB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QUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7Ozs7Ozs7Ozs7QUN0Q0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDeEZBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7Ozs7Ozs7QUN6REw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQSxxQkFBb0IsT0FBTztBQUMzQixxQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0EscUJBQW9CLE9BQU87QUFDM0IscUJBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOzs7Ozs7OztBQ3JJTDtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxVQUFTOztBQUVUOztBQUVBOztBQUVBO0FBQ0EsVUFBUzs7QUFFVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOzs7Ozs7O0FDL0NMOzs7QUFHQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFl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QUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7O0FBRUE7Ozs7Ozs7O0FDMVFBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWMsWUFBWTtBQUMxQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx3QkFBdUIsYUFBYTtBQUNwQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLDRCQUEyQixhQUFhO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTJCLGFBQWE7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjs7QUFFakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxvQ0FBbUMsWUFBWTtBQUMvQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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LHFCQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7Ozs7Ozs7O0FDelBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLHlFQUF3RTtBQUN4RTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWUsTUFBTTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUNoR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtB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QUFDcEI7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0Esb0JBQW1CLFFBQVE7QUFDM0I7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLDRCQUEyQix1QkFBdUI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQSw0QkFBMkIsMEJBQTBCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0QkFBMkIsU0FBUztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2IsVUFBUzs7QUFFVDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNkNBQTRDLE9BQU87QUFDbkQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0Esb0JBQW1CLE9BQU87QUFDMUIscUJBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFTOztBQUVUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0QkFBMkIsYUFBYTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXVCLHVCQUF1QjtBQUM5QztBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF1Qix1QkFBdUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBdUIsdUJBQXVCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBLG9CQUFtQiw2QkFBNkI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE0QyxPQUFPO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxvQkFBbUIsT0FBTztBQUMxQixvQkFBbUIsT0FBTztBQUMxQixvQkFBbUIsT0FBTztBQUMxQixvQkFBbUIsT0FBTztBQUMxQixvQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0Esb0JBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBLG9CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQSxvQkFBbUIsT0FBTztBQUMxQixvQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0Es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QUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBc0IseUJBQXlCO0FBQy9DO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1QkFBc0IseUJBQXlCO0FBQy9DO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBLGVBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFtQixPQUFPO0FBQzFCLG9CQUFtQixPQUFPO0FBQzFCLG9CQUFtQixPQUFPO0FBQzFCLG9CQUFtQixPQUFPO0FBQzFCLG9CQUFtQixPQUFPO0FBQzFCLG9CQUFtQixPQUFPO0FBQzFCLG9CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBcUI7QUFDckI7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBLHFFQUFvRSxLQUFLO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFxQjtBQUNyQjtBQUNBLGtCQUFpQjtBQUNqQjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7O0FDaldBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFrQywyQ0FBMkM7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUNBQWtDOztBQUVsQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBa0MsMkNBQTJDO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQWtDOztBQUVsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUMvR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF1QixtQkFBbUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUErQixZQUFZO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVCx3Q0FBdUMsYUFBYTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUMzTEE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0EsVUFBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw4Q0FBNkM7O0FBRTdDLDRDQUEyQzs7QUFFM0MsaURBQWdEOztBQUVoRDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7Ozs7Ozs7OztBQy9EQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXFDO0FBQ3JDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0EsdUNBQXNDO0FBQ3RDLHFDQUFvQztBQUNwQyxvQ0FBbUM7QUFDbkM7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrREFBaUQsU0FBUyxnQkFBZ0IsRUFBRTtBQUM1RSxrREFBaUQ7QUFDakQ7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBcUM7QUFDckMsbUdBQWtHLFNBQVMsa0JBQWtCLEVBQUU7QUFDL0g7QUFDQTtBQUNBO0FBQ0Esa0RBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBLDhCQUE2QjtBQUM3QiwwQkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQTZCO0FBQzdCOzs7QUFHQSxzQkFBcUI7QUFDckI7QUFDQSx5Q0FBd0M7QUFDeEMsdUdBQXNHLFNBQVMsa0JBQWtCLCtEQUErRDtBQUNoTSwwQkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQSw4QkFBNkI7QUFDN0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBNkI7QUFDN0IsMEJBQXlCO0FBQ3pCOztBQUVBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBeUI7QUFDekI7QUFDQSxzQkFBcUI7QUFDckI7QUFDQTtBQUNBLDBDQUF5QztBQUN6QztBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMENBQXlDO0FBQ3pDO0FBQ0Esb0NBQW1DLDBCQUEwQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ3hMQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQixPQUFPO0FBQzNCLG9CQUFtQixPQUFPO0FBQzFCLHFCQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakIsY0FBYTs7OztBQUliO0FBQ0E7QUFDQSx5REFBd0Q7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXVDO0FBQ3ZDOztBQUVBO0FBQ0E7QUFDQSxnQ0FBK0IsaUJBQWlCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBLDBCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGNBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBcUI7QUFDckI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUNBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBK0Isb0JBQW9CO0FBQ25EO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBOEIsUUFBUTtBQUN0QztBQUNBLHlDQUF3QztBQUN4QztBQUNBLG9HQUFtRztBQUNuRzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBOztBQUVBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSw0QkFBMkIsWUFBWTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQSwyQkFBMEIsNkJBQTZCO0FBQ3ZEO0FBQ0E7O0FBRUEsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0Esb0JBQW1CLE9BQU87QUFDMUIsb0JBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOzs7QUFHVDtBQUNBO0FBQ0EscUJBQW9CLE9BQU87QUFDM0IscUJBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBMkIsaUJBQWlCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUOztBQUVBO0FBQ0E7Ozs7Ozs7O0FDMVVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0EscUJBQW9CLE9BQU87QUFDM0IscUJBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0EsMkJBQTBCLDJCQUEyQjtBQUNyRDtBQUNBO0FBQ0EsVUFBUzs7O0FBR1Q7QUFDQTtBQUNBLHFCQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLHFCQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLDJCQUEwQiw0QkFBNEI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLHFCQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxxQkFBb0IsT0FBTztBQUMzQixxQkFBb0IsT0FBTztBQUMzQixxQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0ZBQStFO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhFQUE2RTs7O0FBRzdFO0FBQ0E7O0FBRUEsc0NBQXFDO0FBQ3JDLFVBQVM7OztBQUdUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQSw2QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBLGNBQWE7QUFDYjtBQUNBLGNBQWE7QUFDYjtBQUNBLGNBQWE7QUFDYjtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0EscUJBQW9CLE9BQU87QUFDM0IscUJBQW9CLE9BQU87QUFDM0IscUJBQW9CLE9BQU87QUFDM0IscUJBQW9CLE9BQU87QUFDM0I7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esa0VBQWlFLHVCQUF1QixtQkFBbUI7QUFDM0c7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdDQUErQjs7QUFFL0I7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBLHFCQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7OztBQUdUO0FBQ0E7QUFDQSxxQkFBb0IsT0FBTztBQUMzQixxQkFBb0IsT0FBTztBQUMzQixxQkFBb0IsT0FBTztBQUMzQixxQkFBb0IsT0FBTztBQUMzQixxQkFBb0IsT0FBTztBQUMzQixxQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDRHQUEyRztBQUMzRyw0R0FBMkc7QUFDM0csNEdBQTJHO0FBQzNHLDRHQUEyRzs7QUFFM0c7QUFDQTtBQUNBLHFDQUFvQywyQkFBMkI7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBLDBHQUF5RztBQUN6RywwR0FBeUc7QUFDekcsMEdBQXlHO0FBQ3pHLDBHQUF5Rzs7QUFFekc7QUFDQTtBQUNBLHFDQUFvQywyQkFBMkI7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0NBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzRkFBcUY7O0FBRXJGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUZBQXNGOztBQUV0RjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNGQUFxRjs7QUFFckY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1RkFBc0Y7O0FBRXRGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFvQyxvQkFBb0I7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF3QyxvQkFBb0I7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFvQyxvQkFBb0I7QUFDeEQ7QUFDQTtBQUNBOztBQUVBLCtEQUE4RDs7QUFFOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw2REFBNEQ7QUFDNUQ7QUFDQTs7QUFFQSxxQ0FBb0Msb0JBQW9CO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFvQyxvQkFBb0I7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFnQyxvQkFBb0I7QUFDcEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlDQUFnQyxvQkFBb0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBZ0Msb0JBQW9CO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhOztBQUViO0FBQ0E7QUFDQTs7Ozs7Ozs7QUM3b0JBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxtQkFBa0IsT0FBTztBQUN6QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7OztBQUdUO0FBQ0E7QUFDQSxtQkFBa0IsT0FBTztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBLG1CQUFrQixPQUFPO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0EsbUJBQWtCLE9BQU87QUFDekI7QUFDQTtBQUNBO0FBQ0EsbURBQWtEO0FBQ2xELG9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQSxtREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLHVDO0FBQ0EscUM7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDakdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlEQUFnRCxRQUFRO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQSxvQkFBbUIsT0FBTztBQUMxQixxQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0QkFBMkIsaUJBQWlCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0Esb0JBQW1CLE9BQU87QUFDMUIsb0JBQW1CLE9BQU87QUFDMUIscUJBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQ0FBK0IsV0FBVztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVULG9DQUFtQzs7QUFFbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7Ozs7O0FDakxBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBb0IsZUFBZTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7Ozs7OztBQ25MQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBZ0IsT0FBTztBQUN2QixpQkFBZ0IsT0FBTztBQUN2QixpQkFBZ0IsT0FBTztBQUN2QixpQkFBZ0IsT0FBTztBQUN2QixpQkFBZ0IsT0FBTztBQUN2QixpQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFnQyxjQUFjLGdCQUFnQjtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLGlEQUFnRCxPQUFPO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFvRCxPQUFPO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBbUQsT0FBTztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7O0FDeEZBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJCQUEwQixrQkFBa0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXVCLGtCQUFrQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFhOztBQUViO0FBQ0E7QUFDQSxjQUFhOztBQUViO0FBQ0E7QUFDQSxjQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBLGdDQUErQixrQkFBa0I7QUFDakQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQStCLFVBQVU7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQ0FBK0IsVUFBVTtBQUN6QztBQUNBLHdDQUF1QyxVQUFVO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBK0IsVUFBVTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FDdElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMEIsd0NBQXdDO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0EsK0JBQThCLHdCQUF3QjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsOEJBQTZCO0FBQzdCO0FBQ0E7QUFDQTs7QUFFQSwwQkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0EsOEJBQTZCO0FBQzdCO0FBQ0E7QUFDQSw4QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBNkI7QUFDN0I7QUFDQTtBQUNBLDhCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7O0FBRUEsMEJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLDhCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsOEJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTBCLHdCQUF3QjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDMUZBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWUsTUFBTTtBQUNyQixpQkFBZ0IsS0FBSztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBZ0IsT0FBTztBQUN2QixpQkFBZ0IsT0FBTztBQUN2QixpQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0Esd0JBQXVCLHdCQUF3QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMEQsWUFBWTtBQUN0RTtBQUNBOztBQUVBOzs7O0FBSUE7O0FBRUE7QUFDQSxnREFBK0MsU0FBUztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFrQyxzQkFBc0I7QUFDeEQ7QUFDQTtBQUNBLDBCQUF5QjtBQUN6QjtBQUNBLDBCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQTZCO0FBQzdCOztBQUVBO0FBQ0Esa0JBQWlCOztBQUVqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFnQixPQUFPO0FBQ3ZCLGlCQUFnQixPQUFPO0FBQ3ZCLGlCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQSx1REFBc0Q7OztBQUd0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYixVQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNuTUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYTtBQUNiO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0EscUJBQW9CLE9BQU87QUFDM0IscUJBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBLHNEQUFxRDtBQUNyRDtBQUNBO0FBQ0EsMkJBQTBCLDRCQUE0QjtBQUN0RDtBQUNBO0FBQ0E7QUFDQSwyQkFBMEIsNEJBQTRCO0FBQ3REO0FBQ0E7QUFDQSwyQkFBMEIsNEJBQTRCO0FBQ3REO0FBQ0EsK0JBQThCLE9BQU87QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQSw2QkFBNEIsaURBQWlEO0FBQzdFO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsZ0NBQStCLCtCQUErQjtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQSxzQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBa0MseUJBQXlCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7Ozs7Ozs7O0FDakhBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFtQixPQUFPO0FBQzFCLG9CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXNELG9CQUFvQjtBQUMxRTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLG9CQUFtQixPQUFPO0FBQzFCLHFCQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLG9CQUFtQixPQUFPO0FBQzFCLHFCQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLG9CQUFtQixPQUFPO0FBQzFCLHFCQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBMkQ7QUFDM0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQSxvQkFBbUIsT0FBTztBQUMxQixxQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxvQkFBbUIsT0FBTztBQUMxQixxQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTREO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxvQkFBbUIsT0FBTztBQUMxQixxQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxvQkFBbUIsT0FBTztBQUMxQixxQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQTZEO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxvQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7OztBQ3BLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFZLGdDQUFnQztBQUM1QztBQUNBLFlBQVcsbUJBQW1CLHNDQUFzQztBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW1CLGNBQWM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUE4QyxZQUFZO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE2QjtBQUM3QjtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBeUI7QUFDekI7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQXlDLFlBQVk7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUE4QyxZQUFZO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQSwwQkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVCQUFzQjs7Ozs7Ozs7O0FDeFd0QjtBQUNBOzs7Ozs7O0FDRkE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSwrQ0FBOEMsT0FBTyxNQUFNLFVBQVUsV0FBVztBQUNoRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4Q0FBNkMsd0JBQXdCO0FBQ3JFOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUErQixZQUFZO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdDQUErQixZQUFZO0FBQzNDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBNkQsYUFBYSxPQUFPO0FBQ2pGLDhCQUE2QixTQUFTLFlBQVksZ0JBQWdCO0FBQ2xFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0Esb0JBQW1CLGlCQUFpQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FDemhDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUM5Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLDJEQUEwRCxnQkFBZ0Isa0JBQWtCLFlBQVksYUFBYTs7QUFFckgsb0RBQW1ELE9BQU8sTUFBTTs7QUFFaEU7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxxQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBLDRCQUEyQixpQkFBaUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBbUIsZ0NBQWdDO0FBQ25EO0FBQ0E7QUFDQTs7QUFFQSIsImZpbGUiOiJmaXNoVG9wb0Zsb3cuanMiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShbXSwgZmFjdG9yeSk7XG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJmaXNoVG9wb0Zsb3dcIl0gPSBmYWN0b3J5KCk7XG5cdGVsc2Vcblx0XHRyb290W1wiZmlzaFRvcG9GbG93XCJdID0gZmFjdG9yeSgpO1xufSkodGhpcywgZnVuY3Rpb24oKSB7XG5yZXR1cm4gXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uXG4gKiovIiwiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pXG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG5cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGV4cG9ydHM6IHt9LFxuIFx0XHRcdGlkOiBtb2R1bGVJZCxcbiBcdFx0XHRsb2FkZWQ6IGZhbHNlXG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmxvYWRlZCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiB3ZWJwYWNrL2Jvb3RzdHJhcCAxYTA5NjNhZjY3OGZhNjRiZGZjNVxuICoqLyIsIi8qKlxyXG4gKiBFeHBvcnQgZmlzaFRvcG8gYXMgQ29tbW9uSlMgbW9kdWxlXHJcbiAqL1xyXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL2Zpc2gtdG9wby1mbG93L2xpYi9GaXNoVG9wb0Zsb3cuanMnKTtcclxuLy/lhbzlrrlJRTgg5byV5YWlVk1MIOWmguaenOS4jemcgOimgeWFvOWuuUlFOOivt+WIoOmZpFxyXG5yZXF1aXJlKCd6cmVuZGVyL2xpYi92bWwvdm1sJyk7XHJcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9pbmRleC5mbG93LmpzXG4gKiogbW9kdWxlIGlkID0gMVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXHJcbiAqIOa1geeoi+WvueixoVxyXG4gKiBAY2xhc3MgZmlzaC50b3BvLkZpc2hUb3BvRmxvd1xyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAZXZlbnQgY2xpY2tcclxuICog6IqC54K55oiW6ICF57q/5q6155qEY2xpY2vkuovku7ZcclxuICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IOS6i+S7tiBldmVudC50YXJnZXTkuLrnm67moIflr7nosaEgZXZlbnQudGFyZ2V0Lm1vZGVs5Li655uu5qCH5a+56LGh55qE5Lia5Yqh5pWw5o2uXHJcbiAqXHJcbiAqICoq5L2/55So6IyD5L6LKirvvJpcclxuICpcclxuICogICAgICBAZXhhbXBsZVxyXG4gKiAgICAgICAgICB0aGlzLmZpc2hUb3BvLm9uKFwiY2xpY2tcIiwgZnVuY3Rpb24oZXZlbnQpIHtcclxuICogICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwi54K55Ye755qE5piv77yaXCIgKyBldmVudC50YXJnZXQubW9kZWwuZ2V0KCdlbGVtZW50VHlwZScpKTtcclxuICogICAgICAgICAgfSk7XHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEBldmVudCBkYmxjbGlja1xyXG4gKiDoioLngrnmiJbogIXnur/mrrXnmoTlj4zlh7vkuovku7ZcclxuICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IOS6i+S7tiBldmVudC50YXJnZXTkuLrnm67moIflr7nosaEgZXZlbnQudGFyZ2V0Lm1vZGVs5Li655uu5qCH5a+56LGh55qE5Lia5Yqh5pWw5o2uXHJcbiAqXHJcbiAqICoq5L2/55So6IyD5L6LKirvvJpcclxuICpcclxuICogICAgICBAZXhhbXBsZVxyXG4gKiAgICAgICAgICB0aGlzLmZpc2hUb3BvLm9uKFwiZGJsY2xpY2tcIiwgZnVuY3Rpb24oZXZlbnQpIHtcclxuICogICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwi5Y+M5Ye755qE5piv77yaXCIgKyBldmVudC50YXJnZXQubW9kZWwuZ2V0KCdlbGVtZW50VHlwZScpKTtcclxuICogICAgICAgICAgfSk7XHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEBldmVudCBjcmVhdGVcclxuICog6IqC54K55LiO57q/5q615Yib5bu65a6M5q+V55qE5LqL5Lu2XHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCDkuovku7YgZXZlbnQudGFyZ2V05Li655uu5qCH5a+56LGhIGV2ZW50LnRhcmdldC5tb2RlbOS4uuebruagh+WvueixoeeahOS4muWKoeaVsOaNrlxyXG4gKlxyXG4gKiAqKuS9v+eUqOiMg+S+iyoq77yaXHJcbiAqXHJcbiAqICAgICAgQGV4YW1wbGVcclxuICogICAgICAgICAgdGhpcy5maXNoVG9wby5vbihcImNyZWF0ZVwiLCBmdW5jdGlvbihlKSB7XHJcbiAqICAgICAgICAgICAgICAgaWYgKG1lLmZpc2hUb3BvLkZsb3cuaXNMaW5rKGUudGFyZ2V0Lm1vZGVsKSkge1xyXG4gKiAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwi57q/5q615Yib5bu65a6M5q+V77yaXCIgKyBlLnRhcmdldC5tb2RlbCk7XHJcbiAqICAgICAgICAgICAgICAgfVxyXG4gKiAgICAgICAgICB9KTtcclxuICovXHJcblxyXG4vKipcclxuICogQGV2ZW50IGRlbGV0ZVxyXG4gKiDoioLngrnkuI7nur/mrrXliJvlu7rlrozmr5XnmoTkuovku7ZcclxuICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IOS6i+S7tiBldmVudC50YXJnZXTkuLrnm67moIflr7nosaEgZXZlbnQudGFyZ2V0Lm1vZGVs5Li655uu5qCH5a+56LGh55qE5Lia5Yqh5pWw5o2uXHJcbiAqXHJcbiAqICoq5L2/55So6IyD5L6LKirvvJpcclxuICpcclxuICogICAgICBAZXhhbXBsZVxyXG4gKiAgICAgICAgICAvL+iKgueCueWIoOmZpOWujOavleS6i+S7tlxyXG4gKiAgICAgICAgICB0aGlzLmZpc2hUb3BvLm9uKFwiZGVsZXRlXCIsIGZ1bmN0aW9uKGV2ZW50KSB7XHJcbiAqICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIuWIoOmZpOeahOaYr++8mlwiICsgZXZlbnQudGFyZ2V0Lm1vZGVsLmdldCgnZWxlbWVudFR5cGUnKSk7XHJcbiAqICAgICAgICAgIH0pO1xyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAZXZlbnQgbW91c2Vkb3duXHJcbiAqIOiKgueCueS4jue6v+autem8oOagh+aMieS4i+S6i+S7tlxyXG4gKiBAcGFyYW0ge09iamVjdH0gZXZlbnQg5LqL5Lu2IG5vZGXkuLroioLngrlcclxuICpcclxuICogKirkvb/nlKjojIPkvosqKu+8mlxyXG4gKlxyXG4gKiAgICAgIEBleGFtcGxlXHJcbiAqICAgICAgICAgIG5vZGUub24oXCJtb3VzZWRvd25cIiwgZnVuY3Rpb24oKXtcclxuICogICAgICAgICAgICAgIG5vZGUuYXR0cihcInN0eWxlXCIse3RleHQ6XCJtb3VzZWRvd25cIn0pO1xyXG4gKiAgICAgICAgICB9KTtcclxuICovXHJcblxyXG4vKipcclxuICogQGV2ZW50IG1vdXNldXBcclxuICog6IqC54K55LiO57q/5q616byg5qCH5oqs6LW35LqL5Lu2XHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCDkuovku7Ygbm9kZeS4uuiKgueCuVxyXG4gKlxyXG4gKiAqKuS9v+eUqOiMg+S+iyoq77yaXHJcbiAqXHJcbiAqICAgICAgQGV4YW1wbGVcclxuICogICAgICAgICAgbm9kZS5vbihcIm1vdXNldXBcIiwgZnVuY3Rpb24oKXtcclxuICogICAgICAgICAgICAgIG5vZGUuYXR0cihcInN0eWxlXCIse3RleHQ6XCJtb3VzZXVwXCJ9KTtcclxuICogICAgICAgICAgfSk7XHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEBldmVudCBtb3VzZW92ZXJcclxuICog6IqC54K55LiO57q/5q616byg5qCH5oKs5rWu5LqL5Lu2XHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCDkuovku7Ygbm9kZeS4uuiKgueCuVxyXG4gKlxyXG4gKiAqKuS9v+eUqOiMg+S+iyoq77yaXHJcbiAqXHJcbiAqICAgICAgQGV4YW1wbGVcclxuICogICAgICAgICAgbm9kZS5vbihcIm1vdXNlb3ZlclwiLCBmdW5jdGlvbigpe1xyXG4gKiAgICAgICAgICAgICAgbm9kZS5hdHRyKFwic3R5bGVcIix7dGV4dDpcIm1vdXNlb3ZlclwifSk7XHJcbiAqICAgICAgICAgIH0pO1xyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAZXZlbnQgbW91c2Vtb3ZlXHJcbiAqIOiKgueCueS4jue6v+autem8oOagh+enu+WKqOS6i+S7tlxyXG4gKiBAcGFyYW0ge09iamVjdH0gZXZlbnQg5LqL5Lu2IG5vZGXkuLroioLngrlcclxuICpcclxuICogKirkvb/nlKjojIPkvosqKu+8mlxyXG4gKlxyXG4gKiAgICAgIEBleGFtcGxlXHJcbiAqICAgICAgICAgIG5vZGUub24oXCJtb3VzZW1vdmVcIiwgZnVuY3Rpb24oKXtcclxuICogICAgICAgICAgICAgIG5vZGUuYXR0cihcInN0eWxlXCIse3RleHQ6XCJtb3VzZW1vdmVcIn0pO1xyXG4gKiAgICAgICAgICB9KTtcclxuICovXHJcblxyXG4vKipcclxuICogQGV2ZW50IG1vdXNlb3V0XHJcbiAqIOiKgueCueS4jue6v+autem8oOagh+emu+W8gOS6i+S7tlxyXG4gKiBAcGFyYW0ge09iamVjdH0gZXZlbnQg5LqL5Lu2IG5vZGXkuLroioLngrlcclxuICpcclxuICogKirkvb/nlKjojIPkvosqKu+8mlxyXG4gKlxyXG4gKiAgICAgIEBleGFtcGxlXHJcbiAqICAgICAgICAgIG5vZGUub24oXCJtb3VzZW91dFwiLCBmdW5jdGlvbigpe1xyXG4gKiAgICAgICAgICAgICAgbm9kZS5hdHRyKFwic3R5bGVcIix7dGV4dDpcIm1vdXNlb3V0XCJ9KTtcclxuICogICAgICAgICAgfSk7XHJcbiAqL1xyXG5cclxuXHJcbi8qKlxyXG4gKiBAbWV0aG9kIHNldFN0eWxlXHJcbiAqIOiKgueCueS4jue6v+auteabtOaUuXN0eWxl6YeM55qE5bGe5oCnXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIOiKgueCueaIluiAhee6v+autXN0eWxl6YeM55qE5p+Q5Liq5bGe5oCn5ZCN56ewXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmcg6IqC54K55oiW6ICF57q/5q61c3R5bGXph4znmoTmn5DkuKrlsZ7mgKflkI3np7Dlr7nlupTnmoTlgLxcclxuICogKirkvb/nlKjojIPkvosqKu+8mlxyXG4gKlxyXG4gKiAgICAgIEBleGFtcGxlXHJcbiAqICAgICAgICAgIC8v6IqC54K56K6+572u5paH5a2XXHJcbiAqICAgICAgICAgbm9kZS5zZXRTdHlsZShcInRleHRcIixcIuS+i+WtkFwiKTtcclxuICovXHJcblxyXG4vKipcclxuICogQG1ldGhvZCBzZXRTaGFwZVxyXG4gKiDoioLngrnmm7TmlLlzaGFwZemHjOeahOWxnuaAp1xyXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSDoioLngrlzaGFwZemHjOeahOafkOS4quWxnuaAp+WQjeensFxyXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nIOiKgueCuXNoYXBl6YeM55qE5p+Q5Liq5bGe5oCn5ZCN56ew5a+55bqU55qE5YC8XHJcbiAqICoq5L2/55So6IyD5L6LKirvvJpcclxuICpcclxuICogICAgICBAZXhhbXBsZVxyXG4gKiAgICAgICAgICAvL+efqeW9ouiKgueCueiuvue9ruWuvVxyXG4gKiAgICAgICAgIG5vZGUuc2V0U2hhcGUoXCJ3aWR0aFwiLDEwMCk7XHJcbiAqL1xyXG5cclxuXHJcblxyXG5cclxuXHJcbiAgICB2YXIgZ3JhcGhpYyA9IHJlcXVpcmUoXCIuLi8uLi9maXNoLXRvcG8tY29yZS9saWIvZ3JhcGhpYy5qc1wiKTtcclxuICAgIHZhciBNaW5pbWFwID0gcmVxdWlyZShcIi4uLy4uL2Zpc2gtdG9wby1jb3JlL2xpYi9taW5pbWFwLmpzXCIpO1xyXG4gICAgdmFyIHV0aWwgPSByZXF1aXJlKFwiLi4vLi4vZmlzaC10b3BvLWNvcmUvbGliL3V0aWwuanNcIik7XHJcbiAgICB2YXIgUG9pbnQgPSByZXF1aXJlKFwiLi4vLi4vZmlzaC10b3BvLWNvcmUvbGliL1BvaW50LmpzXCIpO1xyXG4gICAgdmFyIEV4dGVuc2lvbkFQSSA9IHJlcXVpcmUoJy4vRXh0ZW5zaW9uQXBpJyk7XHJcbiAgICB2YXIgRXZlbnRmdWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9taXhpbi9FdmVudGZ1bCcpO1xyXG4gICAgdmFyIHpyZW5kZXIgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi96cmVuZGVyJyk7XHJcbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XHJcbiAgICB2YXIgR3JvdXBOb2RlID0gcmVxdWlyZShcIi4vbm9kZS9Hcm91cE5vZGUuanNcIik7XHJcbiAgICB2YXIgT3BlcmF0aW9uTm9kZSA9IHJlcXVpcmUoXCIuLi8uLi9maXNoLXRvcG8tY29yZS9saWIvbWFuYWdlci9PcGVyYXRpb25Ob2RlLmpzXCIpO1xyXG4gICAgdmFyIEZsb3dDb25uZWN0aW9uTWFuYWdlciA9IHJlcXVpcmUoXCIuL21hbmFnZXIvRmxvd0Nvbm5lY3Rpb25NYW5hZ2VyLmpzXCIpO1xyXG4gICAgdmFyIGZvcmNlSW5zdGFuY2UgPSByZXF1aXJlKFwiLi9sYXlvdXQvZm9yY2VMYXlvdXQuanNcIik7XHJcbiAgICB2YXIgdHJlZUxheW91dCA9IHJlcXVpcmUoXCIuL2xheW91dC90cmVlTGF5b3V0LmpzXCIpO1xyXG4gICAgdmFyIEZsb3dVdGlsID0gcmVxdWlyZShcIi4vdXRpbC9GbG93VXRpbC5qc1wiKTtcclxuICAgIHZhciBDb25zdGFudHMgPSByZXF1aXJlKFwiLi91dGlsL0Zsb3dDb25zdGFudHMuanNcIik7XHJcbiAgICB2YXIgTW9kZWwgPSByZXF1aXJlKFwiLi4vLi4vZmlzaC10b3BvLWNvcmUvbGliL21vZGVsLmpzXCIpO1xyXG4gICAgdmFyIGV2ZW50VG9vbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvZXZlbnQnKTtcclxuICAgIHZhciBDb25uZWN0b3IgPSByZXF1aXJlKFwiLi4vLi4vZmlzaC10b3BvLWNvcmUvbGliL3NoYXBlcy9Db25uZWN0b3IuanNcIik7XHJcbiAgICB2YXIgTGluZU9wZXJhdGlvbk1hbmFnZXIgPSByZXF1aXJlKFwiLi4vLi4vZmlzaC10b3BvLWNvcmUvbGliL21hbmFnZXIvTGluZU9wZXJhdGlvbk1hbmFnZXIuanNcIik7XHJcbiAgICB2YXIgRmxvdyA9IHJlcXVpcmUoXCIuL0Zsb3cuanNcIik7XHJcbiAgICB2YXIgdGV4dENvbnRhaW4gPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb250YWluL3RleHQnKTtcclxuICAgIHZhciBJbWFnZVBvb2wgPSByZXF1aXJlKFwiLi4vLi4vZmlzaC10b3BvLWNvcmUvbGliL0ltYWdlUG9vbC5qc1wiKTtcclxuXHJcbiAgICBmdW5jdGlvbiBGaXNoVG9wb0Zsb3coZG9tLCBvcHRzKSB7XHJcbiAgICAgICAgdGhpcy5pZDtcclxuICAgICAgICB0aGlzLmdyb3VwO1xyXG4gICAgICAgIHRoaXMuX2RvbSA9IGRvbTtcclxuICAgICAgICB0aGlzLm5vd1pvb20gPSAxO1xyXG4gICAgICAgIHRoaXMuY2FuU2NhbGUgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuZWFnbGVFeWUgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmVhZ2xlRXllTm9kZTtcclxuICAgICAgICB0aGlzLmluaXRTY2FsZVJhdGlvO1xyXG4gICAgICAgIHRoaXMub3BlcmF0aW9uTm9kZTtcclxuICAgICAgICB0aGlzLnNlbGVjdGVkTm9kZSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5hbGxOb2RlcyA9IFtdO1xyXG4gICAgICAgIHRoaXMubWluaW1hcDtcclxuICAgICAgICB0aGlzLl9sYXlvdXRUaW1lb3V0ID0gbnVsbDtcclxuICAgICAgICB0aGlzLl96ciA9IHpyZW5kZXIuaW5pdChkb20sIHtcclxuICAgICAgICAgICAgcmVuZGVyZXI6IG9wdHMucmVuZGVyZXIgfHwgJ2NhbnZhcycsXHJcbiAgICAgICAgICAgIGRldmljZVBpeGVsUmF0aW86IG9wdHMuZGV2aWNlUGl4ZWxSYXRpb1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICB0aGlzLl9hcGkgPSBuZXcgRXh0ZW5zaW9uQVBJKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuU2hhcGUgPSBncmFwaGljO1xyXG4gICAgICAgIHRoaXMubW9kZWwgPSBuZXcgTW9kZWwoe30pO1xyXG4gICAgICAgIHRoaXMubW9kZWwuc2V0KENvbnN0YW50cy5FTEVNRU5UX1RZUEUsIFwic2NlbmVcIik7XHJcbiAgICAgICAgdGhpcy5tb2RlbC5zZXQoQ29uc3RhbnRzLk1PREUsIFwibm9ybWFsXCIpO1xyXG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdHM7XHJcbiAgICAgICAgRXZlbnRmdWwuY2FsbCh0aGlzKTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgZmlzaFRvcG9Qcm90byA9IEZpc2hUb3BvRmxvdy5wcm90b3R5cGU7XHJcblxyXG4gICAgZmlzaFRvcG9Qcm90by5mb3JjZUluc3RhbmNlID0gZm9yY2VJbnN0YW5jZTtcclxuICAgIGZpc2hUb3BvUHJvdG8udHJlZUxheW91dCA9IHRyZWVMYXlvdXQ7XHJcbiAgICAvKipcclxuICAgICAqIOiOt+WPliBmaXNoVG9wbyDlrp7kvovlrrnlmajnmoQgZG9tIOiKgueCuVxyXG4gICAgICogQHJldHVybiB7SFRNTEVsZW1lbnR9XHJcbiAgICAgKi9cclxuICAgIGZpc2hUb3BvUHJvdG8uZ2V0RG9tID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RvbTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBmaXNoVG9wb1Byb3RvLmdldFpyID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3pyO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICog6I635Y+WIGZpc2hUb3BvIOWunuS+i+WuueWZqOeahOWuveW6puOAglxyXG4gICAgICogQHJldHVybiB7bnVtYmVyfVxyXG4gICAgICovXHJcbiAgICBmaXNoVG9wb1Byb3RvLmdldFdpZHRoID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3pyLmdldFdpZHRoKCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICog6I635Y+WIGZpc2hUb3BvIOWunuS+i+WuueWZqOeahOmrmOW6puOAglxyXG4gICAgICogQHJldHVybiB7bnVtYmVyfVxyXG4gICAgICovXHJcbiAgICBmaXNoVG9wb1Byb3RvLmdldEhlaWdodCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl96ci5nZXRIZWlnaHQoKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICog5b2T5YmN5a6e5L6L5piv5ZCm5bey57uP6KKr6YeK5pS+44CCXHJcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufVxyXG4gICAgICovXHJcbiAgICBmaXNoVG9wb1Byb3RvLmlzRGlzcG9zZWQgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZGlzcG9zZWQ7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGlzcG9zZSBpbnN0YW5jZVxyXG4gICAgICovXHJcbiAgICBmaXNoVG9wb1Byb3RvLmRpc3Bvc2UgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB0aGlzLl9kaXNwb3NlZCA9IHRydWU7XHJcblxyXG4gICAgICAgIHRoaXMuX3pyLmRpc3Bvc2UoKTtcclxuXHJcbiAgICAgICAgaW5zdGFuY2VzW3RoaXMuaWRdID0gbnVsbDtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICog6LCD5pW05bC65a+4ICDlnKjnqpflj6PlpKflsI/lj5HnlJ/mlLnlj5jml7bpnIDopoHmiYvlt6XosIPnlKhcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCDlrr3luqZcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQg6auY5bqmXHJcbiAgICAgKi9cclxuICAgIGZpc2hUb3BvUHJvdG8ucmVzaXplID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdGhpcy5fenIucmVzaXplKCk7XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiDliJ3lp4vljJZcclxuICAgICAqL1xyXG4gICAgZmlzaFRvcG9Qcm90by5pbml0ID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMuZ3JvdXAgPSBuZXcgZ3JhcGhpYy5Hcm91cCgpO1xyXG4gICAgICAgIHRoaXMuZ3JvdXAuaXNCZyA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5ncm91cERyYWcodGhpcy5ncm91cCk7XHJcbiAgICAgICAgdGhpcy5fenIuYWRkKHRoaXMuZ3JvdXApO1xyXG4gICAgICAgIHRoaXMuenJTY2FsZSgpO1xyXG4gICAgICAgIEZsb3dDb25uZWN0aW9uTWFuYWdlci5jb25uZWN0b3JzID0gW107XHJcbiAgICAgICAgLy9tb3VzZXVwIOS8muWcqOWQhOS4qm5vZGXmiJbnur/nmoRjbGlja+S6i+S7tuS5i+eCueaJp+ihjCAg5Zyo6YCJ5Lit6IqC54K55oiW57q/5YmNIOWFiOa4heepuumAieS4reaViOaenFxyXG4gICAgICAgIHRoaXMuX3pyLm9uKFwibW91c2V1cFwiLCBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICAgIGNsZWFyU2VsZWN0KGUpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoYXQuX3pyLm9uKFwiZ2xvYmFsb3V0XCIsIGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgICAgY2xlYXJTZWxlY3QoZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgZnVuY3Rpb24gY2xlYXJTZWxlY3QoZSl7XHJcbiAgICAgICAgICAgIGlmICh0aGF0Lm9wZXJhdGlvbk5vZGUpIHtcclxuICAgICAgICAgICAgICAgIHRoYXQuZ3JvdXAucmVtb3ZlKHRoYXQub3BlcmF0aW9uTm9kZSk7XHJcbiAgICAgICAgICAgICAgICB0aGF0Lm9wZXJhdGlvbk5vZGUgPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBzaGFwZSA9IGUudGFyZ2V0O1xyXG4gICAgICAgICAgICBpZiAoc2hhcGUgJiYgc2hhcGUubW9kZWwgJiYgRmxvdy5pc0xpbmsoc2hhcGUubW9kZWwpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgRmxvd0Nvbm5lY3Rpb25NYW5hZ2VyLmNsZWFyU2VsZWN0Q29uKCk7XHJcbiAgICAgICAgICAgIGlmIChzaGFwZSAmJiBzaGFwZS5vcGVyYXRpb24gJiYgc2hhcGUub3BlcmF0aW9uID09IHRydWUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBMaW5lT3BlcmF0aW9uTWFuYWdlci5oaWRlQWxsTGluZU9wZXJhdGlvbigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl96ci5vbihcImNsaWNrXCIsIGZ1bmN0aW9uKGUpIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBzaGFwZSA9IGUudGFyZ2V0Lm1vZGVsO1xyXG4gICAgICAgICAgICBpZiAoKHNoYXBlICYmIEZsb3cuaXNMaW5rKHNoYXBlKSkgfHwgKHNoYXBlICYmIEZsb3cuaXNOb2RlKHNoYXBlKSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgcGFyYW1zID0ge307XHJcbiAgICAgICAgICAgIHBhcmFtcy5ldmVudCA9IGU7XHJcbiAgICAgICAgICAgIHBhcmFtcy50eXBlID0gXCJjbGlja1wiO1xyXG4gICAgICAgICAgICBwYXJhbXMudGFyZ2V0ID0gdGhhdDtcclxuICAgICAgICAgICAgdGhhdC5fYXBpLnRyaWdnZXIocGFyYW1zLnR5cGUsIHBhcmFtcyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5vbignY29uUG9pbnRzR3JvdXA6Y2xpY2snLCBmdW5jdGlvbihhcmd1bWVudCkge1xyXG4gICAgICAgICAgICBMaW5lT3BlcmF0aW9uTWFuYWdlci5iaW5kT3BlcmF0aW9uKGFyZ3VtZW50LmxpbmVOb2RlKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgLy9wb2x5ZmlsbCByZW1vdmVcclxuICAgICAgICBpZiAoISgncmVtb3ZlJyBpbiBFbGVtZW50LnByb3RvdHlwZSkpIHtcclxuICAgICAgICAgICAgRWxlbWVudC5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wYXJlbnROb2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDlr7zlh7pqc29uXHJcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IGpzb27lr7nosaFcclxuICAgICAqL1xyXG4gICAgZmlzaFRvcG9Qcm90by50b0pzb24gPSBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gRmxvd1V0aWwudG9Kc29uKHRoaXMubW9kZWwsIHRoaXMuZ3JvdXApO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIOWvvOWFpWpzb25cclxuICAgICAqIEBwYXJhbSAge09iamVjdH0ganNvbuWvueixoVxyXG4gICAgICovXHJcbiAgICBmaXNoVG9wb1Byb3RvLmZyb21Kc29uID0gZnVuY3Rpb24oanNvbikge1xyXG4gICAgICAgIHRoaXMuY2xlYXIoKTtcclxuICAgICAgICB2YXIgbW9kZWwgPSBuZXcgTW9kZWwoanNvbik7XHJcbiAgICAgICAgdGhpcy5zZXRCYWNrZ3JvdW5kKG1vZGVsLmdldChDb25zdGFudHMuQkFDS0dST1VORCkpO1xyXG4gICAgICAgIHZhciBsYXlvdXRSb290Tm9kZSA9IFtdO1xyXG4gICAgICAgIEZsb3dVdGlsLmZyb21Kc29uKHRoaXMsIHRoaXMuZ3JvdXAsIG1vZGVsLmdldChDb25zdGFudHMuQ0hJTERTKSwgZmFsc2UsIGxheW91dFJvb3ROb2RlKTtcclxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgbGF5b3V0Um9vdE5vZGUubGVuZ3RoOyBpKyspe1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhsYXlvdXRSb290Tm9kZSlcclxuICAgICAgICAgICAgdGhpcy5sYXlvdXROb2RlKFwidHJlZVwiLCB7XHJcbiAgICAgICAgICAgICAgICBcIm5vZGVcIjogbGF5b3V0Um9vdE5vZGVbaV0sXHJcbiAgICAgICAgICAgICAgICBcInR5cGVcIjpsYXlvdXRSb290Tm9kZVtpXS50cmVlVHlwZVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICog5re75Yqg6IqC54K5XHJcbiAgICAgKiBAbWV0aG9kIGFkZE5vZGVcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBub2RlIGNyZWF0Tm9kZei/lOWbnueahOWvueixoVxyXG4gICAgICovXHJcbiAgICBmaXNoVG9wb1Byb3RvLmFkZE5vZGUgPSBmdW5jdGlvbihub2RlKSB7XHJcbiAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBHcm91cE5vZGUpIHtcclxuICAgICAgICAgICAgbm9kZS5zZXRQcm9wZXJ0aWVzKHtcclxuICAgICAgICAgICAgICAgIHNoYXBlOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IG5vZGUuZ2V0Qm91bmRpbmdSZWN0KCkud2lkdGgsXHJcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBub2RlLmdldEJvdW5kaW5nUmVjdCgpLmhlaWdodFxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5ncm91cC5hZGQobm9kZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICog5riF56m65b2T5YmN5a6e5L6L77yM5Lya56e76Zmk5a6e5L6L5Lit5omA5pyJ55qE6IqC54K55LiO57q/XHJcbiAgICAgKiBAbWV0aG9kIGNsZWFyXHJcbiAgICAgKi9cclxuICAgIGZpc2hUb3BvUHJvdG8uY2xlYXIgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYWxsTm9kZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIHBhcmVudFpyO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5hbGxOb2Rlcy5wYXJlbnQpIHtcclxuICAgICAgICAgICAgICAgIHBhcmVudFpyID0gdGhpcy5hbGxOb2Rlcy5wYXJlbnQ7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBwYXJlbnRaciA9IHRoaXMuX3pyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIEZsb3dDb25uZWN0aW9uTWFuYWdlci5kZWxldGVTZWxlY3RDb24odGhpcy5hbGxOb2Rlc1tpXSwgcGFyZW50WnIpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIEZsb3dDb25uZWN0aW9uTWFuYWdlci5jb25uZWN0b3JNYXAuY2xlYXIoKTtcclxuICAgICAgICB0aGlzLmFsbE5vZGVzID0gW107XHJcbiAgICAgICAgdGhpcy5vcGVyYXRpb25Ob2RlID0gbnVsbDtcclxuICAgICAgICB0aGlzLnNlbGVjdGVkTm9kZSA9IG51bGw7XHJcbiAgICAgICAgRmxvd0Nvbm5lY3Rpb25NYW5hZ2VyLmNvbm5lY3RvcnMgPSBbXTtcclxuICAgICAgICB0aGlzLl96ci5jbGVhcigpO1xyXG4gICAgICAgIHRoaXMuZ3JvdXAgPSBuZXcgZ3JhcGhpYy5Hcm91cCgpO1xyXG4gICAgICAgIHRoaXMuZ3JvdXAuaXNCZyA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5fenIuYWRkKHRoaXMuZ3JvdXApO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIOWIm+W7uui/nue6v+eahOWwj+Wbvuagh+aTjeS9nFxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSDlsI/lm77moIfnmoTlkI3np7BcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIOWwj+Wbvuagh+eahOebuOWFs+WPguaVsFxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmljb25dIOWwj+Wbvuagh+i3r+W+hFxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmxpbmVOb2RlXSDnur/mrrXlrp7kvotcclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmNhbGxiYWNrXSDngrnlh7vlkI7nmoTlm57osINcclxuICAgICAqXHJcbiAgICAgKiAqKuS9v+eUqOiMg+S+iyoq77yaXHJcbiAgICAgKlxyXG4gICAgICogICAgICBAZXhhbXBsZVxyXG4gICAgICogICAgICAgICAgICAgICAgICB0aGlzLmZpc2hUb3BvLmFkZEljb24oXCJpY29uMVwiLCB7XHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICBpY29uOiBcImh0dHBzOi8vc3MwLmJkc3RhdGljLmNvbS81YVYxYmpxaF9RMjNvZENmL3N0YXRpYy9zdXBlcm1hbi9pbWcvbG9nb190b3BfY2E3OWExNDYucG5nXCIsXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICBsaW5lTm9kZTogbGluZU5vZGUsXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjazogZnVuY3Rpb24obGluZU5vZGUpIHtcclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICBhbGVydChKU09OLnN0cmluZ2lmeShsaW5lTm9kZSkpXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICogICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAqL1xyXG4gICAgZmlzaFRvcG9Qcm90by5hZGRJY29uID0gZnVuY3Rpb24oa2V5LCBvcHRpb25zKSB7XHJcbiAgICAgICAgTGluZU9wZXJhdGlvbk1hbmFnZXIuYWRkSWNvbihrZXksIG9wdGlvbnMsIHRoaXMuZ3JvdXAsIHRoaXMuX2FwaSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICog5Yib5bu66L+e57q/55qE6buY6K6k5Yig6Zmk5pON5L2cXHJcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IGxpbmVOb2RlIOe6v1xyXG4gICAgICpcclxuICAgICAqICAqKuS9v+eUqOiMg+S+iyoq77yaXHJcbiAgICAgKlxyXG4gICAgICogICAgICBAZXhhbXBsZVxyXG4gICAgICogICAgICBmaXNoVG9wby5saW5lRGVmYXVsdEljb24obGluZU5vZGUpO1xyXG4gICAgICovXHJcbiAgICBmaXNoVG9wb1Byb3RvLmxpbmVEZWZhdWx0SWNvbiA9IGZ1bmN0aW9uKGxpbmVOb2RlKSB7XHJcbiAgICAgICAgdGhpcy5hZGRMaW5lRGVsZXRlSWNvbihsaW5lTm9kZSk7XHJcbiAgICAgICAgdGhpcy5hZGRMaW5lQ2hhbmdlSWNvbihsaW5lTm9kZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIOa3u+WKoOe6v+eahOWIoOmZpOWbvuagh1xyXG4gICAgICovXHJcbiAgICBmaXNoVG9wb1Byb3RvLmFkZExpbmVEZWxldGVJY29uID0gZnVuY3Rpb24obGluZU5vZGUpIHtcclxuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XHJcbiAgICAgICAgdmFyIHBhcmVudFpyO1xyXG4gICAgICAgIGlmIChsaW5lTm9kZS5wYXJlbnQpIHtcclxuICAgICAgICAgICAgcGFyZW50WnIgPSBsaW5lTm9kZS5wYXJlbnQ7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcGFyZW50WnIgPSB0aGlzLmdyb3VwO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvL+WIm+W7uuWIoOmZpFxyXG4gICAgICAgIHZhciBsaW5lT3BlcmF0aW9uID0gTGluZU9wZXJhdGlvbk1hbmFnZXIuYWRkSWNvbihcImRlbGV0ZVwiLCBMaW5lT3BlcmF0aW9uTWFuYWdlci5kZWxldGVJY29uT2JqKHBhcmVudFpyLCBsaW5lTm9kZSksIHBhcmVudFpyLCB0aGlzLl9hcGkpO1xyXG4gICAgICAgIGlmIChsaW5lT3BlcmF0aW9uKSB7XHJcbiAgICAgICAgICAgIGxpbmVPcGVyYXRpb24ub24oXCJjbGlja1wiLCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIHRoYXQuX3RyaWdnZXJEZWxldGVFdmVudChsaW5lTm9kZSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICog5re75Yqg57q/55qE5YiH5o2i5Zu+5qCHXHJcbiAgICAgKi9cclxuICAgIGZpc2hUb3BvUHJvdG8uYWRkTGluZUNoYW5nZUljb24gPSBmdW5jdGlvbihsaW5lTm9kZSkge1xyXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgICAgICB2YXIgcGFyZW50WnI7XHJcbiAgICAgICAgaWYgKGxpbmVOb2RlLnBhcmVudCkge1xyXG4gICAgICAgICAgICBwYXJlbnRaciA9IGxpbmVOb2RlLnBhcmVudDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBwYXJlbnRaciA9IHRoaXMuZ3JvdXA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBhcnJMaW5lVHlwZSA9IFtDb25uZWN0b3IuVFlQRV9TVFJBSUdIVCwgQ29ubmVjdG9yLlRZUEVfSkFHR0VELCBDb25uZWN0b3IuVFlQRV9DVVJWRV07XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIG1vZGlmeU5leHRMaW5lVHlwZShsaW5lKSB7XHJcbiAgICAgICAgICAgIHZhciBpbmRleCA9IHpyVXRpbC5pbmRleE9mKGFyckxpbmVUeXBlLCBsaW5lLm9wdGlvbnMuc3R5bGUubGluZVR5cGUpO1xyXG4gICAgICAgICAgICB2YXIgbmV4dExpbmVUeXBlID0gYXJyTGluZVR5cGVbKGluZGV4ICsgMSkgJSBhcnJMaW5lVHlwZS5sZW5ndGhdO1xyXG4gICAgICAgICAgICAvL0Zsb3dDb25uZWN0aW9uTWFuYWdlci5zZXRNb2RlbChsaW5lLHtzdHlsZTp7bGluZVR5cGU6bmV4dExpbmVUeXBlfX0pO1xyXG4gICAgICAgICAgICB2YXIgc3RhcnROb2RlID0gbGluZS5zdGFydE5vZGU7XHJcbiAgICAgICAgICAgIHZhciBlbmROb2RlID0gbGluZS5lbmROb2RlO1xyXG5cclxuICAgICAgICAgICAgRmxvd0Nvbm5lY3Rpb25NYW5hZ2VyLmRlbGV0ZUxpbmUocGFyZW50WnIpO1xyXG4gICAgICAgICAgICBMaW5lT3BlcmF0aW9uTWFuYWdlci5oaWRlQWxsTGluZU9wZXJhdGlvbigpO1xyXG5cclxuICAgICAgICAgICAgdmFyIG5leHRMaW5lID0gdGhhdC5fY3JlYXRlQ29ubmVjdG9yQnlOb2RlcyhzdGFydE5vZGUsIGVuZE5vZGUsIG5leHRMaW5lVHlwZSk7XHJcbiAgICAgICAgICAgIG5leHRMaW5lLmljb25zID0gbGluZS5pY29ucztcclxuICAgICAgICAgICAgbmV4dExpbmUub24oJ2NsaWNrJywgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICBMaW5lT3BlcmF0aW9uTWFuYWdlci5iaW5kT3BlcmF0aW9uKG5leHRMaW5lKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXh0TGluZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8v5Yib5bu65YiH5o2iXHJcbiAgICAgICAgTGluZU9wZXJhdGlvbk1hbmFnZXIuYWRkSWNvbihcImNoYW5nZVwiLCB7XHJcbiAgICAgICAgICAgIGljb246IFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFCY0FBQUFQQkFNQUFBRDlnVWxsQUFBQUJHZEJUVUVBQUxHUEMveGhCUUFBQUFGelVrZENBSzdPSE9rQUFBQXFVRXhVUlFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQW9Uem9nQUFBQU9kRkpPVXdEK0NDM3V1UjdnVlhlZUZFbk1SSUVESndBQUFHUkpSRUZVQ05kallPQ1p3SUFBN1l1VVFBRE0xblFzRFFXQkJCQm5vU0FZaUJpQU9HZVJPV3dMSXpwQVlBTkVFN0pwREJ0UUtBaVlxUUNtbEkxQllPRnFNTWZjQlFRRVJjRUdta0JNRnd3QWNXekxRY0JSQ3V3SXRUUVFXRDRKeWJRNURBd0FPNzRiMFM4M095TUFBQUFBU1VWT1JLNUNZSUk9XCIsXHJcbiAgICAgICAgICAgIHdpZHRoOiAxNSxcclxuICAgICAgICAgICAgaGVpZ2h0OiAxNSxcclxuICAgICAgICAgICAgbGluZU5vZGU6IGxpbmVOb2RlLFxyXG4gICAgICAgICAgICBjYWxsYmFjazogZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIHNlbGVjdGVkTGluZSA9IG1vZGlmeU5leHRMaW5lVHlwZShGbG93Q29ubmVjdGlvbk1hbmFnZXIuc2VsQ29ubmVjdG9yKTtcclxuICAgICAgICAgICAgICAgIC8vLiAgTGluZU9wZXJhdGlvbk1hbmFnZXIuYmluZE9wZXJhdGlvbihzZWxlY3RlZExpbmUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSwgcGFyZW50WnIsIHRoaXMuX2FwaSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIOWIneWni+WMliDmk43kvZznmoTomZrnur/moYZcclxuICAgICAqL1xyXG4gICAgZmlzaFRvcG9Qcm90by5pbml0T3BlcmF0aW9uTm9kZSA9IGZ1bmN0aW9uKG5vZGUpIHtcclxuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5vcGVyYXRpb25Ob2RlID0gbmV3IE9wZXJhdGlvbk5vZGUobm9kZSwgdGhpcy5ncm91cCk7XHJcblxyXG4gICAgICAgIHRoaXMub3BlcmF0aW9uTm9kZS5vbihPcGVyYXRpb25Ob2RlLkFSUk9XX0RSQUdTVEFSVCwgZnVuY3Rpb24oZSkge1xyXG4gICAgICAgICAgICB2YXIgeCA9IChlLmV2ZW50Lm9mZnNldFggLSB0aGF0Lmdyb3VwLnBvc2l0aW9uWzBdKSAvIHRoYXQubm93Wm9vbTtcclxuICAgICAgICAgICAgdmFyIHkgPSAoZS5ldmVudC5vZmZzZXRZIC0gdGhhdC5ncm91cC5wb3NpdGlvblsxXSkgLyB0aGF0Lm5vd1pvb207XHJcbiAgICAgICAgICAgIC8v5ouW5ou95byA5aeL5YWI5oqKIOeureWktOWbvuaghyDnu5npmpDol49cclxuICAgICAgICAgICAgdmFyIGFycm93ID0gZS5ldmVudC50YXJnZXQ7XHJcbiAgICAgICAgICAgIGFycm93LmhpZGUoKTtcclxuICAgICAgICAgICAgdmFyIHJFbmRQb2ludCA9IG5ldyBQb2ludCh4LCB5KTtcclxuICAgICAgICAgICAgdmFyIGNvbm5lY3RvciA9IEZsb3dDb25uZWN0aW9uTWFuYWdlci5tYW5hZ2VUZW1wQ29ubmVjdG9yKHRoYXQuc2VsZWN0ZWROb2RlLCByRW5kUG9pbnQsIGFycm93LmxpbmVUeXBlKTtcclxuICAgICAgICAgICAgdGhhdC5ncm91cC5hZGQoY29ubmVjdG9yKTtcclxuICAgICAgICAgICAgZS5jYW5jZWxCdWJibGUgPSB0cnVlO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICAvLyDkvqblkKwg566t5aS0IOaLluaLveS6i+S7tlxyXG4gICAgICAgIHRoaXMub3BlcmF0aW9uTm9kZS5vbihPcGVyYXRpb25Ob2RlLkFSUk9XX0RSQUcsIGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgICAgdmFyIHggPSAoZS5ldmVudC5vZmZzZXRYIC0gdGhhdC5ncm91cC5wb3NpdGlvblswXSkgLyB0aGF0Lm5vd1pvb207XHJcbiAgICAgICAgICAgIHZhciB5ID0gKGUuZXZlbnQub2Zmc2V0WSAtIHRoYXQuZ3JvdXAucG9zaXRpb25bMV0pIC8gdGhhdC5ub3dab29tO1xyXG4gICAgICAgICAgICB2YXIgYXJyb3cgPSBlLmV2ZW50LnRhcmdldDtcclxuICAgICAgICAgICAgdmFyIHJFbmRQb2ludCA9IG5ldyBQb2ludCh4LCB5KTtcclxuICAgICAgICAgICAgRmxvd0Nvbm5lY3Rpb25NYW5hZ2VyLm1hbmFnZVRlbXBDb25uZWN0b3IodGhhdC5zZWxlY3RlZE5vZGUsIHJFbmRQb2ludCwgYXJyb3cubGluZVR5cGUpO1xyXG4gICAgICAgICAgICBlLmNhbmNlbEJ1YmJsZSA9IHRydWU7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIC8v5L6m5ZCsIOeureWktCDmi5bmi73nu5PmnZ/kuovku7Yg55S757q/XHJcbiAgICAgICAgdGhpcy5vcGVyYXRpb25Ob2RlLm9uKE9wZXJhdGlvbk5vZGUuQVJST1dfRFJBR0VORCwgZnVuY3Rpb24oZSkge1xyXG4gICAgICAgICAgICBlLmNhbmNlbEJ1YmJsZSA9IHRydWU7XHJcbiAgICAgICAgICAgIHZhciB4ID0gZS5ldmVudC5vZmZzZXRYO1xyXG4gICAgICAgICAgICB2YXIgeSA9IGUuZXZlbnQub2Zmc2V0WTtcclxuICAgICAgICAgICAgdmFyIHRhcmdldE5vZGUgPSBudWxsO1xyXG4gICAgICAgICAgICAvL+aLluaLvee7k+adn+WFiOaKiiDnrq3lpLTlm77moIcg57uZ5pi+56S6XHJcbiAgICAgICAgICAgIHZhciBhcnJvdyA9IGUuZXZlbnQudGFyZ2V0O1xyXG4gICAgICAgICAgICBhcnJvdy5zaG93KCk7XHJcbiAgICAgICAgICAgIC8v5Yig6Zmk5Li05pe257q/XHJcbiAgICAgICAgICAgIEZsb3dDb25uZWN0aW9uTWFuYWdlci5yZW1vdmVUZW1wQ29ubmVjdG9yKHRoYXQuZ3JvdXApO1xyXG5cclxuICAgICAgICAgICAgLy8xLuWmguaenOaYr+WtkOiKgueCuSDlhoUg6IqC54K55ouW5ou9IOWImSDlop7liqDmjpLpmaTlrZDoioLngrnnmoTlj4LmlbBcclxuICAgICAgICAgICAgdGFyZ2V0Tm9kZSA9IGZpbmRIb3Zlcih0aGF0LmFsbE5vZGVzLCB4LCB5KTtcclxuXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIGlzSG92ZXIobm9kZSwgeCwgeSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGN4LCBjeTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBub2RlLnJlY3RDb250YWluKHgsIHkpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBmdW5jdGlvbiBmaW5kSG92ZXIobGlzdCwgeCwgeSwgZXhjbHVkZXMpIHtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSBsaXN0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzRXhjbHVkZShleGNsdWRlcywgbGlzdFtpXSkgLy9saXN0W2ldICE9PSBleGNsdWRlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGdldERpc3BsYXlMaXN0IG1heSBpbmNsdWRlIGlnbm9yZWQgaXRlbSBpbiBWTUwgbW9kZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAmJiAhbGlzdFtpXS5pZ25vcmUgJiYgaXNIb3ZlcihsaXN0W2ldLCB4LCB5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGlzdFtpXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIGlzRXhjbHVkZShleGNsdWRlcywgbm9kZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHpyVXRpbC5pbmRleE9mKGV4Y2x1ZGVzLCBub2RlKSA9PSAtMTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8yLuWmguaenOaJvuWIsOebruagh+e7k+eCuSDliJnnlLvnur9cclxuICAgICAgICAgICAgaWYgKHRhcmdldE5vZGUgJiYgKHRoYXQuc2VsZWN0ZWROb2RlICE9IHRhcmdldE5vZGUpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGF0Ll9jcmVhdGVDb25uZWN0b3JCeU5vZGVzKHRoYXQuc2VsZWN0ZWROb2RlLCB0YXJnZXROb2RlLCBhcnJvdy5saW5lVHlwZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgLy/liKDpmaTmjInpkq7ngrnlh7vkuovku7ZcclxuICAgICAgICB0aGlzLm9wZXJhdGlvbk5vZGUub24oT3BlcmF0aW9uTm9kZS5ERUxFVEVfQ0xJQ0ssIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB0aGF0Ll90cmlnZ2VyRGVsZXRlRXZlbnQodGhhdC5zZWxlY3RlZE5vZGUpO1xyXG4gICAgICAgICAgICB0aGF0LnJlbW92ZU5vZGUodGhhdC5zZWxlY3RlZE5vZGUpO1xyXG4gICAgICAgICAgICBpZiAodGhhdC5zZWxlY3RlZE5vZGUuY21zSW1hZ2UpIHtcclxuICAgICAgICAgICAgICAgIHRoYXQuX3RyaWdnZXJEZWxldGVFdmVudCh0aGF0LnNlbGVjdGVkTm9kZS5jbXNJbWFnZSk7XHJcbiAgICAgICAgICAgICAgICB0aGF0LnJlbW92ZU5vZGUodGhhdC5zZWxlY3RlZE5vZGUuY21zSW1hZ2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5ncm91cC5hZGQodGhpcy5vcGVyYXRpb25Ob2RlKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDnp7vpmaTlnLrmma/kuK3nmoTmn5DkuKroioLngrlcclxuICAgICAqIEBwYXJhbSAge09iamVjdH0gc2VsZWN0ZWROb2RlIOW+heWIoOmZpOeahOiKgueCuVxyXG4gICAgICovXHJcbiAgICBmaXNoVG9wb1Byb3RvLnJlbW92ZU5vZGUgPSBmdW5jdGlvbihzZWxlY3RlZE5vZGUpIHtcclxuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XHJcbiAgICAgICAgLy8xLuWmguaenOaYr+WtkOiKgueCuSDlhoUg6IqC54K5ICDliJkg6LCD55So5a2Q6IqC54K555qE5Yig6ZmkXHJcbiAgICAgICAgaWYgKHNlbGVjdGVkTm9kZS5wYXJlbnQpIHtcclxuICAgICAgICAgICAgc2VsZWN0ZWROb2RlLnBhcmVudC5yZW1vdmUoc2VsZWN0ZWROb2RlKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGF0Lmdyb3VwLnJlbW92ZShzZWxlY3RlZE5vZGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLzIu5LuOYWxsTm9kZXPmlbDnu4TkuK3liKDpmaRcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoYXQuYWxsTm9kZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKHNlbGVjdGVkTm9kZS5pZCA9PSB0aGF0LmFsbE5vZGVzW2ldLmlkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGF0LmFsbE5vZGVzLnNwbGljZShpLCAxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBGbG93Q29ubmVjdGlvbk1hbmFnZXIuZGVsZXRlU2VsZWN0Q29uKHNlbGVjdGVkTm9kZSwgdGhhdC5ncm91cCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIOa0vuWPkWRlbGV0ZeS6i+S7tlxyXG4gICAgICovXHJcbiAgICBmaXNoVG9wb1Byb3RvLl90cmlnZ2VyRGVsZXRlRXZlbnQgPSBmdW5jdGlvbih0YXJnZXQpIHtcclxuICAgICAgICB2YXIgZXZlbnRQYXJhbXMgPSB7fTtcclxuICAgICAgICBldmVudFBhcmFtcy50eXBlID0gXCJkZWxldGVcIjtcclxuICAgICAgICBldmVudFBhcmFtcy50YXJnZXQgPSB0YXJnZXQ7XHJcbiAgICAgICAgdGhpcy5fYXBpLnRyaWdnZXIoZXZlbnRQYXJhbXMudHlwZSwgZXZlbnRQYXJhbXMpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIGZpc2hUb3BvUHJvdG8uX2NyZWF0ZUNvbm5lY3RvckJ5Tm9kZXMgPSBmdW5jdGlvbihzdGFydE5vZGUsIGVuZE5vZGUsIGxpbmVUeXBlKSB7XHJcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgICAgIHZhciBjb25uZWN0b3IgPSBGbG93Q29ubmVjdGlvbk1hbmFnZXIuY29ubmVjdG9yQ3JlYXRlKHN0YXJ0Tm9kZSwgZW5kTm9kZSwge1xyXG4gICAgICAgICAgICBzdHlsZToge1xyXG4gICAgICAgICAgICAgICAgbGluZVR5cGU6IGxpbmVUeXBlXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LCB0aGlzLl9hcGkpO1xyXG4gICAgICAgIGlmIChzdGFydE5vZGUucGFyZW50ICYmIGVuZE5vZGUucGFyZW50KSB7XHJcbiAgICAgICAgICAgIGVuZE5vZGUucGFyZW50LmFkZChjb25uZWN0b3IpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuZ3JvdXAuYWRkKGNvbm5lY3Rvcik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25uZWN0b3Iub24oXCJtb3VzZWRvd25cIiwgenJVdGlsLmJpbmQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIEZsb3dDb25uZWN0aW9uTWFuYWdlci5jb25uZWN0b3JGb3JiaWRFZGl0KCF0aGlzLm9wdGlvbnMubGlua01vZGlmeSk7XHJcbiAgICAgICAgICAgIHRoaXMuaXNOb2RlID0gZmFsc2U7XHJcbiAgICAgICAgfSwgdGhpcykpO1xyXG4gICAgICAgIGNvbm5lY3Rvci5vbihcImRibGNsaWNrXCIsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBpZiAodGhhdC5vcHRpb25zLmlzQWxsb3dFZGl0KSB7XHJcbiAgICAgICAgICAgICAgICB0aGF0LmNvbm5lY3RvckVkaXQodGhpcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgdGhpcy5fdHJpZ2dlckNyZWF0ZUV2ZW50KGNvbm5lY3Rvcik7XHJcbiAgICAgICAgcmV0dXJuIGNvbm5lY3RvcjtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICog5rS+5Y+R5Yib5bu65a6M5oiQ5LqL5Lu2XHJcbiAgICAgKi9cclxuICAgIGZpc2hUb3BvUHJvdG8uX3RyaWdnZXJDcmVhdGVFdmVudCA9IGZ1bmN0aW9uKHRhcmdldCkge1xyXG4gICAgICAgIHZhciBldmVudFBhcmFtcyA9IHt9O1xyXG4gICAgICAgIGV2ZW50UGFyYW1zLnR5cGUgPSBcImNyZWF0ZVwiO1xyXG4gICAgICAgIGV2ZW50UGFyYW1zLnRhcmdldCA9IHRhcmdldDtcclxuICAgICAgICB0aGlzLl9hcGkudHJpZ2dlcihldmVudFBhcmFtcy50eXBlLCBldmVudFBhcmFtcyk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIOm8oOagh+eCueS4iyDlsIbmk43kvZzmoYYg56e75Yiw5a+55bqU55qE6IqC54K55LiKXHJcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IG5vZGUgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBzWCAgIFtkZXNjcmlwdGlvbl1cclxuICAgICAqIEBwYXJhbSAge09iamVjdH0gc1kgICBbZGVzY3JpcHRpb25dXHJcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9ICAgICAgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICovXHJcbiAgICBmaXNoVG9wb1Byb3RvLm5vZGVDbGlja0hhbmRsZXIgPSBmdW5jdGlvbihub2RlLCBzWCwgc1kpIHtcclxuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XHJcbiAgICAgICAgdmFyIG5vZGUgPSBub2RlO1xyXG4gICAgICAgIGlmIChub2RlLm5vU2VsZWN0ZWQgPT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChub2RlLmZyb21DbXNJbWFnZSkge1xyXG4gICAgICAgICAgICBub2RlID0gbm9kZS5mcm9tQ21zSW1hZ2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGlmKG5vZGUgaW5zdGFuY2VvZiBHcm91cE5vZGUpe1xyXG4gICAgICAgIC8vICAgICBub2RlID0gbm9kZS5jaGlsZE9mTmFtZShcIlJlY3RcIik7XHJcbiAgICAgICAgLy8gfVxyXG4gICAgICAgIHRoaXMuc2VsZWN0ZWROb2RlID0gbm9kZTtcclxuICAgICAgICB2YXIgc2hhcGVSZWN0ID0gdXRpbC5nZXRSZWN0KG5vZGUpO1xyXG4gICAgICAgIGlmICghdGhpcy5vcGVyYXRpb25Ob2RlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaW5pdE9wZXJhdGlvbk5vZGUobm9kZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIOWcqOWtmOWcqOWtkOa1geeoi+eahOaDheWGteS4iyDpnIDopoHmiopub2Rl5Lmf5Lyg6YCS5LiA5LiLXHJcbiAgICAgICAgdGhpcy5vcGVyYXRpb25Ob2RlLnJlZnJlc2hQb3N0aW9uKG5vZGUsIHNoYXBlUmVjdCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIGZsb3fkuK3mnIDlpJblsYLnmoRncm91cOenu+WKqOaTjeS9nFxyXG4gICAgICovXHJcbiAgICBmaXNoVG9wb1Byb3RvLmdyb3VwRHJhZyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgICAgICB0aGF0Ll96ci5vbihcIm1vdXNlZG93blwiLCBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICAgIGlmICgoZS50YXJnZXQmJmUudGFyZ2V0Lm1vZGVsKSB8fCAoZS50YXJnZXQgJiYgZS50YXJnZXQubGluZVR5cGUgJiYgZS50YXJnZXQucGFyZW50KSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZ3JvdXBEcmFnRnVuY3Rpb24oZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gZ3JvdXBEcmFnRnVuY3Rpb24oZSkge1xyXG4gICAgICAgICAgICB2YXIgc3RhcnRYID0gZS5ldmVudC5jbGllbnRYO1xyXG4gICAgICAgICAgICB2YXIgc3RhcnRZID0gZS5ldmVudC5jbGllbnRZO1xyXG4gICAgICAgICAgICB2YXIgbW92ZUZ1bmN0aW9uID0gZnVuY3Rpb24oZSkge1xyXG4gICAgICAgICAgICAgICAgbW92ZURyYWcoZSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHZhciBub3dHcm91cFBvc2l0aW9uID0gdGhhdC5ncm91cC5wb3NpdGlvbjtcclxuICAgICAgICAgICAgdmFyIGdyb3VwUG9zaXRpb25YID0gdGhhdC5ncm91cC5wb3NpdGlvblswXTtcclxuICAgICAgICAgICAgdmFyIGdyb3VwUG9zaXRpb25ZID0gdGhhdC5ncm91cC5wb3NpdGlvblsxXTtcclxuXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIG1vdmVEcmFnKGUpIHtcclxuICAgICAgICAgICAgICAgIHZhciB3aWR0aCA9IHRoYXQuZ3JvdXAuZ2V0Qm91bmRpbmdSZWN0KCkud2lkdGggKiB0aGF0Lm5vd1pvb207XHJcbiAgICAgICAgICAgICAgICB2YXIgaGVpZ2h0ID0gdGhhdC5ncm91cC5nZXRCb3VuZGluZ1JlY3QoKS5oZWlnaHQgKiB0aGF0Lm5vd1pvb207XHJcbiAgICAgICAgICAgICAgICB2YXIgZ3ggPSB0aGF0Lmdyb3VwLmdldEJvdW5kaW5nUmVjdCgpLnggKiB0aGF0Lm5vd1pvb207XHJcbiAgICAgICAgICAgICAgICB2YXIgZ3kgPSB0aGF0Lmdyb3VwLmdldEJvdW5kaW5nUmVjdCgpLnkgKiB0aGF0Lm5vd1pvb207XHJcbiAgICAgICAgICAgICAgICB2YXIgbWluID0gWzEwIC0gKHdpZHRoICsgZ3gpLCAxMCAtIChoZWlnaHQgKyBneSldO1xyXG4gICAgICAgICAgICAgICAgdmFyIG1heCA9IFsodGhhdC5fenIuZ2V0V2lkdGgoKSAtIGd4KSAtIDEwLCAodGhhdC5fenIuZ2V0SGVpZ2h0KCkgLSBneSkgLSAxMF07XHJcbiAgICAgICAgICAgICAgICB2YXIgc1ggPSAoZS5ldmVudC5jbGllbnRYIC0gc3RhcnRYKTtcclxuICAgICAgICAgICAgICAgIHZhciBzWSA9IChlLmV2ZW50LmNsaWVudFkgLSBzdGFydFkpO1xyXG4gICAgICAgICAgICAgICAgbm93R3JvdXBQb3NpdGlvblswXSA9IGdyb3VwUG9zaXRpb25YICsgKHNYKTtcclxuICAgICAgICAgICAgICAgIG5vd0dyb3VwUG9zaXRpb25bMV0gPSBncm91cFBvc2l0aW9uWSArIChzWSk7XHJcbiAgICAgICAgICAgICAgICBpZiAobm93R3JvdXBQb3NpdGlvblswXSA+IG1heFswXSB8fCBub3dHcm91cFBvc2l0aW9uWzFdID4gbWF4WzFdIHx8IG5vd0dyb3VwUG9zaXRpb25bMF0gPCBtaW5bMF0gfHwgbm93R3JvdXBQb3NpdGlvblsxXSA8IG1pblsxXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5ncm91cC5hdHRyKFwicG9zaXRpb25cIiwgbm93R3JvdXBQb3NpdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoYXQuZWFnbGVFeWUgPT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGF0Lm1pbmltYXAudXBkYXRhU2VsZWN0aW9uUG9zaXRpb24obm93R3JvdXBQb3NpdGlvbiwgdGhhdC5ub3dab29tKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0aGF0Ll96ci5vbignbW91c2Vtb3ZlJywgbW92ZUZ1bmN0aW9uKTtcclxuICAgICAgICAgICAgdmFyIHVwRnVuY3Rpb24gPSBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICAgICAgICBlbmREcmFnKGUpO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgZnVuY3Rpb24gZW5kRHJhZygpIHtcclxuICAgICAgICAgICAgICAgIHRoYXQuX3pyLm9mZignbW91c2Vtb3ZlJywgbW92ZUZ1bmN0aW9uKTtcclxuICAgICAgICAgICAgICAgIHRoYXQuX3pyLm9mZignbW91c2V1cCcsIHVwRnVuY3Rpb24pO1xyXG4gICAgICAgICAgICAgICAgdGhhdC5fenIub2ZmKFwiZ2xvYmFsb3V0XCIsIHVwRnVuY3Rpb24pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0aGF0Ll96ci5vbignbW91c2V1cCcsIHVwRnVuY3Rpb24pO1xyXG4gICAgICAgICAgICB0aGF0Ll96ci5vbihcImdsb2JhbG91dFwiLCB1cEZ1bmN0aW9uKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIOiKgueCueeahOenu+WKqOaTjeS9nFxyXG4gICAgICovXHJcbiAgICBmaXNoVG9wb1Byb3RvLmRyYWcgPSBmdW5jdGlvbihub2RlKSB7XHJcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgICAgIG5vZGUub24oXCJtb3VzZWRvd25cIiwgZnVuY3Rpb24oZSkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5pc2RyYWdnYWJsZSA9PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGdyb3VwRHJhZ0Z1bmN0aW9uKGUpO1xyXG4gICAgICAgICAgICBlLmNhbmNlbEJ1YmJsZSA9IHRydWU7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIGdyb3VwRHJhZ0Z1bmN0aW9uKGUpIHtcclxuICAgICAgICAgICAgdmFyIGlzTW92ZSA9IDA7XHJcbiAgICAgICAgICAgIG5vZGUuc3RhcnRYID0gZS5ldmVudC5jbGllbnRYO1xyXG4gICAgICAgICAgICBub2RlLnN0YXJ0WSA9IGUuZXZlbnQuY2xpZW50WTtcclxuICAgICAgICAgICAgdmFyIG1vdmVGdW5jdGlvbiA9IGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgICAgICAgIG1vdmVEcmFnKGUpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB2YXIgbm93R3JvdXBQb3NpdGlvbiA9IG5vZGUucG9zaXRpb247XHJcbiAgICAgICAgICAgIHZhciBncm91cFBvc2l0aW9uWCA9IG5vZGUucG9zaXRpb25bMF07XHJcbiAgICAgICAgICAgIHZhciBncm91cFBvc2l0aW9uWSA9IG5vZGUucG9zaXRpb25bMV07XHJcblxyXG4gICAgICAgICAgICBmdW5jdGlvbiBtb3ZlRHJhZyhlKSB7XHJcbiAgICAgICAgICAgICAgICBlLmNhbmNlbEJ1YmJsZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB2YXIgc1ggPSAoZS5ldmVudC5jbGllbnRYIC0gbm9kZS5zdGFydFgpIC8gKHRoYXQubm93Wm9vbSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgc1kgPSAoZS5ldmVudC5jbGllbnRZIC0gbm9kZS5zdGFydFkpIC8gKHRoYXQubm93Wm9vbSk7XHJcbiAgICAgICAgICAgICAgICAvLyBub2RlLnN0YXJ0WCA9IGUuZXZlbnQuY2xpZW50WDtcclxuICAgICAgICAgICAgICAgIC8vIG5vZGUuc3RhcnRZID0gZS5ldmVudC5jbGllbnRZO1xyXG4gICAgICAgICAgICAgICAgaWYgKHNYID4gMCB8fCBzWSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlzTW92ZSA9IDE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBub2RlLmRyaWZ0KHNYLCBzWSwgZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5wYXJlbnQgJiYgbm9kZS5wYXJlbnQgaW5zdGFuY2VvZiBHcm91cE5vZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAvL+aUvuWFpW5vZGXnjrDmnInmlbDlgLzvvIznlKjkuo7ph43nu5hncm91cFxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBub2RlTWVzc2FnZSA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IG5vZGUuc2hhcGUud2lkdGgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogbm9kZS5zaGFwZS5oZWlnaHQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBub2RlLnBvc2l0aW9uLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlWFk6IFtub2RlLnNoYXBlLngsIG5vZGUuc2hhcGUueV0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vdmVQb3NpdGlvbjogW2dyb3VwUG9zaXRpb25YLCBncm91cFBvc2l0aW9uWV0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vdmVYOiBzWCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbW92ZVk6IHNZXHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZ3JvdXBOb2RlID0gbm9kZS5wYXJlbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXBOb2RlLnJlRHJhdyhub2RlTWVzc2FnZSwgbm9kZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBub3dHcm91cFBvc2l0aW9uWzBdID0gZ3JvdXBQb3NpdGlvblggKyBzWDtcclxuICAgICAgICAgICAgICAgIG5vd0dyb3VwUG9zaXRpb25bMV0gPSBncm91cFBvc2l0aW9uWSArIHNZO1xyXG4gICAgICAgICAgICAgICAgbm9kZS5hdHRyKFwicG9zaXRpb25cIiwgbm93R3JvdXBQb3NpdGlvbik7XHJcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5hbGFybSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXdBbGFybVBvc2l0aW9uID0gW25vd0dyb3VwUG9zaXRpb25bMF0gKyBub2RlLmdldEJvdW5kaW5nUmVjdCgpLndpZHRoIC0gKG5vZGUuYWxhcm0uZ2V0Qm91bmRpbmdSZWN0KCkud2lkdGggLSA2KSwgbm93R3JvdXBQb3NpdGlvblsxXSAtIG5vZGUuYWxhcm0uZ2V0Qm91bmRpbmdSZWN0KCkuaGVpZ2h0IC0gM107XHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5hbGFybS5hdHRyKFwicG9zaXRpb25cIiwgbmV3QWxhcm1Qb3NpdGlvbik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5jbXNJbWFnZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXdBbGFybVBvc2l0aW9uMSA9IFtub3dHcm91cFBvc2l0aW9uWzBdLCBub3dHcm91cFBvc2l0aW9uWzFdIC0gOF07XHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5jbXNJbWFnZS5hdHRyKFwicG9zaXRpb25cIiwgbmV3QWxhcm1Qb3NpdGlvbjEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKG5vZGUuZnJvbUNtc0ltYWdlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5ld0FsYXJtUG9zaXRpb24yID0gW25vd0dyb3VwUG9zaXRpb25bMF0sIG5vd0dyb3VwUG9zaXRpb25bMV0gKyA4XTtcclxuICAgICAgICAgICAgICAgICAgICBub2RlLmZyb21DbXNJbWFnZS5hdHRyKFwicG9zaXRpb25cIiwgbmV3QWxhcm1Qb3NpdGlvbjIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhhdC5ub2RlQ2xpY2tIYW5kbGVyKG5vZGUsIGUuZXZlbnQuY2xpZW50WCwgZS5ldmVudC5jbGllbnRZKTtcclxuICAgICAgICAgICAgICAgIEZsb3dDb25uZWN0aW9uTWFuYWdlci5yZWZyZXNoTGluZUJ5Tm9kZShub2RlKTtcclxuICAgICAgICAgICAgICAgIGlmIChub2RlLmZyb21DbXNJbWFnZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIEZsb3dDb25uZWN0aW9uTWFuYWdlci5yZWZyZXNoTGluZUJ5Tm9kZShub2RlLmZyb21DbXNJbWFnZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBpZih0aGF0LmVhZ2xlRXllID09IHRydWUpe1xyXG4gICAgICAgICAgICAgICAgLy8gICAgIHRoYXQub3BlbkVhZ2xlRXllKHRoYXQuZWFnbGVFeWVOb2RlKTtcclxuICAgICAgICAgICAgICAgIC8vIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhhdC5fenIub24oJ21vdXNlbW92ZScsIG1vdmVGdW5jdGlvbik7XHJcbiAgICAgICAgICAgIHZhciB1cEZ1bmN0aW9uID0gZnVuY3Rpb24oZSkge1xyXG4gICAgICAgICAgICAgICAgZW5kRHJhZyhlKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLy/mi5bmi73nu5PmnZ9cclxuICAgICAgICAgICAgZnVuY3Rpb24gZW5kRHJhZygpIHtcclxuICAgICAgICAgICAgICAgIGlmIChub2RlLm1vZGVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5tb2RlbC5zZXQoXCJvcHRpb25zLnBvc2l0aW9uXCIsIG5vZGUucG9zaXRpb24pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHRoYXQuX3pyLm9mZignbW91c2Vtb3ZlJywgbW92ZUZ1bmN0aW9uKTtcclxuICAgICAgICAgICAgICAgIHRoYXQuX3pyLm9mZignbW91c2V1cCcsIHVwRnVuY3Rpb24pO1xyXG4gICAgICAgICAgICAgICAgdGhhdC5fenIub2ZmKFwiZ2xvYmFsb3V0XCIsIHVwRnVuY3Rpb24pO1xyXG4gICAgICAgICAgICAgICAgLy/luIPlsYDph43mlrDorqHnrpdcclxuICAgICAgICAgICAgICAgIGlmIChub2RlLmxheW91dCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoYXQubGF5b3V0Tm9kZShcInRyZWVcIiwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBcIm5vZGVcIjogbm9kZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgXCJ0eXBlXCI6bm9kZS50cmVlVHlwZVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHRoYXQuZm9yY2VMYXlvdXRPcHRpb24gJiYgKCF0aGF0LmZvcmNlTGF5b3V0T3B0aW9uLm9uY2UpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5vZGVzID0gdGhhdC5mb3JjZUxheW91dE9wdGlvbi5hbGxOb2RlcztcclxuICAgICAgICAgICAgICAgICAgICBpZiAoenJVdGlsLmluZGV4T2Yobm9kZXMsIG5vZGUpICE9IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQubGF5b3V0Tm9kZShcImZvcmNlXCIsIHRoaXMuZm9yY2VMYXlvdXRPcHRpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChpc01vdmUgPT0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGF0LmVhZ2xlRXllID09IHRydWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5vcGVuRWFnbGVFeWUodGhhdC5lYWdsZUV5ZU5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHRoYXQuX3pyLm9uKCdtb3VzZXVwJywgdXBGdW5jdGlvbik7XHJcbiAgICAgICAgICAgIHRoYXQuX3pyLm9uKFwiZ2xvYmFsb3V0XCIsIHVwRnVuY3Rpb24pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDliJvlu7roioLngrlcclxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gdHlwZSDnsbvlnosgZWcuICdSZWN0J+OAgSdDaXJjbGUn44CBJ0ltYWdlJ+OAgSdHcm91cCfjgIEnVGV4dCfnrYlcclxuICAgICAqIEBwYXJhbSAge09iamVjdH0gb3B0IOiKgueCuemAiemhuVxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gIFtvcHQucG9zaXRpb25dIOiKgueCueeahOS9jee9riBlZy4gW3gseV1cclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0LnN0eWxlXSDoioLngrnnmoTmoLflvI9cclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0LnN0eWxlLnRleHRdIOiKgueCueS4i+aWue+8iOm7mOiupO+8ieaYvuekuueahOaWh+Wtl1xyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHQuc3R5bGUuZmlsbF0g6IqC54K555qE5aGr5YWF6aKc6Imy5YC8IGVnLiAnIzE1N2NmZicgICdyZ2IoMTIyLDEyMiwxMjIpJ1xyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHQuc3R5bGUuc3Ryb2tlXSDoioLngrnnmoTmj4/ovrnpopzoibLlgLwgZWcuICcjMTU3Y2ZmJyAgJ3JnYigxMjIsMTIyLDEyMiknXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdC5zdHlsZS50ZXh0Rm9udF0g6K6+572u5paH5a2X55qE5a2X5L2T5L+h5oGvIGVnLiAnMTRweCBNaWNyb3NvZnQgWWFIZWknXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdC5zdHlsZS50ZXh0RmlsbF0g6K6+572u5paH5a2X55qE6aKc6Imy5YC8IGVnLiAnI2ZmZmZmZidcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0LnN0eWxlLnRleHRQb3NpdGlvbl0g6K6+572u5paH5a2X5Zyo6IqC54K55Lit55qE5L2N572uIGVnLiAndG9wJywncmlnaHQnLCdib3R0b20nLCAnbGVmdCcsJ2luc2lkZSdcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0Lm1lcmdlZEltYWdlXSDnu4TlkIjlubblkI7mmL7npLrnmoTlm77niYfvvIjnu4TnibnmnInnmoTlsZ7mgKfvvIlcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0LmxheW91dF0g6IqC54K5dHJlZeW4g+WxgOWxnuaAp++8iHRyZWXluIPlsYDnmoToioLngrnmiY3pnIDopoHvvIlcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0LmxheW91dC53aWR0aF0g57uT54K555qE5a2Q6IqC54K55LmL6Ze055qE6Led56a7XHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdC5sYXlvdXQuaGVpZ2h0XSDnu5PngrnnmoTlrZDoioLngrnliLDnu5PngrnnmoTot53nprtcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0LnNoYXBlXSDmr4/np43lvaLnirbnmoTlgLzkuI3kuIDmoLcgZWcuICdSZWN0JyBzaGFwZTp7d2lkdGg6MTAwLGhlaWdodDoxMDB9XHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSAgW29wdC5vcGVyYXRpb25JY29uc10g6K6+572u6YCJ5Lit6IqC54K55pe2IOaYvuekuueahOaTjeS9nOWwj+Wbvuagh++8jCDpu5jorqTmj5DkvpvkuoYg5Yig6ZmkKOWIoOmZpOaUr+aMgeiHquWumuS5ieWbnuiwg+aWueazlSnjgIHnm7Tnur/jgIHmipjnur/jgIHmm7Lnur8056eN5Zu+5qCH77yM5Lmf5Y+v5Lul6Ieq5a6a5Zu+5qCHIGVnLlxyXG4gICAgICogPHByZT5cclxuICAgICAqICAgICAgICAgIG9wZXJhdGlvbkljb25zOiBbeyBuYW1lOiAnREVMJyB9LFxyXG4gICAgICogICAgICAgICAgICAgIHsgbmFtZTogJ1NUUkFJR0hUJyB9LFxyXG4gICAgICogICAgICAgICAgICAgIHsgbmFtZTogJ0pBR0dFRCcgfSxcclxuICAgICAqICAgICAgICAgICAgICB7IG5hbWU6ICdDVVJWRScgfSxcclxuICAgICAqICAgICAgICAgICAgICB7XHJcbiAgICAgKiAgICAgICAgICAgICAgICAgIG5hbWU6IFwiY3VzdG9tMVwiLFxyXG4gICAgICogICAgICAgICAgICAgICAgICBpY29uUGF0aDogXCJpbWcvaG9zdC5wbmdcIixcclxuICAgICAqICAgICAgICAgICAgICAgICAgY2FsbGJhY2s6IGZ1bmN0aW9uKGUpIHsgYWxlcnQoZS5kYXRhLm5hbWUgKyBcIiBjbGlja2VkXCIpIH0gIC8vZS5ub2Rl5piv5b2T5YmN55qE6IqC54K5XHJcbiAgICAgKiAgICAgICAgICAgICAgfVxyXG4gICAgICogICAgICAgICAgXVxyXG4gICAgICogPC9wcmU+XHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdXNlckRhdGEg55So5oi35Lyg6YCS55qE5Lia5Yqh5pWw5o2uXHJcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IOWIm+W7uueahOiKgueCueWvueixoVxyXG4gICAgICpcclxuICAgICAqICoq5L2/55So6IyD5L6LKirvvJpcclxuICAgICAqXHJcbiAgICAgKiAgICAgIEBleGFtcGxlXHJcbiAgICAgKiAgICAgIHZhciByZWN0ID0gdGhpcy5maXNoVG9wby5jcmVhdE5vZGUoXCJSZWN0XCIsIHsgLy/nn6nlvaJcclxuICAgICAqICAgICAgICAgIHNoYXBlOiB7XHJcbiAgICAgKiAgICAgICAgICAgICAgd2lkdGg6IDEwMCxcclxuICAgICAqICAgICAgICAgICAgICBoZWlnaHQ6IDYwLFxyXG4gICAgICogICAgICAgICAgfSxcclxuICAgICAqICAgICAgICAgIHN0eWxlOiB7XHJcbiAgICAgKiAgICAgICAgICAgICAgdGV4dDogXCLln7rmnKznn6nlvaJcIixcclxuICAgICAqICAgICAgICAgICAgICBmaWxsOiBcIiMxNjdDRkZcIixcclxuICAgICAqICAgICAgICAgICAgICBzdHJva2U6IFwicmdiKDI1NSwyNTUsMjU1KVwiLFxyXG4gICAgICogICAgICAgICAgICAgIHRleHRGb250OiAnMTRweCBNaWNyb3NvZnQgWWFIZWknXHJcbiAgICAgKiAgICAgICAgICB9LFxyXG4gICAgICogICAgICAgICAgcG9zaXRpb246IFsxODAsIDEwMF0sXHJcbiAgICAgKiAgICAgICAgICBvcGVyYXRpb25JY29uczogW3sgbmFtZTogJ0RFTCcgfSxcclxuICAgICAqICAgICAgICAgICAgICB7IG5hbWU6ICdTVFJBSUdIVCcgfSxcclxuICAgICAqICAgICAgICAgICAgICB7IG5hbWU6ICdKQUdHRUQnIH0sXHJcbiAgICAgKiAgICAgICAgICAgICAgeyBuYW1lOiAnQ1VSVkUnIH0sXHJcbiAgICAgKiAgICAgICAgICAgICAge1xyXG4gICAgICogICAgICAgICAgICAgICAgICBuYW1lOiBcImN1c3RvbTFcIixcclxuICAgICAqICAgICAgICAgICAgICAgICAgaWNvblBhdGg6IFwiaW1nL2hvc3QucG5nXCIsXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgIGNhbGxiYWNrOiBmdW5jdGlvbihlKSB7IGFsZXJ0KGUuZGF0YS5uYW1lICsgXCIgY2xpY2tlZFwiKSB9ICAvL2Uubm9kZeaYr+W9k+WJjeeahOiKgueCuVxyXG4gICAgICogICAgICAgICAgICAgIH1cclxuICAgICAqICAgICAgICAgIF1cclxuICAgICAqICAgICAgfSk7XHJcbiAgICAgKi9cclxuICAgIGZpc2hUb3BvUHJvdG8uY3JlYXROb2RlID0gZnVuY3Rpb24odHlwZSwgb3B0LCB1c2VyRGF0YSkge1xyXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgICAgICAvL+iuvue9ruaooeWeiyDnu5lqc29u5bqP5YiX5YyW55SoXHJcbiAgICAgICAgdmFyIG1vZGVsID0gbmV3IE1vZGVsKHt9KTtcclxuICAgICAgICBtb2RlbC5zZXQoQ29uc3RhbnRzLkVMRU1FTlRfVFlQRSwgdHlwZSk7XHJcbiAgICAgICAgbW9kZWwuc2V0KENvbnN0YW50cy5PUFRJT05TLCB6clV0aWwuY2xvbmUob3B0KSk7XHJcbiAgICAgICAgbW9kZWwuc2V0KENvbnN0YW50cy5VU0VSREFUQSwgenJVdGlsLmNsb25lKHVzZXJEYXRhKSk7XHJcbiAgICAgICAgaWYgKFwiZHJhZ2dhYmxlXCIgaW4gb3B0KSB7XHJcbiAgICAgICAgICAgIG9wdC5pc2RyYWdnYWJsZSA9IG9wdC5kcmFnZ2FibGU7XHJcbiAgICAgICAgICAgIGRlbGV0ZSBvcHQuZHJhZ2dhYmxlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCFvcHQueikge1xyXG4gICAgICAgICAgICBvcHQueiA9IDE7IC8v6IqC54K5WuS4ujEg57q/5q615Li6MDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIG5vZGUgPSBudWxsO1xyXG4gICAgICAgIC8v5qC55o2u5Y+C5pWwZG9t5LiN5ZCM5Yib5bu65LiN5ZCM55qE6IqC54K5XHJcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XHJcbiAgICAgICAgICAgIGNhc2UgXCJSZWN0XCI6XHJcbiAgICAgICAgICAgICAgICBub2RlID0gbmV3IHRoaXMuU2hhcGUuUmVjdChvcHQpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgXCJHcm91cFwiOlxyXG4gICAgICAgICAgICAgICAgbm9kZSA9IG5ldyBHcm91cE5vZGUob3B0KTtcclxuICAgICAgICAgICAgICAgIGlmIChvcHQubWVyZ2VkSW1hZ2UpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaW1hZ2VTaGFwZSA9IG5ldyB0aGlzLlNoYXBlLkltYWdlKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlOiBvcHQubWVyZ2VkSW1hZ2UsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3aWR0aDogd2lkdGgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBoZWlnaHQ6IGhlaWdodCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IG9wdC5zdHlsZS50ZXh0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dFBvc2l0aW9uOiAnYm90dG9tJ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogWy01MDAwLCAtNTAwMF1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmFnKGltYWdlU2hhcGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIG5vZGUucmVsYXRpb25JbWFnZSA9IGltYWdlU2hhcGU7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5ncm91cC5hZGQoaW1hZ2VTaGFwZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2VTaGFwZS5oaWRlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSwgMzAwKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5vbihcImRibGNsaWNrXCIsIGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5tZXJnZWQoZSlcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFwiSW1hZ2VcIjpcclxuICAgICAgICAgICAgICAgIG5vZGUgPSBuZXcgdGhpcy5TaGFwZS5JbWFnZShvcHQpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgXCJUZXh0XCI6XHJcbiAgICAgICAgICAgICAgICBub2RlID0gbmV3IHRoaXMuU2hhcGUuVGV4dChvcHQpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgXCJDaXJjbGVcIjpcclxuICAgICAgICAgICAgICAgIG5vZGUgPSBuZXcgdGhpcy5TaGFwZS5DaXJjbGUob3B0KTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFwiU2VjdG9yXCI6XHJcbiAgICAgICAgICAgICAgICBub2RlID0gbmV3IHRoaXMuU2hhcGUuU2VjdG9yKG9wdCk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBcIlJpbmdcIjpcclxuICAgICAgICAgICAgICAgIG5vZGUgPSBuZXcgdGhpcy5TaGFwZS5SaW5nKG9wdCk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBcIlBvbHlnb25cIjpcclxuICAgICAgICAgICAgICAgIG5vZGUgPSBuZXcgdGhpcy5TaGFwZS5Qb2x5Z29uKG9wdCk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBcIlBvbHlsaW5lXCI6XHJcbiAgICAgICAgICAgICAgICBub2RlID0gbmV3IHRoaXMuU2hhcGUuUG9seWxpbmUob3B0KTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFwiTGluZVwiOlxyXG4gICAgICAgICAgICAgICAgbm9kZSA9IG5ldyB0aGlzLlNoYXBlLkxpbmUob3B0KTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFwiQmV6aWVyQ3VydmVcIjpcclxuICAgICAgICAgICAgICAgIG5vZGUgPSBuZXcgdGhpcy5TaGFwZS5CZXppZXJDdXJ2ZShvcHQpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgXCJBcmNcIjpcclxuICAgICAgICAgICAgICAgIG5vZGUgPSBuZXcgdGhpcy5TaGFwZS5BcmMob3B0KTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmRyYWcobm9kZSk7XHJcblxyXG4gICAgICAgIG5vZGUuYXR0cihcIm9wZXJhdGlvbkljb25zXCIsIG9wdC5vcGVyYXRpb25JY29ucyk7XHJcblxyXG4gICAgICAgIC8v5L6m5ZCs6IqC54K555qEY2xpY2sgZGJsY2xpY2vkuovku7bvvIzpgInkuK3vvIzlubbmtL7lj5Hlh7rljrtcclxuICAgICAgICBub2RlLm9uKCdjbGljaycsIGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgICAgdmFyIG5vd05vZGU7XHJcbiAgICAgICAgICAgIGlmIChub2RlLmZyb21DbXNJbWFnZSkge1xyXG4gICAgICAgICAgICAgICAgbm93Tm9kZSA9IG5vZGUuZnJvbUNtc0ltYWdlO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbm93Tm9kZSA9IHRoaXM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhhdC5ub2RlQ2xpY2tIYW5kbGVyKG5vd05vZGUsIGUuZXZlbnQuY2xpZW50WCwgZS5ldmVudC5jbGllbnRZKTtcclxuXHJcbiAgICAgICAgICAgIHZhciBwYXJhbXMgPSB7fTtcclxuICAgICAgICAgICAgcGFyYW1zLmV2ZW50ID0gZTtcclxuICAgICAgICAgICAgcGFyYW1zLnR5cGUgPSAnY2xpY2snO1xyXG4gICAgICAgICAgICBwYXJhbXMudGFyZ2V0ID0gbm93Tm9kZTtcclxuICAgICAgICAgICAgdGhhdC5fYXBpLnRyaWdnZXIocGFyYW1zLnR5cGUsIHBhcmFtcyk7XHJcblxyXG4gICAgICAgICAgICBlLmNhbmNlbEJ1YmJsZSA9IHRydWU7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgbm9kZS5vbignZGJsY2xpY2snLCBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICAgIHZhciBub3dOb2RlO1xyXG4gICAgICAgICAgICBpZiAobm9kZS5mcm9tQ21zSW1hZ2UpIHtcclxuICAgICAgICAgICAgICAgIG5vd05vZGUgPSBub2RlLmZyb21DbXNJbWFnZTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG5vd05vZGUgPSB0aGlzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygbm93Tm9kZS5zdHlsZS5pc0FsbG93RWRpdCA9PSBcInVuZGVmaW5lZFwiKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhhdC5vcHRpb25zLmlzQWxsb3dFZGl0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5ub2RlRWRpdChub3dOb2RlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmIChub3dOb2RlLnN0eWxlLmlzQWxsb3dFZGl0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5ub2RlRWRpdChub3dOb2RlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgcGFyYW1zID0ge307XHJcbiAgICAgICAgICAgIHBhcmFtcy5ldmVudCA9IGU7XHJcbiAgICAgICAgICAgIHBhcmFtcy50eXBlID0gJ2RibGNsaWNrJztcclxuICAgICAgICAgICAgcGFyYW1zLnRhcmdldCA9IG5vZGU7XHJcbiAgICAgICAgICAgIHRoYXQuX2FwaS50cmlnZ2VyKHBhcmFtcy50eXBlLCBwYXJhbXMpO1xyXG5cclxuICAgICAgICAgICAgZS5jYW5jZWxCdWJibGUgPSB0cnVlO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICB0aGlzLmFsbE5vZGVzLnB1c2gobm9kZSk7XHJcbiAgICAgICAgaWYgKG9wdC5pZCkge1xyXG4gICAgICAgICAgICBtb2RlbC5zZXQoQ29uc3RhbnRzLklELCBvcHQuaWQpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIG1vZGVsLnNldChDb25zdGFudHMuSUQsIHV0aWwuZ2V0VVVJRCgpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIG5vZGUubW9kZWwgPSBtb2RlbDtcclxuXHJcbiAgICAgICAgdGhpcy5fdHJpZ2dlckNyZWF0ZUV2ZW50KG5vZGUpO1xyXG4gICAgICAgIHJldHVybiBub2RlO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIOagueaNrm5hbWXojrflj5boioLngrlcclxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gbmFtZSDlnKjliJvlu7roioLngrnkuK0gIG5hbWXlsZ7mgKforr7nva7nmoTlgLxcclxuICAgICAqIEByZXR1cm4ge09iamVjdH0gICAgICBuYW1l5a+55bqU55qE6IqC54K5XHJcbiAgICAgKi9cclxuICAgIGZpc2hUb3BvUHJvdG8uY2hpbGRPZk5hbWUgPSBmdW5jdGlvbihuYW1lKSB7XHJcbiAgICAgICAgdmFyIGFyclJlc3VsdCA9IFtdO1xyXG4gICAgICAgIHZhciBjaGlsZHJlbk5vZGUgPSB0aGlzLmFsbE5vZGVzO1xyXG4gICAgICAgIHZhciBjaGlsZHJlbkxpbmUgPSBGbG93Q29ubmVjdGlvbk1hbmFnZXIuY29ubmVjdG9ycztcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuTm9kZS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoY2hpbGRyZW5Ob2RlW2ldLm1vZGVsLmdldChcIm9wdGlvbnMubmFtZVwiKSAmJiBjaGlsZHJlbk5vZGVbaV0ubW9kZWwuZ2V0KFwib3B0aW9ucy5uYW1lXCIpID09IG5hbWUpIHtcclxuICAgICAgICAgICAgICAgIGFyclJlc3VsdC5wdXNoKGNoaWxkcmVuTm9kZVtpXSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2hpbGRyZW5Ob2RlW2ldLm1vZGVsLmdldChcInVzZXJEYXRhLm5hbWVcIikgPT0gbmFtZSkge1xyXG4gICAgICAgICAgICAgICAgYXJyUmVzdWx0LnB1c2goY2hpbGRyZW5Ob2RlW2ldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGNoaWxkcmVuTGluZS5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICBpZiAoY2hpbGRyZW5MaW5lW2pdLm1vZGVsLmdldChcIm9wdGlvbnMubmFtZVwiKSAmJiBjaGlsZHJlbkxpbmVbal0ubW9kZWwuZ2V0KFwib3B0aW9ucy5uYW1lXCIpID09IG5hbWUpIHtcclxuICAgICAgICAgICAgICAgIGFyclJlc3VsdC5wdXNoKGNoaWxkcmVuTGluZVtqXSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2hpbGRyZW5MaW5lW2pdLm1vZGVsLmdldChcInVzZXJEYXRhLm5hbWVcIikgPT0gbmFtZSkge1xyXG4gICAgICAgICAgICAgICAgYXJyUmVzdWx0LnB1c2goY2hpbGRyZW5MaW5lW2pdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoYXJyUmVzdWx0Lmxlbmd0aCA+IDEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGFyclJlc3VsdDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gYXJyUmVzdWx0WzBdO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDmn6Xmib7lnLrmma/kuK3nmoTlr7nosaEgICDkvovlpoI6IHjlnZDmoIflpKfkuo4xMDDnmoToioLngrkgZmluZEVsZW1lbnRzKGZ1bmN0aW9uKGUpeyByZXR1cm4gZS5wb3NpdGlvblswXSA+IDEwMDsgfSk7XHJcbiAgICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gY2IgICAgICDlm57osIPlh73mlbBcclxuICAgICAqIEBwYXJhbSAge09iamVjdH0gICBjb250ZXh0IOWbnuiwg+WHveaVsOaJp+ihjOeahOS4iuS4i+aWh1xyXG4gICAgICogQHJldHVybiB7QXJyYXl9ICAgICAgICAgICDov5Tlm57mn6Xmib7liLDnmoTlr7nosaFcclxuICAgICAqL1xyXG4gICAgZmlzaFRvcG9Qcm90by5maW5kRWxlbWVudHMgPSBmdW5jdGlvbihjYiwgY29udGV4dCkge1xyXG4gICAgICAgIHZhciBjaGlsZHJlbk5vZGUgPSB0aGlzLmFsbE5vZGVzO1xyXG4gICAgICAgIHZhciBjaGlsZHJlbkxpbmUgPSBGbG93Q29ubmVjdGlvbk1hbmFnZXIuY29ubmVjdG9ycztcclxuICAgICAgICB2YXIgYXJyID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbk5vZGUubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIGNoaWxkID0gY2hpbGRyZW5Ob2RlW2ldO1xyXG4gICAgICAgICAgICBpZiAoY2IuY2FsbChjb250ZXh0LCBjaGlsZCwgaSkpIHtcclxuICAgICAgICAgICAgICAgIGFyci5wdXNoKGNoaWxkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGNoaWxkcmVuTGluZS5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICB2YXIgY2hpbGRMID0gY2hpbGRyZW5MaW5lW2pdO1xyXG4gICAgICAgICAgICBpZiAoY2IuY2FsbChjb250ZXh0LCBjaGlsZEwsIGopKSB7XHJcbiAgICAgICAgICAgICAgICBhcnIucHVzaChjaGlsZEwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBhcnI7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICog6K6+572u6IOM5pmv6ImyICDmiJYg6IOM5pmv5Zu+54mHXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaW1hZ2VVcmwg6IOM5pmv6ImyICDmiJYg6IOM5pmv5Zu+54mHIGVnLiAnaW1nL2JnLmpwZydcclxuICAgICAqL1xyXG4gICAgZmlzaFRvcG9Qcm90by5zZXRCYWNrZ3JvdW5kID0gZnVuY3Rpb24oaW1hZ2VVcmwpIHtcclxuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XHJcbiAgICAgICAgaWYgKGltYWdlVXJsICYmIGltYWdlVXJsLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgdGhpcy5tb2RlbC5zZXQoQ29uc3RhbnRzLkJBQ0tHUk9VTkQsIGltYWdlVXJsKTtcclxuICAgICAgICAgICAgaWYgKGltYWdlVXJsLnN1YnN0cigwLCAxKSA9PSBcIiNcIiB8fCBpbWFnZVVybC5zdWJzdHIoMCwgNCkgPT0gXCJyZ2JhXCIpIHsgLy/lpoLmnpzmmK/popzoibLliJvlu7pyZWN05Li66IOM5pmvXHJcbiAgICAgICAgICAgICAgICBpZiAoIWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpLmdldENvbnRleHQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGF0Ll9kb20uc3R5bGUuYmFja2dyb3VuZENvbG9yID0gaW1hZ2VVcmw7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpbWFnZVNoYXBlID0gbmV3IHRoaXMuU2hhcGUuUmVjdCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNoYXBlOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogdGhhdC5fenIuZ2V0V2lkdGgoKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogdGhhdC5fenIuZ2V0SGVpZ2h0KClcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGw6IGltYWdlVXJsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvcjogJ2RlZmF1bHQnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB6OiAtMVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoYXQuX3pyLmFkZChpbWFnZVNoYXBlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpLmdldENvbnRleHQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGF0Ll9kb20uc3R5bGUuYmFja2dyb3VuZEltYWdlID0gXCJ1cmwoXCIgKyBpbWFnZVVybCArIFwiKVwiO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoYXQuX2RvbS5zdHlsZS5iYWNrZ3JvdW5kUmVwZWF0ID0gXCJyZXBlYXRcIjtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGltYWdlU2hhcGUxID0gbmV3IHRoaXMuU2hhcGUuSW1hZ2UoeyAvL+WmguaenOaYr+WbvueJh+WIm+W7umltYWdl5Li66IOM5pmvXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBbMCwgMF0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjYWxlOiBbMSwgMV0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4OiAwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeTogMCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlOiBpbWFnZVVybCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiB0aGlzLl96ci5nZXRXaWR0aCgpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLl96ci5nZXRIZWlnaHQoKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3I6ICdkZWZhdWx0JyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgejogLTFcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB0aGF0Ll96ci5hZGQoaW1hZ2VTaGFwZTEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIOWIm+W7uue6v+autVxyXG4gICAgICogQG1ldGhvZCBjcmVhdExpbmtcclxuICAgICAqIEBwYXJhbSAge09iamVjdH0gc3RhcnROb2RlIOW8gOWni+iKgueCuVxyXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBlbmROb2RlICAg57uT5p2f6IqC54K5XHJcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IG9wdGlvbnMg57q/5q616YCJ6aG5XHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuc3R5bGVdIOiKgueCueeahOagt+W8j1xyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnN0eWxlLmxpbmVXaWR0aD0xXSDnur/mrrXnmoTlrr3luqZcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5zdHlsZS5saW5lVHlwZT0nc3RyYWlnaHQnXSDnur/mrrXnmoTnsbvlnosgZWcuICdzdHJhaWdodCcsICdqYWdnZWQnLCdjdXJ2ZSdcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5zdHlsZS5zdHJva2U9XCIjMDAwMDAwXCJdIOe6v+auteeahOminOiJsuWAvCBlZy4gJyMxNTdjZmYnICAncmdiKDEyMiwxMjIsMTIyKSdcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9ICBbb3B0aW9ucy5zdHlsZS5saW5lRGFzaF0g6Jma57q/55qE6Ze06ZqUIGVnLiBbMywzXVxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLnN5bWJvbF0g57q/5q6155qE566t5aS0XHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuc3ltYm9sLnR5cGU9J2Fycm93J10g57q/5q6155qE566t5aS055qE57G75Z6LIOWPr+mAieWAvOS4uu+8miAnY2lyY2xlJywgJ3JlY3QnLCAncm91bmRSZWN0JywgJ3RyaWFuZ2xlJywgJ2RpYW1vbmQnLCAncGluJywgJ2Fycm93J1xyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnN5bWJvbC5zaXplPTEwXSDnur/mrrXnmoTnrq3lpLTnmoTlsLrlr7hcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5zeW1ib2wuY29sb3I9JyMwMDAwMDAnXSDnur/mrrXnmoTnrq3lpLTnmoTpopzoibJcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy50ZXh0XSDnur/mrrXkuIrnmoTmloflrZdcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy50ZXh0LnRleHRdIOe6v+auteS4iueahOaWh+Wtl+WGheWuuVxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnRleHQuY29sb3JdIOe6v+auteS4iueahOaWh+Wtl+minOiJslxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnRleHQudGV4dFBvc10g5paH5a2X5L2N572u5Y+v6YCJ5YC8ICdzdGFydCcsJ2NlbnRlcicsJ2VuZCcs6buY6K6k5YC85Li6Y2VudGVyXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMudGV4dC54T2Zmc2V0XSDmloflrZfkvY3nva545YGP56e76YePXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMucG9zXSDmjIflrprnur/mrrXotbflp4vkuI7nu4jmraIg5Zyo6IqC54K555qE5LuA5LmI5L2N572uIOm7mOiupOWAvOS4uidsZWZ0LHJpZ2h0JyAg5Y+v5Y+W5YC85Zub5Liq5pa55ZCRdG9wLGJvdHRvbSxsZWZ0LHJpZ2h0IOaWueWQkeWPr+WKoOWBj+enu+mHj+WmguWmgiBcImxlZnQrMTAsdG9wXCJcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5wb3NpdGlvbl0g5oyH5a6a57q/5q615L2N572uXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuZWZmZWN0XSDnur/kuIrliqjmgIHmlYjmnpxcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5lZmZlY3Quc2hvd10g5piv5ZCm5pi+56S6566t5aS05Yqo5pWIXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuZWZmZWN0LnBlcmlvZF0g5Yqo5pWI56e75Yqo6YCf5bqmXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMucG9zaXRpb24uZXNjYXBlRGlzdGFuY2VdIOaMh+Wumue6v+auteesrOS4gOadoeaKmOe6v+eahOmVv+W6pu+8jOacgOWQjuS4gOadoeaKmOe6v+eahOmVv+W6plxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnBvc2l0aW9uLnBvaW50c10g5LiN5L2/55So6Ieq5Yqo6K6h566XIOaMh+Wumui/nue6v+eahOaKmOeCueS9jee9ruaVsOe7hFxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHVzZXJEYXRhIOeUqOaIt+S8oOmAkueahOS4muWKoeaVsOaNrlxyXG4gICAgICogQHJldHVybiB7T2JqZWN0fSDliJvlu7rnmoTnur/mrrXlr7nosaFcclxuICAgICAqXHJcbiAgICAgKiAqKuS9v+eUqOiMg+S+iyoq77yaXHJcbiAgICAgKlxyXG4gICAgICogICAgICBAZXhhbXBsZVxyXG4gICAgICogICAgICB2YXIgbGluayA9IG1lLmZpc2hUb3BvLmNyZWF0TGluayhzdGFydE5vZGUsIGVuZE5vZGUsIHtcclxuICAgICAqICAgICAgICAgICAgICBzeW1ib2w6IHsgdHlwZTogJ2Fycm93Jywgc2l6ZTogMTAsIGNvbG9yOiBcInJnYigwLDIwMCwyNTUpXCIgfSwgLy/nrq3lpLQgIOWPr+mAieWAvOS4uu+8miAnY2lyY2xlJywgJ3JlY3QnLCAncm91bmRSZWN0JywgJ3RyaWFuZ2xlJywgJ2RpYW1vbmQnLCAncGluJywgJ2Fycm93J1xyXG4gICAgICogICAgICAgICAgICAgIHN0eWxlOiB7IGxpbmVXaWR0aDogMywgc3Ryb2tlOiBcInJnYigwLDIwMCwyNTUpXCIsIGxpbmVEYXNoOiBbMywzXSwgbGluZVR5cGU6IFwiamFnZ2VkXCIgIH0sIC8v5qC35byPXHJcbiAgICAgKiAgICAgICAgICAgICAgdGV4dDoge1xyXG4gICAgICogICAgICAgICAgICAgICAgICB0ZXh0OiB0ZXh0LFxyXG4gICAgICogICAgICAgICAgICAgICAgICBjb2xvcjogJyNmZmZmZmYnLFxyXG4gICAgICogICAgICAgICAgICAgICAgICB0ZXh0UG9zOnRleHRQb3MsLy/mloflrZfkvY3nva7lj6/pgInlgLwgJ3N0YXJ0JywnY2VudGVyJywnZW5kJyzpu5jorqTlgLzkuLpjZW50ZXJcclxuICAgICAqICAgICAgICAgICAgICAgICAgeE9mZnNldDoxMCwgLy/mloflrZfkvY3nva545YGP56e76YePXHJcbiAgICAgKiAgICAgICAgICAgICAgfSxcclxuICAgICAqICAgICAgICAgICAgICBwb3M6J3JpZ2h0LGxlZnQnLFxyXG4gICAgICogICAgICAgICAgICAgIGVmZmVjdDoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzaG93OiB0cnVlLC8v5piv5ZCm5pi+56S6566t5aS05Yqo5pWIXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBlcmlvZDogNiwvL+eureWktOmAn+W6plxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgKiAgICAgICAgICAgICAgcG9zaXRpb246e1xyXG4gICAgICogICAgICAgICAgICAgICAgICAgIGVzY2FwZURpc3RhbmNlOls1MCwzMF0sICAvL+esrOS4gOadoeaKmOe6v+eahOmVv+W6pu+8jOacgOWQjuS4gOadoeaKmOe6v+eahOmVv+W6plxyXG4gICAgICogICAgICAgICAgICAgICAgICAgIHBvaW50czpbXCJ4MSx5MVwiLFwieDIseTJcIl0gIOS4jeS9v+eUqOiHquWKqOiuoeeulyDmjIflrprov57nur/nmoTkvY3nva7mlbDnu4RcclxuICAgICAqICAgICAgICAgICAgICB9XHJcbiAgICAgKiAgICAgICAgICB9KTtcclxuICAgICAqL1xyXG4gICAgZmlzaFRvcG9Qcm90by5jcmVhdExpbmsgPSBmdW5jdGlvbihzdGFydE5vZGUsIGVuZE5vZGUsIG9wdGlvbnMsIHVzZXJEYXRhKSB7XHJcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgICAgIG9wdGlvbnMuaXNFZGl0ID0gISF0aGlzLm9wdGlvbnMubGlua01vZGlmeTtcclxuICAgICAgICB2YXIgY29ubmVjdG9yID0gRmxvd0Nvbm5lY3Rpb25NYW5hZ2VyLmNvbm5lY3RvckNyZWF0ZShzdGFydE5vZGUsIGVuZE5vZGUsIG9wdGlvbnMsIHRoaXMuX2FwaSk7XHJcbiAgICAgICAgY29ubmVjdG9yLm1vZGVsLnNldChDb25zdGFudHMuVVNFUkRBVEEsIHpyVXRpbC5jbG9uZSh1c2VyRGF0YSkpO1xyXG4gICAgICAgIGNvbm5lY3Rvci5vbihcImRibGNsaWNrXCIsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy50ZXh0LmlzQWxsb3dFZGl0ID09IFwidW5kZWZpbmVkXCIpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGF0Lm9wdGlvbnMuaXNBbGxvd0VkaXQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGF0LmNvbm5lY3RvckVkaXQodGhpcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnRleHQuaXNBbGxvd0VkaXQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGF0LmNvbm5lY3RvckVkaXQodGhpcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIGlmKHRoaXMuc3R5bGUuaXNBbGxvd0VkaXQpe1xyXG4gICAgICAgICAgICAvLyAgICAgdGhhdC5jb25uZWN0b3JFZGl0KHRoaXMpO1xyXG4gICAgICAgICAgICAvLyB9ZWxzZSBpZih0aGF0Lm9wdGlvbnMuaXNBbGxvd0VkaXQpe1xyXG4gICAgICAgICAgICAvLyAgICAgdGhhdC5jb25uZWN0b3JFZGl0KHRoaXMpO1xyXG4gICAgICAgICAgICAvLyB9XHJcbiAgICAgICAgICAgIC8vIGlmKHRoaXMuc3R5bGUuaXNBbGxvd0VkaXQgPyB0aGlzLnN0eWxlLmlzQWxsb3dFZGl0IDogdGhhdC5vcHRpb25zLmlzQWxsb3dFZGl0KXtcclxuICAgICAgICAgICAgLy8gICAgIHRoYXQuY29ubmVjdG9yRWRpdCh0aGlzKTtcclxuICAgICAgICAgICAgLy8gfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBjb25uZWN0b3I7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIOe6v+S4iuaWh+Wtl+e8lui+kVxyXG4gICAgICovXHJcbiAgICBmaXNoVG9wb1Byb3RvLmNvbm5lY3RvckVkaXQgPSBmdW5jdGlvbih0aGlzQ29ubmVjdG9yKSB7XHJcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgICAgIHZhciBsaW5lVGV4dCA9IHRoaXNDb25uZWN0b3IuY2hpbGRPZk5hbWUoJ2xpbmVUZXh0Jyk7XHJcbiAgICAgICAgaWYgKCFsaW5lVGV4dCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciB0ZXh0YXJlYSA9IHRoYXQuY3JlYXRUZXh0QXJlYSgpO1xyXG4gICAgICAgIHRleHRhcmVhLnN0eWxlLndpZHRoID0gMS4xICogdXRpbC5nZXRSZWN0KGxpbmVUZXh0KS53aWR0aCAqIHRoYXQubm93Wm9vbSArIFwicHhcIjtcclxuICAgICAgICB0ZXh0YXJlYS5zdHlsZS5oZWlnaHQgPSAodXRpbC5nZXRSZWN0KGxpbmVUZXh0KS5oZWlnaHQgfHwgMTIpICogdGhhdC5ub3dab29tICsgXCJweFwiO1xyXG4gICAgICAgIHRleHRhcmVhLmlubmVySFRNTCA9IGxpbmVUZXh0LnN0eWxlLnRleHQ7XHJcbiAgICAgICAgdGhhdC5fZG9tLmFwcGVuZENoaWxkKHRleHRhcmVhKTtcclxuICAgICAgICB0aGF0Ll9kb20uc3R5bGUucG9zaXRpb24gPSBcInJlbGF0aXZlXCI7XHJcbiAgICAgICAgdmFyIHRleHRSZWN0ID0gdGV4dENvbnRhaW4uZ2V0Qm91bmRpbmdSZWN0KGxpbmVUZXh0LnN0eWxlLnRleHQsIGxpbmVUZXh0LnN0eWxlLnRleHRGb250KTtcclxuICAgICAgICB0ZXh0YXJlYS5zdHlsZS5saW5lSGVpZ2h0ID0gKHRleHRSZWN0LmxpbmVIZWlnaHQgfHwgMTQpICsgXCJweFwiO1xyXG4gICAgICAgIHRleHRhcmVhLnN0eWxlLnRvcCA9IChsaW5lVGV4dC5wb3NpdGlvblsxXSAtIHV0aWwuZ2V0UmVjdChsaW5lVGV4dCkuaGVpZ2h0KSAqIHRoYXQubm93Wm9vbSArIHRoYXQuZ3JvdXAucG9zaXRpb25bMV0gKyBcInB4XCI7XHJcbiAgICAgICAgdGV4dGFyZWEuc3R5bGUubGVmdCA9IChsaW5lVGV4dC5wb3NpdGlvblswXSAtIDAuMDUgKiB1dGlsLmdldFJlY3QobGluZVRleHQpLndpZHRoKSAqIHRoYXQubm93Wm9vbSArIHRoYXQuZ3JvdXAucG9zaXRpb25bMF0gKyBcInB4XCI7XHJcbiAgICAgICAgdGV4dGFyZWEuZm9jdXMoKTtcclxuICAgICAgICAkKHRleHRhcmVhKS5vbihcImtleXVwXCIsIHpyVXRpbC5iaW5kKGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgICAgdmFyIHRleHRSZWN0ID0gdGV4dENvbnRhaW4uZ2V0Qm91bmRpbmdSZWN0KGxpbmVUZXh0LnN0eWxlLnRleHQsIGxpbmVUZXh0LnN0eWxlLnRleHRGb250KTtcclxuICAgICAgICAgICAgdGhhdC50ZXh0YXJlYVJlc2l6ZSh0ZXh0UmVjdCwgdGV4dGFyZWEsIGUpO1xyXG4gICAgICAgIH0sIHRoaXMpKTtcclxuICAgICAgICAkKHRleHRhcmVhKS5vbihcImZvY3Vzb3V0XCIsIHpyVXRpbC5iaW5kKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBpZiAodGV4dGFyZWEudmFsdWUgIT09IGxpbmVUZXh0LnN0eWxlLnRleHQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXNDb25uZWN0b3Iuc2V0U3R5bGUoe1xyXG4gICAgICAgICAgICAgICAgICAgIHRleHQ6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogdGV4dGFyZWEudmFsdWUgfHwgXCJcIlxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGV4dGFyZWEucmVtb3ZlKCk7XHJcbiAgICAgICAgfSwgdGhpcykpXHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICog6IqC54K55LiK5paH5a2X57yW6L6RXHJcbiAgICAgKi9cclxuICAgIGZpc2hUb3BvUHJvdG8ubm9kZUVkaXQgPSBmdW5jdGlvbih0aGlzTm9kZSkge1xyXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgICAgICB2YXIgdGV4dGFyZWEgPSB0aGF0LmNyZWF0VGV4dEFyZWEoKTtcclxuICAgICAgICB2YXIgbm9kZVRleHQgPSB0aGlzTm9kZS5zdHlsZS50ZXh0O1xyXG4gICAgICAgIHZhciB0ZXh0UmVjdCA9IHRleHRDb250YWluLmdldEJvdW5kaW5nUmVjdChub2RlVGV4dCwgdGhpc05vZGUuc3R5bGUudGV4dEZvbnQpO1xyXG4gICAgICAgIHRleHRhcmVhLnN0eWxlLndpZHRoID0gMS4xICogdGV4dFJlY3Qud2lkdGggKiB0aGF0Lm5vd1pvb20gKyBcInB4XCI7XHJcbiAgICAgICAgdGV4dGFyZWEuc3R5bGUuaGVpZ2h0ID0gKHRleHRSZWN0LmhlaWdodHx8MTIpICogdGhhdC5ub3dab29tICsgXCJweFwiO1xyXG4gICAgICAgIHZhciBub2RlUmVjdCA9IHV0aWwuZ2V0UmVjdCh0aGlzTm9kZSk7XHJcbiAgICAgICAgdGV4dGFyZWEuc3R5bGUubWF4V2lkdGggPSAxLjEqbm9kZVJlY3Qud2lkdGggKiB0aGF0Lm5vd1pvb20gKyBcInB4XCI7XHJcbiAgICAgICAgdGV4dGFyZWEuc3R5bGUubGluZUhlaWdodCA9ICh0ZXh0UmVjdC5saW5lSGVpZ2h0IHx8IDEyKSArIFwicHhcIjtcclxuICAgICAgICB0ZXh0YXJlYS5pbm5lckhUTUwgPSB0aGlzTm9kZS5zdHlsZS50ZXh0O1xyXG4gICAgICAgIHRoYXQuX2RvbS5hcHBlbmRDaGlsZCh0ZXh0YXJlYSk7XHJcbiAgICAgICAgdGhhdC5fZG9tLnN0eWxlLnBvc2l0aW9uID0gXCJyZWxhdGl2ZVwiO1xyXG4gICAgICAgIHZhciBvZmZlc3RJID0gMTtcclxuICAgICAgICBpZiAodGhpc05vZGUuc3R5bGUudGV4dEFsaWduID09IFwibGVmdFwiKSB7XHJcbiAgICAgICAgICAgIG9mZmVzdEkgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpc05vZGUuc3R5bGUudGV4dEFsaWduID09IFwicmlnaHRcIikge1xyXG4gICAgICAgICAgICBvZmZlc3RJID0gMjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGV4dGFyZWEuc3R5bGUudG9wID0gKG5vZGVSZWN0LnkgLSB0ZXh0UmVjdC5oZWlnaHQgLyAyKSAqIHRoYXQubm93Wm9vbSArIHRoYXQuZ3JvdXAucG9zaXRpb25bMV0gKyBcInB4XCI7XHJcbiAgICAgICAgdGV4dGFyZWEuc3R5bGUubGVmdCA9IChub2RlUmVjdC54IC0gb2ZmZXN0SSAqIHRleHRSZWN0LndpZHRoIC8gMiAtIDAuMDUgKiB0ZXh0UmVjdC53aWR0aCkgKiB0aGF0Lm5vd1pvb20gKyB0aGF0Lmdyb3VwLnBvc2l0aW9uWzBdICsgXCJweFwiO1xyXG4gICAgICAgIHRleHRhcmVhLmZvY3VzKCk7XHJcbiAgICAgICAgJCh0ZXh0YXJlYSkub24oXCJrZXl1cFwiLCB6clV0aWwuYmluZChmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICAgIHZhciB0ZXh0UmVjdCA9IHRleHRDb250YWluLmdldEJvdW5kaW5nUmVjdCh0ZXh0YXJlYS52YWx1ZSwgdGhpc05vZGUuc3R5bGUudGV4dEZvbnQpO1xyXG4gICAgICAgICAgICB0aGF0LnRleHRhcmVhUmVzaXplKHRleHRSZWN0LCB0ZXh0YXJlYSwgZSk7XHJcbiAgICAgICAgfSwgdGhpcykpXHJcbiAgICAgICAgJCh0ZXh0YXJlYSkub24oXCJmb2N1c291dFwiLCB6clV0aWwuYmluZChmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgaWYgKHRleHRhcmVhLnZhbHVlICE9PSBub2RlVGV4dCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHRleHQgPSB0aGF0LmhhbmRsZVdyYXAodGV4dGFyZWEudmFsdWUsIHRleHRhcmVhLnN0eWxlLm1heFdpZHRoKTtcclxuICAgICAgICAgICAgICAgIHRoaXNOb2RlLmF0dHIoXCJzdHlsZVwiLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogdGV4dFxyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIHRoaXNOb2RlLm1vZGVsLnNldChcIm9wdGlvbnMuc3R5bGUudGV4dFwiLHRleHQpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgO1xyXG4gICAgICAgICAgICB0ZXh0YXJlYS5yZW1vdmUoKTtcclxuICAgICAgICB9LCB0aGlzKSlcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICog5Yib5bu65paH5pys5Z+fXHJcbiAgICAgKi9cclxuICAgIGZpc2hUb3BvUHJvdG8uY3JlYXRUZXh0QXJlYSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciB0ZXh0YXJlYSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ0ZXh0YXJlYVwiKTtcclxuICAgICAgICB0ZXh0YXJlYS5zdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIjtcclxuICAgICAgICB0ZXh0YXJlYS5zdHlsZS5vdmVyZmxvdyA9IFwiaGlkZGVuXCI7XHJcbiAgICAgICAgdGV4dGFyZWEuc3R5bGUuYm9yZGVyID0gXCIwXCI7XHJcbiAgICAgICAgdGV4dGFyZWEuc3R5bGUucGFkZGluZyA9IFwiMFwiO1xyXG4gICAgICAgIHRleHRhcmVhLnN0eWxlLnJlc2l6ZSA9IFwibm9uZVwiO1xyXG4gICAgICAgIHJldHVybiB0ZXh0YXJlYTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICog5aSE55CGdGV4dGFyZWHoh6rliqjmjaLooYxcclxuICAgICAqL1xyXG4gICAgZmlzaFRvcG9Qcm90by5oYW5kbGVXcmFwID0gZnVuY3Rpb24odmFsdWUsIHdpZHRoKSB7XHJcbiAgICAgICAgdmFyIHNwYW5Ob2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XHJcbiAgICAgICAgc3Bhbk5vZGUuaWQgPSBcInNwYW5Ob2RlSWRcIjtcclxuICAgICAgICBzcGFuTm9kZS5zdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIjtcclxuICAgICAgICBzcGFuTm9kZS5zdHlsZS5vdmVyZmxvdyA9IFwiaGlkZGVuXCI7XHJcbiAgICAgICAgc3Bhbk5vZGUuc3R5bGUuYm9yZGVyID0gXCIwXCI7XHJcbiAgICAgICAgc3Bhbk5vZGUuc3R5bGUucGFkZGluZyA9IFwiMFwiO1xyXG4gICAgICAgIHRoaXMuX2RvbS5hcHBlbmRDaGlsZChzcGFuTm9kZSk7XHJcbiAgICAgICAgdmFyIGNvbnRlbnQgPSB2YWx1ZS5zcGxpdChcIlxcblwiKTtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gXCJcIjtcclxuICAgICAgICAkLmVhY2goY29udGVudCwgZnVuY3Rpb24oaSwgdmFsKSB7XHJcbiAgICAgICAgICAgIHZhciB2YWxMZW5ndGggPSB2YWwubGVuZ3RoO1xyXG4gICAgICAgICAgICBpZiAodmFsTGVuZ3RoID09IDApIHtcclxuICAgICAgICAgICAgICAgIC8vcmVzdWx0ICs9IFwiXFxuXCI7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcHJlID0gXCJcIixcclxuICAgICAgICAgICAgICAgICAgICBpbm5lclZhbCwgdGVtcFdpZHRoLCBjb25XaWR0aDtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGlubmVySSA9IDA7IGlubmVySSA8IHZhbExlbmd0aDsgaW5uZXJJKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBpbm5lclZhbCA9IHZhbC5jaGFyQXQoaW5uZXJJKTtcclxuICAgICAgICAgICAgICAgICAgICAkKFwiI3NwYW5Ob2RlSWRcIikudGV4dCgkKFwiI3NwYW5Ob2RlSWRcIikudGV4dCgpICsgaW5uZXJWYWwpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRlbXBXaWR0aCA9ICQoXCIjc3Bhbk5vZGVJZFwiKS53aWR0aCgpOyAvL+iOt+WPlua3u+WKoOWtl+espuWQjumakOiXj+Wfn+eahOWuveW6plxyXG4gICAgICAgICAgICAgICAgICAgIGNvbldpZHRoID0gTnVtYmVyKHdpZHRoLnN1YnN0cmluZygwLCB3aWR0aC5sZW5ndGggLSAyKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRlbXBXaWR0aCA+IGNvbldpZHRoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBwcmU7IC8v5aaC5p6c6L+95Yqg5a2X56ym5ZCO6ZqQ6JeP5Z+f5a695bqm5aSn5LqOVGV4dEFyZWHlrr3luqbvvIzliJnooajmmI7or6XlrZfnrKbkuLrkuIvkuIDooYzlrZfnrKbvvIxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IFwiXFxuXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICQoXCIjc3Bhbk5vZGVJZFwiKS50ZXh0KGlubmVyVmFsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHJlID0gaW5uZXJWYWw7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpbm5lckkgPT0gdmFsTGVuZ3RoIC0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gcHJlICsgaW5uZXJWYWw7IC8v5pyA5ZCO5LiA5Liq5a2X56ymXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBcIlxcblwiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAkKFwiI3NwYW5Ob2RlSWRcIikudGV4dChcIlwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHJlID0gXCJcIjtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmUgKz0gaW5uZXJWYWw7IC8v5L6d5qyh6L+95Yqg5YiwcHJl5Y+Y6YeP5LitXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuX2RvbS5yZW1vdmVDaGlsZChzcGFuTm9kZSk7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICog5paH5pys5Z+f6Ieq6YCC5bqU6auY5a69XHJcbiAgICAgKi9cclxuICAgIGZpc2hUb3BvUHJvdG8udGV4dGFyZWFSZXNpemUgPSBmdW5jdGlvbih0ZXh0UmVjdCwgdGV4dGFyZWEpIHtcclxuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XHJcbiAgICAgICAgdGV4dGFyZWEuc3R5bGUud2lkdGggPSAwO1xyXG4gICAgICAgIHRleHRhcmVhLnN0eWxlLndpZHRoID0gKDEuMSAqIHRleHRSZWN0LndpZHRoKSAqIHRoYXQubm93Wm9vbSArIFwicHhcIjtcclxuICAgICAgICBpZiAodGV4dFJlY3Qud2lkdGggPD0gMCkge1xyXG4gICAgICAgICAgICB0ZXh0YXJlYS5zdHlsZS53aWR0aCA9IFwiMTJweFwiO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0ZXh0YXJlYS5zdHlsZS5oZWlnaHQgPSBcIjBweFwiO1xyXG4gICAgICAgIHRleHRhcmVhLnN0eWxlLmhlaWdodCA9IHRleHRhcmVhLnNjcm9sbEhlaWdodCArICdweCc7XHJcbiAgICAgICAgaWYgKHRleHRhcmVhLnNjcm9sbEhlaWdodCA8PSAwKSB7XHJcbiAgICAgICAgICAgIHRleHRhcmVhLnN0eWxlLmhlaWdodCA9IFwiMTJweFwiO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOWIm+W7uuiKgueCueS4iumdoueahOitpuWRilxyXG4gICAgICogQG1ldGhvZCBjcmVhdEFsYXJtXHJcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IG5vZGUg6IqC54K5XHJcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IG9wdCAg6YCJ6aG55YC8XHJcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHQudGV4dF0g6K2m5ZGK55qE5paH5a2XXHJcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHQudGV4dEZvbnRdIOitpuWRiueahOaWh+Wtl+eahOWtl+S9k1xyXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0LnRleHRGaWxsXSDorablkYrnmoTmloflrZfnmoTpopzoibJcclxuICAgICAqIEBwYXJhbSAge09iamVjdH0gW29wdC50ZXh0QmFja2dyb3VuZF0g6K2m5ZGK55qE6IOM5pmv55qE6aKc6ImyXHJcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IOi/lOWbnuiKgueCueS4iueahOitpuWRilxyXG4gICAgICpcclxuICAgICAqICoq5L2/55So6IyD5L6LKirvvJpcclxuICAgICAqXHJcbiAgICAgKiAgICAgIEBleGFtcGxlXHJcbiAgICAgKiAgICAgICAgICB0aGlzLmZpc2hUb3BvLmNyZWF0QWxhcm0oczEse1xyXG4gICAgICogICAgICAgICAgdGV4dDpcIjIgV1wiLFxyXG4gICAgICogICAgICAgICAgdGV4dEZvbnQ6XCI0cHggTWljcm9zb2Z0IFlhSGVpXCIsXHJcbiAgICAgKiAgICAgICAgICB0ZXh0RmlsbDpcIiNGRkZGRkZcIixcclxuICAgICAqICAgICAgICAgIHRleHRCYWNrZ3JvdW5kOlwicmdiYSgyNTUsMCwwLDAuNilcIlxyXG4gICAgICogICAgICB9KTsvL+WIm+W7uuWwj+WbvueJh+WSjOiKgueCuee7keWumlxyXG4gICAgICovXHJcbiAgICBmaXNoVG9wb1Byb3RvLmNyZWF0QWxhcm0gPSBmdW5jdGlvbihub2RlLCBvcHQpIHtcclxuICAgICAgICB2YXIgZ3JvdXAgPSB0aGlzLmNyZWF0Tm9kZShcIkdyb3VwXCIsIHtcclxuICAgICAgICAgICAgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgIGZpbGw6ICdyZ2JhKDAsMCwwLDApJyxcclxuICAgICAgICAgICAgICAgIHN0cm9rZTogJ3JnYmEoMCwwLDAsMCknXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBncm91cC5pc2RyYWdnYWJsZSA9IGZhbHNlO1xyXG4gICAgICAgIHZhciB0ZXh0ID0gdGhpcy5jcmVhdE5vZGUoXCJUZXh0XCIsIHsgLy/mloflrZdcclxuICAgICAgICAgICAgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgIHRleHQ6IG9wdC50ZXh0LFxyXG4gICAgICAgICAgICAgICAgdGV4dEZvbnQ6IG9wdC50ZXh0Rm9udCxcclxuICAgICAgICAgICAgICAgIGZpbGw6IG9wdC50ZXh0RmlsbCxcclxuICAgICAgICAgICAgICAgIHRleHRCYXNlbGluZTogXCJ0b3BcIiAvL+WeguebtOWvuem9kCxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgbm9TZWxlY3RlZDogdHJ1ZSxcclxuICAgICAgICAgICAgcG9zaXRpb246IFsyLCAwXSxcclxuICAgICAgICAgICAgejogMlxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRleHQuaXNkcmFnZ2FibGUgPSBmYWxzZTtcclxuICAgICAgICBncm91cC5hZGQodGV4dCk7XHJcbiAgICAgICAgaWYgKG5vZGUucGFyZW50ICYmIG5vZGUucGFyZW50IGluc3RhbmNlb2YgR3JvdXBOb2RlKSB7XHJcbiAgICAgICAgICAgIG5vZGUucGFyZW50LmFkZChncm91cCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5ncm91cC5hZGQoZ3JvdXApO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgZ3JvdXBXaWR0aCA9IGdyb3VwLmdldEJvdW5kaW5nUmVjdCgpLndpZHRoICsgMjtcclxuICAgICAgICB2YXIgZ3JvdXBIZWlnaHQgPSBncm91cC5nZXRCb3VuZGluZ1JlY3QoKS5oZWlnaHQgKyA2O1xyXG4gICAgICAgIHZhciBwb2ludHMgPSBbXHJcbiAgICAgICAgICAgIFswLCAwXSxcclxuICAgICAgICAgICAgW2dyb3VwV2lkdGgsIDBdLFxyXG4gICAgICAgICAgICBbZ3JvdXBXaWR0aCwgZ3JvdXBIZWlnaHRdLFxyXG4gICAgICAgICAgICBbZ3JvdXBXaWR0aCAtIDMsIGdyb3VwSGVpZ2h0XSxcclxuICAgICAgICAgICAgW2dyb3VwV2lkdGggLSA2LCBncm91cEhlaWdodCArIDNdLFxyXG4gICAgICAgICAgICBbZ3JvdXBXaWR0aCAtIDksIGdyb3VwSGVpZ2h0XSxcclxuICAgICAgICAgICAgWzAsIGdyb3VwSGVpZ2h0XSxcclxuICAgICAgICAgICAgWzAsIDBdXHJcbiAgICAgICAgXTtcclxuICAgICAgICB2YXIgUG9seWxpbmUgPSB0aGlzLmNyZWF0Tm9kZShcIlBvbHlsaW5lXCIsIHtcclxuICAgICAgICAgICAgc2hhcGU6IHtcclxuICAgICAgICAgICAgICAgIHBvaW50czogcG9pbnRzXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgICBmaWxsOiBvcHQudGV4dEJhY2tncm91bmQsXHJcbiAgICAgICAgICAgICAgICBzdHJva2U6IG9wdC50ZXh0QmFja2dyb3VuZFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBub1NlbGVjdGVkOiB0cnVlLFxyXG4gICAgICAgICAgICB6OiAxXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgUG9seWxpbmUuaXNkcmFnZ2FibGUgPSBmYWxzZTtcclxuICAgICAgICBncm91cC5hZGQoUG9seWxpbmUpO1xyXG4gICAgICAgIHZhciBncm91cFBvc2l0aW9uID0gW25vZGUucG9zaXRpb25bMF0gKyBub2RlLmdldEJvdW5kaW5nUmVjdCgpLndpZHRoIC0gKGdyb3VwLmdldEJvdW5kaW5nUmVjdCgpLndpZHRoIC0gNiksIG5vZGUucG9zaXRpb25bMV0gLSBncm91cC5nZXRCb3VuZGluZ1JlY3QoKS5oZWlnaHQgLSAzXTtcclxuICAgICAgICBncm91cC5hdHRyKFwicG9zaXRpb25cIiwgZ3JvdXBQb3NpdGlvbik7XHJcbiAgICAgICAgbm9kZS5hbGFybSA9IGdyb3VwO1xyXG4gICAgICAgIC8v6K6+572u5qih5Z6LIOe7mWpzb27luo/liJfljJbnlKhcclxuICAgICAgICB2YXIgbW9kZWwgPSBuZXcgTW9kZWwoe30pO1xyXG4gICAgICAgIG1vZGVsLnNldChDb25zdGFudHMuRUxFTUVOVF9UWVBFLCBDb25zdGFudHMuQUxBUk0pO1xyXG4gICAgICAgIG1vZGVsLnNldChDb25zdGFudHMuT1BUSU9OUywgenJVdGlsLmNsb25lKG9wdCkpO1xyXG4gICAgICAgIG1vZGVsLnNldChDb25zdGFudHMuUkVMQVRJT05JRCwgbm9kZS5tb2RlbC5nZXQoQ29uc3RhbnRzLklEKSk7XHJcbiAgICAgICAgZ3JvdXAubW9kZWwgPSBtb2RlbDtcclxuICAgICAgICByZXR1cm4gZ3JvdXA7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICog5Yib5bu6Q21z6IqC54K5XHJcbiAgICAgKiBAbWV0aG9kIGNyZWF0Q21zUmVjdFxyXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBub2RlIOiKgueCuVxyXG4gICAgICovXHJcbiAgICBmaXNoVG9wb1Byb3RvLmNyZWF0Q21zUmVjdCA9IGZ1bmN0aW9uKG5vZGUpIHtcclxuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XHJcbiAgICAgICAgLy9ub2RlLm5vU2VsZWN0ZWQgPSB0cnVlO1xyXG4gICAgICAgIHZhciB3aWR0aCwgaGVpZ2h0O1xyXG4gICAgICAgIGlmIChub2RlLnN0eWxlKSB7XHJcbiAgICAgICAgICAgIHdpZHRoID0gbm9kZS5zdHlsZS53aWR0aCB8fCA0MDtcclxuICAgICAgICAgICAgaGVpZ2h0ID0gbm9kZS5zdHlsZS5oZWlnaHQgfHwgNDg7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgd2lkdGggPSBub2RlLm9wdGlvbnMuc3R5bGUud2lkdGggfHwgNDA7XHJcbiAgICAgICAgICAgIGhlaWdodCA9IG5vZGUub3B0aW9ucy5zdHlsZS5oZWlnaHQgfHwgNDg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciByZWN0ID0gdGhpcy5jcmVhdE5vZGUoXCJSZWN0XCIsIHsgLy/nn6nlvaJcclxuICAgICAgICAgICAgc2hhcGU6IHtcclxuICAgICAgICAgICAgICAgIHdpZHRoOiAxMDAgKyB3aWR0aCxcclxuICAgICAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0IC0gOCxcclxuICAgICAgICAgICAgICAgIHI6IDVcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgIGlzQWxsb3dFZGl0OiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgdGV4dDogbm9kZS5tb2RlbC5nZXQoXCJvcHRpb25zLnN0eWxlLnRleHRcIiksXHJcbiAgICAgICAgICAgICAgICBmaWxsOiBcIiNGRkZGRkZcIixcclxuICAgICAgICAgICAgICAgIHRleHRGb250OiBub2RlLm1vZGVsLmdldChcIm9wdGlvbnMuc3R5bGUudGV4dEZvbnRcIikgfHwgJzE0cHggTWljcm9zb2Z0IFlhSGVpJyxcclxuICAgICAgICAgICAgICAgIHRleHRBbGlnbjogXCJsZWZ0XCJcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgejogMSxcclxuICAgICAgICAgICAgcG9zaXRpb246IFtub2RlLnBvc2l0aW9uWzBdLCBub2RlLnBvc2l0aW9uWzFdICsgOF0sXHJcbiAgICAgICAgICAgIGRyYWdnYWJsZTogbm9kZS5kcmFnZ2FibGUsIC8v56aB5q2i5ouW5YqoXHJcbiAgICAgICAgICAgIG9wZXJhdGlvbkljb25zOiBub2RlLm9wZXJhdGlvbkljb25zXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdmFyIG5vZGVUZXh0ID0gbm9kZS5jaGlsZE9mTmFtZSgnUmVjdCcpO1xyXG4gICAgICAgIG5vZGVUZXh0LmF0dHIoXCJzdHlsZVwiLCB7XHJcbiAgICAgICAgICAgIFwidGV4dFwiOiBcIlwiXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgbm9kZS5hdHRyKFwielwiLCAyKTtcclxuICAgICAgICBub2RlLmF0dHIoXCJkcmFnZ2FibGVcIiwgZmFsc2UpO1xyXG4gICAgICAgIG5vZGUub3BlcmF0aW9uSWNvbnMgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuYWRkTm9kZShyZWN0KTtcclxuICAgICAgICByZWN0LmNtc0ltYWdlID0gbm9kZTtcclxuICAgICAgICBub2RlLmZyb21DbXNJbWFnZSA9IHJlY3Q7XHJcbiAgICAgICAgbm9kZS5fY2hpbGRyZW5bMV0uZnJvbUNtc0ltYWdlID0gcmVjdDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDoh6rliqjluIPlsYBcclxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gdHlwZSDoioLngrlcclxuICAgICAqIEBwYXJhbSAge09iamVjdH0gb3B0aW9uIOmAiemhuVxyXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uLm5vZGVdIHRyZWXluIPlsYDkuLrotbfngrnnmoToioLngrnvvIjlj6rmnIl0cmVl5biD5bGA5pyJ77yJXHJcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IFtvcHRpb24udHlwZV0gdHJlZeW4g+WxgOeahOexu+Wei++8jGhvcml6b250YWzkuLrmqKrlkJHvvIx2ZXJ0aWNhbOS4uuerluWQke+8jOm7mOiupOS4unZlcnRpY2FsXHJcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IFtvcHRpb24ucmVwdWxzaW9uXSDlipvlr7zlkJHluIPlsYDnmoTnsbvlnovvvIzoioLngrnkuYvpl7TnmoTmlqXlipvlm6DlrZDjgILor6XlgLzotorlpKfoioLngrnkuYvpl7TnmoTmlqXlipvotorlpKfvvIzkuKTkuKroioLngrnpl7TnmoTot53nprvkuZ/kvJrotorov5zvvIzpu5jorqTkuLoxMDBcclxuICAgICAqIEBwYXJhbSAge051bWJlcn0gW29wdGlvbi5ncmF2aXR5XSDlipvlr7zlkJHluIPlsYDnmoTnsbvlnovvvIzoioLngrnlj5fliLDnmoTlkJHkuK3lv4PnmoTlvJXlipvlm6DlrZDjgILor6XlgLzotorlpKfoioLngrnotorlvoDkuK3lv4PngrnpnaDmi6LjgILpu5jorqTkuLowLjFcclxuICAgICAqIEBwYXJhbSAge051bWJlcn0gW29wdGlvbi5ncmF2aXR5XSDlipvlr7zlkJHluIPlsYDnmoTnsbvlnovvvIzovrnnmoTkuKTkuKroioLngrnkuYvpl7TnmoTot53nprvvvIzov5nkuKrot53nprvkuZ/kvJrlj5cgcmVwdWxzaW9u44CCIOm7mOiupOS4ujMwXHJcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IFtvcHRpb24ud2lkdGhdIOWKm+WvvOWQkeW4g+WxgOeahOexu+Weiywg5biD5bGA55S75biD55qE5a695bqmIOm7mOiupOS4uuaVtOS4queUu+W4g+eahOWuveW6plxyXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBbb3B0aW9uLmhlaWdodF0g5Yqb5a+85ZCR5biD5bGA55qE57G75Z6LLCDluIPlsYDnlLvluIPnmoTpq5jluqYg6buY6K6k5Li65pW05Liq55S75biD55qE6auY5bqmXHJcbiAgICAgKiBAcGFyYW0gIHtCb29sZWFufSBbb3B0aW9uLm9uY2VdIOWPquaJp+ihjOS4gOasoeW4g+WxgO+8jOenu+WKqOiKgueCueS4jeiHquWKqOW4g+WxgO+8jOm7mOiupOS4umZhbHNl77yI5Y+q5pyJ5Yqb5a+85ZCR5biD5bGA5pyJ77yJXHJcbiAgICAgKi9cclxuICAgIGZpc2hUb3BvUHJvdG8ubGF5b3V0Tm9kZSA9IGZ1bmN0aW9uKHR5cGUsIG9wdGlvbikge1xyXG4gICAgICAgIGlmICh0eXBlID09IFwidHJlZVwiKSB7XHJcbiAgICAgICAgICAgIGlmIChvcHRpb24ubm9kZS5wYXJlbnQgJiYgb3B0aW9uLm5vZGUucGFyZW50IGluc3RhbmNlb2YgR3JvdXBOb2RlKSB7XHJcbiAgICAgICAgICAgICAgICBvcHRpb24ubm9kZS5wYXJlbnQuZWFjaENoaWxkKGZ1bmN0aW9uKGNoaWxkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQuaXNkcmFnZ2FibGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMudHJlZUxheW91dChvcHRpb24pO1xyXG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PSBcImZvcmNlXCIpIHtcclxuICAgICAgICAgICAgdmFyIGRlZmF1bHRPcHRpb25zID0ge1xyXG4gICAgICAgICAgICAgICAgYWxsTm9kZXM6IHRoaXMuYWxsTm9kZXMsXHJcbiAgICAgICAgICAgICAgICBhbGxDb25zOiBGbG93Q29ubmVjdGlvbk1hbmFnZXIuY29ubmVjdG9ycyxcclxuICAgICAgICAgICAgICAgIHJlcHVsc2lvbjogMTAwLFxyXG4gICAgICAgICAgICAgICAgZ3Jhdml0eTogMC4xLFxyXG4gICAgICAgICAgICAgICAgZWRnZUxlbmd0aDogMzAsXHJcbiAgICAgICAgICAgICAgICBvbmNlOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIHdpZHRoOiB0aGlzLmdldFdpZHRoKCksXHJcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IHRoaXMuZ2V0SGVpZ2h0KCksXHJcbiAgICAgICAgICAgICAgICBmb3JjZUxheW91dDogbnVsbCxcclxuICAgICAgICAgICAgICAgIHByZXNlcnZlZFBvaW50czoge31cclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuZm9yY2VMYXlvdXRPcHRpb24gPSB6clV0aWwuZGVmYXVsdHMoZGVmYXVsdE9wdGlvbnMsIG9wdGlvbiwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIHRoaXMuZm9yY2VMYXlvdXRPcHRpb24ucmVjdCA9IG5ldyBncmFwaGljLkJvdW5kaW5nUmVjdCgwLCAwLCB0aGlzLmZvcmNlTGF5b3V0T3B0aW9uLndpZHRoLCB0aGlzLmZvcmNlTGF5b3V0T3B0aW9uLmhlaWdodCk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmZvcmNlSW5zdGFuY2UodGhpcy5mb3JjZUxheW91dE9wdGlvbik7XHJcblxyXG4gICAgICAgICAgICB0aGlzLnN0YXJ0Rm9yY2VMYXlvdXRJdGVyYXRpb24odGhpcy5mb3JjZUxheW91dE9wdGlvbi5mb3JjZUxheW91dCwgdHJ1ZSk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICog5byA5aeL6L+b6KGM5Yqb5a+85ZCR6L+t5LujXHJcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IGZvcmNlTGF5b3V0ICAgICBb5Yqb5a+85ZCR5a+56LGhXVxyXG4gICAgICogQHBhcmFtICB7Qm9vbGVhbn0gbGF5b3V0QW5pbWF0aW9uIFvmmK/lkKbliqjnlLtdXHJcbiAgICAgKiBAcmV0dXJuIHt2b2lkfVxyXG4gICAgICovXHJcbiAgICBmaXNoVG9wb1Byb3RvLnN0YXJ0Rm9yY2VMYXlvdXRJdGVyYXRpb24gPSBmdW5jdGlvbihmb3JjZUxheW91dCwgbGF5b3V0QW5pbWF0aW9uKSB7XHJcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgICAgIChmdW5jdGlvbiBzdGVwKCkge1xyXG4gICAgICAgICAgICBmb3JjZUxheW91dC5zdGVwKGZ1bmN0aW9uIChzdG9wcGVkKSB7XHJcbiAgICAgICAgICAgICAgICBzZWxmLl9sYXlvdXRpbmcgPSAhc3RvcHBlZDtcclxuICAgICAgICAgICAgICAgIGlmIChzZWxmLl9sYXlvdXRpbmcpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobGF5b3V0QW5pbWF0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX2xheW91dFRpbWVvdXQgPSBzZXRUaW1lb3V0KHN0ZXAsIDE2KVxyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0ZXAoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgfSkoKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiDov5Tlm57lvZPliY3nlLvluIPnmoTmlbDmja5cclxuICAgICAqL1xyXG4gICAgZmlzaFRvcG9Qcm90by50b0RhdGFVUkwgPSBmdW5jdGlvbihvcHRzKSB7XHJcbiAgICAgICAgcmV0dXJuIEZsb3dVdGlsLnRvRGF0YVVSTCh0aGlzLl96ciwgb3B0cyk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIOWIneWni+WMlue8qeaUvlxyXG4gICAgICovXHJcbiAgICBmaXNoVG9wb1Byb3RvLmluaXRTY2FsZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgICAgICB2YXIgZ3JvdXBNYXhXaWR0aCA9IHRoYXQuZ3JvdXAuZ2V0Qm91bmRpbmdSZWN0KCkud2lkdGg7XHJcbiAgICAgICAgdmFyIGdyb3VwTWF4SGVpZ2h0ID0gdGhhdC5ncm91cC5nZXRCb3VuZGluZ1JlY3QoKS5oZWlnaHQ7XHJcbiAgICAgICAgdmFyIHJhbmdlV2lkdGggPSB0aGF0LmdldFdpZHRoKCk7XHJcbiAgICAgICAgdmFyIHJhbmdlSGVpZ2h0ID0gdGhhdC5nZXRIZWlnaHQoKTtcclxuICAgICAgICB2YXIgaW5pdFJhdGlvID0gMSxcclxuICAgICAgICAgICAgcG9zID0gW107XHJcbiAgICAgICAgaWYgKGdyb3VwTWF4V2lkdGggLyBncm91cE1heEhlaWdodCA+IHJhbmdlV2lkdGggLyByYW5nZUhlaWdodCkge1xyXG4gICAgICAgICAgICBpZiAoZ3JvdXBNYXhXaWR0aCA+IHJhbmdlV2lkdGgpIHtcclxuICAgICAgICAgICAgICAgIGluaXRSYXRpbyA9IHJhbmdlV2lkdGggLyBncm91cE1heFdpZHRoO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKGdyb3VwTWF4SGVpZ2h0ID4gcmFuZ2VIZWlnaHQpIHtcclxuICAgICAgICAgICAgICAgIGluaXRSYXRpbyA9IHJhbmdlSGVpZ2h0IC8gZ3JvdXBNYXhIZWlnaHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcG9zWzBdID0gTWF0aC5hYnModGhhdC5ncm91cC5nZXRCb3VuZGluZ1JlY3QoKS54KSAqIGluaXRSYXRpbztcclxuICAgICAgICBwb3NbMV0gPSBNYXRoLmFicyh0aGF0Lmdyb3VwLmdldEJvdW5kaW5nUmVjdCgpLnkpICogaW5pdFJhdGlvO1xyXG4gICAgICAgIHRoYXQuZ3JvdXAuYXR0cihcInBvc2l0aW9uXCIsIFtwb3NbMF0sIHBvc1sxXV0pO1xyXG4gICAgICAgIHRoYXQuZ3JvdXAuYXR0cihcInNjYWxlXCIsIFtpbml0UmF0aW8sIGluaXRSYXRpb10pO1xyXG4gICAgICAgIHRoYXQuaW5pdFNjYWxlUmF0aW8gPSBpbml0UmF0aW87XHJcbiAgICAgICAgdmFyIGRpc3RhbmNlID0gW3Bvc1swXSwgcG9zWzFdLCB0aGF0LmluaXRTY2FsZVJhdGlvLCBncm91cE1heFdpZHRoLCBncm91cE1heEhlaWdodF07XHJcbiAgICAgICAgcmV0dXJuIGRpc3RhbmNlO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIOaUvuWkp+aIluiAhee8qeWwj1xyXG4gICAgICogQHBhcmFtICB7U3RyaW5nfE51bWJlcn0gdHlwZSDlvZPkuLrlrZfnrKbkuLLml7YgXCJlbmxhcmdlXCLmlL7lpKcgIFwibmFycm93aW5nXCLnvKnlsI8gIOW9k+S4uuaVsOWAvOaXtiDnvKnmlL7nmoTmr5TkvosgIOW7uuiurjAuMy0xLjdcclxuICAgICAqL1xyXG4gICAgZmlzaFRvcG9Qcm90by56clNjYWxlID0gZnVuY3Rpb24odHlwZSkge1xyXG4gICAgICAgIGlmICh0eXBlKSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlID09IFwibmFycm93aW5nXCIpIHtcclxuICAgICAgICAgICAgICAgIHZhciB6b29tRGVsdGExID0gLTAuMDc7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnpvb20oem9vbURlbHRhMSwgdGhpcy5fenIuZ2V0V2lkdGgoKSAvIDIsIHRoaXMuX3pyLmdldEhlaWdodCgpIC8gMik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHR5cGUgPT0gXCJlbmxhcmdlXCIpIHtcclxuICAgICAgICAgICAgICAgIHZhciB6b29tRGVsdGEgPSAwLjA3O1xyXG4gICAgICAgICAgICAgICAgdGhpcy56b29tKHpvb21EZWx0YSwgdGhpcy5fenIuZ2V0V2lkdGgoKSAvIDIsIHRoaXMuX3pyLmdldEhlaWdodCgpIC8gMik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFpc05hTih0eXBlKSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHRhcmdldCA9IHRoaXMuZ3JvdXA7XHJcbiAgICAgICAgICAgICAgICBpZiAodGFyZ2V0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHpvb21TY2FsZSA9IHR5cGU7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fem9vbSA9IHR5cGU7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ub3dab29tID0gdHlwZTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFNjYWxlKHRoaXMuX3pyLmdldFdpZHRoKCkgLyAyLCB0aGlzLl96ci5nZXRIZWlnaHQoKSAvIDIsIHpvb21TY2FsZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLl96ci5vbignbW91c2V3aGVlbCcsIHpyVXRpbC5iaW5kKGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgICAgICAgIGV2ZW50VG9vbC5zdG9wKGUuZXZlbnQpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHpvb21EZWx0YSA9IGUud2hlZWxEZWx0YSA+IDAgPyAwLjA3IDogLTAuMDc7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnpvb20oem9vbURlbHRhLCB0aGlzLl96ci5nZXRXaWR0aCgpIC8gMiwgdGhpcy5fenIuZ2V0SGVpZ2h0KCkgLyAyKTtcclxuICAgICAgICAgICAgfSwgdGhpcykpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBmaXNoVG9wb1Byb3RvLnpvb20gPSBmdW5jdGlvbih6b29tRGVsdGEsIHpvb21YLCB6b29tWSkge1xyXG4gICAgICAgIGlmICh0aGlzLmNhblNjYWxlID09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHRhcmdldCA9IHRoaXMuZ3JvdXA7XHJcbiAgICAgICAgaWYgKHRhcmdldCkge1xyXG5cclxuICAgICAgICAgICAgdmFyIG5ld1pvb20gPSB0aGlzLl96b29tID0gdGhpcy5fem9vbSB8fCAxO1xyXG4gICAgICAgICAgICBuZXdab29tICs9IHpvb21EZWx0YTtcclxuXHJcbiAgICAgICAgICAgIG5ld1pvb20gPSBOdW1iZXIobmV3Wm9vbS50b0ZpeGVkKDIpKTtcclxuICAgICAgICAgICAgdmFyIHpvb21TY2FsZSA9IG5ld1pvb20gLyB0aGlzLl96b29tO1xyXG4gICAgICAgICAgICBpZiAobmV3Wm9vbSA+IDEuNyB8fCBuZXdab29tIDwgMC4zKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fem9vbSA9IG5ld1pvb207XHJcblxyXG4gICAgICAgICAgICB0aGlzLm5vd1pvb20gPSBuZXdab29tO1xyXG4gICAgICAgICAgICB0aGlzLnNldFNjYWxlKHpvb21YLCB6b29tWSwgem9vbVNjYWxlKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgZmlzaFRvcG9Qcm90by5zZXRTY2FsZSA9IGZ1bmN0aW9uKHpvb21YLCB6b29tWSwgem9vbVNjYWxlKSB7XHJcbiAgICAgICAgdmFyIHRhcmdldCA9IHRoaXMuZ3JvdXA7XHJcbiAgICAgICAgdmFyIHBvcyA9IHRhcmdldC5wb3NpdGlvbjtcclxuICAgICAgICB2YXIgc2NhbGUgPSB0YXJnZXQuc2NhbGU7XHJcbiAgICAgICAgLy8gS2VlcCB0aGUgbW91c2UgY2VudGVyIHdoZW4gc2NhbGluZ1xyXG4gICAgICAgIHBvc1swXSAtPSAoem9vbVggLSBwb3NbMF0pICogKHpvb21TY2FsZSAtIDEpO1xyXG4gICAgICAgIHBvc1sxXSAtPSAoem9vbVkgLSBwb3NbMV0pICogKHpvb21TY2FsZSAtIDEpO1xyXG4gICAgICAgIHNjYWxlWzBdICo9IHpvb21TY2FsZTtcclxuICAgICAgICBzY2FsZVsxXSAqPSB6b29tU2NhbGU7XHJcbiAgICAgICAgdGFyZ2V0LmF0dHIoXCJwb3NpdGlvblwiLCBbcG9zWzBdLCBwb3NbMV1dKTtcclxuICAgICAgICB0YXJnZXQuYXR0cihcInNjYWxlXCIsIFtzY2FsZVswXSwgc2NhbGVbMV1dKTtcclxuICAgICAgICBpZiAodGhpcy5lYWdsZUV5ZSA9PSB0cnVlKSB7XHJcbiAgICAgICAgICAgIHRoaXMubWluaW1hcC51cGRhdGFTZWxlY3Rpb24ocG9zWzBdLCBwb3NbMV0sIHpvb21TY2FsZSwgdGhpcy5ub3dab29tKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICog6bmw55y85Zu+XHJcbiAgICAgKiBAcGFyYW0gIHtIVE1MRWxlbWVudH0gZWFnbGVFeWVOb2RlIOaYvuekuum5sOecvOWbvueahGRpduWFg+e0oFxyXG4gICAgICovXHJcbiAgICBmaXNoVG9wb1Byb3RvLm9wZW5FYWdsZUV5ZSA9IGZ1bmN0aW9uKGVhZ2xlRXllTm9kZSkge1xyXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgICAgICB0aGlzLmVhZ2xlRXllID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLmVhZ2xlRXllTm9kZSA9IGVhZ2xlRXllTm9kZTtcclxuICAgICAgICB2YXIgZ3JvdXBQb3NpdGlvbiA9IHpyVXRpbC5jbG9uZSh0aGlzLmdyb3VwLnBvc2l0aW9uKTtcclxuICAgICAgICB2YXIgZ3JvdXBTY2FsZSA9IHpyVXRpbC5jbG9uZSh0aGlzLmdyb3VwLnNjYWxlKTtcclxuICAgICAgICB0aGlzLmdyb3VwLmF0dHIoXCJwb3NpdGlvblwiLCBbMCwgMF0pO1xyXG4gICAgICAgIHRoaXMuZ3JvdXAuYXR0cihcInNjYWxlXCIsIFsxLCAxXSk7XHJcbiAgICAgICAgdmFyIGRpc3RhbmNlID0gdGhpcy5pbml0U2NhbGUoKTtcclxuICAgICAgICB2YXIgaW1nU3JjID0gdGhpcy50b0RhdGFVUkwoKTtcclxuICAgICAgICB0aGlzLmdyb3VwLmF0dHIoXCJwb3NpdGlvblwiLCBncm91cFBvc2l0aW9uKTtcclxuICAgICAgICB0aGlzLmdyb3VwLmF0dHIoXCJzY2FsZVwiLCBncm91cFNjYWxlKTtcclxuICAgICAgICBpZiAodGhpcy5taW5pbWFwKSB7XHJcbiAgICAgICAgICAgIHRoaXMubWluaW1hcC51cGRhdGFNYXAoaW1nU3JjLCB0aGlzLmdyb3VwLmdldEJvdW5kaW5nUmVjdCgpKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLm1pbmltYXAgPSBuZXcgTWluaW1hcCh0aGlzLCB0aGlzLmdyb3VwLnBvc2l0aW9uLCB0aGlzLmdyb3VwLmdldEJvdW5kaW5nUmVjdCgpLCBlYWdsZUV5ZU5vZGUsIGRpc3RhbmNlLCBpbWdTcmMpO1xyXG4gICAgICAgICAgICBzZXRUaW1lb3V0KHpyVXRpbC5iaW5kKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vcGVuRWFnbGVFeWUodGhhdC5lYWdsZUV5ZU5vZGUpXHJcbiAgICAgICAgICAgIH0sIHRoaXMpLCAxMCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoYXQubWluaW1hcC5zZWxlY3Rpb24uYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICAgIHZhciBzdGFydFggPSBlLmNsaWVudFg7XHJcbiAgICAgICAgICAgIHZhciBzdGFydFkgPSBlLmNsaWVudFk7XHJcbiAgICAgICAgICAgIHZhciBtaW5pbWFwTGVmdCA9IE51bWJlcih0aGF0Lm1pbmltYXAuc2VsZWN0aW9uLnN0eWxlLmxlZnQuc3Vic3RyaW5nKDAsIHRoYXQubWluaW1hcC5zZWxlY3Rpb24uc3R5bGUubGVmdC5sZW5ndGggLSAyKSk7XHJcbiAgICAgICAgICAgIHZhciBtaW5pbWFwVG9wID0gTnVtYmVyKHRoYXQubWluaW1hcC5zZWxlY3Rpb24uc3R5bGUudG9wLnN1YnN0cmluZygwLCB0aGF0Lm1pbmltYXAuc2VsZWN0aW9uLnN0eWxlLnRvcC5sZW5ndGggLSAyKSk7XHJcbiAgICAgICAgICAgIHZhciBtb3ZlRnVuY3Rpb24gPSBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICAgICAgICBlYWdsZUV5ZU1vdmUoZSk7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICBmdW5jdGlvbiBlYWdsZUV5ZU1vdmUoZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIG9mZnNldFggPSBlLmNsaWVudFggLSBzdGFydFg7XHJcbiAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0WSA9IGUuY2xpZW50WSAtIHN0YXJ0WTtcclxuICAgICAgICAgICAgICAgIHRoYXQubWluaW1hcC5zZWxlY3Rpb24uc3R5bGUubGVmdCA9IG1pbmltYXBMZWZ0ICsgb2Zmc2V0WCArIFwicHhcIjtcclxuICAgICAgICAgICAgICAgIHRoYXQubWluaW1hcC5zZWxlY3Rpb24uc3R5bGUudG9wID0gbWluaW1hcFRvcCArIG9mZnNldFkgKyBcInB4XCI7XHJcbiAgICAgICAgICAgICAgICB0aGF0Lm1pbmltYXAudXBkYXRhR3JvdXBQb3NpdGlvbih0aGF0Lmdyb3VwLCB0aGF0Lm5vd1pvb20pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0aGF0Lm1pbmltYXAuc2VsZWN0aW9uLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgbW92ZUZ1bmN0aW9uKTtcclxuICAgICAgICAgICAgdmFyIHVwRnVuY3Rpb24gPSBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICAgICAgICBlYWdsZUV5ZVVwKGUpO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgZnVuY3Rpb24gZWFnbGVFeWVVcCgpIHtcclxuICAgICAgICAgICAgICAgIHRoYXQubWluaW1hcC5zZWxlY3Rpb24ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCBtb3ZlRnVuY3Rpb24pO1xyXG4gICAgICAgICAgICAgICAgdGhhdC5taW5pbWFwLnNlbGVjdGlvbi5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCBtb3ZlRnVuY3Rpb24pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0aGF0Lm1pbmltYXAuc2VsZWN0aW9uLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsIHVwRnVuY3Rpb24pO1xyXG4gICAgICAgIH0pXHJcblxyXG5cclxuICAgIH07XHJcbiAgICB6clV0aWwubWl4aW4oRmlzaFRvcG9GbG93LCBFdmVudGZ1bCk7XHJcblxyXG4gICAgLy8gLS0tLS0tLS0t5a+55aSW5pq06ZyyZmlzaFRvcG9GbG93LS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICB2YXIgaWRCYXNlID0gbmV3IERhdGUoKSAtIDA7XHJcbiAgICB2YXIgaW5zdGFuY2VzID0ge307XHJcbiAgICB2YXIgRE9NX0FUVFJJQlVURV9LRVkgPSAnX2Zpc2hUb3BvRmxvd19pbnN0YW5jZV8nO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogZmlzaFRvcG9GbG935YWo5bGA5a+56LGh77yM5aaC5p6c5pivYW1k5pa55byP5Yqg6L2977yM5YiZ55u05o6l6L+U5ZueXHJcbiAgICAgKiBAY2xhc3MgZmlzaFRvcG9GbG93XHJcbiAgICAgKiBAc2luZ2xldG9uXHJcbiAgICAgKi9cclxuICAgIHZhciBmaXNoVG9wb0Zsb3cgPSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICog54mI5pys5Y+3XHJcbiAgICAgICAgICogQHR5cGUge1N0cmluZ31cclxuICAgICAgICAgKi9cclxuICAgICAgICB2ZXJzaW9uOiAnMS4zLjAnLFxyXG4gICAgICAgIGRlcGVuZGVuY2llczoge1xyXG4gICAgICAgICAgICB6cmVuZGVyOiAnMy4wLjQnXHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIOWIneWni+WMlmRvbeWFg+e0oOS4uiBmbG935a+56LGhXHJcbiAgICAgKiBAbWVtYmVyIGZpc2hUb3BvRmxvd1xyXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZG9tICDkuIDkuKpkaXblhYPntKBcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzICDkvKDpgJLnmoTpgInpobnlj4LmlbBcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5yZW5kZXJlcj0nY2FudmFzJ10gJ2NhbnZhcycgb3IgJ3N2Zycgb3IgJ3ZtbCdcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0cy5kZXZpY2VQaXhlbFJhdGlvPTFdIHJldGluYSDlsY/luZXkvJjljJZcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0cy5saW5rTW9kaWZ5PWZhbHNlXSDmmK/lkKblhYHorrjosIPmlbTnur/mrrVcclxuICAgICAqIEByZXR1cm4ge2Zpc2gudG9wby5GaXNoVG9wb0Zsb3d9XHJcbiAgICAgKi9cclxuICAgIGZpc2hUb3BvRmxvdy5pbml0ID0gZnVuY3Rpb24oZG9tLCBvcHRzKSB7XHJcbiAgICAgICAgaWYgKCFkb20pIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbml0aWFsaXplIGZhaWxlZDogaW52YWxpZCBkb20uJyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBvcHRzID0gb3B0cyB8fCB7fTtcclxuICAgICAgICAvLyBEZWZhdWx0IHZhbHVlXHJcbiAgICAgICAgenJVdGlsLmRlZmF1bHRzKG9wdHMsIHtcclxuICAgICAgICAgICAgdHlwZTogXCJmbG93XCIsXHJcbiAgICAgICAgICAgIGRldmljZVBpeGVsUmF0aW86IDEsXHJcbiAgICAgICAgICAgIGxpbmtNb2RpZnk6IGZhbHNlLFxyXG4gICAgICAgICAgICBpc0FsbG93RWRpdDogZmFsc2VcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgdmFyIGZpc2hUb3BvRmxvdyA9IG5ldyBGaXNoVG9wb0Zsb3coZG9tLCBvcHRzKTtcclxuICAgICAgICBmaXNoVG9wb0Zsb3cuaW5pdCgpO1xyXG4gICAgICAgIGZpc2hUb3BvRmxvdy5GbG93ID0gRmxvdztcclxuICAgICAgICBmaXNoVG9wb0Zsb3cuaWQgPSAnZnRfJyArIGlkQmFzZSsrO1xyXG4gICAgICAgIGluc3RhbmNlc1tmaXNoVG9wb0Zsb3cuaWRdID0gZmlzaFRvcG9GbG93O1xyXG5cclxuICAgICAgICBkb20uc2V0QXR0cmlidXRlICYmIGRvbS5zZXRBdHRyaWJ1dGUoRE9NX0FUVFJJQlVURV9LRVksIGZpc2hUb3BvRmxvdy5pZCk7XHJcblxyXG4gICAgICAgIHJldHVybiBmaXNoVG9wb0Zsb3c7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIOiOt+WPliBkb20g5a655Zmo5LiK55qE5a6e5L6L44CCXHJcbiAgICAgKiBAbWVtYmVyIGZpc2hUb3BvRmxvd1xyXG4gICAgICogQHBhcmFtICB7SFRNTEVsZW1lbnR9IGRvbSDkuIDkuKpkaXblhYPntKBcclxuICAgICAqIEByZXR1cm4ge2Zpc2gudG9wby5GaXNoVG9wb0Zsb3d9XHJcbiAgICAgKi9cclxuICAgIGZpc2hUb3BvRmxvdy5nZXRJbnN0YW5jZUJ5RG9tID0gZnVuY3Rpb24oZG9tKSB7XHJcbiAgICAgICAgdmFyIGtleSA9IGRvbS5nZXRBdHRyaWJ1dGUoRE9NX0FUVFJJQlVURV9LRVkpO1xyXG4gICAgICAgIHJldHVybiBpbnN0YW5jZXNba2V5XTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDplIDmr4Hlrp7kvovvvIzlrp7kvovplIDmr4HlkI7ml6Dms5Xlho3ooqvkvb/nlKjjgIJcclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIGZpc2hUb3BvRmxvd1xyXG4gICAgICogQHBhcmFtICB7T2JqZWN0fHN0cmluZ30gY2hhcnQgZmlzaFRvcG9CcG1u5a6e5L6LIOaIliBmaXNoVG9wb0JwbW7nmoRpZFxyXG4gICAgICovXHJcbiAgICBmaXNoVG9wb0Zsb3cuZGlzcG9zZSA9IGZ1bmN0aW9uKGNoYXJ0KSB7XHJcbiAgICAgICAgdmFyIHRvcG87XHJcbiAgICAgICAgaWYgKHpyVXRpbC5pc0RvbShjaGFydCkpIHtcclxuICAgICAgICAgICAgdG9wbyA9IGZpc2hUb3BvRmxvdy5nZXRJbnN0YW5jZUJ5RG9tKGNoYXJ0KTtcclxuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBjaGFydCA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgdG9wbyA9IGluc3RhbmNlc1tjaGFydF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICgodG9wbyBpbnN0YW5jZW9mIGZpc2hUb3BvRmxvdykgJiYgIXRvcG8uaXNEaXNwb3NlZCgpKSB7XHJcbiAgICAgICAgICAgIHRvcG8uZGlzcG9zZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fbGF5b3V0VGltZW91dCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8v5pq06Zyy5Ye65Y6755qE57G7XHJcbiAgICBmaXNoVG9wb0Zsb3cudXRpbCA9IHt9O1xyXG4gICAgZmlzaFRvcG9GbG93LnV0aWxbJ2luaXRJbWFnZVBvb2wnXSA9IEltYWdlUG9vbC5pbml0SW1hZ2VQb29sO1xyXG4gICAgenJVdGlsLmVhY2goW1xyXG4gICAgICAgICAgICAnbWFwJywgJ2VhY2gnLCAnZmlsdGVyJywgJ2luZGV4T2YnLCAnaW5oZXJpdHMnLFxyXG4gICAgICAgICAgICAncmVkdWNlJywgJ2ZpbHRlcicsICdiaW5kJywgJ2N1cnJ5JywgJ2lzQXJyYXknLFxyXG4gICAgICAgICAgICAnaXNTdHJpbmcnLCAnaXNPYmplY3QnLCAnaXNGdW5jdGlvbicsICdleHRlbmQnXHJcbiAgICAgICAgXSxcclxuICAgICAgICBmdW5jdGlvbihuYW1lKSB7XHJcbiAgICAgICAgICAgIGZpc2hUb3BvRmxvdy51dGlsW25hbWVdID0genJVdGlsW25hbWVdO1xyXG4gICAgICAgIH1cclxuICAgICk7XHJcblxyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmaXNoVG9wb0Zsb3c7XHJcblxyXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vbGliL2Zpc2gtdG9wby1mbG93L2xpYi9GaXNoVG9wb0Zsb3cuanNcbiAqKiBtb2R1bGUgaWQgPSAyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cclxuXHJcbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XHJcblxyXG4gICAgdmFyIHBhdGhUb29sID0gcmVxdWlyZSgnenJlbmRlci9saWIvdG9vbC9wYXRoJyk7XHJcbiAgICB2YXIgcm91bmQgPSBNYXRoLnJvdW5kO1xyXG4gICAgdmFyIFBhdGggPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9ncmFwaGljL1BhdGgnKTtcclxuICAgIHZhciBjb2xvclRvb2wgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi90b29sL2NvbG9yJyk7XHJcbiAgICB2YXIgbWF0cml4ID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS9tYXRyaXgnKTtcclxuICAgIHZhciB2ZWN0b3IgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3ZlY3RvcicpO1xyXG4gICAgdmFyIEdyYWRpZW50ID0gcmVxdWlyZSgnenJlbmRlci9saWIvZ3JhcGhpYy9HcmFkaWVudCcpO1xyXG4gICAgdmFyIERyYWdnYWJsZSA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL21peGluL0RyYWdnYWJsZScpO1xyXG5cclxuICAgIHZhciBncmFwaGljID0ge307XHJcbiAgICBncmFwaGljLlV0aWwgPSB6clV0aWw7XHJcbiAgICBncmFwaGljLkdyb3VwID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29udGFpbmVyL0dyb3VwJyk7XHJcblxyXG4gICAgZ3JhcGhpYy5JbWFnZSA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2dyYXBoaWMvSW1hZ2UnKTtcclxuXHJcbiAgICBncmFwaGljLlRleHQgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9ncmFwaGljL1RleHQnKTtcclxuXHJcbiAgICBncmFwaGljLnRleHRDb250YWluID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29udGFpbi90ZXh0Jyk7XHJcblxyXG4gICAgZ3JhcGhpYy5DaXJjbGUgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL0NpcmNsZScpO1xyXG5cclxuICAgIGdyYXBoaWMuU2VjdG9yID0gcmVxdWlyZSgnenJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9TZWN0b3InKTtcclxuXHJcbiAgICBncmFwaGljLlJpbmcgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL1JpbmcnKTtcclxuXHJcbiAgICBncmFwaGljLlBvbHlnb24gPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL1BvbHlnb24nKTtcclxuXHJcbiAgICBncmFwaGljLlBvbHlsaW5lID0gcmVxdWlyZSgnenJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9Qb2x5bGluZScpO1xyXG5cclxuICAgIGdyYXBoaWMuUmVjdCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvUmVjdCcpO1xyXG5cclxuICAgIGdyYXBoaWMuTGluZSA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvTGluZScpO1xyXG5cclxuICAgIGdyYXBoaWMuQmV6aWVyQ3VydmUgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL0JlemllckN1cnZlJyk7XHJcblxyXG4gICAgZ3JhcGhpYy5BcmMgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL0FyYycpO1xyXG5cclxuICAgIGdyYXBoaWMuTGluZWFyR3JhZGllbnQgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9ncmFwaGljL0xpbmVhckdyYWRpZW50Jyk7XHJcblxyXG4gICAgZ3JhcGhpYy5SYWRpYWxHcmFkaWVudCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2dyYXBoaWMvUmFkaWFsR3JhZGllbnQnKTtcclxuXHJcbiAgICBncmFwaGljLkJvdW5kaW5nUmVjdCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvQm91bmRpbmdSZWN0Jyk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBFeHRlbmQgc2hhcGUgd2l0aCBwYXJhbWV0ZXJzXHJcbiAgICAgKi9cclxuICAgIGdyYXBoaWMuZXh0ZW5kU2hhcGUgPSBmdW5jdGlvbiAob3B0cykge1xyXG4gICAgICAgIHJldHVybiBQYXRoLmV4dGVuZChvcHRzKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBFeHRlbmQgcGF0aFxyXG4gICAgICovXHJcbiAgICBncmFwaGljLmV4dGVuZFBhdGggPSBmdW5jdGlvbiAocGF0aERhdGEsIG9wdHMpIHtcclxuICAgICAgICByZXR1cm4gcGF0aFRvb2wuZXh0ZW5kRnJvbVN0cmluZyhwYXRoRGF0YSwgb3B0cyk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlIGEgcGF0aCBlbGVtZW50IGZyb20gcGF0aCBkYXRhIHN0cmluZ1xyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGhEYXRhXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0c1xyXG4gICAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9jb3JlL0JvdW5kaW5nUmVjdH0gcmVjdFxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtsYXlvdXQ9Y292ZXJdICdjZW50ZXInIG9yICdjb3ZlcidcclxuICAgICAqL1xyXG4gICAgZ3JhcGhpYy5tYWtlUGF0aCA9IGZ1bmN0aW9uIChwYXRoRGF0YSwgb3B0cywgcmVjdCwgbGF5b3V0KSB7XHJcbiAgICAgICAgdmFyIHBhdGggPSBwYXRoVG9vbC5jcmVhdGVGcm9tU3RyaW5nKHBhdGhEYXRhLCBvcHRzKTtcclxuICAgICAgICBEcmFnZ2FibGUuY2FsbChwYXRoKTtcclxuICAgICAgICB2YXIgYm91bmRpbmdSZWN0ID0gcGF0aC5nZXRCb3VuZGluZ1JlY3QoKTtcclxuICAgICAgICBpZiAocmVjdCkge1xyXG4gICAgICAgICAgICB2YXIgYXNwZWN0ID0gYm91bmRpbmdSZWN0LndpZHRoIC8gYm91bmRpbmdSZWN0LmhlaWdodDtcclxuXHJcbiAgICAgICAgICAgIGlmIChsYXlvdXQgPT09ICdjZW50ZXInKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBTZXQgcmVjdCB0byBjZW50ZXIsIGtlZXAgd2lkdGggLyBoZWlnaHQgcmF0aW8uXHJcbiAgICAgICAgICAgICAgICB2YXIgd2lkdGggPSByZWN0LmhlaWdodCAqIGFzcGVjdDtcclxuICAgICAgICAgICAgICAgIHZhciBoZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICBpZiAod2lkdGggPD0gcmVjdC53aWR0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodCA9IHJlY3QuaGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2lkdGggPSByZWN0LndpZHRoO1xyXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodCA9IHdpZHRoIC8gYXNwZWN0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIGN4ID0gcmVjdC54ICsgcmVjdC53aWR0aCAvIDI7XHJcbiAgICAgICAgICAgICAgICB2YXIgY3kgPSByZWN0LnkgKyByZWN0LmhlaWdodCAvIDI7XHJcblxyXG4gICAgICAgICAgICAgICAgcmVjdC54ID0gY3ggLSB3aWR0aCAvIDI7XHJcbiAgICAgICAgICAgICAgICByZWN0LnkgPSBjeSAtIGhlaWdodCAvIDI7XHJcbiAgICAgICAgICAgICAgICByZWN0LndpZHRoID0gd2lkdGg7XHJcbiAgICAgICAgICAgICAgICByZWN0LmhlaWdodCA9IGhlaWdodDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhpcy5yZXNpemVQYXRoKHBhdGgsIHJlY3QpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgenJVdGlsLmluaGVyaXRzKHBhdGgsIERyYWdnYWJsZSk7XHJcbiAgICAgICAgcmV0dXJuIHBhdGg7XHJcbiAgICB9O1xyXG5cclxuICAgIGdyYXBoaWMubWVyZ2VQYXRoID0gcGF0aFRvb2wubWVyZ2VQYXRoO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVzaXplIGEgcGF0aCB0byBmaXQgdGhlIHJlY3RcclxuICAgICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvZ3JhcGhpYy9QYXRofSBwYXRoXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcmVjdFxyXG4gICAgICovXHJcbiAgICBncmFwaGljLnJlc2l6ZVBhdGggPSBmdW5jdGlvbiAocGF0aCwgcmVjdCkge1xyXG4gICAgICAgIGlmICghcGF0aC5hcHBseVRyYW5zZm9ybSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgcGF0aFJlY3QgPSBwYXRoLmdldEJvdW5kaW5nUmVjdCgpO1xyXG5cclxuICAgICAgICB2YXIgbSA9IHBhdGhSZWN0LmNhbGN1bGF0ZVRyYW5zZm9ybShyZWN0KTtcclxuXHJcbiAgICAgICAgcGF0aC5hcHBseVRyYW5zZm9ybShtKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTdWIgcGl4ZWwgb3B0aW1pemUgbGluZSBmb3IgY2FudmFzXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3BhcmFtLnNoYXBlXVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtwYXJhbS5zaGFwZS54MV1cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcGFyYW0uc2hhcGUueTFdXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3BhcmFtLnNoYXBlLngyXVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtwYXJhbS5zaGFwZS55Ml1cclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbcGFyYW0uc3R5bGVdXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3BhcmFtLnN0eWxlLmxpbmVXaWR0aF1cclxuICAgICAqIEByZXR1cm4ge09iamVjdH0gTW9kaWZpZWQgcGFyYW1cclxuICAgICAqL1xyXG4gICAgZ3JhcGhpYy5zdWJQaXhlbE9wdGltaXplTGluZSA9IGZ1bmN0aW9uIChwYXJhbSkge1xyXG4gICAgICAgIHZhciBzdWJQaXhlbE9wdGltaXplID0gZ3JhcGhpYy5zdWJQaXhlbE9wdGltaXplO1xyXG4gICAgICAgIHZhciBzaGFwZSA9IHBhcmFtLnNoYXBlO1xyXG4gICAgICAgIHZhciBsaW5lV2lkdGggPSBwYXJhbS5zdHlsZS5saW5lV2lkdGg7XHJcblxyXG4gICAgICAgIGlmIChyb3VuZChzaGFwZS54MSAqIDIpID09PSByb3VuZChzaGFwZS54MiAqIDIpKSB7XHJcbiAgICAgICAgICAgIHNoYXBlLngxID0gc2hhcGUueDIgPSBzdWJQaXhlbE9wdGltaXplKHNoYXBlLngxLCBsaW5lV2lkdGgsIHRydWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocm91bmQoc2hhcGUueTEgKiAyKSA9PT0gcm91bmQoc2hhcGUueTIgKiAyKSkge1xyXG4gICAgICAgICAgICBzaGFwZS55MSA9IHNoYXBlLnkyID0gc3ViUGl4ZWxPcHRpbWl6ZShzaGFwZS55MSwgbGluZVdpZHRoLCB0cnVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHBhcmFtO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFN1YiBwaXhlbCBvcHRpbWl6ZSByZWN0IGZvciBjYW52YXNcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1cclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbcGFyYW0uc2hhcGVdXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3BhcmFtLnNoYXBlLnhdXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3BhcmFtLnNoYXBlLnldXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3BhcmFtLnNoYXBlLndpZHRoXVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtwYXJhbS5zaGFwZS5oZWlnaHRdXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3BhcmFtLnN0eWxlXVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtwYXJhbS5zdHlsZS5saW5lV2lkdGhdXHJcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IE1vZGlmaWVkIHBhcmFtXHJcbiAgICAgKi9cclxuICAgIGdyYXBoaWMuc3ViUGl4ZWxPcHRpbWl6ZVJlY3QgPSBmdW5jdGlvbiAocGFyYW0pIHtcclxuICAgICAgICB2YXIgc3ViUGl4ZWxPcHRpbWl6ZSA9IGdyYXBoaWMuc3ViUGl4ZWxPcHRpbWl6ZTtcclxuICAgICAgICB2YXIgc2hhcGUgPSBwYXJhbS5zaGFwZTtcclxuICAgICAgICB2YXIgbGluZVdpZHRoID0gcGFyYW0uc3R5bGUubGluZVdpZHRoO1xyXG4gICAgICAgIHZhciBvcmlnaW5YID0gc2hhcGUueDtcclxuICAgICAgICB2YXIgb3JpZ2luWSA9IHNoYXBlLnk7XHJcbiAgICAgICAgdmFyIG9yaWdpbldpZHRoID0gc2hhcGUud2lkdGg7XHJcbiAgICAgICAgdmFyIG9yaWdpbkhlaWdodCA9IHNoYXBlLmhlaWdodDtcclxuICAgICAgICBzaGFwZS54ID0gc3ViUGl4ZWxPcHRpbWl6ZShzaGFwZS54LCBsaW5lV2lkdGgsIHRydWUpO1xyXG4gICAgICAgIHNoYXBlLnkgPSBzdWJQaXhlbE9wdGltaXplKHNoYXBlLnksIGxpbmVXaWR0aCwgdHJ1ZSk7XHJcbiAgICAgICAgc2hhcGUud2lkdGggPSBNYXRoLm1heChcclxuICAgICAgICAgICAgc3ViUGl4ZWxPcHRpbWl6ZShvcmlnaW5YICsgb3JpZ2luV2lkdGgsIGxpbmVXaWR0aCwgZmFsc2UpIC0gc2hhcGUueCxcclxuICAgICAgICAgICAgb3JpZ2luV2lkdGggPT09IDAgPyAwIDogMVxyXG4gICAgICAgICk7XHJcbiAgICAgICAgc2hhcGUuaGVpZ2h0ID0gTWF0aC5tYXgoXHJcbiAgICAgICAgICAgIHN1YlBpeGVsT3B0aW1pemUob3JpZ2luWSArIG9yaWdpbkhlaWdodCwgbGluZVdpZHRoLCBmYWxzZSkgLSBzaGFwZS55LFxyXG4gICAgICAgICAgICBvcmlnaW5IZWlnaHQgPT09IDAgPyAwIDogMVxyXG4gICAgICAgICk7XHJcbiAgICAgICAgcmV0dXJuIHBhcmFtO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFN1YiBwaXhlbCBvcHRpbWl6ZSBmb3IgY2FudmFzXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBvc2l0aW9uIENvb3JkaW5hdGUsIHN1Y2ggYXMgeCwgeVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxpbmVXaWR0aCBTaG91bGQgYmUgbm9ubmVnYXRpdmUgaW50ZWdlci5cclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IHBvc2l0aXZlT3JOZWdhdGl2ZSBEZWZhdWx0IGZhbHNlIChuZWdhdGl2ZSkuXHJcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IE9wdGltaXplZCBwb3NpdGlvbi5cclxuICAgICAqL1xyXG4gICAgZ3JhcGhpYy5zdWJQaXhlbE9wdGltaXplID0gZnVuY3Rpb24gKHBvc2l0aW9uLCBsaW5lV2lkdGgsIHBvc2l0aXZlT3JOZWdhdGl2ZSkge1xyXG4gICAgICAgIC8vIEFzc3VyZSB0aGF0IChwb3NpdGlvbiArIGxpbmVXaWR0aCAvIDIpIGlzIG5lYXIgaW50ZWdlciBlZGdlLFxyXG4gICAgICAgIC8vIG90aGVyd2lzZSBsaW5lIHdpbGwgYmUgZnV6enkgaW4gY2FudmFzLlxyXG4gICAgICAgIHZhciBkb3VibGVkUG9zaXRpb24gPSByb3VuZChwb3NpdGlvbiAqIDIpO1xyXG4gICAgICAgIHJldHVybiAoZG91YmxlZFBvc2l0aW9uICsgcm91bmQobGluZVdpZHRoKSkgJSAyID09PSAwXHJcbiAgICAgICAgICAgID8gZG91YmxlZFBvc2l0aW9uIC8gMlxyXG4gICAgICAgICAgICA6IChkb3VibGVkUG9zaXRpb24gKyAocG9zaXRpdmVPck5lZ2F0aXZlID8gMSA6IC0xKSkgLyAyO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGRvU2luZ2xlRW50ZXJIb3ZlcihlbCkge1xyXG4gICAgICAgIGlmIChlbC5fX2lzSG92ZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZWwuX19ob3ZlclN0bERpcnR5KSB7XHJcbiAgICAgICAgICAgIHZhciBzdHJva2UgPSBlbC5zdHlsZS5zdHJva2U7XHJcbiAgICAgICAgICAgIHZhciBmaWxsID0gZWwuc3R5bGUuZmlsbDtcclxuXHJcbiAgICAgICAgICAgIC8vIENyZWF0ZSBob3ZlclN0eWxlIG9uIG1vdXNlb3ZlclxyXG4gICAgICAgICAgICB2YXIgaG92ZXJTdHlsZSA9IGVsLl9faG92ZXJTdGw7XHJcbiAgICAgICAgICAgIHZhciBsaWZ0ID0gY29sb3JUb29sLmxpZnQ7XHJcbiAgICAgICAgICAgIGhvdmVyU3R5bGUuZmlsbCA9IGhvdmVyU3R5bGUuZmlsbFxyXG4gICAgICAgICAgICAgICAgfHwgKGZpbGwgJiYgKGZpbGwgaW5zdGFuY2VvZiBHcmFkaWVudCA/IGZpbGwgOiBsaWZ0KGZpbGwsIC0wLjEpKSk7XHJcbiAgICAgICAgICAgIGhvdmVyU3R5bGUuc3Ryb2tlID0gaG92ZXJTdHlsZS5zdHJva2VcclxuICAgICAgICAgICAgICAgIHx8IChzdHJva2UgJiYgKHN0cm9rZSBpbnN0YW5jZW9mIEdyYWRpZW50ID8gc3Ryb2tlIDogbGlmdChzdHJva2UsIC0wLjEpKSk7XHJcblxyXG4gICAgICAgICAgICB2YXIgbm9ybWFsU3R5bGUgPSB7fTtcclxuICAgICAgICAgICAgZm9yICh2YXIgbmFtZSBpbiBob3ZlclN0eWxlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaG92ZXJTdHlsZS5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5vcm1hbFN0eWxlW25hbWVdID0gZWwuc3R5bGVbbmFtZV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGVsLl9fbm9ybWFsU3RsID0gbm9ybWFsU3R5bGU7XHJcblxyXG4gICAgICAgICAgICBlbC5fX2hvdmVyU3RsRGlydHkgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWwuc2V0U3R5bGUoZWwuX19ob3ZlclN0bCk7XHJcbiAgICAgICAgZWwuejIgKz0gMTtcclxuXHJcbiAgICAgICAgZWwuX19pc0hvdmVyID0gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBpbm5lclxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBkb1NpbmdsZUxlYXZlSG92ZXIoZWwpIHtcclxuICAgICAgICBpZiAoIWVsLl9faXNIb3Zlcikge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgbm9ybWFsU3RsID0gZWwuX19ub3JtYWxTdGw7XHJcbiAgICAgICAgbm9ybWFsU3RsICYmIGVsLnNldFN0eWxlKG5vcm1hbFN0bCk7XHJcbiAgICAgICAgZWwuejIgLT0gMTtcclxuXHJcbiAgICAgICAgZWwuX19pc0hvdmVyID0gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAaW5uZXJcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZG9FbnRlckhvdmVyKGVsKSB7XHJcbiAgICAgICAgZWwudHlwZSA9PT0gJ2dyb3VwJ1xyXG4gICAgICAgICAgICA/IGVsLnRyYXZlcnNlKGZ1bmN0aW9uIChjaGlsZCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkLnR5cGUgIT09ICdncm91cCcpIHtcclxuICAgICAgICAgICAgICAgICAgICBkb1NpbmdsZUVudGVySG92ZXIoY2hpbGQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICA6IGRvU2luZ2xlRW50ZXJIb3ZlcihlbCk7XHJcbiAgICB9XHJcbiAgICBncmFwaGljLmRvRW50ZXJIb3ZlciA9IGRvRW50ZXJIb3ZlcjtcclxuICAgIGZ1bmN0aW9uIGRvTGVhdmVIb3ZlcihlbCkge1xyXG4gICAgICAgIGVsLnR5cGUgPT09ICdncm91cCdcclxuICAgICAgICAgICAgPyBlbC50cmF2ZXJzZShmdW5jdGlvbiAoY2hpbGQpIHtcclxuICAgICAgICAgICAgICAgIGlmIChjaGlsZC50eXBlICE9PSAnZ3JvdXAnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZG9TaW5nbGVMZWF2ZUhvdmVyKGNoaWxkKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgOiBkb1NpbmdsZUxlYXZlSG92ZXIoZWwpO1xyXG4gICAgfVxyXG4gICAgZ3JhcGhpYy5kb0xlYXZlSG92ZXIgPSBkb0xlYXZlSG92ZXI7XHJcbiAgICAvKipcclxuICAgICAqIEBpbm5lclxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBzZXRFbGVtZW50SG92ZXJTdGwoZWwsIGhvdmVyU3RsKSB7XHJcbiAgICAgICAgLy8gSWYgZWxlbWVudCBoYXMgc2VwY2lmaWVkIGhvdmVyU3R5bGUsIHRoZW4gdXNlIGl0IGluc3RlYWQgb2YgZ2l2ZW4gaG92ZXJTdHlsZVxyXG4gICAgICAgIC8vIE9mdGVuIHVzZWQgd2hlbiBpdGVtIGdyb3VwIGhhcyBhIGxhYmVsIGVsZW1lbnQgYW5kIGl0J3MgaG92ZXJTdHlsZSBpcyBkaWZmZXJlbnRcclxuICAgICAgICBlbC5fX2hvdmVyU3RsID0gZWwuaG92ZXJTdHlsZSB8fCBob3ZlclN0bCB8fCB7fTtcclxuICAgICAgICBlbC5fX2hvdmVyU3RsRGlydHkgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgZ3JhcGhpYy5zZXRFbGVtZW50SG92ZXJTdGwgPSBzZXRFbGVtZW50SG92ZXJTdGw7XHJcbiAgICAvKipcclxuICAgICAqIEBpbm5lclxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBvbkVsZW1lbnRNb3VzZU92ZXIoKSB7XHJcbiAgICAgICAgLy8gT25seSBpZiBlbGVtZW50IGlzIG5vdCBpbiBlbXBoYXNpcyBzdGF0dXNcclxuICAgICAgICAhdGhpcy5fX2lzRW1waGFzaXMgJiYgZG9FbnRlckhvdmVyKHRoaXMpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGlubmVyXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIG9uRWxlbWVudE1vdXNlT3V0KCkge1xyXG4gICAgICAgIC8vIE9ubHkgaWYgZWxlbWVudCBpcyBub3QgaW4gZW1waGFzaXMgc3RhdHVzXHJcbiAgICAgICAgIXRoaXMuX19pc0VtcGhhc2lzICYmIGRvTGVhdmVIb3Zlcih0aGlzKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBpbm5lclxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBlbnRlckVtcGhhc2lzKCkge1xyXG4gICAgICAgIHRoaXMuX19pc0VtcGhhc2lzID0gdHJ1ZTtcclxuICAgICAgICBkb0VudGVySG92ZXIodGhpcyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAaW5uZXJcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gbGVhdmVFbXBoYXNpcygpIHtcclxuICAgICAgICB0aGlzLl9faXNFbXBoYXNpcyA9IGZhbHNlO1xyXG4gICAgICAgIGRvTGVhdmVIb3Zlcih0aGlzKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCBob3ZlciBzdHlsZSBvZiBlbGVtZW50XHJcbiAgICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL0VsZW1lbnR9IGVsXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2hvdmVyU3R5bGVdXHJcbiAgICAgKi9cclxuICAgIGdyYXBoaWMuc2V0SG92ZXJTdHlsZSA9IGZ1bmN0aW9uIChlbCwgaG92ZXJTdHlsZSkge1xyXG4gICAgICAgIGVsLnR5cGUgPT09ICdncm91cCdcclxuICAgICAgICAgICAgPyBlbC50cmF2ZXJzZShmdW5jdGlvbiAoY2hpbGQpIHtcclxuICAgICAgICAgICAgICAgIGlmIChjaGlsZC50eXBlICE9PSAnZ3JvdXAnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0RWxlbWVudEhvdmVyU3RsKGNoaWxkLCBob3ZlclN0eWxlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgOiBzZXRFbGVtZW50SG92ZXJTdGwoZWwsIGhvdmVyU3R5bGUpO1xyXG4gICAgICAgIC8vIFJlbW92ZSBwcmV2aW91cyBib3VuZCBoYW5kbGVyc1xyXG4gICAgICAgIGVsLm9uKCdtb3VzZW92ZXInLCBvbkVsZW1lbnRNb3VzZU92ZXIpXHJcbiAgICAgICAgICAub24oJ21vdXNlb3V0Jywgb25FbGVtZW50TW91c2VPdXQpO1xyXG5cclxuICAgICAgICAvLyBFbXBoYXNpcywgbm9ybWFsIGNhbiBiZSB0cmlnZ2VyZWQgbWFudWFsbHlcclxuICAgICAgICBlbC5vbignZW1waGFzaXMnLCBlbnRlckVtcGhhc2lzKVxyXG4gICAgICAgICAgLm9uKCdub3JtYWwnLCBsZWF2ZUVtcGhhc2lzKTtcclxuICAgIH07XHJcblxyXG4gICAgZ3JhcGhpYy5zZXROb3JtYWxTdHlsZSA9IGZ1bmN0aW9uKGVsLCBvcHRpb25zKSB7XHJcbiAgICAgICAgaWYgKGVsLl9fbm9ybWFsU3RsKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIG5hbWUgaW4gb3B0aW9ucykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGVsLl9fbm9ybWFsU3RsLmhhc093blByb3BlcnR5KG5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZWwuX19ub3JtYWxTdGxbbmFtZV0gPSBvcHRpb25zW25hbWVdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCB0ZXh0IG9wdGlvbiBpbiB0aGUgc3R5bGVcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0ZXh0U3R5bGVcclxuICAgICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvbW9kZWwvTW9kZWx9IGxhYmVsTW9kZWxcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb2xvclxyXG4gICAgICovXHJcbiAgICBncmFwaGljLnNldFRleHQgPSBmdW5jdGlvbiAodGV4dFN0eWxlLCBsYWJlbE1vZGVsLCBjb2xvcikge1xyXG4gICAgICAgIHZhciBsYWJlbFBvc2l0aW9uID0gbGFiZWxNb2RlbC5nZXRTaGFsbG93KCdwb3NpdGlvbicpIHx8ICdpbnNpZGUnO1xyXG4gICAgICAgIHZhciBsYWJlbENvbG9yID0gbGFiZWxQb3NpdGlvbi5pbmRleE9mKCdpbnNpZGUnKSA+PSAwID8gJ3doaXRlJyA6IGNvbG9yO1xyXG4gICAgICAgIHZhciB0ZXh0U3R5bGVNb2RlbCA9IGxhYmVsTW9kZWwuZ2V0TW9kZWwoJ3RleHRTdHlsZScpO1xyXG4gICAgICAgIHpyVXRpbC5leHRlbmQodGV4dFN0eWxlLCB7XHJcbiAgICAgICAgICAgIHRleHREaXN0YW5jZTogbGFiZWxNb2RlbC5nZXRTaGFsbG93KCdkaXN0YW5jZScpIHx8IDUsXHJcbiAgICAgICAgICAgIHRleHRGb250OiB0ZXh0U3R5bGVNb2RlbC5nZXRGb250KCksXHJcbiAgICAgICAgICAgIHRleHRQb3NpdGlvbjogbGFiZWxQb3NpdGlvbixcclxuICAgICAgICAgICAgdGV4dEZpbGw6IHRleHRTdHlsZU1vZGVsLmdldFRleHRDb2xvcigpIHx8IGxhYmVsQ29sb3JcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgZnVuY3Rpb24gYW5pbWF0ZU9yU2V0UHJvcHMoaXNVcGRhdGUsIGVsLCBwcm9wcywgYW5pbWF0YWJsZU1vZGVsLCBjYikge1xyXG4gICAgICAgIHZhciBwb3N0Zml4ID0gaXNVcGRhdGUgPyAnVXBkYXRlJyA6ICcnO1xyXG4gICAgICAgIHZhciBkdXJhdGlvbiA9IGFuaW1hdGFibGVNb2RlbFxyXG4gICAgICAgICAgICAmJiBhbmltYXRhYmxlTW9kZWwuZ2V0U2hhbGxvdygnYW5pbWF0aW9uRHVyYXRpb24nICsgcG9zdGZpeCk7XHJcbiAgICAgICAgdmFyIGFuaW1hdGlvbkVhc2luZyA9IGFuaW1hdGFibGVNb2RlbFxyXG4gICAgICAgICAgICAmJiBhbmltYXRhYmxlTW9kZWwuZ2V0U2hhbGxvdygnYW5pbWF0aW9uRWFzaW5nJyArIHBvc3RmaXgpO1xyXG5cclxuICAgICAgICBhbmltYXRhYmxlTW9kZWwgJiYgYW5pbWF0YWJsZU1vZGVsLmdldFNoYWxsb3coJ2FuaW1hdGlvbicpXHJcbiAgICAgICAgICAgID8gZWwuYW5pbWF0ZVRvKHByb3BzLCBkdXJhdGlvbiwgYW5pbWF0aW9uRWFzaW5nLCBjYilcclxuICAgICAgICAgICAgOiAoZWwuYXR0cihwcm9wcyksIGNiICYmIGNiKCkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGUgZ3JhcGhpYyBlbGVtZW50IHByb3BlcnRpZXMgd2l0aCBvciB3aXRob3V0IGFuaW1hdGlvbiBhY2NvcmRpbmcgdG8gdGhlIGNvbmZpZ3VyYXRpb24gaW4gc2VyaWVzXHJcbiAgICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL0VsZW1lbnR9IGVsXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJvcHNcclxuICAgICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvbW9kZWwvTW9kZWx9IFthbmltYXRhYmxlTW9kZWxdXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYlxyXG4gICAgICovXHJcbiAgICBncmFwaGljLnVwZGF0ZVByb3BzID0genJVdGlsLmN1cnJ5KGFuaW1hdGVPclNldFByb3BzLCB0cnVlKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEluaXQgZ3JhcGhpYyBlbGVtZW50IHByb3BlcnRpZXMgd2l0aCBvciB3aXRob3V0IGFuaW1hdGlvbiBhY2NvcmRpbmcgdG8gdGhlIGNvbmZpZ3VyYXRpb24gaW4gc2VyaWVzXHJcbiAgICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL0VsZW1lbnR9IGVsXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJvcHNcclxuICAgICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvbW9kZWwvTW9kZWx9IFthbmltYXRhYmxlTW9kZWxdXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYlxyXG4gICAgICovXHJcbiAgICBncmFwaGljLmluaXRQcm9wcyA9IHpyVXRpbC5jdXJyeShhbmltYXRlT3JTZXRQcm9wcywgZmFsc2UpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRyYW5zZm9ybSBtYXRyaXggb2YgdGFyZ2V0IChwYXJhbSB0YXJnZXQpLFxyXG4gICAgICogaW4gY29vcmRpbmF0ZSBvZiBpdHMgYW5jZXN0b3IgKHBhcmFtIGFuY2VzdG9yKVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvbWl4aW4vVHJhbnNmb3JtYWJsZX0gdGFyZ2V0XHJcbiAgICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL21peGluL1RyYW5zZm9ybWFibGV9IGFuY2VzdG9yXHJcbiAgICAgKi9cclxuICAgIGdyYXBoaWMuZ2V0VHJhbnNmb3JtID0gZnVuY3Rpb24gKHRhcmdldCwgYW5jZXN0b3IpIHtcclxuICAgICAgICB2YXIgbWF0ID0gbWF0cml4LmlkZW50aXR5KFtdKTtcclxuXHJcbiAgICAgICAgd2hpbGUgKHRhcmdldCAmJiB0YXJnZXQgIT09IGFuY2VzdG9yKSB7XHJcbiAgICAgICAgICAgIG1hdHJpeC5tdWwobWF0LCB0YXJnZXQuZ2V0TG9jYWxUcmFuc2Zvcm0oKSwgbWF0KTtcclxuICAgICAgICAgICAgdGFyZ2V0ID0gdGFyZ2V0LnBhcmVudDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBtYXQ7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQXBwbHkgdHJhbnNmb3JtIHRvIGFuIHZlcnRleC5cclxuICAgICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IHZlcnRleCBbeCwgeV1cclxuICAgICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IHRyYW5zZm9ybSBUcmFuc2Zvcm0gbWF0cml4OiBsaWtlIFsxLCAwLCAwLCAxLCAwLCAwXVxyXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gaW52ZXJ0IFdoZXRoZXIgdXNlIGludmVydCBtYXRyaXguXHJcbiAgICAgKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn0gW3gsIHldXHJcbiAgICAgKi9cclxuICAgIGdyYXBoaWMuYXBwbHlUcmFuc2Zvcm0gPSBmdW5jdGlvbiAodmVydGV4LCB0cmFuc2Zvcm0sIGludmVydCkge1xyXG4gICAgICAgIGlmIChpbnZlcnQpIHtcclxuICAgICAgICAgICAgdHJhbnNmb3JtID0gbWF0cml4LmludmVydChbXSwgdHJhbnNmb3JtKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHZlY3Rvci5hcHBseVRyYW5zZm9ybShbXSwgdmVydGV4LCB0cmFuc2Zvcm0pO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBkaXJlY3Rpb24gJ2xlZnQnICdyaWdodCcgJ3RvcCcgJ2JvdHRvbSdcclxuICAgICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IHRyYW5zZm9ybSBUcmFuc2Zvcm0gbWF0cml4OiBsaWtlIFsxLCAwLCAwLCAxLCAwLCAwXVxyXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gaW52ZXJ0IFdoZXRoZXIgdXNlIGludmVydCBtYXRyaXguXHJcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRyYW5zZm9ybWVkIGRpcmVjdGlvbi4gJ2xlZnQnICdyaWdodCcgJ3RvcCcgJ2JvdHRvbSdcclxuICAgICAqL1xyXG4gICAgZ3JhcGhpYy50cmFuc2Zvcm1EaXJlY3Rpb24gPSBmdW5jdGlvbiAoZGlyZWN0aW9uLCB0cmFuc2Zvcm0sIGludmVydCkge1xyXG5cclxuICAgICAgICAvLyBQaWNrIGEgYmFzZSwgZW5zdXJlIHRoYXQgdHJhbnNmb3JtIHJlc3VsdCB3aWxsIG5vdCBiZSAoMCwgMCkuXHJcbiAgICAgICAgdmFyIGhCYXNlID0gKHRyYW5zZm9ybVs0XSA9PT0gMCB8fCB0cmFuc2Zvcm1bNV0gPT09IDAgfHwgdHJhbnNmb3JtWzBdID09PSAwKVxyXG4gICAgICAgICAgICA/IDEgOiBNYXRoLmFicygyICogdHJhbnNmb3JtWzRdIC8gdHJhbnNmb3JtWzBdKTtcclxuICAgICAgICB2YXIgdkJhc2UgPSAodHJhbnNmb3JtWzRdID09PSAwIHx8IHRyYW5zZm9ybVs1XSA9PT0gMCB8fCB0cmFuc2Zvcm1bMl0gPT09IDApXHJcbiAgICAgICAgICAgID8gMSA6IE1hdGguYWJzKDIgKiB0cmFuc2Zvcm1bNF0gLyB0cmFuc2Zvcm1bMl0pO1xyXG5cclxuICAgICAgICB2YXIgdmVydGV4ID0gW1xyXG4gICAgICAgICAgICBkaXJlY3Rpb24gPT09ICdsZWZ0JyA/IC1oQmFzZSA6IGRpcmVjdGlvbiA9PT0gJ3JpZ2h0JyA/IGhCYXNlIDogMCxcclxuICAgICAgICAgICAgZGlyZWN0aW9uID09PSAndG9wJyA/IC12QmFzZSA6IGRpcmVjdGlvbiA9PT0gJ2JvdHRvbScgPyB2QmFzZSA6IDBcclxuICAgICAgICBdO1xyXG5cclxuICAgICAgICB2ZXJ0ZXggPSBncmFwaGljLmFwcGx5VHJhbnNmb3JtKHZlcnRleCwgdHJhbnNmb3JtLCBpbnZlcnQpO1xyXG5cclxuICAgICAgICByZXR1cm4gTWF0aC5hYnModmVydGV4WzBdKSA+IE1hdGguYWJzKHZlcnRleFsxXSlcclxuICAgICAgICAgICAgPyAodmVydGV4WzBdID4gMCA/ICdyaWdodCcgOiAnbGVmdCcpXHJcbiAgICAgICAgICAgIDogKHZlcnRleFsxXSA+IDAgPyAnYm90dG9tJyA6ICd0b3AnKTtcclxuICAgIH07XHJcblxyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBncmFwaGljO1xyXG5cclxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2xpYi9maXNoLXRvcG8tY29yZS9saWIvZ3JhcGhpYy5qc1xuICoqIG1vZHVsZSBpZCA9IDNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQG1vZHVsZSB6cmVuZGVyL2NvcmUvdXRpbFxuICovXG5cblxuICAgIC8vIOeUqOS6juWkhOeQhm1lcmdl5pe25peg5rOV6YGN5Y6GRGF0ZeetieWvueixoeeahOmXrumimFxuICAgIHZhciBCVUlMVElOX09CSkVDVCA9IHtcbiAgICAgICAgJ1tvYmplY3QgRnVuY3Rpb25dJzogMSxcbiAgICAgICAgJ1tvYmplY3QgUmVnRXhwXSc6IDEsXG4gICAgICAgICdbb2JqZWN0IERhdGVdJzogMSxcbiAgICAgICAgJ1tvYmplY3QgRXJyb3JdJzogMSxcbiAgICAgICAgJ1tvYmplY3QgQ2FudmFzR3JhZGllbnRdJzogMSxcbiAgICAgICAgJ1tvYmplY3QgQ2FudmFzUGF0dGVybl0nOiAxLFxuICAgICAgICAvLyBJbiBub2RlLWNhbnZhcyBJbWFnZSBjYW4gYmUgQ2FudmFzLkltYWdlXG4gICAgICAgICdbb2JqZWN0IEltYWdlXSc6IDFcbiAgICB9O1xuXG4gICAgdmFyIG9ialRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuICAgIHZhciBhcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlO1xuICAgIHZhciBuYXRpdmVGb3JFYWNoID0gYXJyYXlQcm90by5mb3JFYWNoO1xuICAgIHZhciBuYXRpdmVGaWx0ZXIgPSBhcnJheVByb3RvLmZpbHRlcjtcbiAgICB2YXIgbmF0aXZlU2xpY2UgPSBhcnJheVByb3RvLnNsaWNlO1xuICAgIHZhciBuYXRpdmVNYXAgPSBhcnJheVByb3RvLm1hcDtcbiAgICB2YXIgbmF0aXZlUmVkdWNlID0gYXJyYXlQcm90by5yZWR1Y2U7XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyp9IHNvdXJjZVxuICAgICAqIEByZXR1cm4geyp9IOaLt+i0neWQjueahOaWsOWvueixoVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNsb25lKHNvdXJjZSkge1xuICAgICAgICBpZiAodHlwZW9mIHNvdXJjZSA9PSAnb2JqZWN0JyAmJiBzb3VyY2UgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBzb3VyY2U7XG4gICAgICAgICAgICBpZiAoc291cmNlIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gc291cmNlLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtpXSA9IGNsb25lKHNvdXJjZVtpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoXG4gICAgICAgICAgICAgICAgIWlzQnVpbGRJbk9iamVjdChzb3VyY2UpXG4gICAgICAgICAgICAgICAgLy8g5piv5ZCm5Li6IGRvbSDlr7nosaFcbiAgICAgICAgICAgICAgICAmJiAhaXNEb20oc291cmNlKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0ge307XG4gICAgICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc291cmNlLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFtrZXldID0gY2xvbmUoc291cmNlW2tleV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHNvdXJjZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gICAgICogQHBhcmFtIHsqfSB0YXJnZXRcbiAgICAgKiBAcGFyYW0geyp9IHNvdXJjZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW292ZXJ3cml0ZT1mYWxzZV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtZXJnZSh0YXJnZXQsIHNvdXJjZSwgb3ZlcndyaXRlKSB7XG4gICAgICAgIC8vIFdlIHNob3VsZCBlc2NhcHNlIHRoYXQgc291cmNlIGlzIHN0cmluZ1xuICAgICAgICAvLyBhbmQgZW50ZXIgZm9yIC4uLiBpbiAuLi5cbiAgICAgICAgaWYgKCFpc09iamVjdChzb3VyY2UpIHx8ICFpc09iamVjdCh0YXJnZXQpKSB7XG4gICAgICAgICAgICByZXR1cm4gb3ZlcndyaXRlID8gY2xvbmUoc291cmNlKSA6IHRhcmdldDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgICAgIGlmIChzb3VyY2UuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgIHZhciB0YXJnZXRQcm9wID0gdGFyZ2V0W2tleV07XG4gICAgICAgICAgICAgICAgdmFyIHNvdXJjZVByb3AgPSBzb3VyY2Vba2V5XTtcblxuICAgICAgICAgICAgICAgIGlmIChpc09iamVjdChzb3VyY2VQcm9wKVxuICAgICAgICAgICAgICAgICAgICAmJiBpc09iamVjdCh0YXJnZXRQcm9wKVxuICAgICAgICAgICAgICAgICAgICAmJiAhaXNBcnJheShzb3VyY2VQcm9wKVxuICAgICAgICAgICAgICAgICAgICAmJiAhaXNBcnJheSh0YXJnZXRQcm9wKVxuICAgICAgICAgICAgICAgICAgICAmJiAhaXNEb20oc291cmNlUHJvcClcbiAgICAgICAgICAgICAgICAgICAgJiYgIWlzRG9tKHRhcmdldFByb3ApXG4gICAgICAgICAgICAgICAgICAgICYmICFpc0J1aWxkSW5PYmplY3Qoc291cmNlUHJvcClcbiAgICAgICAgICAgICAgICAgICAgJiYgIWlzQnVpbGRJbk9iamVjdCh0YXJnZXRQcm9wKVxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAvLyDlpoLmnpzpnIDopoHpgJLlvZLopobnm5bvvIzlsLHpgJLlvZLosIPnlKhtZXJnZVxuICAgICAgICAgICAgICAgICAgICBtZXJnZSh0YXJnZXRQcm9wLCBzb3VyY2VQcm9wLCBvdmVyd3JpdGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChvdmVyd3JpdGUgfHwgIShrZXkgaW4gdGFyZ2V0KSkge1xuICAgICAgICAgICAgICAgICAgICAvLyDlkKbliJnlj6rlpITnkIZvdmVyd3JpdGXkuLp0cnVl77yM5oiW6ICF5Zyo55uu5qCH5a+56LGh5Lit5rKh5pyJ5q2k5bGe5oCn55qE5oOF5Ya1XG4gICAgICAgICAgICAgICAgICAgIC8vIE5PVEXvvIzlnKggdGFyZ2V0W2tleV0g5LiN5a2Y5Zyo55qE5pe25YCZ5Lmf5piv55u05o6l6KaG55uWXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFtrZXldID0gY2xvbmUoc291cmNlW2tleV0sIHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtBcnJheX0gdGFyZ2V0QW5kU291cmNlcyBUaGUgZmlyc3QgaXRlbSBpcyB0YXJnZXQsIGFuZCB0aGUgcmVzdHMgYXJlIHNvdXJjZS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvdmVyd3JpdGU9ZmFsc2VdXG4gICAgICogQHJldHVybiB7Kn0gdGFyZ2V0XG4gICAgICovXG4gICAgZnVuY3Rpb24gbWVyZ2VBbGwodGFyZ2V0QW5kU291cmNlcywgb3ZlcndyaXRlKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB0YXJnZXRBbmRTb3VyY2VzWzBdO1xuICAgICAgICBmb3IgKHZhciBpID0gMSwgbGVuID0gdGFyZ2V0QW5kU291cmNlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgcmVzdWx0ID0gbWVyZ2UocmVzdWx0LCB0YXJnZXRBbmRTb3VyY2VzW2ldLCBvdmVyd3JpdGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHsqfSB0YXJnZXRcbiAgICAgKiBAcGFyYW0geyp9IHNvdXJjZVxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL3V0aWxcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBleHRlbmQodGFyZ2V0LCBzb3VyY2UpIHtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICAgICAgaWYgKHNvdXJjZS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Kn0gdGFyZ2V0XG4gICAgICogQHBhcmFtIHsqfSBzb3VyY2VcbiAgICAgKiBAcGFyYW0ge2Jvb2xlbn0gW292ZXJsYXk9ZmFsc2VdXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRlZmF1bHRzKHRhcmdldCwgc291cmNlLCBvdmVybGF5KSB7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgICAgIGlmIChzb3VyY2UuaGFzT3duUHJvcGVydHkoa2V5KVxuICAgICAgICAgICAgICAgICYmIChvdmVybGF5ID8gc291cmNlW2tleV0gIT0gbnVsbCA6IHRhcmdldFtrZXldID09IG51bGwpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlQ2FudmFzKCkge1xuICAgICAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgfVxuICAgIC8vIEZJWE1FXG4gICAgdmFyIF9jdHg7XG4gICAgZnVuY3Rpb24gZ2V0Q29udGV4dCgpIHtcbiAgICAgICAgaWYgKCFfY3R4KSB7XG4gICAgICAgICAgICAvLyBVc2UgdXRpbC5jcmVhdGVDYW52YXMgaW5zdGVhZCBvZiBjcmVhdGVDYW52YXNcbiAgICAgICAgICAgIC8vIGJlY2F1c2UgY3JlYXRlQ2FudmFzIG1heSBiZSBvdmVyd3JpdHRlbiBpbiBkaWZmZXJlbnQgZW52aXJvbm1lbnRcbiAgICAgICAgICAgIF9jdHggPSB1dGlsLmNyZWF0ZUNhbnZhcygpLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9jdHg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog5p+l6K+i5pWw57uE5Lit5YWD57Sg55qEaW5kZXhcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW5kZXhPZihhcnJheSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKGFycmF5KSB7XG4gICAgICAgICAgICBpZiAoYXJyYXkuaW5kZXhPZikge1xuICAgICAgICAgICAgICAgIHJldHVybiBhcnJheS5pbmRleE9mKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBhcnJheS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChhcnJheVtpXSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDmnoTpgKDnsbvnu6fmib/lhbPns7tcbiAgICAgKlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL3V0aWxcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjbGF6eiDmupDnsbtcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBiYXNlQ2xhenog5Z+657G7XG4gICAgICovXG4gICAgZnVuY3Rpb24gaW5oZXJpdHMoY2xhenosIGJhc2VDbGF6eikge1xuICAgICAgICB2YXIgY2xhenpQcm90b3R5cGUgPSBjbGF6ei5wcm90b3R5cGU7XG4gICAgICAgIGZ1bmN0aW9uIEYoKSB7fVxuICAgICAgICBGLnByb3RvdHlwZSA9IGJhc2VDbGF6ei5wcm90b3R5cGU7XG4gICAgICAgIGNsYXp6LnByb3RvdHlwZSA9IG5ldyBGKCk7XG5cbiAgICAgICAgZm9yICh2YXIgcHJvcCBpbiBjbGF6elByb3RvdHlwZSkge1xuICAgICAgICAgICAgY2xhenoucHJvdG90eXBlW3Byb3BdID0gY2xhenpQcm90b3R5cGVbcHJvcF07XG4gICAgICAgIH1cbiAgICAgICAgY2xhenoucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY2xheno7XG4gICAgICAgIGNsYXp6LnN1cGVyQ2xhc3MgPSBiYXNlQ2xheno7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fEZ1bmN0aW9ufSB0YXJnZXRcbiAgICAgKiBAcGFyYW0ge09iamVjdHxGdW5jdGlvbn0gc29yY2VcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IG92ZXJsYXlcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtaXhpbih0YXJnZXQsIHNvdXJjZSwgb3ZlcmxheSkge1xuICAgICAgICB0YXJnZXQgPSAncHJvdG90eXBlJyBpbiB0YXJnZXQgPyB0YXJnZXQucHJvdG90eXBlIDogdGFyZ2V0O1xuICAgICAgICBzb3VyY2UgPSAncHJvdG90eXBlJyBpbiBzb3VyY2UgPyBzb3VyY2UucHJvdG90eXBlIDogc291cmNlO1xuXG4gICAgICAgIGRlZmF1bHRzKHRhcmdldCwgc291cmNlLCBvdmVybGF5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0FycmF5fFR5cGVkQXJyYXl9IGRhdGFcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0FycmF5TGlrZShkYXRhKSB7XG4gICAgICAgIGlmICghIGRhdGEpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGRhdGEgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHlwZW9mIGRhdGEubGVuZ3RoID09ICdudW1iZXInO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOaVsOe7hOaIluWvueixoemBjeWOhlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL3V0aWxcbiAgICAgKiBAcGFyYW0ge09iamVjdHxBcnJheX0gb2JqXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcbiAgICAgKiBAcGFyYW0geyp9IFtjb250ZXh0XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGVhY2gob2JqLCBjYiwgY29udGV4dCkge1xuICAgICAgICBpZiAoIShvYmogJiYgY2IpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9iai5mb3JFYWNoICYmIG9iai5mb3JFYWNoID09PSBuYXRpdmVGb3JFYWNoKSB7XG4gICAgICAgICAgICBvYmouZm9yRWFjaChjYiwgY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob2JqLmxlbmd0aCA9PT0gK29iai5sZW5ndGgpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBvYmoubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjYi5jYWxsKGNvbnRleHQsIG9ialtpXSwgaSwgb2JqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgICAgICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2IuY2FsbChjb250ZXh0LCBvYmpba2V5XSwga2V5LCBvYmopO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOaVsOe7hOaYoOWwhFxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL3V0aWxcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBvYmpcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYlxuICAgICAqIEBwYXJhbSB7Kn0gW2NvbnRleHRdXG4gICAgICogQHJldHVybiB7QXJyYXl9XG4gICAgICovXG4gICAgZnVuY3Rpb24gbWFwKG9iaiwgY2IsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKCEob2JqICYmIGNiKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvYmoubWFwICYmIG9iai5tYXAgPT09IG5hdGl2ZU1hcCkge1xuICAgICAgICAgICAgcmV0dXJuIG9iai5tYXAoY2IsIGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IG9iai5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGNiLmNhbGwoY29udGV4dCwgb2JqW2ldLCBpLCBvYmopKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gICAgICogQHBhcmFtIHtBcnJheX0gb2JqXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW21lbW9dXG4gICAgICogQHBhcmFtIHsqfSBbY29udGV4dF1cbiAgICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZWR1Y2Uob2JqLCBjYiwgbWVtbywgY29udGV4dCkge1xuICAgICAgICBpZiAoIShvYmogJiYgY2IpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9iai5yZWR1Y2UgJiYgb2JqLnJlZHVjZSA9PT0gbmF0aXZlUmVkdWNlKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqLnJlZHVjZShjYiwgbWVtbywgY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gb2JqLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbWVtbyA9IGNiLmNhbGwoY29udGV4dCwgbWVtbywgb2JqW2ldLCBpLCBvYmopO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1lbW87XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDmlbDnu4Tov4fmu6RcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gICAgICogQHBhcmFtIHtBcnJheX0gb2JqXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcbiAgICAgKiBAcGFyYW0geyp9IFtjb250ZXh0XVxuICAgICAqIEByZXR1cm4ge0FycmF5fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZpbHRlcihvYmosIGNiLCBjb250ZXh0KSB7XG4gICAgICAgIGlmICghKG9iaiAmJiBjYikpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2JqLmZpbHRlciAmJiBvYmouZmlsdGVyID09PSBuYXRpdmVGaWx0ZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBvYmouZmlsdGVyKGNiLCBjb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBvYmoubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoY2IuY2FsbChjb250ZXh0LCBvYmpbaV0sIGksIG9iaikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gob2JqW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog5pWw57uE6aG55p+l5om+XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IG9ialxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiXG4gICAgICogQHBhcmFtIHsqfSBbY29udGV4dF1cbiAgICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaW5kKG9iaiwgY2IsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKCEob2JqICYmIGNiKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBvYmoubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChjYi5jYWxsKGNvbnRleHQsIG9ialtpXSwgaSwgb2JqKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBvYmpbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuY1xuICAgICAqIEBwYXJhbSB7Kn0gY29udGV4dFxuICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJpbmQoZnVuYywgY29udGV4dCkge1xuICAgICAgICB2YXIgYXJncyA9IG5hdGl2ZVNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MuY29uY2F0KG5hdGl2ZVNsaWNlLmNhbGwoYXJndW1lbnRzKSkpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL3V0aWxcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jXG4gICAgICogQHJldHVybiB7RnVuY3Rpb259XG4gICAgICovXG4gICAgZnVuY3Rpb24gY3VycnkoZnVuYykge1xuICAgICAgICB2YXIgYXJncyA9IG5hdGl2ZVNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MuY29uY2F0KG5hdGl2ZVNsaWNlLmNhbGwoYXJndW1lbnRzKSkpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL3V0aWxcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0FycmF5KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBvYmpUb1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL3V0aWxcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1N0cmluZyh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gb2JqVG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09ICdbb2JqZWN0IFN0cmluZ10nO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL3V0aWxcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICAgICAgICAvLyBBdm9pZCBhIFY4IEpJVCBidWcgaW4gQ2hyb21lIDE5LTIwLlxuICAgICAgICAvLyBTZWUgaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTIyOTEgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgICAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gICAgICAgIHJldHVybiB0eXBlID09PSAnZnVuY3Rpb24nIHx8ICghIXZhbHVlICYmIHR5cGUgPT0gJ29iamVjdCcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL3V0aWxcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0J1aWxkSW5PYmplY3QodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuICEhQlVJTFRJTl9PQkpFQ1Rbb2JqVG9TdHJpbmcuY2FsbCh2YWx1ZSldO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL3V0aWxcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0RvbSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgJiYgdmFsdWUubm9kZVR5cGUgPT09IDFcbiAgICAgICAgICAgICAgICYmIHR5cGVvZih2YWx1ZS5ub2RlTmFtZSkgPT0gJ3N0cmluZyc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSWYgdmFsdWUxIGlzIG5vdCBudWxsLCB0aGVuIHJldHVybiB2YWx1ZTEsIG90aGVyd2lzZSBqdWRnZXQgcmVzdCBvZiB2YWx1ZXMuXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICAgICAqIEByZXR1cm4geyp9IEZpbmFsIHZhbHVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmV0cmlldmUodmFsdWVzKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChhcmd1bWVudHNbaV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0SW5kZXhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZW5kSW5kZXhcbiAgICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzbGljZSgpIHtcbiAgICAgICAgcmV0dXJuIEZ1bmN0aW9uLmNhbGwuYXBwbHkobmF0aXZlU2xpY2UsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gY29uZGl0aW9uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhc3NlcnQoY29uZGl0aW9uLCBtZXNzYWdlKSB7XG4gICAgICAgIGlmICghY29uZGl0aW9uKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgdXRpbCA9IHtcbiAgICAgICAgaW5oZXJpdHM6IGluaGVyaXRzLFxuICAgICAgICBtaXhpbjogbWl4aW4sXG4gICAgICAgIGNsb25lOiBjbG9uZSxcbiAgICAgICAgbWVyZ2U6IG1lcmdlLFxuICAgICAgICBtZXJnZUFsbDogbWVyZ2VBbGwsXG4gICAgICAgIGV4dGVuZDogZXh0ZW5kLFxuICAgICAgICBkZWZhdWx0czogZGVmYXVsdHMsXG4gICAgICAgIGdldENvbnRleHQ6IGdldENvbnRleHQsXG4gICAgICAgIGNyZWF0ZUNhbnZhczogY3JlYXRlQ2FudmFzLFxuICAgICAgICBpbmRleE9mOiBpbmRleE9mLFxuICAgICAgICBzbGljZTogc2xpY2UsXG4gICAgICAgIGZpbmQ6IGZpbmQsXG4gICAgICAgIGlzQXJyYXlMaWtlOiBpc0FycmF5TGlrZSxcbiAgICAgICAgZWFjaDogZWFjaCxcbiAgICAgICAgbWFwOiBtYXAsXG4gICAgICAgIHJlZHVjZTogcmVkdWNlLFxuICAgICAgICBmaWx0ZXI6IGZpbHRlcixcbiAgICAgICAgYmluZDogYmluZCxcbiAgICAgICAgY3Vycnk6IGN1cnJ5LFxuICAgICAgICBpc0FycmF5OiBpc0FycmF5LFxuICAgICAgICBpc1N0cmluZzogaXNTdHJpbmcsXG4gICAgICAgIGlzT2JqZWN0OiBpc09iamVjdCxcbiAgICAgICAgaXNGdW5jdGlvbjogaXNGdW5jdGlvbixcbiAgICAgICAgaXNCdWlsZEluT2JqZWN0OiBpc0J1aWxkSW5PYmplY3QsXG4gICAgICAgIGlzRG9tOiBpc0RvbSxcbiAgICAgICAgcmV0cmlldmU6IHJldHJpZXZlLFxuICAgICAgICBhc3NlcnQ6IGFzc2VydCxcbiAgICAgICAgbm9vcDogZnVuY3Rpb24gKCkge31cbiAgICB9O1xuICAgIG1vZHVsZS5leHBvcnRzID0gdXRpbDtcblxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34venJlbmRlci9saWIvY29yZS91dGlsLmpzXG4gKiogbW9kdWxlIGlkID0gNFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXG5cbiAgICB2YXIgUGF0aCA9IHJlcXVpcmUoJy4uL2dyYXBoaWMvUGF0aCcpO1xuICAgIHZhciBQYXRoUHJveHkgPSByZXF1aXJlKCcuLi9jb3JlL1BhdGhQcm94eScpO1xuICAgIHZhciB0cmFuc2Zvcm1QYXRoID0gcmVxdWlyZSgnLi90cmFuc2Zvcm1QYXRoJyk7XG4gICAgdmFyIG1hdHJpeCA9IHJlcXVpcmUoJy4uL2NvcmUvbWF0cml4Jyk7XG5cbiAgICAvLyBjb21tYW5kIGNoYXJzXG4gICAgdmFyIGNjID0gW1xuICAgICAgICAnbScsICdNJywgJ2wnLCAnTCcsICd2JywgJ1YnLCAnaCcsICdIJywgJ3onLCAnWicsXG4gICAgICAgICdjJywgJ0MnLCAncScsICdRJywgJ3QnLCAnVCcsICdzJywgJ1MnLCAnYScsICdBJ1xuICAgIF07XG5cbiAgICB2YXIgbWF0aFNxcnQgPSBNYXRoLnNxcnQ7XG4gICAgdmFyIG1hdGhTaW4gPSBNYXRoLnNpbjtcbiAgICB2YXIgbWF0aENvcyA9IE1hdGguY29zO1xuICAgIHZhciBQSSA9IE1hdGguUEk7XG5cbiAgICB2YXIgdk1hZyA9IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguc3FydCh2WzBdICogdlswXSArIHZbMV0gKiB2WzFdKTtcbiAgICB9O1xuICAgIHZhciB2UmF0aW8gPSBmdW5jdGlvbih1LCB2KSB7XG4gICAgICAgIHJldHVybiAodVswXSAqIHZbMF0gKyB1WzFdICogdlsxXSkgLyAodk1hZyh1KSAqIHZNYWcodikpO1xuICAgIH07XG4gICAgdmFyIHZBbmdsZSA9IGZ1bmN0aW9uKHUsIHYpIHtcbiAgICAgICAgcmV0dXJuICh1WzBdICogdlsxXSA8IHVbMV0gKiB2WzBdID8gLTEgOiAxKVxuICAgICAgICAgICAgICAgICogTWF0aC5hY29zKHZSYXRpbyh1LCB2KSk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHByb2Nlc3NBcmMoeDEsIHkxLCB4MiwgeTIsIGZhLCBmcywgcngsIHJ5LCBwc2lEZWcsIGNtZCwgcGF0aCkge1xuICAgICAgICB2YXIgcHNpID0gcHNpRGVnICogKFBJIC8gMTgwLjApO1xuICAgICAgICB2YXIgeHAgPSBtYXRoQ29zKHBzaSkgKiAoeDEgLSB4MikgLyAyLjBcbiAgICAgICAgICAgICAgICAgKyBtYXRoU2luKHBzaSkgKiAoeTEgLSB5MikgLyAyLjA7XG4gICAgICAgIHZhciB5cCA9IC0xICogbWF0aFNpbihwc2kpICogKHgxIC0geDIpIC8gMi4wXG4gICAgICAgICAgICAgICAgICsgbWF0aENvcyhwc2kpICogKHkxIC0geTIpIC8gMi4wO1xuXG4gICAgICAgIHZhciBsYW1iZGEgPSAoeHAgKiB4cCkgLyAocnggKiByeCkgKyAoeXAgKiB5cCkgLyAocnkgKiByeSk7XG5cbiAgICAgICAgaWYgKGxhbWJkYSA+IDEpIHtcbiAgICAgICAgICAgIHJ4ICo9IG1hdGhTcXJ0KGxhbWJkYSk7XG4gICAgICAgICAgICByeSAqPSBtYXRoU3FydChsYW1iZGEpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGYgPSAoZmEgPT09IGZzID8gLTEgOiAxKVxuICAgICAgICAgICAgKiBtYXRoU3FydCgoKChyeCAqIHJ4KSAqIChyeSAqIHJ5KSlcbiAgICAgICAgICAgICAgICAgICAgLSAoKHJ4ICogcngpICogKHlwICogeXApKVxuICAgICAgICAgICAgICAgICAgICAtICgocnkgKiByeSkgKiAoeHAgKiB4cCkpKSAvICgocnggKiByeCkgKiAoeXAgKiB5cClcbiAgICAgICAgICAgICAgICAgICAgKyAocnkgKiByeSkgKiAoeHAgKiB4cCkpXG4gICAgICAgICAgICAgICAgKSB8fCAwO1xuXG4gICAgICAgIHZhciBjeHAgPSBmICogcnggKiB5cCAvIHJ5O1xuICAgICAgICB2YXIgY3lwID0gZiAqIC1yeSAqIHhwIC8gcng7XG5cbiAgICAgICAgdmFyIGN4ID0gKHgxICsgeDIpIC8gMi4wXG4gICAgICAgICAgICAgICAgICsgbWF0aENvcyhwc2kpICogY3hwXG4gICAgICAgICAgICAgICAgIC0gbWF0aFNpbihwc2kpICogY3lwO1xuICAgICAgICB2YXIgY3kgPSAoeTEgKyB5MikgLyAyLjBcbiAgICAgICAgICAgICAgICArIG1hdGhTaW4ocHNpKSAqIGN4cFxuICAgICAgICAgICAgICAgICsgbWF0aENvcyhwc2kpICogY3lwO1xuXG4gICAgICAgIHZhciB0aGV0YSA9IHZBbmdsZShbIDEsIDAgXSwgWyAoeHAgLSBjeHApIC8gcngsICh5cCAtIGN5cCkgLyByeSBdKTtcbiAgICAgICAgdmFyIHUgPSBbICh4cCAtIGN4cCkgLyByeCwgKHlwIC0gY3lwKSAvIHJ5IF07XG4gICAgICAgIHZhciB2ID0gWyAoLTEgKiB4cCAtIGN4cCkgLyByeCwgKC0xICogeXAgLSBjeXApIC8gcnkgXTtcbiAgICAgICAgdmFyIGRUaGV0YSA9IHZBbmdsZSh1LCB2KTtcblxuICAgICAgICBpZiAodlJhdGlvKHUsIHYpIDw9IC0xKSB7XG4gICAgICAgICAgICBkVGhldGEgPSBQSTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodlJhdGlvKHUsIHYpID49IDEpIHtcbiAgICAgICAgICAgIGRUaGV0YSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZzID09PSAwICYmIGRUaGV0YSA+IDApIHtcbiAgICAgICAgICAgIGRUaGV0YSA9IGRUaGV0YSAtIDIgKiBQSTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZnMgPT09IDEgJiYgZFRoZXRhIDwgMCkge1xuICAgICAgICAgICAgZFRoZXRhID0gZFRoZXRhICsgMiAqIFBJO1xuICAgICAgICB9XG5cbiAgICAgICAgcGF0aC5hZGREYXRhKGNtZCwgY3gsIGN5LCByeCwgcnksIHRoZXRhLCBkVGhldGEsIHBzaSwgZnMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZVBhdGhQcm94eUZyb21TdHJpbmcoZGF0YSkge1xuICAgICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNvbW1hbmQgc3RyaW5nXG4gICAgICAgIHZhciBjcyA9IGRhdGEucmVwbGFjZSgvLS9nLCAnIC0nKVxuICAgICAgICAgICAgLnJlcGxhY2UoLyAgL2csICcgJylcbiAgICAgICAgICAgIC5yZXBsYWNlKC8gL2csICcsJylcbiAgICAgICAgICAgIC5yZXBsYWNlKC8sLC9nLCAnLCcpO1xuXG4gICAgICAgIHZhciBuO1xuICAgICAgICAvLyBjcmVhdGUgcGlwZXMgc28gdGhhdCB3ZSBjYW4gc3BsaXQgdGhlIGRhdGFcbiAgICAgICAgZm9yIChuID0gMDsgbiA8IGNjLmxlbmd0aDsgbisrKSB7XG4gICAgICAgICAgICBjcyA9IGNzLnJlcGxhY2UobmV3IFJlZ0V4cChjY1tuXSwgJ2cnKSwgJ3wnICsgY2Nbbl0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY3JlYXRlIGFycmF5XG4gICAgICAgIHZhciBhcnIgPSBjcy5zcGxpdCgnfCcpO1xuICAgICAgICAvLyBpbml0IGNvbnRleHQgcG9pbnRcbiAgICAgICAgdmFyIGNweCA9IDA7XG4gICAgICAgIHZhciBjcHkgPSAwO1xuXG4gICAgICAgIHZhciBwYXRoID0gbmV3IFBhdGhQcm94eSgpO1xuICAgICAgICB2YXIgQ01EID0gUGF0aFByb3h5LkNNRDtcblxuICAgICAgICB2YXIgcHJldkNtZDtcbiAgICAgICAgZm9yIChuID0gMTsgbiA8IGFyci5sZW5ndGg7IG4rKykge1xuICAgICAgICAgICAgdmFyIHN0ciA9IGFycltuXTtcbiAgICAgICAgICAgIHZhciBjID0gc3RyLmNoYXJBdCgwKTtcbiAgICAgICAgICAgIHZhciBvZmYgPSAwO1xuICAgICAgICAgICAgdmFyIHAgPSBzdHIuc2xpY2UoMSkucmVwbGFjZSgvZSwtL2csICdlLScpLnNwbGl0KCcsJyk7XG4gICAgICAgICAgICB2YXIgY21kO1xuXG4gICAgICAgICAgICBpZiAocC5sZW5ndGggPiAwICYmIHBbMF0gPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgcC5zaGlmdCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHAubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBwW2ldID0gcGFyc2VGbG9hdChwW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlIChvZmYgPCBwLmxlbmd0aCAmJiAhaXNOYU4ocFtvZmZdKSkge1xuICAgICAgICAgICAgICAgIGlmIChpc05hTihwWzBdKSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGN0bFB0eDtcbiAgICAgICAgICAgICAgICB2YXIgY3RsUHR5O1xuXG4gICAgICAgICAgICAgICAgdmFyIHJ4O1xuICAgICAgICAgICAgICAgIHZhciByeTtcbiAgICAgICAgICAgICAgICB2YXIgcHNpO1xuICAgICAgICAgICAgICAgIHZhciBmYTtcbiAgICAgICAgICAgICAgICB2YXIgZnM7XG5cbiAgICAgICAgICAgICAgICB2YXIgeDEgPSBjcHg7XG4gICAgICAgICAgICAgICAgdmFyIHkxID0gY3B5O1xuXG4gICAgICAgICAgICAgICAgLy8gY29udmVydCBsLCBILCBoLCBWLCBhbmQgdiB0byBMXG4gICAgICAgICAgICAgICAgc3dpdGNoIChjKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2wnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY3B4ICs9IHBbb2ZmKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3B5ICs9IHBbb2ZmKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY21kID0gQ01ELkw7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoLmFkZERhdGEoY21kLCBjcHgsIGNweSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnTCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHggPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweSA9IHBbb2ZmKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY21kID0gQ01ELkw7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoLmFkZERhdGEoY21kLCBjcHgsIGNweSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnbSc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHggKz0gcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHkgKz0gcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgICAgICBjbWQgPSBDTUQuTTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGguYWRkRGF0YShjbWQsIGNweCwgY3B5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMgPSAnbCc7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnTSc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHggPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweSA9IHBbb2ZmKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY21kID0gQ01ELk07XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoLmFkZERhdGEoY21kLCBjcHgsIGNweSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjID0gJ0wnO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2gnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY3B4ICs9IHBbb2ZmKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY21kID0gQ01ELkw7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoLmFkZERhdGEoY21kLCBjcHgsIGNweSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnSCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHggPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNtZCA9IENNRC5MO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aC5hZGREYXRhKGNtZCwgY3B4LCBjcHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3YnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY3B5ICs9IHBbb2ZmKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY21kID0gQ01ELkw7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoLmFkZERhdGEoY21kLCBjcHgsIGNweSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnVic6XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHkgPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNtZCA9IENNRC5MO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aC5hZGREYXRhKGNtZCwgY3B4LCBjcHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ0MnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY21kID0gQ01ELkM7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoLmFkZERhdGEoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY21kLCBwW29mZisrXSwgcFtvZmYrK10sIHBbb2ZmKytdLCBwW29mZisrXSwgcFtvZmYrK10sIHBbb2ZmKytdXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3B4ID0gcFtvZmYgLSAyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweSA9IHBbb2ZmIC0gMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnYyc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjbWQgPSBDTUQuQztcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGguYWRkRGF0YShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcFtvZmYrK10gKyBjcHgsIHBbb2ZmKytdICsgY3B5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBbb2ZmKytdICsgY3B4LCBwW29mZisrXSArIGNweSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwW29mZisrXSArIGNweCwgcFtvZmYrK10gKyBjcHlcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHggKz0gcFtvZmYgLSAyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweSArPSBwW29mZiAtIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ1MnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY3RsUHR4ID0gY3B4O1xuICAgICAgICAgICAgICAgICAgICAgICAgY3RsUHR5ID0gY3B5O1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxlbiA9IHBhdGgubGVuKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGF0aERhdGEgPSBwYXRoLmRhdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJldkNtZCA9PT0gQ01ELkMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdGxQdHggKz0gY3B4IC0gcGF0aERhdGFbbGVuIC0gNF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3RsUHR5ICs9IGNweSAtIHBhdGhEYXRhW2xlbiAtIDNdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY21kID0gQ01ELkM7XG4gICAgICAgICAgICAgICAgICAgICAgICB4MSA9IHBbb2ZmKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgeTEgPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweCA9IHBbb2ZmKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3B5ID0gcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoLmFkZERhdGEoY21kLCBjdGxQdHgsIGN0bFB0eSwgeDEsIHkxLCBjcHgsIGNweSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAncyc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjdGxQdHggPSBjcHg7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdGxQdHkgPSBjcHk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGVuID0gcGF0aC5sZW4oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXRoRGF0YSA9IHBhdGguZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcmV2Q21kID09PSBDTUQuQykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0bFB0eCArPSBjcHggLSBwYXRoRGF0YVtsZW4gLSA0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdGxQdHkgKz0gY3B5IC0gcGF0aERhdGFbbGVuIC0gM107XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjbWQgPSBDTUQuQztcbiAgICAgICAgICAgICAgICAgICAgICAgIHgxID0gY3B4ICsgcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgICAgICB5MSA9IGNweSArIHBbb2ZmKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3B4ICs9IHBbb2ZmKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3B5ICs9IHBbb2ZmKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aC5hZGREYXRhKGNtZCwgY3RsUHR4LCBjdGxQdHksIHgxLCB5MSwgY3B4LCBjcHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ1EnOlxuICAgICAgICAgICAgICAgICAgICAgICAgeDEgPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHkxID0gcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHggPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweSA9IHBbb2ZmKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY21kID0gQ01ELlE7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoLmFkZERhdGEoY21kLCB4MSwgeTEsIGNweCwgY3B5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdxJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHgxID0gcFtvZmYrK10gKyBjcHg7XG4gICAgICAgICAgICAgICAgICAgICAgICB5MSA9IHBbb2ZmKytdICsgY3B5O1xuICAgICAgICAgICAgICAgICAgICAgICAgY3B4ICs9IHBbb2ZmKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3B5ICs9IHBbb2ZmKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY21kID0gQ01ELlE7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoLmFkZERhdGEoY21kLCB4MSwgeTEsIGNweCwgY3B5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdUJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0bFB0eCA9IGNweDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0bFB0eSA9IGNweTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsZW4gPSBwYXRoLmxlbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhdGhEYXRhID0gcGF0aC5kYXRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByZXZDbWQgPT09IENNRC5RKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3RsUHR4ICs9IGNweCAtIHBhdGhEYXRhW2xlbiAtIDRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0bFB0eSArPSBjcHkgLSBwYXRoRGF0YVtsZW4gLSAzXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNweCA9IHBbb2ZmKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3B5ID0gcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgICAgICBjbWQgPSBDTUQuUTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGguYWRkRGF0YShjbWQsIGN0bFB0eCwgY3RsUHR5LCBjcHgsIGNweSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAndCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjdGxQdHggPSBjcHg7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdGxQdHkgPSBjcHk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGVuID0gcGF0aC5sZW4oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXRoRGF0YSA9IHBhdGguZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcmV2Q21kID09PSBDTUQuUSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0bFB0eCArPSBjcHggLSBwYXRoRGF0YVtsZW4gLSA0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdGxQdHkgKz0gY3B5IC0gcGF0aERhdGFbbGVuIC0gM107XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHggKz0gcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHkgKz0gcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgICAgICBjbWQgPSBDTUQuUTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGguYWRkRGF0YShjbWQsIGN0bFB0eCwgY3RsUHR5LCBjcHgsIGNweSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnQSc6XG4gICAgICAgICAgICAgICAgICAgICAgICByeCA9IHBbb2ZmKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcnkgPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBzaSA9IHBbb2ZmKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZmEgPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZzID0gcFtvZmYrK107XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHgxID0gY3B4LCB5MSA9IGNweTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweCA9IHBbb2ZmKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3B5ID0gcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgICAgICBjbWQgPSBDTUQuQTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2Nlc3NBcmMoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeDEsIHkxLCBjcHgsIGNweSwgZmEsIGZzLCByeCwgcnksIHBzaSwgY21kLCBwYXRoXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2EnOlxuICAgICAgICAgICAgICAgICAgICAgICAgcnggPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ5ID0gcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgICAgICBwc2kgPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhID0gcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgICAgICBmcyA9IHBbb2ZmKytdO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB4MSA9IGNweCwgeTEgPSBjcHk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHggKz0gcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHkgKz0gcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgICAgICBjbWQgPSBDTUQuQTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2Nlc3NBcmMoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeDEsIHkxLCBjcHgsIGNweSwgZmEsIGZzLCByeCwgcnksIHBzaSwgY21kLCBwYXRoXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoYyA9PT0gJ3onIHx8IGMgPT09ICdaJykge1xuICAgICAgICAgICAgICAgIGNtZCA9IENNRC5aO1xuICAgICAgICAgICAgICAgIHBhdGguYWRkRGF0YShjbWQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwcmV2Q21kID0gY21kO1xuICAgICAgICB9XG5cbiAgICAgICAgcGF0aC50b1N0YXRpYygpO1xuXG4gICAgICAgIHJldHVybiBwYXRoO1xuICAgIH1cblxuICAgIC8vIFRPRE8gT3B0aW1pemUgZG91YmxlIG1lbW9yeSBjb3N0IHByb2JsZW1cbiAgICBmdW5jdGlvbiBjcmVhdGVQYXRoT3B0aW9ucyhzdHIsIG9wdHMpIHtcbiAgICAgICAgdmFyIHBhdGhQcm94eSA9IGNyZWF0ZVBhdGhQcm94eUZyb21TdHJpbmcoc3RyKTtcbiAgICAgICAgdmFyIHRyYW5zZm9ybTtcbiAgICAgICAgb3B0cyA9IG9wdHMgfHwge307XG4gICAgICAgIG9wdHMuYnVpbGRQYXRoID0gZnVuY3Rpb24gKHBhdGgpIHtcbiAgICAgICAgICAgIHBhdGguc2V0RGF0YShwYXRoUHJveHkuZGF0YSk7XG4gICAgICAgICAgICB0cmFuc2Zvcm0gJiYgdHJhbnNmb3JtUGF0aChwYXRoLCB0cmFuc2Zvcm0pO1xuICAgICAgICAgICAgLy8gU3ZnIGFuZCB2bWwgcmVuZGVyZXIgZG9uJ3QgaGF2ZSBjb250ZXh0XG4gICAgICAgICAgICB2YXIgY3R4ID0gcGF0aC5nZXRDb250ZXh0KCk7XG4gICAgICAgICAgICBpZiAoY3R4KSB7XG4gICAgICAgICAgICAgICAgcGF0aC5yZWJ1aWxkUGF0aChjdHgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIG9wdHMuYXBwbHlUcmFuc2Zvcm0gPSBmdW5jdGlvbiAobSkge1xuICAgICAgICAgICAgaWYgKCF0cmFuc2Zvcm0pIHtcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm0gPSBtYXRyaXguY3JlYXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtYXRyaXgubXVsKHRyYW5zZm9ybSwgbSwgdHJhbnNmb3JtKTtcbiAgICAgICAgICAgIHRoaXMuZGlydHkodHJ1ZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIG9wdHM7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGUgYSBQYXRoIG9iamVjdCBmcm9tIHBhdGggc3RyaW5nIGRhdGFcbiAgICAgICAgICogaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHL3BhdGhzLmh0bWwjUGF0aERhdGFcbiAgICAgICAgICogQHBhcmFtICB7T2JqZWN0fSBvcHRzIE90aGVyIG9wdGlvbnNcbiAgICAgICAgICovXG4gICAgICAgIGNyZWF0ZUZyb21TdHJpbmc6IGZ1bmN0aW9uIChzdHIsIG9wdHMpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUGF0aChjcmVhdGVQYXRoT3B0aW9ucyhzdHIsIG9wdHMpKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlIGEgUGF0aCBjbGFzcyBmcm9tIHBhdGggc3RyaW5nIGRhdGFcbiAgICAgICAgICogQHBhcmFtICB7c3RyaW5nfSBzdHJcbiAgICAgICAgICogQHBhcmFtICB7T2JqZWN0fSBvcHRzIE90aGVyIG9wdGlvbnNcbiAgICAgICAgICovXG4gICAgICAgIGV4dGVuZEZyb21TdHJpbmc6IGZ1bmN0aW9uIChzdHIsIG9wdHMpIHtcbiAgICAgICAgICAgIHJldHVybiBQYXRoLmV4dGVuZChjcmVhdGVQYXRoT3B0aW9ucyhzdHIsIG9wdHMpKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogTWVyZ2UgbXVsdGlwbGUgcGF0aHNcbiAgICAgICAgICovXG4gICAgICAgIC8vIFRPRE8gQXBwbHkgdHJhbnNmb3JtXG4gICAgICAgIC8vIFRPRE8gc3Ryb2tlIGRhc2hcbiAgICAgICAgLy8gVE9ETyBPcHRpbWl6ZSBkb3VibGUgbWVtb3J5IGNvc3QgcHJvYmxlbVxuICAgICAgICBtZXJnZVBhdGg6IGZ1bmN0aW9uIChwYXRoRWxzLCBvcHRzKSB7XG4gICAgICAgICAgICB2YXIgcGF0aExpc3QgPSBbXTtcbiAgICAgICAgICAgIHZhciBsZW4gPSBwYXRoRWxzLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgcGF0aEVsID0gcGF0aEVsc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAocGF0aEVsLl9fZGlydHkpIHtcbiAgICAgICAgICAgICAgICAgICAgcGF0aEVsLmJ1aWxkUGF0aChwYXRoRWwucGF0aCwgcGF0aEVsLnNoYXBlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcGF0aExpc3QucHVzaChwYXRoRWwucGF0aCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBwYXRoQnVuZGxlID0gbmV3IFBhdGgob3B0cyk7XG4gICAgICAgICAgICBwYXRoQnVuZGxlLmJ1aWxkUGF0aCA9IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgICAgICAgICAgICAgcGF0aC5hcHBlbmRQYXRoKHBhdGhMaXN0KTtcbiAgICAgICAgICAgICAgICAvLyBTdmcgYW5kIHZtbCByZW5kZXJlciBkb24ndCBoYXZlIGNvbnRleHRcbiAgICAgICAgICAgICAgICB2YXIgY3R4ID0gcGF0aC5nZXRDb250ZXh0KCk7XG4gICAgICAgICAgICAgICAgaWYgKGN0eCkge1xuICAgICAgICAgICAgICAgICAgICBwYXRoLnJlYnVpbGRQYXRoKGN0eCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgcmV0dXJuIHBhdGhCdW5kbGU7XG4gICAgICAgIH1cbiAgICB9O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34venJlbmRlci9saWIvdG9vbC9wYXRoLmpzXG4gKiogbW9kdWxlIGlkID0gNVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBQYXRoIGVsZW1lbnRcbiAqIEBtb2R1bGUgenJlbmRlci9ncmFwaGljL1BhdGhcbiAqL1xuXG5cblxuICAgIHZhciBEaXNwbGF5YWJsZSA9IHJlcXVpcmUoJy4vRGlzcGxheWFibGUnKTtcbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnLi4vY29yZS91dGlsJyk7XG4gICAgdmFyIFBhdGhQcm94eSA9IHJlcXVpcmUoJy4uL2NvcmUvUGF0aFByb3h5Jyk7XG4gICAgdmFyIHBhdGhDb250YWluID0gcmVxdWlyZSgnLi4vY29udGFpbi9wYXRoJyk7XG5cbiAgICB2YXIgUGF0dGVybiA9IHJlcXVpcmUoJy4vUGF0dGVybicpO1xuICAgIHZhciBnZXRDYW52YXNQYXR0ZXJuID0gUGF0dGVybi5wcm90b3R5cGUuZ2V0Q2FudmFzUGF0dGVybjtcblxuICAgIHZhciBhYnMgPSBNYXRoLmFicztcblxuICAgIC8qKlxuICAgICAqIEBhbGlhcyBtb2R1bGU6enJlbmRlci9ncmFwaGljL1BhdGhcbiAgICAgKiBAZXh0ZW5kcyBtb2R1bGU6enJlbmRlci9ncmFwaGljL0Rpc3BsYXlhYmxlXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBQYXRoKG9wdHMpIHtcbiAgICAgICAgRGlzcGxheWFibGUuY2FsbCh0aGlzLCBvcHRzKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge21vZHVsZTp6cmVuZGVyL2NvcmUvUGF0aFByb3h5fVxuICAgICAgICAgKiBAcmVhZE9ubHlcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucGF0aCA9IG5ldyBQYXRoUHJveHkoKTtcbiAgICB9XG5cbiAgICBQYXRoLnByb3RvdHlwZSA9IHtcblxuICAgICAgICBjb25zdHJ1Y3RvcjogUGF0aCxcblxuICAgICAgICB0eXBlOiAncGF0aCcsXG5cbiAgICAgICAgX19kaXJ0eVBhdGg6IHRydWUsXG5cbiAgICAgICAgc3Ryb2tlQ29udGFpblRocmVzaG9sZDogNSxcblxuICAgICAgICBicnVzaDogZnVuY3Rpb24gKGN0eCwgcHJldkVsKSB7XG4gICAgICAgICAgICB2YXIgc3R5bGUgPSB0aGlzLnN0eWxlO1xuICAgICAgICAgICAgdmFyIHBhdGggPSB0aGlzLnBhdGg7XG4gICAgICAgICAgICB2YXIgaGFzU3Ryb2tlID0gc3R5bGUuaGFzU3Ryb2tlKCk7XG4gICAgICAgICAgICB2YXIgaGFzRmlsbCA9IHN0eWxlLmhhc0ZpbGwoKTtcbiAgICAgICAgICAgIHZhciBmaWxsID0gc3R5bGUuZmlsbDtcbiAgICAgICAgICAgIHZhciBzdHJva2UgPSBzdHlsZS5zdHJva2U7XG4gICAgICAgICAgICB2YXIgaGFzRmlsbEdyYWRpZW50ID0gaGFzRmlsbCAmJiAhIShmaWxsLmNvbG9yU3RvcHMpO1xuICAgICAgICAgICAgdmFyIGhhc1N0cm9rZUdyYWRpZW50ID0gaGFzU3Ryb2tlICYmICEhKHN0cm9rZS5jb2xvclN0b3BzKTtcbiAgICAgICAgICAgIHZhciBoYXNGaWxsUGF0dGVybiA9IGhhc0ZpbGwgJiYgISEoZmlsbC5pbWFnZSk7XG4gICAgICAgICAgICB2YXIgaGFzU3Ryb2tlUGF0dGVybiA9IGhhc1N0cm9rZSAmJiAhIShzdHJva2UuaW1hZ2UpO1xuXG4gICAgICAgICAgICBzdHlsZS5iaW5kKGN0eCwgdGhpcywgcHJldkVsKTtcbiAgICAgICAgICAgIHRoaXMuc2V0VHJhbnNmb3JtKGN0eCk7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl9fZGlydHkpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVjdCA9IHRoaXMuZ2V0Qm91bmRpbmdSZWN0KCk7XG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIGdyYWRpZW50IGJlY2F1c2UgYm91bmRpbmcgcmVjdCBtYXkgY2hhbmdlZFxuICAgICAgICAgICAgICAgIGlmIChoYXNGaWxsR3JhZGllbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZmlsbEdyYWRpZW50ID0gc3R5bGUuZ2V0R3JhZGllbnQoY3R4LCBmaWxsLCByZWN0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGhhc1N0cm9rZUdyYWRpZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0cm9rZUdyYWRpZW50ID0gc3R5bGUuZ2V0R3JhZGllbnQoY3R4LCBzdHJva2UsIHJlY3QpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFVzZSB0aGUgZ3JhZGllbnQgb3IgcGF0dGVyblxuICAgICAgICAgICAgaWYgKGhhc0ZpbGxHcmFkaWVudCkge1xuICAgICAgICAgICAgICAgIC8vIFBFTkRJTkcgSWYgbWF5IGhhdmUgYWZmZWN0IHRoZSBzdGF0ZVxuICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLl9maWxsR3JhZGllbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChoYXNGaWxsUGF0dGVybikge1xuICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBnZXRDYW52YXNQYXR0ZXJuLmNhbGwoZmlsbCwgY3R4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChoYXNTdHJva2VHcmFkaWVudCkge1xuICAgICAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHRoaXMuX3N0cm9rZUdyYWRpZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaGFzU3Ryb2tlUGF0dGVybikge1xuICAgICAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IGdldENhbnZhc1BhdHRlcm4uY2FsbChzdHJva2UsIGN0eCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBsaW5lRGFzaCA9IHN0eWxlLmxpbmVEYXNoO1xuICAgICAgICAgICAgdmFyIGxpbmVEYXNoT2Zmc2V0ID0gc3R5bGUubGluZURhc2hPZmZzZXQ7XG5cbiAgICAgICAgICAgIHZhciBjdHhMaW5lRGFzaCA9ICEhY3R4LnNldExpbmVEYXNoO1xuXG4gICAgICAgICAgICAvLyBVcGRhdGUgcGF0aCBzeCwgc3lcbiAgICAgICAgICAgIHZhciBzY2FsZSA9IHRoaXMuZ2V0R2xvYmFsU2NhbGUoKTtcbiAgICAgICAgICAgIHBhdGguc2V0U2NhbGUoc2NhbGVbMF0sIHNjYWxlWzFdKTtcblxuICAgICAgICAgICAgLy8gUHJveHkgY29udGV4dFxuICAgICAgICAgICAgLy8gUmVidWlsZCBwYXRoIGluIGZvbGxvd2luZyAyIGNhc2VzXG4gICAgICAgICAgICAvLyAxLiBQYXRoIGlzIGRpcnR5XG4gICAgICAgICAgICAvLyAyLiBQYXRoIG5lZWRzIGphdmFzY3JpcHQgaW1wbGVtZW50ZWQgbGluZURhc2ggc3Ryb2tpbmcuXG4gICAgICAgICAgICAvLyAgICBJbiB0aGlzIGNhc2UsIGxpbmVEYXNoIGluZm9ybWF0aW9uIHdpbGwgbm90IGJlIHNhdmVkIGluIFBhdGhQcm94eVxuICAgICAgICAgICAgaWYgKHRoaXMuX19kaXJ0eVBhdGggfHwgKFxuICAgICAgICAgICAgICAgIGxpbmVEYXNoICYmICFjdHhMaW5lRGFzaCAmJiBoYXNTdHJva2VcbiAgICAgICAgICAgICkpIHtcbiAgICAgICAgICAgICAgICBwYXRoID0gdGhpcy5wYXRoLmJlZ2luUGF0aChjdHgpO1xuXG4gICAgICAgICAgICAgICAgLy8gU2V0dGluZyBsaW5lIGRhc2ggYmVmb3JlIGJ1aWxkIHBhdGhcbiAgICAgICAgICAgICAgICBpZiAobGluZURhc2ggJiYgIWN0eExpbmVEYXNoKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhdGguc2V0TGluZURhc2gobGluZURhc2gpO1xuICAgICAgICAgICAgICAgICAgICBwYXRoLnNldExpbmVEYXNoT2Zmc2V0KGxpbmVEYXNoT2Zmc2V0KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLmJ1aWxkUGF0aChwYXRoLCB0aGlzLnNoYXBlLCBmYWxzZSk7XG5cbiAgICAgICAgICAgICAgICAvLyBDbGVhciBwYXRoIGRpcnR5IGZsYWdcbiAgICAgICAgICAgICAgICB0aGlzLl9fZGlydHlQYXRoID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBSZXBsYXkgcGF0aCBidWlsZGluZ1xuICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBhdGgucmVidWlsZFBhdGgoY3R4KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaGFzRmlsbCAmJiBwYXRoLmZpbGwoY3R4KTtcblxuICAgICAgICAgICAgaWYgKGxpbmVEYXNoICYmIGN0eExpbmVEYXNoKSB7XG4gICAgICAgICAgICAgICAgY3R4LnNldExpbmVEYXNoKGxpbmVEYXNoKTtcbiAgICAgICAgICAgICAgICBjdHgubGluZURhc2hPZmZzZXQgPSBsaW5lRGFzaE9mZnNldDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaGFzU3Ryb2tlICYmIHBhdGguc3Ryb2tlKGN0eCk7XG5cbiAgICAgICAgICAgIGlmIChsaW5lRGFzaCAmJiBjdHhMaW5lRGFzaCkge1xuICAgICAgICAgICAgICAgIC8vIFBFTkRJTkdcbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgbGluZURhc2hcbiAgICAgICAgICAgICAgICBjdHguc2V0TGluZURhc2goW10pO1xuICAgICAgICAgICAgfVxuXG5cbiAgICAgICAgICAgIHRoaXMucmVzdG9yZVRyYW5zZm9ybShjdHgpO1xuXG4gICAgICAgICAgICAvLyBEcmF3IHJlY3QgdGV4dFxuICAgICAgICAgICAgaWYgKHN0eWxlLnRleHQgfHwgc3R5bGUudGV4dCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIC8vIHZhciByZWN0ID0gdGhpcy5nZXRCb3VuZGluZ1JlY3QoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRyYXdSZWN0VGV4dChjdHgsIHRoaXMuZ2V0Qm91bmRpbmdSZWN0KCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8vIFdoZW4gYnVuZGxpbmcgcGF0aCwgc29tZSBzaGFwZSBtYXkgZGVjaWRlIGlmIHVzZSBtb3ZlVG8gdG8gYmVnaW4gYSBuZXcgc3VicGF0aCBvciBjbG9zZVBhdGhcbiAgICAgICAgLy8gTGlrZSBpbiBjaXJjbGVcbiAgICAgICAgYnVpbGRQYXRoOiBmdW5jdGlvbiAoY3R4LCBzaGFwZUNmZywgaW5CdW5kbGUpIHt9LFxuXG4gICAgICAgIGdldEJvdW5kaW5nUmVjdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHJlY3QgPSB0aGlzLl9yZWN0O1xuICAgICAgICAgICAgdmFyIHN0eWxlID0gdGhpcy5zdHlsZTtcbiAgICAgICAgICAgIHZhciBuZWVkc1VwZGF0ZVJlY3QgPSAhcmVjdDtcbiAgICAgICAgICAgIGlmIChuZWVkc1VwZGF0ZVJlY3QpIHtcbiAgICAgICAgICAgICAgICB2YXIgcGF0aCA9IHRoaXMucGF0aDtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fX2RpcnR5UGF0aCkge1xuICAgICAgICAgICAgICAgICAgICBwYXRoLmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmJ1aWxkUGF0aChwYXRoLCB0aGlzLnNoYXBlLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlY3QgPSBwYXRoLmdldEJvdW5kaW5nUmVjdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fcmVjdCA9IHJlY3Q7XG5cbiAgICAgICAgICAgIGlmIChzdHlsZS5oYXNTdHJva2UoKSkge1xuICAgICAgICAgICAgICAgIC8vIE5lZWRzIHVwZGF0ZSByZWN0IHdpdGggc3Ryb2tlIGxpbmVXaWR0aCB3aGVuXG4gICAgICAgICAgICAgICAgLy8gMS4gRWxlbWVudCBjaGFuZ2VzIHNjYWxlIG9yIGxpbmVXaWR0aFxuICAgICAgICAgICAgICAgIC8vIDIuIFNoYXBlIGlzIGNoYW5nZWRcbiAgICAgICAgICAgICAgICB2YXIgcmVjdFdpdGhTdHJva2UgPSB0aGlzLl9yZWN0V2l0aFN0cm9rZSB8fCAodGhpcy5fcmVjdFdpdGhTdHJva2UgPSByZWN0LmNsb25lKCkpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9fZGlydHkgfHwgbmVlZHNVcGRhdGVSZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlY3RXaXRoU3Ryb2tlLmNvcHkocmVjdCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIEZJWE1FIE11c3QgYWZ0ZXIgdXBkYXRlVHJhbnNmb3JtXG4gICAgICAgICAgICAgICAgICAgIHZhciB3ID0gc3R5bGUubGluZVdpZHRoO1xuICAgICAgICAgICAgICAgICAgICAvLyBQRU5ESU5HLCBNaW4gbGluZSB3aWR0aCBpcyBuZWVkZWQgd2hlbiBsaW5lIGlzIGhvcml6b250YWwgb3IgdmVydGljYWxcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxpbmVTY2FsZSA9IHN0eWxlLnN0cm9rZU5vU2NhbGUgPyB0aGlzLmdldExpbmVTY2FsZSgpIDogMTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBPbmx5IGFkZCBleHRyYSBob3ZlciBsaW5lV2lkdGggd2hlbiB0aGVyZSBhcmUgbm8gZmlsbFxuICAgICAgICAgICAgICAgICAgICBpZiAoIXN0eWxlLmhhc0ZpbGwoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdyA9IE1hdGgubWF4KHcsIHRoaXMuc3Ryb2tlQ29udGFpblRocmVzaG9sZCB8fCA0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBDb25zaWRlciBsaW5lIHdpZHRoXG4gICAgICAgICAgICAgICAgICAgIC8vIExpbmUgc2NhbGUgY2FuJ3QgYmUgMDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxpbmVTY2FsZSA+IDFlLTEwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWN0V2l0aFN0cm9rZS53aWR0aCArPSB3IC8gbGluZVNjYWxlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVjdFdpdGhTdHJva2UuaGVpZ2h0ICs9IHcgLyBsaW5lU2NhbGU7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWN0V2l0aFN0cm9rZS54IC09IHcgLyBsaW5lU2NhbGUgLyAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVjdFdpdGhTdHJva2UueSAtPSB3IC8gbGluZVNjYWxlIC8gMjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFJldHVybiByZWN0IHdpdGggc3Ryb2tlXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlY3RXaXRoU3Ryb2tlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcmVjdDtcbiAgICAgICAgfSxcblxuICAgICAgICBjb250YWluOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICAgICAgdmFyIGxvY2FsUG9zID0gdGhpcy50cmFuc2Zvcm1Db29yZFRvTG9jYWwoeCwgeSk7XG4gICAgICAgICAgICB2YXIgcmVjdCA9IHRoaXMuZ2V0Qm91bmRpbmdSZWN0KCk7XG4gICAgICAgICAgICB2YXIgc3R5bGUgPSB0aGlzLnN0eWxlO1xuICAgICAgICAgICAgeCA9IGxvY2FsUG9zWzBdO1xuICAgICAgICAgICAgeSA9IGxvY2FsUG9zWzFdO1xuXG4gICAgICAgICAgICBpZiAocmVjdC5jb250YWluKHgsIHkpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhdGhEYXRhID0gdGhpcy5wYXRoLmRhdGE7XG4gICAgICAgICAgICAgICAgaWYgKHN0eWxlLmhhc1N0cm9rZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsaW5lV2lkdGggPSBzdHlsZS5saW5lV2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsaW5lU2NhbGUgPSBzdHlsZS5zdHJva2VOb1NjYWxlID8gdGhpcy5nZXRMaW5lU2NhbGUoKSA6IDE7XG4gICAgICAgICAgICAgICAgICAgIC8vIExpbmUgc2NhbGUgY2FuJ3QgYmUgMDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxpbmVTY2FsZSA+IDFlLTEwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBPbmx5IGFkZCBleHRyYSBob3ZlciBsaW5lV2lkdGggd2hlbiB0aGVyZSBhcmUgbm8gZmlsbFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzdHlsZS5oYXNGaWxsKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lV2lkdGggPSBNYXRoLm1heChsaW5lV2lkdGgsIHRoaXMuc3Ryb2tlQ29udGFpblRocmVzaG9sZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGF0aENvbnRhaW4uY29udGFpblN0cm9rZShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRoRGF0YSwgbGluZVdpZHRoIC8gbGluZVNjYWxlLCB4LCB5XG4gICAgICAgICAgICAgICAgICAgICAgICApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHN0eWxlLmhhc0ZpbGwoKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGF0aENvbnRhaW4uY29udGFpbihwYXRoRGF0YSwgeCwgeSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gIHtib29sZWFufSBkaXJ0eVBhdGhcbiAgICAgICAgICovXG4gICAgICAgIGRpcnR5OiBmdW5jdGlvbiAoZGlydHlQYXRoKSB7XG4gICAgICAgICAgICBpZiAoZGlydHlQYXRoID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBkaXJ0eVBhdGggPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gT25seSBtYXJrIGRpcnR5LCBub3QgbWFyayBjbGVhblxuICAgICAgICAgICAgaWYgKGRpcnR5UGF0aCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX19kaXJ0eVBhdGggPSBkaXJ0eVBhdGg7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVjdCA9IG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX19kaXJ0eSA9IHRydWU7XG5cbiAgICAgICAgICAgIHRoaXMuX196ciAmJiB0aGlzLl9fenIucmVmcmVzaCgpO1xuXG4gICAgICAgICAgICAvLyBVc2VkIGFzIGEgY2xpcHBpbmcgcGF0aFxuICAgICAgICAgICAgaWYgKHRoaXMuX19jbGlwVGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fX2NsaXBUYXJnZXQuZGlydHkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQWxpYXMgZm9yIGFuaW1hdGUoJ3NoYXBlJylcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBsb29wXG4gICAgICAgICAqL1xuICAgICAgICBhbmltYXRlU2hhcGU6IGZ1bmN0aW9uIChsb29wKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hbmltYXRlKCdzaGFwZScsIGxvb3ApO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIE92ZXJ3cml0ZSBhdHRyS1ZcbiAgICAgICAgYXR0cktWOiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgLy8gRklYTUVcbiAgICAgICAgICAgIGlmIChrZXkgPT09ICdzaGFwZScpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFNoYXBlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9fZGlydHlQYXRoID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZWN0ID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIERpc3BsYXlhYmxlLnByb3RvdHlwZS5hdHRyS1YuY2FsbCh0aGlzLCBrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R8c3RyaW5nfSBrZXlcbiAgICAgICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0U2hhcGU6IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgc2hhcGUgPSB0aGlzLnNoYXBlO1xuICAgICAgICAgICAgLy8gUGF0aCBmcm9tIHN0cmluZyBtYXkgbm90IGhhdmUgc2hhcGVcbiAgICAgICAgICAgIGlmIChzaGFwZSkge1xuICAgICAgICAgICAgICAgIGlmICh6clV0aWwuaXNPYmplY3Qoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBuYW1lIGluIGtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2hhcGVbbmFtZV0gPSBrZXlbbmFtZV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNoYXBlW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5kaXJ0eSh0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldExpbmVTY2FsZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG0gPSB0aGlzLnRyYW5zZm9ybTtcbiAgICAgICAgICAgIC8vIEdldCB0aGUgbGluZSBzY2FsZS5cbiAgICAgICAgICAgIC8vIERldGVybWluYW50IG9mIGBtYCBtZWFucyBob3cgbXVjaCB0aGUgYXJlYSBpcyBlbmxhcmdlZCBieSB0aGVcbiAgICAgICAgICAgIC8vIHRyYW5zZm9ybWF0aW9uLiBTbyBpdHMgc3F1YXJlIHJvb3QgY2FuIGJlIHVzZWQgYXMgYSBzY2FsZSBmYWN0b3JcbiAgICAgICAgICAgIC8vIGZvciB3aWR0aC5cbiAgICAgICAgICAgIHJldHVybiBtICYmIGFicyhtWzBdIC0gMSkgPiAxZS0xMCAmJiBhYnMobVszXSAtIDEpID4gMWUtMTBcbiAgICAgICAgICAgICAgICA/IE1hdGguc3FydChhYnMobVswXSAqIG1bM10gLSBtWzJdICogbVsxXSkpXG4gICAgICAgICAgICAgICAgOiAxO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIOaJqeWxleS4gOS4qiBQYXRoIGVsZW1lbnQsIOavlOWmguaYn+W9ou+8jOWchuetieOAglxuICAgICAqIEV4dGVuZCBhIHBhdGggZWxlbWVudFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wcy50eXBlIFBhdGggdHlwZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHByb3BzLmluaXQgSW5pdGlhbGl6ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHByb3BzLmJ1aWxkUGF0aCBPdmVyd3JpdGUgYnVpbGRQYXRoIG1ldGhvZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMuc3R5bGVdIEV4dGVuZGVkIGRlZmF1bHQgc3R5bGUgY29uZmlnXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5zaGFwZV0gRXh0ZW5kZWQgZGVmYXVsdCBzaGFwZSBjb25maWdcbiAgICAgKi9cbiAgICBQYXRoLmV4dGVuZCA9IGZ1bmN0aW9uIChkZWZhdWx0cykge1xuICAgICAgICB2YXIgU3ViID0gZnVuY3Rpb24gKG9wdHMpIHtcbiAgICAgICAgICAgIFBhdGguY2FsbCh0aGlzLCBvcHRzKTtcblxuICAgICAgICAgICAgaWYgKGRlZmF1bHRzLnN0eWxlKSB7XG4gICAgICAgICAgICAgICAgLy8gRXh0ZW5kIGRlZmF1bHQgc3R5bGVcbiAgICAgICAgICAgICAgICB0aGlzLnN0eWxlLmV4dGVuZEZyb20oZGVmYXVsdHMuc3R5bGUsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRXh0ZW5kIGRlZmF1bHQgc2hhcGVcbiAgICAgICAgICAgIHZhciBkZWZhdWx0U2hhcGUgPSBkZWZhdWx0cy5zaGFwZTtcbiAgICAgICAgICAgIGlmIChkZWZhdWx0U2hhcGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNoYXBlID0gdGhpcy5zaGFwZSB8fCB7fTtcbiAgICAgICAgICAgICAgICB2YXIgdGhpc1NoYXBlID0gdGhpcy5zaGFwZTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBuYW1lIGluIGRlZmF1bHRTaGFwZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAhIHRoaXNTaGFwZS5oYXNPd25Qcm9wZXJ0eShuYW1lKVxuICAgICAgICAgICAgICAgICAgICAgICAgJiYgZGVmYXVsdFNoYXBlLmhhc093blByb3BlcnR5KG5hbWUpXG4gICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1NoYXBlW25hbWVdID0gZGVmYXVsdFNoYXBlW25hbWVdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkZWZhdWx0cy5pbml0ICYmIGRlZmF1bHRzLmluaXQuY2FsbCh0aGlzLCBvcHRzKTtcbiAgICAgICAgfTtcblxuICAgICAgICB6clV0aWwuaW5oZXJpdHMoU3ViLCBQYXRoKTtcblxuICAgICAgICAvLyBGSVhNRSDkuI3og70gZXh0ZW5kIHBvc2l0aW9uLCByb3RhdGlvbiDnrYnlvJXnlKjlr7nosaFcbiAgICAgICAgZm9yICh2YXIgbmFtZSBpbiBkZWZhdWx0cykge1xuICAgICAgICAgICAgLy8gRXh0ZW5kaW5nIHByb3RvdHlwZSB2YWx1ZXMgYW5kIG1ldGhvZHNcbiAgICAgICAgICAgIGlmIChuYW1lICE9PSAnc3R5bGUnICYmIG5hbWUgIT09ICdzaGFwZScpIHtcbiAgICAgICAgICAgICAgICBTdWIucHJvdG90eXBlW25hbWVdID0gZGVmYXVsdHNbbmFtZV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gU3ViO1xuICAgIH07XG5cbiAgICB6clV0aWwuaW5oZXJpdHMoUGF0aCwgRGlzcGxheWFibGUpO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBQYXRoO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34venJlbmRlci9saWIvZ3JhcGhpYy9QYXRoLmpzXG4gKiogbW9kdWxlIGlkID0gNlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiDlj6/nu5jliLbnmoTlm77lvaLln7rnsbtcbiAqIEJhc2UgY2xhc3Mgb2YgYWxsIGRpc3BsYXlhYmxlIGdyYXBoaWMgb2JqZWN0c1xuICogQG1vZHVsZSB6cmVuZGVyL2dyYXBoaWMvRGlzcGxheWFibGVcbiAqL1xuXG5cblxuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCcuLi9jb3JlL3V0aWwnKTtcblxuICAgIHZhciBTdHlsZSA9IHJlcXVpcmUoJy4vU3R5bGUnKTtcblxuICAgIHZhciBFbGVtZW50ID0gcmVxdWlyZSgnLi4vRWxlbWVudCcpO1xuICAgIHZhciBSZWN0VGV4dCA9IHJlcXVpcmUoJy4vbWl4aW4vUmVjdFRleHQnKTtcbiAgICAvLyB2YXIgU3RhdGVmdWwgPSByZXF1aXJlKCcuL21peGluL1N0YXRlZnVsJyk7XG5cbiAgICAvKipcbiAgICAgKiBAYWxpYXMgbW9kdWxlOnpyZW5kZXIvZ3JhcGhpYy9EaXNwbGF5YWJsZVxuICAgICAqIEBleHRlbmRzIG1vZHVsZTp6cmVuZGVyL0VsZW1lbnRcbiAgICAgKiBAZXh0ZW5kcyBtb2R1bGU6enJlbmRlci9ncmFwaGljL21peGluL1JlY3RUZXh0XG4gICAgICovXG4gICAgZnVuY3Rpb24gRGlzcGxheWFibGUob3B0cykge1xuXG4gICAgICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xuXG4gICAgICAgIEVsZW1lbnQuY2FsbCh0aGlzLCBvcHRzKTtcblxuICAgICAgICAvLyBFeHRlbmQgcHJvcGVydGllc1xuICAgICAgICBmb3IgKHZhciBuYW1lIGluIG9wdHMpIHtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBvcHRzLmhhc093blByb3BlcnR5KG5hbWUpICYmXG4gICAgICAgICAgICAgICAgbmFtZSAhPT0gJ3N0eWxlJ1xuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgdGhpc1tuYW1lXSA9IG9wdHNbbmFtZV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge21vZHVsZTp6cmVuZGVyL2dyYXBoaWMvU3R5bGV9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN0eWxlID0gbmV3IFN0eWxlKG9wdHMuc3R5bGUpO1xuXG4gICAgICAgIHRoaXMuX3JlY3QgPSBudWxsO1xuICAgICAgICAvLyBTaGFwZXMgZm9yIGNhc2NhZGUgY2xpcHBpbmcuXG4gICAgICAgIHRoaXMuX19jbGlwUGF0aHMgPSBbXTtcblxuICAgICAgICAvLyBGSVhNRSBTdGF0ZWZ1bCBtdXN0IGJlIG1peGluZWQgYWZ0ZXIgc3R5bGUgaXMgc2V0dGVkXG4gICAgICAgIC8vIFN0YXRlZnVsLmNhbGwodGhpcywgb3B0cyk7XG4gICAgfVxuXG4gICAgRGlzcGxheWFibGUucHJvdG90eXBlID0ge1xuXG4gICAgICAgIGNvbnN0cnVjdG9yOiBEaXNwbGF5YWJsZSxcblxuICAgICAgICB0eXBlOiAnZGlzcGxheWFibGUnLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEaXNwbGF5YWJsZSDmmK/lkKbkuLrohI/vvIxQYWludGVyIOS4reS8muagueaNruivpeagh+iusOWIpOaWreaYr+WQpumcgOimgeaYr+WQpumcgOimgemHjeaWsOe7mOWItlxuICAgICAgICAgKiBEaXJ0eSBmbGFnLiBGcm9tIHdoaWNoIHBhaW50ZXIgd2lsbCBkZXRlcm1pbmUgaWYgdGhpcyBkaXNwbGF5YWJsZSBvYmplY3QgbmVlZHMgYnJ1c2hcbiAgICAgICAgICogQG5hbWUgbW9kdWxlOnpyZW5kZXIvZ3JhcGhpYy9EaXNwbGF5YWJsZSNfX2RpcnR5XG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgX19kaXJ0eTogdHJ1ZSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5Zu+5b2i5piv5ZCm5Y+v6KeB77yM5Li6dHJ1ZeaXtuS4jee7mOWItuWbvuW9ou+8jOS9huaYr+S7jeiDveinpuWPkem8oOagh+S6i+S7tlxuICAgICAgICAgKiBJZiBpZ25vcmUgZHJhd2luZyBvZiB0aGUgZGlzcGxheWFibGUgb2JqZWN0LiBNb3VzZSBldmVudCB3aWxsIHN0aWxsIGJlIHRyaWdnZXJlZFxuICAgICAgICAgKiBAbmFtZSBtb2R1bGU6L3pyZW5kZXIvZ3JhcGhpYy9EaXNwbGF5YWJsZSNpbnZpc2libGVcbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICBpbnZpc2libGU6IGZhbHNlLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbmFtZSBtb2R1bGU6L3pyZW5kZXIvZ3JhcGhpYy9EaXNwbGF5YWJsZSN6XG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqIEBkZWZhdWx0IDBcbiAgICAgICAgICovXG4gICAgICAgIHo6IDAsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBuYW1lIG1vZHVsZTovenJlbmRlci9ncmFwaGljL0Rpc3BsYXlhYmxlI3pcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICogQGRlZmF1bHQgMFxuICAgICAgICAgKi9cbiAgICAgICAgejI6IDAsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHrlsYJsZXZlbO+8jOWGs+Wumue7mOeUu+WcqOWTquWxgmNhbnZhc+S4rVxuICAgICAgICAgKiBAbmFtZSBtb2R1bGU6L3pyZW5kZXIvZ3JhcGhpYy9EaXNwbGF5YWJsZSN6bGV2ZWxcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICogQGRlZmF1bHQgMFxuICAgICAgICAgKi9cbiAgICAgICAgemxldmVsOiAwLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmmK/lkKblj6/mi5bmi71cbiAgICAgICAgICogQG5hbWUgbW9kdWxlOi96cmVuZGVyL2dyYXBoaWMvRGlzcGxheWFibGUjZHJhZ2dhYmxlXG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgZHJhZ2dhYmxlOiBmYWxzZSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5piv5ZCm5q2j5Zyo5ouW5ou9XG4gICAgICAgICAqIEBuYW1lIG1vZHVsZTovenJlbmRlci9ncmFwaGljL0Rpc3BsYXlhYmxlI2RyYWdnYWJsZVxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIGRyYWdnaW5nOiBmYWxzZSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5piv5ZCm55u45bqU6byg5qCH5LqL5Lu2XG4gICAgICAgICAqIEBuYW1lIG1vZHVsZTovenJlbmRlci9ncmFwaGljL0Rpc3BsYXlhYmxlI3NpbGVudFxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIHNpbGVudDogZmFsc2UsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIGVuYWJsZSBjdWxsaW5nXG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgY3VsbGluZzogZmFsc2UsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1vdXNlIGN1cnNvciB3aGVuIGhvdmVyZWRcbiAgICAgICAgICogQG5hbWUgbW9kdWxlOi96cmVuZGVyL2dyYXBoaWMvRGlzcGxheWFibGUjY3Vyc29yXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICBjdXJzb3I6ICdwb2ludGVyJyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgaG92ZXIgYXJlYSBpcyBib3VuZGluZyByZWN0XG4gICAgICAgICAqIEBuYW1lIG1vZHVsZTovenJlbmRlci9ncmFwaGljL0Rpc3BsYXlhYmxlI3JlY3RIb3ZlclxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgcmVjdEhvdmVyOiBmYWxzZSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmVuZGVyIHRoZSBlbGVtZW50IHByb2dyZXNzaXZlbHkgd2hlbiB0aGUgdmFsdWUgPj0gMCxcbiAgICAgICAgICogdXNlZnVsbCBmb3IgbGFyZ2UgZGF0YS5cbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHByb2dyZXNzaXZlOiAtMSxcblxuICAgICAgICBiZWZvcmVCcnVzaDogZnVuY3Rpb24gKGN0eCkge30sXG5cbiAgICAgICAgYWZ0ZXJCcnVzaDogZnVuY3Rpb24gKGN0eCkge30sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWbvuW9oue7mOWItuaWueazlVxuICAgICAgICAgKiBAcGFyYW0ge0NhbnZhczJEUmVuZGVyaW5nQ29udGV4dH0gY3R4XG4gICAgICAgICAqL1xuICAgICAgICAvLyBJbnRlcmZhY2VcbiAgICAgICAgYnJ1c2g6IGZ1bmN0aW9uIChjdHgsIHByZXZFbCkge30sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOiOt+WPluacgOWwj+WMheWbtOebklxuICAgICAgICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9jb3JlL0JvdW5kaW5nUmVjdH1cbiAgICAgICAgICovXG4gICAgICAgIC8vIEludGVyZmFjZVxuICAgICAgICBnZXRCb3VuZGluZ1JlY3Q6IGZ1bmN0aW9uICgpIHt9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDliKTmlq3lnZDmoIcgeCwgeSDmmK/lkKblnKjlm77lvaLkuIpcbiAgICAgICAgICogSWYgZGlzcGxheWFibGUgZWxlbWVudCBjb250YWluIGNvb3JkIHgsIHlcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSB4XG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0geVxuICAgICAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgY29udGFpbjogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlY3RDb250YWluKHgsIHkpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gY2JcbiAgICAgICAgICogQHBhcmFtICB7fSAgIGNvbnRleHRcbiAgICAgICAgICovXG4gICAgICAgIHRyYXZlcnNlOiBmdW5jdGlvbiAoY2IsIGNvbnRleHQpIHtcbiAgICAgICAgICAgIGNiLmNhbGwoY29udGV4dCwgdGhpcyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWIpOaWreWdkOaghyB4LCB5IOaYr+WQpuWcqOWbvuW9oueahOWMheWbtOebkuS4ilxuICAgICAgICAgKiBJZiBib3VuZGluZyByZWN0IG9mIGVsZW1lbnQgY29udGFpbiBjb29yZCB4LCB5XG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0geFxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHlcbiAgICAgICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIHJlY3RDb250YWluOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICAgICAgdmFyIGNvb3JkID0gdGhpcy50cmFuc2Zvcm1Db29yZFRvTG9jYWwoeCwgeSk7XG4gICAgICAgICAgICB2YXIgcmVjdCA9IHRoaXMuZ2V0Qm91bmRpbmdSZWN0KCk7XG4gICAgICAgICAgICByZXR1cm4gcmVjdC5jb250YWluKGNvb3JkWzBdLCBjb29yZFsxXSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOagh+iusOWbvuW9ouWFg+e0oOS4uuiEj++8jOW5tuS4lOWcqOS4i+S4gOW4p+mHjee7mFxuICAgICAgICAgKiBNYXJrIGRpc3BsYXlhYmxlIGVsZW1lbnQgZGlydHkgYW5kIHJlZnJlc2ggbmV4dCBmcmFtZVxuICAgICAgICAgKi9cbiAgICAgICAgZGlydHk6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX19kaXJ0eSA9IHRydWU7XG5cbiAgICAgICAgICAgIHRoaXMuX3JlY3QgPSBudWxsO1xuXG4gICAgICAgICAgICB0aGlzLl9fenIgJiYgdGhpcy5fX3pyLnJlZnJlc2goKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5Zu+5b2i5piv5ZCm5Lya6Kem5Y+R5LqL5Lu2XG4gICAgICAgICAqIElmIGRpc3BsYXlhYmxlIG9iamVjdCBiaW5kZWQgYW55IGV2ZW50XG4gICAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICAvLyBUT0RPLCDpgJrov4cgYmluZCDnu5HlrprnmoTkuovku7ZcbiAgICAgICAgLy8gaXNTaWxlbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gICAgIHJldHVybiAhKFxuICAgICAgICAvLyAgICAgICAgIHRoaXMuaG92ZXJhYmxlIHx8IHRoaXMuZHJhZ2dhYmxlXG4gICAgICAgIC8vICAgICAgICAgfHwgdGhpcy5vbm1vdXNlbW92ZSB8fCB0aGlzLm9ubW91c2VvdmVyIHx8IHRoaXMub25tb3VzZW91dFxuICAgICAgICAvLyAgICAgICAgIHx8IHRoaXMub25tb3VzZWRvd24gfHwgdGhpcy5vbm1vdXNldXAgfHwgdGhpcy5vbmNsaWNrXG4gICAgICAgIC8vICAgICAgICAgfHwgdGhpcy5vbmRyYWdlbnRlciB8fCB0aGlzLm9uZHJhZ292ZXIgfHwgdGhpcy5vbmRyYWdsZWF2ZVxuICAgICAgICAvLyAgICAgICAgIHx8IHRoaXMub25kcm9wXG4gICAgICAgIC8vICAgICApO1xuICAgICAgICAvLyB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQWxpYXMgZm9yIGFuaW1hdGUoJ3N0eWxlJylcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBsb29wXG4gICAgICAgICAqL1xuICAgICAgICBhbmltYXRlU3R5bGU6IGZ1bmN0aW9uIChsb29wKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hbmltYXRlKCdzdHlsZScsIGxvb3ApO1xuICAgICAgICB9LFxuXG4gICAgICAgIGF0dHJLVjogZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChrZXkgIT09ICdzdHlsZScpIHtcbiAgICAgICAgICAgICAgICBFbGVtZW50LnByb3RvdHlwZS5hdHRyS1YuY2FsbCh0aGlzLCBrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuc3R5bGUuc2V0KHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R8c3RyaW5nfSBrZXlcbiAgICAgICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0U3R5bGU6IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLnN0eWxlLnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIHRoaXMuZGlydHkoZmFsc2UpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVzZSBnaXZlbiBzdHlsZSBvYmplY3RcbiAgICAgICAgICogQHBhcmFtICB7T2JqZWN0fSBvYmpcbiAgICAgICAgICovXG4gICAgICAgIHVzZVN0eWxlOiBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgICAgICB0aGlzLnN0eWxlID0gbmV3IFN0eWxlKG9iaik7XG4gICAgICAgICAgICB0aGlzLmRpcnR5KGZhbHNlKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHpyVXRpbC5pbmhlcml0cyhEaXNwbGF5YWJsZSwgRWxlbWVudCk7XG5cbiAgICB6clV0aWwubWl4aW4oRGlzcGxheWFibGUsIFJlY3RUZXh0KTtcbiAgICAvLyB6clV0aWwubWl4aW4oRGlzcGxheWFibGUsIFN0YXRlZnVsKTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gRGlzcGxheWFibGU7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi96cmVuZGVyL2xpYi9ncmFwaGljL0Rpc3BsYXlhYmxlLmpzXG4gKiogbW9kdWxlIGlkID0gN1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBAbW9kdWxlIHpyZW5kZXIvZ3JhcGhpYy9TdHlsZVxuICovXG5cblxuICAgIHZhciBTVFlMRV9DT01NT05fUFJPUFMgPSBbXG4gICAgICAgIFsnc2hhZG93Qmx1cicsIDBdLCBbJ3NoYWRvd09mZnNldFgnLCAwXSwgWydzaGFkb3dPZmZzZXRZJywgMF0sIFsnc2hhZG93Q29sb3InLCAnIzAwMCddLFxuICAgICAgICBbJ2xpbmVDYXAnLCAnYnV0dCddLCBbJ2xpbmVKb2luJywgJ21pdGVyJ10sIFsnbWl0ZXJMaW1pdCcsIDEwXVxuICAgIF07XG5cbiAgICAvLyB2YXIgU0hBRE9XX1BST1BTID0gU1RZTEVfQ09NTU9OX1BST1BTLnNsaWNlKDAsIDQpO1xuICAgIC8vIHZhciBMSU5FX1BST1BTID0gU1RZTEVfQ09NTU9OX1BST1BTLnNsaWNlKDQpO1xuXG4gICAgdmFyIFN0eWxlID0gZnVuY3Rpb24gKG9wdHMpIHtcbiAgICAgICAgdGhpcy5leHRlbmRGcm9tKG9wdHMpO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVMaW5lYXJHcmFkaWVudChjdHgsIG9iaiwgcmVjdCkge1xuICAgICAgICAvLyB2YXIgc2l6ZSA9XG4gICAgICAgIHZhciB4ID0gb2JqLng7XG4gICAgICAgIHZhciB4MiA9IG9iai54MjtcbiAgICAgICAgdmFyIHkgPSBvYmoueTtcbiAgICAgICAgdmFyIHkyID0gb2JqLnkyO1xuXG4gICAgICAgIGlmICghb2JqLmdsb2JhbCkge1xuICAgICAgICAgICAgeCA9IHggKiByZWN0LndpZHRoICsgcmVjdC54O1xuICAgICAgICAgICAgeDIgPSB4MiAqIHJlY3Qud2lkdGggKyByZWN0Lng7XG4gICAgICAgICAgICB5ID0geSAqIHJlY3QuaGVpZ2h0ICsgcmVjdC55O1xuICAgICAgICAgICAgeTIgPSB5MiAqIHJlY3QuaGVpZ2h0ICsgcmVjdC55O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNhbnZhc0dyYWRpZW50ID0gY3R4LmNyZWF0ZUxpbmVhckdyYWRpZW50KHgsIHksIHgyLCB5Mik7XG5cbiAgICAgICAgcmV0dXJuIGNhbnZhc0dyYWRpZW50O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZVJhZGlhbEdyYWRpZW50KGN0eCwgb2JqLCByZWN0KSB7XG4gICAgICAgIHZhciB3aWR0aCA9IHJlY3Qud2lkdGg7XG4gICAgICAgIHZhciBoZWlnaHQgPSByZWN0LmhlaWdodDtcbiAgICAgICAgdmFyIG1pbiA9IE1hdGgubWluKHdpZHRoLCBoZWlnaHQpO1xuXG4gICAgICAgIHZhciB4ID0gb2JqLng7XG4gICAgICAgIHZhciB5ID0gb2JqLnk7XG4gICAgICAgIHZhciByID0gb2JqLnI7XG4gICAgICAgIGlmICghb2JqLmdsb2JhbCkge1xuICAgICAgICAgICAgeCA9IHggKiB3aWR0aCArIHJlY3QueDtcbiAgICAgICAgICAgIHkgPSB5ICogaGVpZ2h0ICsgcmVjdC55O1xuICAgICAgICAgICAgciA9IHIgKiBtaW47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY2FudmFzR3JhZGllbnQgPSBjdHguY3JlYXRlUmFkaWFsR3JhZGllbnQoeCwgeSwgMCwgeCwgeSwgcik7XG5cbiAgICAgICAgcmV0dXJuIGNhbnZhc0dyYWRpZW50O1xuICAgIH1cblxuXG4gICAgU3R5bGUucHJvdG90eXBlID0ge1xuXG4gICAgICAgIGNvbnN0cnVjdG9yOiBTdHlsZSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIGZpbGw6ICcjMDAwMDAwJyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIHN0cm9rZTogbnVsbCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIG9wYWNpdHk6IDEsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtBcnJheS48bnVtYmVyPn1cbiAgICAgICAgICovXG4gICAgICAgIGxpbmVEYXNoOiBudWxsLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgbGluZURhc2hPZmZzZXQ6IDAsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBzaGFkb3dCbHVyOiAwLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgc2hhZG93T2Zmc2V0WDogMCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHNoYWRvd09mZnNldFk6IDAsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBsaW5lV2lkdGg6IDEsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHN0cm9rZSBpZ25vcmUgc2NhbGVcbiAgICAgICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICBzdHJva2VOb1NjYWxlOiBmYWxzZSxcblxuICAgICAgICAvLyBCb3VuZGluZyByZWN0IHRleHQgY29uZmlndXJhdGlvblxuICAgICAgICAvLyBOb3QgYWZmZWN0ZWQgYnkgZWxlbWVudCB0cmFuc2Zvcm1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICB0ZXh0OiBudWxsLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgdGV4dEZpbGw6ICcjMDAwJyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIHRleHRTdHJva2U6IG51bGwsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqICdpbnNpZGUnLCAnbGVmdCcsICdyaWdodCcsICd0b3AnLCAnYm90dG9tJ1xuICAgICAgICAgKiBbeCwgeV1cbiAgICAgICAgICogQHR5cGUge3N0cmluZ3xBcnJheS48bnVtYmVyPn1cbiAgICAgICAgICogQGRlZmF1bHQgJ2luc2lkZSdcbiAgICAgICAgICovXG4gICAgICAgIHRleHRQb3NpdGlvbjogJ2luc2lkZScsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICB0ZXh0QmFzZWxpbmU6IG51bGwsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICB0ZXh0QWxpZ246IG51bGwsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICB0ZXh0VmVydGljYWxBbGlnbjogbnVsbCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogT25seSB1c2VmdWwgaW4gUGF0aCBhbmQgSW1hZ2UgZWxlbWVudFxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGV4dERpc3RhbmNlOiA1LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBPbmx5IHVzZWZ1bCBpbiBQYXRoIGFuZCBJbWFnZSBlbGVtZW50XG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0ZXh0U2hhZG93Qmx1cjogMCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogT25seSB1c2VmdWwgaW4gUGF0aCBhbmQgSW1hZ2UgZWxlbWVudFxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGV4dFNoYWRvd09mZnNldFg6IDAsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE9ubHkgdXNlZnVsIGluIFBhdGggYW5kIEltYWdlIGVsZW1lbnRcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRleHRTaGFkb3dPZmZzZXRZOiAwLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiB0cmFuc2Zvcm0gdGV4dFxuICAgICAgICAgKiBPbmx5IHVzZWZ1bCBpbiBQYXRoIGFuZCBJbWFnZSBlbGVtZW50XG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgdGV4dFRyYW5zZm9ybTogZmFsc2UsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRleHQgcm90YXRlIGFyb3VuZCBwb3NpdGlvbiBvZiBQYXRoIG9yIEltYWdlXG4gICAgICAgICAqIE9ubHkgdXNlZnVsIGluIFBhdGggYW5kIEltYWdlIGVsZW1lbnQgYW5kIHRleHRUcmFuc2Zvcm0gaXMgZmFsc2UuXG4gICAgICAgICAqL1xuICAgICAgICB0ZXh0Um90YXRpb246IDAsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQvZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uXG4gICAgICAgICAqL1xuICAgICAgICBibGVuZDogbnVsbCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAgICAgKi9cbiAgICAgICAgYmluZDogZnVuY3Rpb24gKGN0eCwgZWwsIHByZXZFbCkge1xuICAgICAgICAgICAgdmFyIHN0eWxlID0gdGhpcztcbiAgICAgICAgICAgIHZhciBwcmV2U3R5bGUgPSBwcmV2RWwgJiYgcHJldkVsLnN0eWxlO1xuICAgICAgICAgICAgdmFyIGZpcnN0RHJhdyA9ICFwcmV2U3R5bGU7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgU1RZTEVfQ09NTU9OX1BST1BTLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHByb3AgPSBTVFlMRV9DT01NT05fUFJPUFNbaV07XG4gICAgICAgICAgICAgICAgdmFyIHN0eWxlTmFtZSA9IHByb3BbMF07XG5cbiAgICAgICAgICAgICAgICBpZiAoZmlyc3REcmF3IHx8IHN0eWxlW3N0eWxlTmFtZV0gIT09IHByZXZTdHlsZVtzdHlsZU5hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEZJWE1FIEludmFsaWQgcHJvcGVydHkgdmFsdWUgd2lsbCBjYXVzZSBzdHlsZSBsZWFrIGZyb20gcHJldmlvdXMgZWxlbWVudC5cbiAgICAgICAgICAgICAgICAgICAgY3R4W3N0eWxlTmFtZV0gPSBzdHlsZVtzdHlsZU5hbWVdIHx8IHByb3BbMV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoKGZpcnN0RHJhdyB8fCBzdHlsZS5maWxsICE9PSBwcmV2U3R5bGUuZmlsbCkpIHtcbiAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gc3R5bGUuZmlsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgoZmlyc3REcmF3IHx8IHN0eWxlLnN0cm9rZSAhPT0gcHJldlN0eWxlLnN0cm9rZSkpIHtcbiAgICAgICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBzdHlsZS5zdHJva2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKGZpcnN0RHJhdyB8fCBzdHlsZS5vcGFjaXR5ICE9PSBwcmV2U3R5bGUub3BhY2l0eSkpIHtcbiAgICAgICAgICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSBzdHlsZS5vcGFjaXR5ID09IG51bGwgPyAxIDogc3R5bGUub3BhY2l0eTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKChmaXJzdERyYXcgfHwgc3R5bGUuYmxlbmQgIT09IHByZXZTdHlsZS5ibGVuZCkpIHtcbiAgICAgICAgICAgICAgICBjdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gc3R5bGUuYmxlbmQgfHwgJ3NvdXJjZS1vdmVyJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmhhc1N0cm9rZSgpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxpbmVXaWR0aCA9IHN0eWxlLmxpbmVXaWR0aDtcbiAgICAgICAgICAgICAgICBjdHgubGluZVdpZHRoID0gbGluZVdpZHRoIC8gKFxuICAgICAgICAgICAgICAgICAgICAodGhpcy5zdHJva2VOb1NjYWxlICYmIGVsICYmIGVsLmdldExpbmVTY2FsZSkgPyBlbC5nZXRMaW5lU2NhbGUoKSA6IDFcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGhhc0ZpbGw6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBmaWxsID0gdGhpcy5maWxsO1xuICAgICAgICAgICAgcmV0dXJuIGZpbGwgIT0gbnVsbCAmJiBmaWxsICE9PSAnbm9uZSc7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGFzU3Ryb2tlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgc3Ryb2tlID0gdGhpcy5zdHJva2U7XG4gICAgICAgICAgICByZXR1cm4gc3Ryb2tlICE9IG51bGwgJiYgc3Ryb2tlICE9PSAnbm9uZScgJiYgdGhpcy5saW5lV2lkdGggPiAwO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFeHRlbmQgZnJvbSBvdGhlciBzdHlsZVxuICAgICAgICAgKiBAcGFyYW0ge3pyZW5kZXIvZ3JhcGhpYy9TdHlsZX0gb3RoZXJTdHlsZVxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IG92ZXJ3cml0ZVxuICAgICAgICAgKi9cbiAgICAgICAgZXh0ZW5kRnJvbTogZnVuY3Rpb24gKG90aGVyU3R5bGUsIG92ZXJ3cml0ZSkge1xuICAgICAgICAgICAgaWYgKG90aGVyU3R5bGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0ID0gdGhpcztcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBuYW1lIGluIG90aGVyU3R5bGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG90aGVyU3R5bGUuaGFzT3duUHJvcGVydHkobmFtZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICYmIChvdmVyd3JpdGUgfHwgISB0YXJnZXQuaGFzT3duUHJvcGVydHkobmFtZSkpXG4gICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W25hbWVdID0gb3RoZXJTdHlsZVtuYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQmF0Y2ggc2V0dGluZyBzdHlsZSB3aXRoIGEgZ2l2ZW4gb2JqZWN0XG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fHN0cmluZ30gb2JqXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29ial1cbiAgICAgICAgICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gKG9iaiwgdmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHRoaXNbb2JqXSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5leHRlbmRGcm9tKG9iaiwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENsb25lXG4gICAgICAgICAqIEByZXR1cm4ge3pyZW5kZXIvZ3JhcGhpYy9TdHlsZX0gW2Rlc2NyaXB0aW9uXVxuICAgICAgICAgKi9cbiAgICAgICAgY2xvbmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBuZXdTdHlsZSA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKCk7XG4gICAgICAgICAgICBuZXdTdHlsZS5leHRlbmRGcm9tKHRoaXMsIHRydWUpO1xuICAgICAgICAgICAgcmV0dXJuIG5ld1N0eWxlO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldEdyYWRpZW50OiBmdW5jdGlvbiAoY3R4LCBvYmosIHJlY3QpIHtcbiAgICAgICAgICAgIHZhciBtZXRob2QgPSBvYmoudHlwZSA9PT0gJ3JhZGlhbCcgPyBjcmVhdGVSYWRpYWxHcmFkaWVudCA6IGNyZWF0ZUxpbmVhckdyYWRpZW50O1xuICAgICAgICAgICAgdmFyIGNhbnZhc0dyYWRpZW50ID0gbWV0aG9kKGN0eCwgb2JqLCByZWN0KTtcbiAgICAgICAgICAgIHZhciBjb2xvclN0b3BzID0gb2JqLmNvbG9yU3RvcHM7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbG9yU3RvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjYW52YXNHcmFkaWVudC5hZGRDb2xvclN0b3AoXG4gICAgICAgICAgICAgICAgICAgIGNvbG9yU3RvcHNbaV0ub2Zmc2V0LCBjb2xvclN0b3BzW2ldLmNvbG9yXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjYW52YXNHcmFkaWVudDtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgc3R5bGVQcm90byA9IFN0eWxlLnByb3RvdHlwZTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IFNUWUxFX0NPTU1PTl9QUk9QUy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcHJvcCA9IFNUWUxFX0NPTU1PTl9QUk9QU1tpXTtcbiAgICAgICAgaWYgKCEocHJvcFswXSBpbiBzdHlsZVByb3RvKSkge1xuICAgICAgICAgICAgc3R5bGVQcm90b1twcm9wWzBdXSA9IHByb3BbMV07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBQcm92aWRlIGZvciBvdGhlcnNcbiAgICBTdHlsZS5nZXRHcmFkaWVudCA9IHN0eWxlUHJvdG8uZ2V0R3JhZGllbnQ7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IFN0eWxlO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34venJlbmRlci9saWIvZ3JhcGhpYy9TdHlsZS5qc1xuICoqIG1vZHVsZSBpZCA9IDhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0Jztcbi8qKlxuICogQG1vZHVsZSB6cmVuZGVyL0VsZW1lbnRcbiAqL1xuXG5cbiAgICB2YXIgZ3VpZCA9IHJlcXVpcmUoJy4vY29yZS9ndWlkJyk7XG4gICAgdmFyIEV2ZW50ZnVsID0gcmVxdWlyZSgnLi9taXhpbi9FdmVudGZ1bCcpO1xuICAgIHZhciBUcmFuc2Zvcm1hYmxlID0gcmVxdWlyZSgnLi9taXhpbi9UcmFuc2Zvcm1hYmxlJyk7XG4gICAgdmFyIEFuaW1hdGFibGUgPSByZXF1aXJlKCcuL21peGluL0FuaW1hdGFibGUnKTtcbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnLi9jb3JlL3V0aWwnKTtcblxuICAgIC8qKlxuICAgICAqIEBhbGlhcyBtb2R1bGU6enJlbmRlci9FbGVtZW50XG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQGV4dGVuZHMge21vZHVsZTp6cmVuZGVyL21peGluL0FuaW1hdGFibGV9XG4gICAgICogQGV4dGVuZHMge21vZHVsZTp6cmVuZGVyL21peGluL1RyYW5zZm9ybWFibGV9XG4gICAgICogQGV4dGVuZHMge21vZHVsZTp6cmVuZGVyL21peGluL0V2ZW50ZnVsfVxuICAgICAqL1xuICAgIHZhciBFbGVtZW50ID0gZnVuY3Rpb24gKG9wdHMpIHtcblxuICAgICAgICBUcmFuc2Zvcm1hYmxlLmNhbGwodGhpcywgb3B0cyk7XG4gICAgICAgIEV2ZW50ZnVsLmNhbGwodGhpcywgb3B0cyk7XG4gICAgICAgIEFuaW1hdGFibGUuY2FsbCh0aGlzLCBvcHRzKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICog55S75biD5YWD57SgSURcbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaWQgPSBvcHRzLmlkIHx8IGd1aWQoKTtcbiAgICB9O1xuXG4gICAgRWxlbWVudC5wcm90b3R5cGUgPSB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWFg+e0oOexu+Wei1xuICAgICAgICAgKiBFbGVtZW50IHR5cGVcbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIHR5cGU6ICdlbGVtZW50JyxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5YWD57Sg5ZCN5a2XXG4gICAgICAgICAqIEVsZW1lbnQgbmFtZVxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgbmFtZTogJycsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFpSZW5kZXIg5a6e5L6L5a+56LGh77yM5Lya5ZyoIGVsZW1lbnQg5re75Yqg5YiwIHpyZW5kZXIg5a6e5L6L5Lit5ZCO6Ieq5Yqo6LWL5YC8XG4gICAgICAgICAqIFpSZW5kZXIgaW5zdGFuY2Ugd2lsbCBiZSBhc3NpZ25lZCB3aGVuIGVsZW1lbnQgaXMgYXNzb2NpYXRlZCB3aXRoIHpyZW5kZXJcbiAgICAgICAgICogQG5hbWUgbW9kdWxlOi96cmVuZGVyL0VsZW1lbnQjX196clxuICAgICAgICAgKiBAdHlwZSB7bW9kdWxlOnpyZW5kZXIvWlJlbmRlcn1cbiAgICAgICAgICovXG4gICAgICAgIF9fenI6IG51bGwsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWbvuW9ouaYr+WQpuW/veeVpe+8jOS4unRydWXml7blv73nlaXlm77lvaLnmoTnu5jliLbku6Xlj4rkuovku7bop6blj5FcbiAgICAgICAgICogSWYgaWdub3JlIGRyYXdpbmcgYW5kIGV2ZW50cyBvZiB0aGUgZWxlbWVudCBvYmplY3RcbiAgICAgICAgICogQG5hbWUgbW9kdWxlOi96cmVuZGVyL0VsZW1lbnQjaWdub3JlXG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgaWdub3JlOiBmYWxzZSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog55So5LqO6KOB5Ymq55qE6Lev5b6EKHNoYXBlKe+8jOaJgOaciSBHcm91cCDlhoXnmoTot6/lvoTlnKjnu5jliLbml7bpg73kvJrooqvov5nkuKrot6/lvoToo4HliapcbiAgICAgICAgICog6K+l6Lev5b6E5Lya57un5om/6KKr6KOB5YeP5a+56LGh55qE5Y+Y5o2iXG4gICAgICAgICAqIEB0eXBlIHttb2R1bGU6enJlbmRlci9ncmFwaGljL1BhdGh9XG4gICAgICAgICAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvMmRjb250ZXh0LyNjbGlwcGluZy1yZWdpb25cbiAgICAgICAgICogQHJlYWRPbmx5XG4gICAgICAgICAqL1xuICAgICAgICBjbGlwUGF0aDogbnVsbCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogRHJpZnQgZWxlbWVudFxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IGR4IGR4IG9uIHRoZSBnbG9iYWwgc3BhY2VcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSBkeSBkeSBvbiB0aGUgZ2xvYmFsIHNwYWNlXG4gICAgICAgICAqL1xuICAgICAgICBkcmlmdDogZnVuY3Rpb24gKGR4LCBkeSkge1xuICAgICAgICAgICAgc3dpdGNoICh0aGlzLmRyYWdnYWJsZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2hvcml6b250YWwnOlxuICAgICAgICAgICAgICAgICAgICBkeSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3ZlcnRpY2FsJzpcbiAgICAgICAgICAgICAgICAgICAgZHggPSAwO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIG0gPSB0aGlzLnRyYW5zZm9ybTtcbiAgICAgICAgICAgIGlmICghbSkge1xuICAgICAgICAgICAgICAgIG0gPSB0aGlzLnRyYW5zZm9ybSA9IFsxLCAwLCAwLCAxLCAwLCAwXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1bNF0gKz0gZHg7XG4gICAgICAgICAgICBtWzVdICs9IGR5O1xuXG4gICAgICAgICAgICB0aGlzLmRlY29tcG9zZVRyYW5zZm9ybSgpO1xuICAgICAgICAgICAgdGhpcy5kaXJ0eShmYWxzZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEhvb2sgYmVmb3JlIHVwZGF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgYmVmb3JlVXBkYXRlOiBmdW5jdGlvbiAoKSB7fSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEhvb2sgYWZ0ZXIgdXBkYXRlXG4gICAgICAgICAqL1xuICAgICAgICBhZnRlclVwZGF0ZTogZnVuY3Rpb24gKCkge30sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVcGRhdGUgZWFjaCBmcmFtZVxuICAgICAgICAgKi9cbiAgICAgICAgdXBkYXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVRyYW5zZm9ybSgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gY2JcbiAgICAgICAgICogQHBhcmFtICB7fSAgIGNvbnRleHRcbiAgICAgICAgICovXG4gICAgICAgIHRyYXZlcnNlOiBmdW5jdGlvbiAoY2IsIGNvbnRleHQpIHt9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBhdHRyS1Y6IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoa2V5ID09PSAncG9zaXRpb24nIHx8IGtleSA9PT0gJ3NjYWxlJyB8fCBrZXkgPT09ICdvcmlnaW4nKSB7XG4gICAgICAgICAgICAgICAgLy8gQ29weSB0aGUgYXJyYXlcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRhcmdldCA9IHRoaXNba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldCA9IHRoaXNba2V5XSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFswXSA9IHZhbHVlWzBdO1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXRbMV0gPSB2YWx1ZVsxXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogSGlkZSB0aGUgZWxlbWVudFxuICAgICAgICAgKi9cbiAgICAgICAgaGlkZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5pZ25vcmUgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fX3pyICYmIHRoaXMuX196ci5yZWZyZXNoKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNob3cgdGhlIGVsZW1lbnRcbiAgICAgICAgICovXG4gICAgICAgIHNob3c6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuaWdub3JlID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9fenIgJiYgdGhpcy5fX3pyLnJlZnJlc2goKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd8T2JqZWN0fSBrZXlcbiAgICAgICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAgICAgKi9cbiAgICAgICAgYXR0cjogZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Yga2V5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHRoaXMuYXR0cktWKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoenJVdGlsLmlzT2JqZWN0KGtleSkpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBuYW1lIGluIGtleSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoa2V5Lmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmF0dHJLVihuYW1lLCBrZXlbbmFtZV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmRpcnR5KGZhbHNlKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvZ3JhcGhpYy9QYXRofSBjbGlwUGF0aFxuICAgICAgICAgKi9cbiAgICAgICAgc2V0Q2xpcFBhdGg6IGZ1bmN0aW9uIChjbGlwUGF0aCkge1xuICAgICAgICAgICAgdmFyIHpyID0gdGhpcy5fX3pyO1xuICAgICAgICAgICAgaWYgKHpyKSB7XG4gICAgICAgICAgICAgICAgY2xpcFBhdGguYWRkU2VsZlRvWnIoenIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBSZW1vdmUgcHJldmlvdXMgY2xpcCBwYXRoXG4gICAgICAgICAgICBpZiAodGhpcy5jbGlwUGF0aCAmJiB0aGlzLmNsaXBQYXRoICE9PSBjbGlwUGF0aCkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlQ2xpcFBhdGgoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5jbGlwUGF0aCA9IGNsaXBQYXRoO1xuICAgICAgICAgICAgY2xpcFBhdGguX196ciA9IHpyO1xuICAgICAgICAgICAgY2xpcFBhdGguX19jbGlwVGFyZ2V0ID0gdGhpcztcblxuICAgICAgICAgICAgdGhpcy5kaXJ0eShmYWxzZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqL1xuICAgICAgICByZW1vdmVDbGlwUGF0aDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGNsaXBQYXRoID0gdGhpcy5jbGlwUGF0aDtcbiAgICAgICAgICAgIGlmIChjbGlwUGF0aCkge1xuICAgICAgICAgICAgICAgIGlmIChjbGlwUGF0aC5fX3pyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsaXBQYXRoLnJlbW92ZVNlbGZGcm9tWnIoY2xpcFBhdGguX196cik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY2xpcFBhdGguX196ciA9IG51bGw7XG4gICAgICAgICAgICAgICAgY2xpcFBhdGguX19jbGlwVGFyZ2V0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLmNsaXBQYXRoID0gbnVsbDtcblxuICAgICAgICAgICAgICAgIHRoaXMuZGlydHkoZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBZGQgc2VsZiBmcm9tIHpyZW5kZXIgaW5zdGFuY2UuXG4gICAgICAgICAqIE5vdCByZWN1cnNpdmVseSBiZWNhdXNlIGl0IHdpbGwgYmUgaW52b2tlZCB3aGVuIGVsZW1lbnQgYWRkZWQgdG8gc3RvcmFnZS5cbiAgICAgICAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9aUmVuZGVyfSB6clxuICAgICAgICAgKi9cbiAgICAgICAgYWRkU2VsZlRvWnI6IGZ1bmN0aW9uICh6cikge1xuICAgICAgICAgICAgdGhpcy5fX3pyID0genI7XG4gICAgICAgICAgICAvLyDmt7vliqDliqjnlLtcbiAgICAgICAgICAgIHZhciBhbmltYXRvcnMgPSB0aGlzLmFuaW1hdG9ycztcbiAgICAgICAgICAgIGlmIChhbmltYXRvcnMpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFuaW1hdG9ycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB6ci5hbmltYXRpb24uYWRkQW5pbWF0b3IoYW5pbWF0b3JzW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmNsaXBQYXRoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jbGlwUGF0aC5hZGRTZWxmVG9acih6cik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlbW92ZSBzZWxmIGZyb20genJlbmRlciBpbnN0YW5jZS5cbiAgICAgICAgICogTm90IHJlY3Vyc2l2ZWx5IGJlY2F1c2UgaXQgd2lsbCBiZSBpbnZva2VkIHdoZW4gZWxlbWVudCBhZGRlZCB0byBzdG9yYWdlLlxuICAgICAgICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL1pSZW5kZXJ9IHpyXG4gICAgICAgICAqL1xuICAgICAgICByZW1vdmVTZWxmRnJvbVpyOiBmdW5jdGlvbiAoenIpIHtcbiAgICAgICAgICAgIHRoaXMuX196ciA9IG51bGw7XG4gICAgICAgICAgICAvLyDnp7vpmaTliqjnlLtcbiAgICAgICAgICAgIHZhciBhbmltYXRvcnMgPSB0aGlzLmFuaW1hdG9ycztcbiAgICAgICAgICAgIGlmIChhbmltYXRvcnMpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFuaW1hdG9ycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB6ci5hbmltYXRpb24ucmVtb3ZlQW5pbWF0b3IoYW5pbWF0b3JzW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmNsaXBQYXRoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jbGlwUGF0aC5yZW1vdmVTZWxmRnJvbVpyKHpyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB6clV0aWwubWl4aW4oRWxlbWVudCwgQW5pbWF0YWJsZSk7XG4gICAgenJVdGlsLm1peGluKEVsZW1lbnQsIFRyYW5zZm9ybWFibGUpO1xuICAgIHpyVXRpbC5taXhpbihFbGVtZW50LCBFdmVudGZ1bCk7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IEVsZW1lbnQ7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi96cmVuZGVyL2xpYi9FbGVtZW50LmpzXG4gKiogbW9kdWxlIGlkID0gOVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiB6cmVuZGVyOiDnlJ/miJDllK/kuIBpZFxuICpcbiAqIEBhdXRob3IgZXJyb3JyaWsgKGVycm9ycmlrQGdtYWlsLmNvbSlcbiAqL1xuXG5cbiAgICB2YXIgaWRTdGFydCA9IDB4MDkwNztcblxuICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gaWRTdGFydCsrO1xuICAgIH07XG5cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3pyZW5kZXIvbGliL2NvcmUvZ3VpZC5qc1xuICoqIG1vZHVsZSBpZCA9IDEwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIOS6i+S7tuaJqeWxlVxuICogQG1vZHVsZSB6cmVuZGVyL21peGluL0V2ZW50ZnVsXG4gKiBAYXV0aG9yIEtlbmVyIChAS2VuZXIt5p6X5bOwLCBrZW5lci5saW5mZW5nQGdtYWlsLmNvbSlcbiAqICAgICAgICAgcGlzc2FuZyAoaHR0cHM6Ly93d3cuZ2l0aHViLmNvbS9waXNzYW5nKVxuICovXG5cblxuICAgIHZhciBhcnJ5U2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG5cbiAgICAvKipcbiAgICAgKiDkuovku7bliIblj5HlmahcbiAgICAgKiBAYWxpYXMgbW9kdWxlOnpyZW5kZXIvbWl4aW4vRXZlbnRmdWxcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKi9cbiAgICB2YXIgRXZlbnRmdWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuXyRoYW5kbGVycyA9IHt9O1xuICAgIH07XG5cbiAgICBFdmVudGZ1bC5wcm90b3R5cGUgPSB7XG5cbiAgICAgICAgY29uc3RydWN0b3I6IEV2ZW50ZnVsLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDljZXmrKHop6blj5Hnu5HlrprvvIx0cmlnZ2Vy5ZCO6ZSA5q+BXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudCDkuovku7blkI1cbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlciDlk43lupTlh73mlbBcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHRcbiAgICAgICAgICovXG4gICAgICAgIG9uZTogZnVuY3Rpb24gKGV2ZW50LCBoYW5kbGVyLCBjb250ZXh0KSB7XG4gICAgICAgICAgICB2YXIgX2ggPSB0aGlzLl8kaGFuZGxlcnM7XG5cbiAgICAgICAgICAgIGlmICghaGFuZGxlciB8fCAhZXZlbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFfaFtldmVudF0pIHtcbiAgICAgICAgICAgICAgICBfaFtldmVudF0gPSBbXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBfaFtldmVudF0ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoX2hbZXZlbnRdW2ldLmggPT09IGhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfaFtldmVudF0ucHVzaCh7XG4gICAgICAgICAgICAgICAgaDogaGFuZGxlcixcbiAgICAgICAgICAgICAgICBvbmU6IHRydWUsXG4gICAgICAgICAgICAgICAgY3R4OiBjb250ZXh0IHx8IHRoaXNcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog57uR5a6a5LqL5Lu2XG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudCDkuovku7blkI1cbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlciDkuovku7blpITnkIblh73mlbBcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IFtjb250ZXh0XVxuICAgICAgICAgKi9cbiAgICAgICAgb246IGZ1bmN0aW9uIChldmVudCwgaGFuZGxlciwgY29udGV4dCkge1xuICAgICAgICAgICAgdmFyIF9oID0gdGhpcy5fJGhhbmRsZXJzO1xuXG4gICAgICAgICAgICBpZiAoIWhhbmRsZXIgfHwgIWV2ZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghX2hbZXZlbnRdKSB7XG4gICAgICAgICAgICAgICAgX2hbZXZlbnRdID0gW107XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgX2hbZXZlbnRdLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKF9oW2V2ZW50XVtpXS5oID09PSBoYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2hbZXZlbnRdLnB1c2goe1xuICAgICAgICAgICAgICAgIGg6IGhhbmRsZXIsXG4gICAgICAgICAgICAgICAgb25lOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBjdHg6IGNvbnRleHQgfHwgdGhpc1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmmK/lkKbnu5Hlrprkuobkuovku7ZcbiAgICAgICAgICogQHBhcmFtICB7c3RyaW5nfSAgZXZlbnRcbiAgICAgICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIGlzU2lsZW50OiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBfaCA9IHRoaXMuXyRoYW5kbGVycztcbiAgICAgICAgICAgIHJldHVybiBfaFtldmVudF0gJiYgX2hbZXZlbnRdLmxlbmd0aDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog6Kej57uR5LqL5Lu2XG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudCDkuovku7blkI1cbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2hhbmRsZXJdIOS6i+S7tuWkhOeQhuWHveaVsFxuICAgICAgICAgKi9cbiAgICAgICAgb2ZmOiBmdW5jdGlvbiAoZXZlbnQsIGhhbmRsZXIpIHtcbiAgICAgICAgICAgIHZhciBfaCA9IHRoaXMuXyRoYW5kbGVycztcblxuICAgICAgICAgICAgaWYgKCFldmVudCkge1xuICAgICAgICAgICAgICAgIHRoaXMuXyRoYW5kbGVycyA9IHt9O1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaGFuZGxlcikge1xuICAgICAgICAgICAgICAgIGlmIChfaFtldmVudF0pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5ld0xpc3QgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBfaFtldmVudF0ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2hbZXZlbnRdW2ldWydoJ10gIT0gaGFuZGxlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0xpc3QucHVzaChfaFtldmVudF1baV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF9oW2V2ZW50XSA9IG5ld0xpc3Q7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKF9oW2V2ZW50XSAmJiBfaFtldmVudF0ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBfaFtldmVudF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIF9oW2V2ZW50XTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOS6i+S7tuWIhuWPkVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSDkuovku7bnsbvlnotcbiAgICAgICAgICovXG4gICAgICAgIHRyaWdnZXI6IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fJGhhbmRsZXJzW3R5cGVdKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgICAgICAgICAgdmFyIGFyZ0xlbiA9IGFyZ3MubGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgaWYgKGFyZ0xlbiA+IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgYXJncyA9IGFycnlTbGljZS5jYWxsKGFyZ3MsIDEpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBfaCA9IHRoaXMuXyRoYW5kbGVyc1t0eXBlXTtcbiAgICAgICAgICAgICAgICB2YXIgbGVuID0gX2gubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOykge1xuICAgICAgICAgICAgICAgICAgICAvLyBPcHRpbWl6ZSBhZHZpc2UgZnJvbSBiYWNrYm9uZVxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGFyZ0xlbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9oW2ldWydoJ10uY2FsbChfaFtpXVsnY3R4J10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9oW2ldWydoJ10uY2FsbChfaFtpXVsnY3R4J10sIGFyZ3NbMV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9oW2ldWydoJ10uY2FsbChfaFtpXVsnY3R4J10sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBoYXZlIG1vcmUgdGhhbiAyIGdpdmVuIGFyZ3VtZW50c1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9oW2ldWydoJ10uYXBwbHkoX2hbaV1bJ2N0eCddLCBhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChfaFtpXVsnb25lJ10pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9oLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlbi0tO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5bim5pyJY29udGV4dOeahOS6i+S7tuWIhuWPkSwg5pyA5ZCO5LiA5Liq5Y+C5pWw5piv5LqL5Lu25Zue6LCD55qEY29udGV4dFxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSDkuovku7bnsbvlnotcbiAgICAgICAgICovXG4gICAgICAgIHRyaWdnZXJXaXRoQ29udGV4dDogZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl8kaGFuZGxlcnNbdHlwZV0pIHtcbiAgICAgICAgICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgICAgICAgICB2YXIgYXJnTGVuID0gYXJncy5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgICBpZiAoYXJnTGVuID4gNCkge1xuICAgICAgICAgICAgICAgICAgICBhcmdzID0gYXJyeVNsaWNlLmNhbGwoYXJncywgMSwgYXJncy5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGN0eCA9IGFyZ3NbYXJncy5sZW5ndGggLSAxXTtcblxuICAgICAgICAgICAgICAgIHZhciBfaCA9IHRoaXMuXyRoYW5kbGVyc1t0eXBlXTtcbiAgICAgICAgICAgICAgICB2YXIgbGVuID0gX2gubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOykge1xuICAgICAgICAgICAgICAgICAgICAvLyBPcHRpbWl6ZSBhZHZpc2UgZnJvbSBiYWNrYm9uZVxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGFyZ0xlbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9oW2ldWydoJ10uY2FsbChjdHgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9oW2ldWydoJ10uY2FsbChjdHgsIGFyZ3NbMV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9oW2ldWydoJ10uY2FsbChjdHgsIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBoYXZlIG1vcmUgdGhhbiAyIGdpdmVuIGFyZ3VtZW50c1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9oW2ldWydoJ10uYXBwbHkoY3R4LCBhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChfaFtpXVsnb25lJ10pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9oLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlbi0tO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvLyDlr7nosaHlj6/ku6XpgJrov4cgb254eHh4IOe7keWumuS6i+S7tlxuICAgIC8qKlxuICAgICAqIEBldmVudCBtb2R1bGU6enJlbmRlci9taXhpbi9FdmVudGZ1bCNvbmNsaWNrXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAqIEBkZWZhdWx0IG51bGxcbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBAZXZlbnQgbW9kdWxlOnpyZW5kZXIvbWl4aW4vRXZlbnRmdWwjb25tb3VzZW92ZXJcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICogQGRlZmF1bHQgbnVsbFxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIEBldmVudCBtb2R1bGU6enJlbmRlci9taXhpbi9FdmVudGZ1bCNvbm1vdXNlb3V0XG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAqIEBkZWZhdWx0IG51bGxcbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBAZXZlbnQgbW9kdWxlOnpyZW5kZXIvbWl4aW4vRXZlbnRmdWwjb25tb3VzZW1vdmVcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICogQGRlZmF1bHQgbnVsbFxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIEBldmVudCBtb2R1bGU6enJlbmRlci9taXhpbi9FdmVudGZ1bCNvbm1vdXNld2hlZWxcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICogQGRlZmF1bHQgbnVsbFxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIEBldmVudCBtb2R1bGU6enJlbmRlci9taXhpbi9FdmVudGZ1bCNvbm1vdXNlZG93blxuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICovXG4gICAgLyoqXG4gICAgICogQGV2ZW50IG1vZHVsZTp6cmVuZGVyL21peGluL0V2ZW50ZnVsI29ubW91c2V1cFxuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICovXG4gICAgLyoqXG4gICAgICogQGV2ZW50IG1vZHVsZTp6cmVuZGVyL21peGluL0V2ZW50ZnVsI29uZHJhZ3N0YXJ0XG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAqIEBkZWZhdWx0IG51bGxcbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBAZXZlbnQgbW9kdWxlOnpyZW5kZXIvbWl4aW4vRXZlbnRmdWwjb25kcmFnZW5kXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAqIEBkZWZhdWx0IG51bGxcbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBAZXZlbnQgbW9kdWxlOnpyZW5kZXIvbWl4aW4vRXZlbnRmdWwjb25kcmFnZW50ZXJcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICogQGRlZmF1bHQgbnVsbFxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIEBldmVudCBtb2R1bGU6enJlbmRlci9taXhpbi9FdmVudGZ1bCNvbmRyYWdsZWF2ZVxuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICovXG4gICAgLyoqXG4gICAgICogQGV2ZW50IG1vZHVsZTp6cmVuZGVyL21peGluL0V2ZW50ZnVsI29uZHJhZ292ZXJcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICogQGRlZmF1bHQgbnVsbFxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIEBldmVudCBtb2R1bGU6enJlbmRlci9taXhpbi9FdmVudGZ1bCNvbmRyb3BcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICogQGRlZmF1bHQgbnVsbFxuICAgICAqL1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBFdmVudGZ1bDtcblxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34venJlbmRlci9saWIvbWl4aW4vRXZlbnRmdWwuanNcbiAqKiBtb2R1bGUgaWQgPSAxMVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuLyoqXG4gKiDmj5Dkvpvlj5jmjaLmianlsZVcbiAqIEBtb2R1bGUgenJlbmRlci9taXhpbi9UcmFuc2Zvcm1hYmxlXG4gKiBAYXV0aG9yIHBpc3NhbmcgKGh0dHBzOi8vd3d3LmdpdGh1Yi5jb20vcGlzc2FuZylcbiAqL1xuXG5cbiAgICB2YXIgbWF0cml4ID0gcmVxdWlyZSgnLi4vY29yZS9tYXRyaXgnKTtcbiAgICB2YXIgdmVjdG9yID0gcmVxdWlyZSgnLi4vY29yZS92ZWN0b3InKTtcbiAgICB2YXIgbUlkZW50aXR5ID0gbWF0cml4LmlkZW50aXR5O1xuXG4gICAgdmFyIEVQU0lMT04gPSA1ZS01O1xuXG4gICAgZnVuY3Rpb24gaXNOb3RBcm91bmRaZXJvKHZhbCkge1xuICAgICAgICByZXR1cm4gdmFsID4gRVBTSUxPTiB8fCB2YWwgPCAtRVBTSUxPTjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAYWxpYXMgbW9kdWxlOnpyZW5kZXIvbWl4aW4vVHJhbnNmb3JtYWJsZVxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIHZhciBUcmFuc2Zvcm1hYmxlID0gZnVuY3Rpb24gKG9wdHMpIHtcbiAgICAgICAgb3B0cyA9IG9wdHMgfHwge307XG4gICAgICAgIC8vIElmIHRoZXJlIGFyZSBubyBnaXZlbiBwb3NpdGlvbiwgcm90YXRpb24sIHNjYWxlXG4gICAgICAgIGlmICghb3B0cy5wb3NpdGlvbikge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiDlubPnp7tcbiAgICAgICAgICAgICAqIEB0eXBlIHtBcnJheS48bnVtYmVyPn1cbiAgICAgICAgICAgICAqIEBkZWZhdWx0IFswLCAwXVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uID0gWzAsIDBdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRzLnJvdGF0aW9uID09IG51bGwpIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICog5peL6L2sXG4gICAgICAgICAgICAgKiBAdHlwZSB7QXJyYXkuPG51bWJlcj59XG4gICAgICAgICAgICAgKiBAZGVmYXVsdCAwXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMucm90YXRpb24gPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmICghb3B0cy5zY2FsZSkge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiDnvKnmlL5cbiAgICAgICAgICAgICAqIEB0eXBlIHtBcnJheS48bnVtYmVyPn1cbiAgICAgICAgICAgICAqIEBkZWZhdWx0IFsxLCAxXVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLnNjYWxlID0gWzEsIDFdO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiDml4vovazlkoznvKnmlL7nmoTljp/ngrlcbiAgICAgICAgICogQHR5cGUge0FycmF5LjxudW1iZXI+fVxuICAgICAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9yaWdpbiA9IHRoaXMub3JpZ2luIHx8IG51bGw7XG4gICAgfTtcblxuICAgIHZhciB0cmFuc2Zvcm1hYmxlUHJvdG8gPSBUcmFuc2Zvcm1hYmxlLnByb3RvdHlwZTtcbiAgICB0cmFuc2Zvcm1hYmxlUHJvdG8udHJhbnNmb3JtID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIOWIpOaWreaYr+WQpumcgOimgeacieWdkOagh+WPmOaNolxuICAgICAqIOWmguaenOacieWdkOagh+WPmOaNoiwg5YiZ5LuOcG9zaXRpb24sIHJvdGF0aW9uLCBzY2FsZeS7peWPiueItuiKgueCueeahHRyYW5zZm9ybeiuoeeul+WHuuiHqui6q+eahHRyYW5zZm9ybeefqemYtVxuICAgICAqL1xuICAgIHRyYW5zZm9ybWFibGVQcm90by5uZWVkTG9jYWxUcmFuc2Zvcm0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBpc05vdEFyb3VuZFplcm8odGhpcy5yb3RhdGlvbilcbiAgICAgICAgICAgIHx8IGlzTm90QXJvdW5kWmVybyh0aGlzLnBvc2l0aW9uWzBdKVxuICAgICAgICAgICAgfHwgaXNOb3RBcm91bmRaZXJvKHRoaXMucG9zaXRpb25bMV0pXG4gICAgICAgICAgICB8fCBpc05vdEFyb3VuZFplcm8odGhpcy5zY2FsZVswXSAtIDEpXG4gICAgICAgICAgICB8fCBpc05vdEFyb3VuZFplcm8odGhpcy5zY2FsZVsxXSAtIDEpO1xuICAgIH07XG5cbiAgICB0cmFuc2Zvcm1hYmxlUHJvdG8udXBkYXRlVHJhbnNmb3JtID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnQ7XG4gICAgICAgIHZhciBwYXJlbnRIYXNUcmFuc2Zvcm0gPSBwYXJlbnQgJiYgcGFyZW50LnRyYW5zZm9ybTtcbiAgICAgICAgdmFyIG5lZWRMb2NhbFRyYW5zZm9ybSA9IHRoaXMubmVlZExvY2FsVHJhbnNmb3JtKCk7XG5cbiAgICAgICAgdmFyIG0gPSB0aGlzLnRyYW5zZm9ybTtcbiAgICAgICAgaWYgKCEobmVlZExvY2FsVHJhbnNmb3JtIHx8IHBhcmVudEhhc1RyYW5zZm9ybSkpIHtcbiAgICAgICAgICAgIG0gJiYgbUlkZW50aXR5KG0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgbSA9IG0gfHwgbWF0cml4LmNyZWF0ZSgpO1xuXG4gICAgICAgIGlmIChuZWVkTG9jYWxUcmFuc2Zvcm0pIHtcbiAgICAgICAgICAgIHRoaXMuZ2V0TG9jYWxUcmFuc2Zvcm0obSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtSWRlbnRpdHkobSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyDlupTnlKjniLboioLngrnlj5jmjaJcbiAgICAgICAgaWYgKHBhcmVudEhhc1RyYW5zZm9ybSkge1xuICAgICAgICAgICAgaWYgKG5lZWRMb2NhbFRyYW5zZm9ybSkge1xuICAgICAgICAgICAgICAgIG1hdHJpeC5tdWwobSwgcGFyZW50LnRyYW5zZm9ybSwgbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBtYXRyaXguY29weShtLCBwYXJlbnQudHJhbnNmb3JtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyDkv53lrZjov5nkuKrlj5jmjaLnn6npmLVcbiAgICAgICAgdGhpcy50cmFuc2Zvcm0gPSBtO1xuXG4gICAgICAgIHRoaXMuaW52VHJhbnNmb3JtID0gdGhpcy5pbnZUcmFuc2Zvcm0gfHwgbWF0cml4LmNyZWF0ZSgpO1xuICAgICAgICBtYXRyaXguaW52ZXJ0KHRoaXMuaW52VHJhbnNmb3JtLCBtKTtcbiAgICB9O1xuXG4gICAgdHJhbnNmb3JtYWJsZVByb3RvLmdldExvY2FsVHJhbnNmb3JtID0gZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgbSA9IG0gfHwgW107XG4gICAgICAgIG1JZGVudGl0eShtKTtcblxuICAgICAgICB2YXIgb3JpZ2luID0gdGhpcy5vcmlnaW47XG5cbiAgICAgICAgdmFyIHNjYWxlID0gdGhpcy5zY2FsZTtcbiAgICAgICAgdmFyIHJvdGF0aW9uID0gdGhpcy5yb3RhdGlvbjtcbiAgICAgICAgdmFyIHBvc2l0aW9uID0gdGhpcy5wb3NpdGlvbjtcbiAgICAgICAgaWYgKG9yaWdpbikge1xuICAgICAgICAgICAgLy8gVHJhbnNsYXRlIHRvIG9yaWdpblxuICAgICAgICAgICAgbVs0XSAtPSBvcmlnaW5bMF07XG4gICAgICAgICAgICBtWzVdIC09IG9yaWdpblsxXTtcbiAgICAgICAgfVxuICAgICAgICBtYXRyaXguc2NhbGUobSwgbSwgc2NhbGUpO1xuICAgICAgICBpZiAocm90YXRpb24pIHtcbiAgICAgICAgICAgIG1hdHJpeC5yb3RhdGUobSwgbSwgcm90YXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcmlnaW4pIHtcbiAgICAgICAgICAgIC8vIFRyYW5zbGF0ZSBiYWNrIGZyb20gb3JpZ2luXG4gICAgICAgICAgICBtWzRdICs9IG9yaWdpblswXTtcbiAgICAgICAgICAgIG1bNV0gKz0gb3JpZ2luWzFdO1xuICAgICAgICB9XG5cbiAgICAgICAgbVs0XSArPSBwb3NpdGlvblswXTtcbiAgICAgICAgbVs1XSArPSBwb3NpdGlvblsxXTtcblxuICAgICAgICByZXR1cm4gbTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIOWwhuiHquW3seeahHRyYW5zZm9ybeW6lOeUqOWIsGNvbnRleHTkuIpcbiAgICAgKiBAcGFyYW0ge0NvbnRleHQyRH0gY3R4XG4gICAgICovXG4gICAgdHJhbnNmb3JtYWJsZVByb3RvLnNldFRyYW5zZm9ybSA9IGZ1bmN0aW9uIChjdHgpIHtcbiAgICAgICAgdmFyIG0gPSB0aGlzLnRyYW5zZm9ybTtcbiAgICAgICAgdmFyIGRwciA9IGN0eC5kcHIgfHwgMTtcbiAgICAgICAgaWYgKG0pIHtcbiAgICAgICAgICAgIGN0eC5zZXRUcmFuc2Zvcm0oZHByICogbVswXSwgZHByICogbVsxXSwgZHByICogbVsyXSwgZHByICogbVszXSwgZHByICogbVs0XSwgZHByICogbVs1XSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjdHguc2V0VHJhbnNmb3JtKGRwciwgMCwgMCwgZHByLCAwLCAwKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB0cmFuc2Zvcm1hYmxlUHJvdG8ucmVzdG9yZVRyYW5zZm9ybSA9IGZ1bmN0aW9uIChjdHgpIHtcbiAgICAgICAgdmFyIG0gPSB0aGlzLnRyYW5zZm9ybTtcbiAgICAgICAgdmFyIGRwciA9IGN0eC5kcHIgfHwgMTtcbiAgICAgICAgY3R4LnNldFRyYW5zZm9ybShkcHIsIDAsIDAsIGRwciwgMCwgMCk7XG4gICAgfVxuXG4gICAgdmFyIHRtcFRyYW5zZm9ybSA9IFtdO1xuXG4gICAgLyoqXG4gICAgICog5YiG6KejYHRyYW5zZm9ybWDnn6npmLXliLBgcG9zaXRpb25gLCBgcm90YXRpb25gLCBgc2NhbGVgXG4gICAgICovXG4gICAgdHJhbnNmb3JtYWJsZVByb3RvLmRlY29tcG9zZVRyYW5zZm9ybSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnRyYW5zZm9ybSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwYXJlbnQgPSB0aGlzLnBhcmVudDtcbiAgICAgICAgdmFyIG0gPSB0aGlzLnRyYW5zZm9ybTtcbiAgICAgICAgaWYgKHBhcmVudCAmJiBwYXJlbnQudHJhbnNmb3JtKSB7XG4gICAgICAgICAgICAvLyBHZXQgbG9jYWwgdHJhbnNmb3JtIGFuZCBkZWNvbXBvc2UgdGhlbSB0byBwb3NpdGlvbiwgc2NhbGUsIHJvdGF0aW9uXG4gICAgICAgICAgICBtYXRyaXgubXVsKHRtcFRyYW5zZm9ybSwgcGFyZW50LmludlRyYW5zZm9ybSwgbSk7XG4gICAgICAgICAgICBtID0gdG1wVHJhbnNmb3JtO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzeCA9IG1bMF0gKiBtWzBdICsgbVsxXSAqIG1bMV07XG4gICAgICAgIHZhciBzeSA9IG1bMl0gKiBtWzJdICsgbVszXSAqIG1bM107XG4gICAgICAgIHZhciBwb3NpdGlvbiA9IHRoaXMucG9zaXRpb247XG4gICAgICAgIHZhciBzY2FsZSA9IHRoaXMuc2NhbGU7XG4gICAgICAgIGlmIChpc05vdEFyb3VuZFplcm8oc3ggLSAxKSkge1xuICAgICAgICAgICAgc3ggPSBNYXRoLnNxcnQoc3gpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc05vdEFyb3VuZFplcm8oc3kgLSAxKSkge1xuICAgICAgICAgICAgc3kgPSBNYXRoLnNxcnQoc3kpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtWzBdIDwgMCkge1xuICAgICAgICAgICAgc3ggPSAtc3g7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1bM10gPCAwKSB7XG4gICAgICAgICAgICBzeSA9IC1zeTtcbiAgICAgICAgfVxuICAgICAgICBwb3NpdGlvblswXSA9IG1bNF07XG4gICAgICAgIHBvc2l0aW9uWzFdID0gbVs1XTtcbiAgICAgICAgc2NhbGVbMF0gPSBzeDtcbiAgICAgICAgc2NhbGVbMV0gPSBzeTtcbiAgICAgICAgdGhpcy5yb3RhdGlvbiA9IE1hdGguYXRhbjIoLW1bMV0gLyBzeSwgbVswXSAvIHN4KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IGdsb2JhbCBzY2FsZVxuICAgICAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fVxuICAgICAqL1xuICAgIHRyYW5zZm9ybWFibGVQcm90by5nZXRHbG9iYWxTY2FsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG0gPSB0aGlzLnRyYW5zZm9ybTtcbiAgICAgICAgaWYgKCFtKSB7XG4gICAgICAgICAgICByZXR1cm4gWzEsIDFdO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzeCA9IE1hdGguc3FydChtWzBdICogbVswXSArIG1bMV0gKiBtWzFdKTtcbiAgICAgICAgdmFyIHN5ID0gTWF0aC5zcXJ0KG1bMl0gKiBtWzJdICsgbVszXSAqIG1bM10pO1xuICAgICAgICBpZiAobVswXSA8IDApIHtcbiAgICAgICAgICAgIHN4ID0gLXN4O1xuICAgICAgICB9XG4gICAgICAgIGlmIChtWzNdIDwgMCkge1xuICAgICAgICAgICAgc3kgPSAtc3k7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtzeCwgc3ldO1xuICAgIH07XG4gICAgLyoqXG4gICAgICog5Y+Y5o2i5Z2Q5qCH5L2N572u5YiwIHNoYXBlIOeahOWxgOmDqOWdkOagh+epuumXtFxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gICAgICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59XG4gICAgICovXG4gICAgdHJhbnNmb3JtYWJsZVByb3RvLnRyYW5zZm9ybUNvb3JkVG9Mb2NhbCA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgIHZhciB2MiA9IFt4LCB5XTtcbiAgICAgICAgdmFyIGludlRyYW5zZm9ybSA9IHRoaXMuaW52VHJhbnNmb3JtO1xuICAgICAgICBpZiAoaW52VHJhbnNmb3JtKSB7XG4gICAgICAgICAgICB2ZWN0b3IuYXBwbHlUcmFuc2Zvcm0odjIsIHYyLCBpbnZUcmFuc2Zvcm0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2MjtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICog5Y+Y5o2i5bGA6YOo5Z2Q5qCH5L2N572u5Yiw5YWo5bGA5Z2Q5qCH56m66Ze0XG4gICAgICogQG1ldGhvZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHlcbiAgICAgKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn1cbiAgICAgKi9cbiAgICB0cmFuc2Zvcm1hYmxlUHJvdG8udHJhbnNmb3JtQ29vcmRUb0dsb2JhbCA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgIHZhciB2MiA9IFt4LCB5XTtcbiAgICAgICAgdmFyIHRyYW5zZm9ybSA9IHRoaXMudHJhbnNmb3JtO1xuICAgICAgICBpZiAodHJhbnNmb3JtKSB7XG4gICAgICAgICAgICB2ZWN0b3IuYXBwbHlUcmFuc2Zvcm0odjIsIHYyLCB0cmFuc2Zvcm0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2MjtcbiAgICB9O1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBUcmFuc2Zvcm1hYmxlO1xuXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi96cmVuZGVyL2xpYi9taXhpbi9UcmFuc2Zvcm1hYmxlLmpzXG4gKiogbW9kdWxlIGlkID0gMTJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlxuICAgIHZhciBBcnJheUN0b3IgPSB0eXBlb2YgRmxvYXQzMkFycmF5ID09PSAndW5kZWZpbmVkJ1xuICAgICAgICA/IEFycmF5XG4gICAgICAgIDogRmxvYXQzMkFycmF5O1xuICAgIC8qKlxuICAgICAqIDN4MuefqemYteaTjeS9nOexu1xuICAgICAqIEBleHBvcnRzIHpyZW5kZXIvdG9vbC9tYXRyaXhcbiAgICAgKi9cbiAgICB2YXIgbWF0cml4ID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICog5Yib5bu65LiA5Liq5Y2V5L2N55+p6Zi1XG4gICAgICAgICAqIEByZXR1cm4ge0Zsb2F0MzJBcnJheXxBcnJheS48bnVtYmVyPn1cbiAgICAgICAgICovXG4gICAgICAgIGNyZWF0ZSA6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIG91dCA9IG5ldyBBcnJheUN0b3IoNik7XG4gICAgICAgICAgICBtYXRyaXguaWRlbnRpdHkob3V0KTtcblxuICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOiuvue9ruefqemYteS4uuWNleS9jeefqemYtVxuICAgICAgICAgKiBAcGFyYW0ge0Zsb2F0MzJBcnJheXxBcnJheS48bnVtYmVyPn0gb3V0XG4gICAgICAgICAqL1xuICAgICAgICBpZGVudGl0eSA6IGZ1bmN0aW9uKG91dCkge1xuICAgICAgICAgICAgb3V0WzBdID0gMTtcbiAgICAgICAgICAgIG91dFsxXSA9IDA7XG4gICAgICAgICAgICBvdXRbMl0gPSAwO1xuICAgICAgICAgICAgb3V0WzNdID0gMTtcbiAgICAgICAgICAgIG91dFs0XSA9IDA7XG4gICAgICAgICAgICBvdXRbNV0gPSAwO1xuICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWkjeWItuefqemYtVxuICAgICAgICAgKiBAcGFyYW0ge0Zsb2F0MzJBcnJheXxBcnJheS48bnVtYmVyPn0gb3V0XG4gICAgICAgICAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fEFycmF5LjxudW1iZXI+fSBtXG4gICAgICAgICAqL1xuICAgICAgICBjb3B5OiBmdW5jdGlvbihvdXQsIG0pIHtcbiAgICAgICAgICAgIG91dFswXSA9IG1bMF07XG4gICAgICAgICAgICBvdXRbMV0gPSBtWzFdO1xuICAgICAgICAgICAgb3V0WzJdID0gbVsyXTtcbiAgICAgICAgICAgIG91dFszXSA9IG1bM107XG4gICAgICAgICAgICBvdXRbNF0gPSBtWzRdO1xuICAgICAgICAgICAgb3V0WzVdID0gbVs1XTtcbiAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDnn6npmLXnm7jkuZhcbiAgICAgICAgICogQHBhcmFtIHtGbG9hdDMyQXJyYXl8QXJyYXkuPG51bWJlcj59IG91dFxuICAgICAgICAgKiBAcGFyYW0ge0Zsb2F0MzJBcnJheXxBcnJheS48bnVtYmVyPn0gbTFcbiAgICAgICAgICogQHBhcmFtIHtGbG9hdDMyQXJyYXl8QXJyYXkuPG51bWJlcj59IG0yXG4gICAgICAgICAqL1xuICAgICAgICBtdWwgOiBmdW5jdGlvbiAob3V0LCBtMSwgbTIpIHtcbiAgICAgICAgICAgIC8vIENvbnNpZGVyIG1hdHJpeC5tdWwobSwgbTIsIG0pO1xuICAgICAgICAgICAgLy8gd2hlcmUgb3V0IGlzIHRoZSBzYW1lIGFzIG0yLlxuICAgICAgICAgICAgLy8gU28gdXNlIHRlbXAgdmFyaWFibGUgdG8gZXNjYXBlIGVycm9yLlxuICAgICAgICAgICAgdmFyIG91dDAgPSBtMVswXSAqIG0yWzBdICsgbTFbMl0gKiBtMlsxXTtcbiAgICAgICAgICAgIHZhciBvdXQxID0gbTFbMV0gKiBtMlswXSArIG0xWzNdICogbTJbMV07XG4gICAgICAgICAgICB2YXIgb3V0MiA9IG0xWzBdICogbTJbMl0gKyBtMVsyXSAqIG0yWzNdO1xuICAgICAgICAgICAgdmFyIG91dDMgPSBtMVsxXSAqIG0yWzJdICsgbTFbM10gKiBtMlszXTtcbiAgICAgICAgICAgIHZhciBvdXQ0ID0gbTFbMF0gKiBtMls0XSArIG0xWzJdICogbTJbNV0gKyBtMVs0XTtcbiAgICAgICAgICAgIHZhciBvdXQ1ID0gbTFbMV0gKiBtMls0XSArIG0xWzNdICogbTJbNV0gKyBtMVs1XTtcbiAgICAgICAgICAgIG91dFswXSA9IG91dDA7XG4gICAgICAgICAgICBvdXRbMV0gPSBvdXQxO1xuICAgICAgICAgICAgb3V0WzJdID0gb3V0MjtcbiAgICAgICAgICAgIG91dFszXSA9IG91dDM7XG4gICAgICAgICAgICBvdXRbNF0gPSBvdXQ0O1xuICAgICAgICAgICAgb3V0WzVdID0gb3V0NTtcbiAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlubPnp7vlj5jmjaJcbiAgICAgICAgICogQHBhcmFtIHtGbG9hdDMyQXJyYXl8QXJyYXkuPG51bWJlcj59IG91dFxuICAgICAgICAgKiBAcGFyYW0ge0Zsb2F0MzJBcnJheXxBcnJheS48bnVtYmVyPn0gYVxuICAgICAgICAgKiBAcGFyYW0ge0Zsb2F0MzJBcnJheXxBcnJheS48bnVtYmVyPn0gdlxuICAgICAgICAgKi9cbiAgICAgICAgdHJhbnNsYXRlIDogZnVuY3Rpb24ob3V0LCBhLCB2KSB7XG4gICAgICAgICAgICBvdXRbMF0gPSBhWzBdO1xuICAgICAgICAgICAgb3V0WzFdID0gYVsxXTtcbiAgICAgICAgICAgIG91dFsyXSA9IGFbMl07XG4gICAgICAgICAgICBvdXRbM10gPSBhWzNdO1xuICAgICAgICAgICAgb3V0WzRdID0gYVs0XSArIHZbMF07XG4gICAgICAgICAgICBvdXRbNV0gPSBhWzVdICsgdlsxXTtcbiAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDml4vovazlj5jmjaJcbiAgICAgICAgICogQHBhcmFtIHtGbG9hdDMyQXJyYXl8QXJyYXkuPG51bWJlcj59IG91dFxuICAgICAgICAgKiBAcGFyYW0ge0Zsb2F0MzJBcnJheXxBcnJheS48bnVtYmVyPn0gYVxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gcmFkXG4gICAgICAgICAqL1xuICAgICAgICByb3RhdGUgOiBmdW5jdGlvbihvdXQsIGEsIHJhZCkge1xuICAgICAgICAgICAgdmFyIGFhID0gYVswXTtcbiAgICAgICAgICAgIHZhciBhYyA9IGFbMl07XG4gICAgICAgICAgICB2YXIgYXR4ID0gYVs0XTtcbiAgICAgICAgICAgIHZhciBhYiA9IGFbMV07XG4gICAgICAgICAgICB2YXIgYWQgPSBhWzNdO1xuICAgICAgICAgICAgdmFyIGF0eSA9IGFbNV07XG4gICAgICAgICAgICB2YXIgc3QgPSBNYXRoLnNpbihyYWQpO1xuICAgICAgICAgICAgdmFyIGN0ID0gTWF0aC5jb3MocmFkKTtcblxuICAgICAgICAgICAgb3V0WzBdID0gYWEgKiBjdCArIGFiICogc3Q7XG4gICAgICAgICAgICBvdXRbMV0gPSAtYWEgKiBzdCArIGFiICogY3Q7XG4gICAgICAgICAgICBvdXRbMl0gPSBhYyAqIGN0ICsgYWQgKiBzdDtcbiAgICAgICAgICAgIG91dFszXSA9IC1hYyAqIHN0ICsgY3QgKiBhZDtcbiAgICAgICAgICAgIG91dFs0XSA9IGN0ICogYXR4ICsgc3QgKiBhdHk7XG4gICAgICAgICAgICBvdXRbNV0gPSBjdCAqIGF0eSAtIHN0ICogYXR4O1xuICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOe8qeaUvuWPmOaNolxuICAgICAgICAgKiBAcGFyYW0ge0Zsb2F0MzJBcnJheXxBcnJheS48bnVtYmVyPn0gb3V0XG4gICAgICAgICAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fEFycmF5LjxudW1iZXI+fSBhXG4gICAgICAgICAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fEFycmF5LjxudW1iZXI+fSB2XG4gICAgICAgICAqL1xuICAgICAgICBzY2FsZSA6IGZ1bmN0aW9uKG91dCwgYSwgdikge1xuICAgICAgICAgICAgdmFyIHZ4ID0gdlswXTtcbiAgICAgICAgICAgIHZhciB2eSA9IHZbMV07XG4gICAgICAgICAgICBvdXRbMF0gPSBhWzBdICogdng7XG4gICAgICAgICAgICBvdXRbMV0gPSBhWzFdICogdnk7XG4gICAgICAgICAgICBvdXRbMl0gPSBhWzJdICogdng7XG4gICAgICAgICAgICBvdXRbM10gPSBhWzNdICogdnk7XG4gICAgICAgICAgICBvdXRbNF0gPSBhWzRdICogdng7XG4gICAgICAgICAgICBvdXRbNV0gPSBhWzVdICogdnk7XG4gICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICog5rGC6YCG55+p6Zi1XG4gICAgICAgICAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fEFycmF5LjxudW1iZXI+fSBvdXRcbiAgICAgICAgICogQHBhcmFtIHtGbG9hdDMyQXJyYXl8QXJyYXkuPG51bWJlcj59IGFcbiAgICAgICAgICovXG4gICAgICAgIGludmVydCA6IGZ1bmN0aW9uKG91dCwgYSkge1xuXG4gICAgICAgICAgICB2YXIgYWEgPSBhWzBdO1xuICAgICAgICAgICAgdmFyIGFjID0gYVsyXTtcbiAgICAgICAgICAgIHZhciBhdHggPSBhWzRdO1xuICAgICAgICAgICAgdmFyIGFiID0gYVsxXTtcbiAgICAgICAgICAgIHZhciBhZCA9IGFbM107XG4gICAgICAgICAgICB2YXIgYXR5ID0gYVs1XTtcblxuICAgICAgICAgICAgdmFyIGRldCA9IGFhICogYWQgLSBhYiAqIGFjO1xuICAgICAgICAgICAgaWYgKCFkZXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRldCA9IDEuMCAvIGRldDtcblxuICAgICAgICAgICAgb3V0WzBdID0gYWQgKiBkZXQ7XG4gICAgICAgICAgICBvdXRbMV0gPSAtYWIgKiBkZXQ7XG4gICAgICAgICAgICBvdXRbMl0gPSAtYWMgKiBkZXQ7XG4gICAgICAgICAgICBvdXRbM10gPSBhYSAqIGRldDtcbiAgICAgICAgICAgIG91dFs0XSA9IChhYyAqIGF0eSAtIGFkICogYXR4KSAqIGRldDtcbiAgICAgICAgICAgIG91dFs1XSA9IChhYiAqIGF0eCAtIGFhICogYXR5KSAqIGRldDtcbiAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBtYXRyaXg7XG5cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3pyZW5kZXIvbGliL2NvcmUvbWF0cml4LmpzXG4gKiogbW9kdWxlIGlkID0gMTNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlxuICAgIHZhciBBcnJheUN0b3IgPSB0eXBlb2YgRmxvYXQzMkFycmF5ID09PSAndW5kZWZpbmVkJ1xuICAgICAgICA/IEFycmF5XG4gICAgICAgIDogRmxvYXQzMkFycmF5O1xuXG4gICAgLyoqXG4gICAgICogQHR5cGVkZWYge0Zsb2F0MzJBcnJheXxBcnJheS48bnVtYmVyPn0gVmVjdG9yMlxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIOS6jOe7tOWQkemHj+exu1xuICAgICAqIEBleHBvcnRzIHpyZW5kZXIvdG9vbC92ZWN0b3JcbiAgICAgKi9cbiAgICB2YXIgdmVjdG9yID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICog5Yib5bu65LiA5Liq5ZCR6YePXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbeD0wXVxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW3k9MF1cbiAgICAgICAgICogQHJldHVybiB7VmVjdG9yMn1cbiAgICAgICAgICovXG4gICAgICAgIGNyZWF0ZTogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgICAgIHZhciBvdXQgPSBuZXcgQXJyYXlDdG9yKDIpO1xuICAgICAgICAgICAgaWYgKHggPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHggPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHkgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHkgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3V0WzBdID0geDtcbiAgICAgICAgICAgIG91dFsxXSA9IHk7XG4gICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlpI3liLblkJHph4/mlbDmja5cbiAgICAgICAgICogQHBhcmFtIHtWZWN0b3IyfSBvdXRcbiAgICAgICAgICogQHBhcmFtIHtWZWN0b3IyfSB2XG4gICAgICAgICAqIEByZXR1cm4ge1ZlY3RvcjJ9XG4gICAgICAgICAqL1xuICAgICAgICBjb3B5OiBmdW5jdGlvbiAob3V0LCB2KSB7XG4gICAgICAgICAgICBvdXRbMF0gPSB2WzBdO1xuICAgICAgICAgICAgb3V0WzFdID0gdlsxXTtcbiAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWFi+mahuS4gOS4quWQkemHj1xuICAgICAgICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IHZcbiAgICAgICAgICogQHJldHVybiB7VmVjdG9yMn1cbiAgICAgICAgICovXG4gICAgICAgIGNsb25lOiBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgdmFyIG91dCA9IG5ldyBBcnJheUN0b3IoMik7XG4gICAgICAgICAgICBvdXRbMF0gPSB2WzBdO1xuICAgICAgICAgICAgb3V0WzFdID0gdlsxXTtcbiAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOiuvue9ruWQkemHj+eahOS4pOS4qumhuVxuICAgICAgICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IG91dFxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gYVxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gYlxuICAgICAgICAgKiBAcmV0dXJuIHtWZWN0b3IyfSDnu5PmnpxcbiAgICAgICAgICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gKG91dCwgYSwgYikge1xuICAgICAgICAgICAgb3V0WzBdID0gYTtcbiAgICAgICAgICAgIG91dFsxXSA9IGI7XG4gICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlkJHph4/nm7jliqBcbiAgICAgICAgICogQHBhcmFtIHtWZWN0b3IyfSBvdXRcbiAgICAgICAgICogQHBhcmFtIHtWZWN0b3IyfSB2MVxuICAgICAgICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IHYyXG4gICAgICAgICAqL1xuICAgICAgICBhZGQ6IGZ1bmN0aW9uIChvdXQsIHYxLCB2Mikge1xuICAgICAgICAgICAgb3V0WzBdID0gdjFbMF0gKyB2MlswXTtcbiAgICAgICAgICAgIG91dFsxXSA9IHYxWzFdICsgdjJbMV07XG4gICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlkJHph4/nvKnmlL7lkI7nm7jliqBcbiAgICAgICAgICogQHBhcmFtIHtWZWN0b3IyfSBvdXRcbiAgICAgICAgICogQHBhcmFtIHtWZWN0b3IyfSB2MVxuICAgICAgICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IHYyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhXG4gICAgICAgICAqL1xuICAgICAgICBzY2FsZUFuZEFkZDogZnVuY3Rpb24gKG91dCwgdjEsIHYyLCBhKSB7XG4gICAgICAgICAgICBvdXRbMF0gPSB2MVswXSArIHYyWzBdICogYTtcbiAgICAgICAgICAgIG91dFsxXSA9IHYxWzFdICsgdjJbMV0gKiBhO1xuICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5ZCR6YeP55u45YePXG4gICAgICAgICAqIEBwYXJhbSB7VmVjdG9yMn0gb3V0XG4gICAgICAgICAqIEBwYXJhbSB7VmVjdG9yMn0gdjFcbiAgICAgICAgICogQHBhcmFtIHtWZWN0b3IyfSB2MlxuICAgICAgICAgKi9cbiAgICAgICAgc3ViOiBmdW5jdGlvbiAob3V0LCB2MSwgdjIpIHtcbiAgICAgICAgICAgIG91dFswXSA9IHYxWzBdIC0gdjJbMF07XG4gICAgICAgICAgICBvdXRbMV0gPSB2MVsxXSAtIHYyWzFdO1xuICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5ZCR6YeP6ZW/5bqmXG4gICAgICAgICAqIEBwYXJhbSB7VmVjdG9yMn0gdlxuICAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBsZW46IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KHRoaXMubGVuU3F1YXJlKHYpKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5ZCR6YeP6ZW/5bqm5bmz5pa5XG4gICAgICAgICAqIEBwYXJhbSB7VmVjdG9yMn0gdlxuICAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBsZW5TcXVhcmU6IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICByZXR1cm4gdlswXSAqIHZbMF0gKyB2WzFdICogdlsxXTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5ZCR6YeP5LmY5rOVXG4gICAgICAgICAqIEBwYXJhbSB7VmVjdG9yMn0gb3V0XG4gICAgICAgICAqIEBwYXJhbSB7VmVjdG9yMn0gdjFcbiAgICAgICAgICogQHBhcmFtIHtWZWN0b3IyfSB2MlxuICAgICAgICAgKi9cbiAgICAgICAgbXVsOiBmdW5jdGlvbiAob3V0LCB2MSwgdjIpIHtcbiAgICAgICAgICAgIG91dFswXSA9IHYxWzBdICogdjJbMF07XG4gICAgICAgICAgICBvdXRbMV0gPSB2MVsxXSAqIHYyWzFdO1xuICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5ZCR6YeP6Zmk5rOVXG4gICAgICAgICAqIEBwYXJhbSB7VmVjdG9yMn0gb3V0XG4gICAgICAgICAqIEBwYXJhbSB7VmVjdG9yMn0gdjFcbiAgICAgICAgICogQHBhcmFtIHtWZWN0b3IyfSB2MlxuICAgICAgICAgKi9cbiAgICAgICAgZGl2OiBmdW5jdGlvbiAob3V0LCB2MSwgdjIpIHtcbiAgICAgICAgICAgIG91dFswXSA9IHYxWzBdIC8gdjJbMF07XG4gICAgICAgICAgICBvdXRbMV0gPSB2MVsxXSAvIHYyWzFdO1xuICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5ZCR6YeP54K55LmYXG4gICAgICAgICAqIEBwYXJhbSB7VmVjdG9yMn0gdjFcbiAgICAgICAgICogQHBhcmFtIHtWZWN0b3IyfSB2MlxuICAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBkb3Q6IGZ1bmN0aW9uICh2MSwgdjIpIHtcbiAgICAgICAgICAgIHJldHVybiB2MVswXSAqIHYyWzBdICsgdjFbMV0gKiB2MlsxXTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5ZCR6YeP57yp5pS+XG4gICAgICAgICAqIEBwYXJhbSB7VmVjdG9yMn0gb3V0XG4gICAgICAgICAqIEBwYXJhbSB7VmVjdG9yMn0gdlxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gc1xuICAgICAgICAgKi9cbiAgICAgICAgc2NhbGU6IGZ1bmN0aW9uIChvdXQsIHYsIHMpIHtcbiAgICAgICAgICAgIG91dFswXSA9IHZbMF0gKiBzO1xuICAgICAgICAgICAgb3V0WzFdID0gdlsxXSAqIHM7XG4gICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlkJHph4/lvZLkuIDljJZcbiAgICAgICAgICogQHBhcmFtIHtWZWN0b3IyfSBvdXRcbiAgICAgICAgICogQHBhcmFtIHtWZWN0b3IyfSB2XG4gICAgICAgICAqL1xuICAgICAgICBub3JtYWxpemU6IGZ1bmN0aW9uIChvdXQsIHYpIHtcbiAgICAgICAgICAgIHZhciBkID0gdmVjdG9yLmxlbih2KTtcbiAgICAgICAgICAgIGlmIChkID09PSAwKSB7XG4gICAgICAgICAgICAgICAgb3V0WzBdID0gMDtcbiAgICAgICAgICAgICAgICBvdXRbMV0gPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgb3V0WzBdID0gdlswXSAvIGQ7XG4gICAgICAgICAgICAgICAgb3V0WzFdID0gdlsxXSAvIGQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDorqHnrpflkJHph4/pl7Tot53nprtcbiAgICAgICAgICogQHBhcmFtIHtWZWN0b3IyfSB2MVxuICAgICAgICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IHYyXG4gICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIGRpc3RhbmNlOiBmdW5jdGlvbiAodjEsIHYyKSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KFxuICAgICAgICAgICAgICAgICh2MVswXSAtIHYyWzBdKSAqICh2MVswXSAtIHYyWzBdKVxuICAgICAgICAgICAgICAgICsgKHYxWzFdIC0gdjJbMV0pICogKHYxWzFdIC0gdjJbMV0pXG4gICAgICAgICAgICApO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlkJHph4/ot53nprvlubPmlrlcbiAgICAgICAgICogQHBhcmFtIHtWZWN0b3IyfSB2MVxuICAgICAgICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IHYyXG4gICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIGRpc3RhbmNlU3F1YXJlOiBmdW5jdGlvbiAodjEsIHYyKSB7XG4gICAgICAgICAgICByZXR1cm4gKHYxWzBdIC0gdjJbMF0pICogKHYxWzBdIC0gdjJbMF0pXG4gICAgICAgICAgICAgICAgKyAodjFbMV0gLSB2MlsxXSkgKiAodjFbMV0gLSB2MlsxXSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOaxgui0n+WQkemHj1xuICAgICAgICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IG91dFxuICAgICAgICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IHZcbiAgICAgICAgICovXG4gICAgICAgIG5lZ2F0ZTogZnVuY3Rpb24gKG91dCwgdikge1xuICAgICAgICAgICAgb3V0WzBdID0gLXZbMF07XG4gICAgICAgICAgICBvdXRbMV0gPSAtdlsxXTtcbiAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOaPkuWAvOS4pOS4queCuVxuICAgICAgICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IG91dFxuICAgICAgICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IHYxXG4gICAgICAgICAqIEBwYXJhbSB7VmVjdG9yMn0gdjJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHRcbiAgICAgICAgICovXG4gICAgICAgIGxlcnA6IGZ1bmN0aW9uIChvdXQsIHYxLCB2MiwgdCkge1xuICAgICAgICAgICAgb3V0WzBdID0gdjFbMF0gKyB0ICogKHYyWzBdIC0gdjFbMF0pO1xuICAgICAgICAgICAgb3V0WzFdID0gdjFbMV0gKyB0ICogKHYyWzFdIC0gdjFbMV0pO1xuICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog55+p6Zi15bem5LmY5ZCR6YePXG4gICAgICAgICAqIEBwYXJhbSB7VmVjdG9yMn0gb3V0XG4gICAgICAgICAqIEBwYXJhbSB7VmVjdG9yMn0gdlxuICAgICAgICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IG1cbiAgICAgICAgICovXG4gICAgICAgIGFwcGx5VHJhbnNmb3JtOiBmdW5jdGlvbiAob3V0LCB2LCBtKSB7XG4gICAgICAgICAgICB2YXIgeCA9IHZbMF07XG4gICAgICAgICAgICB2YXIgeSA9IHZbMV07XG4gICAgICAgICAgICBvdXRbMF0gPSBtWzBdICogeCArIG1bMl0gKiB5ICsgbVs0XTtcbiAgICAgICAgICAgIG91dFsxXSA9IG1bMV0gKiB4ICsgbVszXSAqIHkgKyBtWzVdO1xuICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOaxguS4pOS4quWQkemHj+acgOWwj+WAvFxuICAgICAgICAgKiBAcGFyYW0gIHtWZWN0b3IyfSBvdXRcbiAgICAgICAgICogQHBhcmFtICB7VmVjdG9yMn0gdjFcbiAgICAgICAgICogQHBhcmFtICB7VmVjdG9yMn0gdjJcbiAgICAgICAgICovXG4gICAgICAgIG1pbjogZnVuY3Rpb24gKG91dCwgdjEsIHYyKSB7XG4gICAgICAgICAgICBvdXRbMF0gPSBNYXRoLm1pbih2MVswXSwgdjJbMF0pO1xuICAgICAgICAgICAgb3V0WzFdID0gTWF0aC5taW4odjFbMV0sIHYyWzFdKTtcbiAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmsYLkuKTkuKrlkJHph4/mnIDlpKflgLxcbiAgICAgICAgICogQHBhcmFtICB7VmVjdG9yMn0gb3V0XG4gICAgICAgICAqIEBwYXJhbSAge1ZlY3RvcjJ9IHYxXG4gICAgICAgICAqIEBwYXJhbSAge1ZlY3RvcjJ9IHYyXG4gICAgICAgICAqL1xuICAgICAgICBtYXg6IGZ1bmN0aW9uIChvdXQsIHYxLCB2Mikge1xuICAgICAgICAgICAgb3V0WzBdID0gTWF0aC5tYXgodjFbMF0sIHYyWzBdKTtcbiAgICAgICAgICAgIG91dFsxXSA9IE1hdGgubWF4KHYxWzFdLCB2MlsxXSk7XG4gICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZlY3Rvci5sZW5ndGggPSB2ZWN0b3IubGVuO1xuICAgIHZlY3Rvci5sZW5ndGhTcXVhcmUgPSB2ZWN0b3IubGVuU3F1YXJlO1xuICAgIHZlY3Rvci5kaXN0ID0gdmVjdG9yLmRpc3RhbmNlO1xuICAgIHZlY3Rvci5kaXN0U3F1YXJlID0gdmVjdG9yLmRpc3RhbmNlU3F1YXJlO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB2ZWN0b3I7XG5cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3pyZW5kZXIvbGliL2NvcmUvdmVjdG9yLmpzXG4gKiogbW9kdWxlIGlkID0gMTRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0Jztcbi8qKlxuICogQG1vZHVsZSB6cmVuZGVyL21peGluL0FuaW1hdGFibGVcbiAqL1xuXG5cbiAgICB2YXIgQW5pbWF0b3IgPSByZXF1aXJlKCcuLi9hbmltYXRpb24vQW5pbWF0b3InKTtcbiAgICB2YXIgdXRpbCA9IHJlcXVpcmUoJy4uL2NvcmUvdXRpbCcpO1xuICAgIHZhciBpc1N0cmluZyA9IHV0aWwuaXNTdHJpbmc7XG4gICAgdmFyIGlzRnVuY3Rpb24gPSB1dGlsLmlzRnVuY3Rpb247XG4gICAgdmFyIGlzT2JqZWN0ID0gdXRpbC5pc09iamVjdDtcbiAgICB2YXIgbG9nID0gcmVxdWlyZSgnLi4vY29yZS9sb2cnKTtcblxuICAgIC8qKlxuICAgICAqIEBhbGlhcyBtb2R1ZTp6cmVuZGVyL21peGluL0FuaW1hdGFibGVcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKi9cbiAgICB2YXIgQW5pbWF0YWJsZSA9IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge0FycmF5Ljxtb2R1bGU6enJlbmRlci9hbmltYXRpb24vQW5pbWF0b3I+fVxuICAgICAgICAgKiBAcmVhZE9ubHlcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYW5pbWF0b3JzID0gW107XG4gICAgfTtcblxuICAgIEFuaW1hdGFibGUucHJvdG90eXBlID0ge1xuXG4gICAgICAgIGNvbnN0cnVjdG9yOiBBbmltYXRhYmxlLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDliqjnlLtcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGgg6ZyA6KaB5re75Yqg5Yqo55S755qE5bGe5oCn6I635Y+W6Lev5b6E77yM5Y+v5Lul6YCa6L+HYS5iLmPmnaXojrflj5bmt7HlsYLnmoTlsZ7mgKdcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBbbG9vcF0g5Yqo55S75piv5ZCm5b6q546vXG4gICAgICAgICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2FuaW1hdGlvbi9BbmltYXRvcn1cbiAgICAgICAgICogQGV4YW1wbGU6XG4gICAgICAgICAqICAgICBlbC5hbmltYXRlKCdzdHlsZScsIGZhbHNlKVxuICAgICAgICAgKiAgICAgICAgIC53aGVuKDEwMDAsIHt4OiAxMH0gKVxuICAgICAgICAgKiAgICAgICAgIC5kb25lKGZ1bmN0aW9uKCl7IC8vIEFuaW1hdGlvbiBkb25lIH0pXG4gICAgICAgICAqICAgICAgICAgLnN0YXJ0KClcbiAgICAgICAgICovXG4gICAgICAgIGFuaW1hdGU6IGZ1bmN0aW9uIChwYXRoLCBsb29wKSB7XG4gICAgICAgICAgICB2YXIgdGFyZ2V0O1xuICAgICAgICAgICAgdmFyIGFuaW1hdGluZ1NoYXBlID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgZWwgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIHpyID0gdGhpcy5fX3pyO1xuICAgICAgICAgICAgaWYgKHBhdGgpIHtcbiAgICAgICAgICAgICAgICB2YXIgcGF0aFNwbGl0dGVkID0gcGF0aC5zcGxpdCgnLicpO1xuICAgICAgICAgICAgICAgIHZhciBwcm9wID0gZWw7XG4gICAgICAgICAgICAgICAgLy8gSWYgYW5pbWF0aW5nIHNoYXBlXG4gICAgICAgICAgICAgICAgYW5pbWF0aW5nU2hhcGUgPSBwYXRoU3BsaXR0ZWRbMF0gPT09ICdzaGFwZSc7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBwYXRoU3BsaXR0ZWQubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghcHJvcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcHJvcCA9IHByb3BbcGF0aFNwbGl0dGVkW2ldXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHByb3ApIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0ID0gcHJvcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0YXJnZXQgPSBlbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICBsb2coXG4gICAgICAgICAgICAgICAgICAgICdQcm9wZXJ0eSBcIidcbiAgICAgICAgICAgICAgICAgICAgKyBwYXRoXG4gICAgICAgICAgICAgICAgICAgICsgJ1wiIGlzIG5vdCBleGlzdGVkIGluIGVsZW1lbnQgJ1xuICAgICAgICAgICAgICAgICAgICArIGVsLmlkXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBhbmltYXRvcnMgPSBlbC5hbmltYXRvcnM7XG5cbiAgICAgICAgICAgIHZhciBhbmltYXRvciA9IG5ldyBBbmltYXRvcih0YXJnZXQsIGxvb3ApO1xuXG4gICAgICAgICAgICBhbmltYXRvci5kdXJpbmcoZnVuY3Rpb24gKHRhcmdldCkge1xuICAgICAgICAgICAgICAgIGVsLmRpcnR5KGFuaW1hdGluZ1NoYXBlKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuZG9uZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgLy8gRklYTUUgQW5pbWF0b3Igd2lsbCBub3QgYmUgcmVtb3ZlZCBpZiB1c2UgYEFuaW1hdG9yI3N0b3BgIHRvIHN0b3AgYW5pbWF0aW9uXG4gICAgICAgICAgICAgICAgYW5pbWF0b3JzLnNwbGljZSh1dGlsLmluZGV4T2YoYW5pbWF0b3JzLCBhbmltYXRvciksIDEpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGFuaW1hdG9ycy5wdXNoKGFuaW1hdG9yKTtcblxuICAgICAgICAgICAgLy8gSWYgYW5pbWF0ZSBhZnRlciBhZGRlZCB0byB0aGUgenJlbmRlclxuICAgICAgICAgICAgaWYgKHpyKSB7XG4gICAgICAgICAgICAgICAgenIuYW5pbWF0aW9uLmFkZEFuaW1hdG9yKGFuaW1hdG9yKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGFuaW1hdG9yO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlgZzmraLliqjnlLtcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBmb3J3YXJkVG9MYXN0IElmIG1vdmUgdG8gbGFzdCBmcmFtZSBiZWZvcmUgc3RvcFxuICAgICAgICAgKi9cbiAgICAgICAgc3RvcEFuaW1hdGlvbjogZnVuY3Rpb24gKGZvcndhcmRUb0xhc3QpIHtcbiAgICAgICAgICAgIHZhciBhbmltYXRvcnMgPSB0aGlzLmFuaW1hdG9ycztcbiAgICAgICAgICAgIHZhciBsZW4gPSBhbmltYXRvcnMubGVuZ3RoO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGFuaW1hdG9yc1tpXS5zdG9wKGZvcndhcmRUb0xhc3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYW5pbWF0b3JzLmxlbmd0aCA9IDA7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0XG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbdGltZT01MDBdIFRpbWUgaW4gbXNcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtlYXNpbmc9J2xpbmVhciddXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZGVsYXk9MF1cbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXVxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiAgLy8gQW5pbWF0ZSBwb3NpdGlvblxuICAgICAgICAgKiAgZWwuYW5pbWF0ZVRvKHtcbiAgICAgICAgICogICAgICBwb3NpdGlvbjogWzEwLCAxMF1cbiAgICAgICAgICogIH0sIGZ1bmN0aW9uICgpIHsgLy8gZG9uZSB9KVxuICAgICAgICAgKlxuICAgICAgICAgKiAgLy8gQW5pbWF0ZSBzaGFwZSwgc3R5bGUgYW5kIHBvc2l0aW9uIGluIDEwMG1zLCBkZWxheWVkIDEwMG1zLCB3aXRoIGN1YmljT3V0IGVhc2luZ1xuICAgICAgICAgKiAgZWwuYW5pbWF0ZVRvKHtcbiAgICAgICAgICogICAgICBzaGFwZToge1xuICAgICAgICAgKiAgICAgICAgICB3aWR0aDogNTAwXG4gICAgICAgICAqICAgICAgfSxcbiAgICAgICAgICogICAgICBzdHlsZToge1xuICAgICAgICAgKiAgICAgICAgICBmaWxsOiAncmVkJ1xuICAgICAgICAgKiAgICAgIH1cbiAgICAgICAgICogICAgICBwb3NpdGlvbjogWzEwLCAxMF1cbiAgICAgICAgICogIH0sIDEwMCwgMTAwLCAnY3ViaWNPdXQnLCBmdW5jdGlvbiAoKSB7IC8vIGRvbmUgfSlcbiAgICAgICAgICovXG4gICAgICAgICAvLyBUT0RPIFJldHVybiBhbmltYXRpb24ga2V5XG4gICAgICAgIGFuaW1hdGVUbzogZnVuY3Rpb24gKHRhcmdldCwgdGltZSwgZGVsYXksIGVhc2luZywgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIC8vIGFuaW1hdGVUbyh0YXJnZXQsIHRpbWUsIGVhc2luZywgY2FsbGJhY2spO1xuICAgICAgICAgICAgaWYgKGlzU3RyaW5nKGRlbGF5KSkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gZWFzaW5nO1xuICAgICAgICAgICAgICAgIGVhc2luZyA9IGRlbGF5O1xuICAgICAgICAgICAgICAgIGRlbGF5ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGFuaW1hdGVUbyh0YXJnZXQsIHRpbWUsIGRlbGF5LCBjYWxsYmFjayk7XG4gICAgICAgICAgICBlbHNlIGlmIChpc0Z1bmN0aW9uKGVhc2luZykpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayA9IGVhc2luZztcbiAgICAgICAgICAgICAgICBlYXNpbmcgPSAnbGluZWFyJztcbiAgICAgICAgICAgICAgICBkZWxheSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBhbmltYXRlVG8odGFyZ2V0LCB0aW1lLCBjYWxsYmFjayk7XG4gICAgICAgICAgICBlbHNlIGlmIChpc0Z1bmN0aW9uKGRlbGF5KSkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gZGVsYXk7XG4gICAgICAgICAgICAgICAgZGVsYXkgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gYW5pbWF0ZVRvKHRhcmdldCwgY2FsbGJhY2spXG4gICAgICAgICAgICBlbHNlIGlmIChpc0Z1bmN0aW9uKHRpbWUpKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sgPSB0aW1lO1xuICAgICAgICAgICAgICAgIHRpbWUgPSA1MDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBhbmltYXRlVG8odGFyZ2V0KVxuICAgICAgICAgICAgZWxzZSBpZiAoIXRpbWUpIHtcbiAgICAgICAgICAgICAgICB0aW1lID0gNTAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU3RvcCBhbGwgcHJldmlvdXMgYW5pbWF0aW9uc1xuICAgICAgICAgICAgdGhpcy5zdG9wQW5pbWF0aW9uKCk7XG4gICAgICAgICAgICB0aGlzLl9hbmltYXRlVG9TaGFsbG93KCcnLCB0aGlzLCB0YXJnZXQsIHRpbWUsIGRlbGF5LCBlYXNpbmcsIGNhbGxiYWNrKTtcblxuICAgICAgICAgICAgLy8gQW5pbWF0b3JzIG1heSBiZSByZW1vdmVkIGltbWVkaWF0ZWx5IGFmdGVyIHN0YXJ0XG4gICAgICAgICAgICAvLyBpZiB0aGVyZSBpcyBub3RoaW5nIHRvIGFuaW1hdGVcbiAgICAgICAgICAgIHZhciBhbmltYXRvcnMgPSB0aGlzLmFuaW1hdG9ycy5zbGljZSgpO1xuICAgICAgICAgICAgdmFyIGNvdW50ID0gYW5pbWF0b3JzLmxlbmd0aDtcbiAgICAgICAgICAgIGZ1bmN0aW9uIGRvbmUoKSB7XG4gICAgICAgICAgICAgICAgY291bnQtLTtcbiAgICAgICAgICAgICAgICBpZiAoIWNvdW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBObyBhbmltYXRvcnMuIFRoaXMgc2hvdWxkIGJlIGNoZWNrZWQgYmVmb3JlIGFuaW1hdG9yc1tpXS5zdGFydCgpLFxuICAgICAgICAgICAgLy8gYmVjYXVzZSAnZG9uZScgbWF5IGJlIGV4ZWN1dGVkIGltbWVkaWF0ZWx5IGlmIG5vIG5lZWQgdG8gYW5pbWF0ZS5cbiAgICAgICAgICAgIGlmICghY291bnQpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU3RhcnQgYWZ0ZXIgYWxsIGFuaW1hdG9ycyBjcmVhdGVkXG4gICAgICAgICAgICAvLyBJbmNhc2UgYW55IGFuaW1hdG9yIGlzIGRvbmUgaW1tZWRpYXRlbHkgd2hlbiBhbGwgYW5pbWF0aW9uIHByb3BlcnRpZXMgYXJlIG5vdCBjaGFuZ2VkXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFuaW1hdG9ycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGFuaW1hdG9yc1tpXVxuICAgICAgICAgICAgICAgICAgICAuZG9uZShkb25lKVxuICAgICAgICAgICAgICAgICAgICAuc3RhcnQoZWFzaW5nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGg9JydcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZT10aGlzXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXRcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFt0aW1lPTUwMF1cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtkZWxheT0wXVxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiAgLy8gQW5pbWF0ZSBwb3NpdGlvblxuICAgICAgICAgKiAgZWwuX2FuaW1hdGVUb1NoYWxsb3coe1xuICAgICAgICAgKiAgICAgIHBvc2l0aW9uOiBbMTAsIDEwXVxuICAgICAgICAgKiAgfSlcbiAgICAgICAgICpcbiAgICAgICAgICogIC8vIEFuaW1hdGUgc2hhcGUsIHN0eWxlIGFuZCBwb3NpdGlvbiBpbiAxMDBtcywgZGVsYXllZCAxMDBtc1xuICAgICAgICAgKiAgZWwuX2FuaW1hdGVUb1NoYWxsb3coe1xuICAgICAgICAgKiAgICAgIHNoYXBlOiB7XG4gICAgICAgICAqICAgICAgICAgIHdpZHRoOiA1MDBcbiAgICAgICAgICogICAgICB9LFxuICAgICAgICAgKiAgICAgIHN0eWxlOiB7XG4gICAgICAgICAqICAgICAgICAgIGZpbGw6ICdyZWQnXG4gICAgICAgICAqICAgICAgfVxuICAgICAgICAgKiAgICAgIHBvc2l0aW9uOiBbMTAsIDEwXVxuICAgICAgICAgKiAgfSwgMTAwLCAxMDApXG4gICAgICAgICAqL1xuICAgICAgICBfYW5pbWF0ZVRvU2hhbGxvdzogZnVuY3Rpb24gKHBhdGgsIHNvdXJjZSwgdGFyZ2V0LCB0aW1lLCBkZWxheSkge1xuICAgICAgICAgICAgdmFyIG9ialNoYWxsb3cgPSB7fTtcbiAgICAgICAgICAgIHZhciBwcm9wZXJ0eUNvdW50ID0gMDtcbiAgICAgICAgICAgIGZvciAodmFyIG5hbWUgaW4gdGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHNvdXJjZVtuYW1lXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc09iamVjdCh0YXJnZXRbbmFtZV0pICYmICF1dGlsLmlzQXJyYXlMaWtlKHRhcmdldFtuYW1lXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2FuaW1hdGVUb1NoYWxsb3coXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aCA/IHBhdGggKyAnLicgKyBuYW1lIDogbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2VbbmFtZV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W25hbWVdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsYXlcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvYmpTaGFsbG93W25hbWVdID0gdGFyZ2V0W25hbWVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydHlDb3VudCsrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRhcmdldFtuYW1lXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEF0dHIgZGlyZWN0bHkgaWYgbm90IGhhcyBwcm9wZXJ0eVxuICAgICAgICAgICAgICAgICAgICAvLyBGSVhNRSwgaWYgc29tZSBwcm9wZXJ0eSBub3QgbmVlZGVkIGZvciBlbGVtZW50ID9cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFwYXRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmF0dHIobmFtZSwgdGFyZ2V0W25hbWVdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHsgIC8vIFNoYXBlIG9yIHN0eWxlXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHJvcHMgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BzW3BhdGhdID0ge307XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wc1twYXRoXVtuYW1lXSA9IHRhcmdldFtuYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXR0cihwcm9wcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChwcm9wZXJ0eUNvdW50ID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYW5pbWF0ZShwYXRoLCBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgLndoZW4odGltZSA9PSBudWxsID8gNTAwIDogdGltZSwgb2JqU2hhbGxvdylcbiAgICAgICAgICAgICAgICAgICAgLmRlbGF5KGRlbGF5IHx8IDApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IEFuaW1hdGFibGU7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi96cmVuZGVyL2xpYi9taXhpbi9BbmltYXRhYmxlLmpzXG4gKiogbW9kdWxlIGlkID0gMTVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQG1vZHVsZSBlY2hhcnRzL2FuaW1hdGlvbi9BbmltYXRvclxuICovXG5cblxuICAgIHZhciBDbGlwID0gcmVxdWlyZSgnLi9DbGlwJyk7XG4gICAgdmFyIGNvbG9yID0gcmVxdWlyZSgnLi4vdG9vbC9jb2xvcicpO1xuICAgIHZhciB1dGlsID0gcmVxdWlyZSgnLi4vY29yZS91dGlsJyk7XG4gICAgdmFyIGlzQXJyYXlMaWtlID0gdXRpbC5pc0FycmF5TGlrZTtcblxuICAgIHZhciBhcnJheVNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xuXG4gICAgZnVuY3Rpb24gZGVmYXVsdEdldHRlcih0YXJnZXQsIGtleSkge1xuICAgICAgICByZXR1cm4gdGFyZ2V0W2tleV07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGVmYXVsdFNldHRlcih0YXJnZXQsIGtleSwgdmFsdWUpIHtcbiAgICAgICAgdGFyZ2V0W2tleV0gPSB2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHAwXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBwMVxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcGVyY2VudFxuICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbnRlcnBvbGF0ZU51bWJlcihwMCwgcDEsIHBlcmNlbnQpIHtcbiAgICAgICAgcmV0dXJuIChwMSAtIHAwKSAqIHBlcmNlbnQgKyBwMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9IHAwXG4gICAgICogQHBhcmFtICB7c3RyaW5nfSBwMVxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcGVyY2VudFxuICAgICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbnRlcnBvbGF0ZVN0cmluZyhwMCwgcDEsIHBlcmNlbnQpIHtcbiAgICAgICAgcmV0dXJuIHBlcmNlbnQgPiAwLjUgPyBwMSA6IHAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSAge0FycmF5fSBwMFxuICAgICAqIEBwYXJhbSAge0FycmF5fSBwMVxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcGVyY2VudFxuICAgICAqIEBwYXJhbSAge0FycmF5fSBvdXRcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IGFyckRpbVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGludGVycG9sYXRlQXJyYXkocDAsIHAxLCBwZXJjZW50LCBvdXQsIGFyckRpbSkge1xuICAgICAgICB2YXIgbGVuID0gcDAubGVuZ3RoO1xuICAgICAgICBpZiAoYXJyRGltID09IDEpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBvdXRbaV0gPSBpbnRlcnBvbGF0ZU51bWJlcihwMFtpXSwgcDFbaV0sIHBlcmNlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGxlbjIgPSBwMFswXS5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBsZW4yOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0W2ldW2pdID0gaW50ZXJwb2xhdGVOdW1iZXIoXG4gICAgICAgICAgICAgICAgICAgICAgICBwMFtpXVtqXSwgcDFbaV1bal0sIHBlcmNlbnRcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBhcnIwIGlzIHNvdXJjZSBhcnJheSwgYXJyMSBpcyB0YXJnZXQgYXJyYXkuXG4gICAgLy8gRG8gc29tZSBwcmVwcm9jZXNzIHRvIGF2b2lkIGVycm9yIGhhcHBlbmVkIHdoZW4gaW50ZXJwb2xhdGluZyBmcm9tIGFycjAgdG8gYXJyMVxuICAgIGZ1bmN0aW9uIGZpbGxBcnIoYXJyMCwgYXJyMSwgYXJyRGltKSB7XG4gICAgICAgIHZhciBhcnIwTGVuID0gYXJyMC5sZW5ndGg7XG4gICAgICAgIHZhciBhcnIxTGVuID0gYXJyMS5sZW5ndGg7XG4gICAgICAgIGlmIChhcnIwTGVuICE9PSBhcnIxTGVuKSB7XG4gICAgICAgICAgICAvLyBGSVhNRSBOb3Qgd29yayBmb3IgVHlwZWRBcnJheVxuICAgICAgICAgICAgdmFyIGlzUHJldmlvdXNMYXJnZXIgPSBhcnIwTGVuID4gYXJyMUxlbjtcbiAgICAgICAgICAgIGlmIChpc1ByZXZpb3VzTGFyZ2VyKSB7XG4gICAgICAgICAgICAgICAgLy8gQ3V0IHRoZSBwcmV2aW91c1xuICAgICAgICAgICAgICAgIGFycjAubGVuZ3RoID0gYXJyMUxlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEZpbGwgdGhlIHByZXZpb3VzXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IGFycjBMZW47IGkgPCBhcnIxTGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgYXJyMC5wdXNoKFxuICAgICAgICAgICAgICAgICAgICAgICAgYXJyRGltID09PSAxID8gYXJyMVtpXSA6IGFycmF5U2xpY2UuY2FsbChhcnIxW2ldKVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBIYW5kbGluZyBOYU4gdmFsdWVcbiAgICAgICAgdmFyIGxlbjIgPSBhcnIwWzBdICYmIGFycjBbMF0ubGVuZ3RoO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycjAubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChhcnJEaW0gPT09IDEpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNOYU4oYXJyMFtpXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgYXJyMFtpXSA9IGFycjFbaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBsZW4yOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzTmFOKGFycjBbaV1bal0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcnIwW2ldW2pdID0gYXJyMVtpXVtqXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSAge0FycmF5fSBhcnIwXG4gICAgICogQHBhcmFtICB7QXJyYXl9IGFycjFcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IGFyckRpbVxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNBcnJheVNhbWUoYXJyMCwgYXJyMSwgYXJyRGltKSB7XG4gICAgICAgIGlmIChhcnIwID09PSBhcnIxKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGVuID0gYXJyMC5sZW5ndGg7XG4gICAgICAgIGlmIChsZW4gIT09IGFycjEubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFyckRpbSA9PT0gMSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChhcnIwW2ldICE9PSBhcnIxW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgbGVuMiA9IGFycjBbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbGVuMjsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhcnIwW2ldW2pdICE9PSBhcnIxW2ldW2pdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2F0bXVsbCBSb20gaW50ZXJwb2xhdGUgYXJyYXlcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gcDBcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gcDFcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gcDJcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gcDNcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHRcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHQyXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSB0M1xuICAgICAqIEBwYXJhbSAge0FycmF5fSBvdXRcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IGFyckRpbVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNhdG11bGxSb21JbnRlcnBvbGF0ZUFycmF5KFxuICAgICAgICBwMCwgcDEsIHAyLCBwMywgdCwgdDIsIHQzLCBvdXQsIGFyckRpbVxuICAgICkge1xuICAgICAgICB2YXIgbGVuID0gcDAubGVuZ3RoO1xuICAgICAgICBpZiAoYXJyRGltID09IDEpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBvdXRbaV0gPSBjYXRtdWxsUm9tSW50ZXJwb2xhdGUoXG4gICAgICAgICAgICAgICAgICAgIHAwW2ldLCBwMVtpXSwgcDJbaV0sIHAzW2ldLCB0LCB0MiwgdDNcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGxlbjIgPSBwMFswXS5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBsZW4yOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0W2ldW2pdID0gY2F0bXVsbFJvbUludGVycG9sYXRlKFxuICAgICAgICAgICAgICAgICAgICAgICAgcDBbaV1bal0sIHAxW2ldW2pdLCBwMltpXVtqXSwgcDNbaV1bal0sXG4gICAgICAgICAgICAgICAgICAgICAgICB0LCB0MiwgdDNcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYXRtdWxsIFJvbSBpbnRlcnBvbGF0ZSBudW1iZXJcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHAwXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBwMVxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcDJcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHAzXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSB0XG4gICAgICogQHBhcmFtICB7bnVtYmVyfSB0MlxuICAgICAqIEBwYXJhbSAge251bWJlcn0gdDNcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICovXG4gICAgZnVuY3Rpb24gY2F0bXVsbFJvbUludGVycG9sYXRlKHAwLCBwMSwgcDIsIHAzLCB0LCB0MiwgdDMpIHtcbiAgICAgICAgdmFyIHYwID0gKHAyIC0gcDApICogMC41O1xuICAgICAgICB2YXIgdjEgPSAocDMgLSBwMSkgKiAwLjU7XG4gICAgICAgIHJldHVybiAoMiAqIChwMSAtIHAyKSArIHYwICsgdjEpICogdDNcbiAgICAgICAgICAgICAgICArICgtMyAqIChwMSAtIHAyKSAtIDIgKiB2MCAtIHYxKSAqIHQyXG4gICAgICAgICAgICAgICAgKyB2MCAqIHQgKyBwMTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbG9uZVZhbHVlKHZhbHVlKSB7XG4gICAgICAgIGlmIChpc0FycmF5TGlrZSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHZhciBsZW4gPSB2YWx1ZS5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoaXNBcnJheUxpa2UodmFsdWVbMF0pKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJldCA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0LnB1c2goYXJyYXlTbGljZS5jYWxsKHZhbHVlW2ldKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBhcnJheVNsaWNlLmNhbGwodmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJnYmEyU3RyaW5nKHJnYmEpIHtcbiAgICAgICAgcmdiYVswXSA9IE1hdGguZmxvb3IocmdiYVswXSk7XG4gICAgICAgIHJnYmFbMV0gPSBNYXRoLmZsb29yKHJnYmFbMV0pO1xuICAgICAgICByZ2JhWzJdID0gTWF0aC5mbG9vcihyZ2JhWzJdKTtcblxuICAgICAgICByZXR1cm4gJ3JnYmEoJyArIHJnYmEuam9pbignLCcpICsgJyknO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZVRyYWNrQ2xpcCAoYW5pbWF0b3IsIGVhc2luZywgb25lVHJhY2tEb25lLCBrZXlmcmFtZXMsIHByb3BOYW1lKSB7XG4gICAgICAgIHZhciBnZXR0ZXIgPSBhbmltYXRvci5fZ2V0dGVyO1xuICAgICAgICB2YXIgc2V0dGVyID0gYW5pbWF0b3IuX3NldHRlcjtcbiAgICAgICAgdmFyIHVzZVNwbGluZSA9IGVhc2luZyA9PT0gJ3NwbGluZSc7XG5cbiAgICAgICAgdmFyIHRyYWNrTGVuID0ga2V5ZnJhbWVzLmxlbmd0aDtcbiAgICAgICAgaWYgKCF0cmFja0xlbikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIEd1ZXNzIGRhdGEgdHlwZVxuICAgICAgICB2YXIgZmlyc3RWYWwgPSBrZXlmcmFtZXNbMF0udmFsdWU7XG4gICAgICAgIHZhciBpc1ZhbHVlQXJyYXkgPSBpc0FycmF5TGlrZShmaXJzdFZhbCk7XG4gICAgICAgIHZhciBpc1ZhbHVlQ29sb3IgPSBmYWxzZTtcbiAgICAgICAgdmFyIGlzVmFsdWVTdHJpbmcgPSBmYWxzZTtcblxuICAgICAgICAvLyBGb3IgdmVydGljZXMgbW9ycGhpbmdcbiAgICAgICAgdmFyIGFyckRpbSA9IChcbiAgICAgICAgICAgICAgICBpc1ZhbHVlQXJyYXlcbiAgICAgICAgICAgICAgICAmJiBpc0FycmF5TGlrZShmaXJzdFZhbFswXSlcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgID8gMiA6IDE7XG4gICAgICAgIHZhciB0cmFja01heFRpbWU7XG4gICAgICAgIC8vIFNvcnQga2V5ZnJhbWUgYXMgYXNjZW5kaW5nXG4gICAgICAgIGtleWZyYW1lcy5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgICAgIHJldHVybiBhLnRpbWUgLSBiLnRpbWU7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRyYWNrTWF4VGltZSA9IGtleWZyYW1lc1t0cmFja0xlbiAtIDFdLnRpbWU7XG4gICAgICAgIC8vIFBlcmNlbnRzIG9mIGVhY2gga2V5ZnJhbWVcbiAgICAgICAgdmFyIGtmUGVyY2VudHMgPSBbXTtcbiAgICAgICAgLy8gVmFsdWUgb2YgZWFjaCBrZXlmcmFtZVxuICAgICAgICB2YXIga2ZWYWx1ZXMgPSBbXTtcbiAgICAgICAgdmFyIHByZXZWYWx1ZSA9IGtleWZyYW1lc1swXS52YWx1ZTtcbiAgICAgICAgdmFyIGlzQWxsVmFsdWVFcXVhbCA9IHRydWU7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHJhY2tMZW47IGkrKykge1xuICAgICAgICAgICAga2ZQZXJjZW50cy5wdXNoKGtleWZyYW1lc1tpXS50aW1lIC8gdHJhY2tNYXhUaW1lKTtcbiAgICAgICAgICAgIC8vIEFzc3VtZSB2YWx1ZSBpcyBhIGNvbG9yIHdoZW4gaXQgaXMgYSBzdHJpbmdcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IGtleWZyYW1lc1tpXS52YWx1ZTtcblxuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdmFsdWUgaXMgZXF1YWwsIGRlZXAgY2hlY2sgaWYgdmFsdWUgaXMgYXJyYXlcbiAgICAgICAgICAgIGlmICghKChpc1ZhbHVlQXJyYXkgJiYgaXNBcnJheVNhbWUodmFsdWUsIHByZXZWYWx1ZSwgYXJyRGltKSlcbiAgICAgICAgICAgICAgICB8fCAoIWlzVmFsdWVBcnJheSAmJiB2YWx1ZSA9PT0gcHJldlZhbHVlKSkpIHtcbiAgICAgICAgICAgICAgICBpc0FsbFZhbHVlRXF1YWwgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByZXZWYWx1ZSA9IHZhbHVlO1xuXG4gICAgICAgICAgICAvLyBUcnkgY29udmVydGluZyBhIHN0cmluZyB0byBhIGNvbG9yIGFycmF5XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbG9yQXJyYXkgPSBjb2xvci5wYXJzZSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKGNvbG9yQXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBjb2xvckFycmF5O1xuICAgICAgICAgICAgICAgICAgICBpc1ZhbHVlQ29sb3IgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaXNWYWx1ZVN0cmluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAga2ZWYWx1ZXMucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzQWxsVmFsdWVFcXVhbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxhc3RWYWx1ZSA9IGtmVmFsdWVzW3RyYWNrTGVuIC0gMV07XG4gICAgICAgIC8vIFBvbHlmaWxsIGFycmF5IGFuZCBOYU4gdmFsdWVcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmFja0xlbiAtIDE7IGkrKykge1xuICAgICAgICAgICAgaWYgKGlzVmFsdWVBcnJheSkge1xuICAgICAgICAgICAgICAgIGZpbGxBcnIoa2ZWYWx1ZXNbaV0sIGxhc3RWYWx1ZSwgYXJyRGltKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChpc05hTihrZlZhbHVlc1tpXSkgJiYgIWlzTmFOKGxhc3RWYWx1ZSkgJiYgIWlzVmFsdWVTdHJpbmcgJiYgIWlzVmFsdWVDb2xvcikge1xuICAgICAgICAgICAgICAgICAgICBrZlZhbHVlc1tpXSA9IGxhc3RWYWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaXNWYWx1ZUFycmF5ICYmIGZpbGxBcnIoZ2V0dGVyKGFuaW1hdG9yLl90YXJnZXQsIHByb3BOYW1lKSwgbGFzdFZhbHVlLCBhcnJEaW0pO1xuXG4gICAgICAgIC8vIENhY2hlIHRoZSBrZXkgb2YgbGFzdCBmcmFtZSB0byBzcGVlZCB1cCB3aGVuXG4gICAgICAgIC8vIGFuaW1hdGlvbiBwbGF5YmFjayBpcyBzZXF1ZW5jeVxuICAgICAgICB2YXIgbGFzdEZyYW1lID0gMDtcbiAgICAgICAgdmFyIGxhc3RGcmFtZVBlcmNlbnQgPSAwO1xuICAgICAgICB2YXIgc3RhcnQ7XG4gICAgICAgIHZhciB3O1xuICAgICAgICB2YXIgcDA7XG4gICAgICAgIHZhciBwMTtcbiAgICAgICAgdmFyIHAyO1xuICAgICAgICB2YXIgcDM7XG5cbiAgICAgICAgaWYgKGlzVmFsdWVDb2xvcikge1xuICAgICAgICAgICAgdmFyIHJnYmEgPSBbMCwgMCwgMCwgMF07XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgb25mcmFtZSA9IGZ1bmN0aW9uICh0YXJnZXQsIHBlcmNlbnQpIHtcbiAgICAgICAgICAgIC8vIEZpbmQgdGhlIHJhbmdlIGtleWZyYW1lc1xuICAgICAgICAgICAgLy8ga2YxLS0tLS1rZjItLS0tLS0tLS1jdXJyZW50LS0tLS0tLS1rZjNcbiAgICAgICAgICAgIC8vIGZpbmQga2YyIGFuZCBrZjMgYW5kIGRvIGludGVycG9sYXRpb25cbiAgICAgICAgICAgIHZhciBmcmFtZTtcbiAgICAgICAgICAgIC8vIEluIHRoZSBlYXNpbmcgZnVuY3Rpb24gbGlrZSBlbGFzdGljT3V0LCBwZXJjZW50IG1heSBsZXNzIHRoYW4gMFxuICAgICAgICAgICAgaWYgKHBlcmNlbnQgPCAwKSB7XG4gICAgICAgICAgICAgICAgZnJhbWUgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocGVyY2VudCA8IGxhc3RGcmFtZVBlcmNlbnQpIHtcbiAgICAgICAgICAgICAgICAvLyBTdGFydCBmcm9tIG5leHQga2V5XG4gICAgICAgICAgICAgICAgLy8gUEVORElORyBzdGFydCBmcm9tIGxhc3RGcmFtZSA/XG4gICAgICAgICAgICAgICAgc3RhcnQgPSBNYXRoLm1pbihsYXN0RnJhbWUgKyAxLCB0cmFja0xlbiAtIDEpO1xuICAgICAgICAgICAgICAgIGZvciAoZnJhbWUgPSBzdGFydDsgZnJhbWUgPj0gMDsgZnJhbWUtLSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoa2ZQZXJjZW50c1tmcmFtZV0gPD0gcGVyY2VudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gUEVORElORyByZWFsbHkgbmVlZCB0byBkbyB0aGlzID9cbiAgICAgICAgICAgICAgICBmcmFtZSA9IE1hdGgubWluKGZyYW1lLCB0cmFja0xlbiAtIDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9yIChmcmFtZSA9IGxhc3RGcmFtZTsgZnJhbWUgPCB0cmFja0xlbjsgZnJhbWUrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoa2ZQZXJjZW50c1tmcmFtZV0gPiBwZXJjZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmcmFtZSA9IE1hdGgubWluKGZyYW1lIC0gMSwgdHJhY2tMZW4gLSAyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxhc3RGcmFtZSA9IGZyYW1lO1xuICAgICAgICAgICAgbGFzdEZyYW1lUGVyY2VudCA9IHBlcmNlbnQ7XG5cbiAgICAgICAgICAgIHZhciByYW5nZSA9IChrZlBlcmNlbnRzW2ZyYW1lICsgMV0gLSBrZlBlcmNlbnRzW2ZyYW1lXSk7XG4gICAgICAgICAgICBpZiAocmFuZ2UgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB3ID0gKHBlcmNlbnQgLSBrZlBlcmNlbnRzW2ZyYW1lXSkgLyByYW5nZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh1c2VTcGxpbmUpIHtcbiAgICAgICAgICAgICAgICBwMSA9IGtmVmFsdWVzW2ZyYW1lXTtcbiAgICAgICAgICAgICAgICBwMCA9IGtmVmFsdWVzW2ZyYW1lID09PSAwID8gZnJhbWUgOiBmcmFtZSAtIDFdO1xuICAgICAgICAgICAgICAgIHAyID0ga2ZWYWx1ZXNbZnJhbWUgPiB0cmFja0xlbiAtIDIgPyB0cmFja0xlbiAtIDEgOiBmcmFtZSArIDFdO1xuICAgICAgICAgICAgICAgIHAzID0ga2ZWYWx1ZXNbZnJhbWUgPiB0cmFja0xlbiAtIDMgPyB0cmFja0xlbiAtIDEgOiBmcmFtZSArIDJdO1xuICAgICAgICAgICAgICAgIGlmIChpc1ZhbHVlQXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2F0bXVsbFJvbUludGVycG9sYXRlQXJyYXkoXG4gICAgICAgICAgICAgICAgICAgICAgICBwMCwgcDEsIHAyLCBwMywgdywgdyAqIHcsIHcgKiB3ICogdyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldHRlcih0YXJnZXQsIHByb3BOYW1lKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyckRpbVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNWYWx1ZUNvbG9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGNhdG11bGxSb21JbnRlcnBvbGF0ZUFycmF5KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAwLCBwMSwgcDIsIHAzLCB3LCB3ICogdywgdyAqIHcgKiB3LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJnYmEsIDFcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHJnYmEyU3RyaW5nKHJnYmEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzVmFsdWVTdHJpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN0cmluZyBpcyBzdGVwKDAuNSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpbnRlcnBvbGF0ZVN0cmluZyhwMSwgcDIsIHcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBjYXRtdWxsUm9tSW50ZXJwb2xhdGUoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcDAsIHAxLCBwMiwgcDMsIHcsIHcgKiB3LCB3ICogdyAqIHdcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc2V0dGVyKFxuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcE5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChpc1ZhbHVlQXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgaW50ZXJwb2xhdGVBcnJheShcbiAgICAgICAgICAgICAgICAgICAgICAgIGtmVmFsdWVzW2ZyYW1lXSwga2ZWYWx1ZXNbZnJhbWUgKyAxXSwgdyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldHRlcih0YXJnZXQsIHByb3BOYW1lKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyckRpbVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNWYWx1ZUNvbG9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRlcnBvbGF0ZUFycmF5KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtmVmFsdWVzW2ZyYW1lXSwga2ZWYWx1ZXNbZnJhbWUgKyAxXSwgdyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZ2JhLCAxXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSByZ2JhMlN0cmluZyhyZ2JhKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpc1ZhbHVlU3RyaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTdHJpbmcgaXMgc3RlcCgwLjUpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW50ZXJwb2xhdGVTdHJpbmcoa2ZWYWx1ZXNbZnJhbWVdLCBrZlZhbHVlc1tmcmFtZSArIDFdLCB3KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gaW50ZXJwb2xhdGVOdW1iZXIoa2ZWYWx1ZXNbZnJhbWVdLCBrZlZhbHVlc1tmcmFtZSArIDFdLCB3KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzZXR0ZXIoXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBjbGlwID0gbmV3IENsaXAoe1xuICAgICAgICAgICAgdGFyZ2V0OiBhbmltYXRvci5fdGFyZ2V0LFxuICAgICAgICAgICAgbGlmZTogdHJhY2tNYXhUaW1lLFxuICAgICAgICAgICAgbG9vcDogYW5pbWF0b3IuX2xvb3AsXG4gICAgICAgICAgICBkZWxheTogYW5pbWF0b3IuX2RlbGF5LFxuICAgICAgICAgICAgb25mcmFtZTogb25mcmFtZSxcbiAgICAgICAgICAgIG9uZGVzdHJveTogb25lVHJhY2tEb25lXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChlYXNpbmcgJiYgZWFzaW5nICE9PSAnc3BsaW5lJykge1xuICAgICAgICAgICAgY2xpcC5lYXNpbmcgPSBlYXNpbmc7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2xpcDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAYWxpYXMgbW9kdWxlOnpyZW5kZXIvYW5pbWF0aW9uL0FuaW1hdG9yXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHRhcmdldFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gbG9vcFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGdldHRlclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHNldHRlclxuICAgICAqL1xuICAgIHZhciBBbmltYXRvciA9IGZ1bmN0aW9uKHRhcmdldCwgbG9vcCwgZ2V0dGVyLCBzZXR0ZXIpIHtcbiAgICAgICAgdGhpcy5fdHJhY2tzID0ge307XG4gICAgICAgIHRoaXMuX3RhcmdldCA9IHRhcmdldDtcblxuICAgICAgICB0aGlzLl9sb29wID0gbG9vcCB8fCBmYWxzZTtcblxuICAgICAgICB0aGlzLl9nZXR0ZXIgPSBnZXR0ZXIgfHwgZGVmYXVsdEdldHRlcjtcbiAgICAgICAgdGhpcy5fc2V0dGVyID0gc2V0dGVyIHx8IGRlZmF1bHRTZXR0ZXI7XG5cbiAgICAgICAgdGhpcy5fY2xpcENvdW50ID0gMDtcblxuICAgICAgICB0aGlzLl9kZWxheSA9IDA7XG5cbiAgICAgICAgdGhpcy5fZG9uZUxpc3QgPSBbXTtcblxuICAgICAgICB0aGlzLl9vbmZyYW1lTGlzdCA9IFtdO1xuXG4gICAgICAgIHRoaXMuX2NsaXBMaXN0ID0gW107XG4gICAgfTtcblxuICAgIEFuaW1hdG9yLnByb3RvdHlwZSA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOiuvue9ruWKqOeUu+WFs+mUruW4p1xuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHRpbWUg5YWz6ZSu5bin5pe26Ze077yM5Y2V5L2N5pivbXNcbiAgICAgICAgICogQHBhcmFtICB7T2JqZWN0fSBwcm9wcyDlhbPplK7luKfnmoTlsZ7mgKflgLzvvIxrZXktdmFsdWXooajnpLpcbiAgICAgICAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvYW5pbWF0aW9uL0FuaW1hdG9yfVxuICAgICAgICAgKi9cbiAgICAgICAgd2hlbjogZnVuY3Rpb24odGltZSAvKiBtcyAqLywgcHJvcHMpIHtcbiAgICAgICAgICAgIHZhciB0cmFja3MgPSB0aGlzLl90cmFja3M7XG4gICAgICAgICAgICBmb3IgKHZhciBwcm9wTmFtZSBpbiBwcm9wcykge1xuICAgICAgICAgICAgICAgIGlmICghdHJhY2tzW3Byb3BOYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICB0cmFja3NbcHJvcE5hbWVdID0gW107XG4gICAgICAgICAgICAgICAgICAgIC8vIEludmFsaWQgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5fZ2V0dGVyKHRoaXMuX3RhcmdldCwgcHJvcE5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8genJMb2coJ0ludmFsaWQgcHJvcGVydHkgJyArIHByb3BOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRpbWUgaXMgMFxuICAgICAgICAgICAgICAgICAgICAvLyAgVGhlbiBwcm9wcyBpcyBnaXZlbiBpbml0aWFsaXplIHZhbHVlXG4gICAgICAgICAgICAgICAgICAgIC8vIEVsc2VcbiAgICAgICAgICAgICAgICAgICAgLy8gIEluaXRpYWxpemUgdmFsdWUgZnJvbSBjdXJyZW50IHByb3AgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRpbWUgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYWNrc1twcm9wTmFtZV0ucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZTogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogY2xvbmVWYWx1ZSh2YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRyYWNrc1twcm9wTmFtZV0ucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHRpbWU6IHRpbWUsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBwcm9wc1twcm9wTmFtZV1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICog5re75Yqg5Yqo55S75q+P5LiA5bin55qE5Zue6LCD5Ye95pWwXG4gICAgICAgICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgICAgICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9hbmltYXRpb24vQW5pbWF0b3J9XG4gICAgICAgICAqL1xuICAgICAgICBkdXJpbmc6IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICAgICAgdGhpcy5fb25mcmFtZUxpc3QucHVzaChjYWxsYmFjayk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBfZG9uZUNhbGxiYWNrOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBDbGVhciBhbGwgdHJhY2tzXG4gICAgICAgICAgICB0aGlzLl90cmFja3MgPSB7fTtcbiAgICAgICAgICAgIC8vIENsZWFyIGFsbCBjbGlwc1xuICAgICAgICAgICAgdGhpcy5fY2xpcExpc3QubGVuZ3RoID0gMDtcblxuICAgICAgICAgICAgdmFyIGRvbmVMaXN0ID0gdGhpcy5fZG9uZUxpc3Q7XG4gICAgICAgICAgICB2YXIgbGVuID0gZG9uZUxpc3QubGVuZ3RoO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGRvbmVMaXN0W2ldLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlvIDlp4vmiafooYzliqjnlLtcbiAgICAgICAgICogQHBhcmFtICB7c3RyaW5nfEZ1bmN0aW9ufSBlYXNpbmdcbiAgICAgICAgICogICAgICAgICDliqjnlLvnvJPliqjlh73mlbDvvIzor6bop4F7QGxpbmsgbW9kdWxlOnpyZW5kZXIvYW5pbWF0aW9uL2Vhc2luZ31cbiAgICAgICAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvYW5pbWF0aW9uL0FuaW1hdG9yfVxuICAgICAgICAgKi9cbiAgICAgICAgc3RhcnQ6IGZ1bmN0aW9uIChlYXNpbmcpIHtcblxuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIGNsaXBDb3VudCA9IDA7XG5cbiAgICAgICAgICAgIHZhciBvbmVUcmFja0RvbmUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBjbGlwQ291bnQtLTtcbiAgICAgICAgICAgICAgICBpZiAoIWNsaXBDb3VudCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLl9kb25lQ2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB2YXIgbGFzdENsaXA7XG4gICAgICAgICAgICBmb3IgKHZhciBwcm9wTmFtZSBpbiB0aGlzLl90cmFja3MpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2xpcCA9IGNyZWF0ZVRyYWNrQ2xpcChcbiAgICAgICAgICAgICAgICAgICAgdGhpcywgZWFzaW5nLCBvbmVUcmFja0RvbmUsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3RyYWNrc1twcm9wTmFtZV0sIHByb3BOYW1lXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBpZiAoY2xpcCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jbGlwTGlzdC5wdXNoKGNsaXApO1xuICAgICAgICAgICAgICAgICAgICBjbGlwQ291bnQrKztcblxuICAgICAgICAgICAgICAgICAgICAvLyBJZiBzdGFydCBhZnRlciBhZGRlZCB0byBhbmltYXRpb25cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuYW5pbWF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFuaW1hdGlvbi5hZGRDbGlwKGNsaXApO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgbGFzdENsaXAgPSBjbGlwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQWRkIGR1cmluZyBjYWxsYmFjayBvbiB0aGUgbGFzdCBjbGlwXG4gICAgICAgICAgICBpZiAobGFzdENsaXApIHtcbiAgICAgICAgICAgICAgICB2YXIgb2xkT25GcmFtZSA9IGxhc3RDbGlwLm9uZnJhbWU7XG4gICAgICAgICAgICAgICAgbGFzdENsaXAub25mcmFtZSA9IGZ1bmN0aW9uICh0YXJnZXQsIHBlcmNlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgb2xkT25GcmFtZSh0YXJnZXQsIHBlcmNlbnQpO1xuXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VsZi5fb25mcmFtZUxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX29uZnJhbWVMaXN0W2ldKHRhcmdldCwgcGVyY2VudCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWNsaXBDb3VudCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2RvbmVDYWxsYmFjaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlgZzmraLliqjnlLtcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBmb3J3YXJkVG9MYXN0IElmIG1vdmUgdG8gbGFzdCBmcmFtZSBiZWZvcmUgc3RvcFxuICAgICAgICAgKi9cbiAgICAgICAgc3RvcDogZnVuY3Rpb24gKGZvcndhcmRUb0xhc3QpIHtcbiAgICAgICAgICAgIHZhciBjbGlwTGlzdCA9IHRoaXMuX2NsaXBMaXN0O1xuICAgICAgICAgICAgdmFyIGFuaW1hdGlvbiA9IHRoaXMuYW5pbWF0aW9uO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbGlwTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBjbGlwID0gY2xpcExpc3RbaV07XG4gICAgICAgICAgICAgICAgaWYgKGZvcndhcmRUb0xhc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTW92ZSB0byBsYXN0IGZyYW1lIGJlZm9yZSBzdG9wXG4gICAgICAgICAgICAgICAgICAgIGNsaXAub25mcmFtZSh0aGlzLl90YXJnZXQsIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhbmltYXRpb24gJiYgYW5pbWF0aW9uLnJlbW92ZUNsaXAoY2xpcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjbGlwTGlzdC5sZW5ndGggPSAwO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICog6K6+572u5Yqo55S75bu26L+f5byA5aeL55qE5pe26Ze0XG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gdGltZSDljZXkvY1tc1xuICAgICAgICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9hbmltYXRpb24vQW5pbWF0b3J9XG4gICAgICAgICAqL1xuICAgICAgICBkZWxheTogZnVuY3Rpb24gKHRpbWUpIHtcbiAgICAgICAgICAgIHRoaXMuX2RlbGF5ID0gdGltZTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICog5re75Yqg5Yqo55S757uT5p2f55qE5Zue6LCDXG4gICAgICAgICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBjYlxuICAgICAgICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9hbmltYXRpb24vQW5pbWF0b3J9XG4gICAgICAgICAqL1xuICAgICAgICBkb25lOiBmdW5jdGlvbihjYikge1xuICAgICAgICAgICAgaWYgKGNiKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZG9uZUxpc3QucHVzaChjYik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7QXJyYXkuPG1vZHVsZTp6cmVuZGVyL2FuaW1hdGlvbi9DbGlwPn1cbiAgICAgICAgICovXG4gICAgICAgIGdldENsaXBzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY2xpcExpc3Q7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBBbmltYXRvcjtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3pyZW5kZXIvbGliL2FuaW1hdGlvbi9BbmltYXRvci5qc1xuICoqIG1vZHVsZSBpZCA9IDE2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIOWKqOeUu+S4u+aOp+WItuWZqFxuICogQGNvbmZpZyB0YXJnZXQg5Yqo55S75a+56LGh77yM5Y+v5Lul5piv5pWw57uE77yM5aaC5p6c5piv5pWw57uE55qE6K+d5Lya5om56YeP5YiG5Y+Rb25mcmFtZeetieS6i+S7tlxuICogQGNvbmZpZyBsaWZlKDEwMDApIOWKqOeUu+aXtumVv1xuICogQGNvbmZpZyBkZWxheSgwKSDliqjnlLvlu7bov5/ml7bpl7RcbiAqIEBjb25maWcgbG9vcCh0cnVlKVxuICogQGNvbmZpZyBnYXAoMCkg5b6q546v55qE6Ze06ZqU5pe26Ze0XG4gKiBAY29uZmlnIG9uZnJhbWVcbiAqIEBjb25maWcgZWFzaW5nKG9wdGlvbmFsKVxuICogQGNvbmZpZyBvbmRlc3Ryb3kob3B0aW9uYWwpXG4gKiBAY29uZmlnIG9ucmVzdGFydChvcHRpb25hbClcbiAqXG4gKiBUT0RPIHBhdXNlXG4gKi9cblxuXG4gICAgdmFyIGVhc2luZ0Z1bmNzID0gcmVxdWlyZSgnLi9lYXNpbmcnKTtcblxuICAgIGZ1bmN0aW9uIENsaXAob3B0aW9ucykge1xuXG4gICAgICAgIHRoaXMuX3RhcmdldCA9IG9wdGlvbnMudGFyZ2V0O1xuXG4gICAgICAgIC8vIOeUn+WRveWRqOacn1xuICAgICAgICB0aGlzLl9saWZlID0gb3B0aW9ucy5saWZlIHx8IDEwMDA7XG4gICAgICAgIC8vIOW7tuaXtlxuICAgICAgICB0aGlzLl9kZWxheSA9IG9wdGlvbnMuZGVsYXkgfHwgMDtcbiAgICAgICAgLy8g5byA5aeL5pe26Ze0XG4gICAgICAgIC8vIHRoaXMuX3N0YXJ0VGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpICsgdGhpcy5fZGVsYXk7Ly8g5Y2V5L2N5q+r56eSXG4gICAgICAgIHRoaXMuX2luaXRpYWxpemVkID0gZmFsc2U7XG5cbiAgICAgICAgLy8g5piv5ZCm5b6q546vXG4gICAgICAgIHRoaXMubG9vcCA9IG9wdGlvbnMubG9vcCA9PSBudWxsID8gZmFsc2UgOiBvcHRpb25zLmxvb3A7XG5cbiAgICAgICAgdGhpcy5nYXAgPSBvcHRpb25zLmdhcCB8fCAwO1xuXG4gICAgICAgIHRoaXMuZWFzaW5nID0gb3B0aW9ucy5lYXNpbmcgfHwgJ0xpbmVhcic7XG5cbiAgICAgICAgdGhpcy5vbmZyYW1lID0gb3B0aW9ucy5vbmZyYW1lO1xuICAgICAgICB0aGlzLm9uZGVzdHJveSA9IG9wdGlvbnMub25kZXN0cm95O1xuICAgICAgICB0aGlzLm9ucmVzdGFydCA9IG9wdGlvbnMub25yZXN0YXJ0O1xuICAgIH1cblxuICAgIENsaXAucHJvdG90eXBlID0ge1xuXG4gICAgICAgIGNvbnN0cnVjdG9yOiBDbGlwLFxuXG4gICAgICAgIHN0ZXA6IGZ1bmN0aW9uIChnbG9iYWxUaW1lKSB7XG4gICAgICAgICAgICAvLyBTZXQgc3RhcnRUaW1lIG9uIGZpcnN0IHN0ZXAsIG9yIF9zdGFydFRpbWUgbWF5IGhhcyBtaWxsZXNlY29uZHMgZGlmZmVyZW50IGJldHdlZW4gY2xpcHNcbiAgICAgICAgICAgIC8vIFBFTkRJTkdcbiAgICAgICAgICAgIGlmICghdGhpcy5faW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGFydFRpbWUgPSBnbG9iYWxUaW1lICsgdGhpcy5fZGVsYXk7XG4gICAgICAgICAgICAgICAgdGhpcy5faW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgcGVyY2VudCA9IChnbG9iYWxUaW1lIC0gdGhpcy5fc3RhcnRUaW1lKSAvIHRoaXMuX2xpZmU7XG5cbiAgICAgICAgICAgIC8vIOi/mOayoeW8gOWni1xuICAgICAgICAgICAgaWYgKHBlcmNlbnQgPCAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwZXJjZW50ID0gTWF0aC5taW4ocGVyY2VudCwgMSk7XG5cbiAgICAgICAgICAgIHZhciBlYXNpbmcgPSB0aGlzLmVhc2luZztcbiAgICAgICAgICAgIHZhciBlYXNpbmdGdW5jID0gdHlwZW9mIGVhc2luZyA9PSAnc3RyaW5nJyA/IGVhc2luZ0Z1bmNzW2Vhc2luZ10gOiBlYXNpbmc7XG4gICAgICAgICAgICB2YXIgc2NoZWR1bGUgPSB0eXBlb2YgZWFzaW5nRnVuYyA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgICAgID8gZWFzaW5nRnVuYyhwZXJjZW50KVxuICAgICAgICAgICAgICAgIDogcGVyY2VudDtcblxuICAgICAgICAgICAgdGhpcy5maXJlKCdmcmFtZScsIHNjaGVkdWxlKTtcblxuICAgICAgICAgICAgLy8g57uT5p2fXG4gICAgICAgICAgICBpZiAocGVyY2VudCA9PSAxKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubG9vcCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc3RhcnQgKGdsb2JhbFRpbWUpO1xuICAgICAgICAgICAgICAgICAgICAvLyDph43mlrDlvIDlp4vlkajmnJ9cbiAgICAgICAgICAgICAgICAgICAgLy8g5oqb5Ye66ICM5LiN5piv55u05o6l6LCD55So5LqL5Lu255u05YiwIHN0YWdlLnVwZGF0ZSDlkI7lho3nu5/kuIDosIPnlKjov5nkupvkuovku7ZcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdyZXN0YXJ0JztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyDliqjnlLvlrozmiJDlsIbov5nkuKrmjqfliLblmajmoIfor4bkuLrlvoXliKDpmaRcbiAgICAgICAgICAgICAgICAvLyDlnKhBbmltYXRpb24udXBkYXRl5Lit6L+b6KGM5om56YeP5Yig6ZmkXG4gICAgICAgICAgICAgICAgdGhpcy5fbmVlZHNSZW1vdmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJldHVybiAnZGVzdHJveSc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9LFxuXG4gICAgICAgIHJlc3RhcnQ6IGZ1bmN0aW9uIChnbG9iYWxUaW1lKSB7XG4gICAgICAgICAgICB2YXIgcmVtYWluZGVyID0gKGdsb2JhbFRpbWUgLSB0aGlzLl9zdGFydFRpbWUpICUgdGhpcy5fbGlmZTtcbiAgICAgICAgICAgIHRoaXMuX3N0YXJ0VGltZSA9IGdsb2JhbFRpbWUgLSByZW1haW5kZXIgKyB0aGlzLmdhcDtcblxuICAgICAgICAgICAgdGhpcy5fbmVlZHNSZW1vdmUgPSBmYWxzZTtcbiAgICAgICAgfSxcblxuICAgICAgICBmaXJlOiBmdW5jdGlvbihldmVudFR5cGUsIGFyZykge1xuICAgICAgICAgICAgZXZlbnRUeXBlID0gJ29uJyArIGV2ZW50VHlwZTtcbiAgICAgICAgICAgIGlmICh0aGlzW2V2ZW50VHlwZV0pIHtcbiAgICAgICAgICAgICAgICB0aGlzW2V2ZW50VHlwZV0odGhpcy5fdGFyZ2V0LCBhcmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gQ2xpcDtcblxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34venJlbmRlci9saWIvYW5pbWF0aW9uL0NsaXAuanNcbiAqKiBtb2R1bGUgaWQgPSAxN1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiDnvJPliqjku6PnoIHmnaXoh6ogaHR0cHM6Ly9naXRodWIuY29tL3NvbGUvdHdlZW4uanMvYmxvYi9tYXN0ZXIvc3JjL1R3ZWVuLmpzXG4gKiBAc2VlIGh0dHA6Ly9zb2xlLmdpdGh1Yi5pby90d2Vlbi5qcy9leGFtcGxlcy8wM19ncmFwaHMuaHRtbFxuICogQGV4cG9ydHMgenJlbmRlci9hbmltYXRpb24vZWFzaW5nXG4gKi9cblxuICAgIHZhciBlYXNpbmcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAqL1xuICAgICAgICBsaW5lYXI6IGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICByZXR1cm4gaztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgKi9cbiAgICAgICAgcXVhZHJhdGljSW46IGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICByZXR1cm4gayAqIGs7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAqL1xuICAgICAgICBxdWFkcmF0aWNPdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICByZXR1cm4gayAqICgyIC0gayk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAqL1xuICAgICAgICBxdWFkcmF0aWNJbk91dDogZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgIGlmICgoayAqPSAyKSA8IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMC41ICogayAqIGs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gLTAuNSAqICgtLWsgKiAoayAtIDIpIC0gMSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8g5LiJ5qyh5pa555qE57yT5Yqo77yIdF4z77yJXG4gICAgICAgIC8qKlxuICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAqL1xuICAgICAgICBjdWJpY0luOiBmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgcmV0dXJuIGsgKiBrICogaztcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICovXG4gICAgICAgIGN1YmljT3V0OiBmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgcmV0dXJuIC0tayAqIGsgKiBrICsgMTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICovXG4gICAgICAgIGN1YmljSW5PdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICBpZiAoKGsgKj0gMikgPCAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDAuNSAqIGsgKiBrICogaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAwLjUgKiAoKGsgLT0gMikgKiBrICogayArIDIpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIOWbm+asoeaWueeahOe8k+WKqO+8iHReNO+8iVxuICAgICAgICAvKipcbiAgICAgICAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgKi9cbiAgICAgICAgcXVhcnRpY0luOiBmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgcmV0dXJuIGsgKiBrICogayAqIGs7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAqL1xuICAgICAgICBxdWFydGljT3V0OiBmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgcmV0dXJuIDEgLSAoLS1rICogayAqIGsgKiBrKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICovXG4gICAgICAgIHF1YXJ0aWNJbk91dDogZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgIGlmICgoayAqPSAyKSA8IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMC41ICogayAqIGsgKiBrICogaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAtMC41ICogKChrIC09IDIpICogayAqIGsgKiBrIC0gMik7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8g5LqU5qyh5pa555qE57yT5Yqo77yIdF4177yJXG4gICAgICAgIC8qKlxuICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAqL1xuICAgICAgICBxdWludGljSW46IGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICByZXR1cm4gayAqIGsgKiBrICogayAqIGs7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAqL1xuICAgICAgICBxdWludGljT3V0OiBmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgcmV0dXJuIC0tayAqIGsgKiBrICogayAqIGsgKyAxO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgKi9cbiAgICAgICAgcXVpbnRpY0luT3V0OiBmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgaWYgKChrICo9IDIpIDwgMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAwLjUgKiBrICogayAqIGsgKiBrICogaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAwLjUgKiAoKGsgLT0gMikgKiBrICogayAqIGsgKiBrICsgMik7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8g5q2j5bym5puy57q/55qE57yT5Yqo77yIc2luKHQp77yJXG4gICAgICAgIC8qKlxuICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAqL1xuICAgICAgICBzaW51c29pZGFsSW46IGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICByZXR1cm4gMSAtIE1hdGguY29zKGsgKiBNYXRoLlBJIC8gMik7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAqL1xuICAgICAgICBzaW51c29pZGFsT3V0OiBmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguc2luKGsgKiBNYXRoLlBJIC8gMik7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAqL1xuICAgICAgICBzaW51c29pZGFsSW5PdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICByZXR1cm4gMC41ICogKDEgLSBNYXRoLmNvcyhNYXRoLlBJICogaykpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIOaMh+aVsOabsue6v+eahOe8k+WKqO+8iDJedO+8iVxuICAgICAgICAvKipcbiAgICAgICAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgKi9cbiAgICAgICAgZXhwb25lbnRpYWxJbjogZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgIHJldHVybiBrID09PSAwID8gMCA6IE1hdGgucG93KDEwMjQsIGsgLSAxKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICovXG4gICAgICAgIGV4cG9uZW50aWFsT3V0OiBmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgcmV0dXJuIGsgPT09IDEgPyAxIDogMSAtIE1hdGgucG93KDIsIC0xMCAqIGspO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgKi9cbiAgICAgICAgZXhwb25lbnRpYWxJbk91dDogZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgIGlmIChrID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoayA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChrICo9IDIpIDwgMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAwLjUgKiBNYXRoLnBvdygxMDI0LCBrIC0gMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gMC41ICogKC1NYXRoLnBvdygyLCAtMTAgKiAoayAtIDEpKSArIDIpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIOWchuW9ouabsue6v+eahOe8k+WKqO+8iHNxcnQoMS10XjIp77yJXG4gICAgICAgIC8qKlxuICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAqL1xuICAgICAgICBjaXJjdWxhckluOiBmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgcmV0dXJuIDEgLSBNYXRoLnNxcnQoMSAtIGsgKiBrKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICovXG4gICAgICAgIGNpcmN1bGFyT3V0OiBmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguc3FydCgxIC0gKC0tayAqIGspKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICovXG4gICAgICAgIGNpcmN1bGFySW5PdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICBpZiAoKGsgKj0gMikgPCAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIC0wLjUgKiAoTWF0aC5zcXJ0KDEgLSBrICogaykgLSAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAwLjUgKiAoTWF0aC5zcXJ0KDEgLSAoayAtPSAyKSAqIGspICsgMSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8g5Yib5bu657G75Ly85LqO5by557Cn5Zyo5YGc5q2i5YmN5p2l5Zue5oyv6I2h55qE5Yqo55S7XG4gICAgICAgIC8qKlxuICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAqL1xuICAgICAgICBlbGFzdGljSW46IGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICB2YXIgcztcbiAgICAgICAgICAgIHZhciBhID0gMC4xO1xuICAgICAgICAgICAgdmFyIHAgPSAwLjQ7XG4gICAgICAgICAgICBpZiAoayA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGsgPT09IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghYSB8fCBhIDwgMSkge1xuICAgICAgICAgICAgICAgIGEgPSAxOyBzID0gcCAvIDQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzID0gcCAqIE1hdGguYXNpbigxIC8gYSkgLyAoMiAqIE1hdGguUEkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIC0oYSAqIE1hdGgucG93KDIsIDEwICogKGsgLT0gMSkpICpcbiAgICAgICAgICAgICAgICAgICAgICAgIE1hdGguc2luKChrIC0gcykgKiAoMiAqIE1hdGguUEkpIC8gcCkpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgKi9cbiAgICAgICAgZWxhc3RpY091dDogZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgIHZhciBzO1xuICAgICAgICAgICAgdmFyIGEgPSAwLjE7XG4gICAgICAgICAgICB2YXIgcCA9IDAuNDtcbiAgICAgICAgICAgIGlmIChrID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoayA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFhIHx8IGEgPCAxKSB7XG4gICAgICAgICAgICAgICAgYSA9IDE7IHMgPSBwIC8gNDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHMgPSBwICogTWF0aC5hc2luKDEgLyBhKSAvICgyICogTWF0aC5QSSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gKGEgKiBNYXRoLnBvdygyLCAtMTAgKiBrKSAqXG4gICAgICAgICAgICAgICAgICAgIE1hdGguc2luKChrIC0gcykgKiAoMiAqIE1hdGguUEkpIC8gcCkgKyAxKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICovXG4gICAgICAgIGVsYXN0aWNJbk91dDogZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgIHZhciBzO1xuICAgICAgICAgICAgdmFyIGEgPSAwLjE7XG4gICAgICAgICAgICB2YXIgcCA9IDAuNDtcbiAgICAgICAgICAgIGlmIChrID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoayA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFhIHx8IGEgPCAxKSB7XG4gICAgICAgICAgICAgICAgYSA9IDE7IHMgPSBwIC8gNDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHMgPSBwICogTWF0aC5hc2luKDEgLyBhKSAvICgyICogTWF0aC5QSSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKGsgKj0gMikgPCAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIC0wLjUgKiAoYSAqIE1hdGgucG93KDIsIDEwICogKGsgLT0gMSkpXG4gICAgICAgICAgICAgICAgICAgICogTWF0aC5zaW4oKGsgLSBzKSAqICgyICogTWF0aC5QSSkgLyBwKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYSAqIE1hdGgucG93KDIsIC0xMCAqIChrIC09IDEpKVxuICAgICAgICAgICAgICAgICAgICAqIE1hdGguc2luKChrIC0gcykgKiAoMiAqIE1hdGguUEkpIC8gcCkgKiAwLjUgKyAxO1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8g5Zyo5p+Q5LiA5Yqo55S75byA5aeL5rK/5oyH56S655qE6Lev5b6E6L+b6KGM5Yqo55S75aSE55CG5YmN56iN56iN5pS25Zue6K+l5Yqo55S755qE56e75YqoXG4gICAgICAgIC8qKlxuICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAqL1xuICAgICAgICBiYWNrSW46IGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICB2YXIgcyA9IDEuNzAxNTg7XG4gICAgICAgICAgICByZXR1cm4gayAqIGsgKiAoKHMgKyAxKSAqIGsgLSBzKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICovXG4gICAgICAgIGJhY2tPdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICB2YXIgcyA9IDEuNzAxNTg7XG4gICAgICAgICAgICByZXR1cm4gLS1rICogayAqICgocyArIDEpICogayArIHMpICsgMTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICovXG4gICAgICAgIGJhY2tJbk91dDogZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgIHZhciBzID0gMS43MDE1OCAqIDEuNTI1O1xuICAgICAgICAgICAgaWYgKChrICo9IDIpIDwgMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAwLjUgKiAoayAqIGsgKiAoKHMgKyAxKSAqIGsgLSBzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gMC41ICogKChrIC09IDIpICogayAqICgocyArIDEpICogayArIHMpICsgMik7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8g5Yib5bu65by56Lez5pWI5p6cXG4gICAgICAgIC8qKlxuICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAqL1xuICAgICAgICBib3VuY2VJbjogZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgIHJldHVybiAxIC0gZWFzaW5nLmJvdW5jZU91dCgxIC0gayk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAqL1xuICAgICAgICBib3VuY2VPdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICBpZiAoayA8ICgxIC8gMi43NSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gNy41NjI1ICogayAqIGs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrIDwgKDIgLyAyLjc1KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiA3LjU2MjUgKiAoayAtPSAoMS41IC8gMi43NSkpICogayArIDAuNzU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrIDwgKDIuNSAvIDIuNzUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDcuNTYyNSAqIChrIC09ICgyLjI1IC8gMi43NSkpICogayArIDAuOTM3NTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiA3LjU2MjUgKiAoayAtPSAoMi42MjUgLyAyLjc1KSkgKiBrICsgMC45ODQzNzU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAqL1xuICAgICAgICBib3VuY2VJbk91dDogZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgIGlmIChrIDwgMC41KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVhc2luZy5ib3VuY2VJbihrICogMikgKiAwLjU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZWFzaW5nLmJvdW5jZU91dChrICogMiAtIDEpICogMC41ICsgMC41O1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gZWFzaW5nO1xuXG5cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3pyZW5kZXIvbGliL2FuaW1hdGlvbi9lYXNpbmcuanNcbiAqKiBtb2R1bGUgaWQgPSAxOFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBAbW9kdWxlIHpyZW5kZXIvdG9vbC9jb2xvclxuICovXG5cblxuICAgIHZhciBrQ1NTQ29sb3JUYWJsZSA9IHtcbiAgICAgICAgJ3RyYW5zcGFyZW50JzogWzAsMCwwLDBdLCAnYWxpY2VibHVlJzogWzI0MCwyNDgsMjU1LDFdLFxuICAgICAgICAnYW50aXF1ZXdoaXRlJzogWzI1MCwyMzUsMjE1LDFdLCAnYXF1YSc6IFswLDI1NSwyNTUsMV0sXG4gICAgICAgICdhcXVhbWFyaW5lJzogWzEyNywyNTUsMjEyLDFdLCAnYXp1cmUnOiBbMjQwLDI1NSwyNTUsMV0sXG4gICAgICAgICdiZWlnZSc6IFsyNDUsMjQ1LDIyMCwxXSwgJ2Jpc3F1ZSc6IFsyNTUsMjI4LDE5NiwxXSxcbiAgICAgICAgJ2JsYWNrJzogWzAsMCwwLDFdLCAnYmxhbmNoZWRhbG1vbmQnOiBbMjU1LDIzNSwyMDUsMV0sXG4gICAgICAgICdibHVlJzogWzAsMCwyNTUsMV0sICdibHVldmlvbGV0JzogWzEzOCw0MywyMjYsMV0sXG4gICAgICAgICdicm93bic6IFsxNjUsNDIsNDIsMV0sICdidXJseXdvb2QnOiBbMjIyLDE4NCwxMzUsMV0sXG4gICAgICAgICdjYWRldGJsdWUnOiBbOTUsMTU4LDE2MCwxXSwgJ2NoYXJ0cmV1c2UnOiBbMTI3LDI1NSwwLDFdLFxuICAgICAgICAnY2hvY29sYXRlJzogWzIxMCwxMDUsMzAsMV0sICdjb3JhbCc6IFsyNTUsMTI3LDgwLDFdLFxuICAgICAgICAnY29ybmZsb3dlcmJsdWUnOiBbMTAwLDE0OSwyMzcsMV0sICdjb3Juc2lsayc6IFsyNTUsMjQ4LDIyMCwxXSxcbiAgICAgICAgJ2NyaW1zb24nOiBbMjIwLDIwLDYwLDFdLCAnY3lhbic6IFswLDI1NSwyNTUsMV0sXG4gICAgICAgICdkYXJrYmx1ZSc6IFswLDAsMTM5LDFdLCAnZGFya2N5YW4nOiBbMCwxMzksMTM5LDFdLFxuICAgICAgICAnZGFya2dvbGRlbnJvZCc6IFsxODQsMTM0LDExLDFdLCAnZGFya2dyYXknOiBbMTY5LDE2OSwxNjksMV0sXG4gICAgICAgICdkYXJrZ3JlZW4nOiBbMCwxMDAsMCwxXSwgJ2RhcmtncmV5JzogWzE2OSwxNjksMTY5LDFdLFxuICAgICAgICAnZGFya2toYWtpJzogWzE4OSwxODMsMTA3LDFdLCAnZGFya21hZ2VudGEnOiBbMTM5LDAsMTM5LDFdLFxuICAgICAgICAnZGFya29saXZlZ3JlZW4nOiBbODUsMTA3LDQ3LDFdLCAnZGFya29yYW5nZSc6IFsyNTUsMTQwLDAsMV0sXG4gICAgICAgICdkYXJrb3JjaGlkJzogWzE1Myw1MCwyMDQsMV0sICdkYXJrcmVkJzogWzEzOSwwLDAsMV0sXG4gICAgICAgICdkYXJrc2FsbW9uJzogWzIzMywxNTAsMTIyLDFdLCAnZGFya3NlYWdyZWVuJzogWzE0MywxODgsMTQzLDFdLFxuICAgICAgICAnZGFya3NsYXRlYmx1ZSc6IFs3Miw2MSwxMzksMV0sICdkYXJrc2xhdGVncmF5JzogWzQ3LDc5LDc5LDFdLFxuICAgICAgICAnZGFya3NsYXRlZ3JleSc6IFs0Nyw3OSw3OSwxXSwgJ2Rhcmt0dXJxdW9pc2UnOiBbMCwyMDYsMjA5LDFdLFxuICAgICAgICAnZGFya3Zpb2xldCc6IFsxNDgsMCwyMTEsMV0sICdkZWVwcGluayc6IFsyNTUsMjAsMTQ3LDFdLFxuICAgICAgICAnZGVlcHNreWJsdWUnOiBbMCwxOTEsMjU1LDFdLCAnZGltZ3JheSc6IFsxMDUsMTA1LDEwNSwxXSxcbiAgICAgICAgJ2RpbWdyZXknOiBbMTA1LDEwNSwxMDUsMV0sICdkb2RnZXJibHVlJzogWzMwLDE0NCwyNTUsMV0sXG4gICAgICAgICdmaXJlYnJpY2snOiBbMTc4LDM0LDM0LDFdLCAnZmxvcmFsd2hpdGUnOiBbMjU1LDI1MCwyNDAsMV0sXG4gICAgICAgICdmb3Jlc3RncmVlbic6IFszNCwxMzksMzQsMV0sICdmdWNoc2lhJzogWzI1NSwwLDI1NSwxXSxcbiAgICAgICAgJ2dhaW5zYm9ybyc6IFsyMjAsMjIwLDIyMCwxXSwgJ2dob3N0d2hpdGUnOiBbMjQ4LDI0OCwyNTUsMV0sXG4gICAgICAgICdnb2xkJzogWzI1NSwyMTUsMCwxXSwgJ2dvbGRlbnJvZCc6IFsyMTgsMTY1LDMyLDFdLFxuICAgICAgICAnZ3JheSc6IFsxMjgsMTI4LDEyOCwxXSwgJ2dyZWVuJzogWzAsMTI4LDAsMV0sXG4gICAgICAgICdncmVlbnllbGxvdyc6IFsxNzMsMjU1LDQ3LDFdLCAnZ3JleSc6IFsxMjgsMTI4LDEyOCwxXSxcbiAgICAgICAgJ2hvbmV5ZGV3JzogWzI0MCwyNTUsMjQwLDFdLCAnaG90cGluayc6IFsyNTUsMTA1LDE4MCwxXSxcbiAgICAgICAgJ2luZGlhbnJlZCc6IFsyMDUsOTIsOTIsMV0sICdpbmRpZ28nOiBbNzUsMCwxMzAsMV0sXG4gICAgICAgICdpdm9yeSc6IFsyNTUsMjU1LDI0MCwxXSwgJ2toYWtpJzogWzI0MCwyMzAsMTQwLDFdLFxuICAgICAgICAnbGF2ZW5kZXInOiBbMjMwLDIzMCwyNTAsMV0sICdsYXZlbmRlcmJsdXNoJzogWzI1NSwyNDAsMjQ1LDFdLFxuICAgICAgICAnbGF3bmdyZWVuJzogWzEyNCwyNTIsMCwxXSwgJ2xlbW9uY2hpZmZvbic6IFsyNTUsMjUwLDIwNSwxXSxcbiAgICAgICAgJ2xpZ2h0Ymx1ZSc6IFsxNzMsMjE2LDIzMCwxXSwgJ2xpZ2h0Y29yYWwnOiBbMjQwLDEyOCwxMjgsMV0sXG4gICAgICAgICdsaWdodGN5YW4nOiBbMjI0LDI1NSwyNTUsMV0sICdsaWdodGdvbGRlbnJvZHllbGxvdyc6IFsyNTAsMjUwLDIxMCwxXSxcbiAgICAgICAgJ2xpZ2h0Z3JheSc6IFsyMTEsMjExLDIxMSwxXSwgJ2xpZ2h0Z3JlZW4nOiBbMTQ0LDIzOCwxNDQsMV0sXG4gICAgICAgICdsaWdodGdyZXknOiBbMjExLDIxMSwyMTEsMV0sICdsaWdodHBpbmsnOiBbMjU1LDE4MiwxOTMsMV0sXG4gICAgICAgICdsaWdodHNhbG1vbic6IFsyNTUsMTYwLDEyMiwxXSwgJ2xpZ2h0c2VhZ3JlZW4nOiBbMzIsMTc4LDE3MCwxXSxcbiAgICAgICAgJ2xpZ2h0c2t5Ymx1ZSc6IFsxMzUsMjA2LDI1MCwxXSwgJ2xpZ2h0c2xhdGVncmF5JzogWzExOSwxMzYsMTUzLDFdLFxuICAgICAgICAnbGlnaHRzbGF0ZWdyZXknOiBbMTE5LDEzNiwxNTMsMV0sICdsaWdodHN0ZWVsYmx1ZSc6IFsxNzYsMTk2LDIyMiwxXSxcbiAgICAgICAgJ2xpZ2h0eWVsbG93JzogWzI1NSwyNTUsMjI0LDFdLCAnbGltZSc6IFswLDI1NSwwLDFdLFxuICAgICAgICAnbGltZWdyZWVuJzogWzUwLDIwNSw1MCwxXSwgJ2xpbmVuJzogWzI1MCwyNDAsMjMwLDFdLFxuICAgICAgICAnbWFnZW50YSc6IFsyNTUsMCwyNTUsMV0sICdtYXJvb24nOiBbMTI4LDAsMCwxXSxcbiAgICAgICAgJ21lZGl1bWFxdWFtYXJpbmUnOiBbMTAyLDIwNSwxNzAsMV0sICdtZWRpdW1ibHVlJzogWzAsMCwyMDUsMV0sXG4gICAgICAgICdtZWRpdW1vcmNoaWQnOiBbMTg2LDg1LDIxMSwxXSwgJ21lZGl1bXB1cnBsZSc6IFsxNDcsMTEyLDIxOSwxXSxcbiAgICAgICAgJ21lZGl1bXNlYWdyZWVuJzogWzYwLDE3OSwxMTMsMV0sICdtZWRpdW1zbGF0ZWJsdWUnOiBbMTIzLDEwNCwyMzgsMV0sXG4gICAgICAgICdtZWRpdW1zcHJpbmdncmVlbic6IFswLDI1MCwxNTQsMV0sICdtZWRpdW10dXJxdW9pc2UnOiBbNzIsMjA5LDIwNCwxXSxcbiAgICAgICAgJ21lZGl1bXZpb2xldHJlZCc6IFsxOTksMjEsMTMzLDFdLCAnbWlkbmlnaHRibHVlJzogWzI1LDI1LDExMiwxXSxcbiAgICAgICAgJ21pbnRjcmVhbSc6IFsyNDUsMjU1LDI1MCwxXSwgJ21pc3R5cm9zZSc6IFsyNTUsMjI4LDIyNSwxXSxcbiAgICAgICAgJ21vY2Nhc2luJzogWzI1NSwyMjgsMTgxLDFdLCAnbmF2YWpvd2hpdGUnOiBbMjU1LDIyMiwxNzMsMV0sXG4gICAgICAgICduYXZ5JzogWzAsMCwxMjgsMV0sICdvbGRsYWNlJzogWzI1MywyNDUsMjMwLDFdLFxuICAgICAgICAnb2xpdmUnOiBbMTI4LDEyOCwwLDFdLCAnb2xpdmVkcmFiJzogWzEwNywxNDIsMzUsMV0sXG4gICAgICAgICdvcmFuZ2UnOiBbMjU1LDE2NSwwLDFdLCAnb3JhbmdlcmVkJzogWzI1NSw2OSwwLDFdLFxuICAgICAgICAnb3JjaGlkJzogWzIxOCwxMTIsMjE0LDFdLCAncGFsZWdvbGRlbnJvZCc6IFsyMzgsMjMyLDE3MCwxXSxcbiAgICAgICAgJ3BhbGVncmVlbic6IFsxNTIsMjUxLDE1MiwxXSwgJ3BhbGV0dXJxdW9pc2UnOiBbMTc1LDIzOCwyMzgsMV0sXG4gICAgICAgICdwYWxldmlvbGV0cmVkJzogWzIxOSwxMTIsMTQ3LDFdLCAncGFwYXlhd2hpcCc6IFsyNTUsMjM5LDIxMywxXSxcbiAgICAgICAgJ3BlYWNocHVmZic6IFsyNTUsMjE4LDE4NSwxXSwgJ3BlcnUnOiBbMjA1LDEzMyw2MywxXSxcbiAgICAgICAgJ3BpbmsnOiBbMjU1LDE5MiwyMDMsMV0sICdwbHVtJzogWzIyMSwxNjAsMjIxLDFdLFxuICAgICAgICAncG93ZGVyYmx1ZSc6IFsxNzYsMjI0LDIzMCwxXSwgJ3B1cnBsZSc6IFsxMjgsMCwxMjgsMV0sXG4gICAgICAgICdyZWQnOiBbMjU1LDAsMCwxXSwgJ3Jvc3licm93bic6IFsxODgsMTQzLDE0MywxXSxcbiAgICAgICAgJ3JveWFsYmx1ZSc6IFs2NSwxMDUsMjI1LDFdLCAnc2FkZGxlYnJvd24nOiBbMTM5LDY5LDE5LDFdLFxuICAgICAgICAnc2FsbW9uJzogWzI1MCwxMjgsMTE0LDFdLCAnc2FuZHlicm93bic6IFsyNDQsMTY0LDk2LDFdLFxuICAgICAgICAnc2VhZ3JlZW4nOiBbNDYsMTM5LDg3LDFdLCAnc2Vhc2hlbGwnOiBbMjU1LDI0NSwyMzgsMV0sXG4gICAgICAgICdzaWVubmEnOiBbMTYwLDgyLDQ1LDFdLCAnc2lsdmVyJzogWzE5MiwxOTIsMTkyLDFdLFxuICAgICAgICAnc2t5Ymx1ZSc6IFsxMzUsMjA2LDIzNSwxXSwgJ3NsYXRlYmx1ZSc6IFsxMDYsOTAsMjA1LDFdLFxuICAgICAgICAnc2xhdGVncmF5JzogWzExMiwxMjgsMTQ0LDFdLCAnc2xhdGVncmV5JzogWzExMiwxMjgsMTQ0LDFdLFxuICAgICAgICAnc25vdyc6IFsyNTUsMjUwLDI1MCwxXSwgJ3NwcmluZ2dyZWVuJzogWzAsMjU1LDEyNywxXSxcbiAgICAgICAgJ3N0ZWVsYmx1ZSc6IFs3MCwxMzAsMTgwLDFdLCAndGFuJzogWzIxMCwxODAsMTQwLDFdLFxuICAgICAgICAndGVhbCc6IFswLDEyOCwxMjgsMV0sICd0aGlzdGxlJzogWzIxNiwxOTEsMjE2LDFdLFxuICAgICAgICAndG9tYXRvJzogWzI1NSw5OSw3MSwxXSwgJ3R1cnF1b2lzZSc6IFs2NCwyMjQsMjA4LDFdLFxuICAgICAgICAndmlvbGV0JzogWzIzOCwxMzAsMjM4LDFdLCAnd2hlYXQnOiBbMjQ1LDIyMiwxNzksMV0sXG4gICAgICAgICd3aGl0ZSc6IFsyNTUsMjU1LDI1NSwxXSwgJ3doaXRlc21va2UnOiBbMjQ1LDI0NSwyNDUsMV0sXG4gICAgICAgICd5ZWxsb3cnOiBbMjU1LDI1NSwwLDFdLCAneWVsbG93Z3JlZW4nOiBbMTU0LDIwNSw1MCwxXVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBjbGFtcENzc0J5dGUoaSkgeyAgLy8gQ2xhbXAgdG8gaW50ZWdlciAwIC4uIDI1NS5cbiAgICAgICAgaSA9IE1hdGgucm91bmQoaSk7ICAvLyBTZWVtcyB0byBiZSB3aGF0IENocm9tZSBkb2VzICh2cyB0cnVuY2F0aW9uKS5cbiAgICAgICAgcmV0dXJuIGkgPCAwID8gMCA6IGkgPiAyNTUgPyAyNTUgOiBpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsYW1wQ3NzQW5nbGUoaSkgeyAgLy8gQ2xhbXAgdG8gaW50ZWdlciAwIC4uIDM2MC5cbiAgICAgICAgaSA9IE1hdGgucm91bmQoaSk7ICAvLyBTZWVtcyB0byBiZSB3aGF0IENocm9tZSBkb2VzICh2cyB0cnVuY2F0aW9uKS5cbiAgICAgICAgcmV0dXJuIGkgPCAwID8gMCA6IGkgPiAzNjAgPyAzNjAgOiBpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsYW1wQ3NzRmxvYXQoZikgeyAgLy8gQ2xhbXAgdG8gZmxvYXQgMC4wIC4uIDEuMC5cbiAgICAgICAgcmV0dXJuIGYgPCAwID8gMCA6IGYgPiAxID8gMSA6IGY7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VDc3NJbnQoc3RyKSB7ICAvLyBpbnQgb3IgcGVyY2VudGFnZS5cbiAgICAgICAgaWYgKHN0ci5sZW5ndGggJiYgc3RyLmNoYXJBdChzdHIubGVuZ3RoIC0gMSkgPT09ICclJykge1xuICAgICAgICAgICAgcmV0dXJuIGNsYW1wQ3NzQnl0ZShwYXJzZUZsb2F0KHN0cikgLyAxMDAgKiAyNTUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjbGFtcENzc0J5dGUocGFyc2VJbnQoc3RyLCAxMCkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlQ3NzRmxvYXQoc3RyKSB7ICAvLyBmbG9hdCBvciBwZXJjZW50YWdlLlxuICAgICAgICBpZiAoc3RyLmxlbmd0aCAmJiBzdHIuY2hhckF0KHN0ci5sZW5ndGggLSAxKSA9PT0gJyUnKSB7XG4gICAgICAgICAgICByZXR1cm4gY2xhbXBDc3NGbG9hdChwYXJzZUZsb2F0KHN0cikgLyAxMDApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjbGFtcENzc0Zsb2F0KHBhcnNlRmxvYXQoc3RyKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3NzSHVlVG9SZ2IobTEsIG0yLCBoKSB7XG4gICAgICAgIGlmIChoIDwgMCkge1xuICAgICAgICAgICAgaCArPSAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGggPiAxKSB7XG4gICAgICAgICAgICBoIC09IDE7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaCAqIDYgPCAxKSB7XG4gICAgICAgICAgICByZXR1cm4gbTEgKyAobTIgLSBtMSkgKiBoICogNjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaCAqIDIgPCAxKSB7XG4gICAgICAgICAgICByZXR1cm4gbTI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGggKiAzIDwgMikge1xuICAgICAgICAgICAgcmV0dXJuIG0xICsgKG0yIC0gbTEpICogKDIvMyAtIGgpICogNjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbTE7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGVycChhLCBiLCBwKSB7XG4gICAgICAgIHJldHVybiBhICsgKGIgLSBhKSAqIHA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbG9yU3RyXG4gICAgICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL3V0aWwvY29sb3JcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwYXJzZShjb2xvclN0cikge1xuICAgICAgICBpZiAoIWNvbG9yU3RyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gY29sb3JTdHIgbWF5IGJlIG5vdCBzdHJpbmdcbiAgICAgICAgY29sb3JTdHIgPSBjb2xvclN0ciArICcnO1xuICAgICAgICAvLyBSZW1vdmUgYWxsIHdoaXRlc3BhY2UsIG5vdCBjb21wbGlhbnQsIGJ1dCBzaG91bGQganVzdCBiZSBtb3JlIGFjY2VwdGluZy5cbiAgICAgICAgdmFyIHN0ciA9IGNvbG9yU3RyLnJlcGxhY2UoLyAvZywgJycpLnRvTG93ZXJDYXNlKCk7XG5cbiAgICAgICAgLy8gQ29sb3Iga2V5d29yZHMgKGFuZCB0cmFuc3BhcmVudCkgbG9va3VwLlxuICAgICAgICBpZiAoc3RyIGluIGtDU1NDb2xvclRhYmxlKSB7XG4gICAgICAgICAgICByZXR1cm4ga0NTU0NvbG9yVGFibGVbc3RyXS5zbGljZSgpOyAgLy8gZHVwLlxuICAgICAgICB9XG5cbiAgICAgICAgLy8gI2FiYyBhbmQgI2FiYzEyMyBzeW50YXguXG4gICAgICAgIGlmIChzdHIuY2hhckF0KDApID09PSAnIycpIHtcbiAgICAgICAgICAgIGlmIChzdHIubGVuZ3RoID09PSA0KSB7XG4gICAgICAgICAgICAgICAgdmFyIGl2ID0gcGFyc2VJbnQoc3RyLnN1YnN0cigxKSwgMTYpOyAgLy8gVE9ETyhkZWFubSk6IFN0cmljdGVyIHBhcnNpbmcuXG4gICAgICAgICAgICAgICAgaWYgKCEoaXYgPj0gMCAmJiBpdiA8PSAweGZmZikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuOyAgLy8gQ292ZXJzIE5hTi5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgKChpdiAmIDB4ZjAwKSA+PiA0KSB8ICgoaXYgJiAweGYwMCkgPj4gOCksXG4gICAgICAgICAgICAgICAgICAgIChpdiAmIDB4ZjApIHwgKChpdiAmIDB4ZjApID4+IDQpLFxuICAgICAgICAgICAgICAgICAgICAoaXYgJiAweGYpIHwgKChpdiAmIDB4ZikgPDwgNCksXG4gICAgICAgICAgICAgICAgICAgIDFcbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc3RyLmxlbmd0aCA9PT0gNykge1xuICAgICAgICAgICAgICAgIHZhciBpdiA9IHBhcnNlSW50KHN0ci5zdWJzdHIoMSksIDE2KTsgIC8vIFRPRE8oZGVhbm0pOiBTdHJpY3RlciBwYXJzaW5nLlxuICAgICAgICAgICAgICAgIGlmICghKGl2ID49IDAgJiYgaXYgPD0gMHhmZmZmZmYpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjsgIC8vIENvdmVycyBOYU4uXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgIChpdiAmIDB4ZmYwMDAwKSA+PiAxNixcbiAgICAgICAgICAgICAgICAgICAgKGl2ICYgMHhmZjAwKSA+PiA4LFxuICAgICAgICAgICAgICAgICAgICBpdiAmIDB4ZmYsXG4gICAgICAgICAgICAgICAgICAgIDFcbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG9wID0gc3RyLmluZGV4T2YoJygnKSwgZXAgPSBzdHIuaW5kZXhPZignKScpO1xuICAgICAgICBpZiAob3AgIT09IC0xICYmIGVwICsgMSA9PT0gc3RyLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIGZuYW1lID0gc3RyLnN1YnN0cigwLCBvcCk7XG4gICAgICAgICAgICB2YXIgcGFyYW1zID0gc3RyLnN1YnN0cihvcCArIDEsIGVwIC0gKG9wICsgMSkpLnNwbGl0KCcsJyk7XG4gICAgICAgICAgICB2YXIgYWxwaGEgPSAxOyAgLy8gVG8gYWxsb3cgY2FzZSBmYWxsdGhyb3VnaC5cbiAgICAgICAgICAgIHN3aXRjaCAoZm5hbWUpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdyZ2JhJzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmFtcy5sZW5ndGggIT09IDQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBhbHBoYSA9IHBhcnNlQ3NzRmxvYXQocGFyYW1zLnBvcCgpKTsgLy8ganNoaW50IGlnbm9yZTpsaW5lXG4gICAgICAgICAgICAgICAgLy8gRmFsbCB0aHJvdWdoLlxuICAgICAgICAgICAgICAgIGNhc2UgJ3JnYic6XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJhbXMubGVuZ3RoICE9PSAzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlQ3NzSW50KHBhcmFtc1swXSksXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZUNzc0ludChwYXJhbXNbMV0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VDc3NJbnQocGFyYW1zWzJdKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFscGhhXG4gICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgY2FzZSAnaHNsYSc6XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJhbXMubGVuZ3RoICE9PSA0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zWzNdID0gcGFyc2VDc3NGbG9hdChwYXJhbXNbM10pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaHNsYTJyZ2JhKHBhcmFtcyk7XG4gICAgICAgICAgICAgICAgY2FzZSAnaHNsJzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmFtcy5sZW5ndGggIT09IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaHNsYTJyZ2JhKHBhcmFtcyk7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IGhzbGFcbiAgICAgKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn0gcmdiYVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGhzbGEycmdiYShoc2xhKSB7XG4gICAgICAgIHZhciBoID0gKCgocGFyc2VGbG9hdChoc2xhWzBdKSAlIDM2MCkgKyAzNjApICUgMzYwKSAvIDM2MDsgIC8vIDAgLi4gMVxuICAgICAgICAvLyBOT1RFKGRlYW5tKTogQWNjb3JkaW5nIHRvIHRoZSBDU1Mgc3BlYyBzL2wgc2hvdWxkIG9ubHkgYmVcbiAgICAgICAgLy8gcGVyY2VudGFnZXMsIGJ1dCB3ZSBkb24ndCBib3RoZXIgYW5kIGxldCBmbG9hdCBvciBwZXJjZW50YWdlLlxuICAgICAgICB2YXIgcyA9IHBhcnNlQ3NzRmxvYXQoaHNsYVsxXSk7XG4gICAgICAgIHZhciBsID0gcGFyc2VDc3NGbG9hdChoc2xhWzJdKTtcbiAgICAgICAgdmFyIG0yID0gbCA8PSAwLjUgPyBsICogKHMgKyAxKSA6IGwgKyBzIC0gbCAqIHM7XG4gICAgICAgIHZhciBtMSA9IGwgKiAyIC0gbTI7XG5cbiAgICAgICAgdmFyIHJnYmEgPSBbXG4gICAgICAgICAgICBjbGFtcENzc0J5dGUoY3NzSHVlVG9SZ2IobTEsIG0yLCBoICsgMSAvIDMpICogMjU1KSxcbiAgICAgICAgICAgIGNsYW1wQ3NzQnl0ZShjc3NIdWVUb1JnYihtMSwgbTIsIGgpICogMjU1KSxcbiAgICAgICAgICAgIGNsYW1wQ3NzQnl0ZShjc3NIdWVUb1JnYihtMSwgbTIsIGggLSAxIC8gMykgKiAyNTUpXG4gICAgICAgIF07XG5cbiAgICAgICAgaWYgKGhzbGEubGVuZ3RoID09PSA0KSB7XG4gICAgICAgICAgICByZ2JhWzNdID0gaHNsYVszXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZ2JhO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IHJnYmFcbiAgICAgKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn0gaHNsYVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJnYmEyaHNsYShyZ2JhKSB7XG4gICAgICAgIGlmICghcmdiYSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUkdCIGZyb20gMCB0byAyNTVcbiAgICAgICAgdmFyIFIgPSByZ2JhWzBdIC8gMjU1O1xuICAgICAgICB2YXIgRyA9IHJnYmFbMV0gLyAyNTU7XG4gICAgICAgIHZhciBCID0gcmdiYVsyXSAvIDI1NTtcblxuICAgICAgICB2YXIgdk1pbiA9IE1hdGgubWluKFIsIEcsIEIpOyAvLyBNaW4uIHZhbHVlIG9mIFJHQlxuICAgICAgICB2YXIgdk1heCA9IE1hdGgubWF4KFIsIEcsIEIpOyAvLyBNYXguIHZhbHVlIG9mIFJHQlxuICAgICAgICB2YXIgZGVsdGEgPSB2TWF4IC0gdk1pbjsgLy8gRGVsdGEgUkdCIHZhbHVlXG5cbiAgICAgICAgdmFyIEwgPSAodk1heCArIHZNaW4pIC8gMjtcbiAgICAgICAgdmFyIEg7XG4gICAgICAgIHZhciBTO1xuICAgICAgICAvLyBIU0wgcmVzdWx0cyBmcm9tIDAgdG8gMVxuICAgICAgICBpZiAoZGVsdGEgPT09IDApIHtcbiAgICAgICAgICAgIEggPSAwO1xuICAgICAgICAgICAgUyA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoTCA8IDAuNSkge1xuICAgICAgICAgICAgICAgIFMgPSBkZWx0YSAvICh2TWF4ICsgdk1pbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBTID0gZGVsdGEgLyAoMiAtIHZNYXggLSB2TWluKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGRlbHRhUiA9ICgoKHZNYXggLSBSKSAvIDYpICsgKGRlbHRhIC8gMikpIC8gZGVsdGE7XG4gICAgICAgICAgICB2YXIgZGVsdGFHID0gKCgodk1heCAtIEcpIC8gNikgKyAoZGVsdGEgLyAyKSkgLyBkZWx0YTtcbiAgICAgICAgICAgIHZhciBkZWx0YUIgPSAoKCh2TWF4IC0gQikgLyA2KSArIChkZWx0YSAvIDIpKSAvIGRlbHRhO1xuXG4gICAgICAgICAgICBpZiAoUiA9PT0gdk1heCkge1xuICAgICAgICAgICAgICAgIEggPSBkZWx0YUIgLSBkZWx0YUc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChHID09PSB2TWF4KSB7XG4gICAgICAgICAgICAgICAgSCA9ICgxIC8gMykgKyBkZWx0YVIgLSBkZWx0YUI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChCID09PSB2TWF4KSB7XG4gICAgICAgICAgICAgICAgSCA9ICgyIC8gMykgKyBkZWx0YUcgLSBkZWx0YVI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChIIDwgMCkge1xuICAgICAgICAgICAgICAgIEggKz0gMTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKEggPiAxKSB7XG4gICAgICAgICAgICAgICAgSCAtPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGhzbGEgPSBbSCAqIDM2MCwgUywgTF07XG5cbiAgICAgICAgaWYgKHJnYmFbM10gIT0gbnVsbCkge1xuICAgICAgICAgICAgaHNsYS5wdXNoKHJnYmFbM10pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGhzbGE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbG9yXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxldmVsXG4gICAgICogQHJldHVybiB7c3RyaW5nfVxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci91dGlsL2NvbG9yXG4gICAgICovXG4gICAgZnVuY3Rpb24gbGlmdChjb2xvciwgbGV2ZWwpIHtcbiAgICAgICAgdmFyIGNvbG9yQXJyID0gcGFyc2UoY29sb3IpO1xuICAgICAgICBpZiAoY29sb3JBcnIpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMzsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxldmVsIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBjb2xvckFycltpXSA9IGNvbG9yQXJyW2ldICogKDEgLSBsZXZlbCkgfCAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29sb3JBcnJbaV0gPSAoKDI1NSAtIGNvbG9yQXJyW2ldKSAqIGxldmVsICsgY29sb3JBcnJbaV0pIHwgMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc3RyaW5naWZ5KGNvbG9yQXJyLCBjb2xvckFyci5sZW5ndGggPT09IDQgPyAncmdiYScgOiAncmdiJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29sb3JcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL3V0aWwvY29sb3JcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0b0hleChjb2xvciwgbGV2ZWwpIHtcbiAgICAgICAgdmFyIGNvbG9yQXJyID0gcGFyc2UoY29sb3IpO1xuICAgICAgICBpZiAoY29sb3JBcnIpIHtcbiAgICAgICAgICAgIHJldHVybiAoKDEgPDwgMjQpICsgKGNvbG9yQXJyWzBdIDw8IDE2KSArIChjb2xvckFyclsxXSA8PCA4KSArICgrY29sb3JBcnJbMl0pKS50b1N0cmluZygxNikuc2xpY2UoMSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNYXAgdmFsdWUgdG8gY29sb3IuIEZhc3RlciB0aGFuIG1hcFRvQ29sb3IgbWV0aG9kcyBiZWNhdXNlIGNvbG9yIGlzIHJlcHJlc2VudGVkIGJ5IHJnYmEgYXJyYXlcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbm9ybWFsaXplZFZhbHVlIEEgZmxvYXQgYmV0d2VlbiAwIGFuZCAxLlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPEFycmF5LjxudW1iZXI+Pn0gY29sb3JzIExpc3Qgb2YgcmdiYSBjb2xvciBhcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IFtvdXRdIE1hcHBlZCBnYmEgY29sb3IgYXJyYXlcbiAgICAgKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmYXN0TWFwVG9Db2xvcihub3JtYWxpemVkVmFsdWUsIGNvbG9ycywgb3V0KSB7XG4gICAgICAgIGlmICghKGNvbG9ycyAmJiBjb2xvcnMubGVuZ3RoKVxuICAgICAgICAgICAgfHwgIShub3JtYWxpemVkVmFsdWUgPj0gMCAmJiBub3JtYWxpemVkVmFsdWUgPD0gMSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgb3V0ID0gb3V0IHx8IFswLCAwLCAwLCAwXTtcbiAgICAgICAgdmFyIHZhbHVlID0gbm9ybWFsaXplZFZhbHVlICogKGNvbG9ycy5sZW5ndGggLSAxKTtcbiAgICAgICAgdmFyIGxlZnRJbmRleCA9IE1hdGguZmxvb3IodmFsdWUpO1xuICAgICAgICB2YXIgcmlnaHRJbmRleCA9IE1hdGguY2VpbCh2YWx1ZSk7XG4gICAgICAgIHZhciBsZWZ0Q29sb3IgPSBjb2xvcnNbbGVmdEluZGV4XTtcbiAgICAgICAgdmFyIHJpZ2h0Q29sb3IgPSBjb2xvcnNbcmlnaHRJbmRleF07XG4gICAgICAgIHZhciBkdiA9IHZhbHVlIC0gbGVmdEluZGV4O1xuICAgICAgICBvdXRbMF0gPSBjbGFtcENzc0J5dGUobGVycChsZWZ0Q29sb3JbMF0sIHJpZ2h0Q29sb3JbMF0sIGR2KSk7XG4gICAgICAgIG91dFsxXSA9IGNsYW1wQ3NzQnl0ZShsZXJwKGxlZnRDb2xvclsxXSwgcmlnaHRDb2xvclsxXSwgZHYpKTtcbiAgICAgICAgb3V0WzJdID0gY2xhbXBDc3NCeXRlKGxlcnAobGVmdENvbG9yWzJdLCByaWdodENvbG9yWzJdLCBkdikpO1xuICAgICAgICBvdXRbM10gPSBjbGFtcENzc0J5dGUobGVycChsZWZ0Q29sb3JbM10sIHJpZ2h0Q29sb3JbM10sIGR2KSk7XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBub3JtYWxpemVkVmFsdWUgQSBmbG9hdCBiZXR3ZWVuIDAgYW5kIDEuXG4gICAgICogQHBhcmFtIHtBcnJheS48c3RyaW5nPn0gY29sb3JzIENvbG9yIGxpc3QuXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gZnVsbE91dHB1dCBEZWZhdWx0IGZhbHNlLlxuICAgICAqIEByZXR1cm4geyhzdHJpbmd8T2JqZWN0KX0gUmVzdWx0IGNvbG9yLiBJZiBmdWxsT3V0cHV0LFxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtjb2xvcjogLi4uLCBsZWZ0SW5kZXg6IC4uLiwgcmlnaHRJbmRleDogLi4uLCB2YWx1ZTogLi4ufSxcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvdXRpbC9jb2xvclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1hcFRvQ29sb3Iobm9ybWFsaXplZFZhbHVlLCBjb2xvcnMsIGZ1bGxPdXRwdXQpIHtcbiAgICAgICAgaWYgKCEoY29sb3JzICYmIGNvbG9ycy5sZW5ndGgpXG4gICAgICAgICAgICB8fCAhKG5vcm1hbGl6ZWRWYWx1ZSA+PSAwICYmIG5vcm1hbGl6ZWRWYWx1ZSA8PSAxKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB2YWx1ZSA9IG5vcm1hbGl6ZWRWYWx1ZSAqIChjb2xvcnMubGVuZ3RoIC0gMSk7XG4gICAgICAgIHZhciBsZWZ0SW5kZXggPSBNYXRoLmZsb29yKHZhbHVlKTtcbiAgICAgICAgdmFyIHJpZ2h0SW5kZXggPSBNYXRoLmNlaWwodmFsdWUpO1xuICAgICAgICB2YXIgbGVmdENvbG9yID0gcGFyc2UoY29sb3JzW2xlZnRJbmRleF0pO1xuICAgICAgICB2YXIgcmlnaHRDb2xvciA9IHBhcnNlKGNvbG9yc1tyaWdodEluZGV4XSk7XG4gICAgICAgIHZhciBkdiA9IHZhbHVlIC0gbGVmdEluZGV4O1xuXG4gICAgICAgIHZhciBjb2xvciA9IHN0cmluZ2lmeShcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBjbGFtcENzc0J5dGUobGVycChsZWZ0Q29sb3JbMF0sIHJpZ2h0Q29sb3JbMF0sIGR2KSksXG4gICAgICAgICAgICAgICAgY2xhbXBDc3NCeXRlKGxlcnAobGVmdENvbG9yWzFdLCByaWdodENvbG9yWzFdLCBkdikpLFxuICAgICAgICAgICAgICAgIGNsYW1wQ3NzQnl0ZShsZXJwKGxlZnRDb2xvclsyXSwgcmlnaHRDb2xvclsyXSwgZHYpKSxcbiAgICAgICAgICAgICAgICBjbGFtcENzc0Zsb2F0KGxlcnAobGVmdENvbG9yWzNdLCByaWdodENvbG9yWzNdLCBkdikpXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgJ3JnYmEnXG4gICAgICAgICk7XG5cbiAgICAgICAgcmV0dXJuIGZ1bGxPdXRwdXRcbiAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgIGNvbG9yOiBjb2xvcixcbiAgICAgICAgICAgICAgICBsZWZ0SW5kZXg6IGxlZnRJbmRleCxcbiAgICAgICAgICAgICAgICByaWdodEluZGV4OiByaWdodEluZGV4LFxuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgOiBjb2xvcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29sb3JcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IGggMCB+IDM2MCwgaWdub3JlIHdoZW4gbnVsbC5cbiAgICAgKiBAcGFyYW0ge251bWJlcj19IHMgMCB+IDEsIGlnbm9yZSB3aGVuIG51bGwuXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBsIDAgfiAxLCBpZ25vcmUgd2hlbiBudWxsLlxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gQ29sb3Igc3RyaW5nIGluIHJnYmEgZm9ybWF0LlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci91dGlsL2NvbG9yXG4gICAgICovXG4gICAgZnVuY3Rpb24gbW9kaWZ5SFNMKGNvbG9yLCBoLCBzLCBsKSB7XG4gICAgICAgIGNvbG9yID0gcGFyc2UoY29sb3IpO1xuXG4gICAgICAgIGlmIChjb2xvcikge1xuICAgICAgICAgICAgY29sb3IgPSByZ2JhMmhzbGEoY29sb3IpO1xuICAgICAgICAgICAgaCAhPSBudWxsICYmIChjb2xvclswXSA9IGNsYW1wQ3NzQW5nbGUoaCkpO1xuICAgICAgICAgICAgcyAhPSBudWxsICYmIChjb2xvclsxXSA9IHBhcnNlQ3NzRmxvYXQocykpO1xuICAgICAgICAgICAgbCAhPSBudWxsICYmIChjb2xvclsyXSA9IHBhcnNlQ3NzRmxvYXQobCkpO1xuXG4gICAgICAgICAgICByZXR1cm4gc3RyaW5naWZ5KGhzbGEycmdiYShjb2xvciksICdyZ2JhJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29sb3JcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IGFscGhhIDAgfiAxXG4gICAgICogQHJldHVybiB7c3RyaW5nfSBDb2xvciBzdHJpbmcgaW4gcmdiYSBmb3JtYXQuXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL3V0aWwvY29sb3JcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtb2RpZnlBbHBoYShjb2xvciwgYWxwaGEpIHtcbiAgICAgICAgY29sb3IgPSBwYXJzZShjb2xvcik7XG5cbiAgICAgICAgaWYgKGNvbG9yICYmIGFscGhhICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNvbG9yWzNdID0gY2xhbXBDc3NGbG9hdChhbHBoYSk7XG4gICAgICAgICAgICByZXR1cm4gc3RyaW5naWZ5KGNvbG9yLCAncmdiYScpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtBcnJheS48c3RyaW5nPn0gY29sb3JzIENvbG9yIGxpc3QuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgJ3JnYmEnLCAnaHN2YScsIC4uLlxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gUmVzdWx0IGNvbG9yLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN0cmluZ2lmeShhcnJDb2xvciwgdHlwZSkge1xuICAgICAgICB2YXIgY29sb3JTdHIgPSBhcnJDb2xvclswXSArICcsJyArIGFyckNvbG9yWzFdICsgJywnICsgYXJyQ29sb3JbMl07XG4gICAgICAgIGlmICh0eXBlID09PSAncmdiYScgfHwgdHlwZSA9PT0gJ2hzdmEnIHx8IHR5cGUgPT09ICdoc2xhJykge1xuICAgICAgICAgICAgY29sb3JTdHIgKz0gJywnICsgYXJyQ29sb3JbM107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHR5cGUgKyAnKCcgKyBjb2xvclN0ciArICcpJztcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAgICAgcGFyc2U6IHBhcnNlLFxuICAgICAgICBsaWZ0OiBsaWZ0LFxuICAgICAgICB0b0hleDogdG9IZXgsXG4gICAgICAgIGZhc3RNYXBUb0NvbG9yOiBmYXN0TWFwVG9Db2xvcixcbiAgICAgICAgbWFwVG9Db2xvcjogbWFwVG9Db2xvcixcbiAgICAgICAgbW9kaWZ5SFNMOiBtb2RpZnlIU0wsXG4gICAgICAgIG1vZGlmeUFscGhhOiBtb2RpZnlBbHBoYSxcbiAgICAgICAgc3RyaW5naWZ5OiBzdHJpbmdpZnlcbiAgICB9O1xuXG5cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3pyZW5kZXIvbGliL3Rvb2wvY29sb3IuanNcbiAqKiBtb2R1bGUgaWQgPSAxOVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXG4gICAgICAgIHZhciBjb25maWcgPSByZXF1aXJlKCcuLi9jb25maWcnKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQGV4cG9ydHMgenJlbmRlci90b29sL2xvZ1xuICAgICAgICAgKiBAYXV0aG9yIEtlbmVyIChAS2VuZXIt5p6X5bOwLCBrZW5lci5saW5mZW5nQGdtYWlsLmNvbSlcbiAgICAgICAgICovXG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoY29uZmlnLmRlYnVnTW9kZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNvbmZpZy5kZWJ1Z01vZGUgPT0gMSkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGsgaW4gYXJndW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihhcmd1bWVudHNba10pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNvbmZpZy5kZWJ1Z01vZGUgPiAxKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgayBpbiBhcmd1bWVudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYXJndW1lbnRzW2tdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLyogZm9yIGRlYnVnXG4gICAgICAgIHJldHVybiBmdW5jdGlvbihtZXMpIHtcbiAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd3cm9uZy1tZXNzYWdlJykuaW5uZXJIVE1MID1cbiAgICAgICAgICAgICAgICBtZXMgKyAnICcgKyAobmV3IERhdGUoKSAtIDApXG4gICAgICAgICAgICAgICAgKyAnPGJyLz4nIFxuICAgICAgICAgICAgICAgICsgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3dyb25nLW1lc3NhZ2UnKS5pbm5lckhUTUw7XG4gICAgICAgIH07XG4gICAgICAgICovXG4gICAgXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi96cmVuZGVyL2xpYi9jb3JlL2xvZy5qc1xuICoqIG1vZHVsZSBpZCA9IDIwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcbiAgICB2YXIgZHByID0gMTtcbiAgICAvLyBJZiBpbiBicm93c2VyIGVudmlyb25tZW50XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGRwciA9IE1hdGgubWF4KHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDEsIDEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBjb25maWfpu5jorqTphY3nva7poblcbiAgICAgKiBAZXhwb3J0cyB6cmVuZGVyL2NvbmZpZ1xuICAgICAqIEBhdXRob3IgS2VuZXIgKEBLZW5lci3mnpfls7AsIGtlbmVyLmxpbmZlbmdAZ21haWwuY29tKVxuICAgICAqL1xuICAgIHZhciBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBkZWJ1Z+aXpeW/l+mAiemhue+8mmNhdGNoQnJ1c2hFeGNlcHRpb27kuLp0cnVl5LiL5pyJ5pWIXG4gICAgICAgICAqIDAgOiDkuI3nlJ/miJBkZWJ1Z+aVsOaNru+8jOWPkeW4g+eUqFxuICAgICAgICAgKiAxIDog5byC5bi45oqb5Ye677yM6LCD6K+V55SoXG4gICAgICAgICAqIDIgOiDmjqfliLblj7DovpPlh7rvvIzosIPor5XnlKhcbiAgICAgICAgICovXG4gICAgICAgIGRlYnVnTW9kZTogMCxcblxuICAgICAgICAvLyByZXRpbmEg5bGP5bmV5LyY5YyWXG4gICAgICAgIGRldmljZVBpeGVsUmF0aW86IGRwclxuICAgIH07XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBjb25maWc7XG5cblxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34venJlbmRlci9saWIvY29uZmlnLmpzXG4gKiogbW9kdWxlIGlkID0gMjFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogTWl4aW4gZm9yIGRyYXdpbmcgdGV4dCBpbiBhIGVsZW1lbnQgYm91bmRpbmcgcmVjdFxuICogQG1vZHVsZSB6cmVuZGVyL21peGluL1JlY3RUZXh0XG4gKi9cblxuXG5cbiAgICB2YXIgdGV4dENvbnRhaW4gPSByZXF1aXJlKCcuLi8uLi9jb250YWluL3RleHQnKTtcbiAgICB2YXIgQm91bmRpbmdSZWN0ID0gcmVxdWlyZSgnLi4vLi4vY29yZS9Cb3VuZGluZ1JlY3QnKTtcblxuICAgIHZhciB0bXBSZWN0ID0gbmV3IEJvdW5kaW5nUmVjdCgpO1xuXG4gICAgdmFyIFJlY3RUZXh0ID0gZnVuY3Rpb24gKCkge307XG5cbiAgICBmdW5jdGlvbiBwYXJzZVBlcmNlbnQodmFsdWUsIG1heFZhbHVlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUubGFzdEluZGV4T2YoJyUnKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQodmFsdWUpIC8gMTAwICogbWF4VmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VGbG9hdCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIFJlY3RUZXh0LnByb3RvdHlwZSA9IHtcblxuICAgICAgICBjb25zdHJ1Y3RvcjogUmVjdFRleHQsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERyYXcgdGV4dCBpbiBhIHJlY3Qgd2l0aCBzcGVjaWZpZWQgcG9zaXRpb24uXG4gICAgICAgICAqIEBwYXJhbSAge0NhbnZhc1JlbmRlcmluZ0NvbnRleHR9IGN0eFxuICAgICAgICAgKiBAcGFyYW0gIHtPYmplY3R9IHJlY3QgRGlzcGxheWFibGUgcmVjdFxuICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IHRleHRSZWN0IEFsdGVybmF0aXZlIHByZWNhbGN1bGF0ZWQgdGV4dCBib3VuZGluZyByZWN0XG4gICAgICAgICAqL1xuICAgICAgICBkcmF3UmVjdFRleHQ6IGZ1bmN0aW9uIChjdHgsIHJlY3QsIHRleHRSZWN0KSB7XG4gICAgICAgICAgICB2YXIgc3R5bGUgPSB0aGlzLnN0eWxlO1xuICAgICAgICAgICAgdmFyIHRleHQgPSBzdHlsZS50ZXh0O1xuICAgICAgICAgICAgLy8gQ29udmVydCB0byBzdHJpbmdcbiAgICAgICAgICAgIHRleHQgIT0gbnVsbCAmJiAodGV4dCArPSAnJyk7XG4gICAgICAgICAgICBpZiAoIXRleHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEZJWE1FXG4gICAgICAgICAgICBjdHguc2F2ZSgpO1xuXG4gICAgICAgICAgICB2YXIgeDtcbiAgICAgICAgICAgIHZhciB5O1xuICAgICAgICAgICAgdmFyIHRleHRQb3NpdGlvbiA9IHN0eWxlLnRleHRQb3NpdGlvbjtcbiAgICAgICAgICAgIHZhciBkaXN0YW5jZSA9IHN0eWxlLnRleHREaXN0YW5jZTtcbiAgICAgICAgICAgIHZhciBhbGlnbiA9IHN0eWxlLnRleHRBbGlnbjtcbiAgICAgICAgICAgIHZhciBmb250ID0gc3R5bGUudGV4dEZvbnQgfHwgc3R5bGUuZm9udDtcbiAgICAgICAgICAgIHZhciBiYXNlbGluZSA9IHN0eWxlLnRleHRCYXNlbGluZTtcbiAgICAgICAgICAgIHZhciB2ZXJ0aWNhbEFsaWduID0gc3R5bGUudGV4dFZlcnRpY2FsQWxpZ247XG5cbiAgICAgICAgICAgIHRleHRSZWN0ID0gdGV4dFJlY3QgfHwgdGV4dENvbnRhaW4uZ2V0Qm91bmRpbmdSZWN0KHRleHQsIGZvbnQsIGFsaWduLCBiYXNlbGluZSk7XG5cbiAgICAgICAgICAgIC8vIFRyYW5zZm9ybSByZWN0IHRvIHZpZXcgc3BhY2VcbiAgICAgICAgICAgIHZhciB0cmFuc2Zvcm0gPSB0aGlzLnRyYW5zZm9ybTtcbiAgICAgICAgICAgIGlmICghc3R5bGUudGV4dFRyYW5zZm9ybSkge1xuICAgICAgICAgICAgICAgIGlmICh0cmFuc2Zvcm0pIHtcbiAgICAgICAgICAgICAgICAgICAgdG1wUmVjdC5jb3B5KHJlY3QpO1xuICAgICAgICAgICAgICAgICAgICB0bXBSZWN0LmFwcGx5VHJhbnNmb3JtKHRyYW5zZm9ybSk7XG4gICAgICAgICAgICAgICAgICAgIHJlY3QgPSB0bXBSZWN0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0VHJhbnNmb3JtKGN0eCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFRleHQgcG9zaXRpb24gcmVwcmVzZW50ZWQgYnkgY29vcmRcbiAgICAgICAgICAgIGlmICh0ZXh0UG9zaXRpb24gaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgICAgIC8vIFBlcmNlbnRcbiAgICAgICAgICAgICAgICB4ID0gcmVjdC54ICsgcGFyc2VQZXJjZW50KHRleHRQb3NpdGlvblswXSwgcmVjdC53aWR0aCk7XG4gICAgICAgICAgICAgICAgeSA9IHJlY3QueSArIHBhcnNlUGVyY2VudCh0ZXh0UG9zaXRpb25bMV0sIHJlY3QuaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICBhbGlnbiA9IGFsaWduIHx8ICdsZWZ0JztcbiAgICAgICAgICAgICAgICBiYXNlbGluZSA9IGJhc2VsaW5lIHx8ICd0b3AnO1xuXG4gICAgICAgICAgICAgICAgaWYgKHZlcnRpY2FsQWxpZ24pIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoICh2ZXJ0aWNhbEFsaWduKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdtaWRkbGUnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkgLT0gdGV4dFJlY3QuaGVpZ2h0IC8gMiAtIHRleHRSZWN0LmxpbmVIZWlnaHQgLyAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnYm90dG9tJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5IC09IHRleHRSZWN0LmhlaWdodCAtIHRleHRSZWN0LmxpbmVIZWlnaHQgLyAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5ICs9IHRleHRSZWN0LmxpbmVIZWlnaHQgLyAyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIEZvcmNlIGJzZWxpbmUgdG8gYmUgbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIGJhc2VsaW5lID0gJ21pZGRsZSc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlcyA9IHRleHRDb250YWluLmFkanVzdFRleHRQb3NpdGlvbk9uUmVjdChcbiAgICAgICAgICAgICAgICAgICAgdGV4dFBvc2l0aW9uLCByZWN0LCB0ZXh0UmVjdCwgZGlzdGFuY2VcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHggPSByZXMueDtcbiAgICAgICAgICAgICAgICB5ID0gcmVzLnk7XG4gICAgICAgICAgICAgICAgLy8gRGVmYXVsdCBhbGlnbiBhbmQgYmFzZWxpbmUgd2hlbiBoYXMgdGV4dFBvc2l0aW9uXG4gICAgICAgICAgICAgICAgYWxpZ24gPSBhbGlnbiB8fCByZXMudGV4dEFsaWduO1xuICAgICAgICAgICAgICAgIGJhc2VsaW5lID0gYmFzZWxpbmUgfHwgcmVzLnRleHRCYXNlbGluZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gVXNlIGNhbnZhcyBkZWZhdWx0IGxlZnQgdGV4dEFsaWduLiBHaXZpbmcgaW52YWxpZCB2YWx1ZSB3aWxsIGNhdXNlIHN0YXRlIG5vdCBjaGFuZ2VcbiAgICAgICAgICAgIGN0eC50ZXh0QWxpZ24gPSBhbGlnbiB8fCAnbGVmdCc7XG4gICAgICAgICAgICAvLyBVc2UgY2FudmFzIGRlZmF1bHQgYWxwaGFiZXRpYyBiYXNlbGluZVxuICAgICAgICAgICAgY3R4LnRleHRCYXNlbGluZSA9IGJhc2VsaW5lIHx8ICdhbHBoYWJldGljJztcblxuICAgICAgICAgICAgdmFyIHRleHRGaWxsID0gc3R5bGUudGV4dEZpbGw7XG4gICAgICAgICAgICB2YXIgdGV4dFN0cm9rZSA9IHN0eWxlLnRleHRTdHJva2U7XG4gICAgICAgICAgICB0ZXh0RmlsbCAmJiAoY3R4LmZpbGxTdHlsZSA9IHRleHRGaWxsKTtcbiAgICAgICAgICAgIHRleHRTdHJva2UgJiYgKGN0eC5zdHJva2VTdHlsZSA9IHRleHRTdHJva2UpO1xuXG4gICAgICAgICAgICAvLyBUT0RPIEludmFsaWQgZm9udFxuICAgICAgICAgICAgY3R4LmZvbnQgPSBmb250IHx8ICcxMnB4IHNhbnMtc2VyaWYnO1xuXG4gICAgICAgICAgICAvLyBUZXh0IHNoYWRvd1xuICAgICAgICAgICAgLy8gQWx3YXlzIHNldCBzaGFkb3dCbHVyIGFuZCBzaGFkb3dPZmZzZXQgdG8gYXZvaWQgbGVhayBmcm9tIGRpc3BsYXlhYmxlXG4gICAgICAgICAgICBjdHguc2hhZG93Qmx1ciA9IHN0eWxlLnRleHRTaGFkb3dCbHVyO1xuICAgICAgICAgICAgY3R4LnNoYWRvd0NvbG9yID0gc3R5bGUudGV4dFNoYWRvd0NvbG9yIHx8ICd0cmFuc3BhcmVudCc7XG4gICAgICAgICAgICBjdHguc2hhZG93T2Zmc2V0WCA9IHN0eWxlLnRleHRTaGFkb3dPZmZzZXRYO1xuICAgICAgICAgICAgY3R4LnNoYWRvd09mZnNldFkgPSBzdHlsZS50ZXh0U2hhZG93T2Zmc2V0WTtcblxuICAgICAgICAgICAgdmFyIHRleHRMaW5lcyA9IHRleHQuc3BsaXQoJ1xcbicpO1xuXG4gICAgICAgICAgICBpZiAoc3R5bGUudGV4dFJvdGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtICYmIGN0eC50cmFuc2xhdGUodHJhbnNmb3JtWzRdLCB0cmFuc2Zvcm1bNV0pO1xuICAgICAgICAgICAgICAgIGN0eC5yb3RhdGUoc3R5bGUudGV4dFJvdGF0aW9uKTtcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm0gJiYgY3R4LnRyYW5zbGF0ZSgtdHJhbnNmb3JtWzRdLCAtdHJhbnNmb3JtWzVdKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0ZXh0TGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0ZXh0RmlsbCAmJiBjdHguZmlsbFRleHQodGV4dExpbmVzW2ldLCB4LCB5KTtcbiAgICAgICAgICAgICAgICB0ZXh0U3Ryb2tlICYmIGN0eC5zdHJva2VUZXh0KHRleHRMaW5lc1tpXSwgeCwgeSk7XG4gICAgICAgICAgICAgICAgeSArPSB0ZXh0UmVjdC5saW5lSGVpZ2h0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gUmVjdFRleHQ7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi96cmVuZGVyL2xpYi9ncmFwaGljL21peGluL1JlY3RUZXh0LmpzXG4gKiogbW9kdWxlIGlkID0gMjJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlxuXG4gICAgdmFyIHRleHRXaWR0aENhY2hlID0ge307XG4gICAgdmFyIHRleHRXaWR0aENhY2hlQ291bnRlciA9IDA7XG4gICAgdmFyIFRFWFRfQ0FDSEVfTUFYID0gNTAwMDtcblxuICAgIHZhciB1dGlsID0gcmVxdWlyZSgnLi4vY29yZS91dGlsJyk7XG4gICAgdmFyIEJvdW5kaW5nUmVjdCA9IHJlcXVpcmUoJy4uL2NvcmUvQm91bmRpbmdSZWN0Jyk7XG4gICAgdmFyIHJldHJpZXZlID0gdXRpbC5yZXRyaWV2ZTtcblxuICAgIGZ1bmN0aW9uIGdldFRleHRXaWR0aCh0ZXh0LCB0ZXh0Rm9udCkge1xuICAgICAgICB2YXIga2V5ID0gdGV4dCArICc6JyArIHRleHRGb250O1xuICAgICAgICBpZiAodGV4dFdpZHRoQ2FjaGVba2V5XSkge1xuICAgICAgICAgICAgcmV0dXJuIHRleHRXaWR0aENhY2hlW2tleV07XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdGV4dExpbmVzID0gKHRleHQgKyAnJykuc3BsaXQoJ1xcbicpO1xuICAgICAgICB2YXIgd2lkdGggPSAwO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gdGV4dExpbmVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgLy8gbWVhc3VyZVRleHQg5Y+v5Lul6KKr6KaG55uW5Lul5YW85a655LiN5pSv5oyBIENhbnZhcyDnmoTnjq/looNcbiAgICAgICAgICAgIHdpZHRoID0gTWF0aC5tYXgodGV4dENvbnRhaW4ubWVhc3VyZVRleHQodGV4dExpbmVzW2ldLCB0ZXh0Rm9udCkud2lkdGgsIHdpZHRoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0ZXh0V2lkdGhDYWNoZUNvdW50ZXIgPiBURVhUX0NBQ0hFX01BWCkge1xuICAgICAgICAgICAgdGV4dFdpZHRoQ2FjaGVDb3VudGVyID0gMDtcbiAgICAgICAgICAgIHRleHRXaWR0aENhY2hlID0ge307XG4gICAgICAgIH1cbiAgICAgICAgdGV4dFdpZHRoQ2FjaGVDb3VudGVyKys7XG4gICAgICAgIHRleHRXaWR0aENhY2hlW2tleV0gPSB3aWR0aDtcblxuICAgICAgICByZXR1cm4gd2lkdGg7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0VGV4dFJlY3QodGV4dCwgdGV4dEZvbnQsIHRleHRBbGlnbiwgdGV4dEJhc2VsaW5lKSB7XG4gICAgICAgIHZhciB0ZXh0TGluZUxlbiA9ICgodGV4dCB8fCAnJykgKyAnJykuc3BsaXQoJ1xcbicpLmxlbmd0aDtcblxuICAgICAgICB2YXIgd2lkdGggPSBnZXRUZXh0V2lkdGgodGV4dCwgdGV4dEZvbnQpO1xuICAgICAgICAvLyBGSVhNRSDpq5jluqborqHnrpfmr5TovoPnspfmmrRcbiAgICAgICAgdmFyIGxpbmVIZWlnaHQgPSBnZXRUZXh0V2lkdGgoJ+WbvScsIHRleHRGb250KTtcbiAgICAgICAgdmFyIGhlaWdodCA9IHRleHRMaW5lTGVuICogbGluZUhlaWdodDtcblxuICAgICAgICB2YXIgcmVjdCA9IG5ldyBCb3VuZGluZ1JlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIC8vIFRleHQgaGFzIGEgc3BlY2lhbCBsaW5lIGhlaWdodCBwcm9wZXJ0eVxuICAgICAgICByZWN0LmxpbmVIZWlnaHQgPSBsaW5lSGVpZ2h0O1xuXG4gICAgICAgIHN3aXRjaCAodGV4dEJhc2VsaW5lKSB7XG4gICAgICAgICAgICBjYXNlICdib3R0b20nOlxuICAgICAgICAgICAgY2FzZSAnYWxwaGFiZXRpYyc6XG4gICAgICAgICAgICAgICAgcmVjdC55IC09IGxpbmVIZWlnaHQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdtaWRkbGUnOlxuICAgICAgICAgICAgICAgIHJlY3QueSAtPSBsaW5lSGVpZ2h0IC8gMjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIC8vIGNhc2UgJ2hhbmdpbmcnOlxuICAgICAgICAgICAgLy8gY2FzZSAndG9wJzpcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEZJWE1FIFJpZ2h0IHRvIGxlZnQgbGFuZ3VhZ2VcbiAgICAgICAgc3dpdGNoICh0ZXh0QWxpZ24pIHtcbiAgICAgICAgICAgIGNhc2UgJ2VuZCc6XG4gICAgICAgICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgICAgICAgICAgcmVjdC54IC09IHJlY3Qud2lkdGg7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdjZW50ZXInOlxuICAgICAgICAgICAgICAgIHJlY3QueCAtPSByZWN0LndpZHRoIC8gMjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIC8vIGNhc2UgJ3N0YXJ0JzpcbiAgICAgICAgICAgIC8vIGNhc2UgJ2xlZnQnOlxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlY3Q7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRqdXN0VGV4dFBvc2l0aW9uT25SZWN0KHRleHRQb3NpdGlvbiwgcmVjdCwgdGV4dFJlY3QsIGRpc3RhbmNlKSB7XG5cbiAgICAgICAgdmFyIHggPSByZWN0Lng7XG4gICAgICAgIHZhciB5ID0gcmVjdC55O1xuXG4gICAgICAgIHZhciBoZWlnaHQgPSByZWN0LmhlaWdodDtcbiAgICAgICAgdmFyIHdpZHRoID0gcmVjdC53aWR0aDtcblxuICAgICAgICB2YXIgdGV4dEhlaWdodCA9IHRleHRSZWN0LmhlaWdodDtcblxuICAgICAgICB2YXIgaGFsZkhlaWdodCA9IGhlaWdodCAvIDIgLSB0ZXh0SGVpZ2h0IC8gMjtcblxuICAgICAgICB2YXIgdGV4dEFsaWduID0gJ2xlZnQnO1xuXG4gICAgICAgIHN3aXRjaCAodGV4dFBvc2l0aW9uKSB7XG4gICAgICAgICAgICBjYXNlICdsZWZ0JzpcbiAgICAgICAgICAgICAgICB4IC09IGRpc3RhbmNlO1xuICAgICAgICAgICAgICAgIHkgKz0gaGFsZkhlaWdodDtcbiAgICAgICAgICAgICAgICB0ZXh0QWxpZ24gPSAncmlnaHQnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICAgICAgICAgIHggKz0gZGlzdGFuY2UgKyB3aWR0aDtcbiAgICAgICAgICAgICAgICB5ICs9IGhhbGZIZWlnaHQ7XG4gICAgICAgICAgICAgICAgdGV4dEFsaWduID0gJ2xlZnQnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAndG9wJzpcbiAgICAgICAgICAgICAgICB4ICs9IHdpZHRoIC8gMjtcbiAgICAgICAgICAgICAgICB5IC09IGRpc3RhbmNlICsgdGV4dEhlaWdodDtcbiAgICAgICAgICAgICAgICB0ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICAgICAgICAgICAgeCArPSB3aWR0aCAvIDI7XG4gICAgICAgICAgICAgICAgeSArPSBoZWlnaHQgKyBkaXN0YW5jZTtcbiAgICAgICAgICAgICAgICB0ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2luc2lkZSc6XG4gICAgICAgICAgICAgICAgeCArPSB3aWR0aCAvIDI7XG4gICAgICAgICAgICAgICAgeSArPSBoYWxmSGVpZ2h0O1xuICAgICAgICAgICAgICAgIHRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnaW5zaWRlTGVmdCc6XG4gICAgICAgICAgICAgICAgeCArPSBkaXN0YW5jZTtcbiAgICAgICAgICAgICAgICB5ICs9IGhhbGZIZWlnaHQ7XG4gICAgICAgICAgICAgICAgdGV4dEFsaWduID0gJ2xlZnQnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnaW5zaWRlUmlnaHQnOlxuICAgICAgICAgICAgICAgIHggKz0gd2lkdGggLSBkaXN0YW5jZTtcbiAgICAgICAgICAgICAgICB5ICs9IGhhbGZIZWlnaHQ7XG4gICAgICAgICAgICAgICAgdGV4dEFsaWduID0gJ3JpZ2h0JztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2luc2lkZVRvcCc6XG4gICAgICAgICAgICAgICAgeCArPSB3aWR0aCAvIDI7XG4gICAgICAgICAgICAgICAgeSArPSBkaXN0YW5jZTtcbiAgICAgICAgICAgICAgICB0ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2luc2lkZUJvdHRvbSc6XG4gICAgICAgICAgICAgICAgeCArPSB3aWR0aCAvIDI7XG4gICAgICAgICAgICAgICAgeSArPSBoZWlnaHQgLSB0ZXh0SGVpZ2h0IC0gZGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgdGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdpbnNpZGVUb3BMZWZ0JzpcbiAgICAgICAgICAgICAgICB4ICs9IGRpc3RhbmNlO1xuICAgICAgICAgICAgICAgIHkgKz0gZGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgdGV4dEFsaWduID0gJ2xlZnQnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnaW5zaWRlVG9wUmlnaHQnOlxuICAgICAgICAgICAgICAgIHggKz0gd2lkdGggLSBkaXN0YW5jZTtcbiAgICAgICAgICAgICAgICB5ICs9IGRpc3RhbmNlO1xuICAgICAgICAgICAgICAgIHRleHRBbGlnbiA9ICdyaWdodCc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdpbnNpZGVCb3R0b21MZWZ0JzpcbiAgICAgICAgICAgICAgICB4ICs9IGRpc3RhbmNlO1xuICAgICAgICAgICAgICAgIHkgKz0gaGVpZ2h0IC0gdGV4dEhlaWdodCAtIGRpc3RhbmNlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnaW5zaWRlQm90dG9tUmlnaHQnOlxuICAgICAgICAgICAgICAgIHggKz0gd2lkdGggLSBkaXN0YW5jZTtcbiAgICAgICAgICAgICAgICB5ICs9IGhlaWdodCAtIHRleHRIZWlnaHQgLSBkaXN0YW5jZTtcbiAgICAgICAgICAgICAgICB0ZXh0QWxpZ24gPSAncmlnaHQnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHg6IHgsXG4gICAgICAgICAgICB5OiB5LFxuICAgICAgICAgICAgdGV4dEFsaWduOiB0ZXh0QWxpZ24sXG4gICAgICAgICAgICB0ZXh0QmFzZWxpbmU6ICd0b3AnXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2hvdyBlbGxpcHNpcyBpZiBvdmVyZmxvdy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge3N0cmluZ30gdGV4dFxuICAgICAqIEBwYXJhbSAge3N0cmluZ30gY29udGFpbmVyV2lkdGhcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9IHRleHRGb250XG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBbZWxsaXBzaXM9Jy4uLiddXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IFtvcHRpb25zLm1heEl0ZXJhdGlvbnM9M11cbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IFtvcHRpb25zLm1pbkNoYXI9MF0gSWYgdHJ1bmNhdGUgcmVzdWx0IGFyZSBsZXNzXG4gICAgICogICAgICAgICAgICAgICAgICB0aGVuIG1pbkNoYXIsIGVsbGlwc2lzIHdpbGwgbm90IHNob3csIHdoaWNoIGlzXG4gICAgICogICAgICAgICAgICAgICAgICBiZXR0ZXIgZm9yIHVzZXIgaGludCBpbiBzb21lIGNhc2VzLlxuICAgICAqIEBwYXJhbSAge251bWJlcn0gW29wdGlvbnMucGxhY2Vob2xkZXI9JyddIFdoZW4gYWxsIHRydW5jYXRlZCwgdXNlIHRoZSBwbGFjZWhvbGRlci5cbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAgICovXG4gICAgZnVuY3Rpb24gdHJ1bmNhdGVUZXh0KHRleHQsIGNvbnRhaW5lcldpZHRoLCB0ZXh0Rm9udCwgZWxsaXBzaXMsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKCFjb250YWluZXJXaWR0aCkge1xuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG5cbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAgICAgZWxsaXBzaXMgPSByZXRyaWV2ZShlbGxpcHNpcywgJy4uLicpO1xuICAgICAgICB2YXIgbWF4SXRlcmF0aW9ucyA9IHJldHJpZXZlKG9wdGlvbnMubWF4SXRlcmF0aW9ucywgMik7XG4gICAgICAgIHZhciBtaW5DaGFyID0gcmV0cmlldmUob3B0aW9ucy5taW5DaGFyLCAwKTtcbiAgICAgICAgLy8gRklYTUVcbiAgICAgICAgLy8gT3RoZXIgbGFuZ3VhZ2VzP1xuICAgICAgICB2YXIgY25DaGFyV2lkdGggPSBnZXRUZXh0V2lkdGgoJ+WbvScsIHRleHRGb250KTtcbiAgICAgICAgLy8gRklYTUVcbiAgICAgICAgLy8gQ29uc2lkZXIgcHJvcG9ydGlvbmFsIGZvbnQ/XG4gICAgICAgIHZhciBhc2NDaGFyV2lkdGggPSBnZXRUZXh0V2lkdGgoJ2EnLCB0ZXh0Rm9udCk7XG4gICAgICAgIHZhciBwbGFjZWhvbGRlciA9IHJldHJpZXZlKG9wdGlvbnMucGxhY2Vob2xkZXIsICcnKTtcblxuICAgICAgICAvLyBFeGFtcGxlIDE6IG1pbkNoYXI6IDMsIHRleHQ6ICdhc2RmenhjdicsIHRydW5jYXRlIHJlc3VsdDogJ2FzZGYnLCBidXQgbm90OiAnYS4uLicuXG4gICAgICAgIC8vIEV4YW1wbGUgMjogbWluQ2hhcjogMywgdGV4dDogJ+e7tOW6picsIHRydW5jYXRlIHJlc3VsdDogJ+e7tCcsIGJ1dCBub3Q6ICcuLi4nLlxuICAgICAgICB2YXIgY29udGVudFdpZHRoID0gY29udGFpbmVyV2lkdGggPSBNYXRoLm1heCgwLCBjb250YWluZXJXaWR0aCAtIDEpOyAvLyBSZXNlcnZlIHNvbWUgZ2FwLlxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1pbkNoYXIgJiYgY29udGVudFdpZHRoID49IGFzY0NoYXJXaWR0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb250ZW50V2lkdGggLT0gYXNjQ2hhcldpZHRoO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGVsbGlwc2lzV2lkdGggPSBnZXRUZXh0V2lkdGgoZWxsaXBzaXMpO1xuICAgICAgICBpZiAoZWxsaXBzaXNXaWR0aCA+IGNvbnRlbnRXaWR0aCkge1xuICAgICAgICAgICAgZWxsaXBzaXMgPSAnJztcbiAgICAgICAgICAgIGVsbGlwc2lzV2lkdGggPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgY29udGVudFdpZHRoID0gY29udGFpbmVyV2lkdGggLSBlbGxpcHNpc1dpZHRoO1xuXG4gICAgICAgIHZhciB0ZXh0TGluZXMgPSAodGV4dCArICcnKS5zcGxpdCgnXFxuJyk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRleHRMaW5lcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgdmFyIHRleHRMaW5lID0gdGV4dExpbmVzW2ldO1xuICAgICAgICAgICAgdmFyIGxpbmVXaWR0aCA9IGdldFRleHRXaWR0aCh0ZXh0TGluZSwgdGV4dEZvbnQpO1xuXG4gICAgICAgICAgICBpZiAobGluZVdpZHRoIDw9IGNvbnRhaW5lcldpZHRoKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOzsgaisrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxpbmVXaWR0aCA8PSBjb250ZW50V2lkdGggfHwgaiA+PSBtYXhJdGVyYXRpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgIHRleHRMaW5lICs9IGVsbGlwc2lzO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgc3ViTGVuZ3RoID0gaiA9PT0gMFxuICAgICAgICAgICAgICAgICAgICA/IGVzdGltYXRlTGVuZ3RoKHRleHRMaW5lLCBjb250ZW50V2lkdGgsIGFzY0NoYXJXaWR0aCwgY25DaGFyV2lkdGgpXG4gICAgICAgICAgICAgICAgICAgIDogbGluZVdpZHRoID4gMFxuICAgICAgICAgICAgICAgICAgICA/IE1hdGguZmxvb3IodGV4dExpbmUubGVuZ3RoICogY29udGVudFdpZHRoIC8gbGluZVdpZHRoKVxuICAgICAgICAgICAgICAgICAgICA6IDA7XG5cbiAgICAgICAgICAgICAgICB0ZXh0TGluZSA9IHRleHRMaW5lLnN1YnN0cigwLCBzdWJMZW5ndGgpO1xuICAgICAgICAgICAgICAgIGxpbmVXaWR0aCA9IGdldFRleHRXaWR0aCh0ZXh0TGluZSwgdGV4dEZvbnQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGV4dExpbmUgPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgdGV4dExpbmUgPSBwbGFjZWhvbGRlcjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGV4dExpbmVzW2ldID0gdGV4dExpbmU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGV4dExpbmVzLmpvaW4oJ1xcbicpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVzdGltYXRlTGVuZ3RoKHRleHQsIGNvbnRlbnRXaWR0aCwgYXNjQ2hhcldpZHRoLCBjbkNoYXJXaWR0aCkge1xuICAgICAgICB2YXIgd2lkdGggPSAwO1xuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIGZvciAodmFyIGxlbiA9IHRleHQubGVuZ3RoOyBpIDwgbGVuICYmIHdpZHRoIDwgY29udGVudFdpZHRoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBjaGFyQ29kZSA9IHRleHQuY2hhckNvZGVBdChpKTtcbiAgICAgICAgICAgIHdpZHRoICs9ICgwIDw9IGNoYXJDb2RlICYmIGNoYXJDb2RlIDw9IDEyNykgPyBhc2NDaGFyV2lkdGggOiBjbkNoYXJXaWR0aDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaTtcbiAgICB9XG5cbiAgICB2YXIgdGV4dENvbnRhaW4gPSB7XG5cbiAgICAgICAgZ2V0V2lkdGg6IGdldFRleHRXaWR0aCxcblxuICAgICAgICBnZXRCb3VuZGluZ1JlY3Q6IGdldFRleHRSZWN0LFxuXG4gICAgICAgIGFkanVzdFRleHRQb3NpdGlvbk9uUmVjdDogYWRqdXN0VGV4dFBvc2l0aW9uT25SZWN0LFxuXG4gICAgICAgIHRydW5jYXRlVGV4dDogdHJ1bmNhdGVUZXh0LFxuXG4gICAgICAgIG1lYXN1cmVUZXh0OiBmdW5jdGlvbiAodGV4dCwgdGV4dEZvbnQpIHtcbiAgICAgICAgICAgIHZhciBjdHggPSB1dGlsLmdldENvbnRleHQoKTtcbiAgICAgICAgICAgIGN0eC5mb250ID0gdGV4dEZvbnQgfHwgJzEycHggc2Fucy1zZXJpZic7XG4gICAgICAgICAgICByZXR1cm4gY3R4Lm1lYXN1cmVUZXh0KHRleHQpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gdGV4dENvbnRhaW47XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi96cmVuZGVyL2xpYi9jb250YWluL3RleHQuanNcbiAqKiBtb2R1bGUgaWQgPSAyM1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuLyoqXG4gKiBAbW9kdWxlIGVjaGFydHMvY29yZS9Cb3VuZGluZ1JlY3RcbiAqL1xuXG5cbiAgICB2YXIgdmVjMiA9IHJlcXVpcmUoJy4vdmVjdG9yJyk7XG4gICAgdmFyIG1hdHJpeCA9IHJlcXVpcmUoJy4vbWF0cml4Jyk7XG5cbiAgICB2YXIgdjJBcHBseVRyYW5zZm9ybSA9IHZlYzIuYXBwbHlUcmFuc2Zvcm07XG4gICAgdmFyIG1hdGhNaW4gPSBNYXRoLm1pbjtcbiAgICB2YXIgbWF0aEFicyA9IE1hdGguYWJzO1xuICAgIHZhciBtYXRoTWF4ID0gTWF0aC5tYXg7XG4gICAgLyoqXG4gICAgICogQGFsaWFzIG1vZHVsZTplY2hhcnRzL2NvcmUvQm91bmRpbmdSZWN0XG4gICAgICovXG4gICAgZnVuY3Rpb24gQm91bmRpbmdSZWN0KHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnggPSB4O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMueSA9IHk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIH1cblxuICAgIEJvdW5kaW5nUmVjdC5wcm90b3R5cGUgPSB7XG5cbiAgICAgICAgY29uc3RydWN0b3I6IEJvdW5kaW5nUmVjdCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9jb3JlL0JvdW5kaW5nUmVjdH0gb3RoZXJcbiAgICAgICAgICovXG4gICAgICAgIHVuaW9uOiBmdW5jdGlvbiAob3RoZXIpIHtcbiAgICAgICAgICAgIHZhciB4ID0gbWF0aE1pbihvdGhlci54LCB0aGlzLngpO1xuICAgICAgICAgICAgdmFyIHkgPSBtYXRoTWluKG90aGVyLnksIHRoaXMueSk7XG5cbiAgICAgICAgICAgIHRoaXMud2lkdGggPSBtYXRoTWF4KFxuICAgICAgICAgICAgICAgICAgICBvdGhlci54ICsgb3RoZXIud2lkdGgsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMueCArIHRoaXMud2lkdGhcbiAgICAgICAgICAgICAgICApIC0geDtcbiAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gbWF0aE1heChcbiAgICAgICAgICAgICAgICAgICAgb3RoZXIueSArIG90aGVyLmhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy55ICsgdGhpcy5oZWlnaHRcbiAgICAgICAgICAgICAgICApIC0geTtcbiAgICAgICAgICAgIHRoaXMueCA9IHg7XG4gICAgICAgICAgICB0aGlzLnkgPSB5O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBtXG4gICAgICAgICAqIEBtZXRob2RzXG4gICAgICAgICAqL1xuICAgICAgICBhcHBseVRyYW5zZm9ybTogKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBtaW4gPSBbXTtcbiAgICAgICAgICAgIHZhciBtYXggPSBbXTtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAobSkge1xuICAgICAgICAgICAgICAgIC8vIEluIGNhc2UgdXNhZ2UgbGlrZSB0aGlzXG4gICAgICAgICAgICAgICAgLy8gZWwuZ2V0Qm91bmRpbmdSZWN0KCkuYXBwbHlUcmFuc2Zvcm0oZWwudHJhbnNmb3JtKVxuICAgICAgICAgICAgICAgIC8vIEFuZCBlbGVtZW50IGhhcyBubyB0cmFuc2Zvcm1cbiAgICAgICAgICAgICAgICBpZiAoIW0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtaW5bMF0gPSB0aGlzLng7XG4gICAgICAgICAgICAgICAgbWluWzFdID0gdGhpcy55O1xuICAgICAgICAgICAgICAgIG1heFswXSA9IHRoaXMueCArIHRoaXMud2lkdGg7XG4gICAgICAgICAgICAgICAgbWF4WzFdID0gdGhpcy55ICsgdGhpcy5oZWlnaHQ7XG5cbiAgICAgICAgICAgICAgICB2MkFwcGx5VHJhbnNmb3JtKG1pbiwgbWluLCBtKTtcbiAgICAgICAgICAgICAgICB2MkFwcGx5VHJhbnNmb3JtKG1heCwgbWF4LCBtKTtcblxuICAgICAgICAgICAgICAgIHRoaXMueCA9IG1hdGhNaW4obWluWzBdLCBtYXhbMF0pO1xuICAgICAgICAgICAgICAgIHRoaXMueSA9IG1hdGhNaW4obWluWzFdLCBtYXhbMV0pO1xuICAgICAgICAgICAgICAgIHRoaXMud2lkdGggPSBtYXRoQWJzKG1heFswXSAtIG1pblswXSk7XG4gICAgICAgICAgICAgICAgdGhpcy5oZWlnaHQgPSBtYXRoQWJzKG1heFsxXSAtIG1pblsxXSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KSgpLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYWxjdWxhdGUgbWF0cml4IG9mIHRyYW5zZm9ybWluZyBmcm9tIHNlbGYgdG8gdGFyZ2V0IHJlY3RcbiAgICAgICAgICogQHBhcmFtICB7bW9kdWxlOnpyZW5kZXIvY29yZS9Cb3VuZGluZ1JlY3R9IGJcbiAgICAgICAgICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59XG4gICAgICAgICAqL1xuICAgICAgICBjYWxjdWxhdGVUcmFuc2Zvcm06IGZ1bmN0aW9uIChiKSB7XG4gICAgICAgICAgICB2YXIgYSA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgc3ggPSBiLndpZHRoIC8gYS53aWR0aDtcbiAgICAgICAgICAgIHZhciBzeSA9IGIuaGVpZ2h0IC8gYS5oZWlnaHQ7XG5cbiAgICAgICAgICAgIHZhciBtID0gbWF0cml4LmNyZWF0ZSgpO1xuXG4gICAgICAgICAgICAvLyDnn6npmLXlj7PkuZhcbiAgICAgICAgICAgIG1hdHJpeC50cmFuc2xhdGUobSwgbSwgWy1hLngsIC1hLnldKTtcbiAgICAgICAgICAgIG1hdHJpeC5zY2FsZShtLCBtLCBbc3gsIHN5XSk7XG4gICAgICAgICAgICBtYXRyaXgudHJhbnNsYXRlKG0sIG0sIFtiLngsIGIueV0pO1xuXG4gICAgICAgICAgICByZXR1cm4gbTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHsobW9kdWxlOmVjaGFydHMvY29yZS9Cb3VuZGluZ1JlY3R8T2JqZWN0KX0gYlxuICAgICAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgaW50ZXJzZWN0OiBmdW5jdGlvbiAoYikge1xuICAgICAgICAgICAgdmFyIGEgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIGF4MCA9IGEueDtcbiAgICAgICAgICAgIHZhciBheDEgPSBhLnggKyBhLndpZHRoO1xuICAgICAgICAgICAgdmFyIGF5MCA9IGEueTtcbiAgICAgICAgICAgIHZhciBheTEgPSBhLnkgKyBhLmhlaWdodDtcblxuICAgICAgICAgICAgdmFyIGJ4MCA9IGIueDtcbiAgICAgICAgICAgIHZhciBieDEgPSBiLnggKyBiLndpZHRoO1xuICAgICAgICAgICAgdmFyIGJ5MCA9IGIueTtcbiAgICAgICAgICAgIHZhciBieTEgPSBiLnkgKyBiLmhlaWdodDtcblxuICAgICAgICAgICAgcmV0dXJuICEgKGF4MSA8IGJ4MCB8fCBieDEgPCBheDAgfHwgYXkxIDwgYnkwIHx8IGJ5MSA8IGF5MCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY29udGFpbjogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgICAgIHZhciByZWN0ID0gdGhpcztcbiAgICAgICAgICAgIHJldHVybiB4ID49IHJlY3QueFxuICAgICAgICAgICAgICAgICYmIHggPD0gKHJlY3QueCArIHJlY3Qud2lkdGgpXG4gICAgICAgICAgICAgICAgJiYgeSA+PSByZWN0LnlcbiAgICAgICAgICAgICAgICAmJiB5IDw9IChyZWN0LnkgKyByZWN0LmhlaWdodCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4ge21vZHVsZTplY2hhcnRzL2NvcmUvQm91bmRpbmdSZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgY2xvbmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQm91bmRpbmdSZWN0KHRoaXMueCwgdGhpcy55LCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvcHkgZnJvbSBhbm90aGVyIHJlY3RcbiAgICAgICAgICovXG4gICAgICAgIGNvcHk6IGZ1bmN0aW9uIChvdGhlcikge1xuICAgICAgICAgICAgdGhpcy54ID0gb3RoZXIueDtcbiAgICAgICAgICAgIHRoaXMueSA9IG90aGVyLnk7XG4gICAgICAgICAgICB0aGlzLndpZHRoID0gb3RoZXIud2lkdGg7XG4gICAgICAgICAgICB0aGlzLmhlaWdodCA9IG90aGVyLmhlaWdodDtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IEJvdW5kaW5nUmVjdDtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3pyZW5kZXIvbGliL2NvcmUvQm91bmRpbmdSZWN0LmpzXG4gKiogbW9kdWxlIGlkID0gMjRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0Jztcbi8qKlxuICogUGF0aCDku6PnkIbvvIzlj6/ku6XlnKhgYnVpbGRQYXRoYOS4reeUqOS6juabv+S7o2BjdHhgLCDkvJrkv53lrZjmr4/kuKpwYXRo5pON5L2c55qE5ZG95Luk5YiwcGF0aENvbW1hbmRz5bGe5oCn5LitXG4gKiDlj6/ku6XnlKjkuo4gaXNJbnNpZGVQYXRoIOWIpOaWreS7peWPiuiOt+WPlmJvdW5kaW5nUmVjdFxuICpcbiAqIEBtb2R1bGUgenJlbmRlci9jb3JlL1BhdGhQcm94eVxuICogQGF1dGhvciBZaSBTaGVuIChodHRwOi8vd3d3LmdpdGh1Yi5jb20vcGlzc2FuZylcbiAqL1xuXG4gLy8gVE9ETyBnZXRUb3RhbExlbmd0aCwgZ2V0UG9pbnRBdExlbmd0aFxuXG5cbiAgICB2YXIgY3VydmUgPSByZXF1aXJlKCcuL2N1cnZlJyk7XG4gICAgdmFyIHZlYzIgPSByZXF1aXJlKCcuL3ZlY3RvcicpO1xuICAgIHZhciBiYm94ID0gcmVxdWlyZSgnLi9iYm94Jyk7XG4gICAgdmFyIEJvdW5kaW5nUmVjdCA9IHJlcXVpcmUoJy4vQm91bmRpbmdSZWN0Jyk7XG4gICAgdmFyIGRwciA9IHJlcXVpcmUoJy4uL2NvbmZpZycpLmRldmljZVBpeGVsUmF0aW87XG5cbiAgICB2YXIgQ01EID0ge1xuICAgICAgICBNOiAxLFxuICAgICAgICBMOiAyLFxuICAgICAgICBDOiAzLFxuICAgICAgICBROiA0LFxuICAgICAgICBBOiA1LFxuICAgICAgICBaOiA2LFxuICAgICAgICAvLyBSZWN0XG4gICAgICAgIFI6IDdcbiAgICB9O1xuXG4gICAgdmFyIG1pbiA9IFtdO1xuICAgIHZhciBtYXggPSBbXTtcbiAgICB2YXIgbWluMiA9IFtdO1xuICAgIHZhciBtYXgyID0gW107XG4gICAgdmFyIG1hdGhNaW4gPSBNYXRoLm1pbjtcbiAgICB2YXIgbWF0aE1heCA9IE1hdGgubWF4O1xuICAgIHZhciBtYXRoQ29zID0gTWF0aC5jb3M7XG4gICAgdmFyIG1hdGhTaW4gPSBNYXRoLnNpbjtcbiAgICB2YXIgbWF0aFNxcnQgPSBNYXRoLnNxcnQ7XG4gICAgdmFyIG1hdGhBYnMgPSBNYXRoLmFicztcblxuICAgIHZhciBoYXNUeXBlZEFycmF5ID0gdHlwZW9mIEZsb2F0MzJBcnJheSAhPSAndW5kZWZpbmVkJztcblxuICAgIC8qKlxuICAgICAqIEBhbGlhcyBtb2R1bGU6enJlbmRlci9jb3JlL1BhdGhQcm94eVxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIHZhciBQYXRoUHJveHkgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFBhdGggZGF0YS4gU3RvcmVkIGFzIGZsYXQgYXJyYXlcbiAgICAgICAgICogQHR5cGUge0FycmF5LjxPYmplY3Q+fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kYXRhID0gW107XG5cbiAgICAgICAgdGhpcy5fbGVuID0gMDtcblxuICAgICAgICB0aGlzLl9jdHggPSBudWxsO1xuXG4gICAgICAgIHRoaXMuX3hpID0gMDtcbiAgICAgICAgdGhpcy5feWkgPSAwO1xuXG4gICAgICAgIHRoaXMuX3gwID0gMDtcbiAgICAgICAgdGhpcy5feTAgPSAwO1xuXG4gICAgICAgIC8vIFVuaXQgeCwgVW5pdCB5LiBQcm92aWRlIGZvciBhdm9pZGluZyBkcmF3aW5nIHRoYXQgdG9vIHNob3J0IGxpbmUgc2VnbWVudFxuICAgICAgICB0aGlzLl91eCA9IDA7XG4gICAgICAgIHRoaXMuX3V5ID0gMDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICog5b+r6YCf6K6h566XUGF0aOWMheWbtOebku+8iOW5tuS4jeaYr+acgOWwj+WMheWbtOebku+8iVxuICAgICAqIEByZXR1cm4ge09iamVjdH1cbiAgICAgKi9cbiAgICBQYXRoUHJveHkucHJvdG90eXBlID0ge1xuXG4gICAgICAgIGNvbnN0cnVjdG9yOiBQYXRoUHJveHksXG5cbiAgICAgICAgX2xpbmVEYXNoOiBudWxsLFxuXG4gICAgICAgIF9kYXNoT2Zmc2V0OiAwLFxuXG4gICAgICAgIF9kYXNoSWR4OiAwLFxuXG4gICAgICAgIF9kYXNoU3VtOiAwLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmVhZE9ubHlcbiAgICAgICAgICovXG4gICAgICAgIHNldFNjYWxlOiBmdW5jdGlvbiAoc3gsIHN5KSB7XG4gICAgICAgICAgICB0aGlzLl91eCA9IG1hdGhBYnMoMSAvIGRwciAvIHN4KSB8fCAwO1xuICAgICAgICAgICAgdGhpcy5fdXkgPSBtYXRoQWJzKDEgLyBkcHIgLyBzeSkgfHwgMDtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXRDb250ZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY3R4O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAgICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9jb3JlL1BhdGhQcm94eX1cbiAgICAgICAgICovXG4gICAgICAgIGJlZ2luUGF0aDogZnVuY3Rpb24gKGN0eCkge1xuXG4gICAgICAgICAgICB0aGlzLl9jdHggPSBjdHg7XG5cbiAgICAgICAgICAgIGN0eCAmJiBjdHguYmVnaW5QYXRoKCk7XG5cbiAgICAgICAgICAgIGN0eCAmJiAodGhpcy5kcHIgPSBjdHguZHByKTtcblxuICAgICAgICAgICAgLy8gUmVzZXRcbiAgICAgICAgICAgIHRoaXMuX2xlbiA9IDA7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl9saW5lRGFzaCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xpbmVEYXNoID0gbnVsbDtcblxuICAgICAgICAgICAgICAgIHRoaXMuX2Rhc2hPZmZzZXQgPSAwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSB4XG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0geVxuICAgICAgICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9jb3JlL1BhdGhQcm94eX1cbiAgICAgICAgICovXG4gICAgICAgIG1vdmVUbzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkRGF0YShDTUQuTSwgeCwgeSk7XG4gICAgICAgICAgICB0aGlzLl9jdHggJiYgdGhpcy5fY3R4Lm1vdmVUbyh4LCB5KTtcblxuICAgICAgICAgICAgLy8geDAsIHkwLCB4aSwgeWkg5piv6K6w5b2V5ZyoIF9kYXNoZWRYWFhYVG8g5pa55rOV5Lit5L2/55SoXG4gICAgICAgICAgICAvLyB4aSwgeWkg6K6w5b2V5b2T5YmN54K5LCB4MCwgeTAg5ZyoIGNsb3NlUGF0aCDnmoTml7blgJnlm57liLDotbflp4vngrnjgIJcbiAgICAgICAgICAgIC8vIOacieWPr+iDveWcqCBiZWdpblBhdGgg5LmL5ZCO55u05o6l6LCD55SoIGxpbmVUb++8jOi/meaXtuWAmSB4MCwgeTAg6ZyA6KaBXG4gICAgICAgICAgICAvLyDlnKggbGluZVRvIOaWueazleS4reiusOW9le+8jOi/memHjOWFiOS4jeiAg+iZkei/meenjeaDheWGte+8jGRhc2hlZCBsaW5lIOS5n+WPquWcqCBJRTEwLSDkuK3kuI3mlK/mjIFcbiAgICAgICAgICAgIHRoaXMuX3gwID0geDtcbiAgICAgICAgICAgIHRoaXMuX3kwID0geTtcblxuICAgICAgICAgICAgdGhpcy5feGkgPSB4O1xuICAgICAgICAgICAgdGhpcy5feWkgPSB5O1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSB4XG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0geVxuICAgICAgICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9jb3JlL1BhdGhQcm94eX1cbiAgICAgICAgICovXG4gICAgICAgIGxpbmVUbzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgICAgIHZhciBleGNlZWRVbml0ID0gbWF0aEFicyh4IC0gdGhpcy5feGkpID4gdGhpcy5fdXhcbiAgICAgICAgICAgICAgICB8fCBtYXRoQWJzKHkgLSB0aGlzLl95aSkgPiB0aGlzLl91eVxuICAgICAgICAgICAgICAgIC8vIEZvcmNlIGRyYXcgdGhlIGZpcnN0IHNlZ21lbnRcbiAgICAgICAgICAgICAgICB8fCB0aGlzLl9sZW4gPCA1O1xuXG4gICAgICAgICAgICB0aGlzLmFkZERhdGEoQ01ELkwsIHgsIHkpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5fY3R4ICYmIGV4Y2VlZFVuaXQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9uZWVkc0Rhc2goKSA/IHRoaXMuX2Rhc2hlZExpbmVUbyh4LCB5KVxuICAgICAgICAgICAgICAgICAgICA6IHRoaXMuX2N0eC5saW5lVG8oeCwgeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZXhjZWVkVW5pdCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3hpID0geDtcbiAgICAgICAgICAgICAgICB0aGlzLl95aSA9IHk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHgxXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0geTFcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSB4MlxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHkyXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0geDNcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSB5M1xuICAgICAgICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9jb3JlL1BhdGhQcm94eX1cbiAgICAgICAgICovXG4gICAgICAgIGJlemllckN1cnZlVG86IGZ1bmN0aW9uICh4MSwgeTEsIHgyLCB5MiwgeDMsIHkzKSB7XG4gICAgICAgICAgICB0aGlzLmFkZERhdGEoQ01ELkMsIHgxLCB5MSwgeDIsIHkyLCB4MywgeTMpO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2N0eCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX25lZWRzRGFzaCgpID8gdGhpcy5fZGFzaGVkQmV6aWVyVG8oeDEsIHkxLCB4MiwgeTIsIHgzLCB5MylcbiAgICAgICAgICAgICAgICAgICAgOiB0aGlzLl9jdHguYmV6aWVyQ3VydmVUbyh4MSwgeTEsIHgyLCB5MiwgeDMsIHkzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3hpID0geDM7XG4gICAgICAgICAgICB0aGlzLl95aSA9IHkzO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0geDFcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSB5MVxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHgyXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0geTJcbiAgICAgICAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvY29yZS9QYXRoUHJveHl9XG4gICAgICAgICAqL1xuICAgICAgICBxdWFkcmF0aWNDdXJ2ZVRvOiBmdW5jdGlvbiAoeDEsIHkxLCB4MiwgeTIpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkRGF0YShDTUQuUSwgeDEsIHkxLCB4MiwgeTIpO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2N0eCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX25lZWRzRGFzaCgpID8gdGhpcy5fZGFzaGVkUXVhZHJhdGljVG8oeDEsIHkxLCB4MiwgeTIpXG4gICAgICAgICAgICAgICAgICAgIDogdGhpcy5fY3R4LnF1YWRyYXRpY0N1cnZlVG8oeDEsIHkxLCB4MiwgeTIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5feGkgPSB4MjtcbiAgICAgICAgICAgIHRoaXMuX3lpID0geTI7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSBjeFxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IGN5XG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gclxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHN0YXJ0QW5nbGVcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSBlbmRBbmdsZVxuICAgICAgICAgKiBAcGFyYW0gIHtib29sZWFufSBhbnRpY2xvY2t3aXNlXG4gICAgICAgICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2NvcmUvUGF0aFByb3h5fVxuICAgICAgICAgKi9cbiAgICAgICAgYXJjOiBmdW5jdGlvbiAoY3gsIGN5LCByLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgYW50aWNsb2Nrd2lzZSkge1xuICAgICAgICAgICAgdGhpcy5hZGREYXRhKFxuICAgICAgICAgICAgICAgIENNRC5BLCBjeCwgY3ksIHIsIHIsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlIC0gc3RhcnRBbmdsZSwgMCwgYW50aWNsb2Nrd2lzZSA/IDAgOiAxXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgdGhpcy5fY3R4ICYmIHRoaXMuX2N0eC5hcmMoY3gsIGN5LCByLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgYW50aWNsb2Nrd2lzZSk7XG5cbiAgICAgICAgICAgIHRoaXMuX3hpID0gbWF0aENvcyhlbmRBbmdsZSkgKiByICsgY3g7XG4gICAgICAgICAgICB0aGlzLl94aSA9IG1hdGhTaW4oZW5kQW5nbGUpICogciArIGN4O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gVE9ET1xuICAgICAgICBhcmNUbzogZnVuY3Rpb24gKHgxLCB5MSwgeDIsIHkyLCByYWRpdXMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9jdHgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jdHguYXJjVG8oeDEsIHkxLCB4MiwgeTIsIHJhZGl1cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBUT0RPXG4gICAgICAgIHJlY3Q6IGZ1bmN0aW9uICh4LCB5LCB3LCBoKSB7XG4gICAgICAgICAgICB0aGlzLl9jdHggJiYgdGhpcy5fY3R4LnJlY3QoeCwgeSwgdywgaCk7XG4gICAgICAgICAgICB0aGlzLmFkZERhdGEoQ01ELlIsIHgsIHksIHcsIGgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2NvcmUvUGF0aFByb3h5fVxuICAgICAgICAgKi9cbiAgICAgICAgY2xvc2VQYXRoOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLmFkZERhdGEoQ01ELlopO1xuXG4gICAgICAgICAgICB2YXIgY3R4ID0gdGhpcy5fY3R4O1xuICAgICAgICAgICAgdmFyIHgwID0gdGhpcy5feDA7XG4gICAgICAgICAgICB2YXIgeTAgPSB0aGlzLl95MDtcbiAgICAgICAgICAgIGlmIChjdHgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9uZWVkc0Rhc2goKSAmJiB0aGlzLl9kYXNoZWRMaW5lVG8oeDAsIHkwKTtcbiAgICAgICAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX3hpID0geDA7XG4gICAgICAgICAgICB0aGlzLl95aSA9IHkwO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnRleHQg5LuO5aSW6YOo5Lyg5YWl77yM5Zug5Li65pyJ5Y+v6IO95pivIHJlYnVpbGRQYXRoIOWujOS5i+WQjuWGjSBmaWxs44CCXG4gICAgICAgICAqIHN0cm9rZSDlkIzmoLdcbiAgICAgICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAgICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9jb3JlL1BhdGhQcm94eX1cbiAgICAgICAgICovXG4gICAgICAgIGZpbGw6IGZ1bmN0aW9uIChjdHgpIHtcbiAgICAgICAgICAgIGN0eCAmJiBjdHguZmlsbCgpO1xuICAgICAgICAgICAgdGhpcy50b1N0YXRpYygpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICAgICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2NvcmUvUGF0aFByb3h5fVxuICAgICAgICAgKi9cbiAgICAgICAgc3Ryb2tlOiBmdW5jdGlvbiAoY3R4KSB7XG4gICAgICAgICAgICBjdHggJiYgY3R4LnN0cm9rZSgpO1xuICAgICAgICAgICAgdGhpcy50b1N0YXRpYygpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlv4XpobvlnKjlhbblroPnu5jliLblkb3ku6TliY3osIPnlKhcbiAgICAgICAgICogTXVzdCBiZSBpbnZva2VkIGJlZm9yZSBhbGwgb3RoZXIgcGF0aCBkcmF3aW5nIG1ldGhvZHNcbiAgICAgICAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvY29yZS9QYXRoUHJveHl9XG4gICAgICAgICAqL1xuICAgICAgICBzZXRMaW5lRGFzaDogZnVuY3Rpb24gKGxpbmVEYXNoKSB7XG4gICAgICAgICAgICBpZiAobGluZURhc2ggaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xpbmVEYXNoID0gbGluZURhc2g7XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9kYXNoSWR4ID0gMDtcblxuICAgICAgICAgICAgICAgIHZhciBsaW5lRGFzaFN1bSA9IDA7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lRGFzaC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBsaW5lRGFzaFN1bSArPSBsaW5lRGFzaFtpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fZGFzaFN1bSA9IGxpbmVEYXNoU3VtO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOW/hemhu+WcqOWFtuWug+e7mOWItuWRveS7pOWJjeiwg+eUqFxuICAgICAgICAgKiBNdXN0IGJlIGludm9rZWQgYmVmb3JlIGFsbCBvdGhlciBwYXRoIGRyYXdpbmcgbWV0aG9kc1xuICAgICAgICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9jb3JlL1BhdGhQcm94eX1cbiAgICAgICAgICovXG4gICAgICAgIHNldExpbmVEYXNoT2Zmc2V0OiBmdW5jdGlvbiAob2Zmc2V0KSB7XG4gICAgICAgICAgICB0aGlzLl9kYXNoT2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICBsZW46IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9sZW47XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOebtOaOpeiuvue9riBQYXRoIOaVsOaNrlxuICAgICAgICAgKi9cbiAgICAgICAgc2V0RGF0YTogZnVuY3Rpb24gKGRhdGEpIHtcblxuICAgICAgICAgICAgdmFyIGxlbiA9IGRhdGEubGVuZ3RoO1xuXG4gICAgICAgICAgICBpZiAoISAodGhpcy5kYXRhICYmIHRoaXMuZGF0YS5sZW5ndGggPT0gbGVuKSAmJiBoYXNUeXBlZEFycmF5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhID0gbmV3IEZsb2F0MzJBcnJheShsZW4pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhW2ldID0gZGF0YVtpXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5fbGVuID0gbGVuO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmt7vliqDlrZDot6/lvoRcbiAgICAgICAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9jb3JlL1BhdGhQcm94eXxBcnJheS48bW9kdWxlOnpyZW5kZXIvY29yZS9QYXRoUHJveHk+fSBwYXRoXG4gICAgICAgICAqL1xuICAgICAgICBhcHBlbmRQYXRoOiBmdW5jdGlvbiAocGF0aCkge1xuICAgICAgICAgICAgaWYgKCEocGF0aCBpbnN0YW5jZW9mIEFycmF5KSkge1xuICAgICAgICAgICAgICAgIHBhdGggPSBbcGF0aF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbGVuID0gcGF0aC5sZW5ndGg7XG4gICAgICAgICAgICB2YXIgYXBwZW5kU2l6ZSA9IDA7XG4gICAgICAgICAgICB2YXIgb2Zmc2V0ID0gdGhpcy5fbGVuO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGFwcGVuZFNpemUgKz0gcGF0aFtpXS5sZW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChoYXNUeXBlZEFycmF5ICYmICh0aGlzLmRhdGEgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhID0gbmV3IEZsb2F0MzJBcnJheShvZmZzZXQgKyBhcHBlbmRTaXplKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgYXBwZW5kUGF0aERhdGEgPSBwYXRoW2ldLmRhdGE7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBhcHBlbmRQYXRoRGF0YS5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRhdGFbb2Zmc2V0KytdID0gYXBwZW5kUGF0aERhdGFba107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fbGVuID0gb2Zmc2V0O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDloavlhYUgUGF0aCDmlbDmja7jgIJcbiAgICAgICAgICog5bC96YeP5aSN55So6ICM5LiN55Sz5piO5paw55qE5pWw57uE44CC5aSn6YOo5YiG5Zu+5b2i6YeN57uY55qE5oyH5Luk5pWw5o2u6ZW/5bqm6YO95piv5LiN5Y+Y55qE44CCXG4gICAgICAgICAqL1xuICAgICAgICBhZGREYXRhOiBmdW5jdGlvbiAoY21kKSB7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9sZW4gKyBhcmd1bWVudHMubGVuZ3RoID4gZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAvLyDlm6DkuLrkuYvliY3nmoTmlbDnu4Tlt7Lnu4/ovazmjaLmiJDpnZnmgIHnmoQgRmxvYXQzMkFycmF5XG4gICAgICAgICAgICAgICAgLy8g5omA5Lul5LiN5aSf55So5pe26ZyA6KaB5omp5bGV5LiA5Liq5paw55qE5Yqo5oCB5pWw57uEXG4gICAgICAgICAgICAgICAgdGhpcy5fZXhwYW5kRGF0YSgpO1xuICAgICAgICAgICAgICAgIGRhdGEgPSB0aGlzLmRhdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGRhdGFbdGhpcy5fbGVuKytdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl9wcmV2Q21kID0gY21kO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9leHBhbmREYXRhOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBPbmx5IGlmIGRhdGEgaXMgRmxvYXQzMkFycmF5XG4gICAgICAgICAgICBpZiAoISh0aGlzLmRhdGEgaW5zdGFuY2VvZiBBcnJheSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgbmV3RGF0YSA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3RGF0YVtpXSA9IHRoaXMuZGF0YVtpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhID0gbmV3RGF0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgbmVlZHMganMgaW1wbGVtZW50ZWQgZGFzaGVkIGxpbmVcbiAgICAgICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIF9uZWVkc0Rhc2g6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9saW5lRGFzaDtcbiAgICAgICAgfSxcblxuICAgICAgICBfZGFzaGVkTGluZVRvOiBmdW5jdGlvbiAoeDEsIHkxKSB7XG4gICAgICAgICAgICB2YXIgZGFzaFN1bSA9IHRoaXMuX2Rhc2hTdW07XG4gICAgICAgICAgICB2YXIgb2Zmc2V0ID0gdGhpcy5fZGFzaE9mZnNldDtcbiAgICAgICAgICAgIHZhciBsaW5lRGFzaCA9IHRoaXMuX2xpbmVEYXNoO1xuICAgICAgICAgICAgdmFyIGN0eCA9IHRoaXMuX2N0eDtcblxuICAgICAgICAgICAgdmFyIHgwID0gdGhpcy5feGk7XG4gICAgICAgICAgICB2YXIgeTAgPSB0aGlzLl95aTtcbiAgICAgICAgICAgIHZhciBkeCA9IHgxIC0geDA7XG4gICAgICAgICAgICB2YXIgZHkgPSB5MSAtIHkwO1xuICAgICAgICAgICAgdmFyIGRpc3QgPSBtYXRoU3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gICAgICAgICAgICB2YXIgeCA9IHgwO1xuICAgICAgICAgICAgdmFyIHkgPSB5MDtcbiAgICAgICAgICAgIHZhciBkYXNoO1xuICAgICAgICAgICAgdmFyIG5EYXNoID0gbGluZURhc2gubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIGlkeDtcbiAgICAgICAgICAgIGR4IC89IGRpc3Q7XG4gICAgICAgICAgICBkeSAvPSBkaXN0O1xuXG4gICAgICAgICAgICBpZiAob2Zmc2V0IDwgMCkge1xuICAgICAgICAgICAgICAgIC8vIENvbnZlcnQgdG8gcG9zaXRpdmUgb2Zmc2V0XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gZGFzaFN1bSArIG9mZnNldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9mZnNldCAlPSBkYXNoU3VtO1xuICAgICAgICAgICAgeCAtPSBvZmZzZXQgKiBkeDtcbiAgICAgICAgICAgIHkgLT0gb2Zmc2V0ICogZHk7XG5cbiAgICAgICAgICAgIHdoaWxlICgoZHggPiAwICYmIHggPD0geDEpIHx8IChkeCA8IDAgJiYgeCA+PSB4MSlcbiAgICAgICAgICAgIHx8IChkeCA9PSAwICYmICgoZHkgPiAwICYmIHkgPD0geTEpIHx8IChkeSA8IDAgJiYgeSA+PSB5MSkpKSkge1xuICAgICAgICAgICAgICAgIGlkeCA9IHRoaXMuX2Rhc2hJZHg7XG4gICAgICAgICAgICAgICAgZGFzaCA9IGxpbmVEYXNoW2lkeF07XG4gICAgICAgICAgICAgICAgeCArPSBkeCAqIGRhc2g7XG4gICAgICAgICAgICAgICAgeSArPSBkeSAqIGRhc2g7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGFzaElkeCA9IChpZHggKyAxKSAlIG5EYXNoO1xuICAgICAgICAgICAgICAgIC8vIFNraXAgcG9zaXRpdmUgb2Zmc2V0XG4gICAgICAgICAgICAgICAgaWYgKChkeCA+IDAgJiYgeCA8IHgwKSB8fCAoZHggPCAwICYmIHggPiB4MCkgfHwgKGR5ID4gMCAmJiB5IDwgeTApIHx8IChkeSA8IDAgJiYgeSA+IHkwKSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3R4W2lkeCAlIDIgPyAnbW92ZVRvJyA6ICdsaW5lVG8nXShcbiAgICAgICAgICAgICAgICAgICAgZHggPj0gMCA/IG1hdGhNaW4oeCwgeDEpIDogbWF0aE1heCh4LCB4MSksXG4gICAgICAgICAgICAgICAgICAgIGR5ID49IDAgPyBtYXRoTWluKHksIHkxKSA6IG1hdGhNYXgoeSwgeTEpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE9mZnNldCBmb3IgbmV4dCBsaW5lVG9cbiAgICAgICAgICAgIGR4ID0geCAtIHgxO1xuICAgICAgICAgICAgZHkgPSB5IC0geTE7XG4gICAgICAgICAgICB0aGlzLl9kYXNoT2Zmc2V0ID0gLW1hdGhTcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBOb3QgYWNjdXJhdGUgZGFzaGVkIGxpbmUgdG9cbiAgICAgICAgX2Rhc2hlZEJlemllclRvOiBmdW5jdGlvbiAoeDEsIHkxLCB4MiwgeTIsIHgzLCB5Mykge1xuICAgICAgICAgICAgdmFyIGRhc2hTdW0gPSB0aGlzLl9kYXNoU3VtO1xuICAgICAgICAgICAgdmFyIG9mZnNldCA9IHRoaXMuX2Rhc2hPZmZzZXQ7XG4gICAgICAgICAgICB2YXIgbGluZURhc2ggPSB0aGlzLl9saW5lRGFzaDtcbiAgICAgICAgICAgIHZhciBjdHggPSB0aGlzLl9jdHg7XG5cbiAgICAgICAgICAgIHZhciB4MCA9IHRoaXMuX3hpO1xuICAgICAgICAgICAgdmFyIHkwID0gdGhpcy5feWk7XG4gICAgICAgICAgICB2YXIgdDtcbiAgICAgICAgICAgIHZhciBkeDtcbiAgICAgICAgICAgIHZhciBkeTtcbiAgICAgICAgICAgIHZhciBjdWJpY0F0ID0gY3VydmUuY3ViaWNBdDtcbiAgICAgICAgICAgIHZhciBiZXppZXJMZW4gPSAwO1xuICAgICAgICAgICAgdmFyIGlkeCA9IHRoaXMuX2Rhc2hJZHg7XG4gICAgICAgICAgICB2YXIgbkRhc2ggPSBsaW5lRGFzaC5sZW5ndGg7XG5cbiAgICAgICAgICAgIHZhciB4O1xuICAgICAgICAgICAgdmFyIHk7XG5cbiAgICAgICAgICAgIHZhciB0bXBMZW4gPSAwO1xuXG4gICAgICAgICAgICBpZiAob2Zmc2V0IDwgMCkge1xuICAgICAgICAgICAgICAgIC8vIENvbnZlcnQgdG8gcG9zaXRpdmUgb2Zmc2V0XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gZGFzaFN1bSArIG9mZnNldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9mZnNldCAlPSBkYXNoU3VtO1xuICAgICAgICAgICAgLy8gQmV6aWVyIGFwcHJveCBsZW5ndGhcbiAgICAgICAgICAgIGZvciAodCA9IDA7IHQgPCAxOyB0ICs9IDAuMSkge1xuICAgICAgICAgICAgICAgIGR4ID0gY3ViaWNBdCh4MCwgeDEsIHgyLCB4MywgdCArIDAuMSlcbiAgICAgICAgICAgICAgICAgICAgLSBjdWJpY0F0KHgwLCB4MSwgeDIsIHgzLCB0KTtcbiAgICAgICAgICAgICAgICBkeSA9IGN1YmljQXQoeTAsIHkxLCB5MiwgeTMsIHQgKyAwLjEpXG4gICAgICAgICAgICAgICAgICAgIC0gY3ViaWNBdCh5MCwgeTEsIHkyLCB5MywgdCk7XG4gICAgICAgICAgICAgICAgYmV6aWVyTGVuICs9IG1hdGhTcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRmluZCBpZHggYWZ0ZXIgYWRkIG9mZnNldFxuICAgICAgICAgICAgZm9yICg7IGlkeCA8IG5EYXNoOyBpZHgrKykge1xuICAgICAgICAgICAgICAgIHRtcExlbiArPSBsaW5lRGFzaFtpZHhdO1xuICAgICAgICAgICAgICAgIGlmICh0bXBMZW4gPiBvZmZzZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdCA9ICh0bXBMZW4gLSBvZmZzZXQpIC8gYmV6aWVyTGVuO1xuXG4gICAgICAgICAgICB3aGlsZSAodCA8PSAxKSB7XG5cbiAgICAgICAgICAgICAgICB4ID0gY3ViaWNBdCh4MCwgeDEsIHgyLCB4MywgdCk7XG4gICAgICAgICAgICAgICAgeSA9IGN1YmljQXQoeTAsIHkxLCB5MiwgeTMsIHQpO1xuXG4gICAgICAgICAgICAgICAgLy8gVXNlIGxpbmUgdG8gYXBwcm94aW1hdGUgZGFzaGVkIGJlemllclxuICAgICAgICAgICAgICAgIC8vIEJhZCByZXN1bHQgaWYgZGFzaCBpcyBsb25nXG4gICAgICAgICAgICAgICAgaWR4ICUgMiA/IGN0eC5tb3ZlVG8oeCwgeSlcbiAgICAgICAgICAgICAgICAgICAgOiBjdHgubGluZVRvKHgsIHkpO1xuXG4gICAgICAgICAgICAgICAgdCArPSBsaW5lRGFzaFtpZHhdIC8gYmV6aWVyTGVuO1xuXG4gICAgICAgICAgICAgICAgaWR4ID0gKGlkeCArIDEpICUgbkRhc2g7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEZpbmlzaCB0aGUgbGFzdCBzZWdtZW50IGFuZCBjYWxjdWxhdGUgdGhlIG5ldyBvZmZzZXRcbiAgICAgICAgICAgIChpZHggJSAyICE9PSAwKSAmJiBjdHgubGluZVRvKHgzLCB5Myk7XG4gICAgICAgICAgICBkeCA9IHgzIC0geDtcbiAgICAgICAgICAgIGR5ID0geTMgLSB5O1xuICAgICAgICAgICAgdGhpcy5fZGFzaE9mZnNldCA9IC1tYXRoU3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2Rhc2hlZFF1YWRyYXRpY1RvOiBmdW5jdGlvbiAoeDEsIHkxLCB4MiwgeTIpIHtcbiAgICAgICAgICAgIC8vIENvbnZlcnQgcXVhZHJhdGljIHRvIGN1YmljIHVzaW5nIGRlZ3JlZSBlbGV2YXRpb25cbiAgICAgICAgICAgIHZhciB4MyA9IHgyO1xuICAgICAgICAgICAgdmFyIHkzID0geTI7XG4gICAgICAgICAgICB4MiA9ICh4MiArIDIgKiB4MSkgLyAzO1xuICAgICAgICAgICAgeTIgPSAoeTIgKyAyICogeTEpIC8gMztcbiAgICAgICAgICAgIHgxID0gKHRoaXMuX3hpICsgMiAqIHgxKSAvIDM7XG4gICAgICAgICAgICB5MSA9ICh0aGlzLl95aSArIDIgKiB5MSkgLyAzO1xuXG4gICAgICAgICAgICB0aGlzLl9kYXNoZWRCZXppZXJUbyh4MSwgeTEsIHgyLCB5MiwgeDMsIHkzKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog6L2s5oiQ6Z2Z5oCB55qEIEZsb2F0MzJBcnJheSDlh4/lsJHloIblhoXlrZjljaDnlKhcbiAgICAgICAgICogQ29udmVydCBkeW5hbWljIGFycmF5IHRvIHN0YXRpYyBGbG9hdDMyQXJyYXlcbiAgICAgICAgICovXG4gICAgICAgIHRvU3RhdGljOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICAgICAgICAgIGlmIChkYXRhIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgICAgICBkYXRhLmxlbmd0aCA9IHRoaXMuX2xlbjtcbiAgICAgICAgICAgICAgICBpZiAoaGFzVHlwZWRBcnJheSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRhdGEgPSBuZXcgRmxvYXQzMkFycmF5KGRhdGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvY29yZS9Cb3VuZGluZ1JlY3R9XG4gICAgICAgICAqL1xuICAgICAgICBnZXRCb3VuZGluZ1JlY3Q6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIG1pblswXSA9IG1pblsxXSA9IG1pbjJbMF0gPSBtaW4yWzFdID0gTnVtYmVyLk1BWF9WQUxVRTtcbiAgICAgICAgICAgIG1heFswXSA9IG1heFsxXSA9IG1heDJbMF0gPSBtYXgyWzFdID0gLU51bWJlci5NQVhfVkFMVUU7XG5cbiAgICAgICAgICAgIHZhciBkYXRhID0gdGhpcy5kYXRhO1xuICAgICAgICAgICAgdmFyIHhpID0gMDtcbiAgICAgICAgICAgIHZhciB5aSA9IDA7XG4gICAgICAgICAgICB2YXIgeDAgPSAwO1xuICAgICAgICAgICAgdmFyIHkwID0gMDtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDspIHtcbiAgICAgICAgICAgICAgICB2YXIgY21kID0gZGF0YVtpKytdO1xuXG4gICAgICAgICAgICAgICAgaWYgKGkgPT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAvLyDlpoLmnpznrKzkuIDkuKrlkb3ku6TmmK8gTCwgQywgUVxuICAgICAgICAgICAgICAgICAgICAvLyDliJkgcHJldmlvdXMgcG9pbnQg5ZCM57uY5Yi25ZG95Luk55qE56ys5LiA5LiqIHBvaW50XG4gICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgIC8vIOesrOS4gOS4quWRveS7pOS4uiBBcmMg55qE5oOF5Ya15LiL5Lya5Zyo5ZCO6Z2i54m55q6K5aSE55CGXG4gICAgICAgICAgICAgICAgICAgIHhpID0gZGF0YVtpXTtcbiAgICAgICAgICAgICAgICAgICAgeWkgPSBkYXRhW2kgKyAxXTtcblxuICAgICAgICAgICAgICAgICAgICB4MCA9IHhpO1xuICAgICAgICAgICAgICAgICAgICB5MCA9IHlpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHN3aXRjaCAoY21kKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgQ01ELk06XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBtb3ZlVG8g5ZG95Luk6YeN5paw5Yib5bu65LiA5Liq5paw55qEIHN1YnBhdGgsIOW5tuS4lOabtOaWsOaWsOeahOi1t+eCuVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8g5ZyoIGNsb3NlUGF0aCDnmoTml7blgJnkvb/nlKhcbiAgICAgICAgICAgICAgICAgICAgICAgIHgwID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgeTAgPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgICAgICB4aSA9IHgwO1xuICAgICAgICAgICAgICAgICAgICAgICAgeWkgPSB5MDtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbjJbMF0gPSB4MDtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbjJbMV0gPSB5MDtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heDJbMF0gPSB4MDtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heDJbMV0gPSB5MDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIENNRC5MOlxuICAgICAgICAgICAgICAgICAgICAgICAgYmJveC5mcm9tTGluZSh4aSwgeWksIGRhdGFbaV0sIGRhdGFbaSArIDFdLCBtaW4yLCBtYXgyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHhpID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgeWkgPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBDTUQuQzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGJib3guZnJvbUN1YmljKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhpLCB5aSwgZGF0YVtpKytdLCBkYXRhW2krK10sIGRhdGFbaSsrXSwgZGF0YVtpKytdLCBkYXRhW2ldLCBkYXRhW2kgKyAxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaW4yLCBtYXgyXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgeGkgPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgICAgICB5aSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIENNRC5ROlxuICAgICAgICAgICAgICAgICAgICAgICAgYmJveC5mcm9tUXVhZHJhdGljKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhpLCB5aSwgZGF0YVtpKytdLCBkYXRhW2krK10sIGRhdGFbaV0sIGRhdGFbaSArIDFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pbjIsIG1heDJcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB4aSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHlpID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgQ01ELkE6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPIEFyYyDliKTmlq3nmoTlvIDplIDmr5TovoPlpKdcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjeCA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjeSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByeCA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByeSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdGFydEFuZ2xlID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVuZEFuZ2xlID0gZGF0YVtpKytdICsgc3RhcnRBbmdsZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gQXJjIOaXi+i9rFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBzaSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhbnRpY2xvY2t3aXNlID0gMSAtIGRhdGFbaSsrXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkgPT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIOebtOaOpeS9v+eUqCBhcmMg5ZG95LukXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8g56ys5LiA5Liq5ZG95Luk6LW354K56L+Y5pyq5a6a5LmJXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeDAgPSBtYXRoQ29zKHN0YXJ0QW5nbGUpICogcnggKyBjeDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5MCA9IG1hdGhTaW4oc3RhcnRBbmdsZSkgKiByeSArIGN5O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBiYm94LmZyb21BcmMoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3gsIGN5LCByeCwgcnksIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFudGljbG9ja3dpc2UsIG1pbjIsIG1heDJcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHhpID0gbWF0aENvcyhlbmRBbmdsZSkgKiByeCArIGN4O1xuICAgICAgICAgICAgICAgICAgICAgICAgeWkgPSBtYXRoU2luKGVuZEFuZ2xlKSAqIHJ5ICsgY3k7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBDTUQuUjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHgwID0geGkgPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgICAgICB5MCA9IHlpID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHdpZHRoID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGhlaWdodCA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVzZSBmcm9tTGluZVxuICAgICAgICAgICAgICAgICAgICAgICAgYmJveC5mcm9tTGluZSh4MCwgeTAsIHgwICsgd2lkdGgsIHkwICsgaGVpZ2h0LCBtaW4yLCBtYXgyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIENNRC5aOlxuICAgICAgICAgICAgICAgICAgICAgICAgeGkgPSB4MDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHlpID0geTA7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBVbmlvblxuICAgICAgICAgICAgICAgIHZlYzIubWluKG1pbiwgbWluLCBtaW4yKTtcbiAgICAgICAgICAgICAgICB2ZWMyLm1heChtYXgsIG1heCwgbWF4Mik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIE5vIGRhdGFcbiAgICAgICAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgbWluWzBdID0gbWluWzFdID0gbWF4WzBdID0gbWF4WzFdID0gMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG5ldyBCb3VuZGluZ1JlY3QoXG4gICAgICAgICAgICAgICAgbWluWzBdLCBtaW5bMV0sIG1heFswXSAtIG1pblswXSwgbWF4WzFdIC0gbWluWzFdXG4gICAgICAgICAgICApO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZWJ1aWxkIHBhdGggZnJvbSBjdXJyZW50IGRhdGFcbiAgICAgICAgICogUmVidWlsZCBwYXRoIHdpbGwgbm90IGNvbnNpZGVyIGphdmFzY3JpcHQgaW1wbGVtZW50ZWQgbGluZSBkYXNoLlxuICAgICAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHR9IGN0eFxuICAgICAgICAgKi9cbiAgICAgICAgcmVidWlsZFBhdGg6IGZ1bmN0aW9uIChjdHgpIHtcbiAgICAgICAgICAgIHZhciBkID0gdGhpcy5kYXRhO1xuICAgICAgICAgICAgdmFyIHgwLCB5MDtcbiAgICAgICAgICAgIHZhciB4aSwgeWk7XG4gICAgICAgICAgICB2YXIgeCwgeTtcbiAgICAgICAgICAgIHZhciB1eCA9IHRoaXMuX3V4O1xuICAgICAgICAgICAgdmFyIHV5ID0gdGhpcy5fdXk7XG4gICAgICAgICAgICB2YXIgbGVuID0gdGhpcy5fbGVuO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47KSB7XG4gICAgICAgICAgICAgICAgdmFyIGNtZCA9IGRbaSsrXTtcblxuICAgICAgICAgICAgICAgIGlmIChpID09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8g5aaC5p6c56ys5LiA5Liq5ZG95Luk5pivIEwsIEMsIFFcbiAgICAgICAgICAgICAgICAgICAgLy8g5YiZIHByZXZpb3VzIHBvaW50IOWQjOe7mOWItuWRveS7pOeahOesrOS4gOS4qiBwb2ludFxuICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAvLyDnrKzkuIDkuKrlkb3ku6TkuLogQXJjIOeahOaDheWGteS4i+S8muWcqOWQjumdoueJueauiuWkhOeQhlxuICAgICAgICAgICAgICAgICAgICB4aSA9IGRbaV07XG4gICAgICAgICAgICAgICAgICAgIHlpID0gZFtpICsgMV07XG5cbiAgICAgICAgICAgICAgICAgICAgeDAgPSB4aTtcbiAgICAgICAgICAgICAgICAgICAgeTAgPSB5aTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3dpdGNoIChjbWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBDTUQuTTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHgwID0geGkgPSBkW2krK107XG4gICAgICAgICAgICAgICAgICAgICAgICB5MCA9IHlpID0gZFtpKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4Lm1vdmVUbyh4aSwgeWkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgQ01ELkw6XG4gICAgICAgICAgICAgICAgICAgICAgICB4ID0gZFtpKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgeSA9IGRbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vdCBkcmF3IHRvbyBzbWFsbCBzZWcgYmV0d2VlblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGhBYnMoeCAtIHhpKSA+IHV4IHx8IG1hdGhBYnMoeSAtIHlpKSA+IHV5IHx8IGkgPT09IGxlbiAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHgubGluZVRvKHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhpID0geDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5aSA9IHk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBDTUQuQzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRbaSsrXSwgZFtpKytdLCBkW2krK10sIGRbaSsrXSwgZFtpKytdLCBkW2krK11cbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB4aSA9IGRbaSAtIDJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgeWkgPSBkW2kgLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIENNRC5ROlxuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnF1YWRyYXRpY0N1cnZlVG8oZFtpKytdLCBkW2krK10sIGRbaSsrXSwgZFtpKytdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHhpID0gZFtpIC0gMl07XG4gICAgICAgICAgICAgICAgICAgICAgICB5aSA9IGRbaSAtIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgQ01ELkE6XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3ggPSBkW2krK107XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3kgPSBkW2krK107XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcnggPSBkW2krK107XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcnkgPSBkW2krK107XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGhldGEgPSBkW2krK107XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZFRoZXRhID0gZFtpKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBzaSA9IGRbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmcyA9IGRbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByID0gKHJ4ID4gcnkpID8gcnggOiByeTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzY2FsZVggPSAocnggPiByeSkgPyAxIDogcnggLyByeTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzY2FsZVkgPSAocnggPiByeSkgPyByeSAvIHJ4IDogMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpc0VsbGlwc2UgPSBNYXRoLmFicyhyeCAtIHJ5KSA+IDFlLTM7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZW5kQW5nbGUgPSB0aGV0YSArIGRUaGV0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0VsbGlwc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHgudHJhbnNsYXRlKGN4LCBjeSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnJvdGF0ZShwc2kpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5zY2FsZShzY2FsZVgsIHNjYWxlWSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmFyYygwLCAwLCByLCB0aGV0YSwgZW5kQW5nbGUsIDEgLSBmcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnNjYWxlKDEgLyBzY2FsZVgsIDEgLyBzY2FsZVkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5yb3RhdGUoLXBzaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZSgtY3gsIC1jeSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHguYXJjKGN4LCBjeSwgciwgdGhldGEsIGVuZEFuZ2xlLCAxIC0gZnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaSA9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8g55u05o6l5L2/55SoIGFyYyDlkb3ku6RcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyDnrKzkuIDkuKrlkb3ku6Totbfngrnov5jmnKrlrprkuYlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4MCA9IG1hdGhDb3ModGhldGEpICogcnggKyBjeDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5MCA9IG1hdGhTaW4odGhldGEpICogcnkgKyBjeTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHhpID0gbWF0aENvcyhlbmRBbmdsZSkgKiByeCArIGN4O1xuICAgICAgICAgICAgICAgICAgICAgICAgeWkgPSBtYXRoU2luKGVuZEFuZ2xlKSAqIHJ5ICsgY3k7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBDTUQuUjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHgwID0geGkgPSBkW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgeTAgPSB5aSA9IGRbaSArIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnJlY3QoZFtpKytdLCBkW2krK10sIGRbaSsrXSwgZFtpKytdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIENNRC5aOlxuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgeGkgPSB4MDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHlpID0geTA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIFBhdGhQcm94eS5DTUQgPSBDTUQ7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IFBhdGhQcm94eTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3pyZW5kZXIvbGliL2NvcmUvUGF0aFByb3h5LmpzXG4gKiogbW9kdWxlIGlkID0gMjVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0Jztcbi8qKlxuICog5puy57q/6L6F5Yqp5qih5Z2XXG4gKiBAbW9kdWxlIHpyZW5kZXIvY29yZS9jdXJ2ZVxuICogQGF1dGhvciBwaXNzYW5nKGh0dHBzOi8vd3d3LmdpdGh1Yi5jb20vcGlzc2FuZylcbiAqL1xuXG5cbiAgICB2YXIgdmVjMiA9IHJlcXVpcmUoJy4vdmVjdG9yJyk7XG4gICAgdmFyIHYyQ3JlYXRlID0gdmVjMi5jcmVhdGU7XG4gICAgdmFyIHYyRGlzdFNxdWFyZSA9IHZlYzIuZGlzdFNxdWFyZTtcbiAgICB2YXIgbWF0aFBvdyA9IE1hdGgucG93O1xuICAgIHZhciBtYXRoU3FydCA9IE1hdGguc3FydDtcblxuICAgIHZhciBFUFNJTE9OID0gMWUtODtcbiAgICB2YXIgRVBTSUxPTl9OVU1FUklDID0gMWUtNDtcblxuICAgIHZhciBUSFJFRV9TUVJUID0gbWF0aFNxcnQoMyk7XG4gICAgdmFyIE9ORV9USElSRCA9IDEgLyAzO1xuXG4gICAgLy8g5Li05pe25Y+Y6YePXG4gICAgdmFyIF92MCA9IHYyQ3JlYXRlKCk7XG4gICAgdmFyIF92MSA9IHYyQ3JlYXRlKCk7XG4gICAgdmFyIF92MiA9IHYyQ3JlYXRlKCk7XG4gICAgLy8gdmFyIF92MyA9IHZlYzIuY3JlYXRlKCk7XG5cbiAgICBmdW5jdGlvbiBpc0Fyb3VuZFplcm8odmFsKSB7XG4gICAgICAgIHJldHVybiB2YWwgPiAtRVBTSUxPTiAmJiB2YWwgPCBFUFNJTE9OO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpc05vdEFyb3VuZFplcm8odmFsKSB7XG4gICAgICAgIHJldHVybiB2YWwgPiBFUFNJTE9OIHx8IHZhbCA8IC1FUFNJTE9OO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiDorqHnrpfkuInmrKHotJ3loZ7lsJTlgLxcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS9jdXJ2ZVxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcDBcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHAxXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBwMlxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcDNcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHRcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICovXG4gICAgZnVuY3Rpb24gY3ViaWNBdChwMCwgcDEsIHAyLCBwMywgdCkge1xuICAgICAgICB2YXIgb25ldCA9IDEgLSB0O1xuICAgICAgICByZXR1cm4gb25ldCAqIG9uZXQgKiAob25ldCAqIHAwICsgMyAqIHQgKiBwMSlcbiAgICAgICAgICAgICArIHQgKiB0ICogKHQgKiBwMyArIDMgKiBvbmV0ICogcDIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOiuoeeul+S4ieasoei0neWhnuWwlOWvvOaVsOWAvFxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL2N1cnZlXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBwMFxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcDFcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHAyXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBwM1xuICAgICAqIEBwYXJhbSAge251bWJlcn0gdFxuICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjdWJpY0Rlcml2YXRpdmVBdChwMCwgcDEsIHAyLCBwMywgdCkge1xuICAgICAgICB2YXIgb25ldCA9IDEgLSB0O1xuICAgICAgICByZXR1cm4gMyAqIChcbiAgICAgICAgICAgICgocDEgLSBwMCkgKiBvbmV0ICsgMiAqIChwMiAtIHAxKSAqIHQpICogb25ldFxuICAgICAgICAgICAgKyAocDMgLSBwMikgKiB0ICogdFxuICAgICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOiuoeeul+S4ieasoei0neWhnuWwlOaWueeoi+ague+8jOS9v+eUqOebm+mHkeWFrOW8j1xuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL2N1cnZlXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBwMFxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcDFcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHAyXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBwM1xuICAgICAqIEBwYXJhbSAge251bWJlcn0gdmFsXG4gICAgICogQHBhcmFtICB7QXJyYXkuPG51bWJlcj59IHJvb3RzXG4gICAgICogQHJldHVybiB7bnVtYmVyfSDmnInmlYjmoLnmlbDnm65cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjdWJpY1Jvb3RBdChwMCwgcDEsIHAyLCBwMywgdmFsLCByb290cykge1xuICAgICAgICAvLyBFdmFsdWF0ZSByb290cyBvZiBjdWJpYyBmdW5jdGlvbnNcbiAgICAgICAgdmFyIGEgPSBwMyArIDMgKiAocDEgLSBwMikgLSBwMDtcbiAgICAgICAgdmFyIGIgPSAzICogKHAyIC0gcDEgKiAyICsgcDApO1xuICAgICAgICB2YXIgYyA9IDMgKiAocDEgIC0gcDApO1xuICAgICAgICB2YXIgZCA9IHAwIC0gdmFsO1xuXG4gICAgICAgIHZhciBBID0gYiAqIGIgLSAzICogYSAqIGM7XG4gICAgICAgIHZhciBCID0gYiAqIGMgLSA5ICogYSAqIGQ7XG4gICAgICAgIHZhciBDID0gYyAqIGMgLSAzICogYiAqIGQ7XG5cbiAgICAgICAgdmFyIG4gPSAwO1xuXG4gICAgICAgIGlmIChpc0Fyb3VuZFplcm8oQSkgJiYgaXNBcm91bmRaZXJvKEIpKSB7XG4gICAgICAgICAgICBpZiAoaXNBcm91bmRaZXJvKGIpKSB7XG4gICAgICAgICAgICAgICAgcm9vdHNbMF0gPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIHQxID0gLWMgLyBiOyAgLy90MSwgdDIsIHQzLCBiIGlzIG5vdCB6ZXJvXG4gICAgICAgICAgICAgICAgaWYgKHQxID49IDAgJiYgdDEgPD0gMSkge1xuICAgICAgICAgICAgICAgICAgICByb290c1tuKytdID0gdDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGRpc2MgPSBCICogQiAtIDQgKiBBICogQztcblxuICAgICAgICAgICAgaWYgKGlzQXJvdW5kWmVybyhkaXNjKSkge1xuICAgICAgICAgICAgICAgIHZhciBLID0gQiAvIEE7XG4gICAgICAgICAgICAgICAgdmFyIHQxID0gLWIgLyBhICsgSzsgIC8vIHQxLCBhIGlzIG5vdCB6ZXJvXG4gICAgICAgICAgICAgICAgdmFyIHQyID0gLUsgLyAyOyAgLy8gdDIsIHQzXG4gICAgICAgICAgICAgICAgaWYgKHQxID49IDAgJiYgdDEgPD0gMSkge1xuICAgICAgICAgICAgICAgICAgICByb290c1tuKytdID0gdDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0MiA+PSAwICYmIHQyIDw9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcm9vdHNbbisrXSA9IHQyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGRpc2MgPiAwKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRpc2NTcXJ0ID0gbWF0aFNxcnQoZGlzYyk7XG4gICAgICAgICAgICAgICAgdmFyIFkxID0gQSAqIGIgKyAxLjUgKiBhICogKC1CICsgZGlzY1NxcnQpO1xuICAgICAgICAgICAgICAgIHZhciBZMiA9IEEgKiBiICsgMS41ICogYSAqICgtQiAtIGRpc2NTcXJ0KTtcbiAgICAgICAgICAgICAgICBpZiAoWTEgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIFkxID0gLW1hdGhQb3coLVkxLCBPTkVfVEhJUkQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgWTEgPSBtYXRoUG93KFkxLCBPTkVfVEhJUkQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoWTIgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIFkyID0gLW1hdGhQb3coLVkyLCBPTkVfVEhJUkQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgWTIgPSBtYXRoUG93KFkyLCBPTkVfVEhJUkQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgdDEgPSAoLWIgLSAoWTEgKyBZMikpIC8gKDMgKiBhKTtcbiAgICAgICAgICAgICAgICBpZiAodDEgPj0gMCAmJiB0MSA8PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvb3RzW24rK10gPSB0MTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgVCA9ICgyICogQSAqIGIgLSAzICogYSAqIEIpIC8gKDIgKiBtYXRoU3FydChBICogQSAqIEEpKTtcbiAgICAgICAgICAgICAgICB2YXIgdGhldGEgPSBNYXRoLmFjb3MoVCkgLyAzO1xuICAgICAgICAgICAgICAgIHZhciBBU3FydCA9IG1hdGhTcXJ0KEEpO1xuICAgICAgICAgICAgICAgIHZhciB0bXAgPSBNYXRoLmNvcyh0aGV0YSk7XG5cbiAgICAgICAgICAgICAgICB2YXIgdDEgPSAoLWIgLSAyICogQVNxcnQgKiB0bXApIC8gKDMgKiBhKTtcbiAgICAgICAgICAgICAgICB2YXIgdDIgPSAoLWIgKyBBU3FydCAqICh0bXAgKyBUSFJFRV9TUVJUICogTWF0aC5zaW4odGhldGEpKSkgLyAoMyAqIGEpO1xuICAgICAgICAgICAgICAgIHZhciB0MyA9ICgtYiArIEFTcXJ0ICogKHRtcCAtIFRIUkVFX1NRUlQgKiBNYXRoLnNpbih0aGV0YSkpKSAvICgzICogYSk7XG4gICAgICAgICAgICAgICAgaWYgKHQxID49IDAgJiYgdDEgPD0gMSkge1xuICAgICAgICAgICAgICAgICAgICByb290c1tuKytdID0gdDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0MiA+PSAwICYmIHQyIDw9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcm9vdHNbbisrXSA9IHQyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodDMgPj0gMCAmJiB0MyA8PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvb3RzW24rK10gPSB0MztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG47XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog6K6h566X5LiJ5qyh6LSd5aGe5bCU5pa556iL5p6B6ZmQ5YC855qE5L2N572uXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvY3VydmVcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHAwXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBwMVxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcDJcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHAzXG4gICAgICogQHBhcmFtICB7QXJyYXkuPG51bWJlcj59IGV4dHJlbWFcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IOacieaViOaVsOebrlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGN1YmljRXh0cmVtYShwMCwgcDEsIHAyLCBwMywgZXh0cmVtYSkge1xuICAgICAgICB2YXIgYiA9IDYgKiBwMiAtIDEyICogcDEgKyA2ICogcDA7XG4gICAgICAgIHZhciBhID0gOSAqIHAxICsgMyAqIHAzIC0gMyAqIHAwIC0gOSAqIHAyO1xuICAgICAgICB2YXIgYyA9IDMgKiBwMSAtIDMgKiBwMDtcblxuICAgICAgICB2YXIgbiA9IDA7XG4gICAgICAgIGlmIChpc0Fyb3VuZFplcm8oYSkpIHtcbiAgICAgICAgICAgIGlmIChpc05vdEFyb3VuZFplcm8oYikpIHtcbiAgICAgICAgICAgICAgICB2YXIgdDEgPSAtYyAvIGI7XG4gICAgICAgICAgICAgICAgaWYgKHQxID49IDAgJiYgdDEgPD0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4dHJlbWFbbisrXSA9IHQxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBkaXNjID0gYiAqIGIgLSA0ICogYSAqIGM7XG4gICAgICAgICAgICBpZiAoaXNBcm91bmRaZXJvKGRpc2MpKSB7XG4gICAgICAgICAgICAgICAgZXh0cmVtYVswXSA9IC1iIC8gKDIgKiBhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGRpc2MgPiAwKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRpc2NTcXJ0ID0gbWF0aFNxcnQoZGlzYyk7XG4gICAgICAgICAgICAgICAgdmFyIHQxID0gKC1iICsgZGlzY1NxcnQpIC8gKDIgKiBhKTtcbiAgICAgICAgICAgICAgICB2YXIgdDIgPSAoLWIgLSBkaXNjU3FydCkgLyAoMiAqIGEpO1xuICAgICAgICAgICAgICAgIGlmICh0MSA+PSAwICYmIHQxIDw9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgZXh0cmVtYVtuKytdID0gdDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0MiA+PSAwICYmIHQyIDw9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgZXh0cmVtYVtuKytdID0gdDI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOe7huWIhuS4ieasoei0neWhnuWwlOabsue6v1xuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL2N1cnZlXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBwMFxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcDFcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHAyXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBwM1xuICAgICAqIEBwYXJhbSAge251bWJlcn0gdFxuICAgICAqIEBwYXJhbSAge0FycmF5LjxudW1iZXI+fSBvdXRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjdWJpY1N1YmRpdmlkZShwMCwgcDEsIHAyLCBwMywgdCwgb3V0KSB7XG4gICAgICAgIHZhciBwMDEgPSAocDEgLSBwMCkgKiB0ICsgcDA7XG4gICAgICAgIHZhciBwMTIgPSAocDIgLSBwMSkgKiB0ICsgcDE7XG4gICAgICAgIHZhciBwMjMgPSAocDMgLSBwMikgKiB0ICsgcDI7XG5cbiAgICAgICAgdmFyIHAwMTIgPSAocDEyIC0gcDAxKSAqIHQgKyBwMDE7XG4gICAgICAgIHZhciBwMTIzID0gKHAyMyAtIHAxMikgKiB0ICsgcDEyO1xuXG4gICAgICAgIHZhciBwMDEyMyA9IChwMTIzIC0gcDAxMikgKiB0ICsgcDAxMjtcbiAgICAgICAgLy8gU2VnMFxuICAgICAgICBvdXRbMF0gPSBwMDtcbiAgICAgICAgb3V0WzFdID0gcDAxO1xuICAgICAgICBvdXRbMl0gPSBwMDEyO1xuICAgICAgICBvdXRbM10gPSBwMDEyMztcbiAgICAgICAgLy8gU2VnMVxuICAgICAgICBvdXRbNF0gPSBwMDEyMztcbiAgICAgICAgb3V0WzVdID0gcDEyMztcbiAgICAgICAgb3V0WzZdID0gcDIzO1xuICAgICAgICBvdXRbN10gPSBwMztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDmipXlsITngrnliLDkuInmrKHotJ3loZ7lsJTmm7Lnur/kuIrvvIzov5Tlm57mipXlsITot53nprvjgIJcbiAgICAgKiDmipXlsITngrnmnInlj6/og73kvJrmnInkuIDkuKrmiJbogIXlpJrkuKrvvIzov5nph4zlj6rov5Tlm57lhbbkuK3ot53nprvmnIDnn63nmoTkuIDkuKrjgIJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geDBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geTBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geDFcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geTFcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geDJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geTJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geDNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geTNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gW291dF0g5oqV5bCE54K5XG4gICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGN1YmljUHJvamVjdFBvaW50KFxuICAgICAgICB4MCwgeTAsIHgxLCB5MSwgeDIsIHkyLCB4MywgeTMsXG4gICAgICAgIHgsIHksIG91dFxuICAgICkge1xuICAgICAgICAvLyBodHRwOi8vcG9tYXguZ2l0aHViLmlvL2JlemllcmluZm8vI3Byb2plY3Rpb25zXG4gICAgICAgIHZhciB0O1xuICAgICAgICB2YXIgaW50ZXJ2YWwgPSAwLjAwNTtcbiAgICAgICAgdmFyIGQgPSBJbmZpbml0eTtcbiAgICAgICAgdmFyIHByZXY7XG4gICAgICAgIHZhciBuZXh0O1xuICAgICAgICB2YXIgZDE7XG4gICAgICAgIHZhciBkMjtcblxuICAgICAgICBfdjBbMF0gPSB4O1xuICAgICAgICBfdjBbMV0gPSB5O1xuXG4gICAgICAgIC8vIOWFiOeyl+eVpeS8sOiuoeS4gOS4i+WPr+iDveeahOacgOWwj+i3neemu+eahCB0IOWAvFxuICAgICAgICAvLyBQRU5ESU5HXG4gICAgICAgIGZvciAodmFyIF90ID0gMDsgX3QgPCAxOyBfdCArPSAwLjA1KSB7XG4gICAgICAgICAgICBfdjFbMF0gPSBjdWJpY0F0KHgwLCB4MSwgeDIsIHgzLCBfdCk7XG4gICAgICAgICAgICBfdjFbMV0gPSBjdWJpY0F0KHkwLCB5MSwgeTIsIHkzLCBfdCk7XG4gICAgICAgICAgICBkMSA9IHYyRGlzdFNxdWFyZShfdjAsIF92MSk7XG4gICAgICAgICAgICBpZiAoZDEgPCBkKSB7XG4gICAgICAgICAgICAgICAgdCA9IF90O1xuICAgICAgICAgICAgICAgIGQgPSBkMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBkID0gSW5maW5pdHk7XG5cbiAgICAgICAgLy8gQXQgbW9zdCAzMiBpdGVyYXRpb25cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAzMjsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoaW50ZXJ2YWwgPCBFUFNJTE9OX05VTUVSSUMpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByZXYgPSB0IC0gaW50ZXJ2YWw7XG4gICAgICAgICAgICBuZXh0ID0gdCArIGludGVydmFsO1xuICAgICAgICAgICAgLy8gdCAtIGludGVydmFsXG4gICAgICAgICAgICBfdjFbMF0gPSBjdWJpY0F0KHgwLCB4MSwgeDIsIHgzLCBwcmV2KTtcbiAgICAgICAgICAgIF92MVsxXSA9IGN1YmljQXQoeTAsIHkxLCB5MiwgeTMsIHByZXYpO1xuXG4gICAgICAgICAgICBkMSA9IHYyRGlzdFNxdWFyZShfdjEsIF92MCk7XG5cbiAgICAgICAgICAgIGlmIChwcmV2ID49IDAgJiYgZDEgPCBkKSB7XG4gICAgICAgICAgICAgICAgdCA9IHByZXY7XG4gICAgICAgICAgICAgICAgZCA9IGQxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gdCArIGludGVydmFsXG4gICAgICAgICAgICAgICAgX3YyWzBdID0gY3ViaWNBdCh4MCwgeDEsIHgyLCB4MywgbmV4dCk7XG4gICAgICAgICAgICAgICAgX3YyWzFdID0gY3ViaWNBdCh5MCwgeTEsIHkyLCB5MywgbmV4dCk7XG4gICAgICAgICAgICAgICAgZDIgPSB2MkRpc3RTcXVhcmUoX3YyLCBfdjApO1xuXG4gICAgICAgICAgICAgICAgaWYgKG5leHQgPD0gMSAmJiBkMiA8IGQpIHtcbiAgICAgICAgICAgICAgICAgICAgdCA9IG5leHQ7XG4gICAgICAgICAgICAgICAgICAgIGQgPSBkMjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGludGVydmFsICo9IDAuNTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gdFxuICAgICAgICBpZiAob3V0KSB7XG4gICAgICAgICAgICBvdXRbMF0gPSBjdWJpY0F0KHgwLCB4MSwgeDIsIHgzLCB0KTtcbiAgICAgICAgICAgIG91dFsxXSA9IGN1YmljQXQoeTAsIHkxLCB5MiwgeTMsIHQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKGludGVydmFsLCBpKTtcbiAgICAgICAgcmV0dXJuIG1hdGhTcXJ0KGQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOiuoeeul+S6jOasoeaWuei0neWhnuWwlOWAvFxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcDBcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHAxXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBwMlxuICAgICAqIEBwYXJhbSAge251bWJlcn0gdFxuICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBxdWFkcmF0aWNBdChwMCwgcDEsIHAyLCB0KSB7XG4gICAgICAgIHZhciBvbmV0ID0gMSAtIHQ7XG4gICAgICAgIHJldHVybiBvbmV0ICogKG9uZXQgKiBwMCArIDIgKiB0ICogcDEpICsgdCAqIHQgKiBwMjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDorqHnrpfkuozmrKHmlrnotJ3loZ7lsJTlr7zmlbDlgLxcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHAwXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBwMVxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcDJcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHRcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICovXG4gICAgZnVuY3Rpb24gcXVhZHJhdGljRGVyaXZhdGl2ZUF0KHAwLCBwMSwgcDIsIHQpIHtcbiAgICAgICAgcmV0dXJuIDIgKiAoKDEgLSB0KSAqIChwMSAtIHAwKSArIHQgKiAocDIgLSBwMSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOiuoeeul+S6jOasoeaWuei0neWhnuWwlOaWueeoi+aguVxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcDBcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHAxXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBwMlxuICAgICAqIEBwYXJhbSAge251bWJlcn0gdFxuICAgICAqIEBwYXJhbSAge0FycmF5LjxudW1iZXI+fSByb290c1xuICAgICAqIEByZXR1cm4ge251bWJlcn0g5pyJ5pWI5qC55pWw55uuXG4gICAgICovXG4gICAgZnVuY3Rpb24gcXVhZHJhdGljUm9vdEF0KHAwLCBwMSwgcDIsIHZhbCwgcm9vdHMpIHtcbiAgICAgICAgdmFyIGEgPSBwMCAtIDIgKiBwMSArIHAyO1xuICAgICAgICB2YXIgYiA9IDIgKiAocDEgLSBwMCk7XG4gICAgICAgIHZhciBjID0gcDAgLSB2YWw7XG5cbiAgICAgICAgdmFyIG4gPSAwO1xuICAgICAgICBpZiAoaXNBcm91bmRaZXJvKGEpKSB7XG4gICAgICAgICAgICBpZiAoaXNOb3RBcm91bmRaZXJvKGIpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHQxID0gLWMgLyBiO1xuICAgICAgICAgICAgICAgIGlmICh0MSA+PSAwICYmIHQxIDw9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcm9vdHNbbisrXSA9IHQxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBkaXNjID0gYiAqIGIgLSA0ICogYSAqIGM7XG4gICAgICAgICAgICBpZiAoaXNBcm91bmRaZXJvKGRpc2MpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHQxID0gLWIgLyAoMiAqIGEpO1xuICAgICAgICAgICAgICAgIGlmICh0MSA+PSAwICYmIHQxIDw9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcm9vdHNbbisrXSA9IHQxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGRpc2MgPiAwKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRpc2NTcXJ0ID0gbWF0aFNxcnQoZGlzYyk7XG4gICAgICAgICAgICAgICAgdmFyIHQxID0gKC1iICsgZGlzY1NxcnQpIC8gKDIgKiBhKTtcbiAgICAgICAgICAgICAgICB2YXIgdDIgPSAoLWIgLSBkaXNjU3FydCkgLyAoMiAqIGEpO1xuICAgICAgICAgICAgICAgIGlmICh0MSA+PSAwICYmIHQxIDw9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcm9vdHNbbisrXSA9IHQxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodDIgPj0gMCAmJiB0MiA8PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvb3RzW24rK10gPSB0MjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG47XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog6K6h566X5LqM5qyh6LSd5aGe5bCU5pa556iL5p6B6ZmQ5YC8XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvY3VydmVcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHAwXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBwMVxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcDJcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICovXG4gICAgZnVuY3Rpb24gcXVhZHJhdGljRXh0cmVtdW0ocDAsIHAxLCBwMikge1xuICAgICAgICB2YXIgZGl2aWRlciA9IHAwICsgcDIgLSAyICogcDE7XG4gICAgICAgIGlmIChkaXZpZGVyID09PSAwKSB7XG4gICAgICAgICAgICAvLyBwMSBpcyBjZW50ZXIgb2YgcDAgYW5kIHAyXG4gICAgICAgICAgICByZXR1cm4gMC41O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIChwMCAtIHAxKSAvIGRpdmlkZXI7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDnu4bliIbkuozmrKHotJ3loZ7lsJTmm7Lnur9cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS9jdXJ2ZVxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcDBcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHAxXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBwMlxuICAgICAqIEBwYXJhbSAge251bWJlcn0gdFxuICAgICAqIEBwYXJhbSAge0FycmF5LjxudW1iZXI+fSBvdXRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBxdWFkcmF0aWNTdWJkaXZpZGUocDAsIHAxLCBwMiwgdCwgb3V0KSB7XG4gICAgICAgIHZhciBwMDEgPSAocDEgLSBwMCkgKiB0ICsgcDA7XG4gICAgICAgIHZhciBwMTIgPSAocDIgLSBwMSkgKiB0ICsgcDE7XG4gICAgICAgIHZhciBwMDEyID0gKHAxMiAtIHAwMSkgKiB0ICsgcDAxO1xuXG4gICAgICAgIC8vIFNlZzBcbiAgICAgICAgb3V0WzBdID0gcDA7XG4gICAgICAgIG91dFsxXSA9IHAwMTtcbiAgICAgICAgb3V0WzJdID0gcDAxMjtcblxuICAgICAgICAvLyBTZWcxXG4gICAgICAgIG91dFszXSA9IHAwMTI7XG4gICAgICAgIG91dFs0XSA9IHAxMjtcbiAgICAgICAgb3V0WzVdID0gcDI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog5oqV5bCE54K55Yiw5LqM5qyh6LSd5aGe5bCU5puy57q/5LiK77yM6L+U5Zue5oqV5bCE6Led56a744CCXG4gICAgICog5oqV5bCE54K55pyJ5Y+v6IO95Lya5pyJ5LiA5Liq5oiW6ICF5aSa5Liq77yM6L+Z6YeM5Y+q6L+U5Zue5YW25Lit6Led56a75pyA55+t55qE5LiA5Liq44CCXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHgwXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkwXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHgxXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkxXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHgyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geVxuICAgICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IG91dCDmipXlsITngrlcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICovXG4gICAgZnVuY3Rpb24gcXVhZHJhdGljUHJvamVjdFBvaW50KFxuICAgICAgICB4MCwgeTAsIHgxLCB5MSwgeDIsIHkyLFxuICAgICAgICB4LCB5LCBvdXRcbiAgICApIHtcbiAgICAgICAgLy8gaHR0cDovL3BvbWF4LmdpdGh1Yi5pby9iZXppZXJpbmZvLyNwcm9qZWN0aW9uc1xuICAgICAgICB2YXIgdDtcbiAgICAgICAgdmFyIGludGVydmFsID0gMC4wMDU7XG4gICAgICAgIHZhciBkID0gSW5maW5pdHk7XG5cbiAgICAgICAgX3YwWzBdID0geDtcbiAgICAgICAgX3YwWzFdID0geTtcblxuICAgICAgICAvLyDlhYjnspfnlaXkvLDorqHkuIDkuIvlj6/og73nmoTmnIDlsI/ot53nprvnmoQgdCDlgLxcbiAgICAgICAgLy8gUEVORElOR1xuICAgICAgICBmb3IgKHZhciBfdCA9IDA7IF90IDwgMTsgX3QgKz0gMC4wNSkge1xuICAgICAgICAgICAgX3YxWzBdID0gcXVhZHJhdGljQXQoeDAsIHgxLCB4MiwgX3QpO1xuICAgICAgICAgICAgX3YxWzFdID0gcXVhZHJhdGljQXQoeTAsIHkxLCB5MiwgX3QpO1xuICAgICAgICAgICAgdmFyIGQxID0gdjJEaXN0U3F1YXJlKF92MCwgX3YxKTtcbiAgICAgICAgICAgIGlmIChkMSA8IGQpIHtcbiAgICAgICAgICAgICAgICB0ID0gX3Q7XG4gICAgICAgICAgICAgICAgZCA9IGQxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGQgPSBJbmZpbml0eTtcblxuICAgICAgICAvLyBBdCBtb3N0IDMyIGl0ZXJhdGlvblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDMyOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChpbnRlcnZhbCA8IEVQU0lMT05fTlVNRVJJQykge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHByZXYgPSB0IC0gaW50ZXJ2YWw7XG4gICAgICAgICAgICB2YXIgbmV4dCA9IHQgKyBpbnRlcnZhbDtcbiAgICAgICAgICAgIC8vIHQgLSBpbnRlcnZhbFxuICAgICAgICAgICAgX3YxWzBdID0gcXVhZHJhdGljQXQoeDAsIHgxLCB4MiwgcHJldik7XG4gICAgICAgICAgICBfdjFbMV0gPSBxdWFkcmF0aWNBdCh5MCwgeTEsIHkyLCBwcmV2KTtcblxuICAgICAgICAgICAgdmFyIGQxID0gdjJEaXN0U3F1YXJlKF92MSwgX3YwKTtcblxuICAgICAgICAgICAgaWYgKHByZXYgPj0gMCAmJiBkMSA8IGQpIHtcbiAgICAgICAgICAgICAgICB0ID0gcHJldjtcbiAgICAgICAgICAgICAgICBkID0gZDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyB0ICsgaW50ZXJ2YWxcbiAgICAgICAgICAgICAgICBfdjJbMF0gPSBxdWFkcmF0aWNBdCh4MCwgeDEsIHgyLCBuZXh0KTtcbiAgICAgICAgICAgICAgICBfdjJbMV0gPSBxdWFkcmF0aWNBdCh5MCwgeTEsIHkyLCBuZXh0KTtcbiAgICAgICAgICAgICAgICB2YXIgZDIgPSB2MkRpc3RTcXVhcmUoX3YyLCBfdjApO1xuICAgICAgICAgICAgICAgIGlmIChuZXh0IDw9IDEgJiYgZDIgPCBkKSB7XG4gICAgICAgICAgICAgICAgICAgIHQgPSBuZXh0O1xuICAgICAgICAgICAgICAgICAgICBkID0gZDI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpbnRlcnZhbCAqPSAwLjU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHRcbiAgICAgICAgaWYgKG91dCkge1xuICAgICAgICAgICAgb3V0WzBdID0gcXVhZHJhdGljQXQoeDAsIHgxLCB4MiwgdCk7XG4gICAgICAgICAgICBvdXRbMV0gPSBxdWFkcmF0aWNBdCh5MCwgeTEsIHkyLCB0KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBjb25zb2xlLmxvZyhpbnRlcnZhbCwgaSk7XG4gICAgICAgIHJldHVybiBtYXRoU3FydChkKTtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHtcblxuICAgICAgICBjdWJpY0F0OiBjdWJpY0F0LFxuXG4gICAgICAgIGN1YmljRGVyaXZhdGl2ZUF0OiBjdWJpY0Rlcml2YXRpdmVBdCxcblxuICAgICAgICBjdWJpY1Jvb3RBdDogY3ViaWNSb290QXQsXG5cbiAgICAgICAgY3ViaWNFeHRyZW1hOiBjdWJpY0V4dHJlbWEsXG5cbiAgICAgICAgY3ViaWNTdWJkaXZpZGU6IGN1YmljU3ViZGl2aWRlLFxuXG4gICAgICAgIGN1YmljUHJvamVjdFBvaW50OiBjdWJpY1Byb2plY3RQb2ludCxcblxuICAgICAgICBxdWFkcmF0aWNBdDogcXVhZHJhdGljQXQsXG5cbiAgICAgICAgcXVhZHJhdGljRGVyaXZhdGl2ZUF0OiBxdWFkcmF0aWNEZXJpdmF0aXZlQXQsXG5cbiAgICAgICAgcXVhZHJhdGljUm9vdEF0OiBxdWFkcmF0aWNSb290QXQsXG5cbiAgICAgICAgcXVhZHJhdGljRXh0cmVtdW06IHF1YWRyYXRpY0V4dHJlbXVtLFxuXG4gICAgICAgIHF1YWRyYXRpY1N1YmRpdmlkZTogcXVhZHJhdGljU3ViZGl2aWRlLFxuXG4gICAgICAgIHF1YWRyYXRpY1Byb2plY3RQb2ludDogcXVhZHJhdGljUHJvamVjdFBvaW50XG4gICAgfTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3pyZW5kZXIvbGliL2NvcmUvY3VydmUuanNcbiAqKiBtb2R1bGUgaWQgPSAyNlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBAYXV0aG9yIFlpIFNoZW4oaHR0cHM6Ly9naXRodWIuY29tL3Bpc3NhbmcpXG4gKi9cblxuXG4gICAgdmFyIHZlYzIgPSByZXF1aXJlKCcuL3ZlY3RvcicpO1xuICAgIHZhciBjdXJ2ZSA9IHJlcXVpcmUoJy4vY3VydmUnKTtcblxuICAgIHZhciBiYm94ID0ge307XG4gICAgdmFyIG1hdGhNaW4gPSBNYXRoLm1pbjtcbiAgICB2YXIgbWF0aE1heCA9IE1hdGgubWF4O1xuICAgIHZhciBtYXRoU2luID0gTWF0aC5zaW47XG4gICAgdmFyIG1hdGhDb3MgPSBNYXRoLmNvcztcblxuICAgIHZhciBzdGFydCA9IHZlYzIuY3JlYXRlKCk7XG4gICAgdmFyIGVuZCA9IHZlYzIuY3JlYXRlKCk7XG4gICAgdmFyIGV4dHJlbWl0eSA9IHZlYzIuY3JlYXRlKCk7XG5cbiAgICB2YXIgUEkyID0gTWF0aC5QSSAqIDI7XG4gICAgLyoqXG4gICAgICog5LuO6aG254K55pWw57uE5Lit6K6h566X5Ye65pyA5bCP5YyF5Zu055uS77yM5YaZ5YWlYG1pbmDlkoxgbWF4YOS4rVxuICAgICAqIEBtb2R1bGUgenJlbmRlci9jb3JlL2Jib3hcbiAgICAgKiBAcGFyYW0ge0FycmF5PE9iamVjdD59IHBvaW50cyDpobbngrnmlbDnu4RcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbWluXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1heFxuICAgICAqL1xuICAgIGJib3guZnJvbVBvaW50cyA9IGZ1bmN0aW9uKHBvaW50cywgbWluLCBtYXgpIHtcbiAgICAgICAgaWYgKHBvaW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcCA9IHBvaW50c1swXTtcbiAgICAgICAgdmFyIGxlZnQgPSBwWzBdO1xuICAgICAgICB2YXIgcmlnaHQgPSBwWzBdO1xuICAgICAgICB2YXIgdG9wID0gcFsxXTtcbiAgICAgICAgdmFyIGJvdHRvbSA9IHBbMV07XG4gICAgICAgIHZhciBpO1xuXG4gICAgICAgIGZvciAoaSA9IDE7IGkgPCBwb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHAgPSBwb2ludHNbaV07XG4gICAgICAgICAgICBsZWZ0ID0gbWF0aE1pbihsZWZ0LCBwWzBdKTtcbiAgICAgICAgICAgIHJpZ2h0ID0gbWF0aE1heChyaWdodCwgcFswXSk7XG4gICAgICAgICAgICB0b3AgPSBtYXRoTWluKHRvcCwgcFsxXSk7XG4gICAgICAgICAgICBib3R0b20gPSBtYXRoTWF4KGJvdHRvbSwgcFsxXSk7XG4gICAgICAgIH1cblxuICAgICAgICBtaW5bMF0gPSBsZWZ0O1xuICAgICAgICBtaW5bMV0gPSB0b3A7XG4gICAgICAgIG1heFswXSA9IHJpZ2h0O1xuICAgICAgICBtYXhbMV0gPSBib3R0b207XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL2Jib3hcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geDBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geTBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geDFcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geTFcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBtaW5cbiAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBtYXhcbiAgICAgKi9cbiAgICBiYm94LmZyb21MaW5lID0gZnVuY3Rpb24gKHgwLCB5MCwgeDEsIHkxLCBtaW4sIG1heCkge1xuICAgICAgICBtaW5bMF0gPSBtYXRoTWluKHgwLCB4MSk7XG4gICAgICAgIG1pblsxXSA9IG1hdGhNaW4oeTAsIHkxKTtcbiAgICAgICAgbWF4WzBdID0gbWF0aE1heCh4MCwgeDEpO1xuICAgICAgICBtYXhbMV0gPSBtYXRoTWF4KHkwLCB5MSk7XG4gICAgfTtcblxuICAgIHZhciB4RGltID0gW107XG4gICAgdmFyIHlEaW0gPSBbXTtcbiAgICAvKipcbiAgICAgKiDku47kuInpmLbotJ3loZ7lsJTmm7Lnur8ocDAsIHAxLCBwMiwgcDMp5Lit6K6h566X5Ye65pyA5bCP5YyF5Zu055uS77yM5YaZ5YWlYG1pbmDlkoxgbWF4YOS4rVxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL2Jib3hcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geDBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geTBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geDFcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geTFcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geDJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geTJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geDNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geTNcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBtaW5cbiAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBtYXhcbiAgICAgKi9cbiAgICBiYm94LmZyb21DdWJpYyA9IGZ1bmN0aW9uKFxuICAgICAgICB4MCwgeTAsIHgxLCB5MSwgeDIsIHkyLCB4MywgeTMsIG1pbiwgbWF4XG4gICAgKSB7XG4gICAgICAgIHZhciBjdWJpY0V4dHJlbWEgPSBjdXJ2ZS5jdWJpY0V4dHJlbWE7XG4gICAgICAgIHZhciBjdWJpY0F0ID0gY3VydmUuY3ViaWNBdDtcbiAgICAgICAgdmFyIGk7XG4gICAgICAgIHZhciBuID0gY3ViaWNFeHRyZW1hKHgwLCB4MSwgeDIsIHgzLCB4RGltKTtcbiAgICAgICAgbWluWzBdID0gSW5maW5pdHk7XG4gICAgICAgIG1pblsxXSA9IEluZmluaXR5O1xuICAgICAgICBtYXhbMF0gPSAtSW5maW5pdHk7XG4gICAgICAgIG1heFsxXSA9IC1JbmZpbml0eTtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgeCA9IGN1YmljQXQoeDAsIHgxLCB4MiwgeDMsIHhEaW1baV0pO1xuICAgICAgICAgICAgbWluWzBdID0gbWF0aE1pbih4LCBtaW5bMF0pO1xuICAgICAgICAgICAgbWF4WzBdID0gbWF0aE1heCh4LCBtYXhbMF0pO1xuICAgICAgICB9XG4gICAgICAgIG4gPSBjdWJpY0V4dHJlbWEoeTAsIHkxLCB5MiwgeTMsIHlEaW0pO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgeSA9IGN1YmljQXQoeTAsIHkxLCB5MiwgeTMsIHlEaW1baV0pO1xuICAgICAgICAgICAgbWluWzFdID0gbWF0aE1pbih5LCBtaW5bMV0pO1xuICAgICAgICAgICAgbWF4WzFdID0gbWF0aE1heCh5LCBtYXhbMV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgbWluWzBdID0gbWF0aE1pbih4MCwgbWluWzBdKTtcbiAgICAgICAgbWF4WzBdID0gbWF0aE1heCh4MCwgbWF4WzBdKTtcbiAgICAgICAgbWluWzBdID0gbWF0aE1pbih4MywgbWluWzBdKTtcbiAgICAgICAgbWF4WzBdID0gbWF0aE1heCh4MywgbWF4WzBdKTtcblxuICAgICAgICBtaW5bMV0gPSBtYXRoTWluKHkwLCBtaW5bMV0pO1xuICAgICAgICBtYXhbMV0gPSBtYXRoTWF4KHkwLCBtYXhbMV0pO1xuICAgICAgICBtaW5bMV0gPSBtYXRoTWluKHkzLCBtaW5bMV0pO1xuICAgICAgICBtYXhbMV0gPSBtYXRoTWF4KHkzLCBtYXhbMV0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiDku47kuozpmLbotJ3loZ7lsJTmm7Lnur8ocDAsIHAxLCBwMinkuK3orqHnrpflh7rmnIDlsI/ljIXlm7Tnm5LvvIzlhpnlhaVgbWluYOWSjGBtYXhg5LitXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvYmJveFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4MFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5MFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4MVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5MVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4MlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5MlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IG1pblxuICAgICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IG1heFxuICAgICAqL1xuICAgIGJib3guZnJvbVF1YWRyYXRpYyA9IGZ1bmN0aW9uKHgwLCB5MCwgeDEsIHkxLCB4MiwgeTIsIG1pbiwgbWF4KSB7XG4gICAgICAgIHZhciBxdWFkcmF0aWNFeHRyZW11bSA9IGN1cnZlLnF1YWRyYXRpY0V4dHJlbXVtO1xuICAgICAgICB2YXIgcXVhZHJhdGljQXQgPSBjdXJ2ZS5xdWFkcmF0aWNBdDtcbiAgICAgICAgLy8gRmluZCBleHRyZW1pdGllcywgd2hlcmUgZGVyaXZhdGl2ZSBpbiB4IGRpbSBvciB5IGRpbSBpcyB6ZXJvXG4gICAgICAgIHZhciB0eCA9XG4gICAgICAgICAgICBtYXRoTWF4KFxuICAgICAgICAgICAgICAgIG1hdGhNaW4ocXVhZHJhdGljRXh0cmVtdW0oeDAsIHgxLCB4MiksIDEpLCAwXG4gICAgICAgICAgICApO1xuICAgICAgICB2YXIgdHkgPVxuICAgICAgICAgICAgbWF0aE1heChcbiAgICAgICAgICAgICAgICBtYXRoTWluKHF1YWRyYXRpY0V4dHJlbXVtKHkwLCB5MSwgeTIpLCAxKSwgMFxuICAgICAgICAgICAgKTtcblxuICAgICAgICB2YXIgeCA9IHF1YWRyYXRpY0F0KHgwLCB4MSwgeDIsIHR4KTtcbiAgICAgICAgdmFyIHkgPSBxdWFkcmF0aWNBdCh5MCwgeTEsIHkyLCB0eSk7XG5cbiAgICAgICAgbWluWzBdID0gbWF0aE1pbih4MCwgeDIsIHgpO1xuICAgICAgICBtaW5bMV0gPSBtYXRoTWluKHkwLCB5MiwgeSk7XG4gICAgICAgIG1heFswXSA9IG1hdGhNYXgoeDAsIHgyLCB4KTtcbiAgICAgICAgbWF4WzFdID0gbWF0aE1heCh5MCwgeTIsIHkpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiDku47lnIblvKfkuK3orqHnrpflh7rmnIDlsI/ljIXlm7Tnm5LvvIzlhpnlhaVgbWluYOWSjGBtYXhg5LitXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL2Jib3hcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJ4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJ5XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0QW5nbGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZW5kQW5nbGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYW50aWNsb2Nrd2lzZVxuICAgICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IG1pblxuICAgICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IG1heFxuICAgICAqL1xuICAgIGJib3guZnJvbUFyYyA9IGZ1bmN0aW9uIChcbiAgICAgICAgeCwgeSwgcngsIHJ5LCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgYW50aWNsb2Nrd2lzZSwgbWluLCBtYXhcbiAgICApIHtcbiAgICAgICAgdmFyIHZlYzJNaW4gPSB2ZWMyLm1pbjtcbiAgICAgICAgdmFyIHZlYzJNYXggPSB2ZWMyLm1heDtcblxuICAgICAgICB2YXIgZGlmZiA9IE1hdGguYWJzKHN0YXJ0QW5nbGUgLSBlbmRBbmdsZSk7XG5cblxuICAgICAgICBpZiAoZGlmZiAlIFBJMiA8IDFlLTQgJiYgZGlmZiA+IDFlLTQpIHtcbiAgICAgICAgICAgIC8vIElzIGEgY2lyY2xlXG4gICAgICAgICAgICBtaW5bMF0gPSB4IC0gcng7XG4gICAgICAgICAgICBtaW5bMV0gPSB5IC0gcnk7XG4gICAgICAgICAgICBtYXhbMF0gPSB4ICsgcng7XG4gICAgICAgICAgICBtYXhbMV0gPSB5ICsgcnk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBzdGFydFswXSA9IG1hdGhDb3Moc3RhcnRBbmdsZSkgKiByeCArIHg7XG4gICAgICAgIHN0YXJ0WzFdID0gbWF0aFNpbihzdGFydEFuZ2xlKSAqIHJ5ICsgeTtcblxuICAgICAgICBlbmRbMF0gPSBtYXRoQ29zKGVuZEFuZ2xlKSAqIHJ4ICsgeDtcbiAgICAgICAgZW5kWzFdID0gbWF0aFNpbihlbmRBbmdsZSkgKiByeSArIHk7XG5cbiAgICAgICAgdmVjMk1pbihtaW4sIHN0YXJ0LCBlbmQpO1xuICAgICAgICB2ZWMyTWF4KG1heCwgc3RhcnQsIGVuZCk7XG5cbiAgICAgICAgLy8gVGhyZXNoIHRvIFswLCBNYXRoLlBJICogMl1cbiAgICAgICAgc3RhcnRBbmdsZSA9IHN0YXJ0QW5nbGUgJSAoUEkyKTtcbiAgICAgICAgaWYgKHN0YXJ0QW5nbGUgPCAwKSB7XG4gICAgICAgICAgICBzdGFydEFuZ2xlID0gc3RhcnRBbmdsZSArIFBJMjtcbiAgICAgICAgfVxuICAgICAgICBlbmRBbmdsZSA9IGVuZEFuZ2xlICUgKFBJMik7XG4gICAgICAgIGlmIChlbmRBbmdsZSA8IDApIHtcbiAgICAgICAgICAgIGVuZEFuZ2xlID0gZW5kQW5nbGUgKyBQSTI7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RhcnRBbmdsZSA+IGVuZEFuZ2xlICYmICFhbnRpY2xvY2t3aXNlKSB7XG4gICAgICAgICAgICBlbmRBbmdsZSArPSBQSTI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc3RhcnRBbmdsZSA8IGVuZEFuZ2xlICYmIGFudGljbG9ja3dpc2UpIHtcbiAgICAgICAgICAgIHN0YXJ0QW5nbGUgKz0gUEkyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhbnRpY2xvY2t3aXNlKSB7XG4gICAgICAgICAgICB2YXIgdG1wID0gZW5kQW5nbGU7XG4gICAgICAgICAgICBlbmRBbmdsZSA9IHN0YXJ0QW5nbGU7XG4gICAgICAgICAgICBzdGFydEFuZ2xlID0gdG1wO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdmFyIG51bWJlciA9IDA7XG4gICAgICAgIC8vIHZhciBzdGVwID0gKGFudGljbG9ja3dpc2UgPyAtTWF0aC5QSSA6IE1hdGguUEkpIC8gMjtcbiAgICAgICAgZm9yICh2YXIgYW5nbGUgPSAwOyBhbmdsZSA8IGVuZEFuZ2xlOyBhbmdsZSArPSBNYXRoLlBJIC8gMikge1xuICAgICAgICAgICAgaWYgKGFuZ2xlID4gc3RhcnRBbmdsZSkge1xuICAgICAgICAgICAgICAgIGV4dHJlbWl0eVswXSA9IG1hdGhDb3MoYW5nbGUpICogcnggKyB4O1xuICAgICAgICAgICAgICAgIGV4dHJlbWl0eVsxXSA9IG1hdGhTaW4oYW5nbGUpICogcnkgKyB5O1xuXG4gICAgICAgICAgICAgICAgdmVjMk1pbihtaW4sIGV4dHJlbWl0eSwgbWluKTtcbiAgICAgICAgICAgICAgICB2ZWMyTWF4KG1heCwgZXh0cmVtaXR5LCBtYXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gYmJveDtcblxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34venJlbmRlci9saWIvY29yZS9iYm94LmpzXG4gKiogbW9kdWxlIGlkID0gMjdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuXG4gICAgdmFyIENNRCA9IHJlcXVpcmUoJy4uL2NvcmUvUGF0aFByb3h5JykuQ01EO1xuICAgIHZhciBsaW5lID0gcmVxdWlyZSgnLi9saW5lJyk7XG4gICAgdmFyIGN1YmljID0gcmVxdWlyZSgnLi9jdWJpYycpO1xuICAgIHZhciBxdWFkcmF0aWMgPSByZXF1aXJlKCcuL3F1YWRyYXRpYycpO1xuICAgIHZhciBhcmMgPSByZXF1aXJlKCcuL2FyYycpO1xuICAgIHZhciBub3JtYWxpemVSYWRpYW4gPSByZXF1aXJlKCcuL3V0aWwnKS5ub3JtYWxpemVSYWRpYW47XG4gICAgdmFyIGN1cnZlID0gcmVxdWlyZSgnLi4vY29yZS9jdXJ2ZScpO1xuXG4gICAgdmFyIHdpbmRpbmdMaW5lID0gcmVxdWlyZSgnLi93aW5kaW5nTGluZScpO1xuXG4gICAgdmFyIGNvbnRhaW5TdHJva2UgPSBsaW5lLmNvbnRhaW5TdHJva2U7XG5cbiAgICB2YXIgUEkyID0gTWF0aC5QSSAqIDI7XG5cbiAgICB2YXIgRVBTSUxPTiA9IDFlLTQ7XG5cbiAgICBmdW5jdGlvbiBpc0Fyb3VuZEVxdWFsKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguYWJzKGEgLSBiKSA8IEVQU0lMT047XG4gICAgfVxuXG4gICAgLy8g5Li05pe25pWw57uEXG4gICAgdmFyIHJvb3RzID0gWy0xLCAtMSwgLTFdO1xuICAgIHZhciBleHRyZW1hID0gWy0xLCAtMV07XG5cbiAgICBmdW5jdGlvbiBzd2FwRXh0cmVtYSgpIHtcbiAgICAgICAgdmFyIHRtcCA9IGV4dHJlbWFbMF07XG4gICAgICAgIGV4dHJlbWFbMF0gPSBleHRyZW1hWzFdO1xuICAgICAgICBleHRyZW1hWzFdID0gdG1wO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHdpbmRpbmdDdWJpYyh4MCwgeTAsIHgxLCB5MSwgeDIsIHkyLCB4MywgeTMsIHgsIHkpIHtcbiAgICAgICAgLy8gUXVpY2sgcmVqZWN0XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgICh5ID4geTAgJiYgeSA+IHkxICYmIHkgPiB5MiAmJiB5ID4geTMpXG4gICAgICAgICAgICB8fCAoeSA8IHkwICYmIHkgPCB5MSAmJiB5IDwgeTIgJiYgeSA8IHkzKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHZhciBuUm9vdHMgPSBjdXJ2ZS5jdWJpY1Jvb3RBdCh5MCwgeTEsIHkyLCB5MywgeSwgcm9vdHMpO1xuICAgICAgICBpZiAoblJvb3RzID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciB3ID0gMDtcbiAgICAgICAgICAgIHZhciBuRXh0cmVtYSA9IC0xO1xuICAgICAgICAgICAgdmFyIHkwXywgeTFfO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuUm9vdHM7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciB0ID0gcm9vdHNbaV07XG5cbiAgICAgICAgICAgICAgICAvLyBBdm9pZCB3aW5kaW5nIGVycm9yIHdoZW4gaW50ZXJzZWN0aW9uIHBvaW50IGlzIHRoZSBjb25uZWN0IHBvaW50IG9mIHR3byBsaW5lIG9mIHBvbHlnb25cbiAgICAgICAgICAgICAgICB2YXIgdW5pdCA9ICh0ID09PSAwIHx8IHQgPT09IDEpID8gMC41IDogMTtcblxuICAgICAgICAgICAgICAgIHZhciB4XyA9IGN1cnZlLmN1YmljQXQoeDAsIHgxLCB4MiwgeDMsIHQpO1xuICAgICAgICAgICAgICAgIGlmICh4XyA8IHgpIHsgLy8gUXVpY2sgcmVqZWN0XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobkV4dHJlbWEgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG5FeHRyZW1hID0gY3VydmUuY3ViaWNFeHRyZW1hKHkwLCB5MSwgeTIsIHkzLCBleHRyZW1hKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV4dHJlbWFbMV0gPCBleHRyZW1hWzBdICYmIG5FeHRyZW1hID4gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3dhcEV4dHJlbWEoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB5MF8gPSBjdXJ2ZS5jdWJpY0F0KHkwLCB5MSwgeTIsIHkzLCBleHRyZW1hWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5FeHRyZW1hID4gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgeTFfID0gY3VydmUuY3ViaWNBdCh5MCwgeTEsIHkyLCB5MywgZXh0cmVtYVsxXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG5FeHRyZW1hID09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8g5YiG5oiQ5LiJ5q615Y2V6LCD5Ye95pWwXG4gICAgICAgICAgICAgICAgICAgIGlmICh0IDwgZXh0cmVtYVswXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdyArPSB5MF8gPCB5MCA/IHVuaXQgOiAtdW5pdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0IDwgZXh0cmVtYVsxXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdyArPSB5MV8gPCB5MF8gPyB1bml0IDogLXVuaXQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3ICs9IHkzIDwgeTFfID8gdW5pdCA6IC11bml0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyDliIbmiJDkuKTmrrXljZXosIPlh73mlbBcbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgPCBleHRyZW1hWzBdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3ICs9IHkwXyA8IHkwID8gdW5pdCA6IC11bml0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdyArPSB5MyA8IHkwXyA/IHVuaXQgOiAtdW5pdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB3O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gd2luZGluZ1F1YWRyYXRpYyh4MCwgeTAsIHgxLCB5MSwgeDIsIHkyLCB4LCB5KSB7XG4gICAgICAgIC8vIFF1aWNrIHJlamVjdFxuICAgICAgICBpZiAoXG4gICAgICAgICAgICAoeSA+IHkwICYmIHkgPiB5MSAmJiB5ID4geTIpXG4gICAgICAgICAgICB8fCAoeSA8IHkwICYmIHkgPCB5MSAmJiB5IDwgeTIpXG4gICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5Sb290cyA9IGN1cnZlLnF1YWRyYXRpY1Jvb3RBdCh5MCwgeTEsIHkyLCB5LCByb290cyk7XG4gICAgICAgIGlmIChuUm9vdHMgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIHQgPSBjdXJ2ZS5xdWFkcmF0aWNFeHRyZW11bSh5MCwgeTEsIHkyKTtcbiAgICAgICAgICAgIGlmICh0ID49IDAgJiYgdCA8PSAxKSB7XG4gICAgICAgICAgICAgICAgdmFyIHcgPSAwO1xuICAgICAgICAgICAgICAgIHZhciB5XyA9IGN1cnZlLnF1YWRyYXRpY0F0KHkwLCB5MSwgeTIsIHQpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgblJvb3RzOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVtb3ZlIG9uZSBlbmRwb2ludC5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHVuaXQgPSAocm9vdHNbaV0gPT09IDAgfHwgcm9vdHNbaV0gPT09IDEpID8gMC41IDogMTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgeF8gPSBjdXJ2ZS5xdWFkcmF0aWNBdCh4MCwgeDEsIHgyLCByb290c1tpXSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh4XyA8IHgpIHsgICAvLyBRdWljayByZWplY3RcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChyb290c1tpXSA8IHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHcgKz0geV8gPCB5MCA/IHVuaXQgOiAtdW5pdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHcgKz0geTIgPCB5XyA/IHVuaXQgOiAtdW5pdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBvbmUgZW5kcG9pbnQuXG4gICAgICAgICAgICAgICAgdmFyIHVuaXQgPSAocm9vdHNbMF0gPT09IDAgfHwgcm9vdHNbMF0gPT09IDEpID8gMC41IDogMTtcblxuICAgICAgICAgICAgICAgIHZhciB4XyA9IGN1cnZlLnF1YWRyYXRpY0F0KHgwLCB4MSwgeDIsIHJvb3RzWzBdKTtcbiAgICAgICAgICAgICAgICBpZiAoeF8gPCB4KSB7ICAgLy8gUXVpY2sgcmVqZWN0XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4geTIgPCB5MCA/IHVuaXQgOiAtdW5pdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRPRE9cbiAgICAvLyBBcmMg5peL6L2sXG4gICAgZnVuY3Rpb24gd2luZGluZ0FyYyhcbiAgICAgICAgY3gsIGN5LCByLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgYW50aWNsb2Nrd2lzZSwgeCwgeVxuICAgICkge1xuICAgICAgICB5IC09IGN5O1xuICAgICAgICBpZiAoeSA+IHIgfHwgeSA8IC1yKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdG1wID0gTWF0aC5zcXJ0KHIgKiByIC0geSAqIHkpO1xuICAgICAgICByb290c1swXSA9IC10bXA7XG4gICAgICAgIHJvb3RzWzFdID0gdG1wO1xuXG4gICAgICAgIHZhciBkaWZmID0gTWF0aC5hYnMoc3RhcnRBbmdsZSAtIGVuZEFuZ2xlKTtcbiAgICAgICAgaWYgKGRpZmYgPCAxZS00KSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGlmZiAlIFBJMiA8IDFlLTQpIHtcbiAgICAgICAgICAgIC8vIElzIGEgY2lyY2xlXG4gICAgICAgICAgICBzdGFydEFuZ2xlID0gMDtcbiAgICAgICAgICAgIGVuZEFuZ2xlID0gUEkyO1xuICAgICAgICAgICAgdmFyIGRpciA9IGFudGljbG9ja3dpc2UgPyAxIDogLTE7XG4gICAgICAgICAgICBpZiAoeCA+PSByb290c1swXSArIGN4ICYmIHggPD0gcm9vdHNbMV0gKyBjeCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkaXI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGFudGljbG9ja3dpc2UpIHtcbiAgICAgICAgICAgIHZhciB0bXAgPSBzdGFydEFuZ2xlO1xuICAgICAgICAgICAgc3RhcnRBbmdsZSA9IG5vcm1hbGl6ZVJhZGlhbihlbmRBbmdsZSk7XG4gICAgICAgICAgICBlbmRBbmdsZSA9IG5vcm1hbGl6ZVJhZGlhbih0bXApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RhcnRBbmdsZSA9IG5vcm1hbGl6ZVJhZGlhbihzdGFydEFuZ2xlKTtcbiAgICAgICAgICAgIGVuZEFuZ2xlID0gbm9ybWFsaXplUmFkaWFuKGVuZEFuZ2xlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhcnRBbmdsZSA+IGVuZEFuZ2xlKSB7XG4gICAgICAgICAgICBlbmRBbmdsZSArPSBQSTI7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdyA9IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMjsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgeF8gPSByb290c1tpXTtcbiAgICAgICAgICAgIGlmICh4XyArIGN4ID4geCkge1xuICAgICAgICAgICAgICAgIHZhciBhbmdsZSA9IE1hdGguYXRhbjIoeSwgeF8pO1xuICAgICAgICAgICAgICAgIHZhciBkaXIgPSBhbnRpY2xvY2t3aXNlID8gMSA6IC0xO1xuICAgICAgICAgICAgICAgIGlmIChhbmdsZSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgYW5nbGUgPSBQSTIgKyBhbmdsZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAoYW5nbGUgPj0gc3RhcnRBbmdsZSAmJiBhbmdsZSA8PSBlbmRBbmdsZSlcbiAgICAgICAgICAgICAgICAgICAgfHwgKGFuZ2xlICsgUEkyID49IHN0YXJ0QW5nbGUgJiYgYW5nbGUgKyBQSTIgPD0gZW5kQW5nbGUpXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhbmdsZSA+IE1hdGguUEkgLyAyICYmIGFuZ2xlIDwgTWF0aC5QSSAqIDEuNSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGlyID0gLWRpcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB3ICs9IGRpcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29udGFpblBhdGgoZGF0YSwgbGluZVdpZHRoLCBpc1N0cm9rZSwgeCwgeSkge1xuICAgICAgICB2YXIgdyA9IDA7XG4gICAgICAgIHZhciB4aSA9IDA7XG4gICAgICAgIHZhciB5aSA9IDA7XG4gICAgICAgIHZhciB4MCA9IDA7XG4gICAgICAgIHZhciB5MCA9IDA7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDspIHtcbiAgICAgICAgICAgIHZhciBjbWQgPSBkYXRhW2krK107XG4gICAgICAgICAgICAvLyBCZWdpbiBhIG5ldyBzdWJwYXRoXG4gICAgICAgICAgICBpZiAoY21kID09PSBDTUQuTSAmJiBpID4gMSkge1xuICAgICAgICAgICAgICAgIC8vIENsb3NlIHByZXZpb3VzIHN1YnBhdGhcbiAgICAgICAgICAgICAgICBpZiAoIWlzU3Ryb2tlKSB7XG4gICAgICAgICAgICAgICAgICAgIHcgKz0gd2luZGluZ0xpbmUoeGksIHlpLCB4MCwgeTAsIHgsIHkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyDlpoLmnpzooqvku7vkvZXkuIDkuKogc3VicGF0aCDljIXlkKtcbiAgICAgICAgICAgICAgICAvLyBpZiAodyAhPT0gMCkge1xuICAgICAgICAgICAgICAgIC8vICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChpID09IDEpIHtcbiAgICAgICAgICAgICAgICAvLyDlpoLmnpznrKzkuIDkuKrlkb3ku6TmmK8gTCwgQywgUVxuICAgICAgICAgICAgICAgIC8vIOWImSBwcmV2aW91cyBwb2ludCDlkIznu5jliLblkb3ku6TnmoTnrKzkuIDkuKogcG9pbnRcbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vIOesrOS4gOS4quWRveS7pOS4uiBBcmMg55qE5oOF5Ya15LiL5Lya5Zyo5ZCO6Z2i54m55q6K5aSE55CGXG4gICAgICAgICAgICAgICAgeGkgPSBkYXRhW2ldO1xuICAgICAgICAgICAgICAgIHlpID0gZGF0YVtpICsgMV07XG5cbiAgICAgICAgICAgICAgICB4MCA9IHhpO1xuICAgICAgICAgICAgICAgIHkwID0geWk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHN3aXRjaCAoY21kKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBDTUQuTTpcbiAgICAgICAgICAgICAgICAgICAgLy8gbW92ZVRvIOWRveS7pOmHjeaWsOWIm+W7uuS4gOS4quaWsOeahCBzdWJwYXRoLCDlubbkuJTmm7TmlrDmlrDnmoTotbfngrlcbiAgICAgICAgICAgICAgICAgICAgLy8g5ZyoIGNsb3NlUGF0aCDnmoTml7blgJnkvb/nlKhcbiAgICAgICAgICAgICAgICAgICAgeDAgPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgIHkwID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICB4aSA9IHgwO1xuICAgICAgICAgICAgICAgICAgICB5aSA9IHkwO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIENNRC5MOlxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNTdHJva2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb250YWluU3Ryb2tlKHhpLCB5aSwgZGF0YVtpXSwgZGF0YVtpICsgMV0sIGxpbmVXaWR0aCwgeCwgeSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5PVEUg5Zyo56ys5LiA5Liq5ZG95Luk5Li6IEwsIEMsIFEg55qE5pe25YCZ5Lya6K6h566X5Ye6IE5hTlxuICAgICAgICAgICAgICAgICAgICAgICAgdyArPSB3aW5kaW5nTGluZSh4aSwgeWksIGRhdGFbaV0sIGRhdGFbaSArIDFdLCB4LCB5KSB8fCAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHhpID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICB5aSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBDTUQuQzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzU3Ryb2tlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3ViaWMuY29udGFpblN0cm9rZSh4aSwgeWksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVtpKytdLCBkYXRhW2krK10sIGRhdGFbaSsrXSwgZGF0YVtpKytdLCBkYXRhW2ldLCBkYXRhW2kgKyAxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lV2lkdGgsIHgsIHlcbiAgICAgICAgICAgICAgICAgICAgICAgICkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHcgKz0gd2luZGluZ0N1YmljKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhpLCB5aSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhW2krK10sIGRhdGFbaSsrXSwgZGF0YVtpKytdLCBkYXRhW2krK10sIGRhdGFbaV0sIGRhdGFbaSArIDFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHgsIHlcbiAgICAgICAgICAgICAgICAgICAgICAgICkgfHwgMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB4aSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgeWkgPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgQ01ELlE6XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1N0cm9rZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHF1YWRyYXRpYy5jb250YWluU3Ryb2tlKHhpLCB5aSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhW2krK10sIGRhdGFbaSsrXSwgZGF0YVtpXSwgZGF0YVtpICsgMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZVdpZHRoLCB4LCB5XG4gICAgICAgICAgICAgICAgICAgICAgICApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3ICs9IHdpbmRpbmdRdWFkcmF0aWMoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeGksIHlpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFbaSsrXSwgZGF0YVtpKytdLCBkYXRhW2ldLCBkYXRhW2kgKyAxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4LCB5XG4gICAgICAgICAgICAgICAgICAgICAgICApIHx8IDA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgeGkgPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgIHlpID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIENNRC5BOlxuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPIEFyYyDliKTmlq3nmoTlvIDplIDmr5TovoPlpKdcbiAgICAgICAgICAgICAgICAgICAgdmFyIGN4ID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY3kgPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgIHZhciByeCA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJ5ID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGhldGEgPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgIHZhciBkVGhldGEgPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gQXJjIOaXi+i9rFxuICAgICAgICAgICAgICAgICAgICB2YXIgcHNpID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYW50aWNsb2Nrd2lzZSA9IDEgLSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgIHZhciB4MSA9IE1hdGguY29zKHRoZXRhKSAqIHJ4ICsgY3g7XG4gICAgICAgICAgICAgICAgICAgIHZhciB5MSA9IE1hdGguc2luKHRoZXRhKSAqIHJ5ICsgY3k7XG4gICAgICAgICAgICAgICAgICAgIC8vIOS4jeaYr+ebtOaOpeS9v+eUqCBhcmMg5ZG95LukXG4gICAgICAgICAgICAgICAgICAgIGlmIChpID4gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdyArPSB3aW5kaW5nTGluZSh4aSwgeWksIHgxLCB5MSwgeCwgeSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyDnrKzkuIDkuKrlkb3ku6Totbfngrnov5jmnKrlrprkuYlcbiAgICAgICAgICAgICAgICAgICAgICAgIHgwID0geDE7XG4gICAgICAgICAgICAgICAgICAgICAgICB5MCA9IHkxO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIHpyIOS9v+eUqHNjYWxl5p2l5qih5ouf5qSt5ZyGLCDov5nph4zkuZ/lr7l45YGa5LiA5a6a55qE57yp5pS+XG4gICAgICAgICAgICAgICAgICAgIHZhciBfeCA9ICh4IC0gY3gpICogcnkgLyByeCArIGN4O1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNTdHJva2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhcmMuY29udGFpblN0cm9rZShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjeCwgY3ksIHJ5LCB0aGV0YSwgdGhldGEgKyBkVGhldGEsIGFudGljbG9ja3dpc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZVdpZHRoLCBfeCwgeVxuICAgICAgICAgICAgICAgICAgICAgICAgKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdyArPSB3aW5kaW5nQXJjKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN4LCBjeSwgcnksIHRoZXRhLCB0aGV0YSArIGRUaGV0YSwgYW50aWNsb2Nrd2lzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfeCwgeVxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB4aSA9IE1hdGguY29zKHRoZXRhICsgZFRoZXRhKSAqIHJ4ICsgY3g7XG4gICAgICAgICAgICAgICAgICAgIHlpID0gTWF0aC5zaW4odGhldGEgKyBkVGhldGEpICogcnkgKyBjeTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBDTUQuUjpcbiAgICAgICAgICAgICAgICAgICAgeDAgPSB4aSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgeTAgPSB5aSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHdpZHRoID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgaGVpZ2h0ID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgeDEgPSB4MCArIHdpZHRoO1xuICAgICAgICAgICAgICAgICAgICB2YXIgeTEgPSB5MCArIGhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzU3Ryb2tlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29udGFpblN0cm9rZSh4MCwgeTAsIHgxLCB5MCwgbGluZVdpZHRoLCB4LCB5KVxuICAgICAgICAgICAgICAgICAgICAgICAgICB8fCBjb250YWluU3Ryb2tlKHgxLCB5MCwgeDEsIHkxLCBsaW5lV2lkdGgsIHgsIHkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHx8IGNvbnRhaW5TdHJva2UoeDEsIHkxLCB4MCwgeTEsIGxpbmVXaWR0aCwgeCwgeSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfHwgY29udGFpblN0cm9rZSh4MCwgeTEsIHgwLCB5MCwgbGluZVdpZHRoLCB4LCB5KVxuICAgICAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGSVhNRSBDbG9ja3dpc2UgP1xuICAgICAgICAgICAgICAgICAgICAgICAgdyArPSB3aW5kaW5nTGluZSh4MSwgeTAsIHgxLCB5MSwgeCwgeSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB3ICs9IHdpbmRpbmdMaW5lKHgwLCB5MSwgeDAsIHkwLCB4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIENNRC5aOlxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNTdHJva2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb250YWluU3Ryb2tlKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhpLCB5aSwgeDAsIHkwLCBsaW5lV2lkdGgsIHgsIHlcbiAgICAgICAgICAgICAgICAgICAgICAgICkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENsb3NlIGEgc3VicGF0aFxuICAgICAgICAgICAgICAgICAgICAgICAgdyArPSB3aW5kaW5nTGluZSh4aSwgeWksIHgwLCB5MCwgeCwgeSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyDlpoLmnpzooqvku7vkvZXkuIDkuKogc3VicGF0aCDljIXlkKtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZJWE1FIHN1YnBhdGhzIG1heSBvdmVybGFwXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiAodyAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHhpID0geDA7XG4gICAgICAgICAgICAgICAgICAgIHlpID0geTA7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghaXNTdHJva2UgJiYgIWlzQXJvdW5kRXF1YWwoeWksIHkwKSkge1xuICAgICAgICAgICAgdyArPSB3aW5kaW5nTGluZSh4aSwgeWksIHgwLCB5MCwgeCwgeSkgfHwgMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdyAhPT0gMDtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAgICAgY29udGFpbjogZnVuY3Rpb24gKHBhdGhEYXRhLCB4LCB5KSB7XG4gICAgICAgICAgICByZXR1cm4gY29udGFpblBhdGgocGF0aERhdGEsIDAsIGZhbHNlLCB4LCB5KTtcbiAgICAgICAgfSxcblxuICAgICAgICBjb250YWluU3Ryb2tlOiBmdW5jdGlvbiAocGF0aERhdGEsIGxpbmVXaWR0aCwgeCwgeSkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRhaW5QYXRoKHBhdGhEYXRhLCBsaW5lV2lkdGgsIHRydWUsIHgsIHkpO1xuICAgICAgICB9XG4gICAgfTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3pyZW5kZXIvbGliL2NvbnRhaW4vcGF0aC5qc1xuICoqIG1vZHVsZSBpZCA9IDI4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOe6v+auteWMheWQq+WIpOaWrVxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9ICB4MFxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9ICB5MFxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9ICB4MVxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9ICB5MVxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9ICBsaW5lV2lkdGhcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSAgeFxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9ICB5XG4gICAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICBjb250YWluU3Ryb2tlOiBmdW5jdGlvbiAoeDAsIHkwLCB4MSwgeTEsIGxpbmVXaWR0aCwgeCwgeSkge1xuICAgICAgICAgICAgaWYgKGxpbmVXaWR0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBfbCA9IGxpbmVXaWR0aDtcbiAgICAgICAgICAgIHZhciBfYSA9IDA7XG4gICAgICAgICAgICB2YXIgX2IgPSB4MDtcbiAgICAgICAgICAgIC8vIFF1aWNrIHJlamVjdFxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICh5ID4geTAgKyBfbCAmJiB5ID4geTEgKyBfbClcbiAgICAgICAgICAgICAgICB8fCAoeSA8IHkwIC0gX2wgJiYgeSA8IHkxIC0gX2wpXG4gICAgICAgICAgICAgICAgfHwgKHggPiB4MCArIF9sICYmIHggPiB4MSArIF9sKVxuICAgICAgICAgICAgICAgIHx8ICh4IDwgeDAgLSBfbCAmJiB4IDwgeDEgLSBfbClcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHgwICE9PSB4MSkge1xuICAgICAgICAgICAgICAgIF9hID0gKHkwIC0geTEpIC8gKHgwIC0geDEpO1xuICAgICAgICAgICAgICAgIF9iID0gKHgwICogeTEgLSB4MSAqIHkwKSAvICh4MCAtIHgxKSA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5hYnMoeCAtIHgwKSA8PSBfbCAvIDI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdG1wID0gX2EgKiB4IC0geSArIF9iO1xuICAgICAgICAgICAgdmFyIF9zID0gdG1wICogdG1wIC8gKF9hICogX2EgKyAxKTtcbiAgICAgICAgICAgIHJldHVybiBfcyA8PSBfbCAvIDIgKiBfbCAvIDI7XG4gICAgICAgIH1cbiAgICB9O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34venJlbmRlci9saWIvY29udGFpbi9saW5lLmpzXG4gKiogbW9kdWxlIGlkID0gMjlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlxuXG4gICAgdmFyIGN1cnZlID0gcmVxdWlyZSgnLi4vY29yZS9jdXJ2ZScpO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiDkuInmrKHotJ3loZ7lsJTmm7Lnur/mj4/ovrnljIXlkKvliKTmlq1cbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSAgeDBcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSAgeTBcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSAgeDFcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSAgeTFcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSAgeDJcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSAgeTJcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSAgeDNcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSAgeTNcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSAgbGluZVdpZHRoXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gIHhcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSAgeVxuICAgICAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgY29udGFpblN0cm9rZTogZnVuY3Rpb24oeDAsIHkwLCB4MSwgeTEsIHgyLCB5MiwgeDMsIHkzLCBsaW5lV2lkdGgsIHgsIHkpIHtcbiAgICAgICAgICAgIGlmIChsaW5lV2lkdGggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgX2wgPSBsaW5lV2lkdGg7XG4gICAgICAgICAgICAvLyBRdWljayByZWplY3RcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAoeSA+IHkwICsgX2wgJiYgeSA+IHkxICsgX2wgJiYgeSA+IHkyICsgX2wgJiYgeSA+IHkzICsgX2wpXG4gICAgICAgICAgICAgICAgfHwgKHkgPCB5MCAtIF9sICYmIHkgPCB5MSAtIF9sICYmIHkgPCB5MiAtIF9sICYmIHkgPCB5MyAtIF9sKVxuICAgICAgICAgICAgICAgIHx8ICh4ID4geDAgKyBfbCAmJiB4ID4geDEgKyBfbCAmJiB4ID4geDIgKyBfbCAmJiB4ID4geDMgKyBfbClcbiAgICAgICAgICAgICAgICB8fCAoeCA8IHgwIC0gX2wgJiYgeCA8IHgxIC0gX2wgJiYgeCA8IHgyIC0gX2wgJiYgeCA8IHgzIC0gX2wpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZCA9IGN1cnZlLmN1YmljUHJvamVjdFBvaW50KFxuICAgICAgICAgICAgICAgIHgwLCB5MCwgeDEsIHkxLCB4MiwgeTIsIHgzLCB5MyxcbiAgICAgICAgICAgICAgICB4LCB5LCBudWxsXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmV0dXJuIGQgPD0gX2wgLyAyO1xuICAgICAgICB9XG4gICAgfTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3pyZW5kZXIvbGliL2NvbnRhaW4vY3ViaWMuanNcbiAqKiBtb2R1bGUgaWQgPSAzMFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXG5cbiAgICB2YXIgY3VydmUgPSByZXF1aXJlKCcuLi9jb3JlL2N1cnZlJyk7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOS6jOasoei0neWhnuWwlOabsue6v+aPj+i+ueWMheWQq+WIpOaWrVxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9ICB4MFxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9ICB5MFxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9ICB4MVxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9ICB5MVxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9ICB4MlxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9ICB5MlxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9ICBsaW5lV2lkdGhcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSAgeFxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9ICB5XG4gICAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICBjb250YWluU3Ryb2tlOiBmdW5jdGlvbiAoeDAsIHkwLCB4MSwgeTEsIHgyLCB5MiwgbGluZVdpZHRoLCB4LCB5KSB7XG4gICAgICAgICAgICBpZiAobGluZVdpZHRoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIF9sID0gbGluZVdpZHRoO1xuICAgICAgICAgICAgLy8gUXVpY2sgcmVqZWN0XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgKHkgPiB5MCArIF9sICYmIHkgPiB5MSArIF9sICYmIHkgPiB5MiArIF9sKVxuICAgICAgICAgICAgICAgIHx8ICh5IDwgeTAgLSBfbCAmJiB5IDwgeTEgLSBfbCAmJiB5IDwgeTIgLSBfbClcbiAgICAgICAgICAgICAgICB8fCAoeCA+IHgwICsgX2wgJiYgeCA+IHgxICsgX2wgJiYgeCA+IHgyICsgX2wpXG4gICAgICAgICAgICAgICAgfHwgKHggPCB4MCAtIF9sICYmIHggPCB4MSAtIF9sICYmIHggPCB4MiAtIF9sKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGQgPSBjdXJ2ZS5xdWFkcmF0aWNQcm9qZWN0UG9pbnQoXG4gICAgICAgICAgICAgICAgeDAsIHkwLCB4MSwgeTEsIHgyLCB5MixcbiAgICAgICAgICAgICAgICB4LCB5LCBudWxsXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmV0dXJuIGQgPD0gX2wgLyAyO1xuICAgICAgICB9XG4gICAgfTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3pyZW5kZXIvbGliL2NvbnRhaW4vcXVhZHJhdGljLmpzXG4gKiogbW9kdWxlIGlkID0gMzFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlxuXG4gICAgdmFyIG5vcm1hbGl6ZVJhZGlhbiA9IHJlcXVpcmUoJy4vdXRpbCcpLm5vcm1hbGl6ZVJhZGlhbjtcbiAgICB2YXIgUEkyID0gTWF0aC5QSSAqIDI7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWchuW8p+aPj+i+ueWMheWQq+WIpOaWrVxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9ICBjeFxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9ICBjeVxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9ICByXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gIHN0YXJ0QW5nbGVcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSAgZW5kQW5nbGVcbiAgICAgICAgICogQHBhcmFtICB7Ym9vbGVhbn0gIGFudGljbG9ja3dpc2VcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSBsaW5lV2lkdGhcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSAgeFxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9ICB5XG4gICAgICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICBjb250YWluU3Ryb2tlOiBmdW5jdGlvbiAoXG4gICAgICAgICAgICBjeCwgY3ksIHIsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBhbnRpY2xvY2t3aXNlLFxuICAgICAgICAgICAgbGluZVdpZHRoLCB4LCB5XG4gICAgICAgICkge1xuXG4gICAgICAgICAgICBpZiAobGluZVdpZHRoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIF9sID0gbGluZVdpZHRoO1xuXG4gICAgICAgICAgICB4IC09IGN4O1xuICAgICAgICAgICAgeSAtPSBjeTtcbiAgICAgICAgICAgIHZhciBkID0gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkpO1xuXG4gICAgICAgICAgICBpZiAoKGQgLSBfbCA+IHIpIHx8IChkICsgX2wgPCByKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChNYXRoLmFicyhzdGFydEFuZ2xlIC0gZW5kQW5nbGUpICUgUEkyIDwgMWUtNCkge1xuICAgICAgICAgICAgICAgIC8vIElzIGEgY2lyY2xlXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYW50aWNsb2Nrd2lzZSkge1xuICAgICAgICAgICAgICAgIHZhciB0bXAgPSBzdGFydEFuZ2xlO1xuICAgICAgICAgICAgICAgIHN0YXJ0QW5nbGUgPSBub3JtYWxpemVSYWRpYW4oZW5kQW5nbGUpO1xuICAgICAgICAgICAgICAgIGVuZEFuZ2xlID0gbm9ybWFsaXplUmFkaWFuKHRtcCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0YXJ0QW5nbGUgPSBub3JtYWxpemVSYWRpYW4oc3RhcnRBbmdsZSk7XG4gICAgICAgICAgICAgICAgZW5kQW5nbGUgPSBub3JtYWxpemVSYWRpYW4oZW5kQW5nbGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0YXJ0QW5nbGUgPiBlbmRBbmdsZSkge1xuICAgICAgICAgICAgICAgIGVuZEFuZ2xlICs9IFBJMjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGFuZ2xlID0gTWF0aC5hdGFuMih5LCB4KTtcbiAgICAgICAgICAgIGlmIChhbmdsZSA8IDApIHtcbiAgICAgICAgICAgICAgICBhbmdsZSArPSBQSTI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gKGFuZ2xlID49IHN0YXJ0QW5nbGUgJiYgYW5nbGUgPD0gZW5kQW5nbGUpXG4gICAgICAgICAgICAgICAgfHwgKGFuZ2xlICsgUEkyID49IHN0YXJ0QW5nbGUgJiYgYW5nbGUgKyBQSTIgPD0gZW5kQW5nbGUpO1xuICAgICAgICB9XG4gICAgfTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3pyZW5kZXIvbGliL2NvbnRhaW4vYXJjLmpzXG4gKiogbW9kdWxlIGlkID0gMzJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlxuXG4gICAgdmFyIFBJMiA9IE1hdGguUEkgKiAyO1xuICAgIG1vZHVsZS5leHBvcnRzID0ge1xuICAgICAgICBub3JtYWxpemVSYWRpYW46IGZ1bmN0aW9uKGFuZ2xlKSB7XG4gICAgICAgICAgICBhbmdsZSAlPSBQSTI7XG4gICAgICAgICAgICBpZiAoYW5nbGUgPCAwKSB7XG4gICAgICAgICAgICAgICAgYW5nbGUgKz0gUEkyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFuZ2xlO1xuICAgICAgICB9XG4gICAgfTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3pyZW5kZXIvbGliL2NvbnRhaW4vdXRpbC5qc1xuICoqIG1vZHVsZSBpZCA9IDMzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHdpbmRpbmdMaW5lKHgwLCB5MCwgeDEsIHkxLCB4LCB5KSB7XG4gICAgICAgIGlmICgoeSA+IHkwICYmIHkgPiB5MSkgfHwgKHkgPCB5MCAmJiB5IDwgeTEpKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZ25vcmUgaG9yaXpvbnRhbCBsaW5lXG4gICAgICAgIGlmICh5MSA9PT0geTApIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkaXIgPSB5MSA8IHkwID8gMSA6IC0xO1xuICAgICAgICB2YXIgdCA9ICh5IC0geTApIC8gKHkxIC0geTApO1xuXG4gICAgICAgIC8vIEF2b2lkIHdpbmRpbmcgZXJyb3Igd2hlbiBpbnRlcnNlY3Rpb24gcG9pbnQgaXMgdGhlIGNvbm5lY3QgcG9pbnQgb2YgdHdvIGxpbmUgb2YgcG9seWdvblxuICAgICAgICBpZiAodCA9PT0gMSB8fCB0ID09PSAwKSB7XG4gICAgICAgICAgICBkaXIgPSB5MSA8IHkwID8gMC41IDogLTAuNTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB4XyA9IHQgKiAoeDEgLSB4MCkgKyB4MDtcblxuICAgICAgICByZXR1cm4geF8gPiB4ID8gZGlyIDogMDtcbiAgICB9O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34venJlbmRlci9saWIvY29udGFpbi93aW5kaW5nTGluZS5qc1xuICoqIG1vZHVsZSBpZCA9IDM0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcblxuICAgIHZhciBQYXR0ZXJuID0gZnVuY3Rpb24gKGltYWdlLCByZXBlYXQpIHtcbiAgICAgICAgdGhpcy5pbWFnZSA9IGltYWdlO1xuICAgICAgICB0aGlzLnJlcGVhdCA9IHJlcGVhdDtcblxuICAgICAgICAvLyBDYW4gYmUgY2xvbmVkXG4gICAgICAgIHRoaXMudHlwZSA9ICdwYXR0ZXJuJztcbiAgICB9O1xuXG4gICAgUGF0dGVybi5wcm90b3R5cGUuZ2V0Q2FudmFzUGF0dGVybiA9IGZ1bmN0aW9uIChjdHgpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5fY2FudmFzUGF0dGVyblxuICAgICAgICAgICAgfHwgKHRoaXMuX2NhbnZhc1BhdHRlcm4gPSBjdHguY3JlYXRlUGF0dGVybih0aGlzLmltYWdlLCB0aGlzLnJlcGVhdCkpO1xuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IFBhdHRlcm47XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi96cmVuZGVyL2xpYi9ncmFwaGljL1BhdHRlcm4uanNcbiAqKiBtb2R1bGUgaWQgPSAzNVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXG5cbiAgICB2YXIgQ01EID0gcmVxdWlyZSgnLi4vY29yZS9QYXRoUHJveHknKS5DTUQ7XG4gICAgdmFyIHZlYzIgPSByZXF1aXJlKCcuLi9jb3JlL3ZlY3RvcicpO1xuICAgIHZhciB2MkFwcGx5VHJhbnNmb3JtID0gdmVjMi5hcHBseVRyYW5zZm9ybTtcblxuICAgIHZhciBwb2ludHMgPSBbW10sIFtdLCBbXV07XG4gICAgdmFyIG1hdGhTcXJ0ID0gTWF0aC5zcXJ0O1xuICAgIHZhciBtYXRoQXRhbjIgPSBNYXRoLmF0YW4yO1xuICAgIGZ1bmN0aW9uIHRyYW5zZm9ybVBhdGgocGF0aCwgbSkge1xuICAgICAgICB2YXIgZGF0YSA9IHBhdGguZGF0YTtcbiAgICAgICAgdmFyIGNtZDtcbiAgICAgICAgdmFyIG5Qb2ludDtcbiAgICAgICAgdmFyIGk7XG4gICAgICAgIHZhciBqO1xuICAgICAgICB2YXIgaztcbiAgICAgICAgdmFyIHA7XG5cbiAgICAgICAgdmFyIE0gPSBDTUQuTTtcbiAgICAgICAgdmFyIEMgPSBDTUQuQztcbiAgICAgICAgdmFyIEwgPSBDTUQuTDtcbiAgICAgICAgdmFyIFIgPSBDTUQuUjtcbiAgICAgICAgdmFyIEEgPSBDTUQuQTtcbiAgICAgICAgdmFyIFEgPSBDTUQuUTtcblxuICAgICAgICBmb3IgKGkgPSAwLCBqID0gMDsgaSA8IGRhdGEubGVuZ3RoOykge1xuICAgICAgICAgICAgY21kID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgaiA9IGk7XG4gICAgICAgICAgICBuUG9pbnQgPSAwO1xuXG4gICAgICAgICAgICBzd2l0Y2ggKGNtZCkge1xuICAgICAgICAgICAgICAgIGNhc2UgTTpcbiAgICAgICAgICAgICAgICAgICAgblBvaW50ID0gMTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBMOlxuICAgICAgICAgICAgICAgICAgICBuUG9pbnQgPSAxO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIEM6XG4gICAgICAgICAgICAgICAgICAgIG5Qb2ludCA9IDM7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgUTpcbiAgICAgICAgICAgICAgICAgICAgblBvaW50ID0gMjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBBOlxuICAgICAgICAgICAgICAgICAgICB2YXIgeCA9IG1bNF07XG4gICAgICAgICAgICAgICAgICAgIHZhciB5ID0gbVs1XTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN4ID0gbWF0aFNxcnQobVswXSAqIG1bMF0gKyBtWzFdICogbVsxXSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzeSA9IG1hdGhTcXJ0KG1bMl0gKiBtWzJdICsgbVszXSAqIG1bM10pO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYW5nbGUgPSBtYXRoQXRhbjIoLW1bMV0gLyBzeSwgbVswXSAvIHN4KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gY3hcbiAgICAgICAgICAgICAgICAgICAgZGF0YVtpKytdICs9IHg7XG4gICAgICAgICAgICAgICAgICAgIC8vIGN5XG4gICAgICAgICAgICAgICAgICAgIGRhdGFbaSsrXSArPSB5O1xuICAgICAgICAgICAgICAgICAgICAvLyBTY2FsZSByeCBhbmQgcnlcbiAgICAgICAgICAgICAgICAgICAgLy8gRklYTUUgQXNzdW1lIHBzaSBpcyAwIGhlcmVcbiAgICAgICAgICAgICAgICAgICAgZGF0YVtpKytdICo9IHN4O1xuICAgICAgICAgICAgICAgICAgICBkYXRhW2krK10gKj0gc3k7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gU3RhcnQgYW5nbGVcbiAgICAgICAgICAgICAgICAgICAgZGF0YVtpKytdICs9IGFuZ2xlO1xuICAgICAgICAgICAgICAgICAgICAvLyBlbmQgYW5nbGVcbiAgICAgICAgICAgICAgICAgICAgZGF0YVtpKytdICs9IGFuZ2xlO1xuICAgICAgICAgICAgICAgICAgICAvLyBGSVhNRSBwc2lcbiAgICAgICAgICAgICAgICAgICAgaSArPSAyO1xuICAgICAgICAgICAgICAgICAgICBqID0gaTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBSOlxuICAgICAgICAgICAgICAgICAgICAvLyB4MCwgeTBcbiAgICAgICAgICAgICAgICAgICAgcFswXSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgcFsxXSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgdjJBcHBseVRyYW5zZm9ybShwLCBwLCBtKTtcbiAgICAgICAgICAgICAgICAgICAgZGF0YVtqKytdID0gcFswXTtcbiAgICAgICAgICAgICAgICAgICAgZGF0YVtqKytdID0gcFsxXTtcbiAgICAgICAgICAgICAgICAgICAgLy8geDEsIHkxXG4gICAgICAgICAgICAgICAgICAgIHBbMF0gKz0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICBwWzFdICs9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgdjJBcHBseVRyYW5zZm9ybShwLCBwLCBtKTtcbiAgICAgICAgICAgICAgICAgICAgZGF0YVtqKytdID0gcFswXTtcbiAgICAgICAgICAgICAgICAgICAgZGF0YVtqKytdID0gcFsxXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yIChrID0gMDsgayA8IG5Qb2ludDsgaysrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHAgPSBwb2ludHNba107XG4gICAgICAgICAgICAgICAgcFswXSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICBwWzFdID0gZGF0YVtpKytdO1xuXG4gICAgICAgICAgICAgICAgdjJBcHBseVRyYW5zZm9ybShwLCBwLCBtKTtcbiAgICAgICAgICAgICAgICAvLyBXcml0ZSBiYWNrXG4gICAgICAgICAgICAgICAgZGF0YVtqKytdID0gcFswXTtcbiAgICAgICAgICAgICAgICBkYXRhW2orK10gPSBwWzFdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB0cmFuc2Zvcm1QYXRoO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34venJlbmRlci9saWIvdG9vbC90cmFuc2Zvcm1QYXRoLmpzXG4gKiogbW9kdWxlIGlkID0gMzZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtBcnJheS48T2JqZWN0Pn0gY29sb3JTdG9wc1xuICAgICAqL1xuICAgIHZhciBHcmFkaWVudCA9IGZ1bmN0aW9uIChjb2xvclN0b3BzKSB7XG5cbiAgICAgICAgdGhpcy5jb2xvclN0b3BzID0gY29sb3JTdG9wcyB8fCBbXTtcbiAgICB9O1xuXG4gICAgR3JhZGllbnQucHJvdG90eXBlID0ge1xuXG4gICAgICAgIGNvbnN0cnVjdG9yOiBHcmFkaWVudCxcblxuICAgICAgICBhZGRDb2xvclN0b3A6IGZ1bmN0aW9uIChvZmZzZXQsIGNvbG9yKSB7XG4gICAgICAgICAgICB0aGlzLmNvbG9yU3RvcHMucHVzaCh7XG5cbiAgICAgICAgICAgICAgICBvZmZzZXQ6IG9mZnNldCxcblxuICAgICAgICAgICAgICAgIGNvbG9yOiBjb2xvclxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBHcmFkaWVudDtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvR3JhZGllbnQuanNcbiAqKiBtb2R1bGUgaWQgPSAzN1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gVE9ETyBEcmFnZ2FibGUgZm9yIGdyb3VwXG4vLyBGSVhNRSBEcmFnZ2FibGUgb24gZWxlbWVudCB3aGljaCBoYXMgcGFyZW50IHJvdGF0aW9uIG9yIHNjYWxlXG5cbiAgICBmdW5jdGlvbiBEcmFnZ2FibGUoKSB7XG5cbiAgICAgICAgdGhpcy5vbignbW91c2Vkb3duJywgdGhpcy5fZHJhZ1N0YXJ0LCB0aGlzKTtcbiAgICAgICAgdGhpcy5vbignbW91c2Vtb3ZlJywgdGhpcy5fZHJhZywgdGhpcyk7XG4gICAgICAgIHRoaXMub24oJ21vdXNldXAnLCB0aGlzLl9kcmFnRW5kLCB0aGlzKTtcbiAgICAgICAgdGhpcy5vbignZ2xvYmFsb3V0JywgdGhpcy5fZHJhZ0VuZCwgdGhpcyk7XG4gICAgICAgIC8vIHRoaXMuX2Ryb3BUYXJnZXQgPSBudWxsO1xuICAgICAgICAvLyB0aGlzLl9kcmFnZ2luZ1RhcmdldCA9IG51bGw7XG5cbiAgICAgICAgLy8gdGhpcy5feCA9IDA7XG4gICAgICAgIC8vIHRoaXMuX3kgPSAwO1xuICAgIH1cblxuICAgIERyYWdnYWJsZS5wcm90b3R5cGUgPSB7XG5cbiAgICAgICAgY29uc3RydWN0b3I6IERyYWdnYWJsZSxcblxuICAgICAgICBfZHJhZ1N0YXJ0OiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgdmFyIGRyYWdnaW5nVGFyZ2V0ID0gZS50YXJnZXQ7XG4gICAgICAgICAgICBpZiAoZHJhZ2dpbmdUYXJnZXQgJiYgZHJhZ2dpbmdUYXJnZXQuZHJhZ2dhYmxlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZHJhZ2dpbmdUYXJnZXQgPSBkcmFnZ2luZ1RhcmdldDtcbiAgICAgICAgICAgICAgICBkcmFnZ2luZ1RhcmdldC5kcmFnZ2luZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5feCA9IGUub2Zmc2V0WDtcbiAgICAgICAgICAgICAgICB0aGlzLl95ID0gZS5vZmZzZXRZO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaFRvRWxlbWVudChkcmFnZ2luZ1RhcmdldCwgJ2RyYWdzdGFydCcsIGUuZXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIF9kcmFnOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgdmFyIGRyYWdnaW5nVGFyZ2V0ID0gdGhpcy5fZHJhZ2dpbmdUYXJnZXQ7XG4gICAgICAgICAgICBpZiAoZHJhZ2dpbmdUYXJnZXQpIHtcblxuICAgICAgICAgICAgICAgIHZhciB4ID0gZS5vZmZzZXRYO1xuICAgICAgICAgICAgICAgIHZhciB5ID0gZS5vZmZzZXRZO1xuXG4gICAgICAgICAgICAgICAgdmFyIGR4ID0geCAtIHRoaXMuX3g7XG4gICAgICAgICAgICAgICAgdmFyIGR5ID0geSAtIHRoaXMuX3k7XG4gICAgICAgICAgICAgICAgdGhpcy5feCA9IHg7XG4gICAgICAgICAgICAgICAgdGhpcy5feSA9IHk7XG5cbiAgICAgICAgICAgICAgICBkcmFnZ2luZ1RhcmdldC5kcmlmdChkeCwgZHksIGUpO1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hUb0VsZW1lbnQoZHJhZ2dpbmdUYXJnZXQsICdkcmFnJywgZS5ldmVudCk7XG5cbiAgICAgICAgICAgICAgICB2YXIgZHJvcFRhcmdldCA9IHRoaXMuZmluZEhvdmVyKHgsIHksIGRyYWdnaW5nVGFyZ2V0KTtcbiAgICAgICAgICAgICAgICB2YXIgbGFzdERyb3BUYXJnZXQgPSB0aGlzLl9kcm9wVGFyZ2V0O1xuICAgICAgICAgICAgICAgIHRoaXMuX2Ryb3BUYXJnZXQgPSBkcm9wVGFyZ2V0O1xuXG4gICAgICAgICAgICAgICAgaWYgKGRyYWdnaW5nVGFyZ2V0ICE9PSBkcm9wVGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsYXN0RHJvcFRhcmdldCAmJiBkcm9wVGFyZ2V0ICE9PSBsYXN0RHJvcFRhcmdldCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaFRvRWxlbWVudChsYXN0RHJvcFRhcmdldCwgJ2RyYWdsZWF2ZScsIGUuZXZlbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChkcm9wVGFyZ2V0ICYmIGRyb3BUYXJnZXQgIT09IGxhc3REcm9wVGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoVG9FbGVtZW50KGRyb3BUYXJnZXQsICdkcmFnZW50ZXInLCBlLmV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBfZHJhZ0VuZDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHZhciBkcmFnZ2luZ1RhcmdldCA9IHRoaXMuX2RyYWdnaW5nVGFyZ2V0O1xuXG4gICAgICAgICAgICBpZiAoZHJhZ2dpbmdUYXJnZXQpIHtcbiAgICAgICAgICAgICAgICBkcmFnZ2luZ1RhcmdldC5kcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoVG9FbGVtZW50KGRyYWdnaW5nVGFyZ2V0LCAnZHJhZ2VuZCcsIGUuZXZlbnQpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5fZHJvcFRhcmdldCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hUb0VsZW1lbnQodGhpcy5fZHJvcFRhcmdldCwgJ2Ryb3AnLCBlLmV2ZW50KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5fZHJhZ2dpbmdUYXJnZXQgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5fZHJvcFRhcmdldCA9IG51bGw7XG4gICAgICAgIH1cblxuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IERyYWdnYWJsZTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3pyZW5kZXIvbGliL21peGluL0RyYWdnYWJsZS5qc1xuICoqIG1vZHVsZSBpZCA9IDM4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIEdyb3Vw5piv5LiA5Liq5a655Zmo77yM5Y+v5Lul5o+S5YWl5a2Q6IqC54K577yMR3JvdXDnmoTlj5jmjaLkuZ/kvJrooqvlupTnlKjliLDlrZDoioLngrnkuIpcbiAqIEBtb2R1bGUgenJlbmRlci9ncmFwaGljL0dyb3VwXG4gKiBAZXhhbXBsZVxuICogICAgIHZhciBHcm91cCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvbnRhaW5lci9Hcm91cCcpO1xuICogICAgIHZhciBDaXJjbGUgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL0NpcmNsZScpO1xuICogICAgIHZhciBnID0gbmV3IEdyb3VwKCk7XG4gKiAgICAgZy5wb3NpdGlvblswXSA9IDEwMDtcbiAqICAgICBnLnBvc2l0aW9uWzFdID0gMTAwO1xuICogICAgIGcuYWRkKG5ldyBDaXJjbGUoe1xuICogICAgICAgICBzdHlsZToge1xuICogICAgICAgICAgICAgeDogMTAwLFxuICogICAgICAgICAgICAgeTogMTAwLFxuICogICAgICAgICAgICAgcjogMjAsXG4gKiAgICAgICAgIH1cbiAqICAgICB9KSk7XG4gKiAgICAgenIuYWRkKGcpO1xuICovXG5cblxuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCcuLi9jb3JlL3V0aWwnKTtcbiAgICB2YXIgRWxlbWVudCA9IHJlcXVpcmUoJy4uL0VsZW1lbnQnKTtcbiAgICB2YXIgQm91bmRpbmdSZWN0ID0gcmVxdWlyZSgnLi4vY29yZS9Cb3VuZGluZ1JlY3QnKTtcblxuICAgIC8qKlxuICAgICAqIEBhbGlhcyBtb2R1bGU6enJlbmRlci9ncmFwaGljL0dyb3VwXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQGV4dGVuZHMgbW9kdWxlOnpyZW5kZXIvbWl4aW4vVHJhbnNmb3JtYWJsZVxuICAgICAqIEBleHRlbmRzIG1vZHVsZTp6cmVuZGVyL21peGluL0V2ZW50ZnVsXG4gICAgICovXG4gICAgdmFyIEdyb3VwID0gZnVuY3Rpb24gKG9wdHMpIHtcblxuICAgICAgICBvcHRzID0gb3B0cyB8fCB7fTtcblxuICAgICAgICBFbGVtZW50LmNhbGwodGhpcywgb3B0cyk7XG5cbiAgICAgICAgZm9yICh2YXIga2V5IGluIG9wdHMpIHtcbiAgICAgICAgICAgIHRoaXNba2V5XSA9IG9wdHNba2V5XTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2NoaWxkcmVuID0gW107XG5cbiAgICAgICAgdGhpcy5fX3N0b3JhZ2UgPSBudWxsO1xuXG4gICAgICAgIHRoaXMuX19kaXJ0eSA9IHRydWU7XG4gICAgfTtcblxuICAgIEdyb3VwLnByb3RvdHlwZSA9IHtcblxuICAgICAgICBjb25zdHJ1Y3RvcjogR3JvdXAsXG5cbiAgICAgICAgaXNHcm91cDogdHJ1ZSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIHR5cGU6ICdncm91cCcsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOaJgOacieWtkOWtmeWFg+e0oOaYr+WQpuWTjeW6lOm8oOagh+S6i+S7tlxuICAgICAgICAgKiBAbmFtZSBtb2R1bGU6L3pyZW5kZXIvY29udGFpbmVyL0dyb3VwI3NpbGVudFxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIHNpbGVudDogZmFsc2UsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4ge0FycmF5Ljxtb2R1bGU6enJlbmRlci9FbGVtZW50Pn1cbiAgICAgICAgICovXG4gICAgICAgIGNoaWxkcmVuOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY2hpbGRyZW4uc2xpY2UoKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog6I635Y+W5oyH5a6aIGluZGV4IOeahOWEv+WtkOiKgueCuVxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IGlkeFxuICAgICAgICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9FbGVtZW50fVxuICAgICAgICAgKi9cbiAgICAgICAgY2hpbGRBdDogZnVuY3Rpb24gKGlkeCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NoaWxkcmVuW2lkeF07XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOiOt+WPluaMh+WumuWQjeWtl+eahOWEv+WtkOiKgueCuVxuICAgICAgICAgKiBAcGFyYW0gIHtzdHJpbmd9IG5hbWVcbiAgICAgICAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvRWxlbWVudH1cbiAgICAgICAgICovXG4gICAgICAgIGNoaWxkT2ZOYW1lOiBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgdmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW47XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkcmVuW2ldLm5hbWUgPT09IG5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIGNoaWxkQ291bnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOa3u+WKoOWtkOiKgueCueWIsOacgOWQjlxuICAgICAgICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL0VsZW1lbnR9IGNoaWxkXG4gICAgICAgICAqL1xuICAgICAgICBhZGQ6IGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICAgICAgaWYgKGNoaWxkICYmIGNoaWxkICE9PSB0aGlzICYmIGNoaWxkLnBhcmVudCAhPT0gdGhpcykge1xuXG4gICAgICAgICAgICAgICAgdGhpcy5fY2hpbGRyZW4ucHVzaChjaGlsZCk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9kb0FkZChjaGlsZCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmt7vliqDlrZDoioLngrnlnKggbmV4dFNpYmxpbmcg5LmL5YmNXG4gICAgICAgICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvRWxlbWVudH0gY2hpbGRcbiAgICAgICAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9FbGVtZW50fSBuZXh0U2libGluZ1xuICAgICAgICAgKi9cbiAgICAgICAgYWRkQmVmb3JlOiBmdW5jdGlvbiAoY2hpbGQsIG5leHRTaWJsaW5nKSB7XG4gICAgICAgICAgICBpZiAoY2hpbGQgJiYgY2hpbGQgIT09IHRoaXMgJiYgY2hpbGQucGFyZW50ICE9PSB0aGlzXG4gICAgICAgICAgICAgICAgJiYgbmV4dFNpYmxpbmcgJiYgbmV4dFNpYmxpbmcucGFyZW50ID09PSB0aGlzKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbjtcbiAgICAgICAgICAgICAgICB2YXIgaWR4ID0gY2hpbGRyZW4uaW5kZXhPZihuZXh0U2libGluZyk7XG5cbiAgICAgICAgICAgICAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW4uc3BsaWNlKGlkeCwgMCwgY2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kb0FkZChjaGlsZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBfZG9BZGQ6IGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICAgICAgaWYgKGNoaWxkLnBhcmVudCkge1xuICAgICAgICAgICAgICAgIGNoaWxkLnBhcmVudC5yZW1vdmUoY2hpbGQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjaGlsZC5wYXJlbnQgPSB0aGlzO1xuXG4gICAgICAgICAgICB2YXIgc3RvcmFnZSA9IHRoaXMuX19zdG9yYWdlO1xuICAgICAgICAgICAgdmFyIHpyID0gdGhpcy5fX3pyO1xuICAgICAgICAgICAgaWYgKHN0b3JhZ2UgJiYgc3RvcmFnZSAhPT0gY2hpbGQuX19zdG9yYWdlKSB7XG5cbiAgICAgICAgICAgICAgICBzdG9yYWdlLmFkZFRvTWFwKGNoaWxkKTtcblxuICAgICAgICAgICAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIEdyb3VwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkLmFkZENoaWxkcmVuVG9TdG9yYWdlKHN0b3JhZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgenIgJiYgenIucmVmcmVzaCgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDnp7vpmaTlrZDoioLngrlcbiAgICAgICAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9FbGVtZW50fSBjaGlsZFxuICAgICAgICAgKi9cbiAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICAgIHZhciB6ciA9IHRoaXMuX196cjtcbiAgICAgICAgICAgIHZhciBzdG9yYWdlID0gdGhpcy5fX3N0b3JhZ2U7XG4gICAgICAgICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbjtcblxuICAgICAgICAgICAgdmFyIGlkeCA9IHpyVXRpbC5pbmRleE9mKGNoaWxkcmVuLCBjaGlsZCk7XG4gICAgICAgICAgICBpZiAoaWR4IDwgMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2hpbGRyZW4uc3BsaWNlKGlkeCwgMSk7XG5cbiAgICAgICAgICAgIGNoaWxkLnBhcmVudCA9IG51bGw7XG5cbiAgICAgICAgICAgIGlmIChzdG9yYWdlKSB7XG5cbiAgICAgICAgICAgICAgICBzdG9yYWdlLmRlbEZyb21NYXAoY2hpbGQuaWQpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgR3JvdXApIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQuZGVsQ2hpbGRyZW5Gcm9tU3RvcmFnZShzdG9yYWdlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHpyICYmIHpyLnJlZnJlc2goKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOenu+mZpOaJgOacieWtkOiKgueCuVxuICAgICAgICAgKi9cbiAgICAgICAgcmVtb3ZlQWxsOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbjtcbiAgICAgICAgICAgIHZhciBzdG9yYWdlID0gdGhpcy5fX3N0b3JhZ2U7XG4gICAgICAgICAgICB2YXIgY2hpbGQ7XG4gICAgICAgICAgICB2YXIgaTtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgaWYgKHN0b3JhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RvcmFnZS5kZWxGcm9tTWFwKGNoaWxkLmlkKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgR3JvdXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkLmRlbENoaWxkcmVuRnJvbVN0b3JhZ2Uoc3RvcmFnZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2hpbGQucGFyZW50ID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNoaWxkcmVuLmxlbmd0aCA9IDA7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDpgY3ljobmiYDmnInlrZDoioLngrlcbiAgICAgICAgICogQHBhcmFtICB7RnVuY3Rpb259IGNiXG4gICAgICAgICAqIEBwYXJhbSAge30gICBjb250ZXh0XG4gICAgICAgICAqL1xuICAgICAgICBlYWNoQ2hpbGQ6IGZ1bmN0aW9uIChjYiwgY29udGV4dCkge1xuICAgICAgICAgICAgdmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW47XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgY2IuY2FsbChjb250ZXh0LCBjaGlsZCwgaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5rex5bqm5LyY5YWI6YGN5Y6G5omA5pyJ5a2Q5a2Z6IqC54K5XG4gICAgICAgICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBjYlxuICAgICAgICAgKiBAcGFyYW0gIHt9ICAgY29udGV4dFxuICAgICAgICAgKi9cbiAgICAgICAgdHJhdmVyc2U6IGZ1bmN0aW9uIChjYiwgY29udGV4dCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBjaGlsZCA9IHRoaXMuX2NoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgIGNiLmNhbGwoY29udGV4dCwgY2hpbGQpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkLnR5cGUgPT09ICdncm91cCcpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQudHJhdmVyc2UoY2IsIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGFkZENoaWxkcmVuVG9TdG9yYWdlOiBmdW5jdGlvbiAoc3RvcmFnZSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBjaGlsZCA9IHRoaXMuX2NoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgIHN0b3JhZ2UuYWRkVG9NYXAoY2hpbGQpO1xuICAgICAgICAgICAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIEdyb3VwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkLmFkZENoaWxkcmVuVG9TdG9yYWdlKHN0b3JhZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBkZWxDaGlsZHJlbkZyb21TdG9yYWdlOiBmdW5jdGlvbiAoc3RvcmFnZSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBjaGlsZCA9IHRoaXMuX2NoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgIHN0b3JhZ2UuZGVsRnJvbU1hcChjaGlsZC5pZCk7XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgR3JvdXApIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQuZGVsQ2hpbGRyZW5Gcm9tU3RvcmFnZShzdG9yYWdlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgZGlydHk6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX19kaXJ0eSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9fenIgJiYgdGhpcy5fX3pyLnJlZnJlc2goKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9jb3JlL0JvdW5kaW5nUmVjdH1cbiAgICAgICAgICovXG4gICAgICAgIGdldEJvdW5kaW5nUmVjdDogZnVuY3Rpb24gKGluY2x1ZGVDaGlsZHJlbikge1xuICAgICAgICAgICAgLy8gVE9ETyBDYWNoaW5nXG4gICAgICAgICAgICAvLyBUT0RPIFRyYW5zZm9ybVxuICAgICAgICAgICAgdmFyIHJlY3QgPSBudWxsO1xuICAgICAgICAgICAgdmFyIHRtcFJlY3QgPSBuZXcgQm91bmRpbmdSZWN0KDAsIDAsIDAsIDApO1xuICAgICAgICAgICAgdmFyIGNoaWxkcmVuID0gaW5jbHVkZUNoaWxkcmVuIHx8IHRoaXMuX2NoaWxkcmVuO1xuICAgICAgICAgICAgdmFyIHRtcE1hdCA9IFtdO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkLmlnbm9yZSB8fCBjaGlsZC5pbnZpc2libGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkUmVjdCA9IGNoaWxkLmdldEJvdW5kaW5nUmVjdCgpO1xuICAgICAgICAgICAgICAgIHZhciB0cmFuc2Zvcm0gPSBjaGlsZC5nZXRMb2NhbFRyYW5zZm9ybSh0bXBNYXQpO1xuICAgICAgICAgICAgICAgIGlmICh0cmFuc2Zvcm0pIHtcbiAgICAgICAgICAgICAgICAgICAgdG1wUmVjdC5jb3B5KGNoaWxkUmVjdCk7XG4gICAgICAgICAgICAgICAgICAgIHRtcFJlY3QuYXBwbHlUcmFuc2Zvcm0odHJhbnNmb3JtKTtcbiAgICAgICAgICAgICAgICAgICAgcmVjdCA9IHJlY3QgfHwgdG1wUmVjdC5jbG9uZSgpO1xuICAgICAgICAgICAgICAgICAgICByZWN0LnVuaW9uKHRtcFJlY3QpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVjdCA9IHJlY3QgfHwgY2hpbGRSZWN0LmNsb25lKCk7XG4gICAgICAgICAgICAgICAgICAgIHJlY3QudW5pb24oY2hpbGRSZWN0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVjdCB8fCB0bXBSZWN0O1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHpyVXRpbC5pbmhlcml0cyhHcm91cCwgRWxlbWVudCk7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IEdyb3VwO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34venJlbmRlci9saWIvY29udGFpbmVyL0dyb3VwLmpzXG4gKiogbW9kdWxlIGlkID0gMzlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogSW1hZ2UgZWxlbWVudFxuICogQG1vZHVsZSB6cmVuZGVyL2dyYXBoaWMvSW1hZ2VcbiAqL1xuXG5cblxuICAgIHZhciBEaXNwbGF5YWJsZSA9IHJlcXVpcmUoJy4vRGlzcGxheWFibGUnKTtcbiAgICB2YXIgQm91bmRpbmdSZWN0ID0gcmVxdWlyZSgnLi4vY29yZS9Cb3VuZGluZ1JlY3QnKTtcbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnLi4vY29yZS91dGlsJyk7XG5cbiAgICB2YXIgTFJVID0gcmVxdWlyZSgnLi4vY29yZS9MUlUnKTtcbiAgICB2YXIgZ2xvYmFsSW1hZ2VDYWNoZSA9IG5ldyBMUlUoNTApO1xuICAgIC8qKlxuICAgICAqIEBhbGlhcyB6cmVuZGVyL2dyYXBoaWMvSW1hZ2VcbiAgICAgKiBAZXh0ZW5kcyBtb2R1bGU6enJlbmRlci9ncmFwaGljL0Rpc3BsYXlhYmxlXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBaSW1hZ2Uob3B0cykge1xuICAgICAgICBEaXNwbGF5YWJsZS5jYWxsKHRoaXMsIG9wdHMpO1xuICAgIH1cblxuICAgIFpJbWFnZS5wcm90b3R5cGUgPSB7XG5cbiAgICAgICAgY29uc3RydWN0b3I6IFpJbWFnZSxcblxuICAgICAgICB0eXBlOiAnaW1hZ2UnLFxuXG4gICAgICAgIGJydXNoOiBmdW5jdGlvbiAoY3R4LCBwcmV2RWwpIHtcbiAgICAgICAgICAgIHZhciBzdHlsZSA9IHRoaXMuc3R5bGU7XG4gICAgICAgICAgICB2YXIgc3JjID0gc3R5bGUuaW1hZ2U7XG4gICAgICAgICAgICB2YXIgaW1hZ2U7XG5cbiAgICAgICAgICAgIC8vIE11c3QgYmluZCBlYWNoIHRpbWVcbiAgICAgICAgICAgIHN0eWxlLmJpbmQoY3R4LCB0aGlzLCBwcmV2RWwpO1xuICAgICAgICAgICAgLy8gc3R5bGUuaW1hZ2UgaXMgYSB1cmwgc3RyaW5nXG4gICAgICAgICAgICBpZiAodHlwZW9mIHNyYyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBpbWFnZSA9IHRoaXMuX2ltYWdlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gc3R5bGUuaW1hZ2UgaXMgYW4gSFRNTEltYWdlRWxlbWVudCBvciBIVE1MQ2FudmFzRWxlbWVudCBvciBDYW52YXNcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGltYWdlID0gc3JjO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRklYTUUgQ2FzZSBjcmVhdGUgbWFueSBpbWFnZXMgd2l0aCBzcmNcbiAgICAgICAgICAgIGlmICghaW1hZ2UgJiYgc3JjKSB7XG4gICAgICAgICAgICAgICAgLy8gVHJ5IGdldCBmcm9tIGdsb2JhbCBpbWFnZSBjYWNoZVxuICAgICAgICAgICAgICAgIHZhciBjYWNoZWRJbWdPYmogPSBnbG9iYWxJbWFnZUNhY2hlLmdldChzcmMpO1xuICAgICAgICAgICAgICAgIGlmICghY2FjaGVkSW1nT2JqKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBhIG5ldyBpbWFnZVxuICAgICAgICAgICAgICAgICAgICBpbWFnZSA9IG5ldyBJbWFnZSgpO1xuICAgICAgICAgICAgICAgICAgICBpbWFnZS5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbWFnZS5vbmxvYWQgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYWNoZWRJbWdPYmoucGVuZGluZy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlZEltZ09iai5wZW5kaW5nW2ldLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGNhY2hlZEltZ09iaiA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlOiBpbWFnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBlbmRpbmc6IFt0aGlzXVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBpbWFnZS5zcmMgPSBzcmM7XG4gICAgICAgICAgICAgICAgICAgIGdsb2JhbEltYWdlQ2FjaGUucHV0KHNyYywgY2FjaGVkSW1nT2JqKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faW1hZ2UgPSBpbWFnZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaW1hZ2UgPSBjYWNoZWRJbWdPYmouaW1hZ2U7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2ltYWdlID0gaW1hZ2U7XG4gICAgICAgICAgICAgICAgICAgIC8vIEltYWdlIGlzIG5vdCBjb21wbGV0ZSBmaW5pc2gsIGFkZCB0byBwZW5kaW5nIGxpc3RcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpbWFnZS53aWR0aCB8fCAhaW1hZ2UuaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWNoZWRJbWdPYmoucGVuZGluZy5wdXNoKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaW1hZ2UpIHtcbiAgICAgICAgICAgICAgICAvLyDlm77niYflt7Lnu4/liqDovb3lrozmiJBcbiAgICAgICAgICAgICAgICAvLyBpZiAoaW1hZ2Uubm9kZU5hbWUudG9VcHBlckNhc2UoKSA9PSAnSU1HJykge1xuICAgICAgICAgICAgICAgIC8vICAgICBpZiAoIWltYWdlLmNvbXBsZXRlKSB7XG4gICAgICAgICAgICAgICAgLy8gICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgLy8gICAgIH1cbiAgICAgICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICAgICAgLy8gRWxzZSBpcyBjYW52YXNcblxuICAgICAgICAgICAgICAgIHZhciB3aWR0aCA9IHN0eWxlLndpZHRoIHx8IGltYWdlLndpZHRoO1xuICAgICAgICAgICAgICAgIHZhciBoZWlnaHQgPSBzdHlsZS5oZWlnaHQgfHwgaW1hZ2UuaGVpZ2h0O1xuICAgICAgICAgICAgICAgIHZhciB4ID0gc3R5bGUueCB8fCAwO1xuICAgICAgICAgICAgICAgIHZhciB5ID0gc3R5bGUueSB8fCAwO1xuICAgICAgICAgICAgICAgIC8vIOWbvueJh+WKoOi9veWksei0pVxuICAgICAgICAgICAgICAgIGlmICghaW1hZ2Uud2lkdGggfHwgIWltYWdlLmhlaWdodCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8g6K6+572udHJhbnNmb3JtXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRUcmFuc2Zvcm0oY3R4KTtcblxuXG4gICAgICAgICAgICAgICAgaWYgKHN0eWxlLnNXaWR0aCAmJiBzdHlsZS5zSGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzeCA9IHN0eWxlLnN4IHx8IDA7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzeSA9IHN0eWxlLnN5IHx8IDA7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5kcmF3SW1hZ2UoXG4gICAgICAgICAgICAgICAgICAgICAgICBpbWFnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN4LCBzeSwgc3R5bGUuc1dpZHRoLCBzdHlsZS5zSGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgeCwgeSwgd2lkdGgsIGhlaWdodFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzdHlsZS5zeCAmJiBzdHlsZS5zeSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3ggPSBzdHlsZS5zeDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN5ID0gc3R5bGUuc3k7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzV2lkdGggPSB3aWR0aCAtIHN4O1xuICAgICAgICAgICAgICAgICAgICB2YXIgc0hlaWdodCA9IGhlaWdodCAtIHN5O1xuICAgICAgICAgICAgICAgICAgICBjdHguZHJhd0ltYWdlKFxuICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBzeCwgc3ksIHNXaWR0aCwgc0hlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHgsIHksIHdpZHRoLCBoZWlnaHRcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5kcmF3SW1hZ2UoaW1hZ2UsIHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIOWmguaenOayoeiuvue9ruWuveWSjOmrmOeahOivneiHquWKqOagueaNruWbvueJh+WuvemrmOiuvue9rlxuICAgICAgICAgICAgICAgIGlmIChzdHlsZS53aWR0aCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlLndpZHRoID0gd2lkdGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzdHlsZS5oZWlnaHQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBzdHlsZS5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5yZXN0b3JlVHJhbnNmb3JtKGN0eCk7XG5cbiAgICAgICAgICAgICAgICAvLyBEcmF3IHJlY3QgdGV4dFxuICAgICAgICAgICAgICAgIGlmIChzdHlsZS50ZXh0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3UmVjdFRleHQoY3R4LCB0aGlzLmdldEJvdW5kaW5nUmVjdCgpKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBnZXRCb3VuZGluZ1JlY3Q6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBzdHlsZSA9IHRoaXMuc3R5bGU7XG4gICAgICAgICAgICBpZiAoISB0aGlzLl9yZWN0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVjdCA9IG5ldyBCb3VuZGluZ1JlY3QoXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlLnggfHwgMCwgc3R5bGUueSB8fCAwLCBzdHlsZS53aWR0aCB8fCAwLCBzdHlsZS5oZWlnaHQgfHwgMFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVjdDtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB6clV0aWwuaW5oZXJpdHMoWkltYWdlLCBEaXNwbGF5YWJsZSk7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IFpJbWFnZTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvSW1hZ2UuanNcbiAqKiBtb2R1bGUgaWQgPSA0MFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gU2ltcGxlIExSVSBjYWNoZSB1c2UgZG91Ymx5IGxpbmtlZCBsaXN0XG4vLyBAbW9kdWxlIHpyZW5kZXIvY29yZS9MUlVcblxuXG4gICAgLyoqXG4gICAgICogU2ltcGxlIGRvdWJsZSBsaW5rZWQgbGlzdC4gQ29tcGFyZWQgd2l0aCBhcnJheSwgaXQgaGFzIE8oMSkgcmVtb3ZlIG9wZXJhdGlvbi5cbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKi9cbiAgICB2YXIgTGlua2VkTGlzdCA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7bW9kdWxlOnpyZW5kZXIvY29yZS9MUlV+RW50cnl9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmhlYWQgPSBudWxsO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7bW9kdWxlOnpyZW5kZXIvY29yZS9MUlV+RW50cnl9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnRhaWwgPSBudWxsO1xuXG4gICAgICAgIHRoaXMuX2xlbiA9IDA7XG4gICAgfTtcblxuICAgIHZhciBsaW5rZWRMaXN0UHJvdG8gPSBMaW5rZWRMaXN0LnByb3RvdHlwZTtcbiAgICAvKipcbiAgICAgKiBJbnNlcnQgYSBuZXcgdmFsdWUgYXQgdGhlIHRhaWxcbiAgICAgKiBAcGFyYW0gIHt9IHZhbFxuICAgICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2NvcmUvTFJVfkVudHJ5fVxuICAgICAqL1xuICAgIGxpbmtlZExpc3RQcm90by5pbnNlcnQgPSBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gbmV3IEVudHJ5KHZhbCk7XG4gICAgICAgIHRoaXMuaW5zZXJ0RW50cnkoZW50cnkpO1xuICAgICAgICByZXR1cm4gZW50cnk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEluc2VydCBhbiBlbnRyeSBhdCB0aGUgdGFpbFxuICAgICAqIEBwYXJhbSAge21vZHVsZTp6cmVuZGVyL2NvcmUvTFJVfkVudHJ5fSBlbnRyeVxuICAgICAqL1xuICAgIGxpbmtlZExpc3RQcm90by5pbnNlcnRFbnRyeSA9IGZ1bmN0aW9uKGVudHJ5KSB7XG4gICAgICAgIGlmICghdGhpcy5oZWFkKSB7XG4gICAgICAgICAgICB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBlbnRyeTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudGFpbC5uZXh0ID0gZW50cnk7XG4gICAgICAgICAgICBlbnRyeS5wcmV2ID0gdGhpcy50YWlsO1xuICAgICAgICAgICAgdGhpcy50YWlsID0gZW50cnk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbGVuKys7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBlbnRyeS5cbiAgICAgKiBAcGFyYW0gIHttb2R1bGU6enJlbmRlci9jb3JlL0xSVX5FbnRyeX0gZW50cnlcbiAgICAgKi9cbiAgICBsaW5rZWRMaXN0UHJvdG8ucmVtb3ZlID0gZnVuY3Rpb24oZW50cnkpIHtcbiAgICAgICAgdmFyIHByZXYgPSBlbnRyeS5wcmV2O1xuICAgICAgICB2YXIgbmV4dCA9IGVudHJ5Lm5leHQ7XG4gICAgICAgIGlmIChwcmV2KSB7XG4gICAgICAgICAgICBwcmV2Lm5leHQgPSBuZXh0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gSXMgaGVhZFxuICAgICAgICAgICAgdGhpcy5oZWFkID0gbmV4dDtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmV4dCkge1xuICAgICAgICAgICAgbmV4dC5wcmV2ID0gcHJldjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIElzIHRhaWxcbiAgICAgICAgICAgIHRoaXMudGFpbCA9IHByZXY7XG4gICAgICAgIH1cbiAgICAgICAgZW50cnkubmV4dCA9IGVudHJ5LnByZXYgPSBudWxsO1xuICAgICAgICB0aGlzLl9sZW4tLTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAqL1xuICAgIGxpbmtlZExpc3RQcm90by5sZW4gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xlbjtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHt9IHZhbFxuICAgICAqL1xuICAgIHZhciBFbnRyeSA9IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge31cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWw7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHttb2R1bGU6enJlbmRlci9jb3JlL0xSVX5FbnRyeX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubmV4dDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge21vZHVsZTp6cmVuZGVyL2NvcmUvTFJVfkVudHJ5fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wcmV2O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBMUlUgQ2FjaGVcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAYWxpYXMgbW9kdWxlOnpyZW5kZXIvY29yZS9MUlVcbiAgICAgKi9cbiAgICB2YXIgTFJVID0gZnVuY3Rpb24obWF4U2l6ZSkge1xuXG4gICAgICAgIHRoaXMuX2xpc3QgPSBuZXcgTGlua2VkTGlzdCgpO1xuXG4gICAgICAgIHRoaXMuX21hcCA9IHt9O1xuXG4gICAgICAgIHRoaXMuX21heFNpemUgPSBtYXhTaXplIHx8IDEwO1xuICAgIH07XG5cbiAgICB2YXIgTFJVUHJvdG8gPSBMUlUucHJvdG90eXBlO1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtICB7c3RyaW5nfSBrZXlcbiAgICAgKiBAcGFyYW0gIHt9IHZhbHVlXG4gICAgICovXG4gICAgTFJVUHJvdG8ucHV0ID0gZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgICB2YXIgbGlzdCA9IHRoaXMuX2xpc3Q7XG4gICAgICAgIHZhciBtYXAgPSB0aGlzLl9tYXA7XG4gICAgICAgIGlmIChtYXBba2V5XSA9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgbGVuID0gbGlzdC5sZW4oKTtcbiAgICAgICAgICAgIGlmIChsZW4gPj0gdGhpcy5fbWF4U2l6ZSAmJiBsZW4gPiAwKSB7XG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBsZWFzdCByZWNlbnRseSB1c2VkXG4gICAgICAgICAgICAgICAgdmFyIGxlYXN0VXNlZEVudHJ5ID0gbGlzdC5oZWFkO1xuICAgICAgICAgICAgICAgIGxpc3QucmVtb3ZlKGxlYXN0VXNlZEVudHJ5KTtcbiAgICAgICAgICAgICAgICBkZWxldGUgbWFwW2xlYXN0VXNlZEVudHJ5LmtleV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBlbnRyeSA9IGxpc3QuaW5zZXJ0KHZhbHVlKTtcbiAgICAgICAgICAgIGVudHJ5LmtleSA9IGtleTtcbiAgICAgICAgICAgIG1hcFtrZXldID0gZW50cnk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtICB7c3RyaW5nfSBrZXlcbiAgICAgKiBAcmV0dXJuIHt9XG4gICAgICovXG4gICAgTFJVUHJvdG8uZ2V0ID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMuX21hcFtrZXldO1xuICAgICAgICB2YXIgbGlzdCA9IHRoaXMuX2xpc3Q7XG4gICAgICAgIGlmIChlbnRyeSAhPSBudWxsKSB7XG4gICAgICAgICAgICAvLyBQdXQgdGhlIGxhdGVzdCB1c2VkIGVudHJ5IGluIHRoZSB0YWlsXG4gICAgICAgICAgICBpZiAoZW50cnkgIT09IGxpc3QudGFpbCkge1xuICAgICAgICAgICAgICAgIGxpc3QucmVtb3ZlKGVudHJ5KTtcbiAgICAgICAgICAgICAgICBsaXN0Lmluc2VydEVudHJ5KGVudHJ5KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGVudHJ5LnZhbHVlO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENsZWFyIHRoZSBjYWNoZVxuICAgICAqL1xuICAgIExSVVByb3RvLmNsZWFyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuX2xpc3QuY2xlYXIoKTtcbiAgICAgICAgdGhpcy5fbWFwID0ge307XG4gICAgfTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gTFJVO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34venJlbmRlci9saWIvY29yZS9MUlUuanNcbiAqKiBtb2R1bGUgaWQgPSA0MVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBUZXh0IGVsZW1lbnRcbiAqIEBtb2R1bGUgenJlbmRlci9ncmFwaGljL1RleHRcbiAqXG4gKiBUT0RPIFdyYXBwaW5nXG4gKlxuICogVGV4dCBub3Qgc3VwcG9ydCBncmFkaWVudFxuICovXG5cblxuXG4gICAgdmFyIERpc3BsYXlhYmxlID0gcmVxdWlyZSgnLi9EaXNwbGF5YWJsZScpO1xuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCcuLi9jb3JlL3V0aWwnKTtcbiAgICB2YXIgdGV4dENvbnRhaW4gPSByZXF1aXJlKCcuLi9jb250YWluL3RleHQnKTtcblxuICAgIC8qKlxuICAgICAqIEBhbGlhcyB6cmVuZGVyL2dyYXBoaWMvVGV4dFxuICAgICAqIEBleHRlbmRzIG1vZHVsZTp6cmVuZGVyL2dyYXBoaWMvRGlzcGxheWFibGVcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICAgICAqL1xuICAgIHZhciBUZXh0ID0gZnVuY3Rpb24gKG9wdHMpIHtcbiAgICAgICAgRGlzcGxheWFibGUuY2FsbCh0aGlzLCBvcHRzKTtcbiAgICB9O1xuXG4gICAgVGV4dC5wcm90b3R5cGUgPSB7XG5cbiAgICAgICAgY29uc3RydWN0b3I6IFRleHQsXG5cbiAgICAgICAgdHlwZTogJ3RleHQnLFxuXG4gICAgICAgIGJydXNoOiBmdW5jdGlvbiAoY3R4LCBwcmV2RWwpIHtcbiAgICAgICAgICAgIHZhciBzdHlsZSA9IHRoaXMuc3R5bGU7XG4gICAgICAgICAgICB2YXIgeCA9IHN0eWxlLnggfHwgMDtcbiAgICAgICAgICAgIHZhciB5ID0gc3R5bGUueSB8fCAwO1xuICAgICAgICAgICAgLy8gQ29udmVydCB0byBzdHJpbmdcbiAgICAgICAgICAgIHZhciB0ZXh0ID0gc3R5bGUudGV4dDtcblxuICAgICAgICAgICAgLy8gQ29udmVydCB0byBzdHJpbmdcbiAgICAgICAgICAgIHRleHQgIT0gbnVsbCAmJiAodGV4dCArPSAnJyk7XG5cbiAgICAgICAgICAgIC8vIEFsd2F5cyBiaW5kIHN0eWxlXG4gICAgICAgICAgICBzdHlsZS5iaW5kKGN0eCwgdGhpcywgcHJldkVsKTtcblxuICAgICAgICAgICAgaWYgKHRleHQpIHtcblxuICAgICAgICAgICAgICAgIHRoaXMuc2V0VHJhbnNmb3JtKGN0eCk7XG5cbiAgICAgICAgICAgICAgICB2YXIgdGV4dEJhc2VsaW5lO1xuICAgICAgICAgICAgICAgIHZhciB0ZXh0QWxpZ24gPSBzdHlsZS50ZXh0QWxpZ247XG4gICAgICAgICAgICAgICAgdmFyIGZvbnQgPSBzdHlsZS50ZXh0Rm9udCB8fCBzdHlsZS5mb250O1xuICAgICAgICAgICAgICAgIGlmIChzdHlsZS50ZXh0VmVydGljYWxBbGlnbikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVjdCA9IHRleHRDb250YWluLmdldEJvdW5kaW5nUmVjdChcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQsIGZvbnQsIHN0eWxlLnRleHRBbGlnbiwgJ3RvcCdcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWdub3JlIHRleHRCYXNlbGluZVxuICAgICAgICAgICAgICAgICAgICB0ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChzdHlsZS50ZXh0VmVydGljYWxBbGlnbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnbWlkZGxlJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5IC09IHJlY3QuaGVpZ2h0IC8gMiAtIHJlY3QubGluZUhlaWdodCAvIDI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdib3R0b20nOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkgLT0gcmVjdC5oZWlnaHQgLSByZWN0LmxpbmVIZWlnaHQgLyAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5ICs9IHJlY3QubGluZUhlaWdodCAvIDI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRleHRCYXNlbGluZSA9IHN0eWxlLnRleHRCYXNlbGluZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBUT0RPIEludmFsaWQgZm9udFxuICAgICAgICAgICAgICAgIGN0eC5mb250ID0gZm9udCB8fCAnMTJweCBzYW5zLXNlcmlmJztcbiAgICAgICAgICAgICAgICBjdHgudGV4dEFsaWduID0gdGV4dEFsaWduIHx8ICdsZWZ0JztcbiAgICAgICAgICAgICAgICAvLyBVc2UgY2FudmFzIGRlZmF1bHQgbGVmdCB0ZXh0QWxpZ24uIEdpdmluZyBpbnZhbGlkIHZhbHVlIHdpbGwgY2F1c2Ugc3RhdGUgbm90IGNoYW5nZVxuICAgICAgICAgICAgICAgIGlmIChjdHgudGV4dEFsaWduICE9PSB0ZXh0QWxpZ24pIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4LnRleHRBbGlnbiA9ICdsZWZ0JztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3R4LnRleHRCYXNlbGluZSA9IHRleHRCYXNlbGluZSB8fCAnYWxwaGFiZXRpYyc7XG4gICAgICAgICAgICAgICAgLy8gVXNlIGNhbnZhcyBkZWZhdWx0IGFscGhhYmV0aWMgYmFzZWxpbmVcbiAgICAgICAgICAgICAgICBpZiAoY3R4LnRleHRCYXNlbGluZSAhPT0gdGV4dEJhc2VsaW5lKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eC50ZXh0QmFzZWxpbmUgPSAnYWxwaGFiZXRpYyc7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIGxpbmVIZWlnaHQgPSB0ZXh0Q29udGFpbi5tZWFzdXJlVGV4dCgn5Zu9JywgY3R4LmZvbnQpLndpZHRoO1xuXG4gICAgICAgICAgICAgICAgdmFyIHRleHRMaW5lcyA9IHRleHQuc3BsaXQoJ1xcbicpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGV4dExpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlLmhhc0ZpbGwoKSAmJiBjdHguZmlsbFRleHQodGV4dExpbmVzW2ldLCB4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgc3R5bGUuaGFzU3Ryb2tlKCkgJiYgY3R4LnN0cm9rZVRleHQodGV4dExpbmVzW2ldLCB4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgeSArPSBsaW5lSGVpZ2h0O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMucmVzdG9yZVRyYW5zZm9ybShjdHgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGdldEJvdW5kaW5nUmVjdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9yZWN0KSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0eWxlID0gdGhpcy5zdHlsZTtcbiAgICAgICAgICAgICAgICB2YXIgdGV4dFZlcnRpY2FsQWxpZ24gPSBzdHlsZS50ZXh0VmVydGljYWxBbGlnbjtcbiAgICAgICAgICAgICAgICB2YXIgcmVjdCA9IHRleHRDb250YWluLmdldEJvdW5kaW5nUmVjdChcbiAgICAgICAgICAgICAgICAgICAgc3R5bGUudGV4dCArICcnLCBzdHlsZS50ZXh0Rm9udCB8fCBzdHlsZS5mb250LCBzdHlsZS50ZXh0QWxpZ24sXG4gICAgICAgICAgICAgICAgICAgIHRleHRWZXJ0aWNhbEFsaWduID8gJ3RvcCcgOiBzdHlsZS50ZXh0QmFzZWxpbmVcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAodGV4dFZlcnRpY2FsQWxpZ24pIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnbWlkZGxlJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY3QueSAtPSByZWN0LmhlaWdodCAvIDI7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnYm90dG9tJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY3QueSAtPSByZWN0LmhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZWN0LnggKz0gc3R5bGUueCB8fCAwO1xuICAgICAgICAgICAgICAgIHJlY3QueSArPSBzdHlsZS55IHx8IDA7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVjdCA9IHJlY3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVjdDtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB6clV0aWwuaW5oZXJpdHMoVGV4dCwgRGlzcGxheWFibGUpO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBUZXh0O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34venJlbmRlci9saWIvZ3JhcGhpYy9UZXh0LmpzXG4gKiogbW9kdWxlIGlkID0gNDJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0Jztcbi8qKlxuICog5ZyG5b2iXG4gKiBAbW9kdWxlIHpyZW5kZXIvc2hhcGUvQ2lyY2xlXG4gKi9cblxuXG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uL1BhdGgnKS5leHRlbmQoe1xuXG4gICAgICAgIHR5cGU6ICdjaXJjbGUnLFxuXG4gICAgICAgIHNoYXBlOiB7XG4gICAgICAgICAgICBjeDogMCxcbiAgICAgICAgICAgIGN5OiAwLFxuICAgICAgICAgICAgcjogMFxuICAgICAgICB9LFxuXG5cbiAgICAgICAgYnVpbGRQYXRoIDogZnVuY3Rpb24gKGN0eCwgc2hhcGUsIGluQnVuZGxlKSB7XG4gICAgICAgICAgICAvLyBCZXR0ZXIgc3Ryb2tpbmcgaW4gU2hhcGVCdW5kbGVcbiAgICAgICAgICAgIC8vIEFsd2F5cyBkbyBpdCBtYXkgaGF2ZSBwZXJmb3JtZW5jZSBpc3N1ZSAoIGZpbGwgbWF5IGJlIDJ4IG1vcmUgY29zdClcbiAgICAgICAgICAgIGlmIChpbkJ1bmRsZSkge1xuICAgICAgICAgICAgICAgIGN0eC5tb3ZlVG8oc2hhcGUuY3ggKyBzaGFwZS5yLCBzaGFwZS5jeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBCZXR0ZXIgc3Ryb2tpbmcgaW4gU2hhcGVCdW5kbGVcbiAgICAgICAgICAgIC8vIGN0eC5tb3ZlVG8oc2hhcGUuY3ggKyBzaGFwZS5yLCBzaGFwZS5jeSk7XG4gICAgICAgICAgICBjdHguYXJjKHNoYXBlLmN4LCBzaGFwZS5jeSwgc2hhcGUuciwgMCwgTWF0aC5QSSAqIDIsIHRydWUpO1xuICAgICAgICB9XG4gICAgfSk7XG5cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvQ2lyY2xlLmpzXG4gKiogbW9kdWxlIGlkID0gNDNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICog5omH5b2iXG4gKiBAbW9kdWxlIHpyZW5kZXIvZ3JhcGhpYy9zaGFwZS9TZWN0b3JcbiAqL1xuXG5cblxuICAgIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vUGF0aCcpLmV4dGVuZCh7XG5cbiAgICAgICAgdHlwZTogJ3NlY3RvcicsXG5cbiAgICAgICAgc2hhcGU6IHtcblxuICAgICAgICAgICAgY3g6IDAsXG5cbiAgICAgICAgICAgIGN5OiAwLFxuXG4gICAgICAgICAgICByMDogMCxcblxuICAgICAgICAgICAgcjogMCxcblxuICAgICAgICAgICAgc3RhcnRBbmdsZTogMCxcblxuICAgICAgICAgICAgZW5kQW5nbGU6IE1hdGguUEkgKiAyLFxuXG4gICAgICAgICAgICBjbG9ja3dpc2U6IHRydWVcbiAgICAgICAgfSxcblxuICAgICAgICBidWlsZFBhdGg6IGZ1bmN0aW9uIChjdHgsIHNoYXBlKSB7XG5cbiAgICAgICAgICAgIHZhciB4ID0gc2hhcGUuY3g7XG4gICAgICAgICAgICB2YXIgeSA9IHNoYXBlLmN5O1xuICAgICAgICAgICAgdmFyIHIwID0gTWF0aC5tYXgoc2hhcGUucjAgfHwgMCwgMCk7XG4gICAgICAgICAgICB2YXIgciA9IE1hdGgubWF4KHNoYXBlLnIsIDApO1xuICAgICAgICAgICAgdmFyIHN0YXJ0QW5nbGUgPSBzaGFwZS5zdGFydEFuZ2xlO1xuICAgICAgICAgICAgdmFyIGVuZEFuZ2xlID0gc2hhcGUuZW5kQW5nbGU7XG4gICAgICAgICAgICB2YXIgY2xvY2t3aXNlID0gc2hhcGUuY2xvY2t3aXNlO1xuXG4gICAgICAgICAgICB2YXIgdW5pdFggPSBNYXRoLmNvcyhzdGFydEFuZ2xlKTtcbiAgICAgICAgICAgIHZhciB1bml0WSA9IE1hdGguc2luKHN0YXJ0QW5nbGUpO1xuXG4gICAgICAgICAgICBjdHgubW92ZVRvKHVuaXRYICogcjAgKyB4LCB1bml0WSAqIHIwICsgeSk7XG5cbiAgICAgICAgICAgIGN0eC5saW5lVG8odW5pdFggKiByICsgeCwgdW5pdFkgKiByICsgeSk7XG5cbiAgICAgICAgICAgIGN0eC5hcmMoeCwgeSwgciwgc3RhcnRBbmdsZSwgZW5kQW5nbGUsICFjbG9ja3dpc2UpO1xuXG4gICAgICAgICAgICBjdHgubGluZVRvKFxuICAgICAgICAgICAgICAgIE1hdGguY29zKGVuZEFuZ2xlKSAqIHIwICsgeCxcbiAgICAgICAgICAgICAgICBNYXRoLnNpbihlbmRBbmdsZSkgKiByMCArIHlcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGlmIChyMCAhPT0gMCkge1xuICAgICAgICAgICAgICAgIGN0eC5hcmMoeCwgeSwgcjAsIGVuZEFuZ2xlLCBzdGFydEFuZ2xlLCBjbG9ja3dpc2UpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34venJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9TZWN0b3IuanNcbiAqKiBtb2R1bGUgaWQgPSA0NFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiDlnIbnjq9cbiAqIEBtb2R1bGUgenJlbmRlci9ncmFwaGljL3NoYXBlL1JpbmdcbiAqL1xuXG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uL1BhdGgnKS5leHRlbmQoe1xuXG4gICAgICAgIHR5cGU6ICdyaW5nJyxcblxuICAgICAgICBzaGFwZToge1xuICAgICAgICAgICAgY3g6IDAsXG4gICAgICAgICAgICBjeTogMCxcbiAgICAgICAgICAgIHI6IDAsXG4gICAgICAgICAgICByMDogMFxuICAgICAgICB9LFxuXG4gICAgICAgIGJ1aWxkUGF0aDogZnVuY3Rpb24gKGN0eCwgc2hhcGUpIHtcbiAgICAgICAgICAgIHZhciB4ID0gc2hhcGUuY3g7XG4gICAgICAgICAgICB2YXIgeSA9IHNoYXBlLmN5O1xuICAgICAgICAgICAgdmFyIFBJMiA9IE1hdGguUEkgKiAyO1xuICAgICAgICAgICAgY3R4Lm1vdmVUbyh4ICsgc2hhcGUuciwgeSk7XG4gICAgICAgICAgICBjdHguYXJjKHgsIHksIHNoYXBlLnIsIDAsIFBJMiwgZmFsc2UpO1xuICAgICAgICAgICAgY3R4Lm1vdmVUbyh4ICsgc2hhcGUucjAsIHkpO1xuICAgICAgICAgICAgY3R4LmFyYyh4LCB5LCBzaGFwZS5yMCwgMCwgUEkyLCB0cnVlKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi96cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL1JpbmcuanNcbiAqKiBtb2R1bGUgaWQgPSA0NVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiDlpJrovrnlvaJcbiAqIEBtb2R1bGUgenJlbmRlci9zaGFwZS9Qb2x5Z29uXG4gKi9cblxuXG4gICAgdmFyIHBvbHlIZWxwZXIgPSByZXF1aXJlKCcuLi9oZWxwZXIvcG9seScpO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi9QYXRoJykuZXh0ZW5kKHtcbiAgICAgICAgXG4gICAgICAgIHR5cGU6ICdwb2x5Z29uJyxcblxuICAgICAgICBzaGFwZToge1xuICAgICAgICAgICAgcG9pbnRzOiBudWxsLFxuXG4gICAgICAgICAgICBzbW9vdGg6IGZhbHNlLFxuXG4gICAgICAgICAgICBzbW9vdGhDb25zdHJhaW50OiBudWxsXG4gICAgICAgIH0sXG5cbiAgICAgICAgYnVpbGRQYXRoOiBmdW5jdGlvbiAoY3R4LCBzaGFwZSkge1xuICAgICAgICAgICAgcG9seUhlbHBlci5idWlsZFBhdGgoY3R4LCBzaGFwZSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvUG9seWdvbi5qc1xuICoqIG1vZHVsZSBpZCA9IDQ2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcblxuICAgIHZhciBzbW9vdGhTcGxpbmUgPSByZXF1aXJlKCcuL3Ntb290aFNwbGluZScpO1xuICAgIHZhciBzbW9vdGhCZXppZXIgPSByZXF1aXJlKCcuL3Ntb290aEJlemllcicpO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgICAgIGJ1aWxkUGF0aDogZnVuY3Rpb24gKGN0eCwgc2hhcGUsIGNsb3NlUGF0aCkge1xuICAgICAgICAgICAgdmFyIHBvaW50cyA9IHNoYXBlLnBvaW50cztcbiAgICAgICAgICAgIHZhciBzbW9vdGggPSBzaGFwZS5zbW9vdGg7XG4gICAgICAgICAgICBpZiAocG9pbnRzICYmIHBvaW50cy5sZW5ndGggPj0gMikge1xuICAgICAgICAgICAgICAgIGlmIChzbW9vdGggJiYgc21vb3RoICE9PSAnc3BsaW5lJykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29udHJvbFBvaW50cyA9IHNtb290aEJlemllcihcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50cywgc21vb3RoLCBjbG9zZVBhdGgsIHNoYXBlLnNtb290aENvbnN0cmFpbnRcbiAgICAgICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgICAgICBjdHgubW92ZVRvKHBvaW50c1swXVswXSwgcG9pbnRzWzBdWzFdKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxlbiA9IHBvaW50cy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgKGNsb3NlUGF0aCA/IGxlbiA6IGxlbiAtIDEpOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjcDEgPSBjb250cm9sUG9pbnRzW2kgKiAyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjcDIgPSBjb250cm9sUG9pbnRzW2kgKiAyICsgMV07XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcCA9IHBvaW50c1soaSArIDEpICUgbGVuXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNwMVswXSwgY3AxWzFdLCBjcDJbMF0sIGNwMlsxXSwgcFswXSwgcFsxXVxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNtb290aCA9PT0gJ3NwbGluZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50cyA9IHNtb290aFNwbGluZShwb2ludHMsIGNsb3NlUGF0aCk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBjdHgubW92ZVRvKHBvaW50c1swXVswXSwgcG9pbnRzWzBdWzFdKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDEsIGwgPSBwb2ludHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHgubGluZVRvKHBvaW50c1tpXVswXSwgcG9pbnRzW2ldWzFdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNsb3NlUGF0aCAmJiBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34venJlbmRlci9saWIvZ3JhcGhpYy9oZWxwZXIvcG9seS5qc1xuICoqIG1vZHVsZSBpZCA9IDQ3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENhdG11bGwtUm9tIHNwbGluZSDmj5LlgLzmipjnur9cbiAqIEBtb2R1bGUgenJlbmRlci9zaGFwZS91dGlsL3Ntb290aFNwbGluZVxuICogQGF1dGhvciBwaXNzYW5nIChodHRwczovL3d3dy5naXRodWIuY29tL3Bpc3NhbmcpXG4gKiAgICAgICAgIEtlbmVyIChAS2VuZXIt5p6X5bOwLCBrZW5lci5saW5mZW5nQGdtYWlsLmNvbSlcbiAqICAgICAgICAgZXJyb3JyaWsgKGVycm9ycmlrQGdtYWlsLmNvbSlcbiAqL1xuXG4gICAgdmFyIHZlYzIgPSByZXF1aXJlKCcuLi8uLi9jb3JlL3ZlY3RvcicpO1xuXG4gICAgLyoqXG4gICAgICogQGlubmVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW50ZXJwb2xhdGUocDAsIHAxLCBwMiwgcDMsIHQsIHQyLCB0Mykge1xuICAgICAgICB2YXIgdjAgPSAocDIgLSBwMCkgKiAwLjU7XG4gICAgICAgIHZhciB2MSA9IChwMyAtIHAxKSAqIDAuNTtcbiAgICAgICAgcmV0dXJuICgyICogKHAxIC0gcDIpICsgdjAgKyB2MSkgKiB0M1xuICAgICAgICAgICAgICAgICsgKC0zICogKHAxIC0gcDIpIC0gMiAqIHYwIC0gdjEpICogdDJcbiAgICAgICAgICAgICAgICArIHYwICogdCArIHAxO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBhbGlhcyBtb2R1bGU6enJlbmRlci9zaGFwZS91dGlsL3Ntb290aFNwbGluZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBvaW50cyDnur/mrrXpobbngrnmlbDnu4RcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzTG9vcFxuICAgICAqIEByZXR1cm4ge0FycmF5fVxuICAgICAqL1xuICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHBvaW50cywgaXNMb29wKSB7XG4gICAgICAgIHZhciBsZW4gPSBwb2ludHMubGVuZ3RoO1xuICAgICAgICB2YXIgcmV0ID0gW107XG5cbiAgICAgICAgdmFyIGRpc3RhbmNlID0gMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgZGlzdGFuY2UgKz0gdmVjMi5kaXN0YW5jZShwb2ludHNbaSAtIDFdLCBwb2ludHNbaV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNlZ3MgPSBkaXN0YW5jZSAvIDI7XG4gICAgICAgIHNlZ3MgPSBzZWdzIDwgbGVuID8gbGVuIDogc2VncztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWdzOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBwb3MgPSBpIC8gKHNlZ3MgLSAxKSAqIChpc0xvb3AgPyBsZW4gOiBsZW4gLSAxKTtcbiAgICAgICAgICAgIHZhciBpZHggPSBNYXRoLmZsb29yKHBvcyk7XG5cbiAgICAgICAgICAgIHZhciB3ID0gcG9zIC0gaWR4O1xuXG4gICAgICAgICAgICB2YXIgcDA7XG4gICAgICAgICAgICB2YXIgcDEgPSBwb2ludHNbaWR4ICUgbGVuXTtcbiAgICAgICAgICAgIHZhciBwMjtcbiAgICAgICAgICAgIHZhciBwMztcbiAgICAgICAgICAgIGlmICghaXNMb29wKSB7XG4gICAgICAgICAgICAgICAgcDAgPSBwb2ludHNbaWR4ID09PSAwID8gaWR4IDogaWR4IC0gMV07XG4gICAgICAgICAgICAgICAgcDIgPSBwb2ludHNbaWR4ID4gbGVuIC0gMiA/IGxlbiAtIDEgOiBpZHggKyAxXTtcbiAgICAgICAgICAgICAgICBwMyA9IHBvaW50c1tpZHggPiBsZW4gLSAzID8gbGVuIC0gMSA6IGlkeCArIDJdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcDAgPSBwb2ludHNbKGlkeCAtIDEgKyBsZW4pICUgbGVuXTtcbiAgICAgICAgICAgICAgICBwMiA9IHBvaW50c1soaWR4ICsgMSkgJSBsZW5dO1xuICAgICAgICAgICAgICAgIHAzID0gcG9pbnRzWyhpZHggKyAyKSAlIGxlbl07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciB3MiA9IHcgKiB3O1xuICAgICAgICAgICAgdmFyIHczID0gdyAqIHcyO1xuXG4gICAgICAgICAgICByZXQucHVzaChbXG4gICAgICAgICAgICAgICAgaW50ZXJwb2xhdGUocDBbMF0sIHAxWzBdLCBwMlswXSwgcDNbMF0sIHcsIHcyLCB3MyksXG4gICAgICAgICAgICAgICAgaW50ZXJwb2xhdGUocDBbMV0sIHAxWzFdLCBwMlsxXSwgcDNbMV0sIHcsIHcyLCB3MylcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcblxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34venJlbmRlci9saWIvZ3JhcGhpYy9oZWxwZXIvc21vb3RoU3BsaW5lLmpzXG4gKiogbW9kdWxlIGlkID0gNDhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICog6LSd5aGe5bCU5bmz5ruR5puy57q/XG4gKiBAbW9kdWxlIHpyZW5kZXIvc2hhcGUvdXRpbC9zbW9vdGhCZXppZXJcbiAqIEBhdXRob3IgcGlzc2FuZyAoaHR0cHM6Ly93d3cuZ2l0aHViLmNvbS9waXNzYW5nKVxuICogICAgICAgICBLZW5lciAoQEtlbmVyLeael+WzsCwga2VuZXIubGluZmVuZ0BnbWFpbC5jb20pXG4gKiAgICAgICAgIGVycm9ycmlrIChlcnJvcnJpa0BnbWFpbC5jb20pXG4gKi9cblxuXG4gICAgdmFyIHZlYzIgPSByZXF1aXJlKCcuLi8uLi9jb3JlL3ZlY3RvcicpO1xuICAgIHZhciB2Mk1pbiA9IHZlYzIubWluO1xuICAgIHZhciB2Mk1heCA9IHZlYzIubWF4O1xuICAgIHZhciB2MlNjYWxlID0gdmVjMi5zY2FsZTtcbiAgICB2YXIgdjJEaXN0YW5jZSA9IHZlYzIuZGlzdGFuY2U7XG4gICAgdmFyIHYyQWRkID0gdmVjMi5hZGQ7XG5cbiAgICAvKipcbiAgICAgKiDotJ3loZ7lsJTlubPmu5Hmm7Lnur9cbiAgICAgKiBAYWxpYXMgbW9kdWxlOnpyZW5kZXIvc2hhcGUvdXRpbC9zbW9vdGhCZXppZXJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwb2ludHMg57q/5q616aG254K55pWw57uEXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNtb290aCDlubPmu5HnrYnnuqcsIDAtMVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNMb29wXG4gICAgICogQHBhcmFtIHtBcnJheX0gY29uc3RyYWludCDlsIborqHnrpflh7rmnaXnmoTmjqfliLbngrnnuqbmnZ/lnKjkuIDkuKrljIXlm7Tnm5LlhoVcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIOavlOWmgiBbWzAsIDBdLCBbMTAwLCAxMDBdXSwg6L+Z5Liq5YyF5Zu055uS5Lya5LiOXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICDmlbTkuKrmipjnur/nmoTljIXlm7Tnm5LlgZrkuIDkuKrlubbpm4bnlKjmnaXnuqbmnZ/mjqfliLbngrnjgIJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSDorqHnrpflh7rmnaXnmoTmjqfliLbngrnmlbDnu4RcbiAgICAgKi9cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChwb2ludHMsIHNtb290aCwgaXNMb29wLCBjb25zdHJhaW50KSB7XG4gICAgICAgIHZhciBjcHMgPSBbXTtcblxuICAgICAgICB2YXIgdiA9IFtdO1xuICAgICAgICB2YXIgdjEgPSBbXTtcbiAgICAgICAgdmFyIHYyID0gW107XG4gICAgICAgIHZhciBwcmV2UG9pbnQ7XG4gICAgICAgIHZhciBuZXh0UG9pbnQ7XG5cbiAgICAgICAgdmFyIG1pbiwgbWF4O1xuICAgICAgICBpZiAoY29uc3RyYWludCkge1xuICAgICAgICAgICAgbWluID0gW0luZmluaXR5LCBJbmZpbml0eV07XG4gICAgICAgICAgICBtYXggPSBbLUluZmluaXR5LCAtSW5maW5pdHldO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHBvaW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIHYyTWluKG1pbiwgbWluLCBwb2ludHNbaV0pO1xuICAgICAgICAgICAgICAgIHYyTWF4KG1heCwgbWF4LCBwb2ludHNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8g5LiO5oyH5a6a55qE5YyF5Zu055uS5YGa5bm26ZuGXG4gICAgICAgICAgICB2Mk1pbihtaW4sIG1pbiwgY29uc3RyYWludFswXSk7XG4gICAgICAgICAgICB2Mk1heChtYXgsIG1heCwgY29uc3RyYWludFsxXSk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gcG9pbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgcG9pbnQgPSBwb2ludHNbaV07XG5cbiAgICAgICAgICAgIGlmIChpc0xvb3ApIHtcbiAgICAgICAgICAgICAgICBwcmV2UG9pbnQgPSBwb2ludHNbaSA/IGkgLSAxIDogbGVuIC0gMV07XG4gICAgICAgICAgICAgICAgbmV4dFBvaW50ID0gcG9pbnRzWyhpICsgMSkgJSBsZW5dO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGkgPT09IDAgfHwgaSA9PT0gbGVuIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICBjcHMucHVzaCh2ZWMyLmNsb25lKHBvaW50c1tpXSkpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHByZXZQb2ludCA9IHBvaW50c1tpIC0gMV07XG4gICAgICAgICAgICAgICAgICAgIG5leHRQb2ludCA9IHBvaW50c1tpICsgMV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2ZWMyLnN1Yih2LCBuZXh0UG9pbnQsIHByZXZQb2ludCk7XG5cbiAgICAgICAgICAgIC8vIHVzZSBkZWdyZWUgdG8gc2NhbGUgdGhlIGhhbmRsZSBsZW5ndGhcbiAgICAgICAgICAgIHYyU2NhbGUodiwgdiwgc21vb3RoKTtcblxuICAgICAgICAgICAgdmFyIGQwID0gdjJEaXN0YW5jZShwb2ludCwgcHJldlBvaW50KTtcbiAgICAgICAgICAgIHZhciBkMSA9IHYyRGlzdGFuY2UocG9pbnQsIG5leHRQb2ludCk7XG4gICAgICAgICAgICB2YXIgc3VtID0gZDAgKyBkMTtcbiAgICAgICAgICAgIGlmIChzdW0gIT09IDApIHtcbiAgICAgICAgICAgICAgICBkMCAvPSBzdW07XG4gICAgICAgICAgICAgICAgZDEgLz0gc3VtO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2MlNjYWxlKHYxLCB2LCAtZDApO1xuICAgICAgICAgICAgdjJTY2FsZSh2MiwgdiwgZDEpO1xuICAgICAgICAgICAgdmFyIGNwMCA9IHYyQWRkKFtdLCBwb2ludCwgdjEpO1xuICAgICAgICAgICAgdmFyIGNwMSA9IHYyQWRkKFtdLCBwb2ludCwgdjIpO1xuICAgICAgICAgICAgaWYgKGNvbnN0cmFpbnQpIHtcbiAgICAgICAgICAgICAgICB2Mk1heChjcDAsIGNwMCwgbWluKTtcbiAgICAgICAgICAgICAgICB2Mk1pbihjcDAsIGNwMCwgbWF4KTtcbiAgICAgICAgICAgICAgICB2Mk1heChjcDEsIGNwMSwgbWluKTtcbiAgICAgICAgICAgICAgICB2Mk1pbihjcDEsIGNwMSwgbWF4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNwcy5wdXNoKGNwMCk7XG4gICAgICAgICAgICBjcHMucHVzaChjcDEpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzTG9vcCkge1xuICAgICAgICAgICAgY3BzLnB1c2goY3BzLnNoaWZ0KCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNwcztcbiAgICB9O1xuXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi96cmVuZGVyL2xpYi9ncmFwaGljL2hlbHBlci9zbW9vdGhCZXppZXIuanNcbiAqKiBtb2R1bGUgaWQgPSA0OVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBAbW9kdWxlIHpyZW5kZXIvZ3JhcGhpYy9zaGFwZS9Qb2x5bGluZVxuICovXG5cblxuICAgIHZhciBwb2x5SGVscGVyID0gcmVxdWlyZSgnLi4vaGVscGVyL3BvbHknKTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vUGF0aCcpLmV4dGVuZCh7XG4gICAgICAgIFxuICAgICAgICB0eXBlOiAncG9seWxpbmUnLFxuXG4gICAgICAgIHNoYXBlOiB7XG4gICAgICAgICAgICBwb2ludHM6IG51bGwsXG5cbiAgICAgICAgICAgIHNtb290aDogZmFsc2UsXG5cbiAgICAgICAgICAgIHNtb290aENvbnN0cmFpbnQ6IG51bGxcbiAgICAgICAgfSxcblxuICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgc3Ryb2tlOiAnIzAwMCcsXG5cbiAgICAgICAgICAgIGZpbGw6IG51bGxcbiAgICAgICAgfSxcblxuICAgICAgICBidWlsZFBhdGg6IGZ1bmN0aW9uIChjdHgsIHNoYXBlKSB7XG4gICAgICAgICAgICBwb2x5SGVscGVyLmJ1aWxkUGF0aChjdHgsIHNoYXBlLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvUG9seWxpbmUuanNcbiAqKiBtb2R1bGUgaWQgPSA1MFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiDnn6nlvaJcbiAqIEBtb2R1bGUgenJlbmRlci9ncmFwaGljL3NoYXBlL1JlY3RcbiAqL1xuXG5cbiAgICB2YXIgcm91bmRSZWN0SGVscGVyID0gcmVxdWlyZSgnLi4vaGVscGVyL3JvdW5kUmVjdCcpO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi9QYXRoJykuZXh0ZW5kKHtcblxuICAgICAgICB0eXBlOiAncmVjdCcsXG5cbiAgICAgICAgc2hhcGU6IHtcbiAgICAgICAgICAgIC8vIOW3puS4iuOAgeWPs+S4iuOAgeWPs+S4i+OAgeW3puS4i+inkueahOWNiuW+hOS+neasoeS4unIx44CBcjLjgIFyM+OAgXI0XG4gICAgICAgICAgICAvLyBy57yp5YaZ5Li6MSAgICAgICAgIOebuOW9k+S6jiBbMSwgMSwgMSwgMV1cbiAgICAgICAgICAgIC8vIHLnvKnlhpnkuLpbMV0gICAgICAg55u45b2T5LqOIFsxLCAxLCAxLCAxXVxuICAgICAgICAgICAgLy8gcue8qeWGmeS4ulsxLCAyXSAgICDnm7jlvZPkuo4gWzEsIDIsIDEsIDJdXG4gICAgICAgICAgICAvLyBy57yp5YaZ5Li6WzEsIDIsIDNdIOebuOW9k+S6jiBbMSwgMiwgMywgMl1cbiAgICAgICAgICAgIHI6IDAsXG5cbiAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICB5OiAwLFxuICAgICAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgICAgICBoZWlnaHQ6IDBcbiAgICAgICAgfSxcblxuICAgICAgICBidWlsZFBhdGg6IGZ1bmN0aW9uIChjdHgsIHNoYXBlKSB7XG4gICAgICAgICAgICB2YXIgeCA9IHNoYXBlLng7XG4gICAgICAgICAgICB2YXIgeSA9IHNoYXBlLnk7XG4gICAgICAgICAgICB2YXIgd2lkdGggPSBzaGFwZS53aWR0aDtcbiAgICAgICAgICAgIHZhciBoZWlnaHQgPSBzaGFwZS5oZWlnaHQ7XG4gICAgICAgICAgICBpZiAoIXNoYXBlLnIpIHtcbiAgICAgICAgICAgICAgICBjdHgucmVjdCh4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJvdW5kUmVjdEhlbHBlci5idWlsZFBhdGgoY3R4LCBzaGFwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9KTtcblxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34venJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9SZWN0LmpzXG4gKiogbW9kdWxlIGlkID0gNTFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgICAgIGJ1aWxkUGF0aDogZnVuY3Rpb24gKGN0eCwgc2hhcGUpIHtcbiAgICAgICAgICAgIHZhciB4ID0gc2hhcGUueDtcbiAgICAgICAgICAgIHZhciB5ID0gc2hhcGUueTtcbiAgICAgICAgICAgIHZhciB3aWR0aCA9IHNoYXBlLndpZHRoO1xuICAgICAgICAgICAgdmFyIGhlaWdodCA9IHNoYXBlLmhlaWdodDtcbiAgICAgICAgICAgIHZhciByID0gc2hhcGUucjtcbiAgICAgICAgICAgIHZhciByMTtcbiAgICAgICAgICAgIHZhciByMjtcbiAgICAgICAgICAgIHZhciByMztcbiAgICAgICAgICAgIHZhciByNDtcblxuICAgICAgICAgICAgLy8gQ29udmVydCB3aWR0aCBhbmQgaGVpZ2h0IHRvIHBvc2l0aXZlIGZvciBiZXR0ZXIgYm9yZGVyUmFkaXVzXG4gICAgICAgICAgICBpZiAod2lkdGggPCAwKSB7XG4gICAgICAgICAgICAgICAgeCA9IHggKyB3aWR0aDtcbiAgICAgICAgICAgICAgICB3aWR0aCA9IC13aWR0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChoZWlnaHQgPCAwKSB7XG4gICAgICAgICAgICAgICAgeSA9IHkgKyBoZWlnaHQ7XG4gICAgICAgICAgICAgICAgaGVpZ2h0ID0gLWhlaWdodDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHR5cGVvZiByID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIHIxID0gcjIgPSByMyA9IHI0ID0gcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHIgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgICAgIGlmIChyLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICByMSA9IHIyID0gcjMgPSByNCA9IHJbMF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHIubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgIHIxID0gcjMgPSByWzBdO1xuICAgICAgICAgICAgICAgICAgICByMiA9IHI0ID0gclsxXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoci5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgcjEgPSByWzBdO1xuICAgICAgICAgICAgICAgICAgICByMiA9IHI0ID0gclsxXTtcbiAgICAgICAgICAgICAgICAgICAgcjMgPSByWzJdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcjEgPSByWzBdO1xuICAgICAgICAgICAgICAgICAgICByMiA9IHJbMV07XG4gICAgICAgICAgICAgICAgICAgIHIzID0gclsyXTtcbiAgICAgICAgICAgICAgICAgICAgcjQgPSByWzNdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHIxID0gcjIgPSByMyA9IHI0ID0gMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHRvdGFsO1xuICAgICAgICAgICAgaWYgKHIxICsgcjIgPiB3aWR0aCkge1xuICAgICAgICAgICAgICAgIHRvdGFsID0gcjEgKyByMjtcbiAgICAgICAgICAgICAgICByMSAqPSB3aWR0aCAvIHRvdGFsO1xuICAgICAgICAgICAgICAgIHIyICo9IHdpZHRoIC8gdG90YWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocjMgKyByNCA+IHdpZHRoKSB7XG4gICAgICAgICAgICAgICAgdG90YWwgPSByMyArIHI0O1xuICAgICAgICAgICAgICAgIHIzICo9IHdpZHRoIC8gdG90YWw7XG4gICAgICAgICAgICAgICAgcjQgKj0gd2lkdGggLyB0b3RhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyMiArIHIzID4gaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgdG90YWwgPSByMiArIHIzO1xuICAgICAgICAgICAgICAgIHIyICo9IGhlaWdodCAvIHRvdGFsO1xuICAgICAgICAgICAgICAgIHIzICo9IGhlaWdodCAvIHRvdGFsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHIxICsgcjQgPiBoZWlnaHQpIHtcbiAgICAgICAgICAgICAgICB0b3RhbCA9IHIxICsgcjQ7XG4gICAgICAgICAgICAgICAgcjEgKj0gaGVpZ2h0IC8gdG90YWw7XG4gICAgICAgICAgICAgICAgcjQgKj0gaGVpZ2h0IC8gdG90YWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdHgubW92ZVRvKHggKyByMSwgeSk7XG4gICAgICAgICAgICBjdHgubGluZVRvKHggKyB3aWR0aCAtIHIyLCB5KTtcbiAgICAgICAgICAgIHIyICE9PSAwICYmIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKFxuICAgICAgICAgICAgICAgIHggKyB3aWR0aCwgeSwgeCArIHdpZHRoLCB5ICsgcjJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBjdHgubGluZVRvKHggKyB3aWR0aCwgeSArIGhlaWdodCAtIHIzKTtcbiAgICAgICAgICAgIHIzICE9PSAwICYmIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKFxuICAgICAgICAgICAgICAgIHggKyB3aWR0aCwgeSArIGhlaWdodCwgeCArIHdpZHRoIC0gcjMsIHkgKyBoZWlnaHRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBjdHgubGluZVRvKHggKyByNCwgeSArIGhlaWdodCk7XG4gICAgICAgICAgICByNCAhPT0gMCAmJiBjdHgucXVhZHJhdGljQ3VydmVUbyhcbiAgICAgICAgICAgICAgICB4LCB5ICsgaGVpZ2h0LCB4LCB5ICsgaGVpZ2h0IC0gcjRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBjdHgubGluZVRvKHgsIHkgKyByMSk7XG4gICAgICAgICAgICByMSAhPT0gMCAmJiBjdHgucXVhZHJhdGljQ3VydmVUbyh4LCB5LCB4ICsgcjEsIHkpO1xuICAgICAgICB9XG4gICAgfTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvaGVscGVyL3JvdW5kUmVjdC5qc1xuICoqIG1vZHVsZSBpZCA9IDUyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIOebtOe6v1xuICogQG1vZHVsZSB6cmVuZGVyL2dyYXBoaWMvc2hhcGUvTGluZVxuICovXG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uL1BhdGgnKS5leHRlbmQoe1xuXG4gICAgICAgIHR5cGU6ICdsaW5lJyxcblxuICAgICAgICBzaGFwZToge1xuICAgICAgICAgICAgLy8gU3RhcnQgcG9pbnRcbiAgICAgICAgICAgIHgxOiAwLFxuICAgICAgICAgICAgeTE6IDAsXG4gICAgICAgICAgICAvLyBFbmQgcG9pbnRcbiAgICAgICAgICAgIHgyOiAwLFxuICAgICAgICAgICAgeTI6IDAsXG5cbiAgICAgICAgICAgIHBlcmNlbnQ6IDFcbiAgICAgICAgfSxcblxuICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgc3Ryb2tlOiAnIzAwMCcsXG4gICAgICAgICAgICBmaWxsOiBudWxsXG4gICAgICAgIH0sXG5cbiAgICAgICAgYnVpbGRQYXRoOiBmdW5jdGlvbiAoY3R4LCBzaGFwZSkge1xuICAgICAgICAgICAgdmFyIHgxID0gc2hhcGUueDE7XG4gICAgICAgICAgICB2YXIgeTEgPSBzaGFwZS55MTtcbiAgICAgICAgICAgIHZhciB4MiA9IHNoYXBlLngyO1xuICAgICAgICAgICAgdmFyIHkyID0gc2hhcGUueTI7XG4gICAgICAgICAgICB2YXIgcGVyY2VudCA9IHNoYXBlLnBlcmNlbnQ7XG5cbiAgICAgICAgICAgIGlmIChwZXJjZW50ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjdHgubW92ZVRvKHgxLCB5MSk7XG5cbiAgICAgICAgICAgIGlmIChwZXJjZW50IDwgMSkge1xuICAgICAgICAgICAgICAgIHgyID0geDEgKiAoMSAtIHBlcmNlbnQpICsgeDIgKiBwZXJjZW50O1xuICAgICAgICAgICAgICAgIHkyID0geTEgKiAoMSAtIHBlcmNlbnQpICsgeTIgKiBwZXJjZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3R4LmxpbmVUbyh4MiwgeTIpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgcG9pbnQgYXQgcGVyY2VudFxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHBlcmNlbnRcbiAgICAgICAgICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59XG4gICAgICAgICAqL1xuICAgICAgICBwb2ludEF0OiBmdW5jdGlvbiAocCkge1xuICAgICAgICAgICAgdmFyIHNoYXBlID0gdGhpcy5zaGFwZTtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgc2hhcGUueDEgKiAoMSAtIHApICsgc2hhcGUueDIgKiBwLFxuICAgICAgICAgICAgICAgIHNoYXBlLnkxICogKDEgLSBwKSArIHNoYXBlLnkyICogcFxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi96cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL0xpbmUuanNcbiAqKiBtb2R1bGUgaWQgPSA1M1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuLyoqXG4gKiDotJ3loZ7lsJTmm7Lnur9cbiAqIEBtb2R1bGUgenJlbmRlci9zaGFwZS9CZXppZXJDdXJ2ZVxuICovXG5cblxuICAgIHZhciBjdXJ2ZVRvb2wgPSByZXF1aXJlKCcuLi8uLi9jb3JlL2N1cnZlJyk7XG4gICAgdmFyIHZlYzIgPSByZXF1aXJlKCcuLi8uLi9jb3JlL3ZlY3RvcicpO1xuICAgIHZhciBxdWFkcmF0aWNTdWJkaXZpZGUgPSBjdXJ2ZVRvb2wucXVhZHJhdGljU3ViZGl2aWRlO1xuICAgIHZhciBjdWJpY1N1YmRpdmlkZSA9IGN1cnZlVG9vbC5jdWJpY1N1YmRpdmlkZTtcbiAgICB2YXIgcXVhZHJhdGljQXQgPSBjdXJ2ZVRvb2wucXVhZHJhdGljQXQ7XG4gICAgdmFyIGN1YmljQXQgPSBjdXJ2ZVRvb2wuY3ViaWNBdDtcbiAgICB2YXIgcXVhZHJhdGljRGVyaXZhdGl2ZUF0ID0gY3VydmVUb29sLnF1YWRyYXRpY0Rlcml2YXRpdmVBdDtcbiAgICB2YXIgY3ViaWNEZXJpdmF0aXZlQXQgPSBjdXJ2ZVRvb2wuY3ViaWNEZXJpdmF0aXZlQXQ7XG5cbiAgICB2YXIgb3V0ID0gW107XG5cbiAgICBmdW5jdGlvbiBzb21lVmVjdG9yQXQoc2hhcGUsIHQsIGlzVGFuZ2VudCkge1xuICAgICAgICB2YXIgY3B4MiA9IHNoYXBlLmNweDI7XG4gICAgICAgIHZhciBjcHkyID0gc2hhcGUuY3B5MjtcbiAgICAgICAgaWYgKGNweDIgPT09IG51bGwgfHwgY3B5MiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAoaXNUYW5nZW50ID8gY3ViaWNEZXJpdmF0aXZlQXQgOiBjdWJpY0F0KShzaGFwZS54MSwgc2hhcGUuY3B4MSwgc2hhcGUuY3B4Miwgc2hhcGUueDIsIHQpLFxuICAgICAgICAgICAgICAgIChpc1RhbmdlbnQgPyBjdWJpY0Rlcml2YXRpdmVBdCA6IGN1YmljQXQpKHNoYXBlLnkxLCBzaGFwZS5jcHkxLCBzaGFwZS5jcHkyLCBzaGFwZS55MiwgdClcbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIChpc1RhbmdlbnQgPyBxdWFkcmF0aWNEZXJpdmF0aXZlQXQgOiBxdWFkcmF0aWNBdCkoc2hhcGUueDEsIHNoYXBlLmNweDEsIHNoYXBlLngyLCB0KSxcbiAgICAgICAgICAgICAgICAoaXNUYW5nZW50ID8gcXVhZHJhdGljRGVyaXZhdGl2ZUF0IDogcXVhZHJhdGljQXQpKHNoYXBlLnkxLCBzaGFwZS5jcHkxLCBzaGFwZS55MiwgdClcbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICB9XG4gICAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi9QYXRoJykuZXh0ZW5kKHtcblxuICAgICAgICB0eXBlOiAnYmV6aWVyLWN1cnZlJyxcblxuICAgICAgICBzaGFwZToge1xuICAgICAgICAgICAgeDE6IDAsXG4gICAgICAgICAgICB5MTogMCxcbiAgICAgICAgICAgIHgyOiAwLFxuICAgICAgICAgICAgeTI6IDAsXG4gICAgICAgICAgICBjcHgxOiAwLFxuICAgICAgICAgICAgY3B5MTogMCxcbiAgICAgICAgICAgIC8vIGNweDI6IDAsXG4gICAgICAgICAgICAvLyBjcHkyOiAwXG5cbiAgICAgICAgICAgIC8vIEN1cnZlIHNob3cgcGVyY2VudCwgZm9yIGFuaW1hdGluZ1xuICAgICAgICAgICAgcGVyY2VudDogMVxuICAgICAgICB9LFxuXG4gICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICBzdHJva2U6ICcjMDAwJyxcbiAgICAgICAgICAgIGZpbGw6IG51bGxcbiAgICAgICAgfSxcblxuICAgICAgICBidWlsZFBhdGg6IGZ1bmN0aW9uIChjdHgsIHNoYXBlKSB7XG4gICAgICAgICAgICB2YXIgeDEgPSBzaGFwZS54MTtcbiAgICAgICAgICAgIHZhciB5MSA9IHNoYXBlLnkxO1xuICAgICAgICAgICAgdmFyIHgyID0gc2hhcGUueDI7XG4gICAgICAgICAgICB2YXIgeTIgPSBzaGFwZS55MjtcbiAgICAgICAgICAgIHZhciBjcHgxID0gc2hhcGUuY3B4MTtcbiAgICAgICAgICAgIHZhciBjcHkxID0gc2hhcGUuY3B5MTtcbiAgICAgICAgICAgIHZhciBjcHgyID0gc2hhcGUuY3B4MjtcbiAgICAgICAgICAgIHZhciBjcHkyID0gc2hhcGUuY3B5MjtcbiAgICAgICAgICAgIHZhciBwZXJjZW50ID0gc2hhcGUucGVyY2VudDtcbiAgICAgICAgICAgIGlmIChwZXJjZW50ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjdHgubW92ZVRvKHgxLCB5MSk7XG5cbiAgICAgICAgICAgIGlmIChjcHgyID09IG51bGwgfHwgY3B5MiA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBlcmNlbnQgPCAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHF1YWRyYXRpY1N1YmRpdmlkZShcbiAgICAgICAgICAgICAgICAgICAgICAgIHgxLCBjcHgxLCB4MiwgcGVyY2VudCwgb3V0XG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIGNweDEgPSBvdXRbMV07XG4gICAgICAgICAgICAgICAgICAgIHgyID0gb3V0WzJdO1xuICAgICAgICAgICAgICAgICAgICBxdWFkcmF0aWNTdWJkaXZpZGUoXG4gICAgICAgICAgICAgICAgICAgICAgICB5MSwgY3B5MSwgeTIsIHBlcmNlbnQsIG91dFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICBjcHkxID0gb3V0WzFdO1xuICAgICAgICAgICAgICAgICAgICB5MiA9IG91dFsyXTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjdHgucXVhZHJhdGljQ3VydmVUbyhcbiAgICAgICAgICAgICAgICAgICAgY3B4MSwgY3B5MSxcbiAgICAgICAgICAgICAgICAgICAgeDIsIHkyXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChwZXJjZW50IDwgMSkge1xuICAgICAgICAgICAgICAgICAgICBjdWJpY1N1YmRpdmlkZShcbiAgICAgICAgICAgICAgICAgICAgICAgIHgxLCBjcHgxLCBjcHgyLCB4MiwgcGVyY2VudCwgb3V0XG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIGNweDEgPSBvdXRbMV07XG4gICAgICAgICAgICAgICAgICAgIGNweDIgPSBvdXRbMl07XG4gICAgICAgICAgICAgICAgICAgIHgyID0gb3V0WzNdO1xuICAgICAgICAgICAgICAgICAgICBjdWJpY1N1YmRpdmlkZShcbiAgICAgICAgICAgICAgICAgICAgICAgIHkxLCBjcHkxLCBjcHkyLCB5MiwgcGVyY2VudCwgb3V0XG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIGNweTEgPSBvdXRbMV07XG4gICAgICAgICAgICAgICAgICAgIGNweTIgPSBvdXRbMl07XG4gICAgICAgICAgICAgICAgICAgIHkyID0gb3V0WzNdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjdHguYmV6aWVyQ3VydmVUbyhcbiAgICAgICAgICAgICAgICAgICAgY3B4MSwgY3B5MSxcbiAgICAgICAgICAgICAgICAgICAgY3B4MiwgY3B5MixcbiAgICAgICAgICAgICAgICAgICAgeDIsIHkyXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHBvaW50IGF0IHBlcmNlbnRcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSB0XG4gICAgICAgICAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fVxuICAgICAgICAgKi9cbiAgICAgICAgcG9pbnRBdDogZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgIHJldHVybiBzb21lVmVjdG9yQXQodGhpcy5zaGFwZSwgdCwgZmFsc2UpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGFuZ2VudCBhdCBwZXJjZW50XG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gdFxuICAgICAgICAgKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn1cbiAgICAgICAgICovXG4gICAgICAgIHRhbmdlbnRBdDogZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgIHZhciBwID0gc29tZVZlY3RvckF0KHRoaXMuc2hhcGUsIHQsIHRydWUpO1xuICAgICAgICAgICAgcmV0dXJuIHZlYzIubm9ybWFsaXplKHAsIHApO1xuICAgICAgICB9XG4gICAgfSk7XG5cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvQmV6aWVyQ3VydmUuanNcbiAqKiBtb2R1bGUgaWQgPSA1NFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiDlnIblvKdcbiAqIEBtb2R1bGUgenJlbmRlci9ncmFwaGljL3NoYXBlL0FyY1xuICovXG4gXG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uL1BhdGgnKS5leHRlbmQoe1xuXG4gICAgICAgIHR5cGU6ICdhcmMnLFxuXG4gICAgICAgIHNoYXBlOiB7XG5cbiAgICAgICAgICAgIGN4OiAwLFxuXG4gICAgICAgICAgICBjeTogMCxcblxuICAgICAgICAgICAgcjogMCxcblxuICAgICAgICAgICAgc3RhcnRBbmdsZTogMCxcblxuICAgICAgICAgICAgZW5kQW5nbGU6IE1hdGguUEkgKiAyLFxuXG4gICAgICAgICAgICBjbG9ja3dpc2U6IHRydWVcbiAgICAgICAgfSxcblxuICAgICAgICBzdHlsZToge1xuXG4gICAgICAgICAgICBzdHJva2U6ICcjMDAwJyxcblxuICAgICAgICAgICAgZmlsbDogbnVsbFxuICAgICAgICB9LFxuXG4gICAgICAgIGJ1aWxkUGF0aDogZnVuY3Rpb24gKGN0eCwgc2hhcGUpIHtcblxuICAgICAgICAgICAgdmFyIHggPSBzaGFwZS5jeDtcbiAgICAgICAgICAgIHZhciB5ID0gc2hhcGUuY3k7XG4gICAgICAgICAgICB2YXIgciA9IE1hdGgubWF4KHNoYXBlLnIsIDApO1xuICAgICAgICAgICAgdmFyIHN0YXJ0QW5nbGUgPSBzaGFwZS5zdGFydEFuZ2xlO1xuICAgICAgICAgICAgdmFyIGVuZEFuZ2xlID0gc2hhcGUuZW5kQW5nbGU7XG4gICAgICAgICAgICB2YXIgY2xvY2t3aXNlID0gc2hhcGUuY2xvY2t3aXNlO1xuXG4gICAgICAgICAgICB2YXIgdW5pdFggPSBNYXRoLmNvcyhzdGFydEFuZ2xlKTtcbiAgICAgICAgICAgIHZhciB1bml0WSA9IE1hdGguc2luKHN0YXJ0QW5nbGUpO1xuXG4gICAgICAgICAgICBjdHgubW92ZVRvKHVuaXRYICogciArIHgsIHVuaXRZICogciArIHkpO1xuICAgICAgICAgICAgY3R4LmFyYyh4LCB5LCByLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgIWNsb2Nrd2lzZSk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvQXJjLmpzXG4gKiogbW9kdWxlIGlkID0gNTVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJy4uL2NvcmUvdXRpbCcpO1xuXG4gICAgdmFyIEdyYWRpZW50ID0gcmVxdWlyZSgnLi9HcmFkaWVudCcpO1xuXG4gICAgLyoqXG4gICAgICogeCwgeSwgeDIsIHkyIGFyZSBhbGwgcGVyY2VudCBmcm9tIDAgdG8gMVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbeD0wXVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbeT0wXVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbeDI9MV1cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3kyPTBdXG4gICAgICogQHBhcmFtIHtBcnJheS48T2JqZWN0Pn0gY29sb3JTdG9wc1xuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2dsb2JhbENvb3JkPWZhbHNlXVxuICAgICAqL1xuICAgIHZhciBMaW5lYXJHcmFkaWVudCA9IGZ1bmN0aW9uICh4LCB5LCB4MiwgeTIsIGNvbG9yU3RvcHMsIGdsb2JhbENvb3JkKSB7XG4gICAgICAgIHRoaXMueCA9IHggPT0gbnVsbCA/IDAgOiB4O1xuXG4gICAgICAgIHRoaXMueSA9IHkgPT0gbnVsbCA/IDAgOiB5O1xuXG4gICAgICAgIHRoaXMueDIgPSB4MiA9PSBudWxsID8gMSA6IHgyO1xuXG4gICAgICAgIHRoaXMueTIgPSB5MiA9PSBudWxsID8gMCA6IHkyO1xuXG4gICAgICAgIC8vIENhbiBiZSBjbG9uZWRcbiAgICAgICAgdGhpcy50eXBlID0gJ2xpbmVhcic7XG5cbiAgICAgICAgLy8gSWYgdXNlIGdsb2JhbCBjb29yZFxuICAgICAgICB0aGlzLmdsb2JhbCA9IGdsb2JhbENvb3JkIHx8IGZhbHNlO1xuXG4gICAgICAgIEdyYWRpZW50LmNhbGwodGhpcywgY29sb3JTdG9wcyk7XG4gICAgfTtcblxuICAgIExpbmVhckdyYWRpZW50LnByb3RvdHlwZSA9IHtcblxuICAgICAgICBjb25zdHJ1Y3RvcjogTGluZWFyR3JhZGllbnRcbiAgICB9O1xuXG4gICAgenJVdGlsLmluaGVyaXRzKExpbmVhckdyYWRpZW50LCBHcmFkaWVudCk7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IExpbmVhckdyYWRpZW50O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34venJlbmRlci9saWIvZ3JhcGhpYy9MaW5lYXJHcmFkaWVudC5qc1xuICoqIG1vZHVsZSBpZCA9IDU2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cblxuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCcuLi9jb3JlL3V0aWwnKTtcblxuICAgIHZhciBHcmFkaWVudCA9IHJlcXVpcmUoJy4vR3JhZGllbnQnKTtcblxuICAgIC8qKlxuICAgICAqIHgsIHksIHIgYXJlIGFsbCBwZXJjZW50IGZyb20gMCB0byAxXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFt4PTAuNV1cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3k9MC41XVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcj0wLjVdXG4gICAgICogQHBhcmFtIHtBcnJheS48T2JqZWN0Pn0gW2NvbG9yU3RvcHNdXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbZ2xvYmFsQ29vcmQ9ZmFsc2VdXG4gICAgICovXG4gICAgdmFyIFJhZGlhbEdyYWRpZW50ID0gZnVuY3Rpb24gKHgsIHksIHIsIGNvbG9yU3RvcHMsIGdsb2JhbENvb3JkKSB7XG4gICAgICAgIHRoaXMueCA9IHggPT0gbnVsbCA/IDAuNSA6IHg7XG5cbiAgICAgICAgdGhpcy55ID0geSA9PSBudWxsID8gMC41IDogeTtcblxuICAgICAgICB0aGlzLnIgPSByID09IG51bGwgPyAwLjUgOiByO1xuXG4gICAgICAgIC8vIENhbiBiZSBjbG9uZWRcbiAgICAgICAgdGhpcy50eXBlID0gJ3JhZGlhbCc7XG5cbiAgICAgICAgLy8gSWYgdXNlIGdsb2JhbCBjb29yZFxuICAgICAgICB0aGlzLmdsb2JhbCA9IGdsb2JhbENvb3JkIHx8IGZhbHNlO1xuXG4gICAgICAgIEdyYWRpZW50LmNhbGwodGhpcywgY29sb3JTdG9wcyk7XG4gICAgfTtcblxuICAgIFJhZGlhbEdyYWRpZW50LnByb3RvdHlwZSA9IHtcblxuICAgICAgICBjb25zdHJ1Y3RvcjogUmFkaWFsR3JhZGllbnRcbiAgICB9O1xuXG4gICAgenJVdGlsLmluaGVyaXRzKFJhZGlhbEdyYWRpZW50LCBHcmFkaWVudCk7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IFJhZGlhbEdyYWRpZW50O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34venJlbmRlci9saWIvZ3JhcGhpYy9SYWRpYWxHcmFkaWVudC5qc1xuICoqIG1vZHVsZSBpZCA9IDU3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcclxuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcclxuICAgIHZhciBCb3VuZGluZ1JlY3QgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL0JvdW5kaW5nUmVjdC5qcycpO1xyXG4gICAgZnVuY3Rpb24gTWluaW1hcChiaWdDYW52YXMsZ3JvdXBQb3NpdGlvbiwgZ3JvdXAsZWFnbGVFeWVOb2RlLGRpc3RhbmNlLGltZ1NyYykge1xyXG5cclxuICAgICAgICB0aGlzLmJpZ0NhbnZhcyA9IGJpZ0NhbnZhcztcclxuICAgICAgICB0aGlzLmVhZ2xlRXllTm9kZSA9IGVhZ2xlRXllTm9kZTtcclxuICAgICAgICB0aGlzLmRpc3RhbmNlID0gZGlzdGFuY2U7XHJcbiAgICAgICAgdGhpcy5pbWdTcmMgPSBpbWdTcmM7XHJcbiAgICAgICAgdGhpcy5yYXRpbztcclxuICAgICAgICB0aGlzLmdyb3VwUmF0aW87XHJcbiAgICAgICAgdGhpcy5ncm91cCA9IGdyb3VwO1xyXG4gICAgICAgIHRoaXMuaW1nID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImltZ1wiKTtcclxuICAgICAgICB0aGlzLnNlbGVjdGlvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgICAgIHRoaXMuZ3JvdXBQb3NpdGlvbiA9IHpyVXRpbC5jbG9uZShncm91cFBvc2l0aW9uKTtcclxuICAgICAgICB0aGlzLnNlbGVjdFBvc2l0aW9uID0gWzAsMF07XHJcbiAgICAgICAgdGhpcy5yZW5kZXIoKTtcclxuICAgIH1cclxuXHJcbiAgICBNaW5pbWFwLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XHJcbiAgICAgICAgdGhhdC5yYXRpbyA9IDAuMTI7XHJcbiAgICAgICAgdmFyIGVhZ2xlRXllTm9kZVdpZHRoID0gdGhhdC5ncm91cC53aWR0aCAgKiB0aGF0LnJhdGlvO1xyXG4gICAgICAgIHZhciBlYWdsZUV5ZU5vZGVIZWlnaHQgPSB0aGF0Lmdyb3VwLmhlaWdodCAgKiB0aGF0LnJhdGlvO1xyXG4gICAgICAgIHRoYXQuZWFnbGVFeWVOb2RlLnN0eWxlLndpZHRoID0gZWFnbGVFeWVOb2RlV2lkdGgrXCJweFwiO1xyXG4gICAgICAgIHRoYXQuZWFnbGVFeWVOb2RlLnN0eWxlLmhlaWdodCA9IGVhZ2xlRXllTm9kZUhlaWdodCtcInB4XCI7XHJcbiAgICAgICAgdGhhdC5lYWdsZUV5ZU5vZGUuc3R5bGUubWFyZ2luVG9wID0gLWVhZ2xlRXllTm9kZUhlaWdodCtcInB4XCI7XHJcbiAgICAgICAgdGhhdC5lYWdsZUV5ZU5vZGUuc3R5bGUubWFyZ2luTGVmdCA9IHRoYXQuYmlnQ2FudmFzLmdldFdpZHRoKCktZWFnbGVFeWVOb2RlV2lkdGgrXCJweFwiO1xyXG4gICAgICAgIHRoYXQuZWFnbGVFeWVOb2RlLnN0eWxlLnBvc2l0aW9uPVwicmVsYXRpdmVcIjtcclxuICAgICAgICB0aGF0LmVhZ2xlRXllTm9kZS5zdHlsZS5iYWNrZ3JvdW5kID0gXCJ1cmwoXCIrdGhhdC5pbWdTcmMrXCIpIG5vLXJlcGVhdFwiO1xyXG4gICAgICAgIHRoYXQuZWFnbGVFeWVOb2RlLnN0eWxlLmJhY2tncm91bmRTaXplID0gZWFnbGVFeWVOb2RlV2lkdGgvKHRoYXQuZ3JvdXAud2lkdGgqdGhhdC5kaXN0YW5jZVsyXS90aGF0LmJpZ0NhbnZhcy5nZXRXaWR0aCgpKStcInB4XCI7XHJcbiAgICAgICAgdGhhdC5iYWNrZ3JvdW5kU2l6ZSA9IHpyVXRpbC5jbG9uZSh0aGF0LmVhZ2xlRXllTm9kZS5zdHlsZS5iYWNrZ3JvdW5kU2l6ZSk7XHJcbiAgICAgICAgdGhhdC5lYWdsZUV5ZU5vZGUuaW5uZXJIVE1MID0gXCJcIjtcclxuICAgICAgICB0aGF0LnNlbGVjdGlvbi5zdHlsZS5ib3JkZXIgPSBcIjFweCBzb2xpZCAjZmYwMDAwXCI7XHJcbiAgICAgICAgdGhhdC5zZWxlY3Rpb24uc3R5bGUuY3Vyc29yID0gXCJwb2ludGVyXCI7XHJcbiAgICAgICAgdGhhdC5zZWxlY3Rpb24uc3R5bGUud2lkdGggPSB0aGF0LmJpZ0NhbnZhcy5nZXRXaWR0aCgpL3RoYXQuZ3JvdXAud2lkdGgqZWFnbGVFeWVOb2RlV2lkdGgrXCJweFwiO1xyXG4gICAgICAgIHRoYXQuc2VsZWN0aW9uLnN0eWxlLmhlaWdodCA9IHRoYXQuYmlnQ2FudmFzLmdldEhlaWdodCgpL3RoYXQuZ3JvdXAuaGVpZ2h0KmVhZ2xlRXllTm9kZUhlaWdodCtcInB4XCI7XHJcbiAgICAgICAgdGhhdC5zZWxlY3RXaWR0aCA9IHRoYXQuc2VsZWN0aW9uLnN0eWxlLndpZHRoO1xyXG4gICAgICAgIHRoYXQuc2VsZWN0SGVpZ2h0ID0gdGhhdC5zZWxlY3Rpb24uc3R5bGUuaGVpZ2h0O1xyXG4gICAgICAgIHRoYXQuc2VsZWN0aW9uLnN0eWxlLnBvc2l0aW9uPVwiYWJzb2x1dGVcIjtcclxuICAgICAgICB0aGF0LnNlbGVjdGlvbi5zdHlsZS50b3AgPSAwK1wicHhcIjtcclxuICAgICAgICB0aGF0LnNlbGVjdGlvbi5zdHlsZS5sZWZ0ID0gMCtcInB4XCI7XHJcbiAgICAgICAgdGhhdC5lYWdsZUV5ZU5vZGUuYXBwZW5kQ2hpbGQodGhpcy5zZWxlY3Rpb24pO1xyXG4gICAgfTtcclxuICAgIE1pbmltYXAucHJvdG90eXBlLnVwZGF0YVNlbGVjdGlvbiA9IGZ1bmN0aW9uKG9mZmVjdExlZnQsb2ZmZWN0VG9wLHpvb21TY2FsZSxub3dab29tKXtcclxuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XHJcbiAgICAgICAgdGhhdC56b29tU2NhbGUgPSB6b29tU2NhbGU7XHJcbiAgICAgICAgdGhpcy5zZWxlY3Rpb24uc3R5bGUud2lkdGggPSB0aGlzLnNlbGVjdGlvbi5zdHlsZS53aWR0aC5yZXBsYWNlKFwicHhcIixcIlwiKS96b29tU2NhbGUrXCJweFwiO1xyXG4gICAgICAgIHRoaXMuc2VsZWN0aW9uLnN0eWxlLmhlaWdodCA9IHRoaXMuc2VsZWN0aW9uLnN0eWxlLmhlaWdodC5yZXBsYWNlKFwicHhcIixcIlwiKS96b29tU2NhbGUrXCJweFwiO1xyXG4gICAgICAgIHRoYXQuc2VsZWN0UG9zaXRpb25bMF0gPSB6clV0aWwuY2xvbmUob2ZmZWN0TGVmdCkqdGhhdC5yYXRpby9ub3dab29tO1xyXG4gICAgICAgIHRoYXQuc2VsZWN0UG9zaXRpb25bMV0gPSB6clV0aWwuY2xvbmUob2ZmZWN0VG9wKSp0aGF0LnJhdGlvL25vd1pvb207XHJcbiAgICAgICAgdGhpcy5zZWxlY3Rpb24uc3R5bGUubGVmdCA9IC10aGF0LnNlbGVjdFBvc2l0aW9uWzBdK1wicHhcIjtcclxuICAgICAgICB0aGlzLnNlbGVjdGlvbi5zdHlsZS50b3AgPSAtdGhhdC5zZWxlY3RQb3NpdGlvblsxXStcInB4XCI7XHJcbiAgICB9O1xyXG4gICAgTWluaW1hcC5wcm90b3R5cGUudXBkYXRhTWFwID0gZnVuY3Rpb24oaW1nU3JjLG5ld0dyb3VwKXtcclxuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XHJcbiAgICAgICAgdGhhdC5lYWdsZUV5ZU5vZGUuc3R5bGUuYmFja2dyb3VuZEltYWdlID0gXCJ1cmwoXCIraW1nU3JjK1wiKVwiO1xyXG4gICAgICAgIHZhciBlYWdsZUV5ZU5vZGVXaWR0aCA9IG5ld0dyb3VwLndpZHRoICAqIHRoYXQucmF0aW87XHJcbiAgICAgICAgdmFyIGVhZ2xlRXllTm9kZUhlaWdodCA9IG5ld0dyb3VwLmhlaWdodCAgKiB0aGF0LnJhdGlvO1xyXG4gICAgICAgIHRoYXQuZWFnbGVFeWVOb2RlLnN0eWxlLndpZHRoID0gZWFnbGVFeWVOb2RlV2lkdGgrXCJweFwiO1xyXG4gICAgICAgIHRoYXQuZWFnbGVFeWVOb2RlLnN0eWxlLmhlaWdodCA9IGVhZ2xlRXllTm9kZUhlaWdodCtcInB4XCI7XHJcbiAgICAgICAgdGhhdC5lYWdsZUV5ZU5vZGUuc3R5bGUubWFyZ2luVG9wID0gLWVhZ2xlRXllTm9kZUhlaWdodCtcInB4XCI7XHJcbiAgICAgICAgdGhhdC5lYWdsZUV5ZU5vZGUuc3R5bGUubWFyZ2luTGVmdCA9IHRoYXQuYmlnQ2FudmFzLmdldFdpZHRoKCktZWFnbGVFeWVOb2RlV2lkdGgrXCJweFwiO1xyXG4gICAgfTtcclxuICAgIE1pbmltYXAucHJvdG90eXBlLnVwZGF0YVNlbGVjdGlvblBvc2l0aW9uID0gZnVuY3Rpb24obm93R3JvdXBQb3NpdGlvbixub3dab29tKXtcclxuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XHJcbiAgICAgICAgdGhhdC5zZWxlY3RQb3NpdGlvblswXSA9IHpyVXRpbC5jbG9uZShub3dHcm91cFBvc2l0aW9uWzBdKSp0aGF0LnJhdGlvL25vd1pvb207XHJcbiAgICAgICAgdGhhdC5zZWxlY3RQb3NpdGlvblsxXSA9IHpyVXRpbC5jbG9uZShub3dHcm91cFBvc2l0aW9uWzFdKSp0aGF0LnJhdGlvL25vd1pvb207XHJcbiAgICAgICAgdGhpcy5zZWxlY3Rpb24uc3R5bGUubGVmdCA9IC10aGF0LnNlbGVjdFBvc2l0aW9uWzBdK1wicHhcIjtcclxuICAgICAgICB0aGlzLnNlbGVjdGlvbi5zdHlsZS50b3AgPSAtdGhhdC5zZWxlY3RQb3NpdGlvblsxXStcInB4XCI7XHJcbiAgICB9O1xyXG4gICAgTWluaW1hcC5wcm90b3R5cGUudXBkYXRhR3JvdXBQb3NpdGlvbiA9IGZ1bmN0aW9uKGdyb3VwLG5vd1pvb20pe1xyXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgICAgICB2YXIgcG9zaXRpb25YID0gLU51bWJlcih0aGF0LnNlbGVjdGlvbi5zdHlsZS5sZWZ0LnN1YnN0cmluZygwLHRoYXQuc2VsZWN0aW9uLnN0eWxlLmxlZnQubGVuZ3RoLTIpKS90aGF0LnJhdGlvKm5vd1pvb207XHJcbiAgICAgICAgdmFyIHBvc2l0aW9uWSA9IC1OdW1iZXIodGhhdC5zZWxlY3Rpb24uc3R5bGUudG9wLnN1YnN0cmluZygwLHRoYXQuc2VsZWN0aW9uLnN0eWxlLnRvcC5sZW5ndGgtMikpL3RoYXQucmF0aW8qbm93Wm9vbTtcclxuICAgICAgICBncm91cC5hdHRyKFwicG9zaXRpb25cIixbcG9zaXRpb25YLHBvc2l0aW9uWV0pO1xyXG4gICAgfTtcclxuXHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IE1pbmltYXA7XHJcblxyXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vbGliL2Zpc2gtdG9wby1jb3JlL2xpYi9taW5pbWFwLmpzXG4gKiogbW9kdWxlIGlkID0gNThcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxyXG4gKiDlt6Xlhbfmlrnms5XnsbtcclxuICogQGF1dGhvciB3YW5nLnhpYW9odVxyXG4gKi9cclxuXHJcbiAgICB2YXIgUG9pbnQgPSByZXF1aXJlKFwiLi9Qb2ludC5qc1wiKTtcclxuICAgIHZhciBMaW5lID0gcmVxdWlyZShcIi4vTGluZVN0cnVjdC5qc1wiKTtcclxuICAgIHZhciBncmFwaGljID0gcmVxdWlyZShcIi4vZ3JhcGhpYy5qc1wiKTtcclxuICAgIHZhciBCb3VuZGluZ1JlY3QgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL0JvdW5kaW5nUmVjdCcpO1xyXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xyXG4gICAgLyoqXHJcbiAgICAgKiDmnoTpgKDnsbvnu6fmib/lhbPns7tcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjbGF6eiDmupDnsbtcclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGJhc2VDbGF6eiDln7rnsbtcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gaW5oZXJpdHMoY2xhenosIGJhc2VDbGF6eikge1xyXG4gICAgICAgIHZhciBjbGF6elByb3RvdHlwZSA9IGNsYXp6LnByb3RvdHlwZTtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gRigpIHt9XHJcbiAgICAgICAgRi5wcm90b3R5cGUgPSBiYXNlQ2xhenoucHJvdG90eXBlO1xyXG4gICAgICAgIGNsYXp6LnByb3RvdHlwZSA9IG5ldyBGKCk7XHJcblxyXG4gICAgICAgIGZvciAodmFyIHByb3AgaW4gY2xhenpQcm90b3R5cGUpIHtcclxuICAgICAgICAgICAgY2xhenoucHJvdG90eXBlW3Byb3BdID0gY2xhenpQcm90b3R5cGVbcHJvcF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNsYXp6LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGNsYXp6O1xyXG4gICAgICAgIGNsYXp6LnN1cGVyQ2xhc3MgPSBiYXNlQ2xheno7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZ2V0VVVJRCgpIHtcclxuICAgICAgICB2YXIgY2hhcnMgPSAnMDEyMzQ1Njc4OUFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXonLnNwbGl0KCcnKSxcclxuICAgICAgICAgICAgdXVpZCA9IG5ldyBBcnJheSgzNiksXHJcbiAgICAgICAgICAgIHJuZCA9IDAsXHJcbiAgICAgICAgICAgIHI7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAzNjsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChpID09IDggfHwgaSA9PSAxMyB8fCBpID09IDE4IHx8IGkgPT0gMjMpIHtcclxuICAgICAgICAgICAgICAgIHV1aWRbaV0gPSAnLSc7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaSA9PSAxNCkge1xyXG4gICAgICAgICAgICAgICAgdXVpZFtpXSA9ICc0JztcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmIChybmQgPD0gMHgwMikgcm5kID0gMHgyMDAwMDAwICsgKE1hdGgucmFuZG9tKCkgKiAweDEwMDAwMDApIHwgMDtcclxuICAgICAgICAgICAgICAgIHIgPSBybmQgJiAweGY7XHJcbiAgICAgICAgICAgICAgICBybmQgPSBybmQgPj4gNDtcclxuICAgICAgICAgICAgICAgIHV1aWRbaV0gPSBjaGFyc1soaSA9PSAxOSkgPyAociAmIDB4MykgfCAweDggOiByXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gXCJzaWQtXCIgKyB1dWlkLmpvaW4oJycpO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIOiuoeeul+S4pOeCueS5i+mXtOeahOi3neemu1xyXG4gICAgICpAcGFyYW0ge1BvaW50fSBwMSAtIGZpcnN0IHtQb2ludH1cclxuICAgICAqQHBhcmFtIHtQb2ludH0gcDIgLSBzZWNvbmQge1BvaW50fVxyXG4gICAgICpAcmV0dXJuIHtOdW1iZXJ9IC0gdGhlIGRpc3RhbmNlIGJldHdlZW4gdGhvc2UgMiBwb2ludHMuIEl0IGlzIGFsd2F5cyBwb3NpdGl2ZS5cclxuICAgICAqKi9cclxuICAgIGZ1bmN0aW9uIGRpc3RhbmNlKHAxLCBwMikge1xyXG4gICAgICAgIHJldHVybiBNYXRoLnNxcnQoTWF0aC5wb3cocDEueCAtIHAyLngsIDIpICsgTWF0aC5wb3cocDEueSAtIHAyLnksIDIpKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOi/lOWbnuS4gOadoeaKmOe6vyDmnIDplb/nmoTkuKTkuKrngrlcclxuICAgICAqIEBwYXJhbSAge1t0eXBlXX0gcG9pbnRzIFtkZXNjcmlwdGlvbl1cclxuICAgICAqIEByZXR1cm4ge1t0eXBlXX0gICAgICAgIFtkZXNjcmlwdGlvbl1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZ2V0TWF4TGluZUxlbmd0aChwb2ludHMpIHtcclxuICAgICAgICB2YXIgbSA9IGRpc3RhbmNlKHBvaW50c1swXSwgcG9pbnRzWzFdKTtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gW3BvaW50c1swXSwgcG9pbnRzWzFdXTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IHBvaW50cy5sZW5ndGggLSAxOyBpKyspIHtcclxuXHJcbiAgICAgICAgICAgIGlmIChtIDwgZGlzdGFuY2UocG9pbnRzW2ldLCBwb2ludHNbaSArIDFdKSkge1xyXG4gICAgICAgICAgICAgICAgbSA9IGRpc3RhbmNlKHBvaW50c1tpXSwgcG9pbnRzW2kgKyAxXSlcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IFtwb2ludHNbaV0sIHBvaW50c1tpICsgMV1dO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlJldHVybnMgdGhlIGxlbmd0aCBvZiBhIFBvbHlsaW5lIHRoYXQgd291bGQgYmUgY3JlYXRlZCB3aXRoIGEgc2V0IG9mIHBvaW50c1xyXG4gICAgICpAcGFyYW0ge0FycmF5fSB2IC0gYW4ge0FycmF5fSBvZiB7UG9pbnRzfVxyXG4gICAgICpAcmV0dXJuIHtOdW1iZXJ9IC0gYSBwb3NpdGl2ZSBudW1iZXIgZXF1YWwgd2l0aCB0b3RhbCBsZW5ndGgqL1xyXG4gICAgZnVuY3Rpb24gZ2V0UG9seWxpbmVMZW5ndGgodikge1xyXG4gICAgICAgIHZhciBsID0gMDtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHYubGVuZ3RoIC0gMTsgaSsrKSB7XHJcbiAgICAgICAgICAgIGwgKz0gZGlzdGFuY2UodltpXSwgdltpICsgMV0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGw7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8qKlJldHVybnMgdGhlIG1heCBvZiBhIHZlY3RvclxyXG4gICAgICpAcGFyYW0ge0FycmF5fSB2IC0gdmVjdG9yIG9mIHtOdW1iZXJ9c1xyXG4gICAgICpAcmV0dXJuIHtOdW1iZXJ9IC0gdGhlIG1heGltdW0gbnVtYmVyIGZyb20gdGhlIHZlY3RvciBvciBOYU4gaWYgdmVjdG9yIGlzIGVtcHR5XHJcbiAgICAgKiovXHJcbiAgICBmdW5jdGlvbiBtYXgodikge1xyXG4gICAgICAgIGlmICh2LmxlbmdodCA9PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBOYU47XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdmFyIG0gPSB2WzBdO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHYubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGlmIChtIDwgdltpXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG0gPSB2W2ldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gbTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8qKlJldHVybnMgdGhlIG1pbiBvZiBhIHZlY3RvclxyXG4gICAgICpAcGFyYW0ge0FycmF5fSB2IC0gdmVjdG9yIG9mIHtOdW1iZXJ9c1xyXG4gICAgICpAcmV0dXJuIHtOdW1iZXJ9IC0gdGhlIG1pbmltdW0gbnVtYmVyIGZyb20gdGhlIHZlY3RvciBvciBOYU4gaWYgdmVjdG9yIGlzIGVtcHR5XHJcbiAgICAgKkBhdXRob3IgYWxleEBzY3JpcHRvaWQuY29tXHJcbiAgICAgKiovXHJcbiAgICBmdW5jdGlvbiBtaW4odikge1xyXG4gICAgICAgIGlmICh2LmxlbmdodCA9PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBOYU47XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdmFyIG0gPSB2WzBdO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHYubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGlmIChtID4gdltpXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG0gPSB2W2ldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gbTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDliKTmlq0g54K55pWw57uEIOaYr+WQpuato+S6pOebtOe6v+i3r+W+hFxyXG4gICAgICpUZXN0cyBpZiBhIHZlY3RvciBvZiBwb2ludHMgaXMgYW4gb3J0aG9nb25hbCBwYXRoIChtb3ZpbmcgaW4gbXVsdGlwbGVzIG9mIDkwIGRlZ3JlZXMpXHJcbiAgICAgKkBwYXJhbSB7QXJyYXl9IHYgLSBhbiB7QXJyYXl9IG9mIHtQb2ludH1zXHJcbiAgICAgKkByZXR1cm4ge0Jvb2xlYW59IC0gdHJ1ZSBpZiBwYXRoIGlzIHZhbGlkLCBmYWxzZSBvdGhlcndpc2VcclxuICAgICAqKi9cclxuICAgIGZ1bmN0aW9uIG9ydGhvZ29uYWxQYXRoKHYpIHtcclxuICAgICAgICBpZiAodi5sZW5ndGggPD0gMSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdi5sZW5ndGggLSAxOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKHZbaV0ueCAhPSB2W2kgKyAxXS54ICYmIHZbaV0ueSAhPSB2W2kgKyAxXS55KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqVGVzdCB0byBzZWUgaWYgMiB7TGluZX1zIGludGVyc2VjdHMuIFRoZXkgYXJlIGNvbnNpZGVyZWQgZmluaXRlIHNlZ21lbnRzXHJcbiAgICAgKmFuZCBub3QgdGhlIGluZmluaXRlIGxpbmVzIGZyb20gZ2VvbWV0cnlcclxuICAgICAqQHBhcmFtIHtMaW5lfSBsMSAtIGZpc3QgbGluZS9zZWdtZW50XHJcbiAgICAgKkBwYXJhbSB7TGluZX0gbDIgLSBsYXN0IGxpbmUvc2VnbWVudFxyXG4gICAgICpAcmV0dXJuIHtCb29sZWFufSB0cnVlIC0gaWYgdGhlIGxpbmVzIGludGVyc2VjdCBvciBmYWxzZSBpZiBub3RcclxuICAgICAqKi9cclxuICAgIGZ1bmN0aW9uIGxpbmVJbnRlcnNlY3RzTGluZShsMSwgbDIpIHtcclxuICAgICAgICAvLyBjaGVjayBmb3IgdHdvIHZlcnRpY2FsIGxpbmVzXHJcbiAgICAgICAgaWYgKGwxLnN0YXJ0UG9pbnQueCA9PSBsMS5lbmRQb2ludC54ICYmIGwyLnN0YXJ0UG9pbnQueCA9PSBsMi5lbmRQb2ludC54KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBsMS5zdGFydFBvaW50LnggPT0gbDIuc3RhcnRQb2ludC54ID8gLy8gaWYgJ2luZmluaXRlICdsaW5lcyBkbyBjb2luY2lkZSxcclxuICAgICAgICAgICAgICAgIC8vIHRoZW4gY2hlY2sgc2VnbWVudCBib3VuZHMgZm9yIG92ZXJsYXBwaW5nXHJcbiAgICAgICAgICAgICAgICBsMS5jb250YWlucyhsMi5zdGFydFBvaW50LngsIGwyLnN0YXJ0UG9pbnQueSkgfHxcclxuICAgICAgICAgICAgICAgIGwxLmNvbnRhaW5zKGwyLmVuZFBvaW50LngsIGwyLmVuZFBvaW50LnkpIDpcclxuICAgICAgICAgICAgICAgIC8vIGxpbmVzIGFyZSBwYXJhbGVsXHJcbiAgICAgICAgICAgICAgICBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gaWYgb25lIGxpbmUgaXMgdmVydGljYWwsIGFuZCBhbm90aGVyIGxpbmUgaXMgbm90IHZlcnRpY2FsXHJcbiAgICAgICAgZWxzZSBpZiAobDEuc3RhcnRQb2ludC54ID09IGwxLmVuZFBvaW50LnggfHwgbDIuc3RhcnRQb2ludC54ID09IGwyLmVuZFBvaW50LngpIHtcclxuICAgICAgICAgICAgLy8gbGV0IGFzc3VtZSBsMiBpcyB2ZXJ0aWNhbCwgb3RoZXJ3aXNlIGV4Y2hhbmdlIHRoZW1cclxuICAgICAgICAgICAgaWYgKGwxLnN0YXJ0UG9pbnQueCA9PSBsMS5lbmRQb2ludC54KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbCA9IGwxO1xyXG4gICAgICAgICAgICAgICAgbDEgPSBsMjtcclxuICAgICAgICAgICAgICAgIGwyID0gbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBmaW5kaW5nIGludGVyc2VjdGlvbiBvZiAnaW5maW5pdGUnIGxpbmVzXHJcbiAgICAgICAgICAgIC8vIGVxdWF0aW9uIG9mIHRoZSBmaXJzdCBsaW5lIGlzIHkgPSBheCArIGIsIHNlY29uZDogeCA9IGNcclxuICAgICAgICAgICAgdmFyIGEgPSAobDEuZW5kUG9pbnQueSAtIGwxLnN0YXJ0UG9pbnQueSkgLyAobDEuZW5kUG9pbnQueCAtIGwxLnN0YXJ0UG9pbnQueCk7XHJcbiAgICAgICAgICAgIHZhciBiID0gbDEuc3RhcnRQb2ludC55IC0gYSAqIGwxLnN0YXJ0UG9pbnQueDtcclxuICAgICAgICAgICAgdmFyIHgwID0gbDIuc3RhcnRQb2ludC54O1xyXG4gICAgICAgICAgICB2YXIgeTAgPSBhICogeDAgKyBiO1xyXG4gICAgICAgICAgICByZXR1cm4gbDEuY29udGFpbnMoeDAsIHkwKSAmJiBsMi5jb250YWlucyh4MCwgeTApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gY2hlY2sgbm9ybWFsIGNhc2UgLSBib3RoIGxpbmVzIGFyZSBub3QgdmVydGljYWxcclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy9saW5lIGVxdWF0aW9uIGlzIDogeSA9IGEqeCArIGIsIGIgPSB5IC0gYSAqIHhcclxuICAgICAgICAgICAgdmFyIGExID0gKGwxLmVuZFBvaW50LnkgLSBsMS5zdGFydFBvaW50LnkpIC8gKGwxLmVuZFBvaW50LnggLSBsMS5zdGFydFBvaW50LngpO1xyXG4gICAgICAgICAgICB2YXIgYjEgPSBsMS5zdGFydFBvaW50LnkgLSBhMSAqIGwxLnN0YXJ0UG9pbnQueDtcclxuXHJcbiAgICAgICAgICAgIHZhciBhMiA9IChsMi5lbmRQb2ludC55IC0gbDIuc3RhcnRQb2ludC55KSAvIChsMi5lbmRQb2ludC54IC0gbDIuc3RhcnRQb2ludC54KTtcclxuICAgICAgICAgICAgdmFyIGIyID0gbDIuc3RhcnRQb2ludC55IC0gYTIgKiBsMi5zdGFydFBvaW50Lng7XHJcblxyXG4gICAgICAgICAgICBpZiAoYTEgPT0gYTIpIHsgLy9wYXJhbGVsIGxpbmVzXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYjEgPT0gYjIgP1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGZvciBjb2luY2lkZSBsaW5lcywgY2hlY2sgZm9yIHNlZ21lbnQgYm91bmRzIG92ZXJsYXBwaW5nXHJcbiAgICAgICAgICAgICAgICAgICAgbDEuY29udGFpbnMobDIuc3RhcnRQb2ludC54LCBsMi5zdGFydFBvaW50LnkpIHx8IGwxLmNvbnRhaW5zKGwyLmVuZFBvaW50LngsIGwyLmVuZFBvaW50LnkpIDpcclxuICAgICAgICAgICAgICAgICAgICAvLyBub3QgY29pbmNpZGUgcGFyYWxlbCBsaW5lcyBoYXZlIG5vIGNoYW5jZSB0byBpbnRlcnNlY3RcclxuICAgICAgICAgICAgICAgICAgICBmYWxzZTtcclxuICAgICAgICAgICAgfSBlbHNlIHsgLy91c3VhbCBjYXNlIC0gbm9uIHBhcmFsZWwsIHRoZSAnaW5maW5pdGUnIGxpbmVzIGludGVyc2VjdHMuLi53ZSBvbmx5IG5lZWQgdG8ga25vdyBpZiBpbnNpZGUgdGhlIHNlZ21lbnRcclxuXHJcbiAgICAgICAgICAgICAgICAvKlxyXG4gICAgICAgICAgICAgICAgICogaWYgb25lIG9mIHRoZSBsaW5lcyBhcmUgdmVydGljYWwsIHRoZW4geDAgaXMgZXF1YWwgdG8gdGhlaXIgeCxcclxuICAgICAgICAgICAgICAgICAqIG90aGVyd2lzZTpcclxuICAgICAgICAgICAgICAgICAqIHkxID0gYTEgKiB4ICsgYjFcclxuICAgICAgICAgICAgICAgICAqIHkyID0gYTIgKiB4ICsgYjJcclxuICAgICAgICAgICAgICAgICAqID0+IHgwID0gKGIyIC0gYjEpIC8gKGExIC0gYTIpXHJcbiAgICAgICAgICAgICAgICAgKiA9PiB5MCA9IGExICogeDAgKyBiMVxyXG4gICAgICAgICAgICAgICAgICoqL1xyXG4gICAgICAgICAgICAgICAgeDAgPSAoYjIgLSBiMSkgLyAoYTEgLSBhMik7XHJcbiAgICAgICAgICAgICAgICB5MCA9IGExICogeDAgKyBiMTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBsMS5jb250YWlucyh4MCwgeTApICYmIGwyLmNvbnRhaW5zKHgwLCB5MCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKlxyXG4gICAgICpUZXN0cyBpZiBhIGEgcG9seWxpbmUgZGVmaW5lZCBieSBhIHNldCBvZiBwb2ludHMgaW50ZXJzZWN0cyBhIHJlY3RhbmdsZVxyXG4gICAgICpAcGFyYW0ge0FycmF5fSBwb2ludHMgLSBhbmQge0FycmF5fSBvZiB7UG9pbnR9c1xyXG4gICAgICpAcGFyYW0ge0FycmF5fSBib3VuZHMgLSB0aGUgYm91bmRzIG9mIHRoZSByZWN0YW5nbGUgZGVmaW5lZCBieSAoeDEsIHkxLCB4MiwgeTIpXHJcbiAgICAgKkBwYXJhbSB7Qm9vbGVhbn0gY2xvc2VkUG9seWxpbmUgLSBpbmNhc2UgcG9seWxpbmUgaXMgY2xvc2VkIGZpZ3VyZSB0aGVuIHRydWUsIGVsc2UgZmFsc2VcclxuICAgICAqXHJcbiAgICAgKkByZXR1cm4gdHJ1ZSAtIGlmIGxpbmUgaW50ZXJzZWN0cyB0aGUgcmVjdGFuZ2xlLCBmYWxzZSAtIGlmIG5vdFxyXG4gICAgICoqL1xyXG4gICAgZnVuY3Rpb24gcG9seWxpbmVJbnRlcnNlY3RzUmVjdGFuZ2xlKHBvaW50cywgYm91bmRzLCBjbG9zZWRQb2x5bGluZSkge1xyXG5cclxuXHJcbiAgICAgICAgLy9nZXQgdGhlIDQgbGluZXMvc2VnbWVudHMgcmVwcmVzZW50ZWQgYnkgdGhlIGJvdW5kc1xyXG4gICAgICAgIHZhciBsaW5lcyA9IFtdO1xyXG4gICAgICAgIGxpbmVzLnB1c2gobmV3IExpbmUobmV3IFBvaW50KGJvdW5kc1swXSwgYm91bmRzWzFdKSwgbmV3IFBvaW50KGJvdW5kc1syXSwgYm91bmRzWzFdKSkpO1xyXG4gICAgICAgIGxpbmVzLnB1c2gobmV3IExpbmUobmV3IFBvaW50KGJvdW5kc1syXSwgYm91bmRzWzFdKSwgbmV3IFBvaW50KGJvdW5kc1syXSwgYm91bmRzWzNdKSkpO1xyXG4gICAgICAgIGxpbmVzLnB1c2gobmV3IExpbmUobmV3IFBvaW50KGJvdW5kc1syXSwgYm91bmRzWzNdKSwgbmV3IFBvaW50KGJvdW5kc1swXSwgYm91bmRzWzNdKSkpO1xyXG4gICAgICAgIGxpbmVzLnB1c2gobmV3IExpbmUobmV3IFBvaW50KGJvdW5kc1swXSwgYm91bmRzWzNdKSwgbmV3IFBvaW50KGJvdW5kc1swXSwgYm91bmRzWzFdKSkpO1xyXG5cclxuICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IHBvaW50cy5sZW5ndGggLSAxOyBrKyspIHtcclxuICAgICAgICAgICAgLy9jcmVhdGUgYSBsaW5lIG91dCBvZiBlYWNoIDIgY29uc2VjdXRpdmUgcG9pbnRzXHJcbiAgICAgICAgICAgIHZhciB0ZW1wTGluZSA9IG5ldyBMaW5lKHBvaW50c1trXSwgcG9pbnRzW2sgKyAxXSk7XHJcblxyXG4gICAgICAgICAgICAvL3NlZSBpZiB0aGF0IGxpbmUgaW50ZXJzZWN0IGFueSBvZiB0aGUgbGluZSBvbiBib3VuZHMgYm9yZGVyXHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGlmIChsaW5lSW50ZXJzZWN0c0xpbmUodGVtcExpbmUsIGxpbmVzW2ldKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL2NoZWNrIHRoZSBjbG9zZWQgZmlndXJlIC0gdGhhdCBpcyBsYXN0IHBvaW50IGNvbm5lY3RlZCB0byB0aGUgZmlyc3RcclxuICAgICAgICBpZiAoY2xvc2VkUG9seWxpbmUpIHtcclxuICAgICAgICAgICAgLy9jcmVhdGUgYSBsaW5lIG91dCBvZiBlYWNoIDIgY29uc2VjdXRpdmUgcG9pbnRzXHJcbiAgICAgICAgICAgIHZhciB0ZW1wTGluZTEgPSBuZXcgTGluZShwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDFdLCBwb2ludHNbMF0pO1xyXG5cclxuICAgICAgICAgICAgLy9zZWUgaWYgdGhhdCBsaW5lIGludGVyc2VjdCBhbnkgb2YgdGhlIGxpbmUgb24gYm91bmRzIGJvcmRlclxyXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGxpbmVzLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobGluZUludGVyc2VjdHNMaW5lKHRlbXBMaW5lMSwgbGluZXNbal0pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOiuoeeul+i3r+W+hOeahOWIhuaVsFxyXG4gICAgICogU2NvcmUgYSBvcnRvZ29uYWwgcGF0aCBtYWRlIG91dCBvZiBQb2ludHNcclxuICAgICAqSXRlcmF0ZXMgb3ZlciBhIHNldCBvZiBwb2ludHMgKG1pbmltdW0gMylcclxuICAgICAqRm9yIGVhY2ggMyBwb2ludHMgKGksIGkrMSwgaSsyKSA6XHJcbiAgICAgKiAgLSBpZiB0aGUgM3JkIG9uZSBpcyBhZnRlciB0aGUgMm5kIG9uIHRoZSBzYW1lIGxpbmUgd2UgYWRkICsxXHJcbiAgICAgKiAgLSBpZiB0aGUgM3JkIGlzIHVwIG9yIGRvd24gcmVsYXRlZCB0byB0aGUgMm5kIHdlIGRvIG5vdCBkbyBhbnl0aGluZyArMFxyXG4gICAgICogIC0gaWYgdGhlIDNyZCBnb2VzIGJhY2sgd2UgaW1lZGlhdGVsbHkgcmV0dXJuIC0xXHJcbiAgICAgKkBwYXJhbSB7QXJyYXl9IHYgLSBhbiBhcnJheSBvZiB7UG9pbnR9c1xyXG4gICAgICpAcmV0dXJuIHtOdW1iZXJ9IC0gLTEgaWYgdGhlIHBhdGggaXMgd3JvbmcgKGdvZXMgYmFjaykgb3Igc29tZXRoaW5nID49IDAgaWYgaXMgZmluZVxyXG4gICAgICogIFRoZSBiaWdnZXIgdGhlIG51bWJlciB0aGUgc21vb3RoIHRoZSBwYXRoIGlzXHJcbiAgICAgKiovXHJcbiAgICBmdW5jdGlvbiBzY29yZVBhdGgodikge1xyXG4gICAgICAgIGlmICh2Lmxlbmd0aCA8PSAyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBzY29yZSA9IDA7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCB2Lmxlbmd0aCAtIDE7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAodltpIC0gMV0ueCA9PSB2W2ldLnggJiYgdltpXS54ID09IHZbaSArIDFdLngpIHsgLy9vbiB0aGUgc2FtZSB2ZXJ0aWNhbFxyXG4gICAgICAgICAgICAgICAgaWYgKHNpZ251bSh2W2kgKyAxXS55IC0gdltpXS55KSA9PSBzaWdudW0odltpXS55IC0gdltpIC0gMV0ueSkpIHsgLy9zYW1lIGRpcmVjdGlvblxyXG4gICAgICAgICAgICAgICAgICAgIHNjb3JlKys7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgeyAvL2dvaW5nIGJhY2sgLSBubyBnb29kXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHZbaSAtIDFdLnkgPT0gdltpXS55ICYmIHZbaV0ueSA9PSB2W2kgKyAxXS55KSB7IC8vb24gdGhlIHNhbWUgaG9yaXpvbnRhbFxyXG4gICAgICAgICAgICAgICAgaWYgKHNpZ251bSh2W2kgKyAxXS54IC0gdltpXS54KSA9PSBzaWdudW0odltpXS54IC0gdltpIC0gMV0ueCkpIHsgLy9zYW1lIGRpcmVjdGlvblxyXG4gICAgICAgICAgICAgICAgICAgIHNjb3JlKys7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgeyAvL2dvaW5nIGJhY2sgLSBubyBnb29kXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2UgeyAvL25vdCBvbiBzYW1lIHZlcnRpY2FsIG5vciBob3Jpem9udGFsXHJcbiAgICAgICAgICAgICAgICBzY29yZS0tO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gc2NvcmU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDov5Tlm57mlbDlrZfnrKblj7fvvIgrIC0pXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBzaWduIG9mIGEgbnVtYmVyXHJcbiAgICAgKkBwYXJhbSB7TnVtYmVyfSB4IC0gdGhlIG51bWJlclxyXG4gICAgICpAcmV0dXJucyB7TnVtYmVyfVxyXG4gICAgICpAc2VlIDxhIGhyZWY9XCJodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1NpZ25fZnVuY3Rpb25cIj5odHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1NpZ25fZnVuY3Rpb248L2E+XHJcbiAgICAgKiovXHJcbiAgICBmdW5jdGlvbiBzaWdudW0oeCkge1xyXG4gICAgICAgIGlmICh4ID4gMClcclxuICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgZWxzZSBpZiAoeCA8IDApXHJcbiAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog5Yik5patIOeCueaVsOe7hCDmmK/kuI3mmK/mnInmlYjot6/lvoTvvIjmsqHmnInlm57ot6/vvIlcclxuICAgICAqVGVzdHMgaWYgYSB2ZWN0b3Igb2YgcG9pbnRzIGlzIGEgdmFsaWQgcGF0aCAobm90IGdvaW5nIGJhY2spXHJcbiAgICAgKlRoZXJlIGFyZSBhIGZldyBwcm9ibGVtcyBoZXJlLiBJZiB5b3UgaGF2ZSBwMSwgcDIsIHAzIGFuZCBwNCBhbmQgcDIgPSBwMyB5b3UgbmVlZCB0byBpZ25vcmUgdGhhdFxyXG4gICAgICpAcGFyYW0ge0FycmF5fSB2IC0gYW4ge0FycmF5fSBvZiB7UG9pbnR9c1xyXG4gICAgICpAcmV0dXJuIHtCb29sZWFufSAtIHRydWUgaWYgcGF0aCBpcyB2YWxpZCwgZmFsc2Ugb3RoZXJ3aXNlXHJcbiAgICAgKiovXHJcbiAgICBmdW5jdGlvbiBmb3J3YXJkUGF0aCh2KSB7XHJcbiAgICAgICAgaWYgKHYubGVuZ3RoIDw9IDIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHYubGVuZ3RoIC0gMjsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmICh2W2ldLnggPT0gdltpICsgMV0ueCAmJiB2W2kgKyAxXS54ID09IHZbaSArIDJdLngpIHsgLy9vbiB0aGUgc2FtZSB2ZXJ0aWNhbFxyXG4gICAgICAgICAgICAgICAgaWYgKHNpZ251bSh2W2kgKyAxXS55IC0gdltpXS55KSAhPSAwKSB7IC8vdGVzdCBvbmx5IHdlIGhhdmUgYSBwcm9ncmVzc2luZyBwYXRoXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNpZ251bSh2W2kgKyAxXS55IC0gdltpXS55KSA9PSAtMSAqIHNpZ251bSh2W2kgKyAyXS55IC0gdltpICsgMV0ueSkpIHsgLy9nb2luZyBiYWNrIChpZ25vcmUgemVybylcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIGlmICh2W2ldLnkgPT0gdltpICsgMV0ueSAmJiB2W2kgKyAxXS55ID09IHZbaSArIDJdLnkpIHsgLy9vbiB0aGUgc2FtZSBob3Jpem9udGFsXHJcbiAgICAgICAgICAgICAgICBpZiAoc2lnbnVtKHZbaSArIDFdLnggLSB2W2ldLngpICE9IDApIHsgLy90ZXN0IG9ubHkgd2UgaGF2ZSBhIHByb2dyZXNzaW5nIHBhdGhcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc2lnbnVtKHZbaSArIDFdLnggLSB2W2ldLngpID09IC0xICogc2lnbnVtKHZbaSArIDJdLnggLSB2W2kgKyAxXS54KSkgeyAvL2dvaW5nIGJhY2sgKGlnbm9yZSB6ZXJvKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOWwhlt4OjAseTowXei9rOWMluS4ulswLCAwXSAg57uZenJlbmRlcuS9v+eUqFxyXG4gICAgICogQHBhcmFtICB7W3R5cGVdfSBwb2ludHMgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICogQHBhcmFtICB7W3R5cGVdfSBpc1JldmVydCBbZGVzY3JpcHRpb25dXHJcbiAgICAgKiBAcmV0dXJuIHtbdHlwZV19ICAgICAgICBbZGVzY3JpcHRpb25dXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHRyYXNsYXRlUG9pbnRzKHBvaW50cywgaXNSZXZlcnQpIHtcclxuICAgICAgICB2YXIgbmV3UG9pbnRzID0gW107XHJcbiAgICAgICAgaWYgKGlzUmV2ZXJ0KSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcG9pbnQgPSBwb2ludHNbaV07XHJcbiAgICAgICAgICAgICAgICBuZXdQb2ludHMucHVzaChuZXcgUG9pbnQocG9pbnRbMF0sIHBvaW50WzFdKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG5ld1BvaW50cztcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHBvaW50cy5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHBvaW50MSA9IHBvaW50c1tqXTtcclxuICAgICAgICAgICAgICAgIG5ld1BvaW50cy5wdXNoKFtwb2ludDEueCwgcG9pbnQxLnldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbmV3UG9pbnRzO1xyXG4gICAgICAgIH1cclxuXHJcblxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHJvdGF0aW9uTWF0cml4KGFuZ2xlKSB7XHJcbiAgICAgICAgdmFyIG1SZXR1cm4gPSBbXHJcbiAgICAgICAgICAgIFtNYXRoLmNvcyhhbmdsZSksIC1NYXRoLnNpbihhbmdsZSksIDBdLFxyXG4gICAgICAgICAgICBbTWF0aC5zaW4oYW5nbGUpLCBNYXRoLmNvcyhhbmdsZSksIDBdLFxyXG4gICAgICAgICAgICBbMCwgMCwgMV1cclxuICAgICAgICBdO1xyXG4gICAgICAgIHJldHVybiBtUmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHRyYW5zbGF0aW9uTWF0cml4KGR4LCBkeSkge1xyXG4gICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgIFsxLCAwLCBkeF0sXHJcbiAgICAgICAgICAgIFswLCAxLCBkeV0sXHJcbiAgICAgICAgICAgIFswLCAwLCAxXVxyXG4gICAgICAgIF07XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gc2NhbGVNYXRyaXgoc3gsIHN5KSB7XHJcbiAgICAgICAgaWYgKHN5ID09IG51bGwpIHtcclxuICAgICAgICAgICAgc3kgPSBzeDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgW3N4LCAwLCAwXSxcclxuICAgICAgICAgICAgWzAsIHN5LCAwXSxcclxuICAgICAgICAgICAgWzAsIDAsIDFdXHJcbiAgICAgICAgXTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogSXQgd2lsbCByZXR1cm4gdGhlIGVuZCBwb2ludCBvZiBhIGxpbmUgb24gYSBnaXZlbiBhbmdsZSAoY2xvY2t3aXNlKS5cclxuICAgICAqIEBwYXJhbSB7UG9pbnR9IHN0YXJ0UG9pbnQgLSB0aGUgc3RhcnQgb2YgdGhlIGxpbmVcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsZW5ndGggLSB0aGUgbGVuZ3RoIG9mIHRoZSBsaW5lXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYW5nbGUgLSB0aGUgYW5nbGUgb2YgdGhlIGxpbmUgaW4gcmFkaWFuc1xyXG4gICAgICogQHJldHVybiB7UG9pbnR9IC0gdGhlIGVuZFBvaW50IG9mIHRoZSBsaW5lXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGdldEVuZFBvaW50KHN0YXJ0UG9pbnQsIGxlbmd0aCwgYW5nbGUpIHtcclxuICAgICAgICB2YXIgZW5kUG9pbnQgPSBzdGFydFBvaW50LmNsb25lKCk7XHJcbiAgICAgICAgZW5kUG9pbnQudHJhbnNmb3JtKHRyYW5zbGF0aW9uTWF0cml4KC1zdGFydFBvaW50LngsIC1zdGFydFBvaW50LnkpKTtcclxuICAgICAgICBlbmRQb2ludC55IC09IGxlbmd0aDtcclxuICAgICAgICBlbmRQb2ludC50cmFuc2Zvcm0ocm90YXRpb25NYXRyaXgoYW5nbGUpKTtcclxuICAgICAgICBlbmRQb2ludC50cmFuc2Zvcm0odHJhbnNsYXRpb25NYXRyaXgoc3RhcnRQb2ludC54LCBzdGFydFBvaW50LnkpKTtcclxuICAgICAgICByZXR1cm4gZW5kUG9pbnQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDojrflj5bojrflj5bkuKTkuKrlm77lvaLnmoTlpJbpnaLlm5vkuKrov57mjqXngrlcclxuICAgICAqIEBwYXJhbSAge1t0eXBlXX0gbm9kZSBbZGVzY3JpcHRpb25dXHJcbiAgICAgKiBAcmV0dXJuIHtbdHlwZV19ICAgICAgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBnZXRDb25uZWN0b3JQb2ludHMobm9kZSkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGxlZnQ6IG5ldyBQb2ludChub2RlLngsIG5vZGUueSArIG5vZGUuaGVpZ2h0IC8gMiksIC8v55+p5b2iIOW3puS4reeahOS9jee9rlxyXG4gICAgICAgICAgICB0b3A6IG5ldyBQb2ludChub2RlLnggKyBub2RlLndpZHRoIC8gMiwgbm9kZS55KSwgLy/nn6nlvaIg5LiK5Lit55qE5L2N572uXHJcbiAgICAgICAgICAgIHJpZ2h0OiBuZXcgUG9pbnQobm9kZS54ICsgbm9kZS53aWR0aCwgbm9kZS55ICsgbm9kZS5oZWlnaHQgLyAyKSwgLy/nn6nlvaIg5Y+z5Lit55qE5L2N572uXHJcbiAgICAgICAgICAgIGJvdHRvbTogbmV3IFBvaW50KG5vZGUueCArIG5vZGUud2lkdGggLyAyLCBub2RlLnkgKyBub2RlLmhlaWdodCksIC8v55+p5b2iIOS4i+S4reeahOS9jee9rlxyXG4gICAgICAgICAgICBjZW50ZXI6IG5ldyBQb2ludChub2RlLnggKyBub2RlLndpZHRoIC8gMiwgbm9kZS55ICsgbm9kZS5oZWlnaHQgLyAyKSAvL+S4remXtOS9jee9rlxyXG5cclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog6I635Y+W6I635Y+W5Lik5Liq5Zu+5b2i55qE5aSW6Z2i5Zub5Liq6L+e5o6l54K5XHJcbiAgICAgKiBAcGFyYW0gIHtbdHlwZV19IG5vZGUgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICogQHJldHVybiB7W3R5cGVdfSAgICAgIFtkZXNjcmlwdGlvbl1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZ2V0U29sdFBvaW50cyhub2RlKSB7XHJcbiAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgLy90b3BcclxuICAgICAgICAgICAgW01hdGgucm91bmQobm9kZS5nZXRSZWN0KCkud2lkdGggLyAzIC8xMCkqMTAsIDAgXSxcclxuICAgICAgICAgICAgW01hdGgucm91bmQoMipub2RlLmdldFJlY3QoKS53aWR0aCAvIDMgLzEwKSoxMCwgMCBdLFxyXG4gICAgICAgICAgICAvL3JpZ2h0XHJcbiAgICAgICAgICAgIFtub2RlLmdldFJlY3QoKS53aWR0aCwgTWF0aC5yb3VuZChub2RlLmdldFJlY3QoKS5oZWlnaHQgLyAzIC8xMCkqMTAgXSxcclxuICAgICAgICAgICAgW25vZGUuZ2V0UmVjdCgpLndpZHRoLCBNYXRoLnJvdW5kKDIqbm9kZS5nZXRSZWN0KCkuaGVpZ2h0IC8gMyAvMTApKjEwIF0sXHJcbiAgICAgICAgICAgIC8vYm90dG9tXHJcbiAgICAgICAgICAgIFtNYXRoLnJvdW5kKG5vZGUuZ2V0UmVjdCgpLndpZHRoIC8gMyAvMTApKjEwLCBub2RlLmdldFJlY3QoKS5oZWlnaHQgXSxcclxuICAgICAgICAgICAgW01hdGgucm91bmQoMipub2RlLmdldFJlY3QoKS53aWR0aCAvIDMgLzEwKSoxMCwgbm9kZS5nZXRSZWN0KCkuaGVpZ2h0IF0sXHJcbiAgICAgICAgICAgIC8vbGVmdFxyXG4gICAgICAgICAgICBbMCwgTWF0aC5yb3VuZChub2RlLmdldFJlY3QoKS5oZWlnaHQgLyAzIC8xMCkqMTAgXSxcclxuICAgICAgICAgICAgWzAsIE1hdGgucm91bmQoMipub2RlLmdldFJlY3QoKS5oZWlnaHQgLyAzIC8xMCkqMTAgXVxyXG5cclxuICAgICAgICBdXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDorqHnrpcgcDEgcDLkuKTngrnmiYDov57mjqXnmoTnm7Tnur/nmoTop5LluqZcclxuICAgICAqIEBwYXJhbSAge1t0eXBlXX0gcDEgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICogQHBhcmFtICB7W3R5cGVdfSBwMiBbZGVzY3JpcHRpb25dXHJcbiAgICAgKiBAcmV0dXJuIHtbdHlwZV19ICAgIFtkZXNjcmlwdGlvbl1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gdGFuZ2VudFJvdGF0aW9uKHAxLCBwMikge1xyXG4gICAgICAgIHJldHVybiAtTWF0aC5QSSAvIDIgLSBNYXRoLmF0YW4yKFxyXG4gICAgICAgICAgICBwMi55IC0gcDEueSwgcDIueCAtIHAxLnhcclxuICAgICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog5Yik5patM+eCueaYr+WQpuWcqOS4gOadoeebtOe6v+S4ilxyXG4gICAgICogVGVzdHMgaWYgMyBwb2ludHMgYXJlIGNvbGluaWFyIHdpdGggbWF0cml4IGRldGVybWluYW50cy5cclxuICAgICAqIElmIHRoZSBkZXRlcm1pbmF0IG9mIG1hdHJpeFxyXG4gICAgICogLyAgICAgICAgIFxcXHJcbiAgICAgKiB8IHgxIHkxIDEgfFxyXG4gICAgICogfCB4MiB5MiAxIHxcclxuICAgICAqIHwgeDMgeTMgMSB8XHJcbiAgICAgKiBcXCAgICAgICAgIC9cclxuICAgICAqIGlzIHplcm8gaXQgbWVhbnMgdGhhdCB0aGUgcG9pbnRzIGFyZSBjb2xpbmVhclxyXG4gICAgICpAcGFyYW0ge1BvaW50fSBwMSAtIGZpcnN0IHBvaW50XHJcbiAgICAgKkBwYXJhbSB7UG9pbnR9IHAyIC0gc2Vjb25kIHBvaW50XHJcbiAgICAgKkBwYXJhbSB7UG9pbnR9IHAzIC0gdGhpcmQgcG9pbnRcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBwcmVjaXNzaW9uXHJcbiAgICAgKkByZXR1cm4ge0Jvb2xlYW59IC0gdHJ1ZSBpZiBjb2xpbmlhciBhbmQgZmFsc2UgaWYgbm90XHJcbiAgICAgKkBhdXRob3IgQWxleFxyXG4gICAgICpAc2VlIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRGV0ZXJtaW5hbnRcclxuICAgICAqQHNlZSBodHRwczovL3Blb3BsZS5yaWNobGFuZC5lZHUvamFtZXMvbGVjdHVyZS9tMTE2L21hdHJpY2VzL2FwcGxpY2F0aW9ucy5odG1sXHJcbiAgICAgKiovXHJcbiAgICBmdW5jdGlvbiBjb2xsaW5lYXJpdHkocDEsIHAyLCBwMywgcHJlY2lzc2lvbikge1xyXG4gICAgICAgIHZhciBkZXRlcm1pbmFudCA9IChwMS54ICogcDIueSArIHAxLnkgKiBwMy54ICsgcDIueCAqIHAzLnkpIC0gKHAyLnkgKiBwMy54ICsgcDEueSAqIHAyLnggKyBwMS54ICogcDMueSk7XHJcblxyXG4gICAgICAgIGlmIChwcmVjaXNzaW9uKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmFicyhkZXRlcm1pbmFudCkgPD0gcHJlY2lzc2lvbjtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gZGV0ZXJtaW5hbnQgPT09IDA7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIOWbm+iIjeS6lOWFpSDkv53lrZhkZWNpbWFsc+eahOWwj+aVsFxyXG4gICAgICoqL1xyXG4gICAgZnVuY3Rpb24gZW5oYW5jZWRSb3VuZChudW1iZXIsIGRlY2ltYWxzKSB7XHJcbiAgICAgICAgcmV0dXJuIE1hdGgucm91bmQobnVtYmVyICogTWF0aC5wb3coMTAsIGRlY2ltYWxzKSkgLyBNYXRoLnBvdygxMCwgZGVjaW1hbHMpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog6I635Y+W5Lik54K55LmL6Ze055qE6ZW/5bqmXHJcbiAgICAgKiovXHJcbiAgICBmdW5jdGlvbiBnZXRMZW5ndGgoc3RhcnRQb2ludCwgZW5kUG9pbnQpIHtcclxuICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KHN0YXJ0UG9pbnQueCAtIGVuZFBvaW50LngsIDIpICsgTWF0aC5wb3coc3RhcnRQb2ludC55IC0gZW5kUG9pbnQueSwgMikpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog6I635Y+W6KeS5bqmXHJcbiAgICAgKiBAcGFyYW0gIHtbdHlwZV19IGNlbnRlclBvaW50ICBbZGVzY3JpcHRpb25dXHJcbiAgICAgKiBAcGFyYW0gIHtbdHlwZV19IG91dHNpZGVQb2ludCBbZGVzY3JpcHRpb25dXHJcbiAgICAgKiBAcGFyYW0gIHtbdHlwZV19IHJvdW5kICAgICAgICBbZGVzY3JpcHRpb25dXHJcbiAgICAgKiBAcmV0dXJuIHtbdHlwZV19ICAgICAgICAgICAgICBbZGVzY3JpcHRpb25dXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGdldEFuZ2xlKGNlbnRlclBvaW50LCBvdXRzaWRlUG9pbnQsIHJvdW5kKSB7XHJcbiAgICAgICAgY2VudGVyUG9pbnQueCA9IGVuaGFuY2VkUm91bmQoY2VudGVyUG9pbnQueCwgNSk7XHJcbiAgICAgICAgY2VudGVyUG9pbnQueSA9IGVuaGFuY2VkUm91bmQoY2VudGVyUG9pbnQueSwgNSk7XHJcbiAgICAgICAgb3V0c2lkZVBvaW50LnggPSBlbmhhbmNlZFJvdW5kKG91dHNpZGVQb2ludC54LCA1KTtcclxuICAgICAgICBvdXRzaWRlUG9pbnQueSA9IGVuaGFuY2VkUm91bmQob3V0c2lkZVBvaW50LnksIDUpO1xyXG4gICAgICAgIHZhciBhbmdsZSA9IE1hdGguYXRhbigob3V0c2lkZVBvaW50LnggLSBjZW50ZXJQb2ludC54KSAvIChvdXRzaWRlUG9pbnQueSAtIGNlbnRlclBvaW50LnkpKTtcclxuICAgICAgICBhbmdsZSA9IC1hbmdsZTtcclxuXHJcbiAgICAgICAgLy9lbmRBbmdsZSs9OTA7XHJcbiAgICAgICAgaWYgKG91dHNpZGVQb2ludC54ID49IGNlbnRlclBvaW50LnggJiYgb3V0c2lkZVBvaW50LnkgPj0gY2VudGVyUG9pbnQueSkge1xyXG4gICAgICAgICAgICBhbmdsZSArPSBNYXRoLlBJO1xyXG4gICAgICAgIH0gZWxzZSBpZiAob3V0c2lkZVBvaW50LnggPD0gY2VudGVyUG9pbnQueCAmJiBvdXRzaWRlUG9pbnQueSA+PSBjZW50ZXJQb2ludC55KSB7XHJcbiAgICAgICAgICAgIGFuZ2xlICs9IE1hdGguUEk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChvdXRzaWRlUG9pbnQueCA8PSBjZW50ZXJQb2ludC54ICYmIG91dHNpZGVQb2ludC55IDw9IGNlbnRlclBvaW50LnkpIHtcclxuICAgICAgICAgICAgYW5nbGUgKz0gTWF0aC5QSSAqIDI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHdoaWxlIChhbmdsZSA+PSBNYXRoLlBJICogMikge1xyXG4gICAgICAgICAgICBhbmdsZSAtPSBNYXRoLlBJICogMjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGlzTmFOKGFuZ2xlKSkgeyAvL05hblxyXG4gICAgICAgICAgICBhbmdsZSA9IDA7IC8vd2UgYXJlIGF0IGNlbnRlciBwb2ludDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHJvdW5kKSB7XHJcbiAgICAgICAgICAgIGFuZ2xlID0gTWF0aC5yb3VuZChhbmdsZSAvIHJvdW5kKSAqIHJvdW5kXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBhbmdsZTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBnZXRSZWN0KG5vZGUpIHtcclxuICAgICAgICB2YXIgYm91bmRpbmdSZWN0ID0gbm9kZS5nZXRCb3VuZGluZ1JlY3QoKTtcclxuICAgICAgICAvL+WIm+W7uuacgOWwj+WMheWbtOebkuiZmue6v1xyXG4gICAgICAgIHZhciBwb2ludHMgPSBbXTtcclxuICAgICAgICBwb2ludHNbMF0gPSBbLWJvdW5kaW5nUmVjdC53aWR0aCAvIDIsIC1ib3VuZGluZ1JlY3QuaGVpZ2h0IC8gMl07XHJcbiAgICAgICAgcG9pbnRzWzFdID0gW2JvdW5kaW5nUmVjdC53aWR0aCAvIDIsIC1ib3VuZGluZ1JlY3QuaGVpZ2h0IC8gMl07XHJcbiAgICAgICAgcG9pbnRzWzJdID0gW2JvdW5kaW5nUmVjdC53aWR0aCAvIDIsIGJvdW5kaW5nUmVjdC5oZWlnaHQgLyAyXTtcclxuICAgICAgICBwb2ludHNbM10gPSBbLWJvdW5kaW5nUmVjdC53aWR0aCAvIDIsIGJvdW5kaW5nUmVjdC5oZWlnaHQgLyAyXTtcclxuICAgICAgICBwb2ludHNbNF0gPSBbLWJvdW5kaW5nUmVjdC53aWR0aCAvIDIsIC1ib3VuZGluZ1JlY3QuaGVpZ2h0IC8gMl07XHJcblxyXG4gICAgICAgIHZhciBib3VuZFJlY3QsIGN4LCBjeTtcclxuICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIGdyYXBoaWMuQ2lyY2xlKSB7XHJcbiAgICAgICAgICAgIC8v5rOoOiDlm6Dkuovku7bkuLrlnIblvaIgIOaJgOS7pSB4IHkg5Li65ZyG5b+D55qE5L2N572uICDljIXlm7Tnn6nlvaLopoHlh4/ljrvlrr3luqbkuIDljYpcclxuICAgICAgICAgICAgYm91bmRSZWN0ID0gbmV3IEJvdW5kaW5nUmVjdChOdW1iZXIobm9kZS5wb3NpdGlvblswXSkgLSBOdW1iZXIoYm91bmRpbmdSZWN0LndpZHRoIC8gMiksXHJcbiAgICAgICAgICAgICAgICBOdW1iZXIobm9kZS5wb3NpdGlvblsxXSkgLSBOdW1iZXIoYm91bmRpbmdSZWN0LmhlaWdodCAvIDIpLFxyXG4gICAgICAgICAgICAgICAgTnVtYmVyKGJvdW5kaW5nUmVjdC53aWR0aCksIE51bWJlcihib3VuZGluZ1JlY3QuaGVpZ2h0KSk7XHJcbiAgICAgICAgICAgIGN4ID0gTnVtYmVyKG5vZGUucG9zaXRpb25bMF0pO1xyXG4gICAgICAgICAgICBjeSA9IE51bWJlcihub2RlLnBvc2l0aW9uWzFdKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBib3VuZFJlY3QgPSBuZXcgQm91bmRpbmdSZWN0KE51bWJlcihub2RlLnBvc2l0aW9uWzBdKSxcclxuICAgICAgICAgICAgICAgIE51bWJlcihub2RlLnBvc2l0aW9uWzFdKSxcclxuICAgICAgICAgICAgICAgIE51bWJlcihib3VuZGluZ1JlY3Qud2lkdGgpLCBOdW1iZXIoYm91bmRpbmdSZWN0LmhlaWdodCkpO1xyXG4gICAgICAgICAgICBjeCA9IE51bWJlcihub2RlLnBvc2l0aW9uWzBdKSArIE51bWJlcihib3VuZGluZ1JlY3Qud2lkdGgpIC8gMjtcclxuICAgICAgICAgICAgY3kgPSBOdW1iZXIobm9kZS5wb3NpdGlvblsxXSkgKyBOdW1iZXIoYm91bmRpbmdSZWN0LmhlaWdodCkgLyAyO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB4OiBOdW1iZXIoY3gpLFxyXG4gICAgICAgICAgICB5OiBOdW1iZXIoY3kpLFxyXG4gICAgICAgICAgICB3aWR0aDogTnVtYmVyKGJvdW5kaW5nUmVjdC53aWR0aCksXHJcbiAgICAgICAgICAgIGhlaWdodDogTnVtYmVyKGJvdW5kaW5nUmVjdC5oZWlnaHQpLFxyXG4gICAgICAgICAgICBwb2ludHM6IHBvaW50cyxcclxuICAgICAgICAgICAgYm91bmRpbmdSZWN0OiBib3VuZFJlY3RcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBTdGFja2VkTWFwID0ge1xyXG4gICAgICAgIGNyZWF0ZU5ldzogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHZhciBzdGFjayA9IFtdO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIGFkZDogZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhcnJLZXkgPSB0aGlzLmdldChrZXkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGFycktleS5wdXNoKHZhbHVlKVxyXG5cclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKGtleSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RhY2subGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGtleSA9PSBzdGFja1tpXS5rZXkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzdGFja1tpXS52YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAvL+WmguaenOayoeacieaJvuWIsOeahOivne+8jOWImeWIm+W7uuS4gOS4quaWsOeahOaVsOe7hFxyXG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YWNrLnB1c2goeyBrZXk6IGtleSwgdmFsdWU6IHZhbHVlIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBrZXlzOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIga2V5cyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RhY2subGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAga2V5cy5wdXNoKHN0YWNrW2ldLmtleSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBrZXlzO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHRvcDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHJlbW92ZTogZnVuY3Rpb24oa2V5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlkeCA9IC0xO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RhY2subGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGtleSA9PSBzdGFja1tpXS5rZXkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkeCA9IGk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RhY2suc3BsaWNlKGlkeCwgMSlbMF07XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgcmVtb3ZlSXRlbTogZnVuY3Rpb24oa2V5LCBpdGVtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFycktleSA9IHRoaXMuZ2V0KGtleSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0genJVdGlsLmluZGV4T2YoYXJyS2V5LCBpdGVtKTtcclxuICAgICAgICAgICAgICAgICAgICBhcnJLZXkuc3BsaWNlKGluZGV4LCAxKTtcclxuXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgcmVtb3ZlVG9wOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RhY2suc3BsaWNlKHN0YWNrLmxlbmd0aCAtIDEsIDEpWzBdO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGxlbmd0aDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0YWNrLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBjbGVhcjogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhY2suc3BsaWNlKDAsIHN0YWNrLmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBmdW5jdGlvbiByYW5kb21Db2xvcigpIHtcclxuICAgICAgICB2YXIgYXJySGV4ID0gW1wiMFwiLCBcIjJcIiwgXCIzXCIsIFwiNFwiLCBcIjVcIiwgXCI2XCIsIFwiN1wiLCBcIjhcIiwgXCI5XCIsIFwiYVwiLCBcImJcIiwgXCJjXCIsIFwiZFwiXSxcclxuICAgICAgICAgICAgc3RySGV4ID0gXCIjXCIsXHJcbiAgICAgICAgICAgIGluZGV4O1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNjsgaSsrKSB7XHJcbiAgICAgICAgICAgIGluZGV4ID0gTWF0aC5yb3VuZChNYXRoLnJhbmRvbSgpICogMTUpO1xyXG4gICAgICAgICAgICBzdHJIZXggKz0gYXJySGV4W2luZGV4XTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHN0ckhleDtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBpc1VuZGVmaW5lZChvYmopIHtcclxuICAgICAgICByZXR1cm4gb2JqID09PSB2b2lkIDA7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gY29sbGluZWFyUmVkdWN0aW9uICh2KSB7XHJcbiAgICAgICAgdmFyIHIgPSBbXTtcclxuXHJcbiAgICAgICAgaWYodi5sZW5ndGggPCAzKXtcclxuICAgICAgICAgICAgcmV0dXJuIFBvaW50LmNsb25lQXJyYXkodik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByLnB1c2goIHZbMF0uY2xvbmUoKSApO1xyXG4gICAgICAgIGZvcih2YXIgaT0xOyBpIDwgdi5sZW5ndGgtMTsgaSsrKXtcclxuICAgICAgICAgICAgaWYoICh2W2ktMV0ueCA9PSB2W2ldLnggJiYgdltpXS54ID09IHZbaSsxXS54KSAgfHwgICh2W2ktMV0ueSA9PSB2W2ldLnkgJiYgdltpXS55ID09IHZbaSsxXS55KSApXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2V7XHJcbiAgICAgICAgICAgICAgICByLnB1c2goIHZbaV0uY2xvbmUoKSApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHIucHVzaCggdlt2Lmxlbmd0aC0xXS5jbG9uZSgpICk7XHJcblxyXG4gICAgICAgIHJldHVybiByO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEJ5IGRlZmF1bHQsIFVuZGVyc2NvcmUgdXNlcyBFUkItc3R5bGUgdGVtcGxhdGUgZGVsaW1pdGVycywgY2hhbmdlIHRoZVxyXG4gICAgLy8gZm9sbG93aW5nIHRlbXBsYXRlIHNldHRpbmdzIHRvIHVzZSBhbHRlcm5hdGl2ZSBkZWxpbWl0ZXJzLlxyXG4gICAgdmFyIHRlbXBsYXRlU2V0dGluZ3MgPSB7XHJcbiAgICAgICAgZXZhbHVhdGU6IC88JShbXFxzXFxTXSs/KSU+L2csXHJcbiAgICAgICAgaW50ZXJwb2xhdGU6IC88JT0oW1xcc1xcU10rPyklPi9nLFxyXG4gICAgICAgIGVzY2FwZTogLzwlLShbXFxzXFxTXSs/KSU+L2dcclxuICAgIH07XHJcblxyXG4gICAgLy8gV2hlbiBjdXN0b21pemluZyBgdGVtcGxhdGVTZXR0aW5nc2AsIGlmIHlvdSBkb24ndCB3YW50IHRvIGRlZmluZSBhblxyXG4gICAgLy8gaW50ZXJwb2xhdGlvbiwgZXZhbHVhdGlvbiBvciBlc2NhcGluZyByZWdleCwgd2UgbmVlZCBvbmUgdGhhdCBpc1xyXG4gICAgLy8gZ3VhcmFudGVlZCBub3QgdG8gbWF0Y2guXHJcbiAgICB2YXIgbm9NYXRjaCA9IC8oLileLztcclxuXHJcbiAgICAvLyBDZXJ0YWluIGNoYXJhY3RlcnMgbmVlZCB0byBiZSBlc2NhcGVkIHNvIHRoYXQgdGhleSBjYW4gYmUgcHV0IGludG8gYVxyXG4gICAgLy8gc3RyaW5nIGxpdGVyYWwuXHJcbiAgICB2YXIgZXNjYXBlcyA9IHtcclxuICAgICAgICBcIidcIjogXCInXCIsXHJcbiAgICAgICAgJ1xcXFwnOiAnXFxcXCcsXHJcbiAgICAgICAgJ1xccic6ICdyJyxcclxuICAgICAgICAnXFxuJzogJ24nLFxyXG4gICAgICAgICdcXHUyMDI4JzogJ3UyMDI4JyxcclxuICAgICAgICAnXFx1MjAyOSc6ICd1MjAyOSdcclxuICAgIH07XHJcblxyXG4gICAgdmFyIGVzY2FwZXIgPSAvXFxcXHwnfFxccnxcXG58XFx1MjAyOHxcXHUyMDI5L2c7XHJcblxyXG4gICAgdmFyIGVzY2FwZUNoYXIgPSBmdW5jdGlvbihtYXRjaCkge1xyXG4gICAgICAgIHJldHVybiAnXFxcXCcgKyBlc2NhcGVzW21hdGNoXTtcclxuICAgIH07XHJcblxyXG4gICAgLy8gSmF2YVNjcmlwdCBtaWNyby10ZW1wbGF0aW5nLCBzaW1pbGFyIHRvIEpvaG4gUmVzaWcncyBpbXBsZW1lbnRhdGlvbi5cclxuICAgIC8vIFVuZGVyc2NvcmUgdGVtcGxhdGluZyBoYW5kbGVzIGFyYml0cmFyeSBkZWxpbWl0ZXJzLCBwcmVzZXJ2ZXMgd2hpdGVzcGFjZSxcclxuICAgIC8vIGFuZCBjb3JyZWN0bHkgZXNjYXBlcyBxdW90ZXMgd2l0aGluIGludGVycG9sYXRlZCBjb2RlLlxyXG4gICAgLy8gTkI6IGBvbGRTZXR0aW5nc2Agb25seSBleGlzdHMgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxyXG4gICAgZnVuY3Rpb24gdGVtcGxhdGUodGV4dCwgc2V0dGluZ3MsIG9sZFNldHRpbmdzKSB7XHJcbiAgICAgICAgaWYgKCFzZXR0aW5ncyAmJiBvbGRTZXR0aW5ncykgc2V0dGluZ3MgPSBvbGRTZXR0aW5ncztcclxuICAgICAgICBzZXR0aW5ncyA9IHNldHRpbmdzIHx8IHt9O1xyXG4gICAgICAgIHNldHRpbmdzID0genJVdGlsLmRlZmF1bHRzKHNldHRpbmdzLCB0ZW1wbGF0ZVNldHRpbmdzLCB0cnVlKTtcclxuXHJcbiAgICAgICAgLy8gQ29tYmluZSBkZWxpbWl0ZXJzIGludG8gb25lIHJlZ3VsYXIgZXhwcmVzc2lvbiB2aWEgYWx0ZXJuYXRpb24uXHJcbiAgICAgICAgdmFyIG1hdGNoZXIgPSBSZWdFeHAoW1xyXG4gICAgICAgICAgICAoc2V0dGluZ3MuZXNjYXBlIHx8IG5vTWF0Y2gpLnNvdXJjZSxcclxuICAgICAgICAgICAgKHNldHRpbmdzLmludGVycG9sYXRlIHx8IG5vTWF0Y2gpLnNvdXJjZSxcclxuICAgICAgICAgICAgKHNldHRpbmdzLmV2YWx1YXRlIHx8IG5vTWF0Y2gpLnNvdXJjZVxyXG4gICAgICAgIF0uam9pbignfCcpICsgJ3wkJywgJ2cnKTtcclxuXHJcbiAgICAgICAgLy8gQ29tcGlsZSB0aGUgdGVtcGxhdGUgc291cmNlLCBlc2NhcGluZyBzdHJpbmcgbGl0ZXJhbHMgYXBwcm9wcmlhdGVseS5cclxuICAgICAgICB2YXIgaW5kZXggPSAwO1xyXG4gICAgICAgIHZhciBzb3VyY2UgPSBcIl9fcCs9J1wiO1xyXG4gICAgICAgIHRleHQucmVwbGFjZShtYXRjaGVyLCBmdW5jdGlvbihtYXRjaCwgZXNjYXBlLCBpbnRlcnBvbGF0ZSwgZXZhbHVhdGUsIG9mZnNldCkge1xyXG4gICAgICAgICAgICBzb3VyY2UgKz0gdGV4dC5zbGljZShpbmRleCwgb2Zmc2V0KS5yZXBsYWNlKGVzY2FwZXIsIGVzY2FwZUNoYXIpO1xyXG4gICAgICAgICAgICBpbmRleCA9IG9mZnNldCArIG1hdGNoLmxlbmd0aDtcclxuXHJcbiAgICAgICAgICAgIGlmIChlc2NhcGUpIHtcclxuICAgICAgICAgICAgICAgIHNvdXJjZSArPSBcIicrXFxuKChfX3Q9KFwiICsgZXNjYXBlICsgXCIpKT09bnVsbD8nJzpfLmVzY2FwZShfX3QpKStcXG4nXCI7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaW50ZXJwb2xhdGUpIHtcclxuICAgICAgICAgICAgICAgIHNvdXJjZSArPSBcIicrXFxuKChfX3Q9KFwiICsgaW50ZXJwb2xhdGUgKyBcIikpPT1udWxsPycnOl9fdCkrXFxuJ1wiO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGV2YWx1YXRlKSB7XHJcbiAgICAgICAgICAgICAgICBzb3VyY2UgKz0gXCInO1xcblwiICsgZXZhbHVhdGUgKyBcIlxcbl9fcCs9J1wiO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBBZG9iZSBWTXMgbmVlZCB0aGUgbWF0Y2ggcmV0dXJuZWQgdG8gcHJvZHVjZSB0aGUgY29ycmVjdCBvZmZlc3QuXHJcbiAgICAgICAgICAgIHJldHVybiBtYXRjaDtcclxuICAgICAgICB9KTtcclxuICAgICAgICBzb3VyY2UgKz0gXCInO1xcblwiO1xyXG5cclxuICAgICAgICAvLyBJZiBhIHZhcmlhYmxlIGlzIG5vdCBzcGVjaWZpZWQsIHBsYWNlIGRhdGEgdmFsdWVzIGluIGxvY2FsIHNjb3BlLlxyXG4gICAgICAgIGlmICghc2V0dGluZ3MudmFyaWFibGUpIHNvdXJjZSA9ICd3aXRoKG9ianx8e30pe1xcbicgKyBzb3VyY2UgKyAnfVxcbic7XHJcblxyXG4gICAgICAgIHNvdXJjZSA9IFwidmFyIF9fdCxfX3A9JycsX19qPUFycmF5LnByb3RvdHlwZS5qb2luLFwiICtcclxuICAgICAgICAgICAgXCJwcmludD1mdW5jdGlvbigpe19fcCs9X19qLmNhbGwoYXJndW1lbnRzLCcnKTt9O1xcblwiICtcclxuICAgICAgICAgICAgc291cmNlICsgJ3JldHVybiBfX3A7XFxuJztcclxuXHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgdmFyIHJlbmRlciA9IG5ldyBGdW5jdGlvbihzZXR0aW5ncy52YXJpYWJsZSB8fCAnb2JqJywgc291cmNlKTtcclxuICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIGUuc291cmNlID0gc291cmNlO1xyXG4gICAgICAgICAgICB0aHJvdyBlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHRlbXBsYXRlID0gZnVuY3Rpb24oZGF0YSkge1xyXG4gICAgICAgICAgICByZXR1cm4gcmVuZGVyLmNhbGwodGhpcywgZGF0YSk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLy8gUHJvdmlkZSB0aGUgY29tcGlsZWQgc291cmNlIGFzIGEgY29udmVuaWVuY2UgZm9yIHByZWNvbXBpbGF0aW9uLlxyXG4gICAgICAgIHZhciBhcmd1bWVudCA9IHNldHRpbmdzLnZhcmlhYmxlIHx8ICdvYmonO1xyXG4gICAgICAgIHRlbXBsYXRlLnNvdXJjZSA9ICdmdW5jdGlvbignICsgYXJndW1lbnQgKyAnKXtcXG4nICsgc291cmNlICsgJ30nO1xyXG5cclxuICAgICAgICByZXR1cm4gdGVtcGxhdGU7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gaXNFbXB0eShvYmopIHtcclxuICAgICAgICBpZiAob2JqID09IG51bGwpIHJldHVybiB0cnVlO1xyXG4gICAgICAgIGlmICh6clV0aWwuaXNBcnJheUxpa2Uob2JqKSAmJiAoenJVdGlsLmlzQXJyYXkob2JqKSB8fCB6clV0aWwuaXNTdHJpbmcob2JqKSkpIHJldHVybiBvYmoubGVuZ3RoID09PSAwO1xyXG4gICAgfVxyXG5cclxuICAgIG1vZHVsZS5leHBvcnRzID0ge1xyXG4gICAgICAgIGluaGVyaXRzOiBpbmhlcml0cyxcclxuICAgICAgICBnZXRVVUlEOiBnZXRVVUlELFxyXG4gICAgICAgIGRpc3RhbmNlOiBkaXN0YW5jZSxcclxuICAgICAgICBnZXRQb2x5bGluZUxlbmd0aDogZ2V0UG9seWxpbmVMZW5ndGgsXHJcbiAgICAgICAgbWF4OiBtYXgsXHJcbiAgICAgICAgbWluOiBtaW4sXHJcbiAgICAgICAgaXNFbXB0eTogaXNFbXB0eSxcclxuICAgICAgICBvcnRob2dvbmFsUGF0aDogb3J0aG9nb25hbFBhdGgsXHJcbiAgICAgICAgcG9seWxpbmVJbnRlcnNlY3RzUmVjdGFuZ2xlOiBwb2x5bGluZUludGVyc2VjdHNSZWN0YW5nbGUsXHJcbiAgICAgICAgc2NvcmVQYXRoOiBzY29yZVBhdGgsXHJcbiAgICAgICAgZm9yd2FyZFBhdGg6IGZvcndhcmRQYXRoLFxyXG4gICAgICAgIHRyYXNsYXRlUG9pbnRzOiB0cmFzbGF0ZVBvaW50cyxcclxuICAgICAgICBnZXRFbmRQb2ludDogZ2V0RW5kUG9pbnQsXHJcbiAgICAgICAgZ2V0Q29ubmVjdG9yUG9pbnRzOiBnZXRDb25uZWN0b3JQb2ludHMsXHJcbiAgICAgICAgdGFuZ2VudFJvdGF0aW9uOiB0YW5nZW50Um90YXRpb24sXHJcbiAgICAgICAgY29sbGluZWFyaXR5OiBjb2xsaW5lYXJpdHksXHJcbiAgICAgICAgdHJhbnNsYXRpb25NYXRyaXg6IHRyYW5zbGF0aW9uTWF0cml4LFxyXG4gICAgICAgIHNjYWxlTWF0cml4OiBzY2FsZU1hdHJpeCxcclxuICAgICAgICByb3VuZDogZW5oYW5jZWRSb3VuZCxcclxuICAgICAgICBnZXRMZW5ndGg6IGdldExlbmd0aCxcclxuICAgICAgICBnZXRBbmdsZTogZ2V0QW5nbGUsXHJcbiAgICAgICAgZ2V0UmVjdDogZ2V0UmVjdCxcclxuICAgICAgICBTdGFja2VkTWFwOiBTdGFja2VkTWFwLFxyXG4gICAgICAgIGdldE1heExpbmVMZW5ndGg6IGdldE1heExpbmVMZW5ndGgsXHJcbiAgICAgICAgcmFuZG9tQ29sb3I6IHJhbmRvbUNvbG9yLFxyXG4gICAgICAgIHRlbXBsYXRlOiB0ZW1wbGF0ZSxcclxuICAgICAgICBpc1VuZGVmaW5lZDogaXNVbmRlZmluZWQsXHJcbiAgICAgICAgZ2V0U29sdFBvaW50czpnZXRTb2x0UG9pbnRzLFxyXG4gICAgICAgIGNvbGxpbmVhclJlZHVjdGlvbjogY29sbGluZWFyUmVkdWN0aW9uXHJcbiAgICB9O1xyXG5cclxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2xpYi9maXNoLXRvcG8tY29yZS9saWIvdXRpbC5qc1xuICoqIG1vZHVsZSBpZCA9IDU5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcclxuXHJcbiAgICAvKipcclxuICAgICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIFBvaW50XHJcbiAgICAgICpcclxuICAgICAgKlxyXG4gICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICAqIEB0aGlzIHtQb2ludH1cclxuICAgICAgKiBAcGFyYW0ge051bWJlcn0geCBUaGUgeCBjb29yZGluYXRlIG9mIHBvaW50LlxyXG4gICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5IFRoZSB5IGNvb3JkaW5hdGUgb2YgcG9pbnQuXHJcbiAgICAgICogTm90ZTogRXZlbiBpZiBpdCBpcyBuYW1lZCBQb2ludCB0aGlzIGNsYXNzIHNob3VsZCBiZSBuYW1lZCBEb3QgYXMgRG90IGlzIGNsb3NlclxyXG4gICAgICAqIHRoZW4gUG9pbnQgZnJvbSBtYXRoIHBlcnNwZWN0aXZlLlxyXG4gICAgICAqKi9cclxuICAgIGZ1bmN0aW9uIFBvaW50KHgsIHkpe1xyXG4gICAgICAgIC8qKlRoZSB4IGNvb3JkaW5hdGUgb2YgcG9pbnQqL1xyXG4gICAgICAgIHRoaXMueCA9IHg7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLyoqVGhlIHkgY29vcmRpbmF0ZSBvZiBwb2ludCovXHJcbiAgICAgICAgdGhpcy55ID0geTtcclxuICAgICAgICBcclxuXHJcbiAgICB9XHJcblxyXG4gICAgLyoqQ3JlYXRlcyBhIHtQb2ludH0gb3V0IG9mIEpTT04gcGFyc2VkIG9iamVjdFxyXG4gICAgICpAcGFyYW0ge0pTT05PYmplY3R9IG8gLSB0aGUgSlNPTiBwYXJzZWQgb2JqZWN0XHJcbiAgICAgKkByZXR1cm4ge1BvaW50fSBhIG5ld2x5IGNvbnN0cnVjdGVkIFBvaW50XHJcbiAgICAgKiovXHJcbiAgICBQb2ludC5sb2FkID0gZnVuY3Rpb24obyl7XHJcbiAgICAgICAgdmFyIG5ld1BvaW50ID0gbmV3IFBvaW50KE51bWJlcihvLngpLCBOdW1iZXIoby55KSk7XHJcbiAgICAgICAgcmV0dXJuIG5ld1BvaW50O1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLyoqQ3JlYXRlcyBhbiBhcnJheSBvZiBwb2ludHMgZnJvbSBhbiBhcnJheSBvZiB7SlNPTk9iamVjdH1zXHJcbiAgICAgKkBwYXJhbSB7QXJyYXl9IHYgLSB0aGUgYXJyYXkgb2YgSlNPTk9iamVjdHNcclxuICAgICAqQHJldHVybiBhbiB7QXJyYXl9IG9mIHtQb2ludH1zXHJcbiAgICAgKiovXHJcbiAgICBQb2ludC5sb2FkQXJyYXkgPSBmdW5jdGlvbih2KXtcclxuICAgICAgICB2YXIgbmV3UG9pbnRzID0gW107XHJcbiAgICAgICAgZm9yKHZhciBpPTA7IGk8IHYubGVuZ3RoOyBpKyspe1xyXG4gICAgICAgICAgICBuZXdQb2ludHMucHVzaChQb2ludC5sb2FkKHZbaV0pKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ld1BvaW50cztcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qKkNsb25lcyBhbiBhcnJheSBvZiBwb2ludHNcclxuICAgICAqQHBhcmFtIHtBcnJheX0gdiAtIHRoZSBhcnJheSBvZiB7UG9pbnR9c1xyXG4gICAgICpAcmV0dXJuIGFuIHtBcnJheX0gb2Yge1BvaW50fXNcclxuICAgICAqKi9cclxuICAgIFBvaW50LmNsb25lQXJyYXkgPSBmdW5jdGlvbih2KXtcclxuICAgICAgICB2YXIgbmV3UG9pbnRzID0gW107XHJcbiAgICAgICAgZm9yKHZhciBpPTA7IGk8IHYubGVuZ3RoOyBpKyspe1xyXG4gICAgICAgICAgICBuZXdQb2ludHMucHVzaCh2W2ldLmNsb25lKCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3UG9pbnRzO1xyXG4gICAgfTtcclxuXHJcbiAgICBQb2ludC5wcm90b3R5cGUgPSB7XHJcbiAgICAgICAgY29uc3RydWN0b3IgOiBQb2ludCxcclxuICAgICAgICBcclxuICAgICAgICB0cmFuc2Zvcm06ZnVuY3Rpb24obWF0cml4KXtcclxuICAgICAgICAgICAgdmFyIG9sZFggPSB0aGlzLng7XHJcbiAgICAgICAgICAgIHZhciBvbGRZID0gdGhpcy55O1xyXG4gICAgICAgICAgICB0aGlzLnggPSBtYXRyaXhbMF1bMF0gKiBvbGRYICsgbWF0cml4WzBdWzFdICogb2xkWSArIG1hdHJpeFswXVsyXTtcclxuICAgICAgICAgICAgdGhpcy55ID0gbWF0cml4WzFdWzBdICogb2xkWCArIG1hdHJpeFsxXVsxXSAqIG9sZFkgKyBtYXRyaXhbMV1bMl07XHJcbiAgICAgICAgfSxcclxuICAgICAgICBcclxuICAgICAgICAvKipUZXN0cyBpZiB0aGlzIHBvaW50IGlzIHNpbWlsYXIgdG8gb3RoZXIgcG9pbnRcclxuICAgICAgICAgKkBwYXJhbSB7UG9pbnR9IGFub3RoZXJQb2ludCAtIHRoZSBvdGhlciBwb2ludFxyXG4gICAgICAgICAqKi9cclxuICAgICAgICBlcXVhbHM6ZnVuY3Rpb24oYW5vdGhlclBvaW50KXtcclxuICAgICAgICAgICAgaWYoISAoYW5vdGhlclBvaW50IGluc3RhbmNlb2YgUG9pbnQpICl7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuICh0aGlzLnggPT0gYW5vdGhlclBvaW50LngpXHJcbiAgICAgICAgICAgICYmICh0aGlzLnkgPT0gYW5vdGhlclBvaW50LnkpXHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqQ2xvbmUgY3VycmVudCBQb2ludFxyXG4gICAgICAgICAqKi9cclxuICAgICAgICBjbG9uZTogZnVuY3Rpb24oKXtcclxuICAgICAgICAgICAgdmFyIG5ld1BvaW50ID0gbmV3IFBvaW50KHRoaXMueCwgdGhpcy55KTtcclxuICAgICAgICAgICAgcmV0dXJuIG5ld1BvaW50O1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlRlc3RzIHRvIHNlZSBpZiBhIHBvaW50ICh4LCB5KSBpcyB3aXRoaW4gYSByYW5nZSBvZiBjdXJyZW50IFBvaW50XHJcbiAgICAgICAgICpAcGFyYW0ge051bWVyaWN9IHggLSB0aGUgeCBjb29yZGluYXRlIG9mIHRlc3RlZCBwb2ludFxyXG4gICAgICAgICAqQHBhcmFtIHtOdW1lcmljfSB5IC0gdGhlIHggY29vcmRpbmF0ZSBvZiB0ZXN0ZWQgcG9pbnRcclxuICAgICAgICAgKkBwYXJhbSB7TnVtZXJpY30gcmFkaXVzIC0gdGhlIHJhZGl1cyBvZiB0aGUgdmljaW5pdHlcclxuICAgICAgICAgKiovXHJcbiAgICAgICAgbmVhcjpmdW5jdGlvbih4LCB5LCByYWRpdXMpe1xyXG4gICAgICAgICAgICB2YXIgZGlzdGFuY2UgPSBNYXRoLnNxcnQoTWF0aC5wb3codGhpcy54IC0geCwgMikgKyBNYXRoLnBvdyh0aGlzLnkgLSB5LCAyKSk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gKGRpc3RhbmNlIDw9IHJhZGl1cyk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgY29udGFpbnM6IGZ1bmN0aW9uKHgseSl7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnggPT0geCAmJiB0aGlzLnkgPT0geTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICB0b1N0cmluZzpmdW5jdGlvbigpe1xyXG4gICAgICAgICAgICByZXR1cm4gJ1snICsgdGhpcy54ICsgJywnICsgdGhpcy55ICsgJ10nO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGdldFBvaW50czpmdW5jdGlvbigpe1xyXG4gICAgICAgICAgICByZXR1cm4gW3RoaXNdO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IFBvaW50O1xyXG4gICAgXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2xpYi9maXNoLXRvcG8tY29yZS9saWIvUG9pbnQuanNcbiAqKiBtb2R1bGUgaWQgPSA2MFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXHJcblxyXG4gICAgLyoqXHJcbiAgICAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBhIExpbmUuIEEgTGluZSBpcyBhY3R1YWxseSBhIHNlZ21lbnQgYW5kIG5vdCBhIHB1cmVcclxuICAgICAgKiBnZW9tZXRyaWNhbCBMaW5lXHJcbiAgICAgICpcclxuICAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAgKiBAdGhpcyB7TGluZX1cclxuICAgICAgKiBAcGFyYW0ge1BvaW50fSBzdGFydFBvaW50IC0gc3RhcnRpbmcgcG9pbnQgb2YgdGhlIGxpbmVcclxuICAgICAgKiBAcGFyYW0ge1BvaW50fSBlbmRQb2ludCAtIHRoZSBlbmRpbmcgcG9pbnQgb2YgdGhlIGxpbmVcclxuICAgICAgKiovXHJcbiAgICBmdW5jdGlvbiBMaW5lKHN0YXJ0UG9pbnQsIGVuZFBvaW50KXtcclxuICAgICAgICAvKipTdGFydGluZyB7QGxpbmsgUG9pbnR9IG9mIHRoZSBsaW5lKi9cclxuICAgICAgICB0aGlzLnN0YXJ0UG9pbnQgPSBzdGFydFBvaW50O1xyXG5cclxuICAgICAgICAvKipFbmRpbmcge0BsaW5rIFBvaW50fSBvZiB0aGUgbGluZSovXHJcbiAgICAgICAgdGhpcy5lbmRQb2ludCA9IGVuZFBvaW50O1xyXG5cclxuICAgICAgICAvKipTZXJpYWxpemF0aW9uIHR5cGUqL1xyXG4gICAgICAgIHRoaXMub1R5cGUgPSAnTGluZSc7IC8vb2JqZWN0IHR5cGUgdXNlZCBmb3IgSlNPTiBkZXNlcmlhbGl6YXRpb25cclxuICAgIH1cclxuXHJcbiAgICAvKipDcmVhdGVzIGEge0xpbmV9IG91dCBvZiBKU09OIHBhcnNlZCBvYmplY3RcclxuICAgICAqQHBhcmFtIHtKU09OT2JqZWN0fSBvIC0gdGhlIEpTT04gcGFyc2VkIG9iamVjdFxyXG4gICAgICpAcmV0dXJuIHtMaW5lfSBhIG5ld2x5IGNvbnN0cnVjdGVkIExpbmVcclxuICAgICAqKi9cclxuICAgIExpbmUubG9hZCA9IGZ1bmN0aW9uKG8pe1xyXG4gICAgICAgIHZhciBuZXdMaW5lID0gbmV3IExpbmUoXHJcbiAgICAgICAgICAgIFBvaW50LmxvYWQoby5zdGFydFBvaW50KSxcclxuICAgICAgICAgICAgUG9pbnQubG9hZChvLmVuZFBvaW50KVxyXG4gICAgICAgICk7XHJcblxyXG4gICAgICAgIHJldHVybiBuZXdMaW5lO1xyXG4gICAgfTtcclxuXHJcbiAgICBMaW5lLnByb3RvdHlwZSA9IHtcclxuICAgICAgICBjb250cnVjdG9yOiBMaW5lLFxyXG5cclxuXHJcblxyXG4gICAgICAgIGNsb25lOmZ1bmN0aW9uKCl7XHJcbiAgICAgICAgICAgIHZhciByZXQgPSBuZXcgTGluZSh0aGlzLnN0YXJ0UG9pbnQuY2xvbmUoKSwgdGhpcy5lbmRQb2ludC5jbG9uZSgpKTtcclxuICAgICAgICAgICAgcmV0dXJuIHJldDtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBlcXVhbHM6ZnVuY3Rpb24oYW5vdGhlckxpbmUpe1xyXG4gICAgICAgICAgICBpZighYW5vdGhlckxpbmUgaW5zdGFuY2VvZiBMaW5lKXtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdGFydFBvaW50LmVxdWFscyhhbm90aGVyTGluZS5zdGFydFBvaW50KVxyXG4gICAgICAgICAgICAmJiB0aGlzLmVuZFBvaW50LmVxdWFscyhhbm90aGVyTGluZS5lbmRQb2ludClcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKiogVGVzdHMgdG8gc2VlIGlmIGEgcG9pbnQgYmVsb25ncyB0byB0aGlzIGxpbmUgKG5vdCBhcyBpbmZpbml0ZSBsaW5lIGJ1dCBtb3JlIGxpa2UgYSBzZWdtZW50KVxyXG4gICAgICAgICAqIEFsZ29yaXRobTogQ29tcHV0ZSBsaW5lJ3MgZXF1YXRpb24gYW5kIHNlZSBpZiAoeCwgeSkgdmVyaWZpZXMgaXQuXHJcbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IHggLSB0aGUgWCBjb29yZGluYXRlc1xyXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5IC0gdGhlIFkgY29vcmRpbmF0ZXNcclxuICAgICAgICAgKiovXHJcbiAgICAgICAgY29udGFpbnM6IGZ1bmN0aW9uKHgsIHkpe1xyXG4gICAgICAgICAgICAvLyBpZiB0aGUgcG9pbnQgaXMgaW5zaWRlIHJlY3RhbmdsZSBib3VuZHMgb2YgdGhlIHNlZ21lbnRcclxuICAgICAgICAgICAgaWYgKE1hdGgubWluKHRoaXMuc3RhcnRQb2ludC54LCB0aGlzLmVuZFBvaW50LngpIDw9IHhcclxuICAgICAgICAgICAgICAgICYmIHggPD0gTWF0aC5tYXgodGhpcy5zdGFydFBvaW50LngsIHRoaXMuZW5kUG9pbnQueClcclxuICAgICAgICAgICAgICAgICYmIE1hdGgubWluKHRoaXMuc3RhcnRQb2ludC55LCB0aGlzLmVuZFBvaW50LnkpIDw9IHlcclxuICAgICAgICAgICAgICAgICYmIHkgPD0gTWF0aC5tYXgodGhpcy5zdGFydFBvaW50LnksIHRoaXMuZW5kUG9pbnQueSkpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBjaGVjayBmb3IgdmVydGljYWwgbGluZVxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc3RhcnRQb2ludC54ID09IHRoaXMuZW5kUG9pbnQueCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB4ID09IHRoaXMuc3RhcnRQb2ludC54O1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHsgLy8gdXN1YWwgKG5vdCB2ZXJ0aWNhbCkgbGluZSBjYW4gYmUgcmVwcmVzZW50ZWQgYXMgeSA9IGEgKiB4ICsgYlxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhID0gKHRoaXMuZW5kUG9pbnQueSAtIHRoaXMuc3RhcnRQb2ludC55KSAvICh0aGlzLmVuZFBvaW50LnggLSB0aGlzLnN0YXJ0UG9pbnQueCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGIgPSB0aGlzLnN0YXJ0UG9pbnQueSAtIGEgKiB0aGlzLnN0YXJ0UG9pbnQueDtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4geSA9PSBhICogeCArIGI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKlxyXG4gICAgICAgICAqU2VlIGlmIHdlIGFyZSBuZWFyIGEge0xpbmV9IGJ5IGEgY2VydGFpbiByYWRpdXMgKGFsc28gaW5jbHVkZXMgdGhlIGV4dHJlbWl0aWVzIGludG8gY29tcHV0YXRpb24pXHJcbiAgICAgICAgICpAcGFyYW0ge051bWJlcn0geCAtIHRoZSB4IGNvb3JkaW5hdGVzXHJcbiAgICAgICAgICpAcGFyYW0ge051bWJlcn0geSAtIHRoZSB5IGNvb3JkaW5hdGVzXHJcbiAgICAgICAgICpAcGFyYW0ge051bWJlcn0gcmFkaXVzIC0gdGhlIHJhZGl1cyB0byBzZWFyY2ggZm9yXHJcbiAgICAgICAgICpAc2VlIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRGlzdGFuY2VfZnJvbV9hX3BvaW50X3RvX2FfbGluZVxyXG4gICAgICAgICAqQHNlZSBcIk1hdGhlbWF0aWNzIGZvciBDb21wdXRlciBHcmFwaGljcywgMm5kIEVkLiwgYnkgSm9obiBWaWNlLCBwYWdlIDIyN1wiXHJcbiAgICAgICAgICoqL1xyXG4gICAgICAgIG5lYXI6ZnVuY3Rpb24oeCx5LHJhZGl1cyl7XHJcblxyXG4gICAgICAgICAgICBpZih0aGlzLmVuZFBvaW50LnggPT09IHRoaXMuc3RhcnRQb2ludC54KXsgLy9WZXJ0aWNhbCBsaW5lLCBzbyB0aGUgdmljaW5pdHkgYXJlYSBpcyBhIHJlY3RhbmdsZVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuICggKHRoaXMuc3RhcnRQb2ludC55LXJhZGl1czw9eSAmJiB0aGlzLmVuZFBvaW50LnkrcmFkaXVzPj15KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB8fCAodGhpcy5lbmRQb2ludC55LXJhZGl1czw9eSAmJiB0aGlzLnN0YXJ0UG9pbnQueStyYWRpdXM+PXkpKVxyXG4gICAgICAgICAgICAgICAgJiYgeCA+IHRoaXMuc3RhcnRQb2ludC54IC0gcmFkaXVzICYmIHggPCB0aGlzLnN0YXJ0UG9pbnQueCArIHJhZGl1cyA7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmKHRoaXMuc3RhcnRQb2ludC55ID09PSB0aGlzLmVuZFBvaW50LnkpeyAvL0hvcml6b250YWwgbGluZSwgc28gdGhlIHZpY2luaXR5IGFyZWEgaXMgYSByZWN0YW5nbGVcclxuICAgICAgICAgICAgICAgIHJldHVybiAoICh0aGlzLnN0YXJ0UG9pbnQueCAtIHJhZGl1czw9eCAmJiB0aGlzLmVuZFBvaW50LngrcmFkaXVzPj14KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB8fCAodGhpcy5lbmRQb2ludC54LXJhZGl1czw9eCAmJiB0aGlzLnN0YXJ0UG9pbnQueCtyYWRpdXM+PXgpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAmJiB5PnRoaXMuc3RhcnRQb2ludC55LXJhZGl1cyAmJiB5PHRoaXMuc3RhcnRQb2ludC55K3JhZGl1cyA7XHJcbiAgICAgICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgICAgICB2YXIgc3RhcnRYID0gTWF0aC5taW4odGhpcy5lbmRQb2ludC54LHRoaXMuc3RhcnRQb2ludC54KTtcclxuICAgICAgICAgICAgdmFyIHN0YXJ0WSA9IE1hdGgubWluKHRoaXMuZW5kUG9pbnQueSx0aGlzLnN0YXJ0UG9pbnQueSk7XHJcbiAgICAgICAgICAgIHZhciBlbmRYID0gTWF0aC5tYXgodGhpcy5lbmRQb2ludC54LHRoaXMuc3RhcnRQb2ludC54KTtcclxuICAgICAgICAgICAgdmFyIGVuZFkgPSBNYXRoLm1heCh0aGlzLmVuZFBvaW50LnksdGhpcy5zdGFydFBvaW50LnkpO1xyXG5cclxuICAgICAgICAgICAgLypXZSB3aWxsIGNvbXB1dGUgdGhlIGRpc3RhbmNlIGZyb20gcG9pbnQgdG8gdGhlIGxpbmVcclxuICAgICAgICAgICAgICogYnkgdXNpbmcgdGhlIGFsZ29yaXRobSBmcm9tXHJcbiAgICAgICAgICAgICAqIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRGlzdGFuY2VfZnJvbV9hX3BvaW50X3RvX2FfbGluZVxyXG4gICAgICAgICAgICAgKiAqL1xyXG5cclxuICAgICAgICAgICAgLy9GaXJzdCB3ZSBuZWVkIHRvIGZpbmQgYSxiLGMgb2YgdGhlIGxpbmUgZXF1YXRpb24gYXggKyBieSArIGMgPSAwXHJcbiAgICAgICAgICAgIHZhciBhID0gdGhpcy5lbmRQb2ludC55IC0gdGhpcy5zdGFydFBvaW50Lnk7XHJcbiAgICAgICAgICAgIHZhciBiID0gdGhpcy5zdGFydFBvaW50LnggLSB0aGlzLmVuZFBvaW50Lng7XHJcbiAgICAgICAgICAgIHZhciBjID0gLSh0aGlzLnN0YXJ0UG9pbnQueCAqIHRoaXMuZW5kUG9pbnQueSAtIHRoaXMuZW5kUG9pbnQueCAqIHRoaXMuc3RhcnRQb2ludC55KTtcclxuXHJcbiAgICAgICAgICAgIC8vU2Vjb25kbHkgd2UgZ2V0IHRoZSBkaXN0YW5jZSBcIk1hdGhlbWF0aWNzIGZvciBDb21wdXRlciBHcmFwaGljcywgMm5kIEVkLiwgYnkgSm9obiBWaWNlLCBwYWdlIDIyN1wiXHJcbiAgICAgICAgICAgIHZhciBkID0gTWF0aC5hYnMoIChhKnggKyBiKnkgKyBjKSAvIE1hdGguc3FydChNYXRoLnBvdyhhLDIpICsgTWF0aC5wb3coYiwyKSkgKTtcclxuXHJcbiAgICAgICAgICAgIC8vVGhpcmRseSB3ZSBnZXQgY29vcmRpbmF0ZXMgb2YgY2xvc2VzdCBsaW5lJ3MgcG9pbnQgdG8gdGFyZ2V0IHBvaW50XHJcbiAgICAgICAgICAgIC8vaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9EaXN0YW5jZV9mcm9tX2FfcG9pbnRfdG9fYV9saW5lI0NhcnRlc2lhbl9jb29yZGluYXRlc1xyXG4gICAgICAgICAgICB2YXIgY2xvc2VzdFggPSAoYiAqIChiKnggLSBhKnkpIC0gYSpjKSAvICggTWF0aC5wb3coYSwyKSArIE1hdGgucG93KGIsMikgKTtcclxuICAgICAgICAgICAgdmFyIGNsb3Nlc3RZID0gKGEgKiAoLWIqeCArIGEqeSkgLSBiKmMpIC8gKCBNYXRoLnBvdyhhLDIpICsgTWF0aC5wb3coYiwyKSApO1xyXG5cclxuICAgICAgICAgICAgdmFyIHIgPSAoIGQgPD0gcmFkaXVzICYmIGVuZFg+PWNsb3Nlc3RYICYmIGNsb3Nlc3RYPj1zdGFydFggJiYgZW5kWT49Y2xvc2VzdFkgJiYgY2xvc2VzdFk+PXN0YXJ0WSApIC8vdGhlIHByb2plY3Rpb24gb2YgdGhlIHBvaW50IGZhbGxzIElOU0lERSBvZiB0aGUgc2VnbWVudFxyXG4gICAgICAgICAgICAgICAgfHwgdGhpcy5zdGFydFBvaW50Lm5lYXIoeCx5LHJhZGl1cykgfHwgdGhpcy5lbmRQb2ludC5uZWFyKHgseSxyYWRpdXMpOyAvL3RoZSBwcm9qZWN0aW9uIG9mIHRoZSBwb2ludCBmYWxscyBPVVRTSURFIG9mIHRoZSBzZWdtZW50XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gIHI7XHJcblxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKndlIG5lZWQgdG8gY3JlYXRlIGEgbmV3IGFycmF5IGVhY2ggdGltZSwgb3Igd2Ugd2lsbCBhZmZlY3QgdGhlIGFjdHVhbCBzaGFwZSovXHJcbiAgICAgICAgZ2V0UG9pbnRzOmZ1bmN0aW9uKCl7XHJcbiAgICAgICAgICAgIHZhciBwb2ludHMgPSBbXTtcclxuICAgICAgICAgICAgcG9pbnRzLnB1c2godGhpcy5zdGFydFBvaW50KTtcclxuICAgICAgICAgICAgcG9pbnRzLnB1c2godGhpcy5lbmRQb2ludCk7XHJcbiAgICAgICAgICAgIHJldHVybiBwb2ludHM7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqUmV0dXJuIHRoZSB7UG9pbnR9IGNvcnJlc3BvbmRpbmcgdGhlIHQgY2VydGFpbiB0IHZhbHVlXHJcbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IHQgdGhlIHZhbHVlIG9mIHBhcmFtZXRlciB0LCB3aGVyZSB0IGluIFswLDFdLCB0IGlzIGxpa2UgYSBwZXJjZW50Ki9cclxuICAgICAgICBnZXRQb2ludDogZnVuY3Rpb24odCl7XHJcbiAgICAgICAgICAgIHZhciBYcCA9IHQgKiAodGhpcy5lbmRQb2ludC54IC0gdGhpcy5zdGFydFBvaW50LngpICsgdGhpcy5zdGFydFBvaW50Lng7XHJcbiAgICAgICAgICAgIHZhciBZcCA9IHQgKiAodGhpcy5lbmRQb2ludC55IC0gdGhpcy5zdGFydFBvaW50LnkpICsgdGhpcy5zdGFydFBvaW50Lnk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFBvaW50KFhwLCBZcCk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLy8gLyoqXHJcbiAgICAgICAgLy8gICogUmV0dXJucyB0aGUgbWlkZGxlIG9mIHRoZSBsaW5lXHJcbiAgICAgICAgLy8gICogQHJldHVybiB7UG9pbnR9IHRoZSBtaWRkbGUgcG9pbnRcclxuICAgICAgICAvLyAgKiAqL1xyXG4gICAgICAgIC8vIGdldE1pZGRsZSA6IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgLy8gICAgIHJldHVybiBVdGlsLmdldE1pZGRsZSh0aGlzLnN0YXJ0UG9pbnQsIHRoaXMuZW5kUG9pbnQpO1xyXG4gICAgICAgIC8vIH0sXHJcblxyXG5cclxuICAgICAgICAvLyBnZXRMZW5ndGggOiBmdW5jdGlvbigpe1xyXG4gICAgICAgIC8vICAgICByZXR1cm4gVXRpbC5nZXRMZW5ndGgodGhpcy5zdGFydFBvaW50LCB0aGlzLmVuZFBvaW50KTtcclxuICAgICAgICAvLyB9LFxyXG5cclxuICAgICAgICAvLyAvKipcclxuICAgICAgICAvLyAgKkdldCBib3VuZHMgZm9yIHRoaXMgbGluZVxyXG4gICAgICAgIC8vICAqQGF1dGhvciBBbGV4IEdoZW9yZ2hpdSA8YWxleEBzY3JpcHRvaWQuY29tPlxyXG4gICAgICAgIC8vICAqKi9cclxuICAgICAgICAvLyBnZXRCb3VuZHM6ZnVuY3Rpb24oKXtcclxuICAgICAgICAvLyAgICAgcmV0dXJuIFV0aWwuZ2V0Qm91bmRzKHRoaXMuZ2V0UG9pbnRzKCkpO1xyXG4gICAgICAgIC8vIH0sXHJcblxyXG4gICAgICAgIC8qKlN0cmluZyByZXByZXNlbnRhdGlvbiovXHJcbiAgICAgICAgdG9TdHJpbmc6ZnVuY3Rpb24oKXtcclxuICAgICAgICAgICAgcmV0dXJuICdsaW5lKCcgKyB0aGlzLnN0YXJ0UG9pbnQgKyAnLCcgKyB0aGlzLmVuZFBvaW50ICsgJyknO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IExpbmU7XHJcblxyXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vbGliL2Zpc2gtdG9wby1jb3JlL2xpYi9MaW5lU3RydWN0LmpzXG4gKiogbW9kdWxlIGlkID0gNjFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxyXG5cclxuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcclxuXHJcbiAgICB2YXIgYXBpTGlzdCA9IFtcclxuICAgICAgICAnZ2V0RG9tJywgJ2dldFpyJywgJ2dldFdpZHRoJywgJ2dldEhlaWdodCcsICdkaXNwYXRjaEFjdGlvbicsXHJcbiAgICAgICAgJ29uJywgJ29mZicsICd0cmlnZ2VyJywgJ2dldERhdGFVUkwnLCAnZ2V0Q29ubmVjdGVkRGF0YVVSTCcsICdnZXRNb2RlbCcsICdnZXRPcHRpb24nXHJcbiAgICBdO1xyXG5cclxuICAgIGZ1bmN0aW9uIEV4dGVuc2lvbkFQSShpbnN0YW5jZSkge1xyXG4gICAgICAgIHpyVXRpbC5lYWNoKGFwaUxpc3QsIGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICAgICAgICAgIHRoaXNbbmFtZV0gPSB6clV0aWwuYmluZChpbnN0YW5jZVtuYW1lXSwgaW5zdGFuY2UpO1xyXG4gICAgICAgIH0sIHRoaXMpO1xyXG4gICAgfVxyXG5cclxuICAgIG1vZHVsZS5leHBvcnRzID0gRXh0ZW5zaW9uQVBJO1xyXG5cclxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2xpYi9maXNoLXRvcG8tZmxvdy9saWIvRXh0ZW5zaW9uQXBpLmpzXG4gKiogbW9kdWxlIGlkID0gNjJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qIVxuICogWlJlbmRlciwgYSBoaWdoIHBlcmZvcm1hbmNlIDJkIGRyYXdpbmcgbGlicmFyeS5cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMsIEJhaWR1IEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTElDRU5TRVxuICogaHR0cHM6Ly9naXRodWIuY29tL2Vjb21mZS96cmVuZGVyL2Jsb2IvbWFzdGVyL0xJQ0VOU0UudHh0XG4gKi9cbi8vIEdsb2JhbCBkZWZpbmVzXG5cbiAgICB2YXIgZ3VpZCA9IHJlcXVpcmUoJy4vY29yZS9ndWlkJyk7XG4gICAgdmFyIGVudiA9IHJlcXVpcmUoJy4vY29yZS9lbnYnKTtcblxuICAgIHZhciBIYW5kbGVyID0gcmVxdWlyZSgnLi9IYW5kbGVyJyk7XG4gICAgdmFyIFN0b3JhZ2UgPSByZXF1aXJlKCcuL1N0b3JhZ2UnKTtcbiAgICB2YXIgQW5pbWF0aW9uID0gcmVxdWlyZSgnLi9hbmltYXRpb24vQW5pbWF0aW9uJyk7XG4gICAgdmFyIEhhbmRsZXJQcm94eSA9IHJlcXVpcmUoJy4vZG9tL0hhbmRsZXJQcm94eScpO1xuXG4gICAgdmFyIHVzZVZNTCA9ICFlbnYuY2FudmFzU3VwcG9ydGVkO1xuXG4gICAgdmFyIHBhaW50ZXJDdG9ycyA9IHtcbiAgICAgICAgY2FudmFzOiByZXF1aXJlKCcuL1BhaW50ZXInKVxuICAgIH07XG5cbiAgICB2YXIgaW5zdGFuY2VzID0ge307ICAgIC8vIFpSZW5kZXLlrp7kvottYXDntKLlvJVcblxuICAgIHZhciB6cmVuZGVyID0ge307XG4gICAgLyoqXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB6cmVuZGVyLnZlcnNpb24gPSAnMy4xLjMnO1xuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6aW5nIGEgenJlbmRlciBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGRvbVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLnJlbmRlcmVyPSdjYW52YXMnXSAnY2FudmFzJyBvciAnc3ZnJ1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0cy5kZXZpY2VQaXhlbFJhdGlvXVxuICAgICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL1pSZW5kZXJ9XG4gICAgICovXG4gICAgenJlbmRlci5pbml0ID0gZnVuY3Rpb24oZG9tLCBvcHRzKSB7XG4gICAgICAgIHZhciB6ciA9IG5ldyBaUmVuZGVyKGd1aWQoKSwgZG9tLCBvcHRzKTtcbiAgICAgICAgaW5zdGFuY2VzW3pyLmlkXSA9IHpyO1xuICAgICAgICByZXR1cm4genI7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIERpc3Bvc2UgenJlbmRlciBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvWlJlbmRlcn0genJcbiAgICAgKi9cbiAgICB6cmVuZGVyLmRpc3Bvc2UgPSBmdW5jdGlvbiAoenIpIHtcbiAgICAgICAgaWYgKHpyKSB7XG4gICAgICAgICAgICB6ci5kaXNwb3NlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gaW5zdGFuY2VzKSB7XG4gICAgICAgICAgICAgICAgaW5zdGFuY2VzW2tleV0uZGlzcG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW5zdGFuY2VzID0ge307XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4genJlbmRlcjtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IHpyZW5kZXIgaW5zdGFuY2UgYnkgaWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgenJlbmRlciBpbnN0YW5jZSBpZFxuICAgICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL1pSZW5kZXJ9XG4gICAgICovXG4gICAgenJlbmRlci5nZXRJbnN0YW5jZSA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICByZXR1cm4gaW5zdGFuY2VzW2lkXTtcbiAgICB9O1xuXG4gICAgenJlbmRlci5yZWdpc3RlclBhaW50ZXIgPSBmdW5jdGlvbiAobmFtZSwgQ3Rvcikge1xuICAgICAgICBwYWludGVyQ3RvcnNbbmFtZV0gPSBDdG9yO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBkZWxJbnN0YW5jZShpZCkge1xuICAgICAgICBkZWxldGUgaW5zdGFuY2VzW2lkXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbW9kdWxlIHpyZW5kZXIvWlJlbmRlclxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBhbGlhcyBtb2R1bGU6enJlbmRlci9aUmVuZGVyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGlkXG4gICAgICogQHBhcmFtIHtIVE1MRG9tRWxlbWVudH0gZG9tXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMucmVuZGVyZXI9J2NhbnZhcyddICdjYW52YXMnIG9yICdzdmcnXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRzLmRldmljZVBpeGVsUmF0aW9dXG4gICAgICovXG4gICAgdmFyIFpSZW5kZXIgPSBmdW5jdGlvbihpZCwgZG9tLCBvcHRzKSB7XG5cbiAgICAgICAgb3B0cyA9IG9wdHMgfHwge307XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtIVE1MRG9tRWxlbWVudH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZG9tID0gZG9tO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pZCA9IGlkO1xuXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIHN0b3JhZ2UgPSBuZXcgU3RvcmFnZSgpO1xuXG4gICAgICAgIHZhciByZW5kZXJlclR5cGUgPSBvcHRzLnJlbmRlcmVyO1xuICAgICAgICBpZiAodXNlVk1MKSB7XG4gICAgICAgICAgICBpZiAoIXBhaW50ZXJDdG9ycy52bWwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBuZWVkIHRvIHJlcXVpcmUgXFwnenJlbmRlci92bWwvdm1sXFwnIHRvIHN1cHBvcnQgSUU4Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZW5kZXJlclR5cGUgPSAndm1sJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghcmVuZGVyZXJUeXBlIHx8ICFwYWludGVyQ3RvcnNbcmVuZGVyZXJUeXBlXSkge1xuICAgICAgICAgICAgcmVuZGVyZXJUeXBlID0gJ2NhbnZhcyc7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBhaW50ZXIgPSBuZXcgcGFpbnRlckN0b3JzW3JlbmRlcmVyVHlwZV0oZG9tLCBzdG9yYWdlLCBvcHRzKTtcblxuICAgICAgICB0aGlzLnN0b3JhZ2UgPSBzdG9yYWdlO1xuICAgICAgICB0aGlzLnBhaW50ZXIgPSBwYWludGVyO1xuXG4gICAgICAgIHZhciBoYW5kZXJQcm94eSA9ICFlbnYubm9kZSA/IG5ldyBIYW5kbGVyUHJveHkocGFpbnRlci5nZXRWaWV3cG9ydFJvb3QoKSkgOiBudWxsO1xuICAgICAgICB0aGlzLmhhbmRsZXIgPSBuZXcgSGFuZGxlcihzdG9yYWdlLCBwYWludGVyLCBoYW5kZXJQcm94eSk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHttb2R1bGU6enJlbmRlci9hbmltYXRpb24vQW5pbWF0aW9ufVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5hbmltYXRpb24gPSBuZXcgQW5pbWF0aW9uKHtcbiAgICAgICAgICAgIHN0YWdlOiB7XG4gICAgICAgICAgICAgICAgdXBkYXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLl9uZWVkc1JlZnJlc2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYucmVmcmVzaEltbWVkaWF0ZWx5KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuX25lZWRzUmVmcmVzaEhvdmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnJlZnJlc2hIb3ZlckltbWVkaWF0ZWx5KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmFuaW1hdGlvbi5zdGFydCgpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX25lZWRzUmVmcmVzaDtcblxuICAgICAgICAvLyDkv67mlLkgc3RvcmFnZS5kZWxGcm9tTWFwLCDmr4/mrKHliKDpmaTlhYPntKDkuYvliY3liKDpmaTliqjnlLtcbiAgICAgICAgLy8gRklYTUUg5pyJ54K5dWdseVxuICAgICAgICB2YXIgb2xkRGVsRnJvbU1hcCA9IHN0b3JhZ2UuZGVsRnJvbU1hcDtcbiAgICAgICAgdmFyIG9sZEFkZFRvTWFwID0gc3RvcmFnZS5hZGRUb01hcDtcblxuICAgICAgICBzdG9yYWdlLmRlbEZyb21NYXAgPSBmdW5jdGlvbiAoZWxJZCkge1xuICAgICAgICAgICAgdmFyIGVsID0gc3RvcmFnZS5nZXQoZWxJZCk7XG5cbiAgICAgICAgICAgIG9sZERlbEZyb21NYXAuY2FsbChzdG9yYWdlLCBlbElkKTtcblxuICAgICAgICAgICAgZWwgJiYgZWwucmVtb3ZlU2VsZkZyb21acihzZWxmKTtcbiAgICAgICAgfTtcblxuICAgICAgICBzdG9yYWdlLmFkZFRvTWFwID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICBvbGRBZGRUb01hcC5jYWxsKHN0b3JhZ2UsIGVsKTtcblxuICAgICAgICAgICAgZWwuYWRkU2VsZlRvWnIoc2VsZik7XG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIFpSZW5kZXIucHJvdG90eXBlID0ge1xuXG4gICAgICAgIGNvbnN0cnVjdG9yOiBaUmVuZGVyLFxuICAgICAgICAvKipcbiAgICAgICAgICog6I635Y+W5a6e5L6L5ZSv5LiA5qCH6K+GXG4gICAgICAgICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIGdldElkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pZDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5re75Yqg5YWD57SgXG4gICAgICAgICAqIEBwYXJhbSAge21vZHVsZTp6cmVuZGVyL0VsZW1lbnR9IGVsXG4gICAgICAgICAqL1xuICAgICAgICBhZGQ6IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgdGhpcy5zdG9yYWdlLmFkZFJvb3QoZWwpO1xuICAgICAgICAgICAgdGhpcy5fbmVlZHNSZWZyZXNoID0gdHJ1ZTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5Yig6Zmk5YWD57SgXG4gICAgICAgICAqIEBwYXJhbSAge21vZHVsZTp6cmVuZGVyL0VsZW1lbnR9IGVsXG4gICAgICAgICAqL1xuICAgICAgICByZW1vdmU6IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgdGhpcy5zdG9yYWdlLmRlbFJvb3QoZWwpO1xuICAgICAgICAgICAgdGhpcy5fbmVlZHNSZWZyZXNoID0gdHJ1ZTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2hhbmdlIGNvbmZpZ3VyYXRpb24gb2YgbGF5ZXJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHpMZXZlbFxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY29uZmlnLmNsZWFyQ29sb3I9MF0gQ2xlYXIgY29sb3JcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtjb25maWcubW90aW9uQmx1cj1mYWxzZV0gSWYgZW5hYmxlIG1vdGlvbiBibHVyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbY29uZmlnLmxhc3RGcmFtZUFscGhhPTAuN10gTW90aW9uIGJsdXIgZmFjdG9yLiBMYXJnZXIgdmFsdWUgY2F1c2UgbG9uZ2VyIHRyYWlsZXJcbiAgICAgICAgKi9cbiAgICAgICAgY29uZmlnTGF5ZXI6IGZ1bmN0aW9uICh6TGV2ZWwsIGNvbmZpZykge1xuICAgICAgICAgICAgdGhpcy5wYWludGVyLmNvbmZpZ0xheWVyKHpMZXZlbCwgY29uZmlnKTtcbiAgICAgICAgICAgIHRoaXMuX25lZWRzUmVmcmVzaCA9IHRydWU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlcGFpbnQgdGhlIGNhbnZhcyBpbW1lZGlhdGVseVxuICAgICAgICAgKi9cbiAgICAgICAgcmVmcmVzaEltbWVkaWF0ZWx5OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBDbGVhciBuZWVkc1JlZnJlc2ggYWhlYWQgdG8gYXZvaWQgc29tZXRoaW5nIHdyb25nIGhhcHBlbnMgaW4gcmVmcmVzaFxuICAgICAgICAgICAgLy8gT3IgaXQgd2lsbCBjYXVzZSB6cmVuZGVyIHJlZnJlc2hlcyBhZ2FpbiBhbmQgYWdhaW4uXG4gICAgICAgICAgICB0aGlzLl9uZWVkc1JlZnJlc2ggPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMucGFpbnRlci5yZWZyZXNoKCk7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEF2b2lkIHRyaWdnZXIgenIucmVmcmVzaCBpbiBFbGVtZW50I2JlZm9yZVVwZGF0ZSBob29rXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuX25lZWRzUmVmcmVzaCA9IGZhbHNlO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNYXJrIGFuZCByZXBhaW50IHRoZSBjYW52YXMgaW4gdGhlIG5leHQgZnJhbWUgb2YgYnJvd3NlclxuICAgICAgICAgKi9cbiAgICAgICAgcmVmcmVzaDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLl9uZWVkc1JlZnJlc2ggPSB0cnVlO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBZGQgZWxlbWVudCB0byBob3ZlciBsYXllclxuICAgICAgICAgKiBAcGFyYW0gIHttb2R1bGU6enJlbmRlci9FbGVtZW50fSBlbFxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gc3R5bGVcbiAgICAgICAgICovXG4gICAgICAgIGFkZEhvdmVyOiBmdW5jdGlvbiAoZWwsIHN0eWxlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wYWludGVyLmFkZEhvdmVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wYWludGVyLmFkZEhvdmVyKGVsLCBzdHlsZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWZyZXNoSG92ZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQWRkIGVsZW1lbnQgZnJvbSBob3ZlciBsYXllclxuICAgICAgICAgKiBAcGFyYW0gIHttb2R1bGU6enJlbmRlci9FbGVtZW50fSBlbFxuICAgICAgICAgKi9cbiAgICAgICAgcmVtb3ZlSG92ZXI6IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucGFpbnRlci5yZW1vdmVIb3Zlcikge1xuICAgICAgICAgICAgICAgIHRoaXMucGFpbnRlci5yZW1vdmVIb3ZlcihlbCk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWZyZXNoSG92ZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2xlYXIgYWxsIGhvdmVyIGVsZW1lbnRzIGluIGhvdmVyIGxheWVyXG4gICAgICAgICAqIEBwYXJhbSAge21vZHVsZTp6cmVuZGVyL0VsZW1lbnR9IGVsXG4gICAgICAgICAqL1xuICAgICAgICBjbGVhckhvdmVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wYWludGVyLmNsZWFySG92ZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBhaW50ZXIuY2xlYXJIb3ZlcigpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVmcmVzaEhvdmVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlZnJlc2ggaG92ZXIgaW4gbmV4dCBmcmFtZVxuICAgICAgICAgKi9cbiAgICAgICAgcmVmcmVzaEhvdmVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl9uZWVkc1JlZnJlc2hIb3ZlciA9IHRydWU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlZnJlc2ggaG92ZXIgaW1tZWRpYXRlbHlcbiAgICAgICAgICovXG4gICAgICAgIHJlZnJlc2hIb3ZlckltbWVkaWF0ZWx5OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl9uZWVkc1JlZnJlc2hIb3ZlciA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5wYWludGVyLnJlZnJlc2hIb3ZlciAmJiB0aGlzLnBhaW50ZXIucmVmcmVzaEhvdmVyKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlc2l6ZSB0aGUgY2FudmFzLlxuICAgICAgICAgKiBTaG91bGQgYmUgaW52b2tlZCB3aGVuIGNvbnRhaW5lciBzaXplIGlzIGNoYW5nZWRcbiAgICAgICAgICovXG4gICAgICAgIHJlc2l6ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLnBhaW50ZXIucmVzaXplKCk7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZXIucmVzaXplKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFN0b3AgYW5kIGNsZWFyIGFsbCBhbmltYXRpb24gaW1tZWRpYXRlbHlcbiAgICAgICAgICovXG4gICAgICAgIGNsZWFyQW5pbWF0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLmFuaW1hdGlvbi5jbGVhcigpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgY29udGFpbmVyIHdpZHRoXG4gICAgICAgICAqL1xuICAgICAgICBnZXRXaWR0aDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYWludGVyLmdldFdpZHRoKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCBjb250YWluZXIgaGVpZ2h0XG4gICAgICAgICAqL1xuICAgICAgICBnZXRIZWlnaHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFpbnRlci5nZXRIZWlnaHQoKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogRXhwb3J0IHRoZSBjYW52YXMgYXMgQmFzZTY0IFVSTFxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2JhY2tncm91bmRDb2xvcj0nI2ZmZiddXG4gICAgICAgICAqIEByZXR1cm4ge3N0cmluZ30gQmFzZTY0IFVSTFxuICAgICAgICAgKi9cbiAgICAgICAgLy8gdG9EYXRhVVJMOiBmdW5jdGlvbih0eXBlLCBiYWNrZ3JvdW5kQ29sb3IpIHtcbiAgICAgICAgLy8gICAgIHJldHVybiB0aGlzLnBhaW50ZXIuZ2V0UmVuZGVyZWRDYW52YXMoe1xuICAgICAgICAvLyAgICAgICAgIGJhY2tncm91bmRDb2xvcjogYmFja2dyb3VuZENvbG9yXG4gICAgICAgIC8vICAgICB9KS50b0RhdGFVUkwodHlwZSk7XG4gICAgICAgIC8vIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnZlcnRpbmcgYSBwYXRoIHRvIGltYWdlLlxuICAgICAgICAgKiBJdCBoYXMgbXVjaCBiZXR0ZXIgcGVyZm9ybWFuY2Ugb2YgZHJhd2luZyBpbWFnZSByYXRoZXIgdGhhbiBkcmF3aW5nIGEgdmVjdG9yIHBhdGguXG4gICAgICAgICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvZ3JhcGhpYy9QYXRofSBlXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aFxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0XG4gICAgICAgICAqL1xuICAgICAgICBwYXRoVG9JbWFnZTogZnVuY3Rpb24oZSwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgICAgICAgdmFyIGlkID0gZ3VpZCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFpbnRlci5wYXRoVG9JbWFnZShpZCwgZSwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldCBkZWZhdWx0IGN1cnNvclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2N1cnNvclN0eWxlPSdkZWZhdWx0J10g5L6L5aaCIGNyb3NzaGFpclxuICAgICAgICAgKi9cbiAgICAgICAgc2V0Q3Vyc29yU3R5bGU6IGZ1bmN0aW9uIChjdXJzb3JTdHlsZSkge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVyLnNldEN1cnNvclN0eWxlKGN1cnNvclN0eWxlKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQmluZCBldmVudFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lIEV2ZW50IG5hbWVcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXZlbnRIYW5kbGVyIEhhbmRsZXIgZnVuY3Rpb25cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IFtjb250ZXh0XSBDb250ZXh0IG9iamVjdFxuICAgICAgICAgKi9cbiAgICAgICAgb246IGZ1bmN0aW9uKGV2ZW50TmFtZSwgZXZlbnRIYW5kbGVyLCBjb250ZXh0KSB7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZXIub24oZXZlbnROYW1lLCBldmVudEhhbmRsZXIsIGNvbnRleHQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVbmJpbmQgZXZlbnRcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSBFdmVudCBuYW1lXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtldmVudEhhbmRsZXJdIEhhbmRsZXIgZnVuY3Rpb25cbiAgICAgICAgICovXG4gICAgICAgIG9mZjogZnVuY3Rpb24oZXZlbnROYW1lLCBldmVudEhhbmRsZXIpIHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlci5vZmYoZXZlbnROYW1lLCBldmVudEhhbmRsZXIpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUcmlnZ2VyIGV2ZW50IG1hbnVhbGx5XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUgRXZlbnQgbmFtZVxuICAgICAgICAgKiBAcGFyYW0ge2V2ZW50PX0gZXZlbnQgRXZlbnQgb2JqZWN0XG4gICAgICAgICAqL1xuICAgICAgICB0cmlnZ2VyOiBmdW5jdGlvbiAoZXZlbnROYW1lLCBldmVudCkge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVyLnRyaWdnZXIoZXZlbnROYW1lLCBldmVudCk7XG4gICAgICAgIH0sXG5cblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2xlYXIgYWxsIG9iamVjdHMgYW5kIHRoZSBjYW52YXMuXG4gICAgICAgICAqL1xuICAgICAgICBjbGVhcjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5zdG9yYWdlLmRlbFJvb3QoKTtcbiAgICAgICAgICAgIHRoaXMucGFpbnRlci5jbGVhcigpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEaXNwb3NlIHNlbGYuXG4gICAgICAgICAqL1xuICAgICAgICBkaXNwb3NlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLmFuaW1hdGlvbi5zdG9wKCk7XG5cbiAgICAgICAgICAgIHRoaXMuY2xlYXIoKTtcbiAgICAgICAgICAgIHRoaXMuc3RvcmFnZS5kaXNwb3NlKCk7XG4gICAgICAgICAgICB0aGlzLnBhaW50ZXIuZGlzcG9zZSgpO1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVyLmRpc3Bvc2UoKTtcblxuICAgICAgICAgICAgdGhpcy5hbmltYXRpb24gPVxuICAgICAgICAgICAgdGhpcy5zdG9yYWdlID1cbiAgICAgICAgICAgIHRoaXMucGFpbnRlciA9XG4gICAgICAgICAgICB0aGlzLmhhbmRsZXIgPSBudWxsO1xuXG4gICAgICAgICAgICBkZWxJbnN0YW5jZSh0aGlzLmlkKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHpyZW5kZXI7XG5cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3pyZW5kZXIvbGliL3pyZW5kZXIuanNcbiAqKiBtb2R1bGUgaWQgPSA2M1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBlY2hhcnRz6K6+5aSH546v5aKD6K+G5YirXG4gKlxuICogQGRlc2MgZWNoYXJ0c+WfuuS6jkNhbnZhc++8jOe6r0phdmFzY3JpcHTlm77ooajlupPvvIzmj5Dkvpvnm7Top4LvvIznlJ/liqjvvIzlj6/kuqTkupLvvIzlj6/kuKrmgKfljJblrprliLbnmoTmlbDmja7nu5/orqHlm77ooajjgIJcbiAqIEBhdXRob3IgZmlyZWRlW2ZpcmVkZUBmaXJlZGUudXNdXG4gKiBAZGVzYyB0aGFua3MgemVwdG8uXG4gKi9cblxuICAgIHZhciBlbnYgPSB7fTtcbiAgICBpZiAodHlwZW9mIG5hdmlnYXRvciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgLy8gSW4gbm9kZVxuICAgICAgICBlbnYgPSB7XG4gICAgICAgICAgICBicm93c2VyOiB7fSxcbiAgICAgICAgICAgIG9zOiB7fSxcbiAgICAgICAgICAgIG5vZGU6IHRydWUsXG4gICAgICAgICAgICAvLyBBc3N1bWUgY2FudmFzIGlzIHN1cHBvcnRlZFxuICAgICAgICAgICAgY2FudmFzU3VwcG9ydGVkOiB0cnVlXG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBlbnYgPSBkZXRlY3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBlbnY7XG5cbiAgICAvLyBaZXB0by5qc1xuICAgIC8vIChjKSAyMDEwLTIwMTMgVGhvbWFzIEZ1Y2hzXG4gICAgLy8gWmVwdG8uanMgbWF5IGJlIGZyZWVseSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG5cbiAgICBmdW5jdGlvbiBkZXRlY3QodWEpIHtcbiAgICAgICAgdmFyIG9zID0ge307XG4gICAgICAgIHZhciBicm93c2VyID0ge307XG4gICAgICAgIC8vIHZhciB3ZWJraXQgPSB1YS5tYXRjaCgvV2ViW2tLXWl0W1xcL117MCwxfShbXFxkLl0rKS8pO1xuICAgICAgICAvLyB2YXIgYW5kcm9pZCA9IHVhLm1hdGNoKC8oQW5kcm9pZCk7P1tcXHNcXC9dKyhbXFxkLl0rKT8vKTtcbiAgICAgICAgLy8gdmFyIGlwYWQgPSB1YS5tYXRjaCgvKGlQYWQpLipPU1xccyhbXFxkX10rKS8pO1xuICAgICAgICAvLyB2YXIgaXBvZCA9IHVhLm1hdGNoKC8oaVBvZCkoLipPU1xccyhbXFxkX10rKSk/Lyk7XG4gICAgICAgIC8vIHZhciBpcGhvbmUgPSAhaXBhZCAmJiB1YS5tYXRjaCgvKGlQaG9uZVxcc09TKVxccyhbXFxkX10rKS8pO1xuICAgICAgICAvLyB2YXIgd2Vib3MgPSB1YS5tYXRjaCgvKHdlYk9TfGhwd09TKVtcXHNcXC9dKFtcXGQuXSspLyk7XG4gICAgICAgIC8vIHZhciB0b3VjaHBhZCA9IHdlYm9zICYmIHVhLm1hdGNoKC9Ub3VjaFBhZC8pO1xuICAgICAgICAvLyB2YXIga2luZGxlID0gdWEubWF0Y2goL0tpbmRsZVxcLyhbXFxkLl0rKS8pO1xuICAgICAgICAvLyB2YXIgc2lsayA9IHVhLm1hdGNoKC9TaWxrXFwvKFtcXGQuX10rKS8pO1xuICAgICAgICAvLyB2YXIgYmxhY2tiZXJyeSA9IHVhLm1hdGNoKC8oQmxhY2tCZXJyeSkuKlZlcnNpb25cXC8oW1xcZC5dKykvKTtcbiAgICAgICAgLy8gdmFyIGJiMTAgPSB1YS5tYXRjaCgvKEJCMTApLipWZXJzaW9uXFwvKFtcXGQuXSspLyk7XG4gICAgICAgIC8vIHZhciByaW10YWJsZXRvcyA9IHVhLm1hdGNoKC8oUklNXFxzVGFibGV0XFxzT1MpXFxzKFtcXGQuXSspLyk7XG4gICAgICAgIC8vIHZhciBwbGF5Ym9vayA9IHVhLm1hdGNoKC9QbGF5Qm9vay8pO1xuICAgICAgICAvLyB2YXIgY2hyb21lID0gdWEubWF0Y2goL0Nocm9tZVxcLyhbXFxkLl0rKS8pIHx8IHVhLm1hdGNoKC9DcmlPU1xcLyhbXFxkLl0rKS8pO1xuICAgICAgICB2YXIgZmlyZWZveCA9IHVhLm1hdGNoKC9GaXJlZm94XFwvKFtcXGQuXSspLyk7XG4gICAgICAgIC8vIHZhciBzYWZhcmkgPSB3ZWJraXQgJiYgdWEubWF0Y2goL01vYmlsZVxcLy8pICYmICFjaHJvbWU7XG4gICAgICAgIC8vIHZhciB3ZWJ2aWV3ID0gdWEubWF0Y2goLyhpUGhvbmV8aVBvZHxpUGFkKS4qQXBwbGVXZWJLaXQoPyEuKlNhZmFyaSkvKSAmJiAhY2hyb21lO1xuICAgICAgICB2YXIgaWUgPSB1YS5tYXRjaCgvTVNJRVxccyhbXFxkLl0rKS8pXG4gICAgICAgICAgICAvLyBJRSAxMSBUcmlkZW50LzcuMDsgcnY6MTEuMFxuICAgICAgICAgICAgfHwgdWEubWF0Y2goL1RyaWRlbnRcXC8uKz9ydjooKFtcXGQuXSspKS8pO1xuICAgICAgICB2YXIgZWRnZSA9IHVhLm1hdGNoKC9FZGdlXFwvKFtcXGQuXSspLyk7IC8vIElFIDEyIGFuZCAxMitcblxuICAgICAgICAvLyBUb2RvOiBjbGVhbiB0aGlzIHVwIHdpdGggYSBiZXR0ZXIgT1MvYnJvd3NlciBzZXBlcmF0aW9uOlxuICAgICAgICAvLyAtIGRpc2Nlcm4gKG1vcmUpIGJldHdlZW4gbXVsdGlwbGUgYnJvd3NlcnMgb24gYW5kcm9pZFxuICAgICAgICAvLyAtIGRlY2lkZSBpZiBraW5kbGUgZmlyZSBpbiBzaWxrIG1vZGUgaXMgYW5kcm9pZCBvciBub3RcbiAgICAgICAgLy8gLSBGaXJlZm94IG9uIEFuZHJvaWQgZG9lc24ndCBzcGVjaWZ5IHRoZSBBbmRyb2lkIHZlcnNpb25cbiAgICAgICAgLy8gLSBwb3NzaWJseSBkZXZpZGUgaW4gb3MsIGRldmljZSBhbmQgYnJvd3NlciBoYXNoZXNcblxuICAgICAgICAvLyBpZiAoYnJvd3Nlci53ZWJraXQgPSAhIXdlYmtpdCkgYnJvd3Nlci52ZXJzaW9uID0gd2Via2l0WzFdO1xuXG4gICAgICAgIC8vIGlmIChhbmRyb2lkKSBvcy5hbmRyb2lkID0gdHJ1ZSwgb3MudmVyc2lvbiA9IGFuZHJvaWRbMl07XG4gICAgICAgIC8vIGlmIChpcGhvbmUgJiYgIWlwb2QpIG9zLmlvcyA9IG9zLmlwaG9uZSA9IHRydWUsIG9zLnZlcnNpb24gPSBpcGhvbmVbMl0ucmVwbGFjZSgvXy9nLCAnLicpO1xuICAgICAgICAvLyBpZiAoaXBhZCkgb3MuaW9zID0gb3MuaXBhZCA9IHRydWUsIG9zLnZlcnNpb24gPSBpcGFkWzJdLnJlcGxhY2UoL18vZywgJy4nKTtcbiAgICAgICAgLy8gaWYgKGlwb2QpIG9zLmlvcyA9IG9zLmlwb2QgPSB0cnVlLCBvcy52ZXJzaW9uID0gaXBvZFszXSA/IGlwb2RbM10ucmVwbGFjZSgvXy9nLCAnLicpIDogbnVsbDtcbiAgICAgICAgLy8gaWYgKHdlYm9zKSBvcy53ZWJvcyA9IHRydWUsIG9zLnZlcnNpb24gPSB3ZWJvc1syXTtcbiAgICAgICAgLy8gaWYgKHRvdWNocGFkKSBvcy50b3VjaHBhZCA9IHRydWU7XG4gICAgICAgIC8vIGlmIChibGFja2JlcnJ5KSBvcy5ibGFja2JlcnJ5ID0gdHJ1ZSwgb3MudmVyc2lvbiA9IGJsYWNrYmVycnlbMl07XG4gICAgICAgIC8vIGlmIChiYjEwKSBvcy5iYjEwID0gdHJ1ZSwgb3MudmVyc2lvbiA9IGJiMTBbMl07XG4gICAgICAgIC8vIGlmIChyaW10YWJsZXRvcykgb3MucmltdGFibGV0b3MgPSB0cnVlLCBvcy52ZXJzaW9uID0gcmltdGFibGV0b3NbMl07XG4gICAgICAgIC8vIGlmIChwbGF5Ym9vaykgYnJvd3Nlci5wbGF5Ym9vayA9IHRydWU7XG4gICAgICAgIC8vIGlmIChraW5kbGUpIG9zLmtpbmRsZSA9IHRydWUsIG9zLnZlcnNpb24gPSBraW5kbGVbMV07XG4gICAgICAgIC8vIGlmIChzaWxrKSBicm93c2VyLnNpbGsgPSB0cnVlLCBicm93c2VyLnZlcnNpb24gPSBzaWxrWzFdO1xuICAgICAgICAvLyBpZiAoIXNpbGsgJiYgb3MuYW5kcm9pZCAmJiB1YS5tYXRjaCgvS2luZGxlIEZpcmUvKSkgYnJvd3Nlci5zaWxrID0gdHJ1ZTtcbiAgICAgICAgLy8gaWYgKGNocm9tZSkgYnJvd3Nlci5jaHJvbWUgPSB0cnVlLCBicm93c2VyLnZlcnNpb24gPSBjaHJvbWVbMV07XG4gICAgICAgIGlmIChmaXJlZm94KSBicm93c2VyLmZpcmVmb3ggPSB0cnVlLCBicm93c2VyLnZlcnNpb24gPSBmaXJlZm94WzFdO1xuICAgICAgICAvLyBpZiAoc2FmYXJpICYmICh1YS5tYXRjaCgvU2FmYXJpLykgfHwgISFvcy5pb3MpKSBicm93c2VyLnNhZmFyaSA9IHRydWU7XG4gICAgICAgIC8vIGlmICh3ZWJ2aWV3KSBicm93c2VyLndlYnZpZXcgPSB0cnVlO1xuICAgICAgICBpZiAoaWUpIHtcbiAgICAgICAgICAgIGJyb3dzZXIuaWUgPSB0cnVlOyBicm93c2VyLnZlcnNpb24gPSBpZVsxXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaWUpIHtcbiAgICAgICAgICAgIGJyb3dzZXIuaWUgPSB0cnVlO1xuICAgICAgICAgICAgYnJvd3Nlci52ZXJzaW9uID0gaWVbMV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVkZ2UpIHtcbiAgICAgICAgICAgIGJyb3dzZXIuZWRnZSA9IHRydWU7XG4gICAgICAgICAgICBicm93c2VyLnZlcnNpb24gPSBlZGdlWzFdO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gb3MudGFibGV0ID0gISEoaXBhZCB8fCBwbGF5Ym9vayB8fCAoYW5kcm9pZCAmJiAhdWEubWF0Y2goL01vYmlsZS8pKSB8fFxuICAgICAgICAvLyAgICAgKGZpcmVmb3ggJiYgdWEubWF0Y2goL1RhYmxldC8pKSB8fCAoaWUgJiYgIXVhLm1hdGNoKC9QaG9uZS8pICYmIHVhLm1hdGNoKC9Ub3VjaC8pKSk7XG4gICAgICAgIC8vIG9zLnBob25lICA9ICEhKCFvcy50YWJsZXQgJiYgIW9zLmlwb2QgJiYgKGFuZHJvaWQgfHwgaXBob25lIHx8IHdlYm9zIHx8XG4gICAgICAgIC8vICAgICAoY2hyb21lICYmIHVhLm1hdGNoKC9BbmRyb2lkLykpIHx8IChjaHJvbWUgJiYgdWEubWF0Y2goL0NyaU9TXFwvKFtcXGQuXSspLykpIHx8XG4gICAgICAgIC8vICAgICAoZmlyZWZveCAmJiB1YS5tYXRjaCgvTW9iaWxlLykpIHx8IChpZSAmJiB1YS5tYXRjaCgvVG91Y2gvKSkpKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYnJvd3NlcjogYnJvd3NlcixcbiAgICAgICAgICAgIG9zOiBvcyxcbiAgICAgICAgICAgIG5vZGU6IGZhbHNlLFxuICAgICAgICAgICAgLy8g5Y6f55SfY2FudmFz5pSv5oyB77yM5pS55p6B56uv54K55LqGXG4gICAgICAgICAgICAvLyBjYW52YXNTdXBwb3J0ZWQgOiAhKGJyb3dzZXIuaWUgJiYgcGFyc2VGbG9hdChicm93c2VyLnZlcnNpb24pIDwgOSlcbiAgICAgICAgICAgIGNhbnZhc1N1cHBvcnRlZCA6IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpLmdldENvbnRleHQgPyB0cnVlIDogZmFsc2UsXG4gICAgICAgICAgICAvLyBAc2VlIDxodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzQ4MTcwMjkvd2hhdHMtdGhlLWJlc3Qtd2F5LXRvLWRldGVjdC1hLXRvdWNoLXNjcmVlbi1kZXZpY2UtdXNpbmctamF2YXNjcmlwdD5cbiAgICAgICAgICAgIC8vIHdvcmtzIG9uIG1vc3QgYnJvd3NlcnNcbiAgICAgICAgICAgIC8vIElFMTAvMTEgZG9lcyBub3Qgc3VwcG9ydCB0b3VjaCBldmVudCwgYW5kIE1TIEVkZ2Ugc3VwcG9ydHMgdGhlbSBidXQgbm90IGJ5XG4gICAgICAgICAgICAvLyBkZWZhdWx0LCBzbyB3ZSBkb250IGNoZWNrIG5hdmlnYXRvci5tYXhUb3VjaFBvaW50cyBmb3IgdGhlbSBoZXJlLlxuICAgICAgICAgICAgdG91Y2hFdmVudHNTdXBwb3J0ZWQ6ICdvbnRvdWNoc3RhcnQnIGluIHdpbmRvdyAmJiAhYnJvd3Nlci5pZSAmJiAhYnJvd3Nlci5lZGdlLFxuICAgICAgICAgICAgLy8gPGh0dHA6Ly9jYW5pdXNlLmNvbS8jc2VhcmNoPXBvaW50ZXIlMjBldmVudD4uXG4gICAgICAgICAgICBwb2ludGVyRXZlbnRzU3VwcG9ydGVkOiAnb25wb2ludGVyZG93bicgaW4gd2luZG93XG4gICAgICAgICAgICAgICAgLy8gRmlyZWZveCBzdXBwb3J0cyBwb2ludGVyIGJ1dCBub3QgYnkgZGVmYXVsdCxcbiAgICAgICAgICAgICAgICAvLyBvbmx5IE1TIGJyb3dzZXJzIGFyZSByZWxpYWJsZSBvbiBwb2ludGVyIGV2ZW50cyBjdXJyZW50bHkuXG4gICAgICAgICAgICAgICAgJiYgKGJyb3dzZXIuZWRnZSB8fCAoYnJvd3Nlci5pZSAmJiBicm93c2VyLnZlcnNpb24gPj0gMTApKVxuICAgICAgICB9O1xuICAgIH1cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3pyZW5kZXIvbGliL2NvcmUvZW52LmpzXG4gKiogbW9kdWxlIGlkID0gNjRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0Jztcbi8qKlxuICogSGFuZGxlclxuICogQG1vZHVsZSB6cmVuZGVyL0hhbmRsZXJcbiAqIEBhdXRob3IgS2VuZXIgKEBLZW5lci3mnpfls7AsIGtlbmVyLmxpbmZlbmdAZ21haWwuY29tKVxuICogICAgICAgICBlcnJvcnJpayAoZXJyb3JyaWtAZ21haWwuY29tKVxuICogICAgICAgICBwaXNzYW5nIChzaGVueWkuOTE0QGdtYWlsLmNvbSlcbiAqL1xuXG5cbiAgICB2YXIgdXRpbCA9IHJlcXVpcmUoJy4vY29yZS91dGlsJyk7XG4gICAgdmFyIERyYWdnYWJsZSA9IHJlcXVpcmUoJy4vbWl4aW4vRHJhZ2dhYmxlJyk7XG5cbiAgICB2YXIgRXZlbnRmdWwgPSByZXF1aXJlKCcuL21peGluL0V2ZW50ZnVsJyk7XG5cbiAgICBmdW5jdGlvbiBtYWtlRXZlbnRQYWNrZXQoZXZlVHlwZSwgdGFyZ2V0LCBldmVudCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogZXZlVHlwZSxcbiAgICAgICAgICAgIGV2ZW50OiBldmVudCxcbiAgICAgICAgICAgIHRhcmdldDogdGFyZ2V0LFxuICAgICAgICAgICAgY2FuY2VsQnViYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIG9mZnNldFg6IGV2ZW50LnpyWCxcbiAgICAgICAgICAgIG9mZnNldFk6IGV2ZW50LnpyWSxcbiAgICAgICAgICAgIGdlc3R1cmVFdmVudDogZXZlbnQuZ2VzdHVyZUV2ZW50LFxuICAgICAgICAgICAgcGluY2hYOiBldmVudC5waW5jaFgsXG4gICAgICAgICAgICBwaW5jaFk6IGV2ZW50LnBpbmNoWSxcbiAgICAgICAgICAgIHBpbmNoU2NhbGU6IGV2ZW50LnBpbmNoU2NhbGUsXG4gICAgICAgICAgICB3aGVlbERlbHRhOiBldmVudC56ckRlbHRhXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gRW1wdHlQcm94eSAoKSB7fVxuICAgIEVtcHR5UHJveHkucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7fTtcblxuICAgIHZhciBoYW5kbGVyTmFtZXMgPSBbXG4gICAgICAgICdjbGljaycsICdkYmxjbGljaycsICdtb3VzZXdoZWVsJywgJ21vdXNlb3V0JyxcbiAgICAgICAgJ21vdXNldXAnLCAnbW91c2Vkb3duJywgJ21vdXNlbW92ZSdcbiAgICBdO1xuICAgIC8qKlxuICAgICAqIEBhbGlhcyBtb2R1bGU6enJlbmRlci9IYW5kbGVyXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQGV4dGVuZHMgbW9kdWxlOnpyZW5kZXIvbWl4aW4vRXZlbnRmdWxcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSByb290IE1haW4gSFRNTCBlbGVtZW50IGZvciBwYWludGluZy5cbiAgICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL1N0b3JhZ2V9IHN0b3JhZ2UgU3RvcmFnZSBpbnN0YW5jZS5cbiAgICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL1BhaW50ZXJ9IHBhaW50ZXIgUGFpbnRlciBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICB2YXIgSGFuZGxlciA9IGZ1bmN0aW9uKHN0b3JhZ2UsIHBhaW50ZXIsIHByb3h5KSB7XG4gICAgICAgIEV2ZW50ZnVsLmNhbGwodGhpcyk7XG5cbiAgICAgICAgdGhpcy5zdG9yYWdlID0gc3RvcmFnZTtcblxuICAgICAgICB0aGlzLnBhaW50ZXIgPSBwYWludGVyO1xuXG4gICAgICAgIHByb3h5ID0gcHJveHkgfHwgbmV3IEVtcHR5UHJveHkoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFByb3h5IG9mIGV2ZW50LiBjYW4gYmUgRG9tLCBXZWJHTFN1cmZhY2UsIGV0Yy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucHJveHkgPSBwcm94eTtcblxuICAgICAgICAvLyBBdHRhY2ggaGFuZGxlclxuICAgICAgICBwcm94eS5oYW5kbGVyID0gdGhpcztcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9ob3ZlcmVkO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAdHlwZSB7RGF0ZX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2xhc3RUb3VjaE1vbWVudDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2xhc3RYO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fbGFzdFk7XG5cblxuICAgICAgICBEcmFnZ2FibGUuY2FsbCh0aGlzKTtcblxuICAgICAgICB1dGlsLmVhY2goaGFuZGxlck5hbWVzLCBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgcHJveHkub24gJiYgcHJveHkub24obmFtZSwgdGhpc1tuYW1lXSwgdGhpcyk7XG4gICAgICAgIH0sIHRoaXMpO1xuICAgIH07XG5cbiAgICBIYW5kbGVyLnByb3RvdHlwZSA9IHtcblxuICAgICAgICBjb25zdHJ1Y3RvcjogSGFuZGxlcixcblxuICAgICAgICBtb3VzZW1vdmU6IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgdmFyIHggPSBldmVudC56clg7XG4gICAgICAgICAgICB2YXIgeSA9IGV2ZW50LnpyWTtcblxuICAgICAgICAgICAgdmFyIGhvdmVyZWQgPSB0aGlzLmZpbmRIb3Zlcih4LCB5LCBudWxsKTtcbiAgICAgICAgICAgIHZhciBsYXN0SG92ZXJlZCA9IHRoaXMuX2hvdmVyZWQ7XG4gICAgICAgICAgICB2YXIgcHJveHkgPSB0aGlzLnByb3h5O1xuXG4gICAgICAgICAgICB0aGlzLl9ob3ZlcmVkID0gaG92ZXJlZDtcblxuICAgICAgICAgICAgcHJveHkuc2V0Q3Vyc29yICYmIHByb3h5LnNldEN1cnNvcihob3ZlcmVkID8gaG92ZXJlZC5jdXJzb3IgOiAnZGVmYXVsdCcpO1xuXG4gICAgICAgICAgICAvLyBNb3VzZSBvdXQgb24gcHJldmlvdXMgaG92ZXJlZCBlbGVtZW50XG4gICAgICAgICAgICBpZiAobGFzdEhvdmVyZWQgJiYgaG92ZXJlZCAhPT0gbGFzdEhvdmVyZWQgJiYgbGFzdEhvdmVyZWQuX196cikge1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hUb0VsZW1lbnQobGFzdEhvdmVyZWQsICdtb3VzZW91dCcsIGV2ZW50KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gTW91c2UgbW92aW5nIG9uIG9uZSBlbGVtZW50XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoVG9FbGVtZW50KGhvdmVyZWQsICdtb3VzZW1vdmUnLCBldmVudCk7XG5cbiAgICAgICAgICAgIC8vIE1vdXNlIG92ZXIgb24gYSBuZXcgZWxlbWVudFxuICAgICAgICAgICAgaWYgKGhvdmVyZWQgJiYgaG92ZXJlZCAhPT0gbGFzdEhvdmVyZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoVG9FbGVtZW50KGhvdmVyZWQsICdtb3VzZW92ZXInLCBldmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgbW91c2VvdXQ6IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaFRvRWxlbWVudCh0aGlzLl9ob3ZlcmVkLCAnbW91c2VvdXQnLCBldmVudCk7XG5cbiAgICAgICAgICAgIHRoaXMudHJpZ2dlcignZ2xvYmFsb3V0Jywge1xuICAgICAgICAgICAgICAgIGV2ZW50OiBldmVudFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlc2l6ZVxuICAgICAgICAgKi9cbiAgICAgICAgcmVzaXplOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuX2hvdmVyZWQgPSBudWxsO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEaXNwYXRjaCBldmVudFxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lXG4gICAgICAgICAqIEBwYXJhbSB7ZXZlbnQ9fSBldmVudEFyZ3NcbiAgICAgICAgICovXG4gICAgICAgIGRpc3BhdGNoOiBmdW5jdGlvbiAoZXZlbnROYW1lLCBldmVudEFyZ3MpIHtcbiAgICAgICAgICAgIHZhciBoYW5kbGVyID0gdGhpc1tldmVudE5hbWVdO1xuICAgICAgICAgICAgaGFuZGxlciAmJiBoYW5kbGVyLmNhbGwodGhpcywgZXZlbnRBcmdzKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGlzcG9zZVxuICAgICAgICAgKi9cbiAgICAgICAgZGlzcG9zZTogZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICB0aGlzLnByb3h5LmRpc3Bvc2UoKTtcblxuICAgICAgICAgICAgdGhpcy5zdG9yYWdlID1cbiAgICAgICAgICAgIHRoaXMucHJveHkgPVxuICAgICAgICAgICAgdGhpcy5wYWludGVyID0gbnVsbDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog6K6+572u6buY6K6k55qEY3Vyc29yIHN0eWxlXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY3Vyc29yU3R5bGU9J2RlZmF1bHQnXSDkvovlpoIgY3Jvc3NoYWlyXG4gICAgICAgICAqL1xuICAgICAgICBzZXRDdXJzb3JTdHlsZTogZnVuY3Rpb24gKGN1cnNvclN0eWxlKSB7XG4gICAgICAgICAgICB2YXIgcHJveHkgPSB0aGlzLnByb3h5O1xuICAgICAgICAgICAgcHJveHkuc2V0Q3Vyc29yICYmIHByb3h5LnNldEN1cnNvcihjdXJzb3JTdHlsZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOS6i+S7tuWIhuWPkeS7o+eQhlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0RWwg55uu5qCH5Zu+5b2i5YWD57SgXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUg5LqL5Lu25ZCN56ewXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCDkuovku7blr7nosaFcbiAgICAgICAgICovXG4gICAgICAgIGRpc3BhdGNoVG9FbGVtZW50OiBmdW5jdGlvbiAodGFyZ2V0RWwsIGV2ZW50TmFtZSwgZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBldmVudEhhbmRsZXIgPSAnb24nICsgZXZlbnROYW1lO1xuICAgICAgICAgICAgdmFyIGV2ZW50UGFja2V0ID0gbWFrZUV2ZW50UGFja2V0KGV2ZW50TmFtZSwgdGFyZ2V0RWwsIGV2ZW50KTtcblxuICAgICAgICAgICAgdmFyIGVsID0gdGFyZ2V0RWw7XG5cbiAgICAgICAgICAgIHdoaWxlIChlbCkge1xuICAgICAgICAgICAgICAgIGVsW2V2ZW50SGFuZGxlcl1cbiAgICAgICAgICAgICAgICAgICAgJiYgKGV2ZW50UGFja2V0LmNhbmNlbEJ1YmJsZSA9IGVsW2V2ZW50SGFuZGxlcl0uY2FsbChlbCwgZXZlbnRQYWNrZXQpKTtcblxuICAgICAgICAgICAgICAgIGVsLnRyaWdnZXIoZXZlbnROYW1lLCBldmVudFBhY2tldCk7XG5cbiAgICAgICAgICAgICAgICBlbCA9IGVsLnBhcmVudDtcblxuICAgICAgICAgICAgICAgIGlmIChldmVudFBhY2tldC5jYW5jZWxCdWJibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWV2ZW50UGFja2V0LmNhbmNlbEJ1YmJsZSkge1xuICAgICAgICAgICAgICAgIC8vIOWGkuazoeWIsOmhtue6pyB6cmVuZGVyIOWvueixoVxuICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlcihldmVudE5hbWUsIGV2ZW50UGFja2V0KTtcbiAgICAgICAgICAgICAgICAvLyDliIblj5Hkuovku7bliLDnlKjmiLfoh6rlrprkuYnlsYJcbiAgICAgICAgICAgICAgICAvLyDnlKjmiLfmnInlj6/og73lnKjlhajlsYAgY2xpY2sg5LqL5Lu25LitIGRpc3Bvc2XvvIzmiYDku6XpnIDopoHliKTmlq3kuIsgcGFpbnRlciDmmK/lkKblrZjlnKhcbiAgICAgICAgICAgICAgICB0aGlzLnBhaW50ZXIgJiYgdGhpcy5wYWludGVyLmVhY2hPdGhlckxheWVyKGZ1bmN0aW9uIChsYXllcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mKGxheWVyW2V2ZW50SGFuZGxlcl0pID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxheWVyW2V2ZW50SGFuZGxlcl0uY2FsbChsYXllciwgZXZlbnRQYWNrZXQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChsYXllci50cmlnZ2VyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYXllci50cmlnZ2VyKGV2ZW50TmFtZSwgZXZlbnRQYWNrZXQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gICAgICAgICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvZ3JhcGhpYy9EaXNwbGF5YWJsZX0gZXhjbHVkZVxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqL1xuICAgICAgICBmaW5kSG92ZXI6IGZ1bmN0aW9uKHgsIHksIGV4Y2x1ZGUpIHtcbiAgICAgICAgICAgIHZhciBsaXN0ID0gdGhpcy5zdG9yYWdlLmdldERpc3BsYXlMaXN0KCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gbGlzdC5sZW5ndGggLSAxOyBpID49IDAgOyBpLS0pIHtcbiAgICAgICAgICAgICAgICBpZiAoIWxpc3RbaV0uc2lsZW50XG4gICAgICAgICAgICAgICAgICYmIGxpc3RbaV0gIT09IGV4Y2x1ZGVcbiAgICAgICAgICAgICAgICAgLy8gZ2V0RGlzcGxheUxpc3QgbWF5IGluY2x1ZGUgaWdub3JlZCBpdGVtIGluIFZNTCBtb2RlXG4gICAgICAgICAgICAgICAgICYmICFsaXN0W2ldLmlnbm9yZVxuICAgICAgICAgICAgICAgICAmJiBpc0hvdmVyKGxpc3RbaV0sIHgsIHkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBsaXN0W2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBDb21tb24gaGFuZGxlcnNcbiAgICB1dGlsLmVhY2goWydjbGljaycsICdtb3VzZWRvd24nLCAnbW91c2V1cCcsICdtb3VzZXdoZWVsJywgJ2RibGNsaWNrJ10sIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIEhhbmRsZXIucHJvdG90eXBlW25hbWVdID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAvLyBGaW5kIGhvdmVyIGFnYWluIHRvIGF2b2lkIGNsaWNrIGV2ZW50IGlzIGRpc3BhdGNoZWQgbWFudWFsbHkuIE9yIGNsaWNrIGlzIHRyaWdnZXJlZCB3aXRob3V0IG1vdXNlb3ZlclxuICAgICAgICAgICAgdmFyIGhvdmVyZWQgPSB0aGlzLmZpbmRIb3ZlcihldmVudC56clgsIGV2ZW50LnpyWSwgbnVsbCk7XG5cbiAgICAgICAgICAgIGlmIChuYW1lID09PSAnbW91c2Vkb3duJykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2Rvd25lbCA9IGhvdmVyZWQ7XG4gICAgICAgICAgICAgICAgLy8gSW4gY2FzZSBjbGljayB0cmlnZ2VyZWQgYmVmb3JlIG1vdXNldXBcbiAgICAgICAgICAgICAgICB0aGlzLl91cGVsID0gaG92ZXJlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG5hbWUgPT09ICdtb3N1ZXVwJykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3VwZWwgPSBob3ZlcmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobmFtZSA9PT0gJ2NsaWNrJykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9kb3duZWwgIT09IHRoaXMuX3VwZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaFRvRWxlbWVudChob3ZlcmVkLCBuYW1lLCBldmVudCk7XG4gICAgICAgIH07XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBpc0hvdmVyKGRpc3BsYXlhYmxlLCB4LCB5KSB7XG4gICAgICAgIGlmIChkaXNwbGF5YWJsZVtkaXNwbGF5YWJsZS5yZWN0SG92ZXIgPyAncmVjdENvbnRhaW4nIDogJ2NvbnRhaW4nXSh4LCB5KSkge1xuICAgICAgICAgICAgdmFyIGVsID0gZGlzcGxheWFibGU7XG4gICAgICAgICAgICB3aGlsZSAoZWwpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBhbmNlc3RvciBpcyBzaWxlbnQgb3IgY2xpcHBlZCBieSBhbmNlc3RvclxuICAgICAgICAgICAgICAgIGlmIChlbC5zaWxlbnQgfHwgKGVsLmNsaXBQYXRoICYmICFlbC5jbGlwUGF0aC5jb250YWluKHgsIHkpKSkgIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbCA9IGVsLnBhcmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHV0aWwubWl4aW4oSGFuZGxlciwgRXZlbnRmdWwpO1xuICAgIHV0aWwubWl4aW4oSGFuZGxlciwgRHJhZ2dhYmxlKTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gSGFuZGxlcjtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3pyZW5kZXIvbGliL0hhbmRsZXIuanNcbiAqKiBtb2R1bGUgaWQgPSA2NVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuLyoqXG4gKiBTdG9yYWdl5YaF5a655LuT5bqT5qih5Z2XXG4gKiBAbW9kdWxlIHpyZW5kZXIvU3RvcmFnZVxuICogQGF1dGhvciBLZW5lciAoQEtlbmVyLeael+WzsCwga2VuZXIubGluZmVuZ0BnbWFpbC5jb20pXG4gKiBAYXV0aG9yIGVycm9ycmlrIChlcnJvcnJpa0BnbWFpbC5jb20pXG4gKiBAYXV0aG9yIHBpc3NhbmcgKGh0dHBzOi8vZ2l0aHViLmNvbS9waXNzYW5nLylcbiAqL1xuXG5cbiAgICB2YXIgdXRpbCA9IHJlcXVpcmUoJy4vY29yZS91dGlsJyk7XG4gICAgdmFyIGVudiA9IHJlcXVpcmUoJy4vY29yZS9lbnYnKTtcblxuICAgIHZhciBHcm91cCA9IHJlcXVpcmUoJy4vY29udGFpbmVyL0dyb3VwJyk7XG5cbiAgICAvLyBVc2UgdGltc29ydCBiZWNhdXNlIGluIG1vc3QgY2FzZSBlbGVtZW50cyBhcmUgcGFydGlhbGx5IHNvcnRlZFxuICAgIC8vIGh0dHBzOi8vanNmaWRkbGUubmV0L3Bpc3NhbmcvanI0eDdtZG0vOC9cbiAgICB2YXIgdGltc29ydCA9IHJlcXVpcmUoJy4vY29yZS90aW1zb3J0Jyk7XG5cbiAgICBmdW5jdGlvbiBzaGFwZUNvbXBhcmVGdW5jKGEsIGIpIHtcbiAgICAgICAgaWYgKGEuemxldmVsID09PSBiLnpsZXZlbCkge1xuICAgICAgICAgICAgaWYgKGEueiA9PT0gYi56KSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgKGEuejIgPT09IGIuejIpIHtcbiAgICAgICAgICAgICAgICAvLyAgICAgLy8gRklYTUUgU2xvdyBoYXMgcmVuZGVyaWR4IGNvbXBhcmVcbiAgICAgICAgICAgICAgICAvLyAgICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8yMDg4MzQyMS9zb3J0aW5nLWluLWphdmFzY3JpcHQtc2hvdWxkLWV2ZXJ5LWNvbXBhcmUtZnVuY3Rpb24taGF2ZS1hLXJldHVybi0wLXN0YXRlbWVudFxuICAgICAgICAgICAgICAgIC8vICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vdjgvdjgvYmxvYi80N2NjZTU0NGEzMWVkNTU3N2ZmZTI5NjNmNjdhY2I0MTQ0ZWUwMjMyL3NyYy9qcy9hcnJheS5qcyNMMTAxMlxuICAgICAgICAgICAgICAgIC8vICAgICByZXR1cm4gYS5fX3JlbmRlcmlkeCAtIGIuX19yZW5kZXJpZHg7XG4gICAgICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgICAgIHJldHVybiBhLnoyIC0gYi56MjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhLnogLSBiLno7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGEuemxldmVsIC0gYi56bGV2ZWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIOWGheWuueS7k+W6kyAoTSlcbiAgICAgKiBAYWxpYXMgbW9kdWxlOnpyZW5kZXIvU3RvcmFnZVxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIHZhciBTdG9yYWdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyDmiYDmnInluLjop4TlvaLnirbvvIxpZOe0ouW8leeahG1hcFxuICAgICAgICB0aGlzLl9lbGVtZW50cyA9IHt9O1xuXG4gICAgICAgIHRoaXMuX3Jvb3RzID0gW107XG5cbiAgICAgICAgdGhpcy5fZGlzcGxheUxpc3QgPSBbXTtcblxuICAgICAgICB0aGlzLl9kaXNwbGF5TGlzdExlbiA9IDA7XG4gICAgfTtcblxuICAgIFN0b3JhZ2UucHJvdG90eXBlID0ge1xuXG4gICAgICAgIGNvbnN0cnVjdG9yOiBTdG9yYWdlLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gY2JcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIHRyYXZlcnNlOiBmdW5jdGlvbiAoY2IsIGNvbnRleHQpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fcm9vdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yb290c1tpXS50cmF2ZXJzZShjYiwgY29udGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOi/lOWbnuaJgOacieWbvuW9oueahOe7mOWItumYn+WIl1xuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFt1cGRhdGU9ZmFsc2VdIOaYr+WQpuWcqOi/lOWbnuWJjeabtOaWsOivpeaVsOe7hFxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpbmNsdWRlSWdub3JlPWZhbHNlXSDmmK/lkKbljIXlkKsgaWdub3JlIOeahOaVsOe7hCwg5ZyoIHVwZGF0ZSDkuLogdHJ1ZSDnmoTml7blgJnmnInmlYhcbiAgICAgICAgICpcbiAgICAgICAgICog6K+m6KeBe0BsaW5rIG1vZHVsZTp6cmVuZGVyL2dyYXBoaWMvRGlzcGxheWFibGUucHJvdG90eXBlLnVwZGF0ZURpc3BsYXlMaXN0fVxuICAgICAgICAgKiBAcmV0dXJuIHtBcnJheS48bW9kdWxlOnpyZW5kZXIvZ3JhcGhpYy9EaXNwbGF5YWJsZT59XG4gICAgICAgICAqL1xuICAgICAgICBnZXREaXNwbGF5TGlzdDogZnVuY3Rpb24gKHVwZGF0ZSwgaW5jbHVkZUlnbm9yZSkge1xuICAgICAgICAgICAgaW5jbHVkZUlnbm9yZSA9IGluY2x1ZGVJZ25vcmUgfHwgZmFsc2U7XG4gICAgICAgICAgICBpZiAodXBkYXRlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVEaXNwbGF5TGlzdChpbmNsdWRlSWdub3JlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kaXNwbGF5TGlzdDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5pu05paw5Zu+5b2i55qE57uY5Yi26Zif5YiX44CCXG4gICAgICAgICAqIOavj+asoee7mOWItuWJjemDveS8muiwg+eUqO+8jOivpeaWueazleS8muWFiOa3seW6puS8mOWFiOmBjeWOhuaVtOS4quagke+8jOabtOaWsOaJgOaciUdyb3Vw5ZKMU2hhcGXnmoTlj5jmjaLlubbkuJTmiormiYDmnInlj6/op4HnmoRTaGFwZeS/neWtmOWIsOaVsOe7hOS4re+8jFxuICAgICAgICAgKiDmnIDlkI7moLnmja7nu5jliLbnmoTkvJjlhYjnuqfvvIh6bGV2ZWwgPiB6ID4g5o+S5YWl6aG65bqP77yJ5o6S5bqP5b6X5Yiw57uY5Yi26Zif5YiXXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2luY2x1ZGVJZ25vcmU9ZmFsc2VdIOaYr+WQpuWMheWQqyBpZ25vcmUg55qE5pWw57uEXG4gICAgICAgICAqL1xuICAgICAgICB1cGRhdGVEaXNwbGF5TGlzdDogZnVuY3Rpb24gKGluY2x1ZGVJZ25vcmUpIHtcbiAgICAgICAgICAgIHRoaXMuX2Rpc3BsYXlMaXN0TGVuID0gMDtcbiAgICAgICAgICAgIHZhciByb290cyA9IHRoaXMuX3Jvb3RzO1xuICAgICAgICAgICAgdmFyIGRpc3BsYXlMaXN0ID0gdGhpcy5fZGlzcGxheUxpc3Q7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gcm9vdHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVBbmRBZGREaXNwbGF5YWJsZShyb290c1tpXSwgbnVsbCwgaW5jbHVkZUlnbm9yZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkaXNwbGF5TGlzdC5sZW5ndGggPSB0aGlzLl9kaXNwbGF5TGlzdExlbjtcblxuICAgICAgICAgICAgLy8gZm9yICh2YXIgaSA9IDAsIGxlbiA9IGRpc3BsYXlMaXN0Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAvLyAgICAgZGlzcGxheUxpc3RbaV0uX19yZW5kZXJpZHggPSBpO1xuICAgICAgICAgICAgLy8gfVxuXG4gICAgICAgICAgICAvLyBkaXNwbGF5TGlzdC5zb3J0KHNoYXBlQ29tcGFyZUZ1bmMpO1xuICAgICAgICAgICAgZW52LmNhbnZhc1N1cHBvcnRlZCAmJiB0aW1zb3J0KGRpc3BsYXlMaXN0LCBzaGFwZUNvbXBhcmVGdW5jKTtcbiAgICAgICAgfSxcblxuICAgICAgICBfdXBkYXRlQW5kQWRkRGlzcGxheWFibGU6IGZ1bmN0aW9uIChlbCwgY2xpcFBhdGhzLCBpbmNsdWRlSWdub3JlKSB7XG5cbiAgICAgICAgICAgIGlmIChlbC5pZ25vcmUgJiYgIWluY2x1ZGVJZ25vcmUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGVsLmJlZm9yZVVwZGF0ZSgpO1xuXG4gICAgICAgICAgICBpZiAoZWwuX19kaXJ0eSkge1xuXG4gICAgICAgICAgICAgICAgZWwudXBkYXRlKCk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZWwuYWZ0ZXJVcGRhdGUoKTtcblxuICAgICAgICAgICAgdmFyIGNsaXBQYXRoID0gZWwuY2xpcFBhdGg7XG4gICAgICAgICAgICBpZiAoY2xpcFBhdGgpIHtcbiAgICAgICAgICAgICAgICAvLyBjbGlwUGF0aCDnmoTlj5jmjaLmmK/ln7rkuo4gZ3JvdXAg55qE5Y+Y5o2iXG4gICAgICAgICAgICAgICAgY2xpcFBhdGgucGFyZW50ID0gZWw7XG4gICAgICAgICAgICAgICAgY2xpcFBhdGgudXBkYXRlVHJhbnNmb3JtKCk7XG5cbiAgICAgICAgICAgICAgICAvLyBGSVhNRSDmlYjnjoflvbHlk41cbiAgICAgICAgICAgICAgICBpZiAoY2xpcFBhdGhzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsaXBQYXRocyA9IGNsaXBQYXRocy5zbGljZSgpO1xuICAgICAgICAgICAgICAgICAgICBjbGlwUGF0aHMucHVzaChjbGlwUGF0aCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjbGlwUGF0aHMgPSBbY2xpcFBhdGhdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGVsLmlzR3JvdXApIHtcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGRyZW4gPSBlbC5fY2hpbGRyZW47XG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIEZvcmNlIHRvIG1hcmsgYXMgZGlydHkgaWYgZ3JvdXAgaXMgZGlydHlcbiAgICAgICAgICAgICAgICAgICAgLy8gRklYTUUgX19kaXJ0eVBhdGggP1xuICAgICAgICAgICAgICAgICAgICBpZiAoZWwuX19kaXJ0eSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGQuX19kaXJ0eSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVBbmRBZGREaXNwbGF5YWJsZShjaGlsZCwgY2xpcFBhdGhzLCBpbmNsdWRlSWdub3JlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBNYXJrIGdyb3VwIGNsZWFuIGhlcmVcbiAgICAgICAgICAgICAgICBlbC5fX2RpcnR5ID0gZmFsc2U7XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGVsLl9fY2xpcFBhdGhzID0gY2xpcFBhdGhzO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5fZGlzcGxheUxpc3RbdGhpcy5fZGlzcGxheUxpc3RMZW4rK10gPSBlbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5re75Yqg5Zu+5b2iKFNoYXBlKeaIluiAhee7hChHcm91cCnliLDmoLnoioLngrlcbiAgICAgICAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9FbGVtZW50fSBlbFxuICAgICAgICAgKi9cbiAgICAgICAgYWRkUm9vdDogZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICAvLyBFbGVtZW50IGhhcyBiZWVuIGFkZGVkXG4gICAgICAgICAgICBpZiAodGhpcy5fZWxlbWVudHNbZWwuaWRdKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZWwgaW5zdGFuY2VvZiBHcm91cCkge1xuICAgICAgICAgICAgICAgIGVsLmFkZENoaWxkcmVuVG9TdG9yYWdlKHRoaXMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmFkZFRvTWFwKGVsKTtcbiAgICAgICAgICAgIHRoaXMuX3Jvb3RzLnB1c2goZWwpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDliKDpmaTmjIflrprnmoTlm77lvaIoU2hhcGUp5oiW6ICF57uEKEdyb3VwKVxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ3xBcnJheS48c3RyaW5nPn0gW2VsSWRdIOWmguaenOS4uuepuua4heepuuaVtOS4qlN0b3JhZ2VcbiAgICAgICAgICovXG4gICAgICAgIGRlbFJvb3Q6IGZ1bmN0aW9uIChlbElkKSB7XG4gICAgICAgICAgICBpZiAoZWxJZCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgLy8g5LiN5oyH5a6aZWxJZOa4heepulxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fcm9vdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJvb3QgPSB0aGlzLl9yb290c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJvb3QgaW5zdGFuY2VvZiBHcm91cCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcm9vdC5kZWxDaGlsZHJlbkZyb21TdG9yYWdlKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5fZWxlbWVudHMgPSB7fTtcbiAgICAgICAgICAgICAgICB0aGlzLl9yb290cyA9IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuX2Rpc3BsYXlMaXN0ID0gW107XG4gICAgICAgICAgICAgICAgdGhpcy5fZGlzcGxheUxpc3RMZW4gPSAwO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZWxJZCBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBlbElkLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlbFJvb3QoZWxJZFtpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGVsO1xuICAgICAgICAgICAgaWYgKHR5cGVvZihlbElkKSA9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGVsID0gdGhpcy5fZWxlbWVudHNbZWxJZF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBlbCA9IGVsSWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBpZHggPSB1dGlsLmluZGV4T2YodGhpcy5fcm9vdHMsIGVsKTtcbiAgICAgICAgICAgIGlmIChpZHggPj0gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGVsRnJvbU1hcChlbC5pZCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcm9vdHMuc3BsaWNlKGlkeCwgMSk7XG4gICAgICAgICAgICAgICAgaWYgKGVsIGluc3RhbmNlb2YgR3JvdXApIHtcbiAgICAgICAgICAgICAgICAgICAgZWwuZGVsQ2hpbGRyZW5Gcm9tU3RvcmFnZSh0aGlzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgYWRkVG9NYXA6IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgaWYgKGVsIGluc3RhbmNlb2YgR3JvdXApIHtcbiAgICAgICAgICAgICAgICBlbC5fX3N0b3JhZ2UgPSB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWwuZGlydHkoZmFsc2UpO1xuXG4gICAgICAgICAgICB0aGlzLl9lbGVtZW50c1tlbC5pZF0gPSBlbDtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoZWxJZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2VsZW1lbnRzW2VsSWRdO1xuICAgICAgICB9LFxuXG4gICAgICAgIGRlbEZyb21NYXA6IGZ1bmN0aW9uIChlbElkKSB7XG4gICAgICAgICAgICB2YXIgZWxlbWVudHMgPSB0aGlzLl9lbGVtZW50cztcbiAgICAgICAgICAgIHZhciBlbCA9IGVsZW1lbnRzW2VsSWRdO1xuICAgICAgICAgICAgaWYgKGVsKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGVsZW1lbnRzW2VsSWRdO1xuICAgICAgICAgICAgICAgIGlmIChlbCBpbnN0YW5jZW9mIEdyb3VwKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsLl9fc3RvcmFnZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5riF56m65bm25LiU6YeK5pS+U3RvcmFnZVxuICAgICAgICAgKi9cbiAgICAgICAgZGlzcG9zZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5fZWxlbWVudHMgPVxuICAgICAgICAgICAgdGhpcy5fcmVuZGVyTGlzdCA9XG4gICAgICAgICAgICB0aGlzLl9yb290cyA9IG51bGw7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZGlzcGxheWFibGVTb3J0RnVuYzogc2hhcGVDb21wYXJlRnVuY1xuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IFN0b3JhZ2U7XG5cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3pyZW5kZXIvbGliL1N0b3JhZ2UuanNcbiAqKiBtb2R1bGUgaWQgPSA2NlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL216aWNjYXJkL25vZGUtdGltc29ydFxuXG4gICAgdmFyIERFRkFVTFRfTUlOX01FUkdFID0gMzI7XG5cbiAgICB2YXIgREVGQVVMVF9NSU5fR0FMTE9QSU5HID0gNztcblxuICAgIHZhciBERUZBVUxUX1RNUF9TVE9SQUdFX0xFTkdUSCA9IDI1NjtcblxuICAgIGZ1bmN0aW9uIG1pblJ1bkxlbmd0aChuKSB7XG4gICAgICAgIHZhciByID0gMDtcblxuICAgICAgICB3aGlsZSAobiA+PSBERUZBVUxUX01JTl9NRVJHRSkge1xuICAgICAgICAgICAgciB8PSBuICYgMTtcbiAgICAgICAgICAgIG4gPj49IDE7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbiArIHI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWFrZUFzY2VuZGluZ1J1bihhcnJheSwgbG8sIGhpLCBjb21wYXJlKSB7XG4gICAgICAgIHZhciBydW5IaSA9IGxvICsgMTtcblxuICAgICAgICBpZiAocnVuSGkgPT09IGhpKSB7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb21wYXJlKGFycmF5W3J1bkhpKytdLCBhcnJheVtsb10pIDwgMCkge1xuICAgICAgICAgICAgd2hpbGUgKHJ1bkhpIDwgaGkgJiYgY29tcGFyZShhcnJheVtydW5IaV0sIGFycmF5W3J1bkhpIC0gMV0pIDwgMCkge1xuICAgICAgICAgICAgICAgIHJ1bkhpKys7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldmVyc2VSdW4oYXJyYXksIGxvLCBydW5IaSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB3aGlsZSAocnVuSGkgPCBoaSAmJiBjb21wYXJlKGFycmF5W3J1bkhpXSwgYXJyYXlbcnVuSGkgLSAxXSkgPj0gMCkge1xuICAgICAgICAgICAgICAgIHJ1bkhpKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcnVuSGkgLSBsbztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZXZlcnNlUnVuKGFycmF5LCBsbywgaGkpIHtcbiAgICAgICAgaGktLTtcblxuICAgICAgICB3aGlsZSAobG8gPCBoaSkge1xuICAgICAgICAgICAgdmFyIHQgPSBhcnJheVtsb107XG4gICAgICAgICAgICBhcnJheVtsbysrXSA9IGFycmF5W2hpXTtcbiAgICAgICAgICAgIGFycmF5W2hpLS1dID0gdDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGJpbmFyeUluc2VydGlvblNvcnQoYXJyYXksIGxvLCBoaSwgc3RhcnQsIGNvbXBhcmUpIHtcbiAgICAgICAgaWYgKHN0YXJ0ID09PSBsbykge1xuICAgICAgICAgICAgc3RhcnQrKztcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoOyBzdGFydCA8IGhpOyBzdGFydCsrKSB7XG4gICAgICAgICAgICB2YXIgcGl2b3QgPSBhcnJheVtzdGFydF07XG5cbiAgICAgICAgICAgIHZhciBsZWZ0ID0gbG87XG4gICAgICAgICAgICB2YXIgcmlnaHQgPSBzdGFydDtcbiAgICAgICAgICAgIHZhciBtaWQ7XG5cbiAgICAgICAgICAgIHdoaWxlIChsZWZ0IDwgcmlnaHQpIHtcbiAgICAgICAgICAgICAgICBtaWQgPSBsZWZ0ICsgcmlnaHQgPj4+IDE7XG5cbiAgICAgICAgICAgICAgICBpZiAoY29tcGFyZShwaXZvdCwgYXJyYXlbbWlkXSkgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gbWlkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGVmdCA9IG1pZCArIDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgbiA9IHN0YXJ0IC0gbGVmdDtcblxuICAgICAgICAgICAgc3dpdGNoIChuKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICBhcnJheVtsZWZ0ICsgM10gPSBhcnJheVtsZWZ0ICsgMl07XG5cbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIGFycmF5W2xlZnQgKyAyXSA9IGFycmF5W2xlZnQgKyAxXTtcblxuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgYXJyYXlbbGVmdCArIDFdID0gYXJyYXlbbGVmdF07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChuID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJyYXlbbGVmdCArIG5dID0gYXJyYXlbbGVmdCArIG4gLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG4tLTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBhcnJheVtsZWZ0XSA9IHBpdm90O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2FsbG9wTGVmdCh2YWx1ZSwgYXJyYXksIHN0YXJ0LCBsZW5ndGgsIGhpbnQsIGNvbXBhcmUpIHtcbiAgICAgICAgdmFyIGxhc3RPZmZzZXQgPSAwO1xuICAgICAgICB2YXIgbWF4T2Zmc2V0ID0gMDtcbiAgICAgICAgdmFyIG9mZnNldCA9IDE7XG5cbiAgICAgICAgaWYgKGNvbXBhcmUodmFsdWUsIGFycmF5W3N0YXJ0ICsgaGludF0pID4gMCkge1xuICAgICAgICAgICAgbWF4T2Zmc2V0ID0gbGVuZ3RoIC0gaGludDtcblxuICAgICAgICAgICAgd2hpbGUgKG9mZnNldCA8IG1heE9mZnNldCAmJiBjb21wYXJlKHZhbHVlLCBhcnJheVtzdGFydCArIGhpbnQgKyBvZmZzZXRdKSA+IDApIHtcbiAgICAgICAgICAgICAgICBsYXN0T2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICAgICAgICAgIG9mZnNldCA9IChvZmZzZXQgPDwgMSkgKyAxO1xuXG4gICAgICAgICAgICAgICAgaWYgKG9mZnNldCA8PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG9mZnNldCA9IG1heE9mZnNldDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChvZmZzZXQgPiBtYXhPZmZzZXQpIHtcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSBtYXhPZmZzZXQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxhc3RPZmZzZXQgKz0gaGludDtcbiAgICAgICAgICAgIG9mZnNldCArPSBoaW50O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWF4T2Zmc2V0ID0gaGludCArIDE7XG4gICAgICAgICAgICB3aGlsZSAob2Zmc2V0IDwgbWF4T2Zmc2V0ICYmIGNvbXBhcmUodmFsdWUsIGFycmF5W3N0YXJ0ICsgaGludCAtIG9mZnNldF0pIDw9IDApIHtcbiAgICAgICAgICAgICAgICBsYXN0T2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICAgICAgICAgIG9mZnNldCA9IChvZmZzZXQgPDwgMSkgKyAxO1xuXG4gICAgICAgICAgICAgICAgaWYgKG9mZnNldCA8PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG9mZnNldCA9IG1heE9mZnNldDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob2Zmc2V0ID4gbWF4T2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gbWF4T2Zmc2V0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgdG1wID0gbGFzdE9mZnNldDtcbiAgICAgICAgICAgIGxhc3RPZmZzZXQgPSBoaW50IC0gb2Zmc2V0O1xuICAgICAgICAgICAgb2Zmc2V0ID0gaGludCAtIHRtcDtcbiAgICAgICAgfVxuXG4gICAgICAgIGxhc3RPZmZzZXQrKztcbiAgICAgICAgd2hpbGUgKGxhc3RPZmZzZXQgPCBvZmZzZXQpIHtcbiAgICAgICAgICAgIHZhciBtID0gbGFzdE9mZnNldCArIChvZmZzZXQgLSBsYXN0T2Zmc2V0ID4+PiAxKTtcblxuICAgICAgICAgICAgaWYgKGNvbXBhcmUodmFsdWUsIGFycmF5W3N0YXJ0ICsgbV0pID4gMCkge1xuICAgICAgICAgICAgICAgIGxhc3RPZmZzZXQgPSBtICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG9mZnNldCA9IG07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9mZnNldDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnYWxsb3BSaWdodCh2YWx1ZSwgYXJyYXksIHN0YXJ0LCBsZW5ndGgsIGhpbnQsIGNvbXBhcmUpIHtcbiAgICAgICAgdmFyIGxhc3RPZmZzZXQgPSAwO1xuICAgICAgICB2YXIgbWF4T2Zmc2V0ID0gMDtcbiAgICAgICAgdmFyIG9mZnNldCA9IDE7XG5cbiAgICAgICAgaWYgKGNvbXBhcmUodmFsdWUsIGFycmF5W3N0YXJ0ICsgaGludF0pIDwgMCkge1xuICAgICAgICAgICAgbWF4T2Zmc2V0ID0gaGludCArIDE7XG5cbiAgICAgICAgICAgIHdoaWxlIChvZmZzZXQgPCBtYXhPZmZzZXQgJiYgY29tcGFyZSh2YWx1ZSwgYXJyYXlbc3RhcnQgKyBoaW50IC0gb2Zmc2V0XSkgPCAwKSB7XG4gICAgICAgICAgICAgICAgbGFzdE9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSAob2Zmc2V0IDw8IDEpICsgMTtcblxuICAgICAgICAgICAgICAgIGlmIChvZmZzZXQgPD0gMCkge1xuICAgICAgICAgICAgICAgICAgICBvZmZzZXQgPSBtYXhPZmZzZXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAob2Zmc2V0ID4gbWF4T2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gbWF4T2Zmc2V0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgdG1wID0gbGFzdE9mZnNldDtcbiAgICAgICAgICAgIGxhc3RPZmZzZXQgPSBoaW50IC0gb2Zmc2V0O1xuICAgICAgICAgICAgb2Zmc2V0ID0gaGludCAtIHRtcDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1heE9mZnNldCA9IGxlbmd0aCAtIGhpbnQ7XG5cbiAgICAgICAgICAgIHdoaWxlIChvZmZzZXQgPCBtYXhPZmZzZXQgJiYgY29tcGFyZSh2YWx1ZSwgYXJyYXlbc3RhcnQgKyBoaW50ICsgb2Zmc2V0XSkgPj0gMCkge1xuICAgICAgICAgICAgICAgIGxhc3RPZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gKG9mZnNldCA8PCAxKSArIDE7XG5cbiAgICAgICAgICAgICAgICBpZiAob2Zmc2V0IDw9IDApIHtcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ID0gbWF4T2Zmc2V0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG9mZnNldCA+IG1heE9mZnNldCkge1xuICAgICAgICAgICAgICAgIG9mZnNldCA9IG1heE9mZnNldDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGFzdE9mZnNldCArPSBoaW50O1xuICAgICAgICAgICAgb2Zmc2V0ICs9IGhpbnQ7XG4gICAgICAgIH1cblxuICAgICAgICBsYXN0T2Zmc2V0Kys7XG5cbiAgICAgICAgd2hpbGUgKGxhc3RPZmZzZXQgPCBvZmZzZXQpIHtcbiAgICAgICAgICAgIHZhciBtID0gbGFzdE9mZnNldCArIChvZmZzZXQgLSBsYXN0T2Zmc2V0ID4+PiAxKTtcblxuICAgICAgICAgICAgaWYgKGNvbXBhcmUodmFsdWUsIGFycmF5W3N0YXJ0ICsgbV0pIDwgMCkge1xuICAgICAgICAgICAgICAgIG9mZnNldCA9IG07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsYXN0T2Zmc2V0ID0gbSArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb2Zmc2V0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIFRpbVNvcnQoYXJyYXksIGNvbXBhcmUpIHtcbiAgICAgICAgdmFyIG1pbkdhbGxvcCA9IERFRkFVTFRfTUlOX0dBTExPUElORztcbiAgICAgICAgdmFyIGxlbmd0aCA9IDA7XG4gICAgICAgIHZhciB0bXBTdG9yYWdlTGVuZ3RoID0gREVGQVVMVF9UTVBfU1RPUkFHRV9MRU5HVEg7XG4gICAgICAgIHZhciBzdGFja0xlbmd0aCA9IDA7XG4gICAgICAgIHZhciBydW5TdGFydDtcbiAgICAgICAgdmFyIHJ1bkxlbmd0aDtcbiAgICAgICAgdmFyIHN0YWNrU2l6ZSA9IDA7XG5cbiAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gICAgICAgIGlmIChsZW5ndGggPCAyICogREVGQVVMVF9UTVBfU1RPUkFHRV9MRU5HVEgpIHtcbiAgICAgICAgICAgIHRtcFN0b3JhZ2VMZW5ndGggPSBsZW5ndGggPj4+IDE7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdG1wID0gW107XG5cbiAgICAgICAgc3RhY2tMZW5ndGggPSBsZW5ndGggPCAxMjAgPyA1IDogbGVuZ3RoIDwgMTU0MiA/IDEwIDogbGVuZ3RoIDwgMTE5MTUxID8gMTkgOiA0MDtcblxuICAgICAgICBydW5TdGFydCA9IFtdO1xuICAgICAgICBydW5MZW5ndGggPSBbXTtcblxuICAgICAgICBmdW5jdGlvbiBwdXNoUnVuKF9ydW5TdGFydCwgX3J1bkxlbmd0aCkge1xuICAgICAgICAgICAgcnVuU3RhcnRbc3RhY2tTaXplXSA9IF9ydW5TdGFydDtcbiAgICAgICAgICAgIHJ1bkxlbmd0aFtzdGFja1NpemVdID0gX3J1bkxlbmd0aDtcbiAgICAgICAgICAgIHN0YWNrU2l6ZSArPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gbWVyZ2VSdW5zKCkge1xuICAgICAgICAgICAgd2hpbGUgKHN0YWNrU2l6ZSA+IDEpIHtcbiAgICAgICAgICAgICAgICB2YXIgbiA9IHN0YWNrU2l6ZSAtIDI7XG5cbiAgICAgICAgICAgICAgICBpZiAobiA+PSAxICYmIHJ1bkxlbmd0aFtuIC0gMV0gPD0gcnVuTGVuZ3RoW25dICsgcnVuTGVuZ3RoW24gKyAxXSB8fCBuID49IDIgJiYgcnVuTGVuZ3RoW24gLSAyXSA8PSBydW5MZW5ndGhbbl0gKyBydW5MZW5ndGhbbiAtIDFdKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChydW5MZW5ndGhbbiAtIDFdIDwgcnVuTGVuZ3RoW24gKyAxXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbi0tO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJ1bkxlbmd0aFtuXSA+IHJ1bkxlbmd0aFtuICsgMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG1lcmdlQXQobik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBmb3JjZU1lcmdlUnVucygpIHtcbiAgICAgICAgICAgIHdoaWxlIChzdGFja1NpemUgPiAxKSB7XG4gICAgICAgICAgICAgICAgdmFyIG4gPSBzdGFja1NpemUgLSAyO1xuXG4gICAgICAgICAgICAgICAgaWYgKG4gPiAwICYmIHJ1bkxlbmd0aFtuIC0gMV0gPCBydW5MZW5ndGhbbiArIDFdKSB7XG4gICAgICAgICAgICAgICAgICAgIG4tLTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBtZXJnZUF0KG4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gbWVyZ2VBdChpKSB7XG4gICAgICAgICAgICB2YXIgc3RhcnQxID0gcnVuU3RhcnRbaV07XG4gICAgICAgICAgICB2YXIgbGVuZ3RoMSA9IHJ1bkxlbmd0aFtpXTtcbiAgICAgICAgICAgIHZhciBzdGFydDIgPSBydW5TdGFydFtpICsgMV07XG4gICAgICAgICAgICB2YXIgbGVuZ3RoMiA9IHJ1bkxlbmd0aFtpICsgMV07XG5cbiAgICAgICAgICAgIHJ1bkxlbmd0aFtpXSA9IGxlbmd0aDEgKyBsZW5ndGgyO1xuXG4gICAgICAgICAgICBpZiAoaSA9PT0gc3RhY2tTaXplIC0gMykge1xuICAgICAgICAgICAgICAgIHJ1blN0YXJ0W2kgKyAxXSA9IHJ1blN0YXJ0W2kgKyAyXTtcbiAgICAgICAgICAgICAgICBydW5MZW5ndGhbaSArIDFdID0gcnVuTGVuZ3RoW2kgKyAyXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc3RhY2tTaXplLS07XG5cbiAgICAgICAgICAgIHZhciBrID0gZ2FsbG9wUmlnaHQoYXJyYXlbc3RhcnQyXSwgYXJyYXksIHN0YXJ0MSwgbGVuZ3RoMSwgMCwgY29tcGFyZSk7XG4gICAgICAgICAgICBzdGFydDEgKz0gaztcbiAgICAgICAgICAgIGxlbmd0aDEgLT0gaztcblxuICAgICAgICAgICAgaWYgKGxlbmd0aDEgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxlbmd0aDIgPSBnYWxsb3BMZWZ0KGFycmF5W3N0YXJ0MSArIGxlbmd0aDEgLSAxXSwgYXJyYXksIHN0YXJ0MiwgbGVuZ3RoMiwgbGVuZ3RoMiAtIDEsIGNvbXBhcmUpO1xuXG4gICAgICAgICAgICBpZiAobGVuZ3RoMiA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGxlbmd0aDEgPD0gbGVuZ3RoMikge1xuICAgICAgICAgICAgICAgIG1lcmdlTG93KHN0YXJ0MSwgbGVuZ3RoMSwgc3RhcnQyLCBsZW5ndGgyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG1lcmdlSGlnaChzdGFydDEsIGxlbmd0aDEsIHN0YXJ0MiwgbGVuZ3RoMik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBtZXJnZUxvdyhzdGFydDEsIGxlbmd0aDEsIHN0YXJ0MiwgbGVuZ3RoMikge1xuICAgICAgICAgICAgdmFyIGkgPSAwO1xuXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoMTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdG1wW2ldID0gYXJyYXlbc3RhcnQxICsgaV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBjdXJzb3IxID0gMDtcbiAgICAgICAgICAgIHZhciBjdXJzb3IyID0gc3RhcnQyO1xuICAgICAgICAgICAgdmFyIGRlc3QgPSBzdGFydDE7XG5cbiAgICAgICAgICAgIGFycmF5W2Rlc3QrK10gPSBhcnJheVtjdXJzb3IyKytdO1xuXG4gICAgICAgICAgICBpZiAoLS1sZW5ndGgyID09PSAwKSB7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDE7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBhcnJheVtkZXN0ICsgaV0gPSB0bXBbY3Vyc29yMSArIGldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChsZW5ndGgxID09PSAxKSB7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDI7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBhcnJheVtkZXN0ICsgaV0gPSBhcnJheVtjdXJzb3IyICsgaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFycmF5W2Rlc3QgKyBsZW5ndGgyXSA9IHRtcFtjdXJzb3IxXTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBfbWluR2FsbG9wID0gbWluR2FsbG9wO1xuICAgICAgICAgICAgdmFyIGNvdW50MSwgY291bnQyLCBleGl0O1xuXG4gICAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgICAgIGNvdW50MSA9IDA7XG4gICAgICAgICAgICAgICAgY291bnQyID0gMDtcbiAgICAgICAgICAgICAgICBleGl0ID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb21wYXJlKGFycmF5W2N1cnNvcjJdLCB0bXBbY3Vyc29yMV0pIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJyYXlbZGVzdCsrXSA9IGFycmF5W2N1cnNvcjIrK107XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudDIrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50MSA9IDA7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgtLWxlbmd0aDIgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGl0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFycmF5W2Rlc3QrK10gPSB0bXBbY3Vyc29yMSsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50MSsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY291bnQyID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgtLWxlbmd0aDEgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGl0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gd2hpbGUgKChjb3VudDEgfCBjb3VudDIpIDwgX21pbkdhbGxvcCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoZXhpdCkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50MSA9IGdhbGxvcFJpZ2h0KGFycmF5W2N1cnNvcjJdLCB0bXAsIGN1cnNvcjEsIGxlbmd0aDEsIDAsIGNvbXBhcmUpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb3VudDEgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb3VudDE7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFycmF5W2Rlc3QgKyBpXSA9IHRtcFtjdXJzb3IxICsgaV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGRlc3QgKz0gY291bnQxO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3Vyc29yMSArPSBjb3VudDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZW5ndGgxIC09IGNvdW50MTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsZW5ndGgxIDw9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGl0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGFycmF5W2Rlc3QrK10gPSBhcnJheVtjdXJzb3IyKytdO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICgtLWxlbmd0aDIgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4aXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBjb3VudDIgPSBnYWxsb3BMZWZ0KHRtcFtjdXJzb3IxXSwgYXJyYXksIGN1cnNvcjIsIGxlbmd0aDIsIDAsIGNvbXBhcmUpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb3VudDIgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb3VudDI7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFycmF5W2Rlc3QgKyBpXSA9IGFycmF5W2N1cnNvcjIgKyBpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgZGVzdCArPSBjb3VudDI7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3IyICs9IGNvdW50MjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlbmd0aDIgLT0gY291bnQyO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobGVuZ3RoMiA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4aXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGFycmF5W2Rlc3QrK10gPSB0bXBbY3Vyc29yMSsrXTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoLS1sZW5ndGgxID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBleGl0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgX21pbkdhbGxvcC0tO1xuICAgICAgICAgICAgICAgIH0gd2hpbGUgKGNvdW50MSA+PSBERUZBVUxUX01JTl9HQUxMT1BJTkcgfHwgY291bnQyID49IERFRkFVTFRfTUlOX0dBTExPUElORyk7XG5cbiAgICAgICAgICAgICAgICBpZiAoZXhpdCkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoX21pbkdhbGxvcCA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgX21pbkdhbGxvcCA9IDA7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgX21pbkdhbGxvcCArPSAyO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtaW5HYWxsb3AgPSBfbWluR2FsbG9wO1xuXG4gICAgICAgICAgICBtaW5HYWxsb3AgPCAxICYmIChtaW5HYWxsb3AgPSAxKTtcblxuICAgICAgICAgICAgaWYgKGxlbmd0aDEgPT09IDEpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoMjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGFycmF5W2Rlc3QgKyBpXSA9IGFycmF5W2N1cnNvcjIgKyBpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYXJyYXlbZGVzdCArIGxlbmd0aDJdID0gdG1wW2N1cnNvcjFdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobGVuZ3RoMSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigpO1xuICAgICAgICAgICAgICAgIC8vIHRocm93IG5ldyBFcnJvcignbWVyZ2VMb3cgcHJlY29uZGl0aW9ucyB3ZXJlIG5vdCByZXNwZWN0ZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGgxOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgYXJyYXlbZGVzdCArIGldID0gdG1wW2N1cnNvcjEgKyBpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBtZXJnZUhpZ2ggKHN0YXJ0MSwgbGVuZ3RoMSwgc3RhcnQyLCBsZW5ndGgyKSB7XG4gICAgICAgICAgICB2YXIgaSA9IDA7XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGgyOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0bXBbaV0gPSBhcnJheVtzdGFydDIgKyBpXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGN1cnNvcjEgPSBzdGFydDEgKyBsZW5ndGgxIC0gMTtcbiAgICAgICAgICAgIHZhciBjdXJzb3IyID0gbGVuZ3RoMiAtIDE7XG4gICAgICAgICAgICB2YXIgZGVzdCA9IHN0YXJ0MiArIGxlbmd0aDIgLSAxO1xuICAgICAgICAgICAgdmFyIGN1c3RvbUN1cnNvciA9IDA7XG4gICAgICAgICAgICB2YXIgY3VzdG9tRGVzdCA9IDA7XG5cbiAgICAgICAgICAgIGFycmF5W2Rlc3QtLV0gPSBhcnJheVtjdXJzb3IxLS1dO1xuXG4gICAgICAgICAgICBpZiAoLS1sZW5ndGgxID09PSAwKSB7XG4gICAgICAgICAgICAgICAgY3VzdG9tQ3Vyc29yID0gZGVzdCAtIChsZW5ndGgyIC0gMSk7XG5cbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoMjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGFycmF5W2N1c3RvbUN1cnNvciArIGldID0gdG1wW2ldO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGxlbmd0aDIgPT09IDEpIHtcbiAgICAgICAgICAgICAgICBkZXN0IC09IGxlbmd0aDE7XG4gICAgICAgICAgICAgICAgY3Vyc29yMSAtPSBsZW5ndGgxO1xuICAgICAgICAgICAgICAgIGN1c3RvbURlc3QgPSBkZXN0ICsgMTtcbiAgICAgICAgICAgICAgICBjdXN0b21DdXJzb3IgPSBjdXJzb3IxICsgMTtcblxuICAgICAgICAgICAgICAgIGZvciAoaSA9IGxlbmd0aDEgLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgICAgICBhcnJheVtjdXN0b21EZXN0ICsgaV0gPSBhcnJheVtjdXN0b21DdXJzb3IgKyBpXTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBhcnJheVtkZXN0XSA9IHRtcFtjdXJzb3IyXTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBfbWluR2FsbG9wID0gbWluR2FsbG9wO1xuXG4gICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgICAgIHZhciBjb3VudDEgPSAwO1xuICAgICAgICAgICAgICAgIHZhciBjb3VudDIgPSAwO1xuICAgICAgICAgICAgICAgIHZhciBleGl0ID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb21wYXJlKHRtcFtjdXJzb3IyXSwgYXJyYXlbY3Vyc29yMV0pIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJyYXlbZGVzdC0tXSA9IGFycmF5W2N1cnNvcjEtLV07XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudDErKztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50MiA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoLS1sZW5ndGgxID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhpdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcnJheVtkZXN0LS1dID0gdG1wW2N1cnNvcjItLV07XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudDIrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50MSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoLS1sZW5ndGgyID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhpdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IHdoaWxlICgoY291bnQxIHwgY291bnQyKSA8IF9taW5HYWxsb3ApO1xuXG4gICAgICAgICAgICAgICAgaWYgKGV4aXQpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICBjb3VudDEgPSBsZW5ndGgxIC0gZ2FsbG9wUmlnaHQodG1wW2N1cnNvcjJdLCBhcnJheSwgc3RhcnQxLCBsZW5ndGgxLCBsZW5ndGgxIC0gMSwgY29tcGFyZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvdW50MSAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVzdCAtPSBjb3VudDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3IxIC09IGNvdW50MTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlbmd0aDEgLT0gY291bnQxO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VzdG9tRGVzdCA9IGRlc3QgKyAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VzdG9tQ3Vyc29yID0gY3Vyc29yMSArIDE7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IGNvdW50MSAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJyYXlbY3VzdG9tRGVzdCArIGldID0gYXJyYXlbY3VzdG9tQ3Vyc29yICsgaV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsZW5ndGgxID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhpdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBhcnJheVtkZXN0LS1dID0gdG1wW2N1cnNvcjItLV07XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKC0tbGVuZ3RoMiA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXhpdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGNvdW50MiA9IGxlbmd0aDIgLSBnYWxsb3BMZWZ0KGFycmF5W2N1cnNvcjFdLCB0bXAsIDAsIGxlbmd0aDIsIGxlbmd0aDIgLSAxLCBjb21wYXJlKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoY291bnQyICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZXN0IC09IGNvdW50MjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvcjIgLT0gY291bnQyO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVuZ3RoMiAtPSBjb3VudDI7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXN0b21EZXN0ID0gZGVzdCArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXN0b21DdXJzb3IgPSBjdXJzb3IyICsgMTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGNvdW50MjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJyYXlbY3VzdG9tRGVzdCArIGldID0gdG1wW2N1c3RvbUN1cnNvciArIGldO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobGVuZ3RoMiA8PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhpdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBhcnJheVtkZXN0LS1dID0gYXJyYXlbY3Vyc29yMS0tXTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoLS1sZW5ndGgxID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBleGl0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgX21pbkdhbGxvcC0tO1xuICAgICAgICAgICAgICAgIH0gd2hpbGUgKGNvdW50MSA+PSBERUZBVUxUX01JTl9HQUxMT1BJTkcgfHwgY291bnQyID49IERFRkFVTFRfTUlOX0dBTExPUElORyk7XG5cbiAgICAgICAgICAgICAgICBpZiAoZXhpdCkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoX21pbkdhbGxvcCA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgX21pbkdhbGxvcCA9IDA7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgX21pbkdhbGxvcCArPSAyO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtaW5HYWxsb3AgPSBfbWluR2FsbG9wO1xuXG4gICAgICAgICAgICBpZiAobWluR2FsbG9wIDwgMSkge1xuICAgICAgICAgICAgICAgIG1pbkdhbGxvcCA9IDE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChsZW5ndGgyID09PSAxKSB7XG4gICAgICAgICAgICAgICAgZGVzdCAtPSBsZW5ndGgxO1xuICAgICAgICAgICAgICAgIGN1cnNvcjEgLT0gbGVuZ3RoMTtcbiAgICAgICAgICAgICAgICBjdXN0b21EZXN0ID0gZGVzdCArIDE7XG4gICAgICAgICAgICAgICAgY3VzdG9tQ3Vyc29yID0gY3Vyc29yMSArIDE7XG5cbiAgICAgICAgICAgICAgICBmb3IgKGkgPSBsZW5ndGgxIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgYXJyYXlbY3VzdG9tRGVzdCArIGldID0gYXJyYXlbY3VzdG9tQ3Vyc29yICsgaV07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYXJyYXlbZGVzdF0gPSB0bXBbY3Vyc29yMl07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChsZW5ndGgyID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCk7XG4gICAgICAgICAgICAgICAgLy8gdGhyb3cgbmV3IEVycm9yKCdtZXJnZUhpZ2ggcHJlY29uZGl0aW9ucyB3ZXJlIG5vdCByZXNwZWN0ZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGN1c3RvbUN1cnNvciA9IGRlc3QgLSAobGVuZ3RoMiAtIDEpO1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGgyOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgYXJyYXlbY3VzdG9tQ3Vyc29yICsgaV0gPSB0bXBbaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5tZXJnZVJ1bnMgPSBtZXJnZVJ1bnM7XG4gICAgICAgIHRoaXMuZm9yY2VNZXJnZVJ1bnMgPSBmb3JjZU1lcmdlUnVucztcbiAgICAgICAgdGhpcy5wdXNoUnVuID0gcHVzaFJ1bjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzb3J0KGFycmF5LCBjb21wYXJlLCBsbywgaGkpIHtcbiAgICAgICAgaWYgKCFsbykge1xuICAgICAgICAgICAgbG8gPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaGkpIHtcbiAgICAgICAgICAgIGhpID0gYXJyYXkubGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlbWFpbmluZyA9IGhpIC0gbG87XG5cbiAgICAgICAgaWYgKHJlbWFpbmluZyA8IDIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBydW5MZW5ndGggPSAwO1xuXG4gICAgICAgIGlmIChyZW1haW5pbmcgPCBERUZBVUxUX01JTl9NRVJHRSkge1xuICAgICAgICAgICAgcnVuTGVuZ3RoID0gbWFrZUFzY2VuZGluZ1J1bihhcnJheSwgbG8sIGhpLCBjb21wYXJlKTtcbiAgICAgICAgICAgIGJpbmFyeUluc2VydGlvblNvcnQoYXJyYXksIGxvLCBoaSwgbG8gKyBydW5MZW5ndGgsIGNvbXBhcmUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRzID0gbmV3IFRpbVNvcnQoYXJyYXksIGNvbXBhcmUpO1xuXG4gICAgICAgIHZhciBtaW5SdW4gPSBtaW5SdW5MZW5ndGgocmVtYWluaW5nKTtcblxuICAgICAgICBkbyB7XG4gICAgICAgICAgICBydW5MZW5ndGggPSBtYWtlQXNjZW5kaW5nUnVuKGFycmF5LCBsbywgaGksIGNvbXBhcmUpO1xuICAgICAgICAgICAgaWYgKHJ1bkxlbmd0aCA8IG1pblJ1bikge1xuICAgICAgICAgICAgICAgIHZhciBmb3JjZSA9IHJlbWFpbmluZztcbiAgICAgICAgICAgICAgICBpZiAoZm9yY2UgPiBtaW5SdW4pIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yY2UgPSBtaW5SdW47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYmluYXJ5SW5zZXJ0aW9uU29ydChhcnJheSwgbG8sIGxvICsgZm9yY2UsIGxvICsgcnVuTGVuZ3RoLCBjb21wYXJlKTtcbiAgICAgICAgICAgICAgICBydW5MZW5ndGggPSBmb3JjZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdHMucHVzaFJ1bihsbywgcnVuTGVuZ3RoKTtcbiAgICAgICAgICAgIHRzLm1lcmdlUnVucygpO1xuXG4gICAgICAgICAgICByZW1haW5pbmcgLT0gcnVuTGVuZ3RoO1xuICAgICAgICAgICAgbG8gKz0gcnVuTGVuZ3RoO1xuICAgICAgICB9IHdoaWxlIChyZW1haW5pbmcgIT09IDApO1xuXG4gICAgICAgIHRzLmZvcmNlTWVyZ2VSdW5zKCk7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBzb3J0O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34venJlbmRlci9saWIvY29yZS90aW1zb3J0LmpzXG4gKiogbW9kdWxlIGlkID0gNjdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0Jztcbi8qKlxuICog5Yqo55S75Li757G7LCDosIPluqblkoznrqHnkIbmiYDmnInliqjnlLvmjqfliLblmahcbiAqXG4gKiBAbW9kdWxlIHpyZW5kZXIvYW5pbWF0aW9uL0FuaW1hdGlvblxuICogQGF1dGhvciBwaXNzYW5nKGh0dHBzOi8vZ2l0aHViLmNvbS9waXNzYW5nKVxuICovXG4vLyBUT0RPIEFkZGl0aXZlIGFuaW1hdGlvblxuLy8gaHR0cDovL2lvc290ZXJpYy5jb20vYWRkaXRpdmUtYW5pbWF0aW9ucy1hbmltYXRld2l0aGR1cmF0aW9uLWluLWlvcy04L1xuLy8gaHR0cHM6Ly9kZXZlbG9wZXIuYXBwbGUuY29tL3ZpZGVvcy93d2RjMjAxNC8jMjM2XG5cblxuICAgIHZhciB1dGlsID0gcmVxdWlyZSgnLi4vY29yZS91dGlsJyk7XG4gICAgdmFyIERpc3BhdGNoZXIgPSByZXF1aXJlKCcuLi9jb3JlL2V2ZW50JykuRGlzcGF0Y2hlcjtcblxuICAgIHZhciByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSByZXF1aXJlKCcuL3JlcXVlc3RBbmltYXRpb25GcmFtZScpO1xuXG4gICAgdmFyIEFuaW1hdG9yID0gcmVxdWlyZSgnLi9BbmltYXRvcicpO1xuICAgIC8qKlxuICAgICAqIEB0eXBlZGVmIHtPYmplY3R9IElaUmVuZGVyU3RhZ2VcbiAgICAgKiBAcHJvcGVydHkge0Z1bmN0aW9ufSB1cGRhdGVcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEBhbGlhcyBtb2R1bGU6enJlbmRlci9hbmltYXRpb24vQW5pbWF0aW9uXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLm9uZnJhbWVdXG4gICAgICogQHBhcmFtIHtJWlJlbmRlclN0YWdlfSBbb3B0aW9ucy5zdGFnZV1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqICAgICB2YXIgYW5pbWF0aW9uID0gbmV3IEFuaW1hdGlvbigpO1xuICAgICAqICAgICB2YXIgb2JqID0ge1xuICAgICAqICAgICAgICAgeDogMTAwLFxuICAgICAqICAgICAgICAgeTogMTAwXG4gICAgICogICAgIH07XG4gICAgICogICAgIGFuaW1hdGlvbi5hbmltYXRlKG5vZGUucG9zaXRpb24pXG4gICAgICogICAgICAgICAud2hlbigxMDAwLCB7XG4gICAgICogICAgICAgICAgICAgeDogNTAwLFxuICAgICAqICAgICAgICAgICAgIHk6IDUwMFxuICAgICAqICAgICAgICAgfSlcbiAgICAgKiAgICAgICAgIC53aGVuKDIwMDAsIHtcbiAgICAgKiAgICAgICAgICAgICB4OiAxMDAsXG4gICAgICogICAgICAgICAgICAgeTogMTAwXG4gICAgICogICAgICAgICB9KVxuICAgICAqICAgICAgICAgLnN0YXJ0KCdzcGxpbmUnKTtcbiAgICAgKi9cbiAgICB2YXIgQW5pbWF0aW9uID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcblxuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgICAgICB0aGlzLnN0YWdlID0gb3B0aW9ucy5zdGFnZSB8fCB7fTtcblxuICAgICAgICB0aGlzLm9uZnJhbWUgPSBvcHRpb25zLm9uZnJhbWUgfHwgZnVuY3Rpb24oKSB7fTtcblxuICAgICAgICAvLyBwcml2YXRlIHByb3BlcnRpZXNcbiAgICAgICAgdGhpcy5fY2xpcHMgPSBbXTtcblxuICAgICAgICB0aGlzLl9ydW5uaW5nID0gZmFsc2U7XG5cbiAgICAgICAgdGhpcy5fdGltZTtcblxuICAgICAgICB0aGlzLl9wYXVzZWRUaW1lO1xuXG4gICAgICAgIHRoaXMuX3BhdXNlU3RhcnQ7XG5cbiAgICAgICAgdGhpcy5fcGF1c2VkID0gZmFsc2U7XG5cbiAgICAgICAgRGlzcGF0Y2hlci5jYWxsKHRoaXMpO1xuICAgIH07XG5cbiAgICBBbmltYXRpb24ucHJvdG90eXBlID0ge1xuXG4gICAgICAgIGNvbnN0cnVjdG9yOiBBbmltYXRpb24sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmt7vliqAgY2xpcFxuICAgICAgICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL2FuaW1hdGlvbi9DbGlwfSBjbGlwXG4gICAgICAgICAqL1xuICAgICAgICBhZGRDbGlwOiBmdW5jdGlvbiAoY2xpcCkge1xuICAgICAgICAgICAgdGhpcy5fY2xpcHMucHVzaChjbGlwKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOa3u+WKoCBhbmltYXRvclxuICAgICAgICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL2FuaW1hdGlvbi9BbmltYXRvcn0gYW5pbWF0b3JcbiAgICAgICAgICovXG4gICAgICAgIGFkZEFuaW1hdG9yOiBmdW5jdGlvbiAoYW5pbWF0b3IpIHtcbiAgICAgICAgICAgIGFuaW1hdG9yLmFuaW1hdGlvbiA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgY2xpcHMgPSBhbmltYXRvci5nZXRDbGlwcygpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbGlwcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkQ2xpcChjbGlwc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDliKDpmaTliqjnlLvniYfmrrVcbiAgICAgICAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9hbmltYXRpb24vQ2xpcH0gY2xpcFxuICAgICAgICAgKi9cbiAgICAgICAgcmVtb3ZlQ2xpcDogZnVuY3Rpb24oY2xpcCkge1xuICAgICAgICAgICAgdmFyIGlkeCA9IHV0aWwuaW5kZXhPZih0aGlzLl9jbGlwcywgY2xpcCk7XG4gICAgICAgICAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jbGlwcy5zcGxpY2UoaWR4LCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5Yig6Zmk5Yqo55S754mH5q61XG4gICAgICAgICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvYW5pbWF0aW9uL0FuaW1hdG9yfSBhbmltYXRvclxuICAgICAgICAgKi9cbiAgICAgICAgcmVtb3ZlQW5pbWF0b3I6IGZ1bmN0aW9uIChhbmltYXRvcikge1xuICAgICAgICAgICAgdmFyIGNsaXBzID0gYW5pbWF0b3IuZ2V0Q2xpcHMoKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2xpcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZUNsaXAoY2xpcHNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYW5pbWF0b3IuYW5pbWF0aW9uID0gbnVsbDtcbiAgICAgICAgfSxcblxuICAgICAgICBfdXBkYXRlOiBmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgdmFyIHRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKSAtIHRoaXMuX3BhdXNlZFRpbWU7XG4gICAgICAgICAgICB2YXIgZGVsdGEgPSB0aW1lIC0gdGhpcy5fdGltZTtcbiAgICAgICAgICAgIHZhciBjbGlwcyA9IHRoaXMuX2NsaXBzO1xuICAgICAgICAgICAgdmFyIGxlbiA9IGNsaXBzLmxlbmd0aDtcblxuICAgICAgICAgICAgdmFyIGRlZmVycmVkRXZlbnRzID0gW107XG4gICAgICAgICAgICB2YXIgZGVmZXJyZWRDbGlwcyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBjbGlwID0gY2xpcHNbaV07XG4gICAgICAgICAgICAgICAgdmFyIGUgPSBjbGlwLnN0ZXAodGltZSk7XG4gICAgICAgICAgICAgICAgLy8gVGhyb3cgb3V0IHRoZSBldmVudHMgbmVlZCB0byBiZSBjYWxsZWQgYWZ0ZXJcbiAgICAgICAgICAgICAgICAvLyBzdGFnZS51cGRhdGUsIGxpa2UgZGVzdHJveVxuICAgICAgICAgICAgICAgIGlmIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlZmVycmVkRXZlbnRzLnB1c2goZSk7XG4gICAgICAgICAgICAgICAgICAgIGRlZmVycmVkQ2xpcHMucHVzaChjbGlwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgZmluaXNoZWQgY2xpcFxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47KSB7XG4gICAgICAgICAgICAgICAgaWYgKGNsaXBzW2ldLl9uZWVkc1JlbW92ZSkge1xuICAgICAgICAgICAgICAgICAgICBjbGlwc1tpXSA9IGNsaXBzW2xlbiAtIDFdO1xuICAgICAgICAgICAgICAgICAgICBjbGlwcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgbGVuLS07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZW4gPSBkZWZlcnJlZEV2ZW50cy5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZGVmZXJyZWRDbGlwc1tpXS5maXJlKGRlZmVycmVkRXZlbnRzW2ldKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5fdGltZSA9IHRpbWU7XG5cbiAgICAgICAgICAgIHRoaXMub25mcmFtZShkZWx0YSk7XG5cbiAgICAgICAgICAgIHRoaXMudHJpZ2dlcignZnJhbWUnLCBkZWx0YSk7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLnN0YWdlLnVwZGF0ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhZ2UudXBkYXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgX3N0YXJ0TG9vcDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgICAgICB0aGlzLl9ydW5uaW5nID0gdHJ1ZTtcblxuICAgICAgICAgICAgZnVuY3Rpb24gc3RlcCgpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5fcnVubmluZykge1xuXG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShzdGVwKTtcblxuICAgICAgICAgICAgICAgICAgICAhc2VsZi5fcGF1c2VkICYmIHNlbGYuX3VwZGF0ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHN0ZXApO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlvIDlp4vov5DooYzliqjnlLtcbiAgICAgICAgICovXG4gICAgICAgIHN0YXJ0OiBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgIHRoaXMuX3RpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgICAgICAgIHRoaXMuX3BhdXNlZFRpbWUgPSAwO1xuXG4gICAgICAgICAgICB0aGlzLl9zdGFydExvb3AoKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWBnOatoui/kOihjOWKqOeUu1xuICAgICAgICAgKi9cbiAgICAgICAgc3RvcDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5fcnVubmluZyA9IGZhbHNlO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQYXVzZVxuICAgICAgICAgKi9cbiAgICAgICAgcGF1c2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fcGF1c2VkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGF1c2VTdGFydCA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3BhdXNlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlc3VtZVxuICAgICAgICAgKi9cbiAgICAgICAgcmVzdW1lOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fcGF1c2VkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGF1c2VkVGltZSArPSAobmV3IERhdGUoKS5nZXRUaW1lKCkpIC0gdGhpcy5fcGF1c2VTdGFydDtcbiAgICAgICAgICAgICAgICB0aGlzLl9wYXVzZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5riF6Zmk5omA5pyJ5Yqo55S754mH5q61XG4gICAgICAgICAqL1xuICAgICAgICBjbGVhcjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5fY2xpcHMgPSBbXTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWvueS4gOS4quebruagh+WIm+W7uuS4gOS4qmFuaW1hdG9y5a+56LGh77yM5Y+v5Lul5oyH5a6a55uu5qCH5Lit55qE5bGe5oCn5L2/55So5Yqo55S7XG4gICAgICAgICAqIEBwYXJhbSAge09iamVjdH0gdGFyZ2V0XG4gICAgICAgICAqIEBwYXJhbSAge09iamVjdH0gb3B0aW9uc1xuICAgICAgICAgKiBAcGFyYW0gIHtib29sZWFufSBbb3B0aW9ucy5sb29wPWZhbHNlXSDmmK/lkKblvqrnjq/mkq3mlL7liqjnlLtcbiAgICAgICAgICogQHBhcmFtICB7RnVuY3Rpb259IFtvcHRpb25zLmdldHRlcj1udWxsXVxuICAgICAgICAgKiAgICAgICAgIOWmguaenOaMh+WummdldHRlcuWHveaVsO+8jOS8mumAmui/h2dldHRlcuWHveaVsOWPluWxnuaAp+WAvFxuICAgICAgICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gW29wdGlvbnMuc2V0dGVyPW51bGxdXG4gICAgICAgICAqICAgICAgICAg5aaC5p6c5oyH5a6ac2V0dGVy5Ye95pWw77yM5Lya6YCa6L+Hc2V0dGVy5Ye95pWw6K6+572u5bGe5oCn5YC8XG4gICAgICAgICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2FuaW1hdGlvbi9BbmltYXRpb25+QW5pbWF0b3J9XG4gICAgICAgICAqL1xuICAgICAgICAvLyBUT0RPIEdhcFxuICAgICAgICBhbmltYXRlOiBmdW5jdGlvbiAodGFyZ2V0LCBvcHRpb25zKSB7XG4gICAgICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgICAgICAgIHZhciBhbmltYXRvciA9IG5ldyBBbmltYXRvcihcbiAgICAgICAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5sb29wLFxuICAgICAgICAgICAgICAgIG9wdGlvbnMuZ2V0dGVyLFxuICAgICAgICAgICAgICAgIG9wdGlvbnMuc2V0dGVyXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICByZXR1cm4gYW5pbWF0b3I7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdXRpbC5taXhpbihBbmltYXRpb24sIERpc3BhdGNoZXIpO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBBbmltYXRpb247XG5cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3pyZW5kZXIvbGliL2FuaW1hdGlvbi9BbmltYXRpb24uanNcbiAqKiBtb2R1bGUgaWQgPSA2OFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuLyoqXG4gKiDkuovku7bovoXliqnnsbtcbiAqIEBtb2R1bGUgenJlbmRlci9jb3JlL2V2ZW50XG4gKiBAYXV0aG9yIEtlbmVyIChAS2VuZXIt5p6X5bOwLCBrZW5lci5saW5mZW5nQGdtYWlsLmNvbSlcbiAqL1xuXG5cbiAgICB2YXIgRXZlbnRmdWwgPSByZXF1aXJlKCcuLi9taXhpbi9FdmVudGZ1bCcpO1xuXG4gICAgdmFyIGlzRG9tTGV2ZWwyID0gKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSAmJiAhIXdpbmRvdy5hZGRFdmVudExpc3RlbmVyO1xuXG4gICAgZnVuY3Rpb24gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGVsKSB7XG4gICAgICAgIC8vIEJsYWNrQmVycnkgNSwgaU9TIDMgKG9yaWdpbmFsIGlQaG9uZSkgZG9uJ3QgaGF2ZSBnZXRCb3VuZGluZ1JlY3RcbiAgICAgICAgcmV0dXJuIGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCA/IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpIDoge2xlZnQ6IDAsIHRvcDogMH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xpZW50VG9Mb2NhbChlbCwgZSwgb3V0KSB7XG4gICAgICAgIC8vIGNsaWVudFgvY2xpZW50WSBpcyBhY2NvcmRpbmcgdG8gdmlldyBwb3J0LlxuICAgICAgICB2YXIgYm94ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGVsKTtcbiAgICAgICAgb3V0ID0gb3V0IHx8IHt9O1xuICAgICAgICBvdXQuenJYID0gZS5jbGllbnRYIC0gYm94LmxlZnQ7XG4gICAgICAgIG91dC56clkgPSBlLmNsaWVudFkgLSBib3gudG9wO1xuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOWmguaenOWtmOWcqOesrOS4ieaWueW1jOWFpeeahOS4gOS6m2RvbeinpuWPkeeahOS6i+S7tu+8jOaIlnRvdWNo5LqL5Lu277yM6ZyA6KaB6L2s5o2i5LiA5LiL5LqL5Lu25Z2Q5qCHXG4gICAgICovXG4gICAgZnVuY3Rpb24gbm9ybWFsaXplRXZlbnQoZWwsIGUpIHtcblxuICAgICAgICBlID0gZSB8fCB3aW5kb3cuZXZlbnQ7XG5cbiAgICAgICAgaWYgKGUuenJYICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGV2ZW50VHlwZSA9IGUudHlwZTtcbiAgICAgICAgdmFyIGlzVG91Y2ggPSBldmVudFR5cGUgJiYgZXZlbnRUeXBlLmluZGV4T2YoJ3RvdWNoJykgPj0gMDtcblxuICAgICAgICBpZiAoIWlzVG91Y2gpIHtcbiAgICAgICAgICAgIGNsaWVudFRvTG9jYWwoZWwsIGUsIGUpO1xuICAgICAgICAgICAgZS56ckRlbHRhID0gKGUud2hlZWxEZWx0YSkgPyBlLndoZWVsRGVsdGEgLyAxMjAgOiAtKGUuZGV0YWlsIHx8IDApIC8gMztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciB0b3VjaCA9IGV2ZW50VHlwZSAhPSAndG91Y2hlbmQnXG4gICAgICAgICAgICAgICAgPyBlLnRhcmdldFRvdWNoZXNbMF1cbiAgICAgICAgICAgICAgICA6IGUuY2hhbmdlZFRvdWNoZXNbMF07XG4gICAgICAgICAgICB0b3VjaCAmJiBjbGllbnRUb0xvY2FsKGVsLCB0b3VjaCwgZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGRFdmVudExpc3RlbmVyKGVsLCBuYW1lLCBoYW5kbGVyKSB7XG4gICAgICAgIGlmIChpc0RvbUxldmVsMikge1xuICAgICAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcihuYW1lLCBoYW5kbGVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVsLmF0dGFjaEV2ZW50KCdvbicgKyBuYW1lLCBoYW5kbGVyKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlbW92ZUV2ZW50TGlzdGVuZXIoZWwsIG5hbWUsIGhhbmRsZXIpIHtcbiAgICAgICAgaWYgKGlzRG9tTGV2ZWwyKSB7XG4gICAgICAgICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKG5hbWUsIGhhbmRsZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZWwuZGV0YWNoRXZlbnQoJ29uJyArIG5hbWUsIGhhbmRsZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog5YGc5q2i5YaS5rOh5ZKM6Zi75q2i6buY6K6k6KGM5Li6XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvZXZlbnRcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQHBhcmFtIHtFdmVudH0gZSA6IGV2ZW505a+56LGhXG4gICAgICovXG4gICAgdmFyIHN0b3AgPSBpc0RvbUxldmVsMlxuICAgICAgICA/IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgZS5jYW5jZWxCdWJibGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGUucmV0dXJuVmFsdWUgPSBmYWxzZTtcbiAgICAgICAgICAgIGUuY2FuY2VsQnViYmxlID0gdHJ1ZTtcbiAgICAgICAgfTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0ge1xuICAgICAgICBjbGllbnRUb0xvY2FsOiBjbGllbnRUb0xvY2FsLFxuICAgICAgICBub3JtYWxpemVFdmVudDogbm9ybWFsaXplRXZlbnQsXG4gICAgICAgIGFkZEV2ZW50TGlzdGVuZXI6IGFkZEV2ZW50TGlzdGVuZXIsXG4gICAgICAgIHJlbW92ZUV2ZW50TGlzdGVuZXI6IHJlbW92ZUV2ZW50TGlzdGVuZXIsXG5cbiAgICAgICAgc3RvcDogc3RvcCxcbiAgICAgICAgLy8g5YGa5ZCR5LiK5YW85a65XG4gICAgICAgIERpc3BhdGNoZXI6IEV2ZW50ZnVsXG4gICAgfTtcblxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34venJlbmRlci9saWIvY29yZS9ldmVudC5qc1xuICoqIG1vZHVsZSBpZCA9IDY5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcblxuICAgIG1vZHVsZS5leHBvcnRzID0gKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAod2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfHwgd2luZG93Lm1zUmVxdWVzdEFuaW1hdGlvbkZyYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8fCB3aW5kb3cubW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8fCB3aW5kb3cud2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfHwgZnVuY3Rpb24gKGZ1bmMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuYywgMTYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi96cmVuZGVyL2xpYi9hbmltYXRpb24vcmVxdWVzdEFuaW1hdGlvbkZyYW1lLmpzXG4gKiogbW9kdWxlIGlkID0gNzBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlxuXG4gICAgdmFyIGV2ZW50VG9vbCA9IHJlcXVpcmUoJy4uL2NvcmUvZXZlbnQnKTtcbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnLi4vY29yZS91dGlsJyk7XG4gICAgdmFyIEV2ZW50ZnVsID0gcmVxdWlyZSgnLi4vbWl4aW4vRXZlbnRmdWwnKTtcbiAgICB2YXIgZW52ID0gcmVxdWlyZSgnLi4vY29yZS9lbnYnKTtcbiAgICB2YXIgR2VzdHVyZU1nciA9IHJlcXVpcmUoJy4uL2NvcmUvR2VzdHVyZU1ncicpO1xuXG4gICAgdmFyIGFkZEV2ZW50TGlzdGVuZXIgPSBldmVudFRvb2wuYWRkRXZlbnRMaXN0ZW5lcjtcbiAgICB2YXIgcmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGV2ZW50VG9vbC5yZW1vdmVFdmVudExpc3RlbmVyO1xuICAgIHZhciBub3JtYWxpemVFdmVudCA9IGV2ZW50VG9vbC5ub3JtYWxpemVFdmVudDtcblxuICAgIHZhciBUT1VDSF9DTElDS19ERUxBWSA9IDMwMDtcblxuICAgIHZhciBtb3VzZUhhbmRsZXJOYW1lcyA9IFtcbiAgICAgICAgJ2NsaWNrJywgJ2RibGNsaWNrJywgJ21vdXNld2hlZWwnLCAnbW91c2VvdXQnLFxuICAgICAgICAnbW91c2V1cCcsICdtb3VzZWRvd24nLCAnbW91c2Vtb3ZlJ1xuICAgIF07XG5cbiAgICB2YXIgdG91Y2hIYW5kbGVyTmFtZXMgPSBbXG4gICAgICAgICd0b3VjaHN0YXJ0JywgJ3RvdWNoZW5kJywgJ3RvdWNobW92ZSdcbiAgICBdO1xuXG4gICAgZnVuY3Rpb24gZXZlbnROYW1lRml4KG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIChuYW1lID09PSAnbW91c2V3aGVlbCcgJiYgZW52LmJyb3dzZXIuZmlyZWZveCkgPyAnRE9NTW91c2VTY3JvbGwnIDogbmFtZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcm9jZXNzR2VzdHVyZShwcm94eSwgZXZlbnQsIHN0YWdlKSB7XG4gICAgICAgIHZhciBnZXN0dXJlTWdyID0gcHJveHkuX2dlc3R1cmVNZ3I7XG5cbiAgICAgICAgc3RhZ2UgPT09ICdzdGFydCcgJiYgZ2VzdHVyZU1nci5jbGVhcigpO1xuXG4gICAgICAgIHZhciBnZXN0dXJlSW5mbyA9IGdlc3R1cmVNZ3IucmVjb2duaXplKFxuICAgICAgICAgICAgZXZlbnQsXG4gICAgICAgICAgICBwcm94eS5oYW5kbGVyLmZpbmRIb3ZlcihldmVudC56clgsIGV2ZW50LnpyWSwgbnVsbCksXG4gICAgICAgICAgICBwcm94eS5kb21cbiAgICAgICAgKTtcblxuICAgICAgICBzdGFnZSA9PT0gJ2VuZCcgJiYgZ2VzdHVyZU1nci5jbGVhcigpO1xuXG4gICAgICAgIGlmIChnZXN0dXJlSW5mbykge1xuICAgICAgICAgICAgLy8gZXZlbnRUb29sLnN0b3AoZXZlbnQpO1xuICAgICAgICAgICAgdmFyIHR5cGUgPSBnZXN0dXJlSW5mby50eXBlO1xuICAgICAgICAgICAgZXZlbnQuZ2VzdHVyZUV2ZW50ID0gdHlwZTtcblxuICAgICAgICAgICAgcHJveHkuaGFuZGxlci5kaXNwYXRjaFRvRWxlbWVudChnZXN0dXJlSW5mby50YXJnZXQsIHR5cGUsIGdlc3R1cmVJbmZvLmV2ZW50KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFByZXZlbnQgbW91c2UgZXZlbnQgZnJvbSBiZWluZyBkaXNwYXRjaGVkIGFmdGVyIFRvdWNoIEV2ZW50cyBhY3Rpb25cbiAgICAgKiBAc2VlIDxodHRwczovL2dpdGh1Yi5jb20vZGVsdGFrb3NoL2hhbmRqcy9ibG9iL21hc3Rlci9zcmMvaGFuZC5iYXNlLmpzPlxuICAgICAqIDEuIE1vYmlsZSBicm93c2VycyBkaXNwYXRjaCBtb3VzZSBldmVudHMgMzAwbXMgYWZ0ZXIgdG91Y2hlbmQuXG4gICAgICogMi4gQ2hyb21lIGZvciBBbmRyb2lkIGRpc3BhdGNoIG1vdXNlZG93biBmb3IgbG9uZy10b3VjaCBhYm91dCA2NTBtc1xuICAgICAqIFJlc3VsdDogQmxvY2tpbmcgTW91c2UgRXZlbnRzIGZvciA3MDBtcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzZXRUb3VjaFRpbWVyKGluc3RhbmNlKSB7XG4gICAgICAgIGluc3RhbmNlLl90b3VjaGluZyA9IHRydWU7XG4gICAgICAgIGNsZWFyVGltZW91dChpbnN0YW5jZS5fdG91Y2hUaW1lcik7XG4gICAgICAgIGluc3RhbmNlLl90b3VjaFRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpbnN0YW5jZS5fdG91Y2hpbmcgPSBmYWxzZTtcbiAgICAgICAgfSwgNzAwKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1c2VUb3VjaEV2ZW50KCkge1xuICAgICAgICByZXR1cm4gZW52LnRvdWNoRXZlbnRzU3VwcG9ydGVkO1xuICAgIH1cblxuICAgIHZhciBkb21IYW5kbGVycyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1vdXNlIG1vdmUgaGFuZGxlclxuICAgICAgICAgKiBAaW5uZXJcbiAgICAgICAgICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAgICAgICAgICovXG4gICAgICAgIG1vdXNlbW92ZTogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICBldmVudCA9IG5vcm1hbGl6ZUV2ZW50KHRoaXMuZG9tLCBldmVudCk7XG5cbiAgICAgICAgICAgIHRoaXMudHJpZ2dlcignbW91c2Vtb3ZlJywgZXZlbnQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNb3VzZSBvdXQgaGFuZGxlclxuICAgICAgICAgKiBAaW5uZXJcbiAgICAgICAgICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAgICAgICAgICovXG4gICAgICAgIG1vdXNlb3V0OiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIGV2ZW50ID0gbm9ybWFsaXplRXZlbnQodGhpcy5kb20sIGV2ZW50KTtcblxuICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSBldmVudC50b0VsZW1lbnQgfHwgZXZlbnQucmVsYXRlZFRhcmdldDtcbiAgICAgICAgICAgIGlmIChlbGVtZW50ICE9IHRoaXMuZG9tKSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGVsZW1lbnQgJiYgZWxlbWVudC5ub2RlVHlwZSAhPSA5KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIOW/veeVpeWMheWQq+WcqHJvb3TkuK3nmoRkb23lvJXotbfnmoRtb3VzZU91dFxuICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbWVudCA9PT0gdGhpcy5kb20pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQgPSBlbGVtZW50LnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnRyaWdnZXIoJ21vdXNlb3V0JywgZXZlbnQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUb3VjaOW8gOWni+WTjeW6lOWHveaVsFxuICAgICAgICAgKiBAaW5uZXJcbiAgICAgICAgICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAgICAgICAgICovXG4gICAgICAgIHRvdWNoc3RhcnQ6IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgLy8gRGVmYXVsdCBtb3VzZSBiZWhhdmlvdXIgc2hvdWxkIG5vdCBiZSBkaXNhYmxlZCBoZXJlLlxuICAgICAgICAgICAgLy8gRm9yIGV4YW1wbGUsIHBhZ2UgbWF5IG5lZWRzIHRvIGJlIHNsaWRlZC5cblxuICAgICAgICAgICAgZXZlbnQgPSBub3JtYWxpemVFdmVudCh0aGlzLmRvbSwgZXZlbnQpO1xuXG4gICAgICAgICAgICB0aGlzLl9sYXN0VG91Y2hNb21lbnQgPSBuZXcgRGF0ZSgpO1xuXG4gICAgICAgICAgICBwcm9jZXNzR2VzdHVyZSh0aGlzLCBldmVudCwgJ3N0YXJ0Jyk7XG5cbiAgICAgICAgICAgIC8vIOW5s+adv+ihpeWFheS4gOasoWZpbmRIb3ZlclxuICAgICAgICAgICAgLy8gdGhpcy5fbW9iaWxlRmluZEZpeGVkKGV2ZW50KTtcbiAgICAgICAgICAgIC8vIFRyaWdnZXIgbW91c2Vtb3ZlIGFuZCBtb3VzZWRvd25cbiAgICAgICAgICAgIGRvbUhhbmRsZXJzLm1vdXNlbW92ZS5jYWxsKHRoaXMsIGV2ZW50KTtcblxuICAgICAgICAgICAgZG9tSGFuZGxlcnMubW91c2Vkb3duLmNhbGwodGhpcywgZXZlbnQpO1xuXG4gICAgICAgICAgICBzZXRUb3VjaFRpbWVyKHRoaXMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUb3VjaOenu+WKqOWTjeW6lOWHveaVsFxuICAgICAgICAgKiBAaW5uZXJcbiAgICAgICAgICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAgICAgICAgICovXG4gICAgICAgIHRvdWNobW92ZTogZnVuY3Rpb24gKGV2ZW50KSB7XG5cbiAgICAgICAgICAgIGV2ZW50ID0gbm9ybWFsaXplRXZlbnQodGhpcy5kb20sIGV2ZW50KTtcblxuICAgICAgICAgICAgcHJvY2Vzc0dlc3R1cmUodGhpcywgZXZlbnQsICdjaGFuZ2UnKTtcblxuICAgICAgICAgICAgLy8gTW91c2UgbW92ZSBzaG91bGQgYWx3YXlzIGJlIHRyaWdnZXJlZCBubyBtYXR0ZXIgd2hldGhlclxuICAgICAgICAgICAgLy8gdGhlcmUgaXMgZ2VzdHJ1ZSBldmVudCwgYmVjYXVzZSBtb3VzZSBtb3ZlIGFuZCBwaW5jaCBtYXlcbiAgICAgICAgICAgIC8vIGJlIHVzZWQgYXQgdGhlIHNhbWUgdGltZS5cbiAgICAgICAgICAgIGRvbUhhbmRsZXJzLm1vdXNlbW92ZS5jYWxsKHRoaXMsIGV2ZW50KTtcblxuICAgICAgICAgICAgc2V0VG91Y2hUaW1lcih0aGlzKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVG91Y2jnu5PmnZ/lk43lupTlh73mlbBcbiAgICAgICAgICogQGlubmVyXG4gICAgICAgICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gICAgICAgICAqL1xuICAgICAgICB0b3VjaGVuZDogZnVuY3Rpb24gKGV2ZW50KSB7XG5cbiAgICAgICAgICAgIGV2ZW50ID0gbm9ybWFsaXplRXZlbnQodGhpcy5kb20sIGV2ZW50KTtcblxuICAgICAgICAgICAgcHJvY2Vzc0dlc3R1cmUodGhpcywgZXZlbnQsICdlbmQnKTtcblxuICAgICAgICAgICAgZG9tSGFuZGxlcnMubW91c2V1cC5jYWxsKHRoaXMsIGV2ZW50KTtcblxuICAgICAgICAgICAgLy8gY2xpY2sgZXZlbnQgc2hvdWxkIGFsd2F5cyBiZSB0cmlnZ2VyZWQgbm8gbWF0dGVyIHdoZXRoZXJcbiAgICAgICAgICAgIC8vIHRoZXJlIGlzIGdlc3RydWUgZXZlbnQuIFN5c3RlbSBjbGljayBjYW4gbm90IGJlIHByZXZlbnRlZC5cbiAgICAgICAgICAgIGlmICgrbmV3IERhdGUoKSAtIHRoaXMuX2xhc3RUb3VjaE1vbWVudCA8IFRPVUNIX0NMSUNLX0RFTEFZKSB7XG4gICAgICAgICAgICAgICAgZG9tSGFuZGxlcnMuY2xpY2suY2FsbCh0aGlzLCBldmVudCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNldFRvdWNoVGltZXIodGhpcyk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gQ29tbW9uIGhhbmRsZXJzXG4gICAgenJVdGlsLmVhY2goWydjbGljaycsICdtb3VzZWRvd24nLCAnbW91c2V1cCcsICdtb3VzZXdoZWVsJywgJ2RibGNsaWNrJ10sIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIGRvbUhhbmRsZXJzW25hbWVdID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICBldmVudCA9IG5vcm1hbGl6ZUV2ZW50KHRoaXMuZG9tLCBldmVudCk7XG4gICAgICAgICAgICB0aGlzLnRyaWdnZXIobmFtZSwgZXZlbnQpO1xuICAgICAgICB9O1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICog5Li65o6n5Yi257G75a6e5L6L5Yid5aeL5YyWZG9tIOS6i+S7tuWkhOeQhuWHveaVsFxuICAgICAqXG4gICAgICogQGlubmVyXG4gICAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9IYW5kbGVyfSBpbnN0YW5jZSDmjqfliLbnsbvlrp7kvotcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbml0RG9tSGFuZGxlcihpbnN0YW5jZSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRvdWNoSGFuZGxlck5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgbmFtZSA9IHRvdWNoSGFuZGxlck5hbWVzW2ldO1xuICAgICAgICAgICAgaW5zdGFuY2UuX2hhbmRsZXJzW25hbWVdID0genJVdGlsLmJpbmQoZG9tSGFuZGxlcnNbbmFtZV0sIGluc3RhbmNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbW91c2VIYW5kbGVyTmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBuYW1lID0gbW91c2VIYW5kbGVyTmFtZXNbaV07XG4gICAgICAgICAgICBpbnN0YW5jZS5faGFuZGxlcnNbbmFtZV0gPSBtYWtlTW91c2VIYW5kbGVyKGRvbUhhbmRsZXJzW25hbWVdLCBpbnN0YW5jZSk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBtYWtlTW91c2VIYW5kbGVyKGZuLCBpbnN0YW5jZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5zdGFuY2UuX3RvdWNoaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZuLmFwcGx5KGluc3RhbmNlLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgZnVuY3Rpb24gSGFuZGxlckRvbVByb3h5KGRvbSkge1xuICAgICAgICBFdmVudGZ1bC5jYWxsKHRoaXMpO1xuXG4gICAgICAgIHRoaXMuZG9tID0gZG9tO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3RvdWNoaW5nID0gZmFsc2U7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl90b3VjaFRpbWVyO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAdHlwZSB7bW9kdWxlOnpyZW5kZXIvY29yZS9HZXN0dXJlTWdyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fZ2VzdHVyZU1nciA9IG5ldyBHZXN0dXJlTWdyKCk7XG5cbiAgICAgICAgdGhpcy5faGFuZGxlcnMgPSB7fTtcblxuICAgICAgICBpbml0RG9tSGFuZGxlcih0aGlzKTtcblxuICAgICAgICBpZiAodXNlVG91Y2hFdmVudCgpKSB7XG4gICAgICAgICAgICBtb3VudEhhbmRsZXJzKHRvdWNoSGFuZGxlck5hbWVzLCB0aGlzKTtcblxuICAgICAgICAgICAgLy8gSGFuZGxlciBvZiAnbW91c2VvdXQnIGV2ZW50IGlzIG5lZWRlZCBpbiB0b3VjaCBtb2RlLCB3aGljaCB3aWxsIGJlIG1vdW50ZWQgYmVsb3cuXG4gICAgICAgICAgICAvLyBhZGRFdmVudExpc3RlbmVyKHJvb3QsICdtb3VzZW91dCcsIHRoaXMuX21vdXNlb3V0SGFuZGxlcik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDb25zaWRlcmluZyBzb21lIGRldmljZXMgdGhhdCBib3RoIGVuYWJsZSB0b3VjaCBhbmQgbW91c2UgZXZlbnQgKGxpa2UgTVMgU3VyZmFjZVxuICAgICAgICAvLyBhbmQgbGVub3ZvIFgyNDAsIEBzZWUgIzIzNTApLCB3ZSBtYWtlIG1vdXNlIGV2ZW50IGJlIGFsd2F5cyBsaXN0ZW5lZCwgb3RoZXJ3aXNlXG4gICAgICAgIC8vIG1vdXNlIGV2ZW50IGNhbiBub3QgYmUgaGFuZGxlIGluIHRob3NlIGRldmljZXMuXG4gICAgICAgIG1vdW50SGFuZGxlcnMobW91c2VIYW5kbGVyTmFtZXMsIHRoaXMpO1xuXG4gICAgICAgIGZ1bmN0aW9uIG1vdW50SGFuZGxlcnMoaGFuZGxlck5hbWVzLCBpbnN0YW5jZSkge1xuICAgICAgICAgICAgenJVdGlsLmVhY2goaGFuZGxlck5hbWVzLCBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgICAgIGFkZEV2ZW50TGlzdGVuZXIoZG9tLCBldmVudE5hbWVGaXgobmFtZSksIGluc3RhbmNlLl9oYW5kbGVyc1tuYW1lXSk7XG4gICAgICAgICAgICB9LCBpbnN0YW5jZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgaGFuZGxlckRvbVByb3h5UHJvdG8gPSBIYW5kbGVyRG9tUHJveHkucHJvdG90eXBlO1xuICAgIGhhbmRsZXJEb21Qcm94eVByb3RvLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBoYW5kbGVyTmFtZXMgPSBtb3VzZUhhbmRsZXJOYW1lcy5jb25jYXQodG91Y2hIYW5kbGVyTmFtZXMpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaGFuZGxlck5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgbmFtZSA9IGhhbmRsZXJOYW1lc1tpXTtcbiAgICAgICAgICAgIHJlbW92ZUV2ZW50TGlzdGVuZXIodGhpcy5kb20sIGV2ZW50TmFtZUZpeChuYW1lKSwgdGhpcy5faGFuZGxlcnNbbmFtZV0pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGhhbmRsZXJEb21Qcm94eVByb3RvLnNldEN1cnNvciA9IGZ1bmN0aW9uIChjdXJzb3JTdHlsZSkge1xuICAgICAgICB0aGlzLmRvbS5zdHlsZS5jdXJzb3IgPSBjdXJzb3JTdHlsZSB8fCAnZGVmYXVsdCc7XG4gICAgfTtcblxuICAgIHpyVXRpbC5taXhpbihIYW5kbGVyRG9tUHJveHksIEV2ZW50ZnVsKTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gSGFuZGxlckRvbVByb3h5O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34venJlbmRlci9saWIvZG9tL0hhbmRsZXJQcm94eS5qc1xuICoqIG1vZHVsZSBpZCA9IDcxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG4vKipcbiAqIE9ubHkgaW1wbGVtZW50cyBuZWVkZWQgZ2VzdHVyZXMgZm9yIG1vYmlsZS5cbiAqL1xuXG5cbiAgICB2YXIgZXZlbnRVdGlsID0gcmVxdWlyZSgnLi9ldmVudCcpO1xuXG4gICAgdmFyIEdlc3R1cmVNZ3IgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEB0eXBlIHtBcnJheS48T2JqZWN0Pn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3RyYWNrID0gW107XG4gICAgfTtcblxuICAgIEdlc3R1cmVNZ3IucHJvdG90eXBlID0ge1xuXG4gICAgICAgIGNvbnN0cnVjdG9yOiBHZXN0dXJlTWdyLFxuXG4gICAgICAgIHJlY29nbml6ZTogZnVuY3Rpb24gKGV2ZW50LCB0YXJnZXQsIHJvb3QpIHtcbiAgICAgICAgICAgIHRoaXMuX2RvVHJhY2soZXZlbnQsIHRhcmdldCwgcm9vdCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVjb2duaXplKGV2ZW50KTtcbiAgICAgICAgfSxcblxuICAgICAgICBjbGVhcjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5fdHJhY2subGVuZ3RoID0gMDtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9kb1RyYWNrOiBmdW5jdGlvbiAoZXZlbnQsIHRhcmdldCwgcm9vdCkge1xuICAgICAgICAgICAgdmFyIHRvdWNoZXMgPSBldmVudC50b3VjaGVzO1xuXG4gICAgICAgICAgICBpZiAoIXRvdWNoZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciB0cmFja0l0ZW0gPSB7XG4gICAgICAgICAgICAgICAgcG9pbnRzOiBbXSxcbiAgICAgICAgICAgICAgICB0b3VjaGVzOiBbXSxcbiAgICAgICAgICAgICAgICB0YXJnZXQ6IHRhcmdldCxcbiAgICAgICAgICAgICAgICBldmVudDogZXZlbnRcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0b3VjaGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRvdWNoID0gdG91Y2hlc1tpXTtcbiAgICAgICAgICAgICAgICB2YXIgcG9zID0gZXZlbnRVdGlsLmNsaWVudFRvTG9jYWwocm9vdCwgdG91Y2gpO1xuICAgICAgICAgICAgICAgIHRyYWNrSXRlbS5wb2ludHMucHVzaChbcG9zLnpyWCwgcG9zLnpyWV0pO1xuICAgICAgICAgICAgICAgIHRyYWNrSXRlbS50b3VjaGVzLnB1c2godG91Y2gpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl90cmFjay5wdXNoKHRyYWNrSXRlbSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX3JlY29nbml6ZTogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICBmb3IgKHZhciBldmVudE5hbWUgaW4gcmVjb2duaXplcnMpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVjb2duaXplcnMuaGFzT3duUHJvcGVydHkoZXZlbnROYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZ2VzdHVyZUluZm8gPSByZWNvZ25pemVyc1tldmVudE5hbWVdKHRoaXMuX3RyYWNrLCBldmVudCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChnZXN0dXJlSW5mbykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdlc3R1cmVJbmZvO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGRpc3QocG9pbnRQYWlyKSB7XG4gICAgICAgIHZhciBkeCA9IHBvaW50UGFpclsxXVswXSAtIHBvaW50UGFpclswXVswXTtcbiAgICAgICAgdmFyIGR5ID0gcG9pbnRQYWlyWzFdWzFdIC0gcG9pbnRQYWlyWzBdWzFdO1xuXG4gICAgICAgIHJldHVybiBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNlbnRlcihwb2ludFBhaXIpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIChwb2ludFBhaXJbMF1bMF0gKyBwb2ludFBhaXJbMV1bMF0pIC8gMixcbiAgICAgICAgICAgIChwb2ludFBhaXJbMF1bMV0gKyBwb2ludFBhaXJbMV1bMV0pIC8gMlxuICAgICAgICBdO1xuICAgIH1cblxuICAgIHZhciByZWNvZ25pemVycyA9IHtcblxuICAgICAgICBwaW5jaDogZnVuY3Rpb24gKHRyYWNrLCBldmVudCkge1xuICAgICAgICAgICAgdmFyIHRyYWNrTGVuID0gdHJhY2subGVuZ3RoO1xuXG4gICAgICAgICAgICBpZiAoIXRyYWNrTGVuKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgcGluY2hFbmQgPSAodHJhY2tbdHJhY2tMZW4gLSAxXSB8fCB7fSkucG9pbnRzO1xuICAgICAgICAgICAgdmFyIHBpbmNoUHJlID0gKHRyYWNrW3RyYWNrTGVuIC0gMl0gfHwge30pLnBvaW50cyB8fCBwaW5jaEVuZDtcblxuICAgICAgICAgICAgaWYgKHBpbmNoUHJlXG4gICAgICAgICAgICAgICAgJiYgcGluY2hQcmUubGVuZ3RoID4gMVxuICAgICAgICAgICAgICAgICYmIHBpbmNoRW5kXG4gICAgICAgICAgICAgICAgJiYgcGluY2hFbmQubGVuZ3RoID4gMVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBpbmNoU2NhbGUgPSBkaXN0KHBpbmNoRW5kKSAvIGRpc3QocGluY2hQcmUpO1xuICAgICAgICAgICAgICAgICFpc0Zpbml0ZShwaW5jaFNjYWxlKSAmJiAocGluY2hTY2FsZSA9IDEpO1xuXG4gICAgICAgICAgICAgICAgZXZlbnQucGluY2hTY2FsZSA9IHBpbmNoU2NhbGU7XG5cbiAgICAgICAgICAgICAgICB2YXIgcGluY2hDZW50ZXIgPSBjZW50ZXIocGluY2hFbmQpO1xuICAgICAgICAgICAgICAgIGV2ZW50LnBpbmNoWCA9IHBpbmNoQ2VudGVyWzBdO1xuICAgICAgICAgICAgICAgIGV2ZW50LnBpbmNoWSA9IHBpbmNoQ2VudGVyWzFdO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3BpbmNoJyxcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiB0cmFja1swXS50YXJnZXQsXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50OiBldmVudFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBPbmx5IHBpbmNoIGN1cnJlbnRseS5cbiAgICB9O1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBHZXN0dXJlTWdyO1xuXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi96cmVuZGVyL2xpYi9jb3JlL0dlc3R1cmVNZ3IuanNcbiAqKiBtb2R1bGUgaWQgPSA3MlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuLyoqXG4gKiBEZWZhdWx0IGNhbnZhcyBwYWludGVyXG4gKiBAbW9kdWxlIHpyZW5kZXIvUGFpbnRlclxuICogQGF1dGhvciBLZW5lciAoQEtlbmVyLeael+WzsCwga2VuZXIubGluZmVuZ0BnbWFpbC5jb20pXG4gKiAgICAgICAgIGVycm9ycmlrIChlcnJvcnJpa0BnbWFpbC5jb20pXG4gKiAgICAgICAgIHBpc3NhbmcgKGh0dHBzOi8vd3d3LmdpdGh1Yi5jb20vcGlzc2FuZylcbiAqL1xuIFxuXG4gICAgdmFyIGNvbmZpZyA9IHJlcXVpcmUoJy4vY29uZmlnJyk7XG4gICAgdmFyIHV0aWwgPSByZXF1aXJlKCcuL2NvcmUvdXRpbCcpO1xuICAgIHZhciBsb2cgPSByZXF1aXJlKCcuL2NvcmUvbG9nJyk7XG4gICAgdmFyIEJvdW5kaW5nUmVjdCA9IHJlcXVpcmUoJy4vY29yZS9Cb3VuZGluZ1JlY3QnKTtcbiAgICB2YXIgdGltc29ydCA9IHJlcXVpcmUoJy4vY29yZS90aW1zb3J0Jyk7XG5cbiAgICB2YXIgTGF5ZXIgPSByZXF1aXJlKCcuL0xheWVyJyk7XG5cbiAgICB2YXIgcmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gcmVxdWlyZSgnLi9hbmltYXRpb24vcmVxdWVzdEFuaW1hdGlvbkZyYW1lJyk7XG5cbiAgICAvLyBQRU5ESUdOXG4gICAgLy8gTGF5ZXIgZXhjZWVkcyBNQVhfUFJPR1JFU1NJVkVfTEFZRVJfTlVNQkVSIG1heSBoYXZlIHNvbWUgcHJvYmxlbSB3aGVuIGZsdXNoIGRpcmVjdGx5IHNlY29uZCB0aW1lLlxuICAgIC8vXG4gICAgLy8gTWF4aW11bSBwcm9ncmVzc2l2ZSBsYXllci4gV2hlbiBleGNlZWRpbmcgdGhpcyBudW1iZXIuIEFsbCBlbGVtZW50cyB3aWxsIGJlIGRyYXdlZCBpbiB0aGUgbGFzdCBsYXllci5cbiAgICB2YXIgTUFYX1BST0dSRVNTSVZFX0xBWUVSX05VTUJFUiA9IDU7XG5cbiAgICBmdW5jdGlvbiBwYXJzZUludDEwKHZhbCkge1xuICAgICAgICByZXR1cm4gcGFyc2VJbnQodmFsLCAxMCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNMYXllclZhbGlkKGxheWVyKSB7XG4gICAgICAgIGlmICghbGF5ZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsYXllci5pc0J1aWxkaW4pIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZihsYXllci5yZXNpemUpICE9PSAnZnVuY3Rpb24nXG4gICAgICAgICAgICB8fCB0eXBlb2YobGF5ZXIucmVmcmVzaCkgIT09ICdmdW5jdGlvbidcbiAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcmVQcm9jZXNzTGF5ZXIobGF5ZXIpIHtcbiAgICAgICAgbGF5ZXIuX191bnVzZWRDb3VudCsrO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBvc3RQcm9jZXNzTGF5ZXIobGF5ZXIpIHtcbiAgICAgICAgaWYgKGxheWVyLl9fdW51c2VkQ291bnQgPT0gMSkge1xuICAgICAgICAgICAgbGF5ZXIuY2xlYXIoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciB0bXBSZWN0ID0gbmV3IEJvdW5kaW5nUmVjdCgwLCAwLCAwLCAwKTtcbiAgICB2YXIgdmlld1JlY3QgPSBuZXcgQm91bmRpbmdSZWN0KDAsIDAsIDAsIDApO1xuICAgIGZ1bmN0aW9uIGlzRGlzcGxheWFibGVDdWxsZWQoZWwsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgdG1wUmVjdC5jb3B5KGVsLmdldEJvdW5kaW5nUmVjdCgpKTtcbiAgICAgICAgaWYgKGVsLnRyYW5zZm9ybSkge1xuICAgICAgICAgICAgdG1wUmVjdC5hcHBseVRyYW5zZm9ybShlbC50cmFuc2Zvcm0pO1xuICAgICAgICB9XG4gICAgICAgIHZpZXdSZWN0LndpZHRoID0gd2lkdGg7XG4gICAgICAgIHZpZXdSZWN0LmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgcmV0dXJuICF0bXBSZWN0LmludGVyc2VjdCh2aWV3UmVjdCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNDbGlwUGF0aENoYW5nZWQoY2xpcFBhdGhzLCBwcmV2Q2xpcFBhdGhzKSB7XG4gICAgICAgIGlmIChjbGlwUGF0aHMgPT0gcHJldkNsaXBQYXRocykgeyAvLyBDYW4gYm90aCBiZSBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFjbGlwUGF0aHMgfHwgIXByZXZDbGlwUGF0aHMgfHwgKGNsaXBQYXRocy5sZW5ndGggIT09IHByZXZDbGlwUGF0aHMubGVuZ3RoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbGlwUGF0aHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChjbGlwUGF0aHNbaV0gIT09IHByZXZDbGlwUGF0aHNbaV0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRvQ2xpcChjbGlwUGF0aHMsIGN0eCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNsaXBQYXRocy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGNsaXBQYXRoID0gY2xpcFBhdGhzW2ldO1xuICAgICAgICAgICAgdmFyIHBhdGggPSBjbGlwUGF0aC5wYXRoO1xuXG4gICAgICAgICAgICBjbGlwUGF0aC5zZXRUcmFuc2Zvcm0oY3R4KTtcbiAgICAgICAgICAgIHBhdGguYmVnaW5QYXRoKGN0eCk7XG4gICAgICAgICAgICBjbGlwUGF0aC5idWlsZFBhdGgocGF0aCwgY2xpcFBhdGguc2hhcGUpO1xuICAgICAgICAgICAgY3R4LmNsaXAoKTtcbiAgICAgICAgICAgIC8vIFRyYW5zZm9ybSBiYWNrXG4gICAgICAgICAgICBjbGlwUGF0aC5yZXN0b3JlVHJhbnNmb3JtKGN0eCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVSb290KHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgdmFyIGRvbVJvb3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdmFyIGRvbVJvb3RTdHlsZSA9IGRvbVJvb3Quc3R5bGU7XG5cbiAgICAgICAgLy8gZG9tUm9vdC5vbnNlbGVjdHN0YXJ0ID0gcmV0dXJuRmFsc2U7IC8vIOmBv+WFjemhtemdoumAieS4reeahOWwtOWwrFxuICAgICAgICBkb21Sb290U3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnO1xuICAgICAgICBkb21Sb290U3R5bGUub3ZlcmZsb3cgPSAnaGlkZGVuJztcbiAgICAgICAgZG9tUm9vdFN0eWxlLndpZHRoID0gd2lkdGggKyAncHgnO1xuICAgICAgICBkb21Sb290U3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgJ3B4JztcbiAgICAgICAgcmV0dXJuIGRvbVJvb3Q7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGFsaWFzIG1vZHVsZTp6cmVuZGVyL1BhaW50ZXJcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSByb290IOe7mOWbvuWuueWZqFxuICAgICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvU3RvcmFnZX0gc3RvcmFnZVxuICAgICAqIEBwYXJhbSB7T2piZWN0fSBvcHRzXG4gICAgICovXG4gICAgdmFyIFBhaW50ZXIgPSBmdW5jdGlvbiAocm9vdCwgc3RvcmFnZSwgb3B0cykge1xuICAgICAgICAvLyBJbiBub2RlIGVudmlyb25tZW50IHVzaW5nIG5vZGUtY2FudmFzXG4gICAgICAgIHZhciBzaW5nbGVDYW52YXMgPSAhcm9vdC5ub2RlTmFtZSAvLyBJbiBub2RlID9cbiAgICAgICAgICAgIHx8IHJvb3Qubm9kZU5hbWUudG9VcHBlckNhc2UoKSA9PT0gJ0NBTlZBUyc7XG5cbiAgICAgICAgb3B0cyA9IG9wdHMgfHwge307XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRwciA9IG9wdHMuZGV2aWNlUGl4ZWxSYXRpbyB8fCBjb25maWcuZGV2aWNlUGl4ZWxSYXRpbztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fc2luZ2xlQ2FudmFzID0gc2luZ2xlQ2FudmFzO1xuICAgICAgICAvKipcbiAgICAgICAgICog57uY5Zu+5a655ZmoXG4gICAgICAgICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucm9vdCA9IHJvb3Q7XG5cbiAgICAgICAgdmFyIHJvb3RTdHlsZSA9IHJvb3Quc3R5bGU7XG5cbiAgICAgICAgaWYgKHJvb3RTdHlsZSkge1xuICAgICAgICAgICAgcm9vdFN0eWxlWyctd2Via2l0LXRhcC1oaWdobGlnaHQtY29sb3InXSA9ICd0cmFuc3BhcmVudCc7XG4gICAgICAgICAgICByb290U3R5bGVbJy13ZWJraXQtdXNlci1zZWxlY3QnXSA9XG4gICAgICAgICAgICByb290U3R5bGVbJ3VzZXItc2VsZWN0J10gPVxuICAgICAgICAgICAgcm9vdFN0eWxlWyctd2Via2l0LXRvdWNoLWNhbGxvdXQnXSA9ICdub25lJztcblxuICAgICAgICAgICAgcm9vdC5pbm5lckhUTUwgPSAnJztcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7bW9kdWxlOnpyZW5kZXIvU3RvcmFnZX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3RvcmFnZSA9IHN0b3JhZ2U7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtBcnJheS48bnVtYmVyPn1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHZhciB6bGV2ZWxMaXN0ID0gdGhpcy5femxldmVsTGlzdCA9IFtdO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsIG1vZHVsZTp6cmVuZGVyL0xheWVyPn1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHZhciBsYXllcnMgPSB0aGlzLl9sYXllcnMgPSB7fTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge09iamVjdC48c3RyaW5nLCBPYmplY3Q+fVxuICAgICAgICAgKiBAdHlwZSB7cHJpdmF0ZX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2xheWVyQ29uZmlnID0ge307XG5cbiAgICAgICAgaWYgKCFzaW5nbGVDYW52YXMpIHtcbiAgICAgICAgICAgIHRoaXMuX3dpZHRoID0gdGhpcy5fZ2V0V2lkdGgoKTtcbiAgICAgICAgICAgIHRoaXMuX2hlaWdodCA9IHRoaXMuX2dldEhlaWdodCgpO1xuXG4gICAgICAgICAgICB2YXIgZG9tUm9vdCA9IHRoaXMuX2RvbVJvb3QgPSBjcmVhdGVSb290KFxuICAgICAgICAgICAgICAgIHRoaXMuX3dpZHRoLCB0aGlzLl9oZWlnaHRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICByb290LmFwcGVuZENoaWxkKGRvbVJvb3QpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gVXNlIGNhbnZhcyB3aWR0aCBhbmQgaGVpZ2h0IGRpcmVjdGx5XG4gICAgICAgICAgICB2YXIgd2lkdGggPSByb290LndpZHRoO1xuICAgICAgICAgICAgdmFyIGhlaWdodCA9IHJvb3QuaGVpZ2h0O1xuICAgICAgICAgICAgdGhpcy5fd2lkdGggPSB3aWR0aDtcbiAgICAgICAgICAgIHRoaXMuX2hlaWdodCA9IGhlaWdodDtcblxuICAgICAgICAgICAgLy8gQ3JlYXRlIGxheWVyIGlmIG9ubHkgb25lIGdpdmVuIGNhbnZhc1xuICAgICAgICAgICAgLy8gRGV2aWNlIHBpeGVsIHJhdGlvIGlzIGZpeGVkIHRvIDEgYmVjYXVzZSBnaXZlbiBjYW52YXMgaGFzIGl0cyBzcGVjaWZpZWQgd2lkdGggYW5kIGhlaWdodFxuICAgICAgICAgICAgdmFyIG1haW5MYXllciA9IG5ldyBMYXllcihyb290LCB0aGlzLCAxKTtcbiAgICAgICAgICAgIG1haW5MYXllci5pbml0Q29udGV4dCgpO1xuICAgICAgICAgICAgLy8gRklYTUUgVXNlIGNhbnZhcyB3aWR0aCBhbmQgaGVpZ2h0XG4gICAgICAgICAgICAvLyBtYWluTGF5ZXIucmVzaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgICAgbGF5ZXJzWzBdID0gbWFpbkxheWVyO1xuICAgICAgICAgICAgemxldmVsTGlzdC5wdXNoKDApO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5wYXRoVG9JbWFnZSA9IHRoaXMuX2NyZWF0ZVBhdGhUb0ltYWdlKCk7XG5cbiAgICAgICAgLy8gTGF5ZXJzIGZvciBwcm9ncmVzc2l2ZSByZW5kZXJpbmdcbiAgICAgICAgdGhpcy5fcHJvZ3Jlc3NpdmVMYXllcnMgPSBbXTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge21vZHVsZTp6cmVuZGVyL0xheWVyfVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5faG92ZXJsYXllcjtcblxuICAgICAgICB0aGlzLl9ob3ZlckVsZW1lbnRzID0gW107XG4gICAgfTtcblxuICAgIFBhaW50ZXIucHJvdG90eXBlID0ge1xuXG4gICAgICAgIGNvbnN0cnVjdG9yOiBQYWludGVyLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiBwYWludGVyIHVzZSBhIHNpbmdsZSBjYW52YXNcbiAgICAgICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIGlzU2luZ2xlQ2FudmFzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2luZ2xlQ2FudmFzO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7SFRNTERpdkVsZW1lbnR9XG4gICAgICAgICAqL1xuICAgICAgICBnZXRWaWV3cG9ydFJvb3Q6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zaW5nbGVDYW52YXMgPyB0aGlzLl9sYXllcnNbMF0uZG9tIDogdGhpcy5fZG9tUm9vdDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5Yi35pawXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3BhaW50QWxsPWZhbHNlXSDlvLrliLbnu5jliLbmiYDmnIlkaXNwbGF5YWJsZVxuICAgICAgICAgKi9cbiAgICAgICAgcmVmcmVzaDogZnVuY3Rpb24gKHBhaW50QWxsKSB7XG5cbiAgICAgICAgICAgIHZhciBsaXN0ID0gdGhpcy5zdG9yYWdlLmdldERpc3BsYXlMaXN0KHRydWUpO1xuXG4gICAgICAgICAgICB2YXIgemxldmVsTGlzdCA9IHRoaXMuX3psZXZlbExpc3Q7XG5cbiAgICAgICAgICAgIHRoaXMuX3BhaW50TGlzdChsaXN0LCBwYWludEFsbCk7XG5cbiAgICAgICAgICAgIC8vIFBhaW50IGN1c3R1bSBsYXllcnNcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgemxldmVsTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciB6ID0gemxldmVsTGlzdFtpXTtcbiAgICAgICAgICAgICAgICB2YXIgbGF5ZXIgPSB0aGlzLl9sYXllcnNbel07XG4gICAgICAgICAgICAgICAgaWYgKCFsYXllci5pc0J1aWxkaW4gJiYgbGF5ZXIucmVmcmVzaCkge1xuICAgICAgICAgICAgICAgICAgICBsYXllci5yZWZyZXNoKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnJlZnJlc2hIb3ZlcigpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5fcHJvZ3Jlc3NpdmVMYXllcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhcnRQcm9nZXNzaXZlKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGFkZEhvdmVyOiBmdW5jdGlvbiAoZWwsIGhvdmVyU3R5bGUpIHtcbiAgICAgICAgICAgIGlmIChlbC5fX2hvdmVyTWlyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGVsTWlycm9yID0gbmV3IGVsLmNvbnN0cnVjdG9yKHtcbiAgICAgICAgICAgICAgICBzdHlsZTogZWwuc3R5bGUsXG4gICAgICAgICAgICAgICAgc2hhcGU6IGVsLnNoYXBlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGVsTWlycm9yLl9fZnJvbSA9IGVsO1xuICAgICAgICAgICAgZWwuX19ob3Zlck1pciA9IGVsTWlycm9yO1xuICAgICAgICAgICAgZWxNaXJyb3Iuc2V0U3R5bGUoaG92ZXJTdHlsZSk7XG4gICAgICAgICAgICB0aGlzLl9ob3ZlckVsZW1lbnRzLnB1c2goZWxNaXJyb3IpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHJlbW92ZUhvdmVyOiBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgIHZhciBlbE1pcnJvciA9IGVsLl9faG92ZXJNaXI7XG4gICAgICAgICAgICB2YXIgaG92ZXJFbGVtZW50cyA9IHRoaXMuX2hvdmVyRWxlbWVudHM7XG4gICAgICAgICAgICB2YXIgaWR4ID0gdXRpbC5pbmRleE9mKGhvdmVyRWxlbWVudHMsIGVsTWlycm9yKTtcbiAgICAgICAgICAgIGlmIChpZHggPj0gMCkge1xuICAgICAgICAgICAgICAgIGhvdmVyRWxlbWVudHMuc3BsaWNlKGlkeCwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbC5fX2hvdmVyTWlyID0gbnVsbDtcbiAgICAgICAgfSxcblxuICAgICAgICBjbGVhckhvdmVyOiBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgIHZhciBob3ZlckVsZW1lbnRzID0gdGhpcy5faG92ZXJFbGVtZW50cztcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaG92ZXJFbGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBmcm9tID0gaG92ZXJFbGVtZW50c1tpXS5fX2Zyb207XG4gICAgICAgICAgICAgICAgaWYgKGZyb20pIHtcbiAgICAgICAgICAgICAgICAgICAgZnJvbS5fX2hvdmVyTWlyID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBob3ZlckVsZW1lbnRzLmxlbmd0aCA9IDA7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVmcmVzaEhvdmVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgaG92ZXJFbGVtZW50cyA9IHRoaXMuX2hvdmVyRWxlbWVudHM7XG4gICAgICAgICAgICB2YXIgbGVuID0gaG92ZXJFbGVtZW50cy5sZW5ndGg7XG4gICAgICAgICAgICB2YXIgaG92ZXJMYXllciA9IHRoaXMuX2hvdmVybGF5ZXI7XG4gICAgICAgICAgICBob3ZlckxheWVyICYmIGhvdmVyTGF5ZXIuY2xlYXIoKTtcblxuICAgICAgICAgICAgaWYgKCFsZW4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aW1zb3J0KGhvdmVyRWxlbWVudHMsIHRoaXMuc3RvcmFnZS5kaXNwbGF5YWJsZVNvcnRGdW5jKTtcblxuICAgICAgICAgICAgLy8gVXNlIGEgZXh0cmVhbSBsYXJnZSB6bGV2ZWxcbiAgICAgICAgICAgIC8vIEZJWE1FP1xuICAgICAgICAgICAgaWYgKCFob3ZlckxheWVyKSB7XG4gICAgICAgICAgICAgICAgaG92ZXJMYXllciA9IHRoaXMuX2hvdmVybGF5ZXIgPSB0aGlzLmdldExheWVyKDFlNSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBzY29wZSA9IHt9O1xuICAgICAgICAgICAgaG92ZXJMYXllci5jdHguc2F2ZSgpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47KSB7XG4gICAgICAgICAgICAgICAgdmFyIGVsID0gaG92ZXJFbGVtZW50c1tpXTtcbiAgICAgICAgICAgICAgICB2YXIgb3JpZ2luYWxFbCA9IGVsLl9fZnJvbTtcbiAgICAgICAgICAgICAgICAvLyBPcmlnaW5hbCBlbCBpcyByZW1vdmVkXG4gICAgICAgICAgICAgICAgLy8gUEVORElOR1xuICAgICAgICAgICAgICAgIGlmICghKG9yaWdpbmFsRWwgJiYgb3JpZ2luYWxFbC5fX3pyKSkge1xuICAgICAgICAgICAgICAgICAgICBob3ZlckVsZW1lbnRzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxFbC5fX2hvdmVyTWlyID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgbGVuLS07XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpKys7XG5cbiAgICAgICAgICAgICAgICAvLyBVc2UgdHJhbnNmb3JtXG4gICAgICAgICAgICAgICAgLy8gRklYTUUgc3R5bGUgYW5kIHNoYXBlID9cbiAgICAgICAgICAgICAgICBpZiAoIW9yaWdpbmFsRWwuaW52aXNpYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsLnRyYW5zZm9ybSA9IG9yaWdpbmFsRWwudHJhbnNmb3JtO1xuICAgICAgICAgICAgICAgICAgICBlbC5pbnZUcmFuc2Zvcm0gPSBvcmlnaW5hbEVsLmludlRyYW5zZm9ybTtcbiAgICAgICAgICAgICAgICAgICAgZWwuX19jbGlwUGF0aHMgPSBvcmlnaW5hbEVsLl9fY2xpcFBhdGhzO1xuICAgICAgICAgICAgICAgICAgICAvLyBlbC5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZG9QYWludEVsKGVsLCBob3ZlckxheWVyLCB0cnVlLCBzY29wZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaG92ZXJMYXllci5jdHgucmVzdG9yZSgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9zdGFydFByb2dlc3NpdmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICAgICAgaWYgKCFzZWxmLl9mdXJ0aGVyUHJvZ3Jlc3NpdmUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFVzZSBhIHRva2VuIHRvIHN0b3AgcHJvZ3Jlc3Mgc3RlcHMgdHJpZ2dlcmVkIGJ5XG4gICAgICAgICAgICAvLyBwcmV2aW91cyB6ci5yZWZyZXNoIGNhbGxpbmcuXG4gICAgICAgICAgICB2YXIgdG9rZW4gPSBzZWxmLl9wcm9ncmVzc2l2ZVRva2VuID0gK25ldyBEYXRlKCk7XG5cbiAgICAgICAgICAgIHNlbGYuX3Byb2dyZXNzKys7XG4gICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoc3RlcCk7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIHN0ZXAoKSB7XG4gICAgICAgICAgICAgICAgLy8gSW4gY2FzZSByZWZyZXNoZWQgb3IgZGlzcG9zZWRcbiAgICAgICAgICAgICAgICBpZiAodG9rZW4gPT09IHNlbGYuX3Byb2dyZXNzaXZlVG9rZW4gJiYgc2VsZi5zdG9yYWdlKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgc2VsZi5fZG9QYWludExpc3Qoc2VsZi5zdG9yYWdlLmdldERpc3BsYXlMaXN0KCkpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLl9mdXJ0aGVyUHJvZ3Jlc3NpdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX3Byb2dyZXNzKys7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoc3RlcCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9wcm9ncmVzc2l2ZVRva2VuID0gLTE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2NsZWFyUHJvZ3Jlc3NpdmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX3Byb2dyZXNzaXZlVG9rZW4gPSAtMTtcbiAgICAgICAgICAgIHRoaXMuX3Byb2dyZXNzID0gMDtcbiAgICAgICAgICAgIHV0aWwuZWFjaCh0aGlzLl9wcm9ncmVzc2l2ZUxheWVycywgZnVuY3Rpb24gKGxheWVyKSB7XG4gICAgICAgICAgICAgICAgbGF5ZXIuX19kaXJ0eSAmJiBsYXllci5jbGVhcigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX3BhaW50TGlzdDogZnVuY3Rpb24gKGxpc3QsIHBhaW50QWxsKSB7XG5cbiAgICAgICAgICAgIGlmIChwYWludEFsbCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcGFpbnRBbGwgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5fdXBkYXRlTGF5ZXJTdGF0dXMobGlzdCk7XG5cbiAgICAgICAgICAgIHRoaXMuX2NsZWFyUHJvZ3Jlc3NpdmUoKTtcblxuICAgICAgICAgICAgdGhpcy5lYWNoQnVpbGRpbkxheWVyKHByZVByb2Nlc3NMYXllcik7XG5cbiAgICAgICAgICAgIHRoaXMuX2RvUGFpbnRMaXN0KGxpc3QsIHBhaW50QWxsKTtcblxuICAgICAgICAgICAgdGhpcy5lYWNoQnVpbGRpbkxheWVyKHBvc3RQcm9jZXNzTGF5ZXIpO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9kb1BhaW50TGlzdDogZnVuY3Rpb24gKGxpc3QsIHBhaW50QWxsKSB7XG4gICAgICAgICAgICB2YXIgY3VycmVudExheWVyO1xuICAgICAgICAgICAgdmFyIGN1cnJlbnRaTGV2ZWw7XG4gICAgICAgICAgICB2YXIgY3R4O1xuXG4gICAgICAgICAgICAvLyB2YXIgaW52VHJhbnNmb3JtID0gW107XG4gICAgICAgICAgICB2YXIgc2NvcGU7XG5cbiAgICAgICAgICAgIHZhciBwcm9ncmVzc2l2ZUxheWVySWR4ID0gMDtcbiAgICAgICAgICAgIHZhciBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllcjtcblxuICAgICAgICAgICAgdmFyIHdpZHRoID0gdGhpcy5fd2lkdGg7XG4gICAgICAgICAgICB2YXIgaGVpZ2h0ID0gdGhpcy5faGVpZ2h0O1xuICAgICAgICAgICAgdmFyIGxheWVyUHJvZ3Jlc3M7XG4gICAgICAgICAgICB2YXIgZnJhbWUgPSB0aGlzLl9wcm9ncmVzcztcbiAgICAgICAgICAgIGZ1bmN0aW9uIGZsdXNoUHJvZ3Jlc3NpdmVMYXllcihsYXllcikge1xuICAgICAgICAgICAgICAgIHZhciBkcHIgPSBjdHguZHByIHx8IDE7XG4gICAgICAgICAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSAxO1xuICAgICAgICAgICAgICAgIGN0eC5zaGFkb3dCbHVyID0gMDtcbiAgICAgICAgICAgICAgICAvLyBBdm9pZCBsYXllciBkb24ndCBjbGVhciBpbiBuZXh0IHByb2dyZXNzaXZlIGZyYW1lXG4gICAgICAgICAgICAgICAgY3VycmVudExheWVyLl9fZGlydHkgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGN0eC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG4gICAgICAgICAgICAgICAgY3R4LmRyYXdJbWFnZShsYXllci5kb20sIDAsIDAsIHdpZHRoICogZHByLCBoZWlnaHQgKiBkcHIpO1xuICAgICAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gbGlzdC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgZWwgPSBsaXN0W2ldO1xuICAgICAgICAgICAgICAgIHZhciBlbFpMZXZlbCA9IHRoaXMuX3NpbmdsZUNhbnZhcyA/IDAgOiBlbC56bGV2ZWw7XG5cbiAgICAgICAgICAgICAgICB2YXIgZWxGcmFtZSA9IGVsLl9fZnJhbWU7XG5cbiAgICAgICAgICAgICAgICAvLyBGbHVzaCBhdCBjdXJyZW50IGNvbnRleHRcbiAgICAgICAgICAgICAgICAvLyBQRU5ESU5HXG4gICAgICAgICAgICAgICAgaWYgKGVsRnJhbWUgPCAwICYmIGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGZsdXNoUHJvZ3Jlc3NpdmVMYXllcihjdXJyZW50UHJvZ3Jlc3NpdmVMYXllcik7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBDaGFuZ2UgZHJhdyBsYXllclxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50WkxldmVsICE9PSBlbFpMZXZlbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY3R4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gUmVzZXQgc2NvcGVcbiAgICAgICAgICAgICAgICAgICAgc2NvcGUgPSB7fTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBPbmx5IDAgemxldmVsIGlmIG9ubHkgaGFzIG9uZSBjYW52YXNcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFpMZXZlbCA9IGVsWkxldmVsO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50TGF5ZXIgPSB0aGlzLmdldExheWVyKGN1cnJlbnRaTGV2ZWwpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICghY3VycmVudExheWVyLmlzQnVpbGRpbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdaTGV2ZWwgJyArIGN1cnJlbnRaTGV2ZWxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICArICcgaGFzIGJlZW4gdXNlZCBieSB1bmtvd24gbGF5ZXIgJyArIGN1cnJlbnRMYXllci5pZFxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IGN1cnJlbnRMYXllci5jdHg7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5zYXZlKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gUmVzZXQgdGhlIGNvdW50XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRMYXllci5fX3VudXNlZENvdW50ID0gMDtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudExheWVyLl9fZGlydHkgfHwgcGFpbnRBbGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRMYXllci5jbGVhcigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCEoY3VycmVudExheWVyLl9fZGlydHkgfHwgcGFpbnRBbGwpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChlbEZyYW1lID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUHJvZ3Jlc3NpdmUgbGF5ZXIgY2hhbmdlZFxuICAgICAgICAgICAgICAgICAgICBpZiAoIWN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllciA9IHRoaXMuX3Byb2dyZXNzaXZlTGF5ZXJzW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1hdGgubWluKHByb2dyZXNzaXZlTGF5ZXJJZHgrKywgTUFYX1BST0dSRVNTSVZFX0xBWUVSX05VTUJFUiAtIDEpXG4gICAgICAgICAgICAgICAgICAgICAgICBdO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllci5jdHguc2F2ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFByb2dyZXNzaXZlTGF5ZXIucmVuZGVyU2NvcGUgPSB7fTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgKGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyLl9fcHJvZ3Jlc3MgPiBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllci5fX21heFByb2dyZXNzKVxuICAgICAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZmx1c2hQcm9ncmVzc2l2ZUxheWVyKGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBRdWljayBqdW1wIGFsbCBwcm9ncmVzc2l2ZSBlbGVtZW50c1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFsbCBwcm9ncmVzc2l2ZSBlbGVtZW50IGFyZSBub3QgZGlydHksIGp1bXAgb3ZlciBhbmQgZmx1c2ggZGlyZWN0bHlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpID0gY3VycmVudFByb2dyZXNzaXZlTGF5ZXIuX19uZXh0SWR4Tm90UHJvZyAtIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY3VycmVudFByb2dyZXNzaXZlTGF5ZXIgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBsYXllclByb2dyZXNzID0gY3VycmVudFByb2dyZXNzaXZlTGF5ZXIuX19wcm9ncmVzcztcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjdXJyZW50UHJvZ3Jlc3NpdmVMYXllci5fX2RpcnR5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gS2VlcCByZW5kZXJpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcmFtZSA9IGxheWVyUHJvZ3Jlc3M7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyLl9fcHJvZ3Jlc3MgPSBmcmFtZSArIDE7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoZWxGcmFtZSA9PT0gZnJhbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2RvUGFpbnRFbChlbCwgY3VycmVudFByb2dyZXNzaXZlTGF5ZXIsIHRydWUsIGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyLnJlbmRlclNjb3BlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZG9QYWludEVsKGVsLCBjdXJyZW50TGF5ZXIsIHBhaW50QWxsLCBzY29wZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZWwuX19kaXJ0eSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoY3VycmVudFByb2dyZXNzaXZlTGF5ZXIpIHtcbiAgICAgICAgICAgICAgICBmbHVzaFByb2dyZXNzaXZlTGF5ZXIoY3VycmVudFByb2dyZXNzaXZlTGF5ZXIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBSZXN0b3JlIHRoZSBsYXN0TGF5ZXIgY3R4XG4gICAgICAgICAgICBjdHggJiYgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgICAgIC8vIElmIHN0aWxsIGhhcyBjbGlwcGluZyBzdGF0ZVxuICAgICAgICAgICAgLy8gaWYgKHNjb3BlLnByZXZFbENsaXBQYXRocykge1xuICAgICAgICAgICAgLy8gICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgICAgICAvLyB9XG5cbiAgICAgICAgICAgIHRoaXMuX2Z1cnRoZXJQcm9ncmVzc2l2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgdXRpbC5lYWNoKHRoaXMuX3Byb2dyZXNzaXZlTGF5ZXJzLCBmdW5jdGlvbiAobGF5ZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAobGF5ZXIuX19tYXhQcm9ncmVzcyA+PSBsYXllci5fX3Byb2dyZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2Z1cnRoZXJQcm9ncmVzc2l2ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2RvUGFpbnRFbDogZnVuY3Rpb24gKGVsLCBjdXJyZW50TGF5ZXIsIGZvcmNlUGFpbnQsIHNjb3BlKSB7XG4gICAgICAgICAgICB2YXIgY3R4ID0gY3VycmVudExheWVyLmN0eDtcbiAgICAgICAgICAgIHZhciBtID0gZWwudHJhbnNmb3JtO1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIChjdXJyZW50TGF5ZXIuX19kaXJ0eSB8fCBmb3JjZVBhaW50KVxuICAgICAgICAgICAgICAgIC8vIElnbm9yZSBpbnZpc2libGUgZWxlbWVudFxuICAgICAgICAgICAgICAgICYmICFlbC5pbnZpc2libGVcbiAgICAgICAgICAgICAgICAvLyBJZ25vcmUgdHJhbnNwYXJlbnQgZWxlbWVudFxuICAgICAgICAgICAgICAgICYmIGVsLnN0eWxlLm9wYWNpdHkgIT09IDBcbiAgICAgICAgICAgICAgICAvLyBJZ25vcmUgc2NhbGUgMCBlbGVtZW50LCBpbiBzb21lIGVudmlyb25tZW50IGxpa2Ugbm9kZS1jYW52YXNcbiAgICAgICAgICAgICAgICAvLyBEcmF3IGEgc2NhbGUgMCBlbGVtZW50IGNhbiBjYXVzZSBhbGwgZm9sbG93aW5nIGRyYXcgd3JvbmdcbiAgICAgICAgICAgICAgICAvLyBBbmQgc2V0VHJhbnNmb3JtIHdpdGggc2NhbGUgMCB3aWxsIGNhdXNlIHNldCBiYWNrIHRyYW5zZm9ybSBmYWlsZWQuXG4gICAgICAgICAgICAgICAgJiYgIShtICYmICFtWzBdICYmICFtWzNdKVxuICAgICAgICAgICAgICAgIC8vIElnbm9yZSBjdWxsZWQgZWxlbWVudFxuICAgICAgICAgICAgICAgICYmICEoZWwuY3VsbGluZyAmJiBpc0Rpc3BsYXlhYmxlQ3VsbGVkKGVsLCB0aGlzLl93aWR0aCwgdGhpcy5faGVpZ2h0KSlcbiAgICAgICAgICAgICkge1xuXG4gICAgICAgICAgICAgICAgdmFyIGNsaXBQYXRocyA9IGVsLl9fY2xpcFBhdGhzO1xuXG4gICAgICAgICAgICAgICAgLy8gT3B0aW1pemUgd2hlbiBjbGlwcGluZyBvbiBncm91cCB3aXRoIHNldmVyYWwgZWxlbWVudHNcbiAgICAgICAgICAgICAgICBpZiAoc2NvcGUucHJldkNsaXBMYXllciAhPT0gY3VycmVudExheWVyXG4gICAgICAgICAgICAgICAgICAgIHx8IGlzQ2xpcFBhdGhDaGFuZ2VkKGNsaXBQYXRocywgc2NvcGUucHJldkVsQ2xpcFBhdGhzKVxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiBoYXMgcHJldmlvdXMgY2xpcHBpbmcgc3RhdGUsIHJlc3RvcmUgZnJvbSBpdFxuICAgICAgICAgICAgICAgICAgICBpZiAoc2NvcGUucHJldkVsQ2xpcFBhdGhzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzY29wZS5wcmV2Q2xpcExheWVyLmN0eC5yZXN0b3JlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzY29wZS5wcmV2Q2xpcExheWVyID0gc2NvcGUucHJldkVsQ2xpcFBhdGhzID0gbnVsbDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVzZXQgcHJldkVsIHNpbmNlIGNvbnRleHQgaGFzIGJlZW4gcmVzdG9yZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlLnByZXZFbCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gTmV3IGNsaXBwaW5nIHN0YXRlXG4gICAgICAgICAgICAgICAgICAgIGlmIChjbGlwUGF0aHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb0NsaXAoY2xpcFBhdGhzLCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGUucHJldkNsaXBMYXllciA9IGN1cnJlbnRMYXllcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlLnByZXZFbENsaXBQYXRocyA9IGNsaXBQYXRocztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbC5iZWZvcmVCcnVzaCAmJiBlbC5iZWZvcmVCcnVzaChjdHgpO1xuXG4gICAgICAgICAgICAgICAgZWwuYnJ1c2goY3R4LCBzY29wZS5wcmV2RWwgfHwgbnVsbCk7XG4gICAgICAgICAgICAgICAgc2NvcGUucHJldkVsID0gZWw7XG5cbiAgICAgICAgICAgICAgICBlbC5hZnRlckJydXNoICYmIGVsLmFmdGVyQnJ1c2goY3R4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog6I635Y+WIHpsZXZlbCDmiYDlnKjlsYLvvIzlpoLmnpzkuI3lrZjlnKjliJnkvJrliJvlu7rkuIDkuKrmlrDnmoTlsYJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHpsZXZlbFxuICAgICAgICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9MYXllcn1cbiAgICAgICAgICovXG4gICAgICAgIGdldExheWVyOiBmdW5jdGlvbiAoemxldmVsKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fc2luZ2xlQ2FudmFzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xheWVyc1swXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGxheWVyID0gdGhpcy5fbGF5ZXJzW3psZXZlbF07XG4gICAgICAgICAgICBpZiAoIWxheWVyKSB7XG4gICAgICAgICAgICAgICAgLy8gQ3JlYXRlIGEgbmV3IGxheWVyXG4gICAgICAgICAgICAgICAgbGF5ZXIgPSBuZXcgTGF5ZXIoJ3pyXycgKyB6bGV2ZWwsIHRoaXMsIHRoaXMuZHByKTtcbiAgICAgICAgICAgICAgICBsYXllci5pc0J1aWxkaW4gPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2xheWVyQ29uZmlnW3psZXZlbF0pIHtcbiAgICAgICAgICAgICAgICAgICAgdXRpbC5tZXJnZShsYXllciwgdGhpcy5fbGF5ZXJDb25maWdbemxldmVsXSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5pbnNlcnRMYXllcih6bGV2ZWwsIGxheWVyKTtcblxuICAgICAgICAgICAgICAgIC8vIENvbnRleHQgaXMgY3JlYXRlZCBhZnRlciBkb20gaW5zZXJ0ZWQgdG8gZG9jdW1lbnRcbiAgICAgICAgICAgICAgICAvLyBPciBleGNhbnZhcyB3aWxsIGdldCAwcHggY2xpZW50V2lkdGggYW5kIGNsaWVudEhlaWdodFxuICAgICAgICAgICAgICAgIGxheWVyLmluaXRDb250ZXh0KCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBsYXllcjtcbiAgICAgICAgfSxcblxuICAgICAgICBpbnNlcnRMYXllcjogZnVuY3Rpb24gKHpsZXZlbCwgbGF5ZXIpIHtcblxuICAgICAgICAgICAgdmFyIGxheWVyc01hcCA9IHRoaXMuX2xheWVycztcbiAgICAgICAgICAgIHZhciB6bGV2ZWxMaXN0ID0gdGhpcy5femxldmVsTGlzdDtcbiAgICAgICAgICAgIHZhciBsZW4gPSB6bGV2ZWxMaXN0Lmxlbmd0aDtcbiAgICAgICAgICAgIHZhciBwcmV2TGF5ZXIgPSBudWxsO1xuICAgICAgICAgICAgdmFyIGkgPSAtMTtcbiAgICAgICAgICAgIHZhciBkb21Sb290ID0gdGhpcy5fZG9tUm9vdDtcblxuICAgICAgICAgICAgaWYgKGxheWVyc01hcFt6bGV2ZWxdKSB7XG4gICAgICAgICAgICAgICAgbG9nKCdaTGV2ZWwgJyArIHpsZXZlbCArICcgaGFzIGJlZW4gdXNlZCBhbHJlYWR5Jyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgaXMgYSB2YWxpZCBsYXllclxuICAgICAgICAgICAgaWYgKCFpc0xheWVyVmFsaWQobGF5ZXIpKSB7XG4gICAgICAgICAgICAgICAgbG9nKCdMYXllciBvZiB6bGV2ZWwgJyArIHpsZXZlbCArICcgaXMgbm90IHZhbGlkJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobGVuID4gMCAmJiB6bGV2ZWwgPiB6bGV2ZWxMaXN0WzBdKSB7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbiAtIDE7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgICB6bGV2ZWxMaXN0W2ldIDwgemxldmVsXG4gICAgICAgICAgICAgICAgICAgICAgICAmJiB6bGV2ZWxMaXN0W2kgKyAxXSA+IHpsZXZlbFxuICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHByZXZMYXllciA9IGxheWVyc01hcFt6bGV2ZWxMaXN0W2ldXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHpsZXZlbExpc3Quc3BsaWNlKGkgKyAxLCAwLCB6bGV2ZWwpO1xuXG4gICAgICAgICAgICBpZiAocHJldkxheWVyKSB7XG4gICAgICAgICAgICAgICAgdmFyIHByZXZEb20gPSBwcmV2TGF5ZXIuZG9tO1xuICAgICAgICAgICAgICAgIGlmIChwcmV2RG9tLm5leHRTaWJsaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIGRvbVJvb3QuaW5zZXJ0QmVmb3JlKFxuICAgICAgICAgICAgICAgICAgICAgICAgbGF5ZXIuZG9tLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJldkRvbS5uZXh0U2libGluZ1xuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZG9tUm9vdC5hcHBlbmRDaGlsZChsYXllci5kb20pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChkb21Sb290LmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgZG9tUm9vdC5pbnNlcnRCZWZvcmUobGF5ZXIuZG9tLCBkb21Sb290LmZpcnN0Q2hpbGQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZG9tUm9vdC5hcHBlbmRDaGlsZChsYXllci5kb20pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGF5ZXJzTWFwW3psZXZlbF0gPSBsYXllcjtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBJdGVyYXRlIGVhY2ggbGF5ZXJcbiAgICAgICAgZWFjaExheWVyOiBmdW5jdGlvbiAoY2IsIGNvbnRleHQpIHtcbiAgICAgICAgICAgIHZhciB6bGV2ZWxMaXN0ID0gdGhpcy5femxldmVsTGlzdDtcbiAgICAgICAgICAgIHZhciB6O1xuICAgICAgICAgICAgdmFyIGk7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgemxldmVsTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHogPSB6bGV2ZWxMaXN0W2ldO1xuICAgICAgICAgICAgICAgIGNiLmNhbGwoY29udGV4dCwgdGhpcy5fbGF5ZXJzW3pdLCB6KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvLyBJdGVyYXRlIGVhY2ggYnVpbGRpbiBsYXllclxuICAgICAgICBlYWNoQnVpbGRpbkxheWVyOiBmdW5jdGlvbiAoY2IsIGNvbnRleHQpIHtcbiAgICAgICAgICAgIHZhciB6bGV2ZWxMaXN0ID0gdGhpcy5femxldmVsTGlzdDtcbiAgICAgICAgICAgIHZhciBsYXllcjtcbiAgICAgICAgICAgIHZhciB6O1xuICAgICAgICAgICAgdmFyIGk7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgemxldmVsTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHogPSB6bGV2ZWxMaXN0W2ldO1xuICAgICAgICAgICAgICAgIGxheWVyID0gdGhpcy5fbGF5ZXJzW3pdO1xuICAgICAgICAgICAgICAgIGlmIChsYXllci5pc0J1aWxkaW4pIHtcbiAgICAgICAgICAgICAgICAgICAgY2IuY2FsbChjb250ZXh0LCBsYXllciwgeik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8vIEl0ZXJhdGUgZWFjaCBvdGhlciBsYXllciBleGNlcHQgYnVpbGRpbiBsYXllclxuICAgICAgICBlYWNoT3RoZXJMYXllcjogZnVuY3Rpb24gKGNiLCBjb250ZXh0KSB7XG4gICAgICAgICAgICB2YXIgemxldmVsTGlzdCA9IHRoaXMuX3psZXZlbExpc3Q7XG4gICAgICAgICAgICB2YXIgbGF5ZXI7XG4gICAgICAgICAgICB2YXIgejtcbiAgICAgICAgICAgIHZhciBpO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHpsZXZlbExpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB6ID0gemxldmVsTGlzdFtpXTtcbiAgICAgICAgICAgICAgICBsYXllciA9IHRoaXMuX2xheWVyc1t6XTtcbiAgICAgICAgICAgICAgICBpZiAoISBsYXllci5pc0J1aWxkaW4pIHtcbiAgICAgICAgICAgICAgICAgICAgY2IuY2FsbChjb250ZXh0LCBsYXllciwgeik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDojrflj5bmiYDmnInlt7LliJvlu7rnmoTlsYJcbiAgICAgICAgICogQHBhcmFtIHtBcnJheS48bW9kdWxlOnpyZW5kZXIvTGF5ZXI+fSBbcHJldkxheWVyXVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0TGF5ZXJzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbGF5ZXJzO1xuICAgICAgICB9LFxuXG4gICAgICAgIF91cGRhdGVMYXllclN0YXR1czogZnVuY3Rpb24gKGxpc3QpIHtcblxuICAgICAgICAgICAgdmFyIGxheWVycyA9IHRoaXMuX2xheWVycztcbiAgICAgICAgICAgIHZhciBwcm9ncmVzc2l2ZUxheWVycyA9IHRoaXMuX3Byb2dyZXNzaXZlTGF5ZXJzO1xuXG4gICAgICAgICAgICB2YXIgZWxDb3VudHNMYXN0RnJhbWUgPSB7fTtcbiAgICAgICAgICAgIHZhciBwcm9ncmVzc2l2ZUVsQ291bnRzTGFzdEZyYW1lID0ge307XG5cbiAgICAgICAgICAgIHRoaXMuZWFjaEJ1aWxkaW5MYXllcihmdW5jdGlvbiAobGF5ZXIsIHopIHtcbiAgICAgICAgICAgICAgICBlbENvdW50c0xhc3RGcmFtZVt6XSA9IGxheWVyLmVsQ291bnQ7XG4gICAgICAgICAgICAgICAgbGF5ZXIuZWxDb3VudCA9IDA7XG4gICAgICAgICAgICAgICAgbGF5ZXIuX19kaXJ0eSA9IGZhbHNlO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHV0aWwuZWFjaChwcm9ncmVzc2l2ZUxheWVycywgZnVuY3Rpb24gKGxheWVyLCBpZHgpIHtcbiAgICAgICAgICAgICAgICBwcm9ncmVzc2l2ZUVsQ291bnRzTGFzdEZyYW1lW2lkeF0gPSBsYXllci5lbENvdW50O1xuICAgICAgICAgICAgICAgIGxheWVyLmVsQ291bnQgPSAwO1xuICAgICAgICAgICAgICAgIGxheWVyLl9fZGlydHkgPSBmYWxzZTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB2YXIgcHJvZ3Jlc3NpdmVMYXllckNvdW50ID0gMDtcbiAgICAgICAgICAgIHZhciBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllcjtcbiAgICAgICAgICAgIHZhciBsYXN0UHJvZ3Jlc3NpdmVLZXk7XG4gICAgICAgICAgICB2YXIgZnJhbWVDb3VudCA9IDA7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGxpc3QubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVsID0gbGlzdFtpXTtcbiAgICAgICAgICAgICAgICB2YXIgemxldmVsID0gdGhpcy5fc2luZ2xlQ2FudmFzID8gMCA6IGVsLnpsZXZlbDtcbiAgICAgICAgICAgICAgICB2YXIgbGF5ZXIgPSBsYXllcnNbemxldmVsXTtcbiAgICAgICAgICAgICAgICB2YXIgZWxQcm9ncmVzcyA9IGVsLnByb2dyZXNzaXZlO1xuICAgICAgICAgICAgICAgIGlmIChsYXllcikge1xuICAgICAgICAgICAgICAgICAgICBsYXllci5lbENvdW50Kys7XG4gICAgICAgICAgICAgICAgICAgIGxheWVyLl9fZGlydHkgPSBsYXllci5fX2RpcnR5IHx8IGVsLl9fZGlydHk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8vLy8vLyBVcGRhdGUgcHJvZ3Jlc3NpdmVcbiAgICAgICAgICAgICAgICBpZiAoZWxQcm9ncmVzcyA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEZpeCB3cm9uZyBwcm9ncmVzc2l2ZSBzZXF1ZW5jZSBwcm9ibGVtLlxuICAgICAgICAgICAgICAgICAgICBpZiAobGFzdFByb2dyZXNzaXZlS2V5ICE9PSBlbFByb2dyZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0UHJvZ3Jlc3NpdmVLZXkgPSBlbFByb2dyZXNzO1xuICAgICAgICAgICAgICAgICAgICAgICAgZnJhbWVDb3VudCsrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBlbEZyYW1lID0gZWwuX19mcmFtZSA9IGZyYW1lQ291bnQgLSAxO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaWR4ID0gTWF0aC5taW4ocHJvZ3Jlc3NpdmVMYXllckNvdW50LCBNQVhfUFJPR1JFU1NJVkVfTEFZRVJfTlVNQkVSIC0gMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllciA9IHByb2dyZXNzaXZlTGF5ZXJzW2lkeF07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFByb2dyZXNzaXZlTGF5ZXIgPSBwcm9ncmVzc2l2ZUxheWVyc1tpZHhdID0gbmV3IExheWVyKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAncHJvZ3Jlc3NpdmUnLCB0aGlzLCB0aGlzLmRwclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFByb2dyZXNzaXZlTGF5ZXIuaW5pdENvbnRleHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyLl9fbWF4UHJvZ3Jlc3MgPSAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyLl9fZGlydHkgPSBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllci5fX2RpcnR5IHx8IGVsLl9fZGlydHk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyLmVsQ291bnQrKztcblxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllci5fX21heFByb2dyZXNzID0gTWF0aC5tYXgoXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllci5fX21heFByb2dyZXNzLCBlbEZyYW1lXG4gICAgICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyLl9fbWF4UHJvZ3Jlc3MgPj0gY3VycmVudFByb2dyZXNzaXZlTGF5ZXIuX19wcm9ncmVzcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2hvdWxkIGtlZXAgcmVuZGVyaW5nIHRoaXMgIGxheWVyIGJlY2F1c2UgcHJvZ3Jlc3NpdmUgcmVuZGVyaW5nIGlzIG5vdCBmaW5pc2hlZCB5ZXRcbiAgICAgICAgICAgICAgICAgICAgICAgIGxheWVyLl9fZGlydHkgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBlbC5fX2ZyYW1lID0gLTE7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllci5fX25leHRJZHhOb3RQcm9nID0gaTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2dyZXNzaXZlTGF5ZXJDb3VudCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFByb2dyZXNzaXZlTGF5ZXIgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoY3VycmVudFByb2dyZXNzaXZlTGF5ZXIpIHtcbiAgICAgICAgICAgICAgICBwcm9ncmVzc2l2ZUxheWVyQ291bnQrKztcbiAgICAgICAgICAgICAgICBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllci5fX25leHRJZHhOb3RQcm9nID0gaTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8g5bGC5Lit55qE5YWD57Sg5pWw6YeP5pyJ5Y+R55Sf5Y+Y5YyWXG4gICAgICAgICAgICB0aGlzLmVhY2hCdWlsZGluTGF5ZXIoZnVuY3Rpb24gKGxheWVyLCB6KSB7XG4gICAgICAgICAgICAgICAgaWYgKGVsQ291bnRzTGFzdEZyYW1lW3pdICE9PSBsYXllci5lbENvdW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGxheWVyLl9fZGlydHkgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBwcm9ncmVzc2l2ZUxheWVycy5sZW5ndGggPSBNYXRoLm1pbihwcm9ncmVzc2l2ZUxheWVyQ291bnQsIE1BWF9QUk9HUkVTU0lWRV9MQVlFUl9OVU1CRVIpO1xuICAgICAgICAgICAgdXRpbC5lYWNoKHByb2dyZXNzaXZlTGF5ZXJzLCBmdW5jdGlvbiAobGF5ZXIsIGlkeCkge1xuICAgICAgICAgICAgICAgIGlmIChwcm9ncmVzc2l2ZUVsQ291bnRzTGFzdEZyYW1lW2lkeF0gIT09IGxheWVyLmVsQ291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgZWwuX19kaXJ0eSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChsYXllci5fX2RpcnR5KSB7XG4gICAgICAgICAgICAgICAgICAgIGxheWVyLl9fcHJvZ3Jlc3MgPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmuIXpmaRob3ZlcuWxguWkluaJgOacieWGheWuuVxuICAgICAgICAgKi9cbiAgICAgICAgY2xlYXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuZWFjaEJ1aWxkaW5MYXllcih0aGlzLl9jbGVhckxheWVyKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9jbGVhckxheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcbiAgICAgICAgICAgIGxheWVyLmNsZWFyKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOS/ruaUueaMh+WumnpsZXZlbOeahOe7mOWItuWPguaVsFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gemxldmVsXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcg6YWN572u5a+56LGhXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY29uZmlnLmNsZWFyQ29sb3I9MF0g5q+P5qyh5riF56m655S75biD55qE6aKc6ImyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY29uZmlnLm1vdGlvbkJsdXI9ZmFsc2VdIOaYr+WQpuW8gOWQr+WKqOaAgeaooeezilxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2NvbmZpZy5sYXN0RnJhbWVBbHBoYT0wLjddXG4gICAgICAgICAqICAgICAgICAgICAgICAgICDlnKjlvIDlkK/liqjmgIHmqKHns4rnmoTml7blgJnkvb/nlKjvvIzkuI7kuIrkuIDluKfmt7flkIjnmoRhbHBoYeWAvO+8jOWAvOi2iuWkp+Wwvui/uei2iuaYjuaYvlxuICAgICAgICAgKi9cbiAgICAgICAgY29uZmlnTGF5ZXI6IGZ1bmN0aW9uICh6bGV2ZWwsIGNvbmZpZykge1xuICAgICAgICAgICAgaWYgKGNvbmZpZykge1xuICAgICAgICAgICAgICAgIHZhciBsYXllckNvbmZpZyA9IHRoaXMuX2xheWVyQ29uZmlnO1xuICAgICAgICAgICAgICAgIGlmICghbGF5ZXJDb25maWdbemxldmVsXSkge1xuICAgICAgICAgICAgICAgICAgICBsYXllckNvbmZpZ1t6bGV2ZWxdID0gY29uZmlnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdXRpbC5tZXJnZShsYXllckNvbmZpZ1t6bGV2ZWxdLCBjb25maWcsIHRydWUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBsYXllciA9IHRoaXMuX2xheWVyc1t6bGV2ZWxdO1xuXG4gICAgICAgICAgICAgICAgaWYgKGxheWVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHV0aWwubWVyZ2UobGF5ZXIsIGxheWVyQ29uZmlnW3psZXZlbF0sIHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5Yig6Zmk5oyH5a6a5bGCXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB6bGV2ZWwg5bGC5omA5Zyo55qEemxldmVsXG4gICAgICAgICAqL1xuICAgICAgICBkZWxMYXllcjogZnVuY3Rpb24gKHpsZXZlbCkge1xuICAgICAgICAgICAgdmFyIGxheWVycyA9IHRoaXMuX2xheWVycztcbiAgICAgICAgICAgIHZhciB6bGV2ZWxMaXN0ID0gdGhpcy5femxldmVsTGlzdDtcbiAgICAgICAgICAgIHZhciBsYXllciA9IGxheWVyc1t6bGV2ZWxdO1xuICAgICAgICAgICAgaWYgKCFsYXllcikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxheWVyLmRvbS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGxheWVyLmRvbSk7XG4gICAgICAgICAgICBkZWxldGUgbGF5ZXJzW3psZXZlbF07XG5cbiAgICAgICAgICAgIHpsZXZlbExpc3Quc3BsaWNlKHV0aWwuaW5kZXhPZih6bGV2ZWxMaXN0LCB6bGV2ZWwpLCAxKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5Yy65Z+f5aSn5bCP5Y+Y5YyW5ZCO6YeN57uYXG4gICAgICAgICAqL1xuICAgICAgICByZXNpemU6IGZ1bmN0aW9uICh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgICAgICB2YXIgZG9tUm9vdCA9IHRoaXMuX2RvbVJvb3Q7XG4gICAgICAgICAgICAvLyBGSVhNRSBXaHkgP1xuICAgICAgICAgICAgZG9tUm9vdC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuXG4gICAgICAgICAgICB3aWR0aCA9IHdpZHRoIHx8IHRoaXMuX2dldFdpZHRoKCk7XG4gICAgICAgICAgICBoZWlnaHQgPSBoZWlnaHQgfHwgdGhpcy5fZ2V0SGVpZ2h0KCk7XG5cbiAgICAgICAgICAgIGRvbVJvb3Quc3R5bGUuZGlzcGxheSA9ICcnO1xuXG4gICAgICAgICAgICAvLyDkvJjljJbmsqHmnInlrp7pmYXmlLnlj5jnmoRyZXNpemVcbiAgICAgICAgICAgIGlmICh0aGlzLl93aWR0aCAhPSB3aWR0aCB8fCBoZWlnaHQgIT0gdGhpcy5faGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgZG9tUm9vdC5zdHlsZS53aWR0aCA9IHdpZHRoICsgJ3B4JztcbiAgICAgICAgICAgICAgICBkb21Sb290LnN0eWxlLmhlaWdodCA9IGhlaWdodCArICdweCc7XG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpZCBpbiB0aGlzLl9sYXllcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbGF5ZXJzW2lkXS5yZXNpemUod2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5yZWZyZXNoKHRydWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl93aWR0aCA9IHdpZHRoO1xuICAgICAgICAgICAgdGhpcy5faGVpZ2h0ID0gaGVpZ2h0O1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5riF6Zmk5Y2V54us55qE5LiA5Liq5bGCXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB6bGV2ZWxcbiAgICAgICAgICovXG4gICAgICAgIGNsZWFyTGF5ZXI6IGZ1bmN0aW9uICh6bGV2ZWwpIHtcbiAgICAgICAgICAgIHZhciBsYXllciA9IHRoaXMuX2xheWVyc1t6bGV2ZWxdO1xuICAgICAgICAgICAgaWYgKGxheWVyKSB7XG4gICAgICAgICAgICAgICAgbGF5ZXIuY2xlYXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog6YeK5pS+XG4gICAgICAgICAqL1xuICAgICAgICBkaXNwb3NlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLnJvb3QuaW5uZXJIVE1MID0gJyc7XG5cbiAgICAgICAgICAgIHRoaXMucm9vdCA9XG4gICAgICAgICAgICB0aGlzLnN0b3JhZ2UgPVxuXG4gICAgICAgICAgICB0aGlzLl9kb21Sb290ID1cbiAgICAgICAgICAgIHRoaXMuX2xheWVycyA9IG51bGw7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCBjYW52YXMgd2hpY2ggaGFzIGFsbCB0aGluZyByZW5kZXJlZFxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuYmFja2dyb3VuZENvbG9yXVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0UmVuZGVyZWRDYW52YXM6IGZ1bmN0aW9uIChvcHRzKSB7XG4gICAgICAgICAgICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9zaW5nbGVDYW52YXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbGF5ZXJzWzBdLmRvbTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGltYWdlTGF5ZXIgPSBuZXcgTGF5ZXIoJ2ltYWdlJywgdGhpcywgb3B0cy5waXhlbFJhdGlvIHx8IHRoaXMuZHByKTtcbiAgICAgICAgICAgIGltYWdlTGF5ZXIuaW5pdENvbnRleHQoKTtcblxuICAgICAgICAgICAgaW1hZ2VMYXllci5jbGVhckNvbG9yID0gb3B0cy5iYWNrZ3JvdW5kQ29sb3I7XG4gICAgICAgICAgICBpbWFnZUxheWVyLmNsZWFyKCk7XG5cbiAgICAgICAgICAgIHZhciBkaXNwbGF5TGlzdCA9IHRoaXMuc3RvcmFnZS5nZXREaXNwbGF5TGlzdCh0cnVlKTtcblxuICAgICAgICAgICAgdmFyIHNjb3BlID0ge307XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpc3BsYXlMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVsID0gZGlzcGxheUxpc3RbaV07XG4gICAgICAgICAgICAgICAgdGhpcy5fZG9QYWludEVsKGVsLCBpbWFnZUxheWVyLCB0cnVlLCBzY29wZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBpbWFnZUxheWVyLmRvbTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOiOt+WPlue7mOWbvuWMuuWfn+WuveW6plxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0V2lkdGg6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl93aWR0aDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog6I635Y+W57uY5Zu+5Yy65Z+f6auY5bqmXG4gICAgICAgICAqL1xuICAgICAgICBnZXRIZWlnaHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9oZWlnaHQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2dldFdpZHRoOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcm9vdCA9IHRoaXMucm9vdDtcbiAgICAgICAgICAgIHZhciBzdGwgPSBkb2N1bWVudC5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKHJvb3QpO1xuXG4gICAgICAgICAgICAvLyBGSVhNRSBCZXR0ZXIgd2F5IHRvIGdldCB0aGUgd2lkdGggYW5kIGhlaWdodCB3aGVuIGVsZW1lbnQgaGFzIG5vdCBiZWVuIGFwcGVuZCB0byB0aGUgZG9jdW1lbnRcbiAgICAgICAgICAgIHJldHVybiAoKHJvb3QuY2xpZW50V2lkdGggfHwgcGFyc2VJbnQxMChzdGwud2lkdGgpIHx8IHBhcnNlSW50MTAocm9vdC5zdHlsZS53aWR0aCkpXG4gICAgICAgICAgICAgICAgICAgIC0gKHBhcnNlSW50MTAoc3RsLnBhZGRpbmdMZWZ0KSB8fCAwKVxuICAgICAgICAgICAgICAgICAgICAtIChwYXJzZUludDEwKHN0bC5wYWRkaW5nUmlnaHQpIHx8IDApKSB8IDA7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2dldEhlaWdodDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHJvb3QgPSB0aGlzLnJvb3Q7XG4gICAgICAgICAgICB2YXIgc3RsID0gZG9jdW1lbnQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZShyb290KTtcblxuICAgICAgICAgICAgcmV0dXJuICgocm9vdC5jbGllbnRIZWlnaHQgfHwgcGFyc2VJbnQxMChzdGwuaGVpZ2h0KSB8fCBwYXJzZUludDEwKHJvb3Quc3R5bGUuaGVpZ2h0KSlcbiAgICAgICAgICAgICAgICAgICAgLSAocGFyc2VJbnQxMChzdGwucGFkZGluZ1RvcCkgfHwgMClcbiAgICAgICAgICAgICAgICAgICAgLSAocGFyc2VJbnQxMChzdGwucGFkZGluZ0JvdHRvbSkgfHwgMCkpIHwgMDtcbiAgICAgICAgfSxcblxuICAgICAgICBfcGF0aFRvSW1hZ2U6IGZ1bmN0aW9uIChpZCwgcGF0aCwgd2lkdGgsIGhlaWdodCwgZHByKSB7XG4gICAgICAgICAgICB2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgICAgICB2YXIgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG5cbiAgICAgICAgICAgIGNhbnZhcy53aWR0aCA9IHdpZHRoICogZHByO1xuICAgICAgICAgICAgY2FudmFzLmhlaWdodCA9IGhlaWdodCAqIGRwcjtcblxuICAgICAgICAgICAgY3R4LmNsZWFyUmVjdCgwLCAwLCB3aWR0aCAqIGRwciwgaGVpZ2h0ICogZHByKTtcblxuICAgICAgICAgICAgdmFyIHBhdGhUcmFuc2Zvcm0gPSB7XG4gICAgICAgICAgICAgICAgcG9zaXRpb246IHBhdGgucG9zaXRpb24sXG4gICAgICAgICAgICAgICAgcm90YXRpb246IHBhdGgucm90YXRpb24sXG4gICAgICAgICAgICAgICAgc2NhbGU6IHBhdGguc2NhbGVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBwYXRoLnBvc2l0aW9uID0gWzAsIDAsIDBdO1xuICAgICAgICAgICAgcGF0aC5yb3RhdGlvbiA9IDA7XG4gICAgICAgICAgICBwYXRoLnNjYWxlID0gWzEsIDFdO1xuICAgICAgICAgICAgaWYgKHBhdGgpIHtcbiAgICAgICAgICAgICAgICBwYXRoLmJydXNoKGN0eCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBJbWFnZVNoYXBlID0gcmVxdWlyZSgnLi9ncmFwaGljL0ltYWdlJyk7XG4gICAgICAgICAgICB2YXIgaW1nU2hhcGUgPSBuZXcgSW1hZ2VTaGFwZSh7XG4gICAgICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICAgICAgICAgIHk6IDAsXG4gICAgICAgICAgICAgICAgICAgIGltYWdlOiBjYW52YXNcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKHBhdGhUcmFuc2Zvcm0ucG9zaXRpb24gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGltZ1NoYXBlLnBvc2l0aW9uID0gcGF0aC5wb3NpdGlvbiA9IHBhdGhUcmFuc2Zvcm0ucG9zaXRpb247XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChwYXRoVHJhbnNmb3JtLnJvdGF0aW9uICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpbWdTaGFwZS5yb3RhdGlvbiA9IHBhdGgucm90YXRpb24gPSBwYXRoVHJhbnNmb3JtLnJvdGF0aW9uO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocGF0aFRyYW5zZm9ybS5zY2FsZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaW1nU2hhcGUuc2NhbGUgPSBwYXRoLnNjYWxlID0gcGF0aFRyYW5zZm9ybS5zY2FsZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGltZ1NoYXBlO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9jcmVhdGVQYXRoVG9JbWFnZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG1lID0gdGhpcztcblxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChpZCwgZSwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtZS5fcGF0aFRvSW1hZ2UoXG4gICAgICAgICAgICAgICAgICAgIGlkLCBlLCB3aWR0aCwgaGVpZ2h0LCBtZS5kcHJcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IFBhaW50ZXI7XG5cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3pyZW5kZXIvbGliL1BhaW50ZXIuanNcbiAqKiBtb2R1bGUgaWQgPSA3M1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBAbW9kdWxlIHpyZW5kZXIvTGF5ZXJcbiAqIEBhdXRob3IgcGlzc2FuZyhodHRwczovL3d3dy5naXRodWIuY29tL3Bpc3NhbmcpXG4gKi9cblxuXG4gICAgdmFyIHV0aWwgPSByZXF1aXJlKCcuL2NvcmUvdXRpbCcpO1xuICAgIHZhciBjb25maWcgPSByZXF1aXJlKCcuL2NvbmZpZycpO1xuICAgIHZhciBTdHlsZSA9IHJlcXVpcmUoJy4vZ3JhcGhpYy9TdHlsZScpO1xuICAgIHZhciBQYXR0ZXJuID0gcmVxdWlyZSgnLi9ncmFwaGljL1BhdHRlcm4nKTtcblxuICAgIGZ1bmN0aW9uIHJldHVybkZhbHNlKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog5Yib5bu6ZG9tXG4gICAgICpcbiAgICAgKiBAaW5uZXJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgZG9tIGlkIOW+heeUqFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIGRvbSB0eXBl77yMc3VjaCBhcyBjYW52YXMsIGRpdiBldGMuXG4gICAgICogQHBhcmFtIHtQYWludGVyfSBwYWludGVyIHBhaW50ZXIgaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbnVtYmVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlRG9tKGlkLCB0eXBlLCBwYWludGVyLCBkcHIpIHtcbiAgICAgICAgdmFyIG5ld0RvbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodHlwZSk7XG4gICAgICAgIHZhciB3aWR0aCA9IHBhaW50ZXIuZ2V0V2lkdGgoKTtcbiAgICAgICAgdmFyIGhlaWdodCA9IHBhaW50ZXIuZ2V0SGVpZ2h0KCk7XG5cbiAgICAgICAgdmFyIG5ld0RvbVN0eWxlID0gbmV3RG9tLnN0eWxlO1xuICAgICAgICAvLyDmsqFhcHBlbmTlkaLvvIzor7fljp/osIXmiJHov5nmoLflhpnvvIzmuIXmmbB+XG4gICAgICAgIG5ld0RvbVN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgICAgbmV3RG9tU3R5bGUubGVmdCA9IDA7XG4gICAgICAgIG5ld0RvbVN0eWxlLnRvcCA9IDA7XG4gICAgICAgIG5ld0RvbVN0eWxlLndpZHRoID0gd2lkdGggKyAncHgnO1xuICAgICAgICBuZXdEb21TdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyAncHgnO1xuICAgICAgICBuZXdEb20ud2lkdGggPSB3aWR0aCAqIGRwcjtcbiAgICAgICAgbmV3RG9tLmhlaWdodCA9IGhlaWdodCAqIGRwcjtcblxuICAgICAgICAvLyBpZOS4jeS9nOS4uue0ouW8leeUqO+8jOmBv+WFjeWPr+iDvemAoOaIkOeahOmHjeWQje+8jOWumuS5ieS4uuengeacieWxnuaAp1xuICAgICAgICBuZXdEb20uc2V0QXR0cmlidXRlKCdkYXRhLXpyLWRvbS1pZCcsIGlkKTtcbiAgICAgICAgcmV0dXJuIG5ld0RvbTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAYWxpYXMgbW9kdWxlOnpyZW5kZXIvTGF5ZXJcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAZXh0ZW5kcyBtb2R1bGU6enJlbmRlci9taXhpbi9UcmFuc2Zvcm1hYmxlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGlkXG4gICAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9QYWludGVyfSBwYWludGVyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtkcHJdXG4gICAgICovXG4gICAgdmFyIExheWVyID0gZnVuY3Rpb24oaWQsIHBhaW50ZXIsIGRwcikge1xuICAgICAgICB2YXIgZG9tO1xuICAgICAgICBkcHIgPSBkcHIgfHwgY29uZmlnLmRldmljZVBpeGVsUmF0aW87XG4gICAgICAgIGlmICh0eXBlb2YgaWQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBkb20gPSBjcmVhdGVEb20oaWQsICdjYW52YXMnLCBwYWludGVyLCBkcHIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5vdCB1c2luZyBpc0RvbSBiZWNhdXNlIGluIG5vZGUgaXQgd2lsbCByZXR1cm4gZmFsc2VcbiAgICAgICAgZWxzZSBpZiAodXRpbC5pc09iamVjdChpZCkpIHtcbiAgICAgICAgICAgIGRvbSA9IGlkO1xuICAgICAgICAgICAgaWQgPSBkb20uaWQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pZCA9IGlkO1xuICAgICAgICB0aGlzLmRvbSA9IGRvbTtcblxuICAgICAgICB2YXIgZG9tU3R5bGUgPSBkb20uc3R5bGU7XG4gICAgICAgIGlmIChkb21TdHlsZSkgeyAvLyBOb3QgaW4gbm9kZVxuICAgICAgICAgICAgZG9tLm9uc2VsZWN0c3RhcnQgPSByZXR1cm5GYWxzZTsgLy8g6YG/5YWN6aG16Z2i6YCJ5Lit55qE5bC05bCsXG4gICAgICAgICAgICBkb21TdHlsZVsnLXdlYmtpdC11c2VyLXNlbGVjdCddID0gJ25vbmUnO1xuICAgICAgICAgICAgZG9tU3R5bGVbJ3VzZXItc2VsZWN0J10gPSAnbm9uZSc7XG4gICAgICAgICAgICBkb21TdHlsZVsnLXdlYmtpdC10b3VjaC1jYWxsb3V0J10gPSAnbm9uZSc7XG4gICAgICAgICAgICBkb21TdHlsZVsnLXdlYmtpdC10YXAtaGlnaGxpZ2h0LWNvbG9yJ10gPSAncmdiYSgwLDAsMCwwKSc7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmRvbUJhY2sgPSBudWxsO1xuICAgICAgICB0aGlzLmN0eEJhY2sgPSBudWxsO1xuXG4gICAgICAgIHRoaXMucGFpbnRlciA9IHBhaW50ZXI7XG5cbiAgICAgICAgdGhpcy5jb25maWcgPSBudWxsO1xuXG4gICAgICAgIC8vIENvbmZpZ3NcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOavj+asoea4heepuueUu+W4g+eahOminOiJslxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKiBAZGVmYXVsdCAwXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNsZWFyQ29sb3IgPSAwO1xuICAgICAgICAvKipcbiAgICAgICAgICog5piv5ZCm5byA5ZCv5Yqo5oCB5qih57OKXG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5tb3Rpb25CbHVyID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlnKjlvIDlkK/liqjmgIHmqKHns4rnmoTml7blgJnkvb/nlKjvvIzkuI7kuIrkuIDluKfmt7flkIjnmoRhbHBoYeWAvO+8jOWAvOi2iuWkp+Wwvui/uei2iuaYjuaYvlxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKiBAZGVmYXVsdCAwLjdcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubGFzdEZyYW1lQWxwaGEgPSAwLjc7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIExheWVyIGRwclxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kcHIgPSBkcHI7XG4gICAgfTtcblxuICAgIExheWVyLnByb3RvdHlwZSA9IHtcblxuICAgICAgICBjb25zdHJ1Y3RvcjogTGF5ZXIsXG5cbiAgICAgICAgZWxDb3VudDogMCxcblxuICAgICAgICBfX2RpcnR5OiB0cnVlLFxuXG4gICAgICAgIGluaXRDb250ZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLmN0eCA9IHRoaXMuZG9tLmdldENvbnRleHQoJzJkJyk7XG5cbiAgICAgICAgICAgIHRoaXMuY3R4LmRwciA9IHRoaXMuZHByO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNyZWF0ZUJhY2tCdWZmZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBkcHIgPSB0aGlzLmRwcjtcblxuICAgICAgICAgICAgdGhpcy5kb21CYWNrID0gY3JlYXRlRG9tKCdiYWNrLScgKyB0aGlzLmlkLCAnY2FudmFzJywgdGhpcy5wYWludGVyLCBkcHIpO1xuICAgICAgICAgICAgdGhpcy5jdHhCYWNrID0gdGhpcy5kb21CYWNrLmdldENvbnRleHQoJzJkJyk7XG5cbiAgICAgICAgICAgIGlmIChkcHIgIT0gMSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY3R4QmFjay5zY2FsZShkcHIsIGRwcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gd2lkdGhcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSBoZWlnaHRcbiAgICAgICAgICovXG4gICAgICAgIHJlc2l6ZTogZnVuY3Rpb24gKHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgICAgIHZhciBkcHIgPSB0aGlzLmRwcjtcblxuICAgICAgICAgICAgdmFyIGRvbSA9IHRoaXMuZG9tO1xuICAgICAgICAgICAgdmFyIGRvbVN0eWxlID0gZG9tLnN0eWxlO1xuICAgICAgICAgICAgdmFyIGRvbUJhY2sgPSB0aGlzLmRvbUJhY2s7XG5cbiAgICAgICAgICAgIGRvbVN0eWxlLndpZHRoID0gd2lkdGggKyAncHgnO1xuICAgICAgICAgICAgZG9tU3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgJ3B4JztcblxuICAgICAgICAgICAgZG9tLndpZHRoID0gd2lkdGggKiBkcHI7XG4gICAgICAgICAgICBkb20uaGVpZ2h0ID0gaGVpZ2h0ICogZHByO1xuXG4gICAgICAgICAgICBpZiAoZG9tQmFjaykge1xuICAgICAgICAgICAgICAgIGRvbUJhY2sud2lkdGggPSB3aWR0aCAqIGRwcjtcbiAgICAgICAgICAgICAgICBkb21CYWNrLmhlaWdodCA9IGhlaWdodCAqIGRwcjtcblxuICAgICAgICAgICAgICAgIGlmIChkcHIgIT0gMSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmN0eEJhY2suc2NhbGUoZHByLCBkcHIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5riF56m66K+l5bGC55S75biDXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gY2xlYXJBbGwgQ2xlYXIgYWxsIHdpdGggb3V0IG1vdGlvbiBibHVyXG4gICAgICAgICAqL1xuICAgICAgICBjbGVhcjogZnVuY3Rpb24gKGNsZWFyQWxsKSB7XG4gICAgICAgICAgICB2YXIgZG9tID0gdGhpcy5kb207XG4gICAgICAgICAgICB2YXIgY3R4ID0gdGhpcy5jdHg7XG4gICAgICAgICAgICB2YXIgd2lkdGggPSBkb20ud2lkdGg7XG4gICAgICAgICAgICB2YXIgaGVpZ2h0ID0gZG9tLmhlaWdodDtcblxuICAgICAgICAgICAgdmFyIGNsZWFyQ29sb3IgPSB0aGlzLmNsZWFyQ29sb3I7XG4gICAgICAgICAgICB2YXIgaGF2ZU1vdGlvbkJMdXIgPSB0aGlzLm1vdGlvbkJsdXIgJiYgIWNsZWFyQWxsO1xuICAgICAgICAgICAgdmFyIGxhc3RGcmFtZUFscGhhID0gdGhpcy5sYXN0RnJhbWVBbHBoYTtcblxuICAgICAgICAgICAgdmFyIGRwciA9IHRoaXMuZHByO1xuXG4gICAgICAgICAgICBpZiAoaGF2ZU1vdGlvbkJMdXIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuZG9tQmFjaykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNyZWF0ZUJhY2tCdWZmZXIoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLmN0eEJhY2suZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gJ2NvcHknO1xuICAgICAgICAgICAgICAgIHRoaXMuY3R4QmFjay5kcmF3SW1hZ2UoXG4gICAgICAgICAgICAgICAgICAgIGRvbSwgMCwgMCxcbiAgICAgICAgICAgICAgICAgICAgd2lkdGggLyBkcHIsXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodCAvIGRwclxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgICBpZiAoY2xlYXJDb2xvcikge1xuICAgICAgICAgICAgICAgIHZhciBjbGVhckNvbG9yR3JhZGllbnRPclBhdHRlcm47XG4gICAgICAgICAgICAgICAgLy8gR3JhZGllbnRcbiAgICAgICAgICAgICAgICBpZiAoY2xlYXJDb2xvci5jb2xvclN0b3BzKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIENhY2hlIGNhbnZhcyBncmFkaWVudFxuICAgICAgICAgICAgICAgICAgICBjbGVhckNvbG9yR3JhZGllbnRPclBhdHRlcm4gPSBjbGVhckNvbG9yLl9fY2FudmFzR3JhZGllbnQgfHwgU3R5bGUuZ2V0R3JhZGllbnQoY3R4LCBjbGVhckNvbG9yLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgeTogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIGNsZWFyQ29sb3IuX19jYW52YXNHcmFkaWVudCA9IGNsZWFyQ29sb3JHcmFkaWVudE9yUGF0dGVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gUGF0dGVyblxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNsZWFyQ29sb3IuaW1hZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJDb2xvckdyYWRpZW50T3JQYXR0ZXJuID0gUGF0dGVybi5wcm90b3R5cGUuZ2V0Q2FudmFzUGF0dGVybi5jYWxsKGNsZWFyQ29sb3IsIGN0eCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGNsZWFyQ29sb3JHcmFkaWVudE9yUGF0dGVybiB8fCBjbGVhckNvbG9yO1xuICAgICAgICAgICAgICAgIGN0eC5maWxsUmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaGF2ZU1vdGlvbkJMdXIpIHtcbiAgICAgICAgICAgICAgICB2YXIgZG9tQmFjayA9IHRoaXMuZG9tQmFjaztcbiAgICAgICAgICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICAgICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IGxhc3RGcmFtZUFscGhhO1xuICAgICAgICAgICAgICAgIGN0eC5kcmF3SW1hZ2UoZG9tQmFjaywgMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IExheWVyO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34venJlbmRlci9saWIvTGF5ZXIuanNcbiAqKiBtb2R1bGUgaWQgPSA3NFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXHJcbiAgICB2YXIgTm9kZSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9maXNoLXRvcG8tY29yZS9saWIvTm9kZVwiKTtcclxuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcclxuICAgIHZhciBCb3VuZGluZ1JlY3QgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL0JvdW5kaW5nUmVjdC5qcycpO1xyXG4gICAgdmFyIGdyYXBoaWMgPSByZXF1aXJlKFwiLi4vLi4vLi4vZmlzaC10b3BvLWNvcmUvbGliL2dyYXBoaWMuanNcIik7XHJcbiAgICB2YXIgdXRpbCA9IHJlcXVpcmUoXCIuLi8uLi8uLi9maXNoLXRvcG8tY29yZS9saWIvdXRpbC5qc1wiKTtcclxuICAgIHZhciBDb25uZWN0b3IgPSByZXF1aXJlKFwiLi4vLi4vLi4vZmlzaC10b3BvLWNvcmUvbGliL3NoYXBlcy9Db25uZWN0b3IuanNcIik7XHJcbiAgICAvL+WIm+W7uk5vZGXnsbsg5omA5pyJ5b2i54q26YO957un5om/Tm9kZVxyXG4gICAgLy9cclxuICAgIGZ1bmN0aW9uIEdyb3VwTm9kZShtb2RlbCwgYXBpKSB7XHJcblxyXG4gICAgICAgIE5vZGUuY2FsbCh0aGlzLCBtb2RlbCwgYXBpKTtcclxuICAgICAgICB0aGlzLmJwbW5JbmZvID0ge3R5cGU6IC0xLCBuYW1lOlwiR3JvdXBOb2RlXCIgfTsgICAgLy/oioLngrnkv6Hmga9cclxuICAgICAgICB0aGlzLm1vZGVsID0gbW9kZWw7XHJcbiAgICAgICAgdmFyIGRlZmF1bHRPcHRpb25zID0ge1xyXG4gICAgICAgICAgICAgICAgc2hhcGU6IHtcclxuICAgICAgICAgICAgICAgICAgICB3aWR0aDowLFxyXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDowLFxyXG4gICAgICAgICAgICAgICAgICAgIHI6IDdcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBzdHlsZToge1xyXG4gICAgICAgICAgICAgICAgICAgIGZpbGw6ICcjZjlmOWY5JyxcclxuICAgICAgICAgICAgICAgICAgICBzdHJva2U6ICcjYmJiYmJiJ1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHBvc2l0aW9uOlswLDBdXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5vcHRpb25zID0genJVdGlsLmV4dGVuZChkZWZhdWx0T3B0aW9ucywgbW9kZWwpO1xyXG4gICAgICAgIHRoaXMuaXNkcmFnZ2FibGUgPSB0aGlzLm9wdGlvbnMuaXNkcmFnZ2FibGU7XHJcbiAgICAgICAgdGhpcy5tYXggPSBbMTAyNCw5NjBdO1xyXG4gICAgICAgIHRoaXMucmVuZGVyKHRoaXMub3B0aW9ucyk7XHJcbiAgICB9XHJcblxyXG4gICAgR3JvdXBOb2RlLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbihtb2RlbCkge1xyXG4gICAgICAgIHZhciByZWN0ID0gbmV3IGdyYXBoaWMuUmVjdCh7XHJcbiAgICAgICAgICAgIHNoYXBlOiBtb2RlbC5zaGFwZSxcclxuICAgICAgICAgICAgc3R5bGU6IG1vZGVsLnN0eWxlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmVjdC5uYW1lID0gXCJSZWN0XCI7XHJcbiAgICAgICAgdGhpcy5hZGQocmVjdCk7XHJcbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IG1vZGVsLnBvc2l0aW9uO1xyXG4gICAgICAgIHRoaXMubWVyZ2VkSW1hZ2UgPSBtb2RlbC5tZXJnZWRJbWFnZTtcclxuICAgIH07XHJcblxyXG4gICAgR3JvdXBOb2RlLnByb3RvdHlwZS5mcm9tSlNPTiA9IGZ1bmN0aW9uKGpzb24pIHtcclxuICAgICAgICAvLyBib2R5Li4uXHJcblxyXG5cclxuICAgIH07XHJcblxyXG4gICAgR3JvdXBOb2RlLnByb3RvdHlwZS5yZWN0Q29udGFpbiA9IGZ1bmN0aW9uKHgsIHkpIHtcclxuICAgICAgICB2YXIgcmVjdCA9IHV0aWwuZ2V0UmVjdCh0aGlzKTtcclxuICAgICAgICByZXR1cm4gcmVjdC5ib3VuZGluZ1JlY3QuY29udGFpbih4LHkpO1xyXG4gICAgfTtcclxuXHJcbiAgICBHcm91cE5vZGUucHJvdG90eXBlLmdldFJlY3QgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAvLyBib2R5Li4uXHJcbiAgICAgICAgdmFyIGJvdW5kaW5nUmVjdCA9IHRoaXMuZ2V0Qm91bmRpbmdSZWN0KCk7XHJcbiAgICAgICAgLy/liJvlu7rmnIDlsI/ljIXlm7Tnm5LomZrnur9cclxuICAgICAgICB2YXIgcG9pbnRzID0gW107XHJcbiAgICAgICAgcG9pbnRzWzBdID1bLWJvdW5kaW5nUmVjdC53aWR0aC8yLC1ib3VuZGluZ1JlY3QuaGVpZ2h0LzJdO1xyXG4gICAgICAgIHBvaW50c1sxXSA9W2JvdW5kaW5nUmVjdC53aWR0aC8yLC1ib3VuZGluZ1JlY3QuaGVpZ2h0LzJdO1xyXG4gICAgICAgIHBvaW50c1syXSA9W2JvdW5kaW5nUmVjdC53aWR0aC8yLGJvdW5kaW5nUmVjdC5oZWlnaHQvMl07XHJcbiAgICAgICAgcG9pbnRzWzNdID1bLWJvdW5kaW5nUmVjdC53aWR0aC8yLGJvdW5kaW5nUmVjdC5oZWlnaHQvMl07XHJcbiAgICAgICAgcG9pbnRzWzRdID1bLWJvdW5kaW5nUmVjdC53aWR0aC8yLC1ib3VuZGluZ1JlY3QuaGVpZ2h0LzJdO1xyXG5cclxuICAgICAgICB2YXIgYm91bmRSZWN0ID0gbmV3IEJvdW5kaW5nUmVjdCh0aGlzLnBvc2l0aW9uWzBdICxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBvc2l0aW9uWzFdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvdW5kaW5nUmVjdC53aWR0aCwgYm91bmRpbmdSZWN0LmhlaWdodCk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgeDogdGhpcy5wb3NpdGlvblswXStib3VuZGluZ1JlY3Qud2lkdGgvMixcclxuICAgICAgICAgICAgeTogdGhpcy5wb3NpdGlvblsxXStib3VuZGluZ1JlY3QuaGVpZ2h0LzIsXHJcbiAgICAgICAgICAgIHdpZHRoOiBib3VuZGluZ1JlY3Qud2lkdGgsXHJcbiAgICAgICAgICAgIGhlaWdodDogYm91bmRpbmdSZWN0LmhlaWdodCxcclxuICAgICAgICAgICAgcG9pbnRzOiBwb2ludHMsXHJcbiAgICAgICAgICAgIGJvdW5kaW5nUmVjdDogYm91bmRSZWN0XHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcblxyXG4gICAgR3JvdXBOb2RlLnByb3RvdHlwZS5yZURyYXcgPSBmdW5jdGlvbihub2RlTWVzc2FnZSxub2RlLG5vd0dyb3VwUG9zaXRpb24pIHtcclxuICAgICAgICAvL+mHjee9ruiDjOaZr3JlY3Qg55qE6ZW/5a69XHJcbiAgICAgICAgdmFyIG1pbkxlbmd0aCA9IHRoaXMub3B0aW9ucy5zaGFwZS5yO1xyXG4gICAgICAgIHRoaXMuc2V0UHJvcGVydGllcyh7XHJcbiAgICAgICAgICAgIHNoYXBlOntcclxuICAgICAgICAgICAgICAgICAgICB3aWR0aDptaW5MZW5ndGgsXHJcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0Om1pbkxlbmd0aCxcclxuICAgICAgICAgICAgICAgICAgICByOiBtaW5MZW5ndGhcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHZhciBncm91cFBvc2l0aW9uID0genJVdGlsLmNsb25lKHRoaXMucG9zaXRpb24pO1xyXG4gICAgICAgIHZhciByZWN0ID0gdGhpcy5jaGlsZE9mTmFtZShcIlJlY3RcIik7XHJcbiAgICAgICAgdmFyIHdpZHRoID0gdGhpcy5nZXRCb3VuZGluZ1JlY3QoKS53aWR0aDtcclxuICAgICAgICB2YXIgaGVpZ2h0ID0gdGhpcy5nZXRCb3VuZGluZ1JlY3QoKS5oZWlnaHQ7XHJcbiAgICAgICAgdmFyIHJ4ID0gcmVjdC5zaGFwZS54LHJ5ID0gcmVjdC5zaGFwZS55O1xyXG4gICAgICAgIC8v5Y+WZ3JvdXDkuK3miYDmnInoioLngrnmnIDpnaDkuIrovrnlkozmnIDpq5jlt6bovrnnmoTlgLzvvIzkuI3ljIXmi6zog4zmma9yZWN055qE5YC8XHJcbiAgICAgICAgdmFyIG1pblggPSB0aGlzLl9jaGlsZHJlblsxXS5wb3NpdGlvblswXSxtaW5ZID0gdGhpcy5fY2hpbGRyZW5bMV0ucG9zaXRpb25bMV07XHJcbiAgICAgICAgdmFyIG1heFggPSB0aGlzLl9jaGlsZHJlblsxXS5wb3NpdGlvblswXSxtYXhZID0gdGhpcy5fY2hpbGRyZW5bMV0ucG9zaXRpb25bMV07XHJcbiAgICAgICAgdmFyIGxpbmVOb2RlID0gW107XHJcbiAgICAgICAgdmFyIG5vd0dyb3VwUG9zaXRpb24gPSB6clV0aWwuY2xvbmUobm9kZU1lc3NhZ2UucG9zaXRpb24pO1xyXG4gICAgICAgIGZvcih2YXIgaSA9IDE7IGk8dGhpcy5fY2hpbGRyZW4ubGVuZ3RoO2krKyl7XHJcbiAgICAgICAgICAgIGlmKHRoaXMuX2NoaWxkcmVuW2ldIGluc3RhbmNlb2YgQ29ubmVjdG9yIHx8IHRoaXMuX2NoaWxkcmVuW2ldLmlzSWNvbiA9PSB0cnVlKXtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgICAgIGlmKG1pblg+dGhpcy5fY2hpbGRyZW5baV0ucG9zaXRpb25bMF0pe1xyXG4gICAgICAgICAgICAgICAgICAgIG1pblggPSB0aGlzLl9jaGlsZHJlbltpXS5wb3NpdGlvblswXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmKG1heFg8dGhpcy5fY2hpbGRyZW5baV0ucG9zaXRpb25bMF0pe1xyXG4gICAgICAgICAgICAgICAgICAgIG1heFggPSB0aGlzLl9jaGlsZHJlbltpXS5wb3NpdGlvblswXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yKHZhciBqID0gMTsgajx0aGlzLl9jaGlsZHJlbi5sZW5ndGg7aisrKXtcclxuICAgICAgICAgICAgaWYodGhpcy5fY2hpbGRyZW5bal0gaW5zdGFuY2VvZiBDb25uZWN0b3IgfHwgdGhpcy5fY2hpbGRyZW5bal0uaXNJY29uID09IHRydWUpe1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICAgICAgaWYobWluWT50aGlzLl9jaGlsZHJlbltqXS5wb3NpdGlvblsxXSl7XHJcbiAgICAgICAgICAgICAgICAgICAgbWluWSA9IHRoaXMuX2NoaWxkcmVuW2pdLnBvc2l0aW9uWzFdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYobWF4WTx0aGlzLl9jaGlsZHJlbltqXS5wb3NpdGlvblsxXSl7XHJcbiAgICAgICAgICAgICAgICAgICAgbWF4WSA9IHRoaXMuX2NoaWxkcmVuW2pdLnBvc2l0aW9uWzFdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmKHdpZHRoID4gdGhpcy5tYXhbMF0pe1xyXG4gICAgICAgICAgICB3aWR0aCA9IHRoaXMubWF4WzBdLTI7XHJcbiAgICAgICAgICAgIGlmKG5vZGVNZXNzYWdlLnBvc2l0aW9uWzBdPm1pblgpe1xyXG4gICAgICAgICAgICAgICAgbm93R3JvdXBQb3NpdGlvblswXSA9IG1pblgrdGhpcy5tYXhbMF0tbm9kZU1lc3NhZ2Uud2lkdGg7XHJcbiAgICAgICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICAgICAgbm93R3JvdXBQb3NpdGlvblswXSA9IG1heFgtdGhpcy5tYXhbMF0rbm9kZU1lc3NhZ2Uud2lkdGg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgLy/np7vliqjoioLngrnmlLnlj5hncm91cOS4reiDjOaZr3JlY3TnmoR45L2N572u77yM5LiN6LaF6L+H5pyA5bCP55qE5YC8XHJcbiAgICAgICAgICAgIHJ4ID0gdGhpcy5jaGlsZE9mTmFtZShcIlJlY3RcIikucG9zaXRpb25bMF0rKG5vZGVNZXNzYWdlLnBvc2l0aW9uWzBdKTtcclxuICAgICAgICAgICAgaWYocng+bWluWCl7XHJcbiAgICAgICAgICAgICAgICByeCA9IG1pblg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbm93R3JvdXBQb3NpdGlvblswXSA9IG5vZGVNZXNzYWdlLm1vdmVQb3NpdGlvblswXStub2RlTWVzc2FnZS5tb3ZlWDtcclxuICAgICAgICAgICAgaWYobm9kZU1lc3NhZ2UucG9zaXRpb25bMF0+bWluWCl7XHJcbiAgICAgICAgICAgICAgICBpZihub3dHcm91cFBvc2l0aW9uWzBdPm1pblgrdGhpcy5tYXhbMF0tbm9kZU1lc3NhZ2Uud2lkdGgpe1xyXG4gICAgICAgICAgICAgICAgICAgIG5vd0dyb3VwUG9zaXRpb25bMF0gPSBtaW5YK3RoaXMubWF4WzBdLW5vZGVNZXNzYWdlLndpZHRoO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgICAgIGlmKG5vd0dyb3VwUG9zaXRpb25bMF0gPCBtYXhYLXRoaXMubWF4WzBdK25vZGVNZXNzYWdlLndpZHRoKXtcclxuICAgICAgICAgICAgICAgICAgICBub3dHcm91cFBvc2l0aW9uWzBdID0gbWF4WC10aGlzLm1heFswXStub2RlTWVzc2FnZS53aWR0aFxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmKGhlaWdodCA+IHRoaXMubWF4WzFdKXtcclxuICAgICAgICAgICAgaGVpZ2h0ID0gdGhpcy5tYXhbMV0tMjtcclxuICAgICAgICAgICAgaWYobm9kZU1lc3NhZ2UucG9zaXRpb25bMV0+bWluWSl7XHJcbiAgICAgICAgICAgICAgICBub3dHcm91cFBvc2l0aW9uWzFdID0gbWluWSt0aGlzLm1heFsxXS1ub2RlTWVzc2FnZS5oZWlnaHQ7XHJcbiAgICAgICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICAgICAgbm93R3JvdXBQb3NpdGlvblsxXSA9IG1heFktdGhpcy5tYXhbMV0rbm9kZU1lc3NhZ2UuaGVpZ2h0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgIC8v56e75Yqo6IqC54K55pS55Y+YZ3JvdXDkuK3og4zmma9yZWN055qEeeS9jee9ru+8jOS4jei2hei/h+acgOWwj+eahOWAvFxyXG4gICAgICAgICAgICByeSA9IHRoaXMuY2hpbGRPZk5hbWUoXCJSZWN0XCIpLnBvc2l0aW9uWzFdKyhub2RlTWVzc2FnZS5wb3NpdGlvblsxXSk7XHJcbiAgICAgICAgICAgIGlmKHJ5Pm1pblkpe1xyXG4gICAgICAgICAgICAgICAgcnkgPSBtaW5ZO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG5vd0dyb3VwUG9zaXRpb25bMV0gPSBub2RlTWVzc2FnZS5tb3ZlUG9zaXRpb25bMV0rbm9kZU1lc3NhZ2UubW92ZVk7XHJcbiAgICAgICAgICAgIGlmKG5vZGVNZXNzYWdlLnBvc2l0aW9uWzFdPm1pblkpe1xyXG4gICAgICAgICAgICAgICAgaWYobm93R3JvdXBQb3NpdGlvblsxXT5taW5ZK3RoaXMubWF4WzFdLW5vZGVNZXNzYWdlLmhlaWdodCl7XHJcbiAgICAgICAgICAgICAgICAgICAgbm93R3JvdXBQb3NpdGlvblsxXSA9IG1pblkrdGhpcy5tYXhbMV0tbm9kZU1lc3NhZ2UuaGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgICAgIGlmKG5vd0dyb3VwUG9zaXRpb25bMV0gPCBtYXhZLXRoaXMubWF4WzFdK25vZGVNZXNzYWdlLmhlaWdodCl7XHJcbiAgICAgICAgICAgICAgICAgICAgbm93R3JvdXBQb3NpdGlvblsxXSA9IG1heFktdGhpcy5tYXhbMV0rbm9kZU1lc3NhZ2UuaGVpZ2h0XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYobm9kZS5hbGFybSl7XHJcbiAgICAgICAgICAgIHZhciBuZXdBbGFybVBvc2l0aW9uID0gW25vd0dyb3VwUG9zaXRpb25bMF0rbm9kZS5nZXRCb3VuZGluZ1JlY3QoKS53aWR0aC0obm9kZS5hbGFybS5nZXRCb3VuZGluZ1JlY3QoKS53aWR0aC02KSxub3dHcm91cFBvc2l0aW9uWzFdLW5vZGUuYWxhcm0uZ2V0Qm91bmRpbmdSZWN0KCkuaGVpZ2h0LTNdO1xyXG4gICAgICAgICAgICBub2RlLmFsYXJtLmF0dHIoXCJwb3NpdGlvblwiLG5ld0FsYXJtUG9zaXRpb24pO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvL+aUueWPmOiDjOaZr3JlY3TnmoTplb/lrr3lkozkvY3nva5cclxuICAgICAgICB0aGlzLnNldFByb3BlcnRpZXMoe1xyXG4gICAgICAgICAgICBzaGFwZTp7XHJcbiAgICAgICAgICAgICAgICB3aWR0aDp3aWR0aCxcclxuICAgICAgICAgICAgICAgIGhlaWdodDpoZWlnaHQsXHJcbiAgICAgICAgICAgICAgICB4OnJ4LFxyXG4gICAgICAgICAgICAgICAgeTpyeVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgfTtcclxuICAgIEdyb3VwTm9kZS5wcm90b3R5cGUuc2V0UHJvcGVydGllcyA9IGZ1bmN0aW9uKG9wdCkge1xyXG4gICAgICAgIHZhciByZWN0ID0gdGhpcy5jaGlsZE9mTmFtZShcIlJlY3RcIik7XHJcbiAgICAgICAgcmVjdC5zZXRTaGFwZShvcHQuc2hhcGUpO1xyXG4gICAgICAgIHJlY3QuYXR0cihcInN0eWxlXCIsb3B0LnN0eWxlKTtcclxuICAgICAgICB0aGlzLmF0dHIoJ3Bvc2l0aW9uJyxvcHQucG9zaXRpb24pO1xyXG4gICAgICAgIHRoaXMuYXR0cihcInNoYXBlXCIsb3B0LnNoYXBlKTtcclxuICAgIH07XHJcblxyXG4gICAgLy/nu4TnmoTlkIjlubbkuI7mlL7lvIBcclxuICAgIEdyb3VwTm9kZS5wcm90b3R5cGUubWVyZ2VkID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgICAgIGlmKCF0aGlzLm1lcmdlZEltYWdlKXtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvL+S/neeVmWdyb3Vw55qE5Yid5aeL5L2N572uXHJcbiAgICAgICAgdmFyIGdyb3VwUG9zaXRpb24gPSB6clV0aWwuY2xvbmUodGhpcy5wb3NpdGlvbik7XHJcbiAgICAgICAgLy/nu5nlsI/lm77niYforr7nva7lsZ7mgKfvvIzpmpDol49ncm91cFxyXG4gICAgICAgIHZhciB3aWR0aCA9IHRoaXMucmVsYXRpb25JbWFnZS5nZXRCb3VuZGluZ1JlY3QoKS53aWR0aDtcclxuICAgICAgICB2YXIgaGVpZ2h0ID0gdGhpcy5yZWxhdGlvbkltYWdlLmdldEJvdW5kaW5nUmVjdCgpLmhlaWdodDtcclxuICAgICAgICAvL+iuoeeul+WQiOW5tuWQjueahOWwj+WbvueJh+eahHBvc2l0aW9uXHJcbiAgICAgICAgdmFyIHJlbGF0aW9uSW1hZ2VQb3NpdGlvbiA9IFt0aGlzLnBvc2l0aW9uWzBdK3RoaXMuY2hpbGRPZk5hbWUoXCJSZWN0XCIpLnNoYXBlLngrKHRoaXMuZ2V0Qm91bmRpbmdSZWN0KCkud2lkdGgvMi13aWR0aC8yKSx0aGlzLnBvc2l0aW9uWzFdK3RoaXMuY2hpbGRPZk5hbWUoXCJSZWN0XCIpLnNoYXBlLnkrKHRoaXMuZ2V0Qm91bmRpbmdSZWN0KCkuaGVpZ2h0LzItaGVpZ2h0LzIpXTtcclxuICAgICAgICAvL+WwhuWwj+WbvueJh+eahOS9jee9ruS/neeVmeS4i+adpVxyXG4gICAgICAgIHZhciBjbG9uZUltYWdlUG9zaXRpb24gPSB6clV0aWwuY2xvbmUocmVsYXRpb25JbWFnZVBvc2l0aW9uKTtcclxuICAgICAgICB0aGlzLnJlbGF0aW9uSW1hZ2UuYXR0cihcInN0eWxlXCIse2ltYWdlOnRoaXMubWVyZ2VkSW1hZ2Usd2lkdGg6d2lkdGgsaGVpZ2h0OmhlaWdodH0pO1xyXG4gICAgICAgIHRoaXMucmVsYXRpb25JbWFnZS5hdHRyKFwicG9zaXRpb25cIixyZWxhdGlvbkltYWdlUG9zaXRpb24pO1xyXG4gICAgICAgIGlmKHdpZHRoPjAmJmhlaWdodD4wKXtcclxuICAgICAgICAgICAgdGhpcy5oaWRlKCk7XHJcbiAgICAgICAgICAgIHRoaXMucmVsYXRpb25JbWFnZS5zaG93KCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL+WPjOWHu+WbvueJh+aUvuWHuue7hFxyXG4gICAgICAgIHRoaXMucmVsYXRpb25JbWFnZS5vbihcImRibGNsaWNrXCIsZnVuY3Rpb24oKXtcclxuICAgICAgICAgICAgdGhhdC5zZXRQcm9wZXJ0aWVzKHtcclxuICAgICAgICAgICAgICAgIC8v6K6+572u57uE55qE5L2N572u5qC55o2u5bCP5Zu+54mH55qE5YGP56e76YeP5p2l6K6h566XXHJcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjpbZ3JvdXBQb3NpdGlvblswXSsodGhpcy5wb3NpdGlvblswXS1jbG9uZUltYWdlUG9zaXRpb25bMF0pLGdyb3VwUG9zaXRpb25bMV0rKHRoaXMucG9zaXRpb25bMV0tY2xvbmVJbWFnZVBvc2l0aW9uWzFdKV1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHRoaXMuaGlkZSgpO1xyXG4gICAgICAgICAgICB0aGF0LnNob3coKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gdGhpcy5yZWxhdGlvbkltYWdlO1xyXG4gICAgfTtcclxuXHJcbiAgICB6clV0aWwuaW5oZXJpdHMoR3JvdXBOb2RlLE5vZGUpO1xyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBHcm91cE5vZGU7XHJcblxyXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vbGliL2Zpc2gtdG9wby1mbG93L2xpYi9ub2RlL0dyb3VwTm9kZS5qc1xuICoqIG1vZHVsZSBpZCA9IDc1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcclxuICAgIHZhciBncmFwaGljID0gcmVxdWlyZSgnLi9ncmFwaGljJyk7XHJcbiAgICB2YXIgdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWwuanNcIilcclxuICAgIC8v5Yib5bu6Tm9kZeexuyDmiYDmnInlvaLnirbpg73nu6fmib9Ob2RlICDljIXmi6xmcm9tSlNPTiB0b0pTT05cclxuICAgIGZ1bmN0aW9uIE5vZGUoKSB7XHJcbiAgICAgICAgdGhpcy5yZXNvdXJjZUlkID0gdXRpbC5nZXRVVUlEKCk7IC8vIOeUn+aIkOiKgueCuUlEXHJcbiAgICAgICAgZ3JhcGhpYy5Hcm91cC5jYWxsKHRoaXMpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog55Sx54i257G75a6e546wXHJcbiAgICAgKiBAcmV0dXJuIHtbdHlwZV19IFtkZXNjcmlwdGlvbl1cclxuICAgICAqL1xyXG4gICAgTm9kZS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24oKSB7fTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIOeUseeItuexu+WunueOsFxyXG4gICAgICogQHBhcmFtICB7W3R5cGVdfSBqc29uIFtkZXNjcmlwdGlvbl1cclxuICAgICAqIEByZXR1cm4ge1t0eXBlXX0gICAgICBbZGVzY3JpcHRpb25dXHJcbiAgICAgKi9cclxuICAgIE5vZGUucHJvdG90eXBlLmdldFJlY3QgPSBmdW5jdGlvbihqc29uKSB7fTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIGRyYXdUZXh0XHJcbiAgICAgKiBAZGVzY3JpcHRpb24g55S75LiA5Liq5paH5pysXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbG9yXHJcbiAgICAgKi9cclxuICAgIE5vZGUucHJvdG90eXBlLmRyYXdUZXh0ID0gZnVuY3Rpb24obmFtZSxjb2xvcikge1xyXG4gICAgICAgIHZhciB0ZXh0TmFtZSA9IHRoaXMuYnBtbkluZm8ubmFtZTtcclxuICAgICAgICBpZihuYW1lICE9IG51bGwpe1xyXG4gICAgICAgICAgICB0ZXh0TmFtZSA9IG5hbWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciB0ZXh0ID0gbmV3IGdyYXBoaWMuVGV4dCh7XHJcbiAgICAgICAgICAgIHN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgICB0ZXh0OiB0ZXh0TmFtZSxcclxuICAgICAgICAgICAgICAgIGNvbG9yOiBjb2xvciA/IGNvbG9yIDogdGhpcy5vcHRpb25zLnRleHQuY29sb3IsXHJcbiAgICAgICAgICAgICAgICB0ZXh0Rm9udDogJzEycHggTWljcm9zb2Z0IFlhSGVpJ1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB6bGV2ZWw6IDIwXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLy/mloflrZfnu5jliLbnmoTkvY3nva4gIFxyXG4gICAgICAgIC8veCA9IOS4reW/g+eCuS54IC0g6LW35aeL5L2N572uLnggLSDmloflrZflrr3luqbnmoTkuIDljYpcclxuICAgICAgICB2YXIgeCA9IHRoaXMuZ2V0UmVjdCgpLnggLSB0aGlzLnBvc2l0aW9uWzBdIC0gdGV4dC5nZXRCb3VuZGluZ1JlY3QoKS53aWR0aCAvIDI7XHJcbiAgICAgICAgLy95ID0g5Lit5b+D54K5LnkgLSDotbflp4vkvY3nva4ueSArIOiKgueCuemrmOW6pueahOS4gOWNiiArIOWBj+enu+WAvO+8iDbvvIlcclxuICAgICAgICB2YXIgeSA9IHRoaXMuZ2V0UmVjdCgpLnkgLSB0aGlzLnBvc2l0aW9uWzFdICsgdGhpcy5nZXRCb3VuZGluZ1JlY3QoKS5oZWlnaHQgLyAyICsgdGV4dC5nZXRCb3VuZGluZ1JlY3QoKS5oZWlnaHQgKyA2O1xyXG4gICAgICAgIHRleHQuYXR0cihcInN0eWxlXCIsIHsgeDogeCwgeTogeSB9KTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB0ZXh0OiB0ZXh0LFxyXG4gICAgICAgICAgICByZWN0OiB0ZXh0LmdldEJvdW5kaW5nUmVjdCgpXHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIHJlZnJlc2hUZXh0XHJcbiAgICAgKiBAZGVzY3JpcHRpb24g5Yi35paw5paH5pysXHJcbiAgICAgKi9cclxuICAgIE5vZGUucHJvdG90eXBlLnJlZnJlc2hUZXh0ID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIHRleHQgPSB0aGlzLmNoaWxkT2ZOYW1lKFwiVGl0bGVcIik7XHJcbiAgICAgICAgdmFyIHggPSB0aGlzLmdldFJlY3QoKS54IC0gdGhpcy5wb3NpdGlvblswXSAtIHRleHQuZ2V0Qm91bmRpbmdSZWN0KCkud2lkdGggLyAyO1xyXG4gICAgICAgIHZhciB5ID0gdGhpcy5nZXRSZWN0KCkueSAtIHRoaXMucG9zaXRpb25bMV0gKyB0aGlzLmdldEJvdW5kaW5nUmVjdCgpLmhlaWdodCAvIDIgKyB0ZXh0LmdldEJvdW5kaW5nUmVjdCgpLmhlaWdodCArIDY7XHJcbiAgICAgICAgdGV4dC5hdHRyKFwic3R5bGVcIiwgeyB4OiB4LCB5OiB5IH0pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICog55Sx54i257G75a6e546wXHJcbiAgICAgKiBAcmV0dXJuIHtbdHlwZV19IFtkZXNjcmlwdGlvbl1cclxuICAgICAqL1xyXG4gICAgTm9kZS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24oKSB7fTtcclxuXHJcbiAgICBncmFwaGljLlV0aWwuaW5oZXJpdHMoTm9kZSwgZ3JhcGhpYy5Hcm91cCk7XHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IE5vZGU7XHJcblxyXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vbGliL2Zpc2gtdG9wby1jb3JlL2xpYi9Ob2RlLmpzXG4gKiogbW9kdWxlIGlkID0gNzZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxyXG4gKiDov57mjqXnur9cclxuICogQGF1dGhvciB3YW5nLnhpYW9odVxyXG4gKi9cclxuXHJcbiAgICB2YXIgVXRpbCA9IHJlcXVpcmUoXCIuLi91dGlsLmpzXCIpO1xyXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xyXG4gICAgdmFyIGdyYXBoaWMgPSByZXF1aXJlKFwiLi4vZ3JhcGhpYy5qc1wiKTtcclxuICAgIHZhciBOb2RlID0gcmVxdWlyZShcIi4uL05vZGUuanNcIik7XHJcbiAgICB2YXIgc3ltYm9sVXRpbCA9IHJlcXVpcmUoXCIuL1N5bWJvbC5qc1wiKTtcclxuICAgIHZhciBIYW5kbGUgPSByZXF1aXJlKFwiLi9IYW5kbGUuanNcIik7XHJcbiAgICB2YXIgRWZmZWN0TGluZSA9IHJlcXVpcmUoXCIuL0VmZmVjdExpbmUuanNcIik7XHJcbiAgICB2YXIgQ29ubmVjdGlvblBvaW50ID0gcmVxdWlyZShcIi4vQ29ubmVjdGlvblBvaW50LmpzXCIpO1xyXG4gICAgdmFyIFBvaW50ID0gcmVxdWlyZShcIi4uL1BvaW50LmpzXCIpO1xyXG4gICAgLyoqXHJcbiAgICAgKiDmnoTpgKDlh73mlbBcclxuICAgICAqIEBwYXJhbSB7W3R5cGVdfSBvcHRpb25zIFtkZXNjcmlwdGlvbl1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gQ29ubmVjdG9yKG9wdGlvbnMpIHtcclxuICAgICAgICBOb2RlLmNhbGwodGhpcyk7XHJcbiAgICAgICAgdGhpcy5yZXNvdXJjZUlkID0gVXRpbC5nZXRVVUlEKCk7ICAvLyDnlJ/miJDoioLngrlJRFxyXG4gICAgICAgIHZhciBkZWZhdWx0T3B0aW9ucyA9IHtcclxuICAgICAgICAgICAgc3ltYm9sOiB7dHlwZTpcImFycm93XCIgLCBzaXplOiAxMCwgY29sb3I6XCIjMDAwMDAwXCJ9LCAgLy/nrq3lpLQgIOWPr+mAieWAvOS4uu+8miAnY2lyY2xlJywgJ3JlY3QnLCAncm91bmRSZWN0JywgJ3RyaWFuZ2xlJywgJ2RpYW1vbmQnLCAncGluJywgJ2Fycm93J1xyXG4gICAgICAgICAgICBzdHlsZToge2xpbmVXaWR0aDoxLCBzdHJva2U6XCIjMDAwMDAwXCIsIGxpbmVUeXBlOkNvbm5lY3Rvci5UWVBFX1NUUkFJR0hUfSwgICAgLy/moLflvI9cclxuICAgICAgICAgICAgaG92ZXJTdHlsZToge2xpbmVXaWR0aDoyLCBzdHJva2U6XCJsaW1lXCJ9LCAvL+enu+S4iuWOu+eahOagt+W8j1xyXG4gICAgICAgICAgICBhcnJvd0hvdmVyU3R5bGU6IHtmaWxsOlwibGltZVwifSxcclxuICAgICAgICAgICAgc2hhcGU6IHtwb2ludHM6bnVsbCwgc21vb3RoOmZhbHNlLCBzbW9vdGhDb25zdHJhaW50Om51bGx9LC8v5b2i54q2XHJcbiAgICAgICAgICAgIHBvc2l0aW9uOiBbMCwwXSxcclxuICAgICAgICAgICAgaXNFZGl0OiB0cnVlLCAgLy/mmK/lkKblj6/nvJbovpFcclxuICAgICAgICAgICAgdGV4dDoge1xyXG4gICAgICAgICAgICAgICAgdGV4dDogXCJcIixcclxuICAgICAgICAgICAgICAgIGNvbG9yOiAnIzAwMDAwMCcsIC8vIOaWh+acrOminOiJslxyXG4gICAgICAgICAgICAgICAgdGV4dEZvbnQ6ICcxMnB4IE1pY3Jvc29mdCBZYUhlaSdcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgejogMFxyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgb3B0ID0gb3B0aW9ucyB8fCB7fTtcclxuICAgICAgICB0aGlzLm9wdGlvbnMgPSB6clV0aWwubWVyZ2UoZGVmYXVsdE9wdGlvbnMsIG9wdCwgdHJ1ZSk7XHJcbiAgICAgICAgdGhpcy5tb2RlbCA9IG9wdGlvbnMubW9kZWw7XHJcbiAgICAgICAgdGhpcy5oYW5kbGVzID0gW107XHJcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uUG9pbnRzID0gW107XHJcbiAgICAgICAgdGhpcy5jb25Qb2ludHNHcm91cCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5zdGFydE5vZGUgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuZW5kTm9kZSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5saW5lID0gbnVsbDtcclxuICAgICAgICB0aGlzLmdyb3VwQ3VydmUgPSBuZXcgZ3JhcGhpYy5Hcm91cCgpO1xyXG4gICAgICAgIHRoaXMuaWNvbnMgPSBbXTsgIC8vIOeUqOS6juWtmOWCqOe6v+auteS4iumdoueahOaTjeS9nOWbvuagh1xyXG4gICAgICAgIHRoaXMucmVuZGVyKCk7XHJcbiAgICB9XHJcblxyXG4gICAgQ29ubmVjdG9yLlRZUEVfU1RSQUlHSFQgPSAnc3RyYWlnaHQnO1xyXG5cclxuICAgIENvbm5lY3Rvci5UWVBFX0pBR0dFRCA9ICdqYWdnZWQnO1xyXG5cclxuICAgIENvbm5lY3Rvci5UWVBFX0NVUlZFID0gJ2N1cnZlJztcclxuXHJcbiAgICBDb25uZWN0b3IuUkFESVVTID0gMztcclxuXHJcbiAgICBDb25uZWN0b3IuU1RBUlRfTk9ERSA9IFwic3RhcnROb2RlXCI7XHJcblxyXG4gICAgQ29ubmVjdG9yLkVORF9OT0RFID0gXCJlbmROb2RlXCI7XHJcblxyXG4gICAgQ29ubmVjdG9yLkxFRlQgPSBcImxlZnRcIjtcclxuXHJcbiAgICBDb25uZWN0b3IuUklHSFQgPSBcInJpZ2h0XCI7XHJcblxyXG4gICAgQ29ubmVjdG9yLlRPUCA9IFwidG9wXCI7XHJcblxyXG4gICAgQ29ubmVjdG9yLkJPVFRPTSA9IFwiYm90dG9tXCI7XHJcblxyXG4gICAgQ29ubmVjdG9yLkJPVFRPTSA9IFwiYm90dG9tXCI7XHJcblxyXG4gICAgQ29ubmVjdG9yLlNFUEVSQVRPUiA9IFwiLVwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiDph43mlrDnlLvnur/vvIzlpoLmnpzkvKDnqbrliJnmoLnmja50dXJuaW5nUG9pbnRzIOmHjeaWsOeUu+e6v1xyXG4gICAgICogQHBhcmFtICB7W3R5cGVdfSBwb2ludHMgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICogQHJldHVybiB7W3R5cGVdfSAgICAgICAgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICovXHJcbiAgICBDb25uZWN0b3IucHJvdG90eXBlLnJlZnJlc2ggPSBmdW5jdGlvbihwb2ludHMpIHtcclxuICAgICAgICBpZihwb2ludHMpIHtcclxuICAgICAgICAgICAgdGhpcy50dXJuaW5nUG9pbnRzID0gcG9pbnRzO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvL+Wwhlt4OjAseTowXei9rOWMluS4ulswLCAwXSAg57uZenJlbmRlcuS9v+eUqFxyXG4gICAgICAgIHZhciBwb2ludHMgPSBVdGlsLnRyYXNsYXRlUG9pbnRzKHRoaXMudHVybmluZ1BvaW50cyk7XHJcblxyXG4gICAgICAgIGlmKCh0aGlzLm9wdGlvbnMuc3R5bGUubGluZVR5cGUgPT0gQ29ubmVjdG9yLlRZUEVfQ1VSVkUpICYmIChwb2ludHMubGVuZ3RoID4gMikpIHtcclxuICAgICAgICAgICAgdGhpcy5tb2RpZnlDdXJ2ZSh0aGlzLnR1cm5pbmdQb2ludHMpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMubGluZS5hdHRyKCdzaGFwZScsIHtwb2ludHM6IHBvaW50c30pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGxpbmVUZXh0ID0gdGhpcy5jaGlsZE9mTmFtZSgnbGluZVRleHQnKTtcclxuICAgICAgICAvL+W8gOWni+ayoeacieWIm+W7uuaWh+acrO+8jOWQjuadpeS8oOi/m+adpXRleHTkuobvvIzpnIDopoHlhYjliJvlu7rmlofmnKxcclxuICAgICAgICBpZiAoIWxpbmVUZXh0ICAmJiB0aGlzLm9wdGlvbnMudGV4dC50ZXh0KSB7XHJcbiAgICAgICAgICAgIHZhciB0ZXh0ID0gdGhpcy5kcmF3VGV4dChcImxpbmVUZXh0XCIsIHRoaXMub3B0aW9ucy50ZXh0LnRleHQsMCwgMCk7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkKHRleHQudGV4dCk7XHJcbiAgICAgICAgICAgIGxpbmVUZXh0ID0gdGhpcy5jaGlsZE9mTmFtZSgnbGluZVRleHQnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGxpbmVUZXh0KSB7XHJcbiAgICAgICAgICAgIGxpbmVUZXh0LnNldFN0eWxlKFwidGV4dFwiLCB0aGlzLm9wdGlvbnMudGV4dC50ZXh0KTtcclxuXHJcbiAgICAgICAgICAgIHZhciB0ZXh0UG9pbnQgPSB0aGlzLmdldFRleHRQb3N0aW9uKHRoaXMub3B0aW9ucy50ZXh0KTtcclxuXHJcbiAgICAgICAgICAgIC8vIGlmICh0aGlzLm9wdGlvbnMuc3R5bGUubGluZVR5cGUgPT0gQ29ubmVjdG9yLlRZUEVfU1RSQUlHSFQgKSB7XHJcbiAgICAgICAgICAgIC8vICAgICBsaW5lVGV4dC5hdHRyKCdyb3RhdGlvbicsIHRoaXMuZ2V0VGV4dFJvdGF0aW9uKHRleHRQb2ludCkpO1xyXG4gICAgICAgICAgICAvLyB9XHJcblxyXG4gICAgICAgICAgICBsaW5lVGV4dC5hdHRyKFwicG9zaXRpb25cIiwgdGV4dFBvaW50KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHN5bWJvbFRvID0gdGhpcy5jaGlsZE9mTmFtZSgndG9TeW1ib2wnKTtcclxuICAgICAgICBpZihzeW1ib2xUbykge1xyXG4gICAgICAgICAgICBpZih0aGlzLm9wdGlvbnMuZWZmZWN0JiZ0aGlzLm9wdGlvbnMuZWZmZWN0LnNob3cpe1xyXG4gICAgICAgICAgICAgICAgbmV3IEVmZmVjdExpbmUoc3ltYm9sVG8sdGhpcy5vcHRpb25zLHRoaXMuZ3JvdXBDdXJ2ZSx0aGlzLnBvbHlMaW5lKTtcclxuICAgICAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgICAgICBzeW1ib2xUby5hdHRyKCdwb3NpdGlvbicsIHBvaW50c1twb2ludHMubGVuZ3RoIC0xXSk7XHJcbiAgICAgICAgICAgICAgICBzeW1ib2xUby5hdHRyKCdyb3RhdGlvbicsIFV0aWwudGFuZ2VudFJvdGF0aW9uKHRoaXMudHVybmluZ1BvaW50c1t0aGlzLnR1cm5pbmdQb2ludHMubGVuZ3RoLTJdLCB0aGlzLnR1cm5pbmdQb2ludHNbdGhpcy50dXJuaW5nUG9pbnRzLmxlbmd0aC0xXSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiDmuLLmn5NcclxuICAgICAqIEByZXR1cm4ge1t0eXBlXX0gW2Rlc2NyaXB0aW9uXVxyXG4gICAgICovXHJcbiAgICBDb25uZWN0b3IucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgICAgICAvLzEu5Yib5bu6566t5aS0XHJcbiAgICAgICAgdmFyIHN5bWJvbFRvID0gdGhpcy5jcmVhdGVTeW1ib2woJ3RvU3ltYm9sJywgdGhpcy5vcHRpb25zKTsgLy9hcnJvdyx0cmlhbmdsZVxyXG4gICAgICAgIGlmIChzeW1ib2xUbykge1xyXG4gICAgICAgICAgICB0aGlzLmFkZChzeW1ib2xUbyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLzIu5Yib5bu657q/XHJcbiAgICAgICAgdGhpcy5jdXJ2ZUxpbmUgPSBuZXcgZ3JhcGhpYy5CZXppZXJDdXJ2ZSh7XHJcbiAgICAgICAgICAgIHBvc2l0aW9uOiB0aGlzLm9wdGlvbnMucG9zaXRpb24sXHJcbiAgICAgICAgICAgIHN0eWxlOiB0aGlzLm9wdGlvbnMuc3R5bGUsXHJcbiAgICAgICAgICAgIHo6IHRoaXMub3B0aW9ucy56XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5ncm91cEN1cnZlLmFkZCh0aGlzLmN1cnZlTGluZSk7XHJcbiAgICAgICAgdGhpcy5hZGQodGhpcy5ncm91cEN1cnZlKTtcclxuXHJcbiAgICAgICAgdGhpcy5wb2x5TGluZSA9IG5ldyBncmFwaGljLlBvbHlsaW5lKHtcclxuICAgICAgICAgICAgcG9zaXRpb246IHRoaXMub3B0aW9ucy5wb3NpdGlvbixcclxuICAgICAgICAgICAgc2hhcGU6IHRoaXMub3B0aW9ucy5zaGFwZSxcclxuICAgICAgICAgICAgc3R5bGU6IHRoaXMub3B0aW9ucy5zdHlsZSxcclxuICAgICAgICAgICAgejogdGhpcy5vcHRpb25zLnpcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmFkZCh0aGlzLnBvbHlMaW5lKTtcclxuXHJcbiAgICAgICAgaWYoKHRoaXMub3B0aW9ucy5zdHlsZS5saW5lVHlwZSA9PSBDb25uZWN0b3IuVFlQRV9DVVJWRSkpIHtcclxuICAgICAgICAgICAgdGhpcy5saW5lID0gdGhpcy5ncm91cEN1cnZlO1xyXG4gICAgICAgICAgICB0aGlzLmNyZWF0ZUhvdmVyU3R5bGUodGhpcy5jdXJ2ZUxpbmUpO1xyXG4gICAgICAgICAgICB0aGlzLnBvbHlMaW5lLmhpZGUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMubGluZSA9IHRoaXMucG9seUxpbmU7XHJcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlSG92ZXJTdHlsZSh0aGlzLnBvbHlMaW5lKTtcclxuICAgICAgICAgICAgdGhpcy5jdXJ2ZUxpbmUuaGlkZSgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8zLuS+puWQrOe6v+S6i+S7tlxyXG4gICAgICAgIHZhciBNT1VTRV9FVkVOVF9OQU1FUyA9IFsnZGJsY2xpY2snLCAnY2xpY2snXTsvLydjbGljaycsICdkYmxjbGljaycsICdtb3VzZW92ZXInLCAnbW91c2VvdXQnXHJcbiAgICAgICAgenJVdGlsLmVhY2goTU9VU0VfRVZFTlRfTkFNRVMsIGZ1bmN0aW9uIChldmVOYW1lKSB7XHJcbiAgICAgICAgICAgIHRoaXMubGluZS5vbihldmVOYW1lLCB6clV0aWwuYmluZChmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAgICAgZS5jYW5jZWxCdWJibGUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgdmFyIHBhcmFtcyA9IHt9O1xyXG4gICAgICAgICAgICAgICAgcGFyYW1zLmV2ZW50ID0gZTtcclxuICAgICAgICAgICAgICAgIHBhcmFtcy50eXBlID0gXCJDb25uZWN0b3I6XCIgKyBldmVOYW1lO1xyXG4gICAgICAgICAgICAgICAgcGFyYW1zLnRhcmdldCA9IHRoYXQ7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXIocGFyYW1zLnR5cGUsIHBhcmFtcyk7XHJcbiAgICAgICAgICAgICAgICBpZih0aGlzLm9wdGlvbnMuaXNFZGl0ID09IGZhbHNlKXtyZXR1cm47fVxyXG5cclxuICAgICAgICAgICAgICAgIGlmKHRoaXMub3B0aW9ucy5pc0VkaXQgJiYgdGhpcy5jb25uZWN0aW9uUG9pbnRzLmxlbmd0aCA8IDEgJiYgdGhpcy50dXJuaW5nUG9pbnRzLmxlbmd0aCA+PTIpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNyZWF0ZUFsbGNvbm5lY3Rpb25Qb2ludCgpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZih0aGlzLmhhbmRsZXMubGVuZ3RoIDwgMSApIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNoYXBlU2V0SGFuZGxlKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sIHRoaXMpKTtcclxuICAgICAgICB9LCB0aGlzKTtcclxuXHJcbiAgICAgICAgLy8zLuWIm+W7uuiwg+aVtOe6v+eahOi/nuaOpeeCuVxyXG4gICAgICAgIGlmKHRoaXMub3B0aW9ucy5pc0VkaXQpIHtcclxuICAgICAgICAgICAgdGhpcy5jb25Qb2ludHNHcm91cCA9IG5ldyBncmFwaGljLkdyb3VwKCk7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkKHRoaXMuY29uUG9pbnRzR3JvdXApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy80LuWIm+W7uue6v+S4iuaWh+acrFxyXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMudGV4dC50ZXh0ICYmIHRoaXMub3B0aW9ucy50ZXh0LnRleHQgIT0gXCJcIikge1xyXG4gICAgICAgICAgICB2YXIgdGV4dCA9IHRoaXMuZHJhd1RleHQoXCJsaW5lVGV4dFwiLCB0aGlzLm9wdGlvbnMudGV4dC50ZXh0LDAsIDApO1xyXG4gICAgICAgICAgICB0aGlzLmFkZCh0ZXh0LnRleHQpO1xyXG4gICAgICAgIH1cclxuXHJcblxyXG4gICAgfTtcclxuXHJcbiAgICAvL+iuvue9rnN0eWxlXHJcbiAgICBDb25uZWN0b3IucHJvdG90eXBlLnNldFN0eWxlID0gZnVuY3Rpb24ob3B0aW9ucykge1xyXG4gICAgICAgIGlmKG9wdGlvbnMuY29sb3Ipe1xyXG4gICAgICAgICAgICBpZih0aGlzLm9wdGlvbnMuc3R5bGUubGluZVR5cGUgPT0gQ29ubmVjdG9yLlRZUEVfQ1VSVkUpe1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ncm91cEN1cnZlLmVhY2hDaGlsZChmdW5jdGlvbihjdXJ2ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnZlLmF0dHIoXCJzdHlsZVwiLHtzdHJva2U6b3B0aW9ucy5jb2xvcn0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGdyYXBoaWMuc2V0Tm9ybWFsU3R5bGUoY3VydmUsIHtzdHJva2U6b3B0aW9ucy5jb2xvcn0pO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wb2x5TGluZS5hdHRyKFwic3R5bGVcIix7c3Ryb2tlOm9wdGlvbnMuY29sb3J9KTtcclxuICAgICAgICAgICAgICAgIGdyYXBoaWMuc2V0Tm9ybWFsU3R5bGUodGhpcy5wb2x5TGluZSwge3N0cm9rZTpvcHRpb25zLmNvbG9yfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHN5bWJvbFRvID0gdGhpcy5jaGlsZE9mTmFtZSgndG9TeW1ib2wnKTtcclxuICAgICAgICAgICAgaWYgKHN5bWJvbFRvKSB7XHJcbiAgICAgICAgICAgICAgICBzeW1ib2xUby5hdHRyKFwic3R5bGVcIix7ZmlsbDpvcHRpb25zLmNvbG9yfSk7XHJcbiAgICAgICAgICAgICAgICBncmFwaGljLnNldE5vcm1hbFN0eWxlKHN5bWJvbFRvLCB7ZmlsbDpvcHRpb25zLmNvbG9yfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5vcHRpb25zLnN0eWxlLnN0cm9rZSA9IG9wdGlvbnMuY29sb3I7XHJcbiAgICAgICAgICAgIHRoaXMubW9kZWwuc2V0KFwib3B0aW9ucy5zdHlsZS5zdHJva2VcIiwgb3B0aW9ucy5jb2xvcik7XHJcbiAgICAgICAgICAgIHRoaXMubW9kZWwuc2V0KFwib3B0aW9ucy5zeW1ib2wuY29sb3JcIiwgb3B0aW9ucy5jb2xvcik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZihvcHRpb25zLnRleHQpe1xyXG4gICAgICAgICAgICAgdmFyIGxpbmVUZXh0ID0gdGhpcy5jaGlsZE9mTmFtZSgnbGluZVRleHQnKTtcclxuICAgICAgICAgICAgLy/lvIDlp4vmsqHmnInliJvlu7rmlofmnKzvvIzlkI7mnaXkvKDov5vmnaV0ZXh05LqG77yM6ZyA6KaB5YWI5Yib5bu65paH5pysXHJcbiAgICAgICAgICAgIGlmICghbGluZVRleHQgICYmIG9wdGlvbnMudGV4dC50ZXh0KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdGV4dCA9IHRoaXMuZHJhd1RleHQoXCJsaW5lVGV4dFwiLCBvcHRpb25zLnRleHQudGV4dCwwLCAwKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuYWRkKHRleHQudGV4dCk7XHJcbiAgICAgICAgICAgICAgICBsaW5lVGV4dCA9IHRoaXMuY2hpbGRPZk5hbWUoJ2xpbmVUZXh0Jyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmKG9wdGlvbnMudGV4dC50ZXh0IHx8IG9wdGlvbnMudGV4dC50ZXh0ID09IFwiXCIpe1xyXG4gICAgICAgICAgICAgICAgbGluZVRleHQuc2V0U3R5bGUoXCJ0ZXh0XCIsIG9wdGlvbnMudGV4dC50ZXh0KTtcclxuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy50ZXh0LnRleHQgPSBvcHRpb25zLnRleHQudGV4dDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgdGV4dFBvaW50ID0gdGhpcy5nZXRUZXh0UG9zdGlvbihvcHRpb25zLnRleHQpO1xyXG4gICAgICAgICAgICBsaW5lVGV4dC5hdHRyKFwicG9zaXRpb25cIiwgdGV4dFBvaW50KTtcclxuICAgICAgICAgICAgaWYob3B0aW9ucy50ZXh0LnRleHRQb3Mpe1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLnRleHQudGV4dFBvcyA9IG9wdGlvbnMudGV4dC50ZXh0UG9zO1xyXG4gICAgICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy50ZXh0LnRleHRQb3MgPSAnY2VudGVyJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZihvcHRpb25zLnRleHQuY29sb3Ipe1xyXG4gICAgICAgICAgICAgICAgbGluZVRleHQuYXR0cihcInN0eWxlXCIse1xyXG4gICAgICAgICAgICAgICAgICAgIGZpbGw6IG9wdGlvbnMudGV4dC5jb2xvclxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMudGV4dC5jb2xvciA9IG9wdGlvbnMudGV4dC5jb2xvcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLm1vZGVsLnNldChcIm9wdGlvbnMudGV4dFwiLCBvcHRpb25zLnRleHQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICog6I635Y+W57q/5q6155qE5L2N572uXHJcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IHRleHQge3RleHQ6JycsIGNvbG9yOicnLCB0ZXh0UG9zOicnfVxyXG4gICAgICogQHJldHVybiB7T2JqZWN0fSAgICAgIHt4LHl9XHJcbiAgICAgKi9cclxuICAgIENvbm5lY3Rvci5wcm90b3R5cGUuZ2V0VGV4dFBvc3Rpb24gPSBmdW5jdGlvbih0ZXh0KSB7XHJcbiAgICAgICAgdmFyIHRleHRQb3N0aW9uID0gW107XHJcbiAgICAgICAgdmFyIHRleHRXaWR0aCA9IGdyYXBoaWMudGV4dENvbnRhaW4uZ2V0V2lkdGgodGV4dC50ZXh0LCB0ZXh0LnRleHRGb250KTtcclxuICAgICAgICBpZih0ZXh0JiZ0ZXh0LnRleHRQb3Mpe1xyXG4gICAgICAgICAgICBpZih0ZXh0LnRleHRQb3MgPT0gJ3N0YXJ0Jyl7XHJcbiAgICAgICAgICAgICAgICB2YXIgeE9mZnNldCA9IHRleHQueE9mZnNldCB8fCAwO1xyXG4gICAgICAgICAgICAgICAgdGV4dFBvc3Rpb24gPSBbdGhpcy50dXJuaW5nUG9pbnRzWzBdLnggKyB4T2Zmc2V0LHRoaXMudHVybmluZ1BvaW50c1swXS55XTtcclxuICAgICAgICAgICAgfWVsc2UgaWYodGV4dC50ZXh0UG9zID09ICdlbmQnKXtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc3R5bGUubGluZVR5cGUgPT0gQ29ubmVjdG9yLlRZUEVfU1RSQUlHSFQgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBvaW50cyAgPSBVdGlsLmdldE1heExpbmVMZW5ndGgodGhpcy50dXJuaW5nUG9pbnRzKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFuZ2xlID0gVXRpbC5nZXRBbmdsZShwb2ludHNbMF0scG9pbnRzWzFdKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbGVuZ3RoID0gIFV0aWwuZGlzdGFuY2UocG9pbnRzWzBdLHBvaW50c1sxXSkgLSB0ZXh0V2lkdGg7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5ld1BvaW50ID0gVXRpbC5nZXRFbmRQb2ludChwb2ludHNbMF0sIGxlbmd0aCwgYW5nbGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRleHRQb3N0aW9uID0gW25ld1BvaW50LngsbmV3UG9pbnQueV07XHJcbiAgICAgICAgICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgICAgICAgICB0ZXh0UG9zdGlvbiA9IFt0aGlzLnR1cm5pbmdQb2ludHNbdGhpcy50dXJuaW5nUG9pbnRzLmxlbmd0aC0xXS54LHRoaXMudHVybmluZ1BvaW50c1t0aGlzLnR1cm5pbmdQb2ludHMubGVuZ3RoLTFdLnldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgICAgIHRleHRQb3N0aW9uID0gdGhpcy5taWRkbGUodGV4dCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgdmFyIHBvc2l0aW9uID0gdGhpcy5taWRkbGUodGV4dCk7XHJcbiAgICAgICAgICAgIHRleHRQb3N0aW9uID0gW3Bvc2l0aW9uWzBdLXRleHRXaWR0aC8yLHBvc2l0aW9uWzFdXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0ZXh0UG9zdGlvbjtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDojrflj5bnur/mrrXnmoTml4vovazop5LluqZcclxuICAgICAqIEBwYXJhbSAge09iamVjdH0gdGV4dFBvc3Rpb24ge3gseX1cclxuICAgICAqIEByZXR1cm4ge051bWJlcn0gICAgICAgICAgICAg6KeS5bqm5YC8XHJcbiAgICAgKi9cclxuICAgIENvbm5lY3Rvci5wcm90b3R5cGUuZ2V0VGV4dFJvdGF0aW9uID0gZnVuY3Rpb24odGV4dFBvc3Rpb24pIHtcclxuICAgICAgICAvL+iuoeeul+WHuuaegeWdkOagh+eahOinkuW6plxyXG4gICAgICAgIHZhciBwb2ludHMgID0gVXRpbC5nZXRNYXhMaW5lTGVuZ3RoKHRoaXMudHVybmluZ1BvaW50cyk7XHJcbiAgICAgICAgdmFyIGFuZ2xlID0gLSBNYXRoLmF0YW4yKHBvaW50c1sxXS55IC0gdGV4dFBvc3Rpb25bMV0sIHBvaW50c1sxXS54IC0gdGV4dFBvc3Rpb25bMF0pOyAgLy8sTWF0aC5QSS8yXHJcbiAgICAgICAgcmV0dXJuIGFuZ2xlO1xyXG4gICAgfTtcclxuXHJcbiAgICBDb25uZWN0b3IucHJvdG90eXBlLmNyZWF0ZUhvdmVyU3R5bGUgPSBmdW5jdGlvbihlbCkge1xyXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuaG92ZXJTdHlsZSkge1xyXG4gICAgICAgICAgICBncmFwaGljLnNldEVsZW1lbnRIb3ZlclN0bChlbCwgdGhpcy5vcHRpb25zLmhvdmVyU3R5bGUpO1xyXG5cclxuICAgICAgICAgICAgdmFyIHN5bWJvbFRvID0gdGhpcy5jaGlsZE9mTmFtZSgndG9TeW1ib2wnKTtcclxuICAgICAgICAgICAgaWYoc3ltYm9sVG8pe2dyYXBoaWMuc2V0RWxlbWVudEhvdmVyU3RsKHN5bWJvbFRvLCB0aGlzLm9wdGlvbnMuYXJyb3dIb3ZlclN0eWxlKTt9XHJcblxyXG4gICAgICAgICAgICBlbC5vbignbW91c2VvdmVyJywgenJVdGlsLmJpbmQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICBncmFwaGljLmRvRW50ZXJIb3ZlcihlbCk7XHJcbiAgICAgICAgICAgICAgICBpZihzeW1ib2xUbyl7Z3JhcGhpYy5kb0VudGVySG92ZXIoc3ltYm9sVG8pO31cclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLmdyb3VwQ3VydmUuZWFjaENoaWxkKGZ1bmN0aW9uKGxpbmUpIHtcclxuICAgICAgICAgICAgICAgICAgICBncmFwaGljLmRvRW50ZXJIb3ZlcihsaW5lKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9LHRoaXMpKVxyXG4gICAgICAgICAgICAgIC5vbignbW91c2VvdXQnLCB6clV0aWwuYmluZChmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIGdyYXBoaWMuZG9MZWF2ZUhvdmVyKGVsKTtcclxuICAgICAgICAgICAgICAgIGlmKHN5bWJvbFRvKXtncmFwaGljLmRvTGVhdmVIb3ZlcihzeW1ib2xUbyk7fVxyXG4gICAgICAgICAgICAgICAgdGhpcy5ncm91cEN1cnZlLmVhY2hDaGlsZChmdW5jdGlvbihsaW5lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZ3JhcGhpYy5kb0xlYXZlSG92ZXIobGluZSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSx0aGlzKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICog5Yib5bu6Tm9kZeeahOi/nuaOpeeCuVxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJuIHtbdHlwZV19IFtkZXNjcmlwdGlvbl1cclxuICAgICAqL1xyXG4gICAgQ29ubmVjdG9yLnByb3RvdHlwZS5jcmVhdGVBbGxjb25uZWN0aW9uUG9pbnQgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgc1JlY3QgPSB0aGlzLnN0YXJ0Tm9kZS5nZXRSZWN0PyB0aGlzLnN0YXJ0Tm9kZS5nZXRSZWN0KCkuYm91bmRpbmdSZWN0IDogVXRpbC5nZXRSZWN0KHRoaXMuc3RhcnROb2RlKS5ib3VuZGluZ1JlY3Q7XHJcblxyXG4gICAgICAgIHZhciBlUmVjdCA9IHRoaXMuZW5kTm9kZS5nZXRSZWN0PyB0aGlzLmVuZE5vZGUuZ2V0UmVjdCgpLmJvdW5kaW5nUmVjdCA6IFV0aWwuZ2V0UmVjdCh0aGlzLmVuZE5vZGUpLmJvdW5kaW5nUmVjdDtcclxuXHJcbiAgICAgICAgdmFyIHNDb25uZWN0b3JQb2ludCA9IFV0aWwuZ2V0Q29ubmVjdG9yUG9pbnRzKHNSZWN0KTtcclxuICAgICAgICB2YXIgZUNvbm5lY3RvclBvaW50ID0gVXRpbC5nZXRDb25uZWN0b3JQb2ludHMoZVJlY3QpO1xyXG5cclxuICAgICAgICB0aGlzLmNvbm5lY3Rpb25Qb2ludENyZWF0ZSh0aGlzLnN0YXJ0Tm9kZSwgc0Nvbm5lY3RvclBvaW50LmxlZnQsIENvbm5lY3Rvci5TVEFSVF9OT0RFICsgQ29ubmVjdG9yLlNFUEVSQVRPUiArIENvbm5lY3Rvci5MRUZUKTtcclxuICAgICAgICB0aGlzLmNvbm5lY3Rpb25Qb2ludENyZWF0ZSh0aGlzLnN0YXJ0Tm9kZSwgc0Nvbm5lY3RvclBvaW50LnJpZ2h0LCBDb25uZWN0b3IuU1RBUlRfTk9ERSArIENvbm5lY3Rvci5TRVBFUkFUT1IgKyBDb25uZWN0b3IuUklHSFQpO1xyXG4gICAgICAgIHRoaXMuY29ubmVjdGlvblBvaW50Q3JlYXRlKHRoaXMuc3RhcnROb2RlLCBzQ29ubmVjdG9yUG9pbnQudG9wLCBDb25uZWN0b3IuU1RBUlRfTk9ERSArIENvbm5lY3Rvci5TRVBFUkFUT1IgKyBDb25uZWN0b3IuVE9QKTtcclxuICAgICAgICB0aGlzLmNvbm5lY3Rpb25Qb2ludENyZWF0ZSh0aGlzLnN0YXJ0Tm9kZSwgc0Nvbm5lY3RvclBvaW50LmJvdHRvbSwgQ29ubmVjdG9yLlNUQVJUX05PREUgKyBDb25uZWN0b3IuU0VQRVJBVE9SICsgQ29ubmVjdG9yLkJPVFRPTSk7XHJcblxyXG4gICAgICAgIHRoaXMuY29ubmVjdGlvblBvaW50Q3JlYXRlKHRoaXMuZW5kTm9kZSwgZUNvbm5lY3RvclBvaW50LmxlZnQsIENvbm5lY3Rvci5FTkRfTk9ERSArIENvbm5lY3Rvci5TRVBFUkFUT1IgKyBDb25uZWN0b3IuTEVGVCk7XHJcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uUG9pbnRDcmVhdGUodGhpcy5lbmROb2RlLCBlQ29ubmVjdG9yUG9pbnQucmlnaHQsIENvbm5lY3Rvci5FTkRfTk9ERSArIENvbm5lY3Rvci5TRVBFUkFUT1IgKyBDb25uZWN0b3IuUklHSFQpO1xyXG4gICAgICAgIHRoaXMuY29ubmVjdGlvblBvaW50Q3JlYXRlKHRoaXMuZW5kTm9kZSwgZUNvbm5lY3RvclBvaW50LnRvcCwgQ29ubmVjdG9yLkVORF9OT0RFICsgQ29ubmVjdG9yLlNFUEVSQVRPUiArIENvbm5lY3Rvci5UT1ApO1xyXG4gICAgICAgIHRoaXMuY29ubmVjdGlvblBvaW50Q3JlYXRlKHRoaXMuZW5kTm9kZSwgZUNvbm5lY3RvclBvaW50LmJvdHRvbSwgQ29ubmVjdG9yLkVORF9OT0RFICsgQ29ubmVjdG9yLlNFUEVSQVRPUiArIENvbm5lY3Rvci5CT1RUT00pO1xyXG5cclxuXHJcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uUG9pbnRDcmVhdGUodGhpcywgdGhpcy50dXJuaW5nUG9pbnRzWzBdLmNsb25lKCksIENvbm5lY3Rpb25Qb2ludC5UWVBFX0NPTk5FQ1RPUik7XHJcblxyXG4gICAgICAgIHRoaXMuY29ubmVjdGlvblBvaW50Q3JlYXRlKHRoaXMsIHRoaXMudHVybmluZ1BvaW50c1t0aGlzLnR1cm5pbmdQb2ludHMubGVuZ3RoLTFdLmNsb25lKCksIENvbm5lY3Rpb25Qb2ludC5UWVBFX0NPTk5FQ1RPUik7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICog5Yib5bu66L+e5o6l54K5XHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtICB7W3R5cGVdfSBzaGFwZSBbZGVzY3JpcHRpb25dXHJcbiAgICAgKiBAcGFyYW0gIHtbdHlwZV19IHBvaW50IFtkZXNjcmlwdGlvbl1cclxuICAgICAqIEBwYXJhbSAge1t0eXBlXX0gdHlwZSAgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICogQHJldHVybiB7W3R5cGVdfSAgICAgICBbZGVzY3JpcHRpb25dXHJcbiAgICAgKi9cclxuICAgIENvbm5lY3Rvci5wcm90b3R5cGUuY29ubmVjdGlvblBvaW50Q3JlYXRlID0gZnVuY3Rpb24oc2hhcGUsIHBvaW50LCB0eXBlKSB7XHJcbiAgICAgICAgdmFyIGNvblBvaW50ID0gbmV3IENvbm5lY3Rpb25Qb2ludCh0aGlzLCBwb2ludCwgdHlwZSwgdGhpcy5vcHRpb25zKTtcclxuICAgICAgICB0aGlzLmNvblBvaW50c0dyb3VwLmFkZChjb25Qb2ludC5zaGFwZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICog5riF56m65o6n5Yi254K5XHJcbiAgICAgKiBAcmV0dXJuIHtbdHlwZV19IFtkZXNjcmlwdGlvbl1cclxuICAgICAqL1xyXG4gICAgQ29ubmVjdG9yLnByb3RvdHlwZS5jbGVhckhhbmRsZXMgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuaGFuZGxlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB0aGlzLnJlbW92ZSh0aGlzLmhhbmRsZXNbaV0uaGFuZGxlU2hhcGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmhhbmRsZXMgPSBbXTtcclxuICAgICAgICBpZiAodGhpcy5jb25Qb2ludHNHcm91cCkge1xyXG4gICAgICAgICAgICB0aGlzLmNvblBvaW50c0dyb3VwLnJlbW92ZUFsbCgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDliJvlu7rmi4bnur8g57q/5pat55qE5o6n5Yi254K5XHJcbiAgICAgKiBAcmV0dXJuIHtbdHlwZV19IFtkZXNjcmlwdGlvbl1cclxuICAgICAqL1xyXG4gICAgQ29ubmVjdG9yLnByb3RvdHlwZS5zaGFwZVNldEhhbmRsZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGZvcih2YXIgaT0xOyBpPHRoaXMudHVybmluZ1BvaW50cy5sZW5ndGgtMjsgaSsrKXtcclxuICAgICAgICAgICAgdmFyIGg7XHJcbiAgICAgICAgICAgIHZhciB4LCB5O1xyXG4gICAgICAgICAgICAvL+aYr+WQpuWcqOS4gOadoee6v+S4ilxyXG4gICAgICAgICAgICB2YXIgaXNDb2xsaW5lYWl0eUZpcnN0ID0gVXRpbC5jb2xsaW5lYXJpdHkodGhpcy50dXJuaW5nUG9pbnRzW2ktMV0sIHRoaXMudHVybmluZ1BvaW50c1tpXSwgdGhpcy50dXJuaW5nUG9pbnRzW2krMV0pO1xyXG4gICAgICAgICAgICB2YXIgaXNDb2xsaW5lYWl0eVNlY29uZCA9IFV0aWwuY29sbGluZWFyaXR5KHRoaXMudHVybmluZ1BvaW50c1tpXSwgdGhpcy50dXJuaW5nUG9pbnRzW2krMV0sIHRoaXMudHVybmluZ1BvaW50c1tpKzJdKTtcclxuICAgICAgICAgICAgaWYoICghaXNDb2xsaW5lYWl0eUZpcnN0ICYmICghaXNDb2xsaW5lYWl0eVNlY29uZCB8fCB0aGlzLnR1cm5pbmdQb2ludHNbaSsxXS5lcXVhbHModGhpcy50dXJuaW5nUG9pbnRzW2krMl0pKSlcclxuICAgICAgICAgICAgICAgIHx8ICggKCFpc0NvbGxpbmVhaXR5Rmlyc3QgfHwgdGhpcy50dXJuaW5nUG9pbnRzW2ktMV0uZXF1YWxzKHRoaXMudHVybmluZ1BvaW50c1tpXSkpICYmICFpc0NvbGxpbmVhaXR5U2Vjb25kICkpIHtcclxuXHJcbiAgICAgICAgICAgICAgICBpZih0aGlzLnR1cm5pbmdQb2ludHNbaV0ueCA9PT0gdGhpcy50dXJuaW5nUG9pbnRzW2krMV0ueCl7IC8vc2FtZSB2ZXJ0aWNhbFxyXG4gICAgICAgICAgICAgICAgICAgIHggPSB0aGlzLnR1cm5pbmdQb2ludHNbaV0ueDtcclxuICAgICAgICAgICAgICAgICAgICB5ID0gKHRoaXMudHVybmluZ1BvaW50c1tpXS55ICsgdGhpcy50dXJuaW5nUG9pbnRzW2krMV0ueSkgLyAyO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBoID0gbmV3IEhhbmRsZSgnaCcseCx5LHRoaXMpO1xyXG5cclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmKHRoaXMudHVybmluZ1BvaW50c1tpXS55ID09PSB0aGlzLnR1cm5pbmdQb2ludHNbaSsxXS55KXsgLy8gc2FtZSBob3Jpem9udGFsXHJcbiAgICAgICAgICAgICAgICAgICAgeCA9ICh0aGlzLnR1cm5pbmdQb2ludHNbaV0ueCArICB0aGlzLnR1cm5pbmdQb2ludHNbaSsxXS54KSAvIDI7XHJcbiAgICAgICAgICAgICAgICAgICAgeSA9IHRoaXMudHVybmluZ1BvaW50c1tpXS55O1xyXG4gICAgICAgICAgICAgICAgICAgIGggPSAgbmV3ICBIYW5kbGUoJ3YnLHgseSx0aGlzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGQoaC5oYW5kbGVTaGFwZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVzLnB1c2goaCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDliJvlu7rnrq3lpLRcclxuICAgICAqIEBwYXJhbSAge1t0eXBlXX0gbmFtZSAgICAgICBbZGVzY3JpcHRpb25dXHJcbiAgICAgKiBAcGFyYW0gIHtbdHlwZV19IG9wdGlvbnMgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICogQHJldHVybiB7W3R5cGVdfSAgICAgICAgICAgIFtkZXNjcmlwdGlvbl1cclxuICAgICAqL1xyXG4gICAgQ29ubmVjdG9yLnByb3RvdHlwZS5jcmVhdGVTeW1ib2wgPSBmdW5jdGlvbihuYW1lLCBvcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIHN5bWJvbFR5cGUgPSBvcHRpb25zLnN5bWJvbC50eXBlO1xyXG4gICAgICAgIHZhciBzeW1ib2xTaXplID10aGlzLm9wdGlvbnMuc3ltYm9sLnNpemU7XHJcbiAgICAgICAgaWYgKHN5bWJvbFR5cGUgPT09ICdub25lJykge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIXpyVXRpbC5pc0FycmF5KHN5bWJvbFNpemUpKSB7XHJcbiAgICAgICAgICAgIHN5bWJvbFNpemUgPSBbc3ltYm9sU2l6ZSwgc3ltYm9sU2l6ZV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBzeW1ib2xQYXRoID0gc3ltYm9sVXRpbC5jcmVhdGVTeW1ib2woXHJcbiAgICAgICAgICAgIHN5bWJvbFR5cGUsIC1zeW1ib2xTaXplWzBdIC8gMiwgLXN5bWJvbFNpemVbMV0gLyAyLFxyXG4gICAgICAgICAgICBzeW1ib2xTaXplWzBdLCBzeW1ib2xTaXplWzFdLCB0aGlzLm9wdGlvbnMuc3ltYm9sLmNvbG9yLCB0aGlzLm9wdGlvbnMuelxyXG4gICAgICAgICk7XHJcbiAgICAgICAgc3ltYm9sUGF0aC5uYW1lID0gbmFtZTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHN5bWJvbFBhdGg7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICog57uY5Yi257q/5q615LiK55qE5paH5pysXHJcbiAgICAgKiBAcGFyYW0gIHtbdHlwZV19IGNvbnRlbnQgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICogQHBhcmFtICB7W3R5cGVdfSBuYW1lIFtkZXNjcmlwdGlvbl1cclxuICAgICAqIEBwYXJhbSAge1t0eXBlXX0geCAgICAgICBbZGVzY3JpcHRpb25dXHJcbiAgICAgKiBAcGFyYW0gIHtbdHlwZV19IHkgICAgICAgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICogQHBhcmFtICB7W3R5cGVdfSBjb2xvciAgIFtkZXNjcmlwdGlvbl1cclxuICAgICAqIEByZXR1cm4ge1t0eXBlXX0gICAgICAgICBbZGVzY3JpcHRpb25dXHJcbiAgICAgKi9cclxuICAgIENvbm5lY3Rvci5wcm90b3R5cGUuZHJhd1RleHQgPSBmdW5jdGlvbiAobmFtZSxjb250ZW50LCB4LCB5LCBjb2xvcikge1xyXG4gICAgICAgIHZhciB0ZXh0ID0gbmV3IGdyYXBoaWMuVGV4dCh7XHJcbiAgICAgICAgICAgIHN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgICB0ZXh0OiBjb250ZW50LFxyXG4gICAgICAgICAgICAgICAgeDogeCxcclxuICAgICAgICAgICAgICAgIHk6IHksXHJcbiAgICAgICAgICAgICAgICBmaWxsOiBjb2xvciA/IGNvbG9yIDogdGhpcy5vcHRpb25zLnRleHQuY29sb3IsXHJcbiAgICAgICAgICAgICAgICB0ZXh0Rm9udDogdGhpcy5vcHRpb25zLnRleHQudGV4dEZvbnRcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgemxldmVsOiAyMFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRleHQubmFtZSA9IG5hbWU7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgdGV4dDogdGV4dCxcclxuICAgICAgICAgICAgcmVjdDogdGV4dC5nZXRCb3VuZGluZ1JlY3QoKVxyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICog6I635Y+W57q/5q6155qE5Lit6Ze05YC8XHJcbiAgICAgKiBAcmV0dXJuIHtbdHlwZV19IHRleHRcclxuICAgICAqL1xyXG4gICAgQ29ubmVjdG9yLnByb3RvdHlwZS5taWRkbGUgPSBmdW5jdGlvbih0ZXh0KXtcclxuXHJcbiAgICAgICAgaWYodGhpcy5vcHRpb25zLnN0eWxlLmxpbmVUeXBlID09IENvbm5lY3Rvci5UWVBFX1NUUkFJR0hUKXtcclxuICAgICAgICAgICAgdmFyIHBvaW50cyAgPSBVdGlsLmdldE1heExpbmVMZW5ndGgodGhpcy50dXJuaW5nUG9pbnRzKTtcclxuICAgICAgICAgICAgLy/lpoLmnpzmmK/msYLnur/mrrXkuIrnmoTmloflrZfnmoTkuK3pl7TlgLxcclxuICAgICAgICAgICAgLy8gaWYodGV4dCkge1xyXG4gICAgICAgICAgICAvLyAgICAgLy/lj5blh7rlrZfnmoTplb/luqbvvIzorqHnrpfop5LluqbvvIxcclxuICAgICAgICAgICAgLy8gICAgIHZhciB0ZXh0V2lkdGggPSBncmFwaGljLnRleHRDb250YWluLmdldFdpZHRoKHRleHQudGV4dCwgdGV4dC50ZXh0Rm9udCk7XHJcbiAgICAgICAgICAgIC8vICAgICB2YXIgYW5nbGUgPSBVdGlsLmdldEFuZ2xlKHBvaW50c1swXSxwb2ludHNbMV0pO1xyXG4gICAgICAgICAgICAvLyAgICAgdmFyIGxlbmd0aCA9ICBVdGlsLmRpc3RhbmNlKHBvaW50c1swXSxwb2ludHNbMV0pLzIgLSB0ZXh0V2lkdGgvMjtcclxuICAgICAgICAgICAgLy8gICAgIHZhciBuZXdQb2ludCA9IFV0aWwuZ2V0RW5kUG9pbnQocG9pbnRzWzBdLCBsZW5ndGgsIGFuZ2xlKTtcclxuICAgICAgICAgICAgLy8gICAgIHJldHVybiBbbmV3UG9pbnQueCwgbmV3UG9pbnQueV07XHJcbiAgICAgICAgICAgIC8vIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vICAgICB2YXIgbWlkZGxlWCA9IChwb2ludHNbMF0ueCArIHBvaW50c1sxXS54KS8yO1xyXG4gICAgICAgICAgICAvLyAgICAgdmFyIG1pZGRsZVkgPSAocG9pbnRzWzBdLnkgKyBwb2ludHNbMV0ueSkgLzI7XHJcbiAgICAgICAgICAgIC8vICAgICByZXR1cm4gW21pZGRsZVgsIG1pZGRsZVldO1xyXG4gICAgICAgICAgICAvLyB9XHJcbiAgICAgICAgICAgIHZhciBtaWRkbGVYID0gKHBvaW50c1swXS54ICsgcG9pbnRzWzFdLngpLzI7XHJcbiAgICAgICAgICAgIHZhciBtaWRkbGVZID0gKHBvaW50c1swXS55ICsgcG9pbnRzWzFdLnkpIC8yO1xyXG4gICAgICAgICAgICByZXR1cm4gW21pZGRsZVgsIG1pZGRsZVldO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmKHRoaXMub3B0aW9ucy5zdHlsZS5saW5lVHlwZSA9PSBDb25uZWN0b3IuVFlQRV9KQUdHRUQpe1xyXG5cclxuICAgICAgICAgICAgLy9maW5kIHRvdGFsIGRpc3RhbmNlXHJcbiAgICAgICAgICAgIHZhciBkaXN0YW5jZSA9IHRoaXMuZ2V0TGVuZ3RoKCk7XHJcblxyXG4gICAgICAgICAgICAvL2ZpbmQgYmV0d2VlbiB3aGF0IHR1cm5pbmcgcG9pbnRzIHRoZSBoYWxmIGRpc3RhbmNlIGlzXHJcbiAgICAgICAgICAgIHZhciBpbmRleCA9IC0xO1xyXG4gICAgICAgICAgICB2YXIgZWxsYXBzZWREaXN0YW5jZSA9IDA7XHJcbiAgICAgICAgICAgIGZvcih2YXIgaT0wOyBpPHRoaXMudHVybmluZ1BvaW50cy5sZW5ndGgtMTsgaSsrKXtcclxuICAgICAgICAgICAgICAgIGluZGV4ID0gaTtcclxuICAgICAgICAgICAgICAgIHZhciBzZWdtZW50ID0gVXRpbC5nZXRMZW5ndGgodGhpcy50dXJuaW5nUG9pbnRzW2ldLCB0aGlzLnR1cm5pbmdQb2ludHNbaSsxXSk7XHJcbiAgICAgICAgICAgICAgICBpZihlbGxhcHNlZERpc3RhbmNlICsgc2VnbWVudCA8IGRpc3RhbmNlIC8yKXtcclxuICAgICAgICAgICAgICAgICAgICBlbGxhcHNlZERpc3RhbmNlICs9IHNlZ21lbnQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNle1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvL3dlIGhhdmUgdGhlIG1pZGRsZSBkaXN0YW5jZSBzb21ld2hlcmUgYmV0d2VlbiBpKG5kZXgpIGFuZCBpKG5kZXgpKzFcclxuICAgICAgICAgICAgaWYoaW5kZXggIT0gLTEpe1xyXG4gICAgICAgICAgICAgICAgdmFyIG1pc3NpbmdEaXN0YW5jZSA9IGRpc3RhbmNlIC8gMiAtIGVsbGFwc2VkRGlzdGFuY2U7XHJcbiAgICAgICAgICAgICAgICBpZiggVXRpbC5yb3VuZCh0aGlzLnR1cm5pbmdQb2ludHNbaW5kZXhdLngsIDMpID09IFV0aWwucm91bmQodGhpcy50dXJuaW5nUG9pbnRzW2luZGV4ICsgMV0ueCwgMykgKXsgLy92ZXJ0aWNhbCBzZWdtZW50IChzYW1lIHgpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFt0aGlzLnR1cm5pbmdQb2ludHNbaW5kZXhdLngsIE1hdGgubWluKHRoaXMudHVybmluZ1BvaW50c1tpbmRleF0ueSwgdGhpcy50dXJuaW5nUG9pbnRzW2luZGV4ICsgMV0ueSkgKyBtaXNzaW5nRGlzdGFuY2VdO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmKCBVdGlsLnJvdW5kKHRoaXMudHVybmluZ1BvaW50c1tpbmRleF0ueSwgMykgPT0gVXRpbC5yb3VuZCh0aGlzLnR1cm5pbmdQb2ludHNbaW5kZXggKyAxXS55LCAzKSApIHsgLy9ob3Jpem9udGFsIHNlZ21lbnQgKHNhbWUgeSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW01hdGgubWluKHRoaXMudHVybmluZ1BvaW50c1tpbmRleF0ueCwgdGhpcy50dXJuaW5nUG9pbnRzW2luZGV4ICsgMV0ueCkgKyBtaXNzaW5nRGlzdGFuY2UsIHRoaXMudHVybmluZ1BvaW50c1tpbmRleF0ueV07XHJcbiAgICAgICAgICAgICAgICB9IGVsc2V7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkNvbm5lY3RvcjptaWRkbGUoKSAtIHRoaXMgc2hvdWxkIG5ldmVyIGhhcHBlbiBcIiArIHRoaXMudHVybmluZ1BvaW50c1tpbmRleF0gKyBcIiBcIiArIHRoaXMudHVybmluZ1BvaW50c1tpbmRleCArIDFdXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICsgXCIgbnIgb2YgcG9pbnRzIFwiICsgdGhpcy50dXJuaW5nUG9pbnRzLmxlbmd0aFxyXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmKHRoaXMub3B0aW9ucy5zdHlsZS5saW5lVHlwZSA9PSBDb25uZWN0b3IuVFlQRV9DVVJWRSl7XHJcbiAgICAgICAgICAgIHZhciB0ID0gMC41O1xyXG4gICAgICAgICAgICB2YXIgbCA9IHRoaXMuZ2V0TGVuZ3RoKCk7XHJcblxyXG4gICAgICAgICAgICB2YXIgd2Fsa2VkID0gMDtcclxuICAgICAgICAgICAgZm9yKHZhciBqID0wOyBqPCB0aGlzLnR1cm5pbmdQb2ludHMubGVuZ3RoLTE7IGorKyl7XHJcbiAgICAgICAgICAgICAgICBpZiggd2Fsa2VkICsgVXRpbC5kaXN0YW5jZSh0aGlzLnR1cm5pbmdQb2ludHNbal0sIHRoaXMudHVybmluZ1BvaW50c1tqKzFdKSA+IGwgKiB0ICl7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgd2Fsa2VkICs9IFV0aWwuZGlzdGFuY2UodGhpcy50dXJuaW5nUG9pbnRzW2pdLCB0aGlzLnR1cm5pbmdQb2ludHNbaisxXSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciByZXN0ID0gbCAqIHQgLSB3YWxrZWQ7XHJcbiAgICAgICAgICAgIHZhciBjdXJyZW50U2VnbWVudExlbmd0aCA9IFV0aWwuZGlzdGFuY2UodGhpcy50dXJuaW5nUG9pbnRzW2pdLCB0aGlzLnR1cm5pbmdQb2ludHNbaisxXSk7XHJcblxyXG4gICAgICAgICAgICAvL2ZpbmQgdGhlIHBvc2l0aW9uL3JhdGlvbiBvZiB0aGUgbWlkZGxlIG9mIFBvbHlsaW5lIG9uIGN1cnJlbnQgc2VnbWVudFxyXG4gICAgICAgICAgICB2YXIgc2VnbWVudFBlcmNlbnQgPSByZXN0IC8gY3VycmVudFNlZ21lbnRMZW5ndGg7XHJcblxyXG4gICAgICAgICAgICB2YXIgWHAgPSBzZWdtZW50UGVyY2VudCAqICh0aGlzLnR1cm5pbmdQb2ludHNbaisxXS54IC0gdGhpcy50dXJuaW5nUG9pbnRzW2pdLngpICsgdGhpcy50dXJuaW5nUG9pbnRzW2pdLng7XHJcbiAgICAgICAgICAgIHZhciBZcCA9IHNlZ21lbnRQZXJjZW50ICogKHRoaXMudHVybmluZ1BvaW50c1tqKzFdLnkgLSB0aGlzLnR1cm5pbmdQb2ludHNbal0ueSkgKyB0aGlzLnR1cm5pbmdQb2ludHNbal0ueTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBbWHAsIFlwXTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBmaW5kIHRvdGFsIGRpc3RhbmNlXHJcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFtkZXNjcmlwdGlvbl1cclxuICAgICAqL1xyXG4gICAgQ29ubmVjdG9yLnByb3RvdHlwZS5nZXRMZW5ndGggPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgLy9maW5kIHRvdGFsIGRpc3RhbmNlXHJcbiAgICAgICAgdmFyIGRpc3RhbmNlID0gMDtcclxuICAgICAgICBmb3IodmFyIGk9MDsgaTx0aGlzLnR1cm5pbmdQb2ludHMubGVuZ3RoLTE7IGkrKyl7XHJcbiAgICAgICAgICAgIGRpc3RhbmNlICs9IFV0aWwuZ2V0TGVuZ3RoKHRoaXMudHVybmluZ1BvaW50c1tpXSwgdGhpcy50dXJuaW5nUG9pbnRzW2krMV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZGlzdGFuY2U7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICog6L2sSlNPTuWvueixoVxyXG4gICAgICogQHJldHVybiB7W3R5cGVdfSBbZGVzY3JpcHRpb25dXHJcbiAgICAgKi9cclxuICAgIENvbm5lY3Rvci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgICAgIHRoaXMubW9kZWwuc2V0KFwicmVzb3VyY2VJZFwiLCB0aGlzLnJlc291cmNlSWQpO1xyXG4gICAgICAgIHRoaXMubW9kZWwuc2V0KFwicHJvcGVydGllcy50eXBlXCIsIDE0KTtcclxuXHJcbiAgICAgICAgdGhpcy5tb2RlbC5zZXQoXCJib3VuZHMudXBwZXJMZWZ0LnhcIiwgdGhpcy5wb3NpdGlvblswXSk7XHJcbiAgICAgICAgdGhpcy5tb2RlbC5zZXQoXCJib3VuZHMudXBwZXJMZWZ0LnlcIiwgdGhpcy5wb3NpdGlvblsxXSk7XHJcbiAgICAgICAgdGhpcy5tb2RlbC5zZXQoXCJib3VuZHMubG93ZXJSaWdodC54XCIsIHRoaXMucG9zaXRpb25bMF0gKyB0aGlzLmdldEJvdW5kaW5nUmVjdCgpLndpZHRoKTtcclxuICAgICAgICB0aGlzLm1vZGVsLnNldChcImJvdW5kcy5sb3dlclJpZ2h0LnlcIiwgdGhpcy5wb3NpdGlvblsxXSArIHRoaXMuZ2V0Qm91bmRpbmdSZWN0KCkuaGVpZ2h0KTtcclxuICAgICAgICB0aGlzLm1vZGVsLnNldChcInN0eWxlLnNQb3NcIiwgdGhpcy5zUG9zKTtcclxuICAgICAgICB0aGlzLm1vZGVsLnNldChcInN0eWxlLmVQb3NcIiwgdGhpcy5lUG9zKTtcclxuICAgICAgICB0aGlzLm1vZGVsLnNldChcImRvY2tlcnNcIix0aGlzLnR1cm5pbmdQb2ludHMpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLm1vZGVsLm9wdGlvbjtcclxuICAgIH07XHJcblxyXG4gICAgIC8qKlxyXG4gICAgICogcmVmcmVzaE1vZGVsXHJcbiAgICAgKiBAcmV0dXJuIHtbdHlwZV19IFtkZXNjcmlwdGlvbl1cclxuICAgICAqL1xyXG4gICAgQ29ubmVjdG9yLnByb3RvdHlwZS5yZWZyZXNoTW9kZWwgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB0aGlzLm1vZGVsLnNldChcIm9wdGlvbnMuZG9ja2Vyc1wiLHRoaXMudHVybmluZ1BvaW50cyk7XHJcbiAgICAgICAgdmFyIGljb25zID0gW107XHJcbiAgICAgICAgZm9yKHZhciBpID0gMDtpIDwgdGhpcy5pY29ucy5sZW5ndGg7aSsrKXtcclxuICAgICAgICAgICAgdmFyIGljb25Ob2RlID0gdGhpcy5pY29uc1tpXTtcclxuICAgICAgICAgICAgdmFyIG9wdGlvbiA9IFtpY29uTm9kZS5rZXkse1xyXG4gICAgICAgICAgICAgICAgaWNvbjppY29uTm9kZS5zdHlsZS5pbWFnZSxcclxuICAgICAgICAgICAgICAgIHdpZHRoOiBpY29uTm9kZS5zdHlsZS53aWR0aCxcclxuICAgICAgICAgICAgICAgIGhlaWdodDogaWNvbk5vZGUuc3R5bGUuaGVpZ2h0XHJcbiAgICAgICAgICAgIH1dO1xyXG4gICAgICAgICAgICBpY29ucy5wdXNoKG9wdGlvbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMubW9kZWwuc2V0KFwiaWNvbnNcIixpY29ucyk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICog6LCD5pW05puy57q/55qE5b2i54q2XHJcbiAgICAgKiBAcGFyYW0gIHthcnJheX0gcG9pbnRzIOeCueaVsOe7hFxyXG4gICAgICogQHJldHVybiB7dm9pZH1cclxuICAgICAqL1xyXG4gICAgQ29ubmVjdG9yLnByb3RvdHlwZS5tb2RpZnlDdXJ2ZSA9IGZ1bmN0aW9uKHBvaW50cykge1xyXG4gICAgICAgIHZhciBzb2wgPSB0aGlzLmdldEN1cnZlUG9pbnQocG9pbnRzKTtcclxuXHJcbiAgICAgICAgLy8gMS4g5aaC5p6c5puy57q/55qE5pWw6YePIOavlOaVsOmHj+eahOS4reaVsOmHj+imgeWwkSDliJnliKDpmaTlpJrkvZnnmoTnur/mrrVcclxuICAgICAgICB2YXIgd2lsbERlbEN1cnZlcyA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIGogPSBzb2wubGVuZ3RoLCBjbnRDdXJ2ZSA9IHRoaXMuZ3JvdXBDdXJ2ZS5jaGlsZENvdW50KCk7IGogPCBjbnRDdXJ2ZSA7IGorKykge1xyXG4gICAgICAgICAgICB3aWxsRGVsQ3VydmVzLnB1c2godGhpcy5ncm91cEN1cnZlLmNoaWxkQXQoaikpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB6clV0aWwuZWFjaCh3aWxsRGVsQ3VydmVzLCBmdW5jdGlvbihjdXJ2ZSkge1xyXG4gICAgICAgICAgICB0aGlzLmdyb3VwQ3VydmUucmVtb3ZlKGN1cnZlKTtcclxuICAgICAgICB9LCB0aGlzKTtcclxuICAgICAgICAvLyAyLiDpgY3ljobmm7Lnur8gICDlpoLmnpzlrZjlnKjliJnnm7TmjqXorr7nva7lvaLnirbvvIzlkKbliJnliJvlu7pcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNvbC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgbGluZSA9IHRoaXMuZ3JvdXBDdXJ2ZS5jaGlsZEF0KGkpO1xyXG4gICAgICAgICAgICBpZiAobGluZSkge1xyXG4gICAgICAgICAgICAgICAgbGluZS5hdHRyKCdzaGFwZScsIHNvbFtpXSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY3VyZSA9IG5ldyBncmFwaGljLkJlemllckN1cnZlKHtcclxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogdGhpcy5vcHRpb25zLnBvc2l0aW9uLFxyXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlOiB0aGlzLm9wdGlvbnMuc3R5bGUsXHJcbiAgICAgICAgICAgICAgICAgICAgc2hhcGU6IHNvbFtpXSxcclxuICAgICAgICAgICAgICAgICAgICB6OiB0aGlzLm9wdGlvbnMuelxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmdyb3VwQ3VydmUuYWRkKGN1cmUpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jcmVhdGVIb3ZlclN0eWxlKGN1cmUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDmoLnmja7kvKDlhaXnmoTngrnmlbDnu4TorqHnrpfmm7Lnur/nmoTngrlcclxuICAgICAqIEBwYXJhbSAge2FycmF5fSBQIOeCueaVsOe7hFxyXG4gICAgICogQHJldHVybiB7b2JqZWN0fSAgICAgICAg5puy57q/55qE54K55pWw57uEXHJcbiAgICAgKi9cclxuICAgIENvbm5lY3Rvci5wcm90b3R5cGUuZ2V0Q3VydmVQb2ludCA9IGZ1bmN0aW9uKFApIHtcclxuICAgICAgICB2YXIgbiA9IFAubGVuZ3RoO1xyXG4gICAgICAgIHZhciBzb2wgPSBbXTtcclxuICAgICAgICBpZiAobiA9PT0gMykge1xyXG4gICAgICAgICAgICBzb2wucHVzaCh7eDE6IFBbMF0ueCxcclxuICAgICAgICAgICAgICAgICAgIHkxOiBQWzBdLnksXHJcbiAgICAgICAgICAgICAgICAgICBjcHgxOiBQWzFdLngsXHJcbiAgICAgICAgICAgICAgICAgICBjcHkxOiBQWzFdLnksXHJcbiAgICAgICAgICAgICAgICAgICB4MjogUFsyXS54LFxyXG4gICAgICAgICAgICAgICAgICAgeTI6IFBbMl0ueVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiBzb2w7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKG4gPT09IDQpIHtcclxuICAgICAgICAgICAgc29sLnB1c2goe3gxOiBQWzBdLngsXHJcbiAgICAgICAgICAgICAgICAgICB5MTogUFswXS55LFxyXG4gICAgICAgICAgICAgICAgICAgY3B4MTogUFsxXS54LFxyXG4gICAgICAgICAgICAgICAgICAgY3B5MTogUFsxXS55LFxyXG4gICAgICAgICAgICAgICAgICAgY3B4MjogUFsyXS54LFxyXG4gICAgICAgICAgICAgICAgICAgY3B5MjogUFsyXS55LFxyXG4gICAgICAgICAgICAgICAgICAgeDI6IFBbM10ueCxcclxuICAgICAgICAgICAgICAgICAgIHkyOiBQWzNdLnlcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gc29sO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyoqQ29tcHV0ZXMgZmFjdG9yaWFsXHJcbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IGsgdGhlIG51bWJlclxyXG4gICAgICAgICAqICovXHJcbiAgICAgICAgZnVuY3Rpb24gZmFjdChrKXtcclxuICAgICAgICAgICAgaWYoaz09PTAgfHwgaz09PTEpe1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZXtcclxuICAgICAgICAgICAgICAgIHJldHVybiBrICogZmFjdChrLTEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKipDb21wdXRlcyBCZXJuc3RhaW4qL1xyXG4gICAgICAgIGZ1bmN0aW9uIEIoaSxuLHUpe1xyXG4gICAgICAgICAgICByZXR1cm4gZmFjdChuKSAvIChmYWN0KGkpICogZmFjdChuLWkpKSogTWF0aC5wb3codSwgaSkgKiBNYXRoLnBvdygxLXUsIG4taSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKipDb21wdXRlcyB0aGUgc3VtIGJldHdlZW4gdHdvIHBvaW50XHJcbiAgICAgICAgICpAcGFyYW0gcDEgLSB7UG9pbnR9XHJcbiAgICAgICAgICpAcGFyYW0gcDIgLSB7UG9pbnR9XHJcbiAgICAgICAgICpAcmV0dXJuIHtQb2ludH0gdGhlIHN1bSBvZiBpbml0aWFsIHBvaW50c1xyXG4gICAgICAgICAqKi9cclxuICAgICAgICBmdW5jdGlvbiBzdW0ocDEsIHAyKXtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludChwMS54ICsgcDIueCwgcDEueSArIHAyLnkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyoqQ29tcHV0ZXMgdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiBmaXJzdCB7UG9pbnR9IGFuZCBzZWNvbmQge1BvaW50fVxyXG4gICAgICAgICAqQHBhcmFtIHAxIC0ge1BvaW50fVxyXG4gICAgICAgICAqQHBhcmFtIHAyIC0ge1BvaW50fVxyXG4gICAgICAgICAqQHJldHVybiB7UG9pbnR9IHRoZSBzdW0gb2YgaW5pdGlhbCBwb2ludHNcclxuICAgICAgICAgKiovXHJcbiAgICAgICAgZnVuY3Rpb24gbWludXMocDEsIHAyKXtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludChwMS54IC0gcDIueCwgcDEueSAtIHAyLnkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyoqQ29tcHV0ZXMgdGhlIGRpdmlzaW9uIG9mIGEge1BvaW50fSBieSBhIG51bWJlclxyXG4gICAgICAgICAqQHBhcmFtIHAgLSB7UG9pbnR9XHJcbiAgICAgICAgICpAcGFyYW0gbnIgLSB7TnVtYmVyfVxyXG4gICAgICAgICAqQHJldHVybiB7UG9pbnR9XHJcbiAgICAgICAgICoqL1xyXG4gICAgICAgIGZ1bmN0aW9uIGRpdmlkZShwLCBucil7XHJcbiAgICAgICAgICAgIGlmKG5yID09IDApe1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgXCJEaXZpc2lvbiBieSB6ZXJvIG5vdCBhbGxvd2VkICh5ZXQgOikgXCIgKyB0aGlzLmNhbGxlZSA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludChwLngvbnIsIHAueS9ucik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKipDb21wdXRlcyB0aGUgbXVsdGlwbGljYXRpb24gb2YgYSB7UG9pbnR9IGJ5IGEgbnVtYmVyXHJcbiAgICAgICAgICpAcGFyYW0gcCAtIHtQb2ludH1cclxuICAgICAgICAgKkBwYXJhbSBuciAtIHtOdW1iZXJ9XHJcbiAgICAgICAgICpAcmV0dXJuIHtQb2ludH1cclxuICAgICAgICAgKiovXHJcbiAgICAgICAgZnVuY3Rpb24gbXVsdGlwbHkocCwgbnIpe1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFBvaW50IChwLnggKiBuciwgcC55ICogbnIpO1xyXG4gICAgICAgIH1cclxuXHJcblxyXG5cclxuXHJcbiAgICAgICAgLypcclxuICAgICAgICAgKkkgZG8gbm90IGdldCB3aHkgZmlyc3QgNCBtdXN0IGJlIDAgYW5kIGxhc3QgMyBvZiBzYW1lIHZhbHVlLi4uLi5cclxuICAgICAgICAgKmJ1dCBvdGhlcndpc2Ugd2Ugd2lsbCBnZXQgZGl2aXNpb24gYnkgemVyb1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHZhciBrID0gWzAsMCwwXTtcclxuXHJcbiAgICAgICAgdmFyIGo7XHJcbiAgICAgICAgZm9yKGo9MDtqPD1uLTM7aisrKXtcclxuICAgICAgICAgICAgay5wdXNoKGopO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgay5wdXNoKG4tMywgbi0zKTtcclxuXHJcblxyXG5cclxuICAgICAgICBmb3IoaT0xOyBpPD1uLTM7IGkrKyl7XHJcbiAgICAgICAgICAgIC8vcTEgLSBjb21wdXRlIHN0YXJ0IHBvaW50XHJcbiAgICAgICAgICAgIHZhciBxMSA9IGRpdmlkZSggc3VtKCBtdWx0aXBseShQW2ldLCBrW2krNF0gLSBrW2krMl0pLCBtdWx0aXBseShQW2krMV0sIGtbaSsyXSAtIGtbaSsxXSkgKSwga1tpKzRdIC0ga1tpKzFdKTtcclxuXHJcbiAgICAgICAgICAgIC8vcTAgLSBjb21wdXRlIDFzdCBjb250cm9sbCBwb2ludFxyXG4gICAgICAgICAgICB2YXIgcV8wMSA9IChrW2krM10gLSBrW2krMl0pIC8gKGtbaSszXSAtIGtbaSsxXSk7XHJcbiAgICAgICAgICAgIHZhciBxXzAyID0gZGl2aWRlKCBzdW0oIG11bHRpcGx5KFBbaS0xXSxrW2krM10gLSBrW2krMl0pLCBtdWx0aXBseShQW2ldLCBrW2krMl0gLSBrW2ldKSksIGtbaSszXSAtIGtbaV0pO1xyXG4gICAgICAgICAgICB2YXIgcV8wMyA9IG11bHRpcGx5KHExLCAoIGtbaSsyXSAtIGtbaSsxXSkvIChrW2krM10gLSBrW2krMV0pICk7XHJcbiAgICAgICAgICAgIHZhciBxMCA9IHN1bShtdWx0aXBseShxXzAyLCBxXzAxKSwgcV8wMyk7XHJcblxyXG4gICAgICAgICAgICAvL3EyIC0gY29tcHV0ZSAybmQgY29udHJvbGwgcG9pbnRcclxuICAgICAgICAgICAgdmFyIHEyID0gZGl2aWRlKCBzdW0oIG11bHRpcGx5KFBbaV0sIGtbaSs0XSAtIGtbaSszXSksIG11bHRpcGx5KFBbaSsxXSwga1tpKzNdIC0ga1tpKzFdKSApLCBrW2krNF0gLSBrW2krMV0gKTtcclxuXHJcbiAgICAgICAgICAgIC8vcTMgLSBjb21wdXRlIGVuZCBwb2ludFxyXG4gICAgICAgICAgICB2YXIgcV8zMSA9IChrW2krM10gLSBrW2krMl0pIC8gKGtbaSs0XSAtIGtbaSsyXSk7XHJcbiAgICAgICAgICAgIHZhciBxXzMyID0gZGl2aWRlKCBzdW0oIG11bHRpcGx5KFBbaSsxXSwga1tpKzVdIC0ga1tpKzNdKSwgbXVsdGlwbHkoUFtpKzJdLCBrW2krM10gLSBrW2krMl0pICkgLCBrW2krNV0gLSBrW2krMl0pO1xyXG4gICAgICAgICAgICB2YXIgcV8zMyA9IG11bHRpcGx5KHEyLCAoa1tpKzRdIC0ga1tpKzNdKS8oa1tpKzRdIC0ga1tpKzJdKSApO1xyXG4gICAgICAgICAgICB2YXIgcTMgPSBzdW0obXVsdGlwbHkocV8zMiwgcV8zMSksIHFfMzMpO1xyXG5cclxuICAgICAgICAgICAgLy9zdG9yZSBzb2x1dGlvblxyXG4gICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICBzb2wucHVzaCh7eDE6IHEwLngsXHJcbiAgICAgICAgICAgICAgICAgICB5MTogcTAueSxcclxuICAgICAgICAgICAgICAgICAgIGNweDE6IHExLngsXHJcbiAgICAgICAgICAgICAgICAgICBjcHkxOiBxMS55LFxyXG4gICAgICAgICAgICAgICAgICAgY3B4MjogcTIueCxcclxuICAgICAgICAgICAgICAgICAgIGNweTI6IHEyLnksXHJcbiAgICAgICAgICAgICAgICAgICB4MjogcTMueCxcclxuICAgICAgICAgICAgICAgICAgIHkyOiBxMy55XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBzb2w7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICBVdGlsLmluaGVyaXRzKENvbm5lY3RvcixOb2RlKTtcclxuXHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IENvbm5lY3RvcjtcclxuXHJcblxyXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vbGliL2Zpc2gtdG9wby1jb3JlL2xpYi9zaGFwZXMvQ29ubmVjdG9yLmpzXG4gKiogbW9kdWxlIGlkID0gNzdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0Jztcbi8vIFN5bWJvbCBmYWN0b3J5XHJcblxyXG5cclxuICAgIHZhciBncmFwaGljID0gcmVxdWlyZSgnLi4vZ3JhcGhpYycpO1xyXG4gICAgdmFyIEJvdW5kaW5nUmVjdCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvQm91bmRpbmdSZWN0Jyk7XHJcbiAgICAvKipcclxuICAgICAqIFRyaWFuZ2xlIHNoYXBlXHJcbiAgICAgKiBAaW5uZXJcclxuICAgICAqL1xyXG4gICAgdmFyIFRyaWFuZ2xlID0gZ3JhcGhpYy5leHRlbmRTaGFwZSh7XHJcbiAgICAgICAgdHlwZTogJ3RyaWFuZ2xlJyxcclxuICAgICAgICBzaGFwZToge1xyXG4gICAgICAgICAgICBjeDogMCxcclxuICAgICAgICAgICAgY3k6IDAsXHJcbiAgICAgICAgICAgIHdpZHRoOiAwLFxyXG4gICAgICAgICAgICBoZWlnaHQ6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIGJ1aWxkUGF0aDogZnVuY3Rpb24gKHBhdGgsIHNoYXBlKSB7XHJcbiAgICAgICAgICAgIHZhciBjeCA9IHNoYXBlLmN4O1xyXG4gICAgICAgICAgICB2YXIgY3kgPSBzaGFwZS5jeTtcclxuICAgICAgICAgICAgdmFyIHdpZHRoID0gc2hhcGUud2lkdGggLyAyO1xyXG4gICAgICAgICAgICB2YXIgaGVpZ2h0ID0gc2hhcGUuaGVpZ2h0IC8gMjtcclxuICAgICAgICAgICAgcGF0aC5tb3ZlVG8oY3gsIGN5IC0gaGVpZ2h0KTtcclxuICAgICAgICAgICAgcGF0aC5saW5lVG8oY3ggKyB3aWR0aCwgY3kgKyBoZWlnaHQpO1xyXG4gICAgICAgICAgICBwYXRoLmxpbmVUbyhjeCAtIHdpZHRoLCBjeSArIGhlaWdodCk7XHJcbiAgICAgICAgICAgIHBhdGguY2xvc2VQYXRoKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICAvKipcclxuICAgICAqIERpYW1vbmQgc2hhcGVcclxuICAgICAqIEBpbm5lclxyXG4gICAgICovXHJcbiAgICB2YXIgRGlhbW9uZCA9IGdyYXBoaWMuZXh0ZW5kU2hhcGUoe1xyXG4gICAgICAgIHR5cGU6ICdkaWFtb25kJyxcclxuICAgICAgICBzaGFwZToge1xyXG4gICAgICAgICAgICBjeDogMCxcclxuICAgICAgICAgICAgY3k6IDAsXHJcbiAgICAgICAgICAgIHdpZHRoOiAwLFxyXG4gICAgICAgICAgICBoZWlnaHQ6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIGJ1aWxkUGF0aDogZnVuY3Rpb24gKHBhdGgsIHNoYXBlKSB7XHJcbiAgICAgICAgICAgIHZhciBjeCA9IHNoYXBlLmN4O1xyXG4gICAgICAgICAgICB2YXIgY3kgPSBzaGFwZS5jeTtcclxuICAgICAgICAgICAgdmFyIHdpZHRoID0gc2hhcGUud2lkdGggLyAyO1xyXG4gICAgICAgICAgICB2YXIgaGVpZ2h0ID0gc2hhcGUuaGVpZ2h0IC8gMjtcclxuICAgICAgICAgICAgcGF0aC5tb3ZlVG8oY3gsIGN5IC0gaGVpZ2h0KTtcclxuICAgICAgICAgICAgcGF0aC5saW5lVG8oY3ggKyB3aWR0aCwgY3kpO1xyXG4gICAgICAgICAgICBwYXRoLmxpbmVUbyhjeCwgY3kgKyBoZWlnaHQpO1xyXG4gICAgICAgICAgICBwYXRoLmxpbmVUbyhjeCAtIHdpZHRoLCBjeSk7XHJcbiAgICAgICAgICAgIHBhdGguY2xvc2VQYXRoKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQaW4gc2hhcGVcclxuICAgICAqIEBpbm5lclxyXG4gICAgICovXHJcbiAgICB2YXIgUGluID0gZ3JhcGhpYy5leHRlbmRTaGFwZSh7XHJcbiAgICAgICAgdHlwZTogJ3BpbicsXHJcbiAgICAgICAgc2hhcGU6IHtcclxuICAgICAgICAgICAgLy8geCwgeSBvbiB0aGUgY3VzcFxyXG4gICAgICAgICAgICB4OiAwLFxyXG4gICAgICAgICAgICB5OiAwLFxyXG4gICAgICAgICAgICB3aWR0aDogMCxcclxuICAgICAgICAgICAgaGVpZ2h0OiAwXHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgYnVpbGRQYXRoOiBmdW5jdGlvbiAocGF0aCwgc2hhcGUpIHtcclxuICAgICAgICAgICAgdmFyIHggPSBzaGFwZS54O1xyXG4gICAgICAgICAgICB2YXIgeSA9IHNoYXBlLnk7XHJcbiAgICAgICAgICAgIHZhciB3ID0gc2hhcGUud2lkdGggLyA1ICogMztcclxuICAgICAgICAgICAgLy8gSGVpZ2h0IG11c3QgYmUgbGFyZ2VyIHRoYW4gd2lkdGhcclxuICAgICAgICAgICAgdmFyIGggPSBNYXRoLm1heCh3LCBzaGFwZS5oZWlnaHQpO1xyXG4gICAgICAgICAgICB2YXIgciA9IHcgLyAyO1xyXG5cclxuICAgICAgICAgICAgLy8gRGlzdCBvbiB5IHdpdGggdGFuZ2VudCBwb2ludCBhbmQgY2lyY2xlIGNlbnRlclxyXG4gICAgICAgICAgICB2YXIgZHkgPSByICogciAvIChoIC0gcik7XHJcbiAgICAgICAgICAgIHZhciBjeSA9IHkgLSBoICsgciArIGR5O1xyXG4gICAgICAgICAgICB2YXIgYW5nbGUgPSBNYXRoLmFzaW4oZHkgLyByKTtcclxuICAgICAgICAgICAgLy8gRGlzdCBvbiB4IHdpdGggdGFuZ2VudCBwb2ludCBhbmQgY2lyY2xlIGNlbnRlclxyXG4gICAgICAgICAgICB2YXIgZHggPSBNYXRoLmNvcyhhbmdsZSkgKiByO1xyXG5cclxuICAgICAgICAgICAgdmFyIHRhblggPSBNYXRoLnNpbihhbmdsZSk7XHJcbiAgICAgICAgICAgIHZhciB0YW5ZID0gTWF0aC5jb3MoYW5nbGUpO1xyXG5cclxuICAgICAgICAgICAgcGF0aC5hcmMoXHJcbiAgICAgICAgICAgICAgICB4LCBjeSwgcixcclxuICAgICAgICAgICAgICAgIE1hdGguUEkgLSBhbmdsZSxcclxuICAgICAgICAgICAgICAgIE1hdGguUEkgKiAyICsgYW5nbGVcclxuICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgIHZhciBjcExlbiA9IHIgKiAwLjY7XHJcbiAgICAgICAgICAgIHZhciBjcExlbjIgPSByICogMC43O1xyXG4gICAgICAgICAgICBwYXRoLmJlemllckN1cnZlVG8oXHJcbiAgICAgICAgICAgICAgICB4ICsgZHggLSB0YW5YICogY3BMZW4sIGN5ICsgZHkgKyB0YW5ZICogY3BMZW4sXHJcbiAgICAgICAgICAgICAgICB4LCB5IC0gY3BMZW4yLFxyXG4gICAgICAgICAgICAgICAgeCwgeVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICBwYXRoLmJlemllckN1cnZlVG8oXHJcbiAgICAgICAgICAgICAgICB4LCB5IC0gY3BMZW4yLFxyXG4gICAgICAgICAgICAgICAgeCAtIGR4ICsgdGFuWCAqIGNwTGVuLCBjeSArIGR5ICsgdGFuWSAqIGNwTGVuLFxyXG4gICAgICAgICAgICAgICAgeCAtIGR4LCBjeSArIGR5XHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIHBhdGguY2xvc2VQYXRoKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBcnJvdyBzaGFwZVxyXG4gICAgICogQGlubmVyXHJcbiAgICAgKi9cclxuICAgIHZhciBBcnJvdyA9IGdyYXBoaWMuZXh0ZW5kU2hhcGUoe1xyXG5cclxuICAgICAgICB0eXBlOiAnYXJyb3cnLFxyXG5cclxuICAgICAgICBzaGFwZToge1xyXG4gICAgICAgICAgICB4OiAwLFxyXG4gICAgICAgICAgICB5OiAwLFxyXG4gICAgICAgICAgICB3aWR0aDogMCxcclxuICAgICAgICAgICAgaGVpZ2h0OiAwXHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgYnVpbGRQYXRoOiBmdW5jdGlvbiAoY3R4LCBzaGFwZSkge1xyXG4gICAgICAgICAgICB2YXIgaGVpZ2h0ID0gc2hhcGUuaGVpZ2h0O1xyXG4gICAgICAgICAgICB2YXIgd2lkdGggPSBzaGFwZS53aWR0aDtcclxuICAgICAgICAgICAgdmFyIHggPSBzaGFwZS54O1xyXG4gICAgICAgICAgICB2YXIgeSA9IHNoYXBlLnk7XHJcbiAgICAgICAgICAgIHZhciBkeCA9IHdpZHRoIC8gMyAqIDI7XHJcbiAgICAgICAgICAgIGN0eC5tb3ZlVG8oeCwgeSk7XHJcbiAgICAgICAgICAgIGN0eC5saW5lVG8oeCArIGR4LCB5ICsgaGVpZ2h0KTtcclxuICAgICAgICAgICAgY3R4LmxpbmVUbyh4LCB5ICsgaGVpZ2h0IC8gNCAqIDMpO1xyXG4gICAgICAgICAgICBjdHgubGluZVRvKHggLSBkeCwgeSArIGhlaWdodCk7XHJcbiAgICAgICAgICAgIGN0eC5saW5lVG8oeCwgeSk7XHJcbiAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIE1hcCBvZiBwYXRoIGNvbnRydWN0b3JzXHJcbiAgICAgKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsIG1vZHVsZTp6cmVuZGVyL2dyYXBoaWMvUGF0aD59XHJcbiAgICAgKi9cclxuICAgIHZhciBzeW1ib2xDdG9ycyA9IHtcclxuICAgICAgICBsaW5lOiBncmFwaGljLkxpbmUsXHJcblxyXG4gICAgICAgIHJlY3Q6IGdyYXBoaWMuUmVjdCxcclxuXHJcbiAgICAgICAgcm91bmRSZWN0OiBncmFwaGljLlJlY3QsXHJcblxyXG4gICAgICAgIHNxdWFyZTogZ3JhcGhpYy5SZWN0LFxyXG5cclxuICAgICAgICBjaXJjbGU6IGdyYXBoaWMuQ2lyY2xlLFxyXG5cclxuICAgICAgICBkaWFtb25kOiBEaWFtb25kLFxyXG5cclxuICAgICAgICBwaW46IFBpbixcclxuXHJcbiAgICAgICAgYXJyb3c6IEFycm93LFxyXG5cclxuICAgICAgICB0cmlhbmdsZTogVHJpYW5nbGVcclxuICAgIH07XHJcblxyXG4gICAgdmFyIHN5bWJvbFNoYXBlTWFrZXJzID0ge1xyXG5cclxuICAgICAgICBsaW5lOiBmdW5jdGlvbiAoeCwgeSwgdywgaCwgc2hhcGUpIHtcclxuICAgICAgICAgICAgLy8gRklYTUVcclxuICAgICAgICAgICAgc2hhcGUueDEgPSB4O1xyXG4gICAgICAgICAgICBzaGFwZS55MSA9IHkgKyBoIC8gMjtcclxuICAgICAgICAgICAgc2hhcGUueDIgPSB4ICsgdztcclxuICAgICAgICAgICAgc2hhcGUueTIgPSB5ICsgaCAvIDI7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgcmVjdDogZnVuY3Rpb24gKHgsIHksIHcsIGgsIHNoYXBlKSB7XHJcbiAgICAgICAgICAgIHNoYXBlLnggPSB4O1xyXG4gICAgICAgICAgICBzaGFwZS55ID0geTtcclxuICAgICAgICAgICAgc2hhcGUud2lkdGggPSB3O1xyXG4gICAgICAgICAgICBzaGFwZS5oZWlnaHQgPSBoO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHJvdW5kUmVjdDogZnVuY3Rpb24gKHgsIHksIHcsIGgsIHNoYXBlKSB7XHJcbiAgICAgICAgICAgIHNoYXBlLnggPSB4O1xyXG4gICAgICAgICAgICBzaGFwZS55ID0geTtcclxuICAgICAgICAgICAgc2hhcGUud2lkdGggPSB3O1xyXG4gICAgICAgICAgICBzaGFwZS5oZWlnaHQgPSBoO1xyXG4gICAgICAgICAgICBzaGFwZS5yID0gTWF0aC5taW4odywgaCkgLyA0O1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNxdWFyZTogZnVuY3Rpb24gKHgsIHksIHcsIGgsIHNoYXBlKSB7XHJcbiAgICAgICAgICAgIHZhciBzaXplID0gTWF0aC5taW4odywgaCk7XHJcbiAgICAgICAgICAgIHNoYXBlLnggPSB4O1xyXG4gICAgICAgICAgICBzaGFwZS55ID0geTtcclxuICAgICAgICAgICAgc2hhcGUud2lkdGggPSBzaXplO1xyXG4gICAgICAgICAgICBzaGFwZS5oZWlnaHQgPSBzaXplO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGNpcmNsZTogZnVuY3Rpb24gKHgsIHksIHcsIGgsIHNoYXBlKSB7XHJcbiAgICAgICAgICAgIC8vIFB1dCBjaXJjbGUgaW4gdGhlIGNlbnRlciBvZiBzcXVhcmVcclxuICAgICAgICAgICAgc2hhcGUuY3ggPSB4ICsgdyAvIDI7XHJcbiAgICAgICAgICAgIHNoYXBlLmN5ID0geSArIGggLyAyO1xyXG4gICAgICAgICAgICBzaGFwZS5yID0gTWF0aC5taW4odywgaCkgLyAyO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGRpYW1vbmQ6IGZ1bmN0aW9uICh4LCB5LCB3LCBoLCBzaGFwZSkge1xyXG4gICAgICAgICAgICBzaGFwZS5jeCA9IHggKyB3IC8gMjtcclxuICAgICAgICAgICAgc2hhcGUuY3kgPSB5ICsgaCAvIDI7XHJcbiAgICAgICAgICAgIHNoYXBlLndpZHRoID0gdztcclxuICAgICAgICAgICAgc2hhcGUuaGVpZ2h0ID0gaDtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBwaW46IGZ1bmN0aW9uICh4LCB5LCB3LCBoLCBzaGFwZSkge1xyXG4gICAgICAgICAgICBzaGFwZS54ID0geCArIHcgLyAyO1xyXG4gICAgICAgICAgICBzaGFwZS55ID0geSArIGggLyAyO1xyXG4gICAgICAgICAgICBzaGFwZS53aWR0aCA9IHc7XHJcbiAgICAgICAgICAgIHNoYXBlLmhlaWdodCA9IGg7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgYXJyb3c6IGZ1bmN0aW9uICh4LCB5LCB3LCBoLCBzaGFwZSkge1xyXG4gICAgICAgICAgICBzaGFwZS54ID0geCArIHcgLyAyO1xyXG4gICAgICAgICAgICBzaGFwZS55ID0geSArIGggLyAyO1xyXG4gICAgICAgICAgICBzaGFwZS53aWR0aCA9IHc7XHJcbiAgICAgICAgICAgIHNoYXBlLmhlaWdodCA9IGg7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgdHJpYW5nbGU6IGZ1bmN0aW9uICh4LCB5LCB3LCBoLCBzaGFwZSkge1xyXG4gICAgICAgICAgICBzaGFwZS5jeCA9IHggKyB3IC8gMjtcclxuICAgICAgICAgICAgc2hhcGUuY3kgPSB5ICsgaCAvIDI7XHJcbiAgICAgICAgICAgIHNoYXBlLndpZHRoID0gdztcclxuICAgICAgICAgICAgc2hhcGUuaGVpZ2h0ID0gaDtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHZhciBzeW1ib2xCdWlsZFByb3hpZXMgPSB7fTtcclxuICAgIGZvciAodmFyIG5hbWUgaW4gc3ltYm9sQ3RvcnMpIHtcclxuICAgICAgICBzeW1ib2xCdWlsZFByb3hpZXNbbmFtZV0gPSBuZXcgc3ltYm9sQ3RvcnNbbmFtZV0oKTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgU3ltYm9sID0gZ3JhcGhpYy5leHRlbmRTaGFwZSh7XHJcblxyXG4gICAgICAgIHR5cGU6ICdzeW1ib2wnLFxyXG5cclxuICAgICAgICBzaGFwZToge1xyXG4gICAgICAgICAgICBzeW1ib2xUeXBlOiAnJyxcclxuICAgICAgICAgICAgeDogMCxcclxuICAgICAgICAgICAgeTogMCxcclxuICAgICAgICAgICAgd2lkdGg6IDAsXHJcbiAgICAgICAgICAgIGhlaWdodDogMFxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGJlZm9yZUJydXNoOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBzdHlsZSA9IHRoaXMuc3R5bGU7XHJcbiAgICAgICAgICAgIHZhciBzaGFwZSA9IHRoaXMuc2hhcGU7XHJcbiAgICAgICAgICAgIC8vIEZJWE1FXHJcbiAgICAgICAgICAgIGlmIChzaGFwZS5zeW1ib2xUeXBlID09PSAncGluJyAmJiBzdHlsZS50ZXh0UG9zaXRpb24gPT09ICdpbnNpZGUnKSB7XHJcbiAgICAgICAgICAgICAgICBzdHlsZS50ZXh0UG9zaXRpb24gPSBbJzUwJScsICc0MCUnXTtcclxuICAgICAgICAgICAgICAgIHN0eWxlLnRleHRBbGlnbiA9ICdjZW50ZXInO1xyXG4gICAgICAgICAgICAgICAgc3R5bGUudGV4dFZlcnRpY2FsQWxpZ24gPSAnbWlkZGxlJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGJ1aWxkUGF0aDogZnVuY3Rpb24gKGN0eCwgc2hhcGUpIHtcclxuICAgICAgICAgICAgdmFyIHN5bWJvbFR5cGUgPSBzaGFwZS5zeW1ib2xUeXBlO1xyXG4gICAgICAgICAgICB2YXIgcHJveHlTeW1ib2wgPSBzeW1ib2xCdWlsZFByb3hpZXNbc3ltYm9sVHlwZV07XHJcbiAgICAgICAgICAgIGlmIChzaGFwZS5zeW1ib2xUeXBlICE9PSAnbm9uZScpIHtcclxuICAgICAgICAgICAgICAgIGlmICghcHJveHlTeW1ib2wpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBEZWZhdWx0IHJlY3RcclxuICAgICAgICAgICAgICAgICAgICBzeW1ib2xUeXBlID0gJ3JlY3QnO1xyXG4gICAgICAgICAgICAgICAgICAgIHByb3h5U3ltYm9sID0gc3ltYm9sQnVpbGRQcm94aWVzW3N5bWJvbFR5cGVdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgc3ltYm9sU2hhcGVNYWtlcnNbc3ltYm9sVHlwZV0oXHJcbiAgICAgICAgICAgICAgICAgICAgc2hhcGUueCwgc2hhcGUueSwgc2hhcGUud2lkdGgsIHNoYXBlLmhlaWdodCwgcHJveHlTeW1ib2wuc2hhcGVcclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICBwcm94eVN5bWJvbC5idWlsZFBhdGgoY3R4LCBwcm94eVN5bWJvbC5zaGFwZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBQcm92aWRlIHNldENvbG9yIGhlbHBlciBtZXRob2QgdG8gYXZvaWQgZGV0ZXJtaW5lIGlmIHNldCB0aGUgZmlsbCBvciBzdHJva2Ugb3V0c2lkZVxyXG4gICAgdmFyIHN5bWJvbFBhdGhTZXRDb2xvciA9IGZ1bmN0aW9uIChjb2xvcikge1xyXG4gICAgICAgIGlmICh0aGlzLnR5cGUgIT09ICdpbWFnZScpIHtcclxuICAgICAgICAgICAgdmFyIHN5bWJvbFN0eWxlID0gdGhpcy5zdHlsZTtcclxuICAgICAgICAgICAgdmFyIHN5bWJvbFNoYXBlID0gdGhpcy5zaGFwZTtcclxuICAgICAgICAgICAgaWYgKHN5bWJvbFNoYXBlICYmIHN5bWJvbFNoYXBlLnN5bWJvbFR5cGUgPT09ICdsaW5lJykge1xyXG4gICAgICAgICAgICAgICAgc3ltYm9sU3R5bGUuc3Ryb2tlID0gY29sb3I7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fX2lzRW1wdHlCcnVzaCkge1xyXG4gICAgICAgICAgICAgICAgc3ltYm9sU3R5bGUuc3Ryb2tlID0gY29sb3I7XHJcbiAgICAgICAgICAgICAgICBzeW1ib2xTdHlsZS5maWxsID0gJyNmZmYnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gRklYTUUg5Yik5pat5Zu+5b2i6buY6K6k5piv5aGr5YWF6L+Y5piv5o+P6L6577yM5L2/55SoIG9ubHlTdHJva2UgP1xyXG4gICAgICAgICAgICAgICAgc3ltYm9sU3R5bGUuZmlsbCAmJiAoc3ltYm9sU3R5bGUuZmlsbCA9IGNvbG9yKTtcclxuICAgICAgICAgICAgICAgIHN5bWJvbFN0eWxlLnN0cm9rZSAmJiAoc3ltYm9sU3R5bGUuc3Ryb2tlID0gY29sb3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuZGlydHkoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHZhciBzeW1ib2xVdGlsID0ge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENyZWF0ZSBhIHN5bWJvbCBlbGVtZW50IHdpdGggZ2l2ZW4gc3ltYm9sIGNvbmZpZ3VyYXRpb246IHNoYXBlLCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCBjb2xvclxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzeW1ib2xUeXBlXHJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHhcclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0geVxyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3XHJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGhcclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gelxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb2xvclxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGNyZWF0ZVN5bWJvbDogZnVuY3Rpb24gKHN5bWJvbFR5cGUsIHgsIHksIHcsIGgsIGNvbG9yLCB6KSB7XHJcbiAgICAgICAgICAgIHZhciBpc0VtcHR5ID0gc3ltYm9sVHlwZS5pbmRleE9mKCdlbXB0eScpID09PSAwO1xyXG4gICAgICAgICAgICBpZiAoaXNFbXB0eSkge1xyXG4gICAgICAgICAgICAgICAgc3ltYm9sVHlwZSA9IHN5bWJvbFR5cGUuc3Vic3RyKDUsIDEpLnRvTG93ZXJDYXNlKCkgKyBzeW1ib2xUeXBlLnN1YnN0cig2KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgc3ltYm9sUGF0aDtcclxuXHJcbiAgICAgICAgICAgIGlmIChzeW1ib2xUeXBlLmluZGV4T2YoJ2ltYWdlOi8vJykgPT09IDApIHtcclxuICAgICAgICAgICAgICAgIHN5bWJvbFBhdGggPSBuZXcgZ3JhcGhpYy5JbWFnZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2U6IHN5bWJvbFR5cGUuc2xpY2UoOCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHg6IHgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHk6IHksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiB3LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGhcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIHo6IHpcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHN5bWJvbFR5cGUuaW5kZXhPZigncGF0aDovLycpID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBzeW1ib2xQYXRoID0gZ3JhcGhpYy5tYWtlUGF0aChzeW1ib2xUeXBlLnNsaWNlKDcpLCB7ejogen0sIG5ldyBCb3VuZGluZ1JlY3QoeCwgeSwgdywgaCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgc3ltYm9sUGF0aCA9IG5ldyBTeW1ib2woe1xyXG4gICAgICAgICAgICAgICAgICAgIHNoYXBlOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN5bWJvbFR5cGU6IHN5bWJvbFR5cGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHg6IHgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHk6IHksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiB3LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGhcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIHo6IHpcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBzeW1ib2xQYXRoLl9faXNFbXB0eUJydXNoID0gaXNFbXB0eTtcclxuXHJcbiAgICAgICAgICAgIHN5bWJvbFBhdGguc2V0Q29sb3IgPSBzeW1ib2xQYXRoU2V0Q29sb3I7XHJcblxyXG4gICAgICAgICAgICBzeW1ib2xQYXRoLnNldENvbG9yKGNvbG9yKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBzeW1ib2xQYXRoO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBzeW1ib2xVdGlsO1xyXG5cclxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2xpYi9maXNoLXRvcG8tY29yZS9saWIvc2hhcGVzL1N5bWJvbC5qc1xuICoqIG1vZHVsZSBpZCA9IDc4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcclxuICog55S75Y+l5p+EXHJcbiAqIEBhdXRob3Igd2FuZy54aWFvaHVcclxuICovXHJcblxyXG4gICAgdmFyIGdyYXBoaWMgPSByZXF1aXJlKFwiLi4vZ3JhcGhpYy5qc1wiKTtcclxuICAgIHZhciBVdGlsID0gcmVxdWlyZShcIi4uL3V0aWwuanNcIik7XHJcbiAgICBmdW5jdGlvbiBIYW5kbGUodHlwZSwgeCwgeSwgY29ubmVjdG9yKXtcclxuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xyXG5cclxuICAgICAgICB0aGlzLnggPSB4O1xyXG5cclxuICAgICAgICB0aGlzLnkgPSB5O1xyXG5cclxuICAgICAgICB0aGlzLnZpc2libGUgPSB0cnVlO1xyXG5cclxuICAgICAgICB0aGlzLmNvbm5lY3RvciA9IGNvbm5lY3RvcjtcclxuXHJcbiAgICAgICAgdGhpcy5oYW5kbGVTaGFwZSA9IG5ldyBncmFwaGljLkNpcmNsZSh7XHJcbiAgICAgICAgICAgIHNoYXBlOiB7XHJcbiAgICAgICAgICAgICAgICBjeDogeCxcclxuICAgICAgICAgICAgICAgIGN5OiB5LFxyXG4gICAgICAgICAgICAgICAgcjogSGFuZGxlLlJBRElVU1xyXG4gICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgIGZpbGw6IFwicmdiKDAsMjU1LDApXCIsXHJcbiAgICAgICAgICAgICAgICBzdHJva2U6XCJyZ2IoMCwwLDApXCJcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgeiA6IGNvbm5lY3Rvci5vcHRpb25zLnogKyAyLCAgLy/oioLngrla5Li6MSDnur/mrrXkuLowO1xyXG4gICAgICAgICAgICBkcmFnZ2FibGU6dHJ1ZVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5oYW5kbGVTaGFwZS5vbihcImRyYWdcIiwgZnVuY3Rpb24oZSkge1xyXG4gICAgICAgICAgICB0aGF0LmFjdGlvbkNvbm5lY3RvcihlLm9mZnNldFgsZS5vZmZzZXRZKTtcclxuICAgICAgICB9KTtcclxuICAgICAgIC8vIHJldHVybiB0aGlzLmNpcmNsZTtcclxuICAgIH1cclxuXHJcbiAgICBIYW5kbGUuUkFESVVTID0gNDtcclxuXHJcbiAgICBIYW5kbGUucHJvdG90eXBlID0ge1xyXG5cclxuICAgICAgICBjb25zdHJ1Y3RvciA6IEhhbmRsZSxcclxuXHJcbiAgICAgICAgZXF1YWxzIDogZnVuY3Rpb24oYW5vdGhlckhhbmRsZSl7XHJcbiAgICAgICAgICAgIGlmKCFhbm90aGVySGFuZGxlIGluc3RhbmNlb2YgSGFuZGxlKXtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudHlwZSA9PSBhbm90aGVySGFuZGxlLnR5cGVcclxuICAgICAgICAgICAgJiYgdGhpcy54ID09IGFub3RoZXJIYW5kbGUueFxyXG4gICAgICAgICAgICAmJiB0aGlzLnkgPT0gYW5vdGhlckhhbmRsZS55XHJcbiAgICAgICAgICAgICYmIHRoaXMudmlzaWJsZSA9PSBhbm90aGVySGFuZGxlLnZpc2libGU7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICog56e75Yqo5Y+l5p+EXHJcbiAgICAgICAgICogQHBhcmFtICB7W3R5cGVdfSBuZXdYIFtkZXNjcmlwdGlvbl1cclxuICAgICAgICAgKiBAcGFyYW0gIHtbdHlwZV19IG5ld1kgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICAgICAqIEByZXR1cm4ge1t0eXBlXX0gICAgICBbZGVzY3JpcHRpb25dXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgYWN0aW9uQ29ubmVjdG9yOiBmdW5jdGlvbihuZXdYLCBuZXdZKXtcclxuICAgICAgICAgICAgc3dpdGNoKHRoaXMudHlwZSl7XHJcbiAgICAgICAgICAgICAgICBjYXNlICd2JzpcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXg7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8g5om+5Ye65Lik5Liq6L2s5oqY54K577yI5Y+v56e75Yqo5Y+l5p+E5Zyo6L+Z5Lik5Liq6L2s5oqY54K55Lit6Ze077yJXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yKHZhciBpID0gMTsgaSA8IHRoaXMuY29ubmVjdG9yLnR1cm5pbmdQb2ludHMubGVuZ3RoLTE7IGkrKyl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHRoaXMuY29ubmVjdG9yLnR1cm5pbmdQb2ludHNbaS0xXS55ID09IHRoaXMuY29ubmVjdG9yLnR1cm5pbmdQb2ludHNbaV0ueVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgdGhpcy5jb25uZWN0b3IudHVybmluZ1BvaW50c1tpXS55ID09IHRoaXMueVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgTWF0aC5taW4odGhpcy5jb25uZWN0b3IudHVybmluZ1BvaW50c1tpXS54LCB0aGlzLmNvbm5lY3Rvci50dXJuaW5nUG9pbnRzW2ktMV0ueCkgPD0gdGhpcy54XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAmJiBNYXRoLm1heCh0aGlzLmNvbm5lY3Rvci50dXJuaW5nUG9pbnRzW2ldLngsIHRoaXMuY29ubmVjdG9yLnR1cm5pbmdQb2ludHNbaS0xXS54KSA+PSB0aGlzLngpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ID0gaTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB2YXIgZGVsdGFZID0gbmV3WSAtIHRoaXMueTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdHJhbnNsYXRpb25NYXRyaXggPSBVdGlsLnRyYW5zbGF0aW9uTWF0cml4KDAsIGRlbHRhWSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdG9yLnR1cm5pbmdQb2ludHNbaW5kZXgtMV0udHJhbnNmb3JtKHRyYW5zbGF0aW9uTWF0cml4KTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3Rvci50dXJuaW5nUG9pbnRzW2luZGV4XS50cmFuc2Zvcm0odHJhbnNsYXRpb25NYXRyaXgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdG9yLnJlZnJlc2goKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnkgPSBuZXdZOyAgLy/lsIblj6Xmn4TmlrDnmoTkvY3nva7otYvlgLznu5l5XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIGNhc2UgJ2gnOlxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmRleDtcclxuICAgICAgICAgICAgICAgICAgICAvLyDmib7lh7rkuKTkuKrovazmipjngrnvvIjlj6/np7vliqjlj6Xmn4TlnKjov5nkuKTkuKrovazmipjngrnkuK3pl7TvvIlcclxuICAgICAgICAgICAgICAgICAgICBmb3IodmFyIGkgPSAxOyBpIDwgdGhpcy5jb25uZWN0b3IudHVybmluZ1BvaW50cy5sZW5ndGgtMTsgaSsrKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYodGhpcy5jb25uZWN0b3IudHVybmluZ1BvaW50c1tpLTFdLnggPT0gdGhpcy5jb25uZWN0b3IudHVybmluZ1BvaW50c1tpXS54XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAmJiB0aGlzLmNvbm5lY3Rvci50dXJuaW5nUG9pbnRzW2ldLnggPT0gdGhpcy54XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAmJiBNYXRoLm1pbih0aGlzLmNvbm5lY3Rvci50dXJuaW5nUG9pbnRzW2ldLnksIHRoaXMuY29ubmVjdG9yLnR1cm5pbmdQb2ludHNbaS0xXS55KSA8PSB0aGlzLnlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICYmIE1hdGgubWF4KHRoaXMuY29ubmVjdG9yLnR1cm5pbmdQb2ludHNbaV0ueSwgdGhpcy5jb25uZWN0b3IudHVybmluZ1BvaW50c1tpLTFdLnkpID49IHRoaXMueSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ID0gaTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB2YXIgZGVsdGFYID0gbmV3WC10aGlzLng7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRyYW5zbGF0aW9uTWF0cml4ID0gVXRpbC50cmFuc2xhdGlvbk1hdHJpeChkZWx0YVgsIDApO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdG9yLnR1cm5pbmdQb2ludHNbaW5kZXgtMV0udHJhbnNmb3JtKHRyYW5zbGF0aW9uTWF0cml4KTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3Rvci50dXJuaW5nUG9pbnRzW2luZGV4XS50cmFuc2Zvcm0odHJhbnNsYXRpb25NYXRyaXgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdG9yLnJlZnJlc2goKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnggPSBuZXdYOyAvL+WwhuWPpeafhOaWsOeahOS9jee9rui1i+WAvOe7mXhcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAvLy4gdGhpcy5zaGFwZS51cGRhdGVNaWRkbGVUZXh0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIG1vZHVsZS5leHBvcnRzID0gSGFuZGxlO1xyXG5cclxuXHJcblxyXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vbGliL2Zpc2gtdG9wby1jb3JlL2xpYi9zaGFwZXMvSGFuZGxlLmpzXG4gKiogbW9kdWxlIGlkID0gNzlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxyXG4gKiDov57nur/liqjmgIHmlYjmnpxcclxuICogQGF1dGhvciBtaWFvLmN1bnpoaVxyXG4gKi9cclxuXHJcbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XHJcbiAgICB2YXIgdmVjMiA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdmVjdG9yJyk7XHJcbiAgICB2YXIgY3VydmVVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS9jdXJ2ZScpO1xyXG4gICAgdmFyIHN5bWJvbFV0aWwgPSByZXF1aXJlKCcuL1N5bWJvbC5qcycpO1xyXG5cclxuICAgIGZ1bmN0aW9uIEVmZmVjdExpbmUoc3ltYm9sLCBvcHRpb25zLCBncm91cEN1cnZlLCBwb2x5TGluZSkge1xyXG4gICAgICAgIHRoaXMuX2xhc3RGcmFtZSA9IDA7XHJcbiAgICAgICAgdGhpcy5fbGFzdEZyYW1lUGVyY2VudCA9IDA7XHJcbiAgICAgICAgdGhpcy5zeW1ib2wgPSBzeW1ib2w7XHJcbiAgICAgICAgdGhpcy5ncm91cEN1cnZlID0gZ3JvdXBDdXJ2ZTtcclxuICAgICAgICB0aGlzLmluaXRTeW1ib2wob3B0aW9ucywgcG9seUxpbmUpO1xyXG4gICAgfVxyXG4gICAgdmFyIEVmZmVjdExpbmVQcm90byA9IEVmZmVjdExpbmUucHJvdG90eXBlO1xyXG5cclxuICAgIEVmZmVjdExpbmVQcm90by5pbml0U3ltYm9sID0gZnVuY3Rpb24ob3B0aW9ucywgcG9seUxpbmUpIHtcclxuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5zeW1ib2wuejIgPSAxMDA7XHJcbiAgICAgICAgdGhpcy5zeW1ib2wuY3VsbGluZyA9IHRydWU7XHJcbiAgICAgICAgdmFyIHBlcmlvZCA9IG9wdGlvbnMuZWZmZWN0LnBlcmlvZCAqIDEwMDA7XHJcbiAgICAgICAgdGhpcy5zeW1ib2wuX190ID0gMDtcclxuICAgICAgICB0aGlzLnN5bWJvbC5zdG9wQW5pbWF0aW9uKCk7XHJcbiAgICAgICAgaWYgKChvcHRpb25zLnN0eWxlLmxpbmVUeXBlID09IFwiY3VydmVcIikpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuZ3JvdXBDdXJ2ZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGkgPSAwO1xyXG4gICAgICAgICAgICAgICAgcGVyaW9kID0gcGVyaW9kIC8gdGhpcy5ncm91cEN1cnZlLl9jaGlsZHJlbi5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmdyb3VwQ3VydmVBbmltYXRlKHRoaXMuZ3JvdXBDdXJ2ZS5fY2hpbGRyZW5bMF0sIGksIHBlcmlvZCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5zeW1ib2wuYW5pbWF0ZSgnJywgdHJ1ZSlcclxuICAgICAgICAgICAgICAgIC53aGVuKHBlcmlvZCwge1xyXG4gICAgICAgICAgICAgICAgICAgIF9fdDogMVxyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC5kZWxheSgwKVxyXG4gICAgICAgICAgICAgICAgLmR1cmluZyhmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGF0LnVwZGF0ZVN5bWJvbFBvc2l0aW9uUG9seWxpbmUoKTtcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAuc3RhcnQoKTtcclxuICAgICAgICAgICAgdGhpcy5zZXRBbmltYXRpb25Qb2ludHNQb2x5bGluZShwb2x5TGluZS5zaGFwZS5wb2ludHMpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9O1xyXG5cclxuICAgIEVmZmVjdExpbmVQcm90by5ncm91cEN1cnZlQW5pbWF0ZSA9IGZ1bmN0aW9uKGN1cnZlTGluZSwgaSwgcGVyaW9kKSB7XHJcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgICAgIGlmIChjdXJ2ZUxpbmUgPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIGN1cnZlTGluZSA9IHRoaXMuZ3JvdXBDdXJ2ZS5fY2hpbGRyZW5bMF07XHJcbiAgICAgICAgICAgIGkgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcG9pbnRzO1xyXG4gICAgICAgIHZhciBwb3MgPSBjdXJ2ZUxpbmUuc2hhcGU7XHJcbiAgICAgICAgcG9pbnRzID0gW1xyXG4gICAgICAgICAgICBbcG9zLngxLCBwb3MueTFdLFxyXG4gICAgICAgICAgICBbcG9zLngyLCBwb3MueTJdLFxyXG4gICAgICAgICAgICBbcG9zLmNweDEsIHBvcy5jcHkxXSxcclxuICAgICAgICAgICAgW3Bvcy5jcHgyLCBwb3MuY3B5Ml1cclxuICAgICAgICBdO1xyXG4gICAgICAgIHRoaXMuc2V0QW5pbWF0aW9uUG9pbnRzQmV6aWVyQ3VydmUocG9pbnRzKTtcclxuICAgICAgICB0aGlzLnN5bWJvbC5hbmltYXRlKCcnKVxyXG4gICAgICAgICAgICAud2hlbihwZXJpb2QsIHtcclxuICAgICAgICAgICAgICAgIF9fdDogMVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAuZGVsYXkoMClcclxuICAgICAgICAgICAgLmR1cmluZyhmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIHRoYXQudXBkYXRlU3ltYm9sUG9zaXRpb25CZXppZXJDdXJ2ZSgpO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAuZG9uZShmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIHRoYXQuc3ltYm9sLl9fdCA9IDA7XHJcbiAgICAgICAgICAgICAgICB0aGF0Lmdyb3VwQ3VydmVBbmltYXRlKHRoYXQuZ3JvdXBDdXJ2ZS5fY2hpbGRyZW5baSArIDFdLCBpICsgMSwgcGVyaW9kKTtcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgLnN0YXJ0KCk7XHJcblxyXG4gICAgfTtcclxuXHJcblxyXG4gICAgRWZmZWN0TGluZVByb3RvLnNldEFuaW1hdGlvblBvaW50c0JlemllckN1cnZlID0gZnVuY3Rpb24ocG9pbnRzKSB7XHJcbiAgICAgICAgdGhpcy5zeW1ib2wuX19wMSA9IHBvaW50c1swXTtcclxuICAgICAgICB0aGlzLnN5bWJvbC5fX3AyID0gcG9pbnRzWzFdO1xyXG4gICAgICAgIHRoaXMuc3ltYm9sLl9fY3AxID0gcG9pbnRzWzJdIHx8IFtcclxuICAgICAgICAgICAgKHBvaW50c1swXVswXSArIHBvaW50c1sxXVswXSkgLyAyLFxyXG4gICAgICAgICAgICAocG9pbnRzWzBdWzFdICsgcG9pbnRzWzFdWzFdKSAvIDJcclxuICAgICAgICBdO1xyXG4gICAgICAgIHRoaXMuc3ltYm9sLl9fY3AyID0gcG9pbnRzWzNdO1xyXG4gICAgfTtcclxuXHJcbiAgICBFZmZlY3RMaW5lUHJvdG8udXBkYXRlU3ltYm9sUG9zaXRpb25CZXppZXJDdXJ2ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBwMSA9IHRoaXMuc3ltYm9sLl9fcDE7XHJcbiAgICAgICAgdmFyIHAyID0gdGhpcy5zeW1ib2wuX19wMjtcclxuICAgICAgICB2YXIgY3AxID0gdGhpcy5zeW1ib2wuX19jcDE7XHJcbiAgICAgICAgdmFyIGNwMiA9IHRoaXMuc3ltYm9sLl9fY3AyO1xyXG4gICAgICAgIHZhciB0ID0gdGhpcy5zeW1ib2wuX190O1xyXG4gICAgICAgIHZhciBwb3MgPSB0aGlzLnN5bWJvbC5wb3NpdGlvbjtcclxuICAgICAgICB2YXIgdHgsIHR5O1xyXG4gICAgICAgIGlmIChjcDJbMF0gIT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHZhciBjdWJpY0F0ID0gY3VydmVVdGlsLmN1YmljQXQ7XHJcbiAgICAgICAgICAgIHZhciBjdWJpY0Rlcml2YXRpdmVBdCA9IGN1cnZlVXRpbC5jdWJpY0Rlcml2YXRpdmVBdDtcclxuICAgICAgICAgICAgcG9zWzBdID0gY3ViaWNBdChwMVswXSwgY3AxWzBdLCBjcDJbMF0sIHAyWzBdLCB0KTtcclxuICAgICAgICAgICAgcG9zWzFdID0gY3ViaWNBdChwMVsxXSwgY3AxWzFdLCBjcDJbMV0sIHAyWzFdLCB0KTtcclxuICAgICAgICAgICAgLy8gVGFuZ2VudFxyXG4gICAgICAgICAgICB0eCA9IGN1YmljRGVyaXZhdGl2ZUF0KHAxWzBdLCBjcDFbMF0sIGNwMlswXSwgcDJbMF0sIHQpO1xyXG4gICAgICAgICAgICB0eSA9IGN1YmljRGVyaXZhdGl2ZUF0KHAxWzFdLCBjcDFbMV0sIGNwMlsxXSwgcDJbMV0sIHQpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHZhciBxdWFkcmF0aWNBdCA9IGN1cnZlVXRpbC5xdWFkcmF0aWNBdDtcclxuICAgICAgICAgICAgdmFyIHF1YWRyYXRpY0Rlcml2YXRpdmVBdCA9IGN1cnZlVXRpbC5xdWFkcmF0aWNEZXJpdmF0aXZlQXQ7XHJcbiAgICAgICAgICAgIHBvc1swXSA9IHF1YWRyYXRpY0F0KHAxWzBdLCBjcDFbMF0sIHAyWzBdLCB0KTtcclxuICAgICAgICAgICAgcG9zWzFdID0gcXVhZHJhdGljQXQocDFbMV0sIGNwMVsxXSwgcDJbMV0sIHQpO1xyXG4gICAgICAgICAgICAvLyBUYW5nZW50XHJcbiAgICAgICAgICAgIHR4ID0gcXVhZHJhdGljRGVyaXZhdGl2ZUF0KHAxWzBdLCBjcDFbMF0sIHAyWzBdLCB0KTtcclxuICAgICAgICAgICAgdHkgPSBxdWFkcmF0aWNEZXJpdmF0aXZlQXQocDFbMV0sIGNwMVsxXSwgcDJbMV0sIHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnN5bWJvbC5yb3RhdGlvbiA9IC1NYXRoLmF0YW4yKHR5LCB0eCkgLSBNYXRoLlBJIC8gMjtcclxuXHJcbiAgICAgICAgdGhpcy5zeW1ib2wuaWdub3JlID0gZmFsc2U7XHJcbiAgICB9O1xyXG5cclxuICAgIEVmZmVjdExpbmVQcm90by5zZXRBbmltYXRpb25Qb2ludHNQb2x5bGluZSA9IGZ1bmN0aW9uKHBvaW50cykge1xyXG4gICAgICAgIHRoaXMuX3BvaW50cyA9IHBvaW50cztcclxuICAgICAgICB2YXIgYWNjTGVuQXJyID0gWzBdO1xyXG4gICAgICAgIHZhciBsZW4gPSAwO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBwMSA9IHBvaW50c1tpIC0gMV07XHJcbiAgICAgICAgICAgIHZhciBwMiA9IHBvaW50c1tpXTtcclxuICAgICAgICAgICAgbGVuICs9IHZlYzIuZGlzdChwMSwgcDIpO1xyXG4gICAgICAgICAgICBhY2NMZW5BcnIucHVzaChsZW4pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobGVuID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgYWNjTGVuQXJyLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgIGFjY0xlbkFycltqXSAvPSBsZW47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX29mZnNldHMgPSBhY2NMZW5BcnI7XHJcbiAgICAgICAgdGhpcy5fbGVuZ3RoID0gbGVuO1xyXG4gICAgICAgIHRoaXMuc3ltYm9sLl9sYXN0RnJhbWUgPSAwO1xyXG4gICAgICAgIHRoaXMuc3ltYm9sLl9fbGFzdEZyYW1lUGVyY2VudCA9IDA7XHJcbiAgICB9O1xyXG5cclxuICAgIEVmZmVjdExpbmVQcm90by51cGRhdGVTeW1ib2xQb3NpdGlvblBvbHlsaW5lID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIHQgPSB0aGlzLnN5bWJvbC5fX3Q7XHJcbiAgICAgICAgdmFyIHBvaW50cyA9IHRoaXMuX3BvaW50cztcclxuICAgICAgICB2YXIgb2Zmc2V0cyA9IHRoaXMuX29mZnNldHM7XHJcbiAgICAgICAgdmFyIGxlbiA9IHBvaW50cy5sZW5ndGg7XHJcblxyXG4gICAgICAgIGlmICghb2Zmc2V0cykge1xyXG4gICAgICAgICAgICAvLyBIYXMgbGVuZ3RoIDBcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGxhc3RGcmFtZSA9IHRoaXMuX2xhc3RGcmFtZTtcclxuICAgICAgICB2YXIgZnJhbWU7XHJcblxyXG4gICAgICAgIGlmICh0IDwgdGhpcy5fbGFzdEZyYW1lUGVyY2VudCkge1xyXG4gICAgICAgICAgICAvLyBTdGFydCBmcm9tIHRoZSBuZXh0IGZyYW1lXHJcbiAgICAgICAgICAgIC8vIFBFTkRJTkcgc3RhcnQgZnJvbSBsYXN0RnJhbWUgP1xyXG4gICAgICAgICAgICB2YXIgc3RhcnQgPSBNYXRoLm1pbihsYXN0RnJhbWUgKyAxLCBsZW4gLSAxKTtcclxuICAgICAgICAgICAgZm9yIChmcmFtZSA9IHN0YXJ0OyBmcmFtZSA+PSAwOyBmcmFtZS0tKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAob2Zmc2V0c1tmcmFtZV0gPD0gdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIFBFTkRJTkcgcmVhbGx5IG5lZWQgdG8gZG8gdGhpcyA/XHJcbiAgICAgICAgICAgIGZyYW1lID0gTWF0aC5taW4oZnJhbWUsIGxlbiAtIDIpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGZyYW1lID0gbGFzdEZyYW1lOyBmcmFtZSA8IGxlbjsgZnJhbWUrKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKG9mZnNldHNbZnJhbWVdID4gdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZyYW1lID0gTWF0aC5taW4oZnJhbWUgLSAxLCBsZW4gLSAyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmVjMi5sZXJwKFxyXG4gICAgICAgICAgICB0aGlzLnN5bWJvbC5wb3NpdGlvbiwgcG9pbnRzW2ZyYW1lXSwgcG9pbnRzW2ZyYW1lICsgMV0sXHJcbiAgICAgICAgICAgICh0IC0gb2Zmc2V0c1tmcmFtZV0pIC8gKG9mZnNldHNbZnJhbWUgKyAxXSAtIG9mZnNldHNbZnJhbWVdKVxyXG4gICAgICAgICk7XHJcblxyXG4gICAgICAgIHRoaXMuX2xhc3RGcmFtZSA9IGZyYW1lO1xyXG4gICAgICAgIHRoaXMuX2xhc3RGcmFtZVBlcmNlbnQgPSB0O1xyXG4gICAgICAgIHZhciBhbmdsZSA9IC1NYXRoLmF0YW4yKHBvaW50c1tmcmFtZSArIDFdWzFdIC0gcG9pbnRzW2ZyYW1lXVsxXSwgcG9pbnRzW2ZyYW1lICsgMV1bMF0gLSBwb2ludHNbZnJhbWVdWzBdKTtcclxuICAgICAgICB0aGlzLnN5bWJvbC5yb3RhdGlvbiA9IGFuZ2xlIC0gTWF0aC5QSSAvIDI7XHJcbiAgICAgICAgdGhpcy5zeW1ib2wuaWdub3JlID0gZmFsc2U7XHJcbiAgICB9O1xyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBFZmZlY3RMaW5lO1xyXG5cclxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2xpYi9maXNoLXRvcG8tY29yZS9saWIvc2hhcGVzL0VmZmVjdExpbmUuanNcbiAqKiBtb2R1bGUgaWQgPSA4MFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXHJcbiAqIOaOp+WItueCuVxyXG4gKiBAYXV0aG9yIHdhbmcueGlhb2h1XHJcbiAqL1xyXG5cclxuICAgIHZhciBncmFwaGljID0gcmVxdWlyZShcIi4uL2dyYXBoaWMuanNcIik7XHJcbiAgICB2YXIgVXRpbCA9IHJlcXVpcmUoXCIuLi91dGlsLmpzXCIpO1xyXG4gICAgZnVuY3Rpb24gQ29ubmVjdGlvblBvaW50KGNvbm5lY3RvciwgcG9pbnQsIHR5cGUsIG9wdGlvbnMpe1xyXG4gICAgICAgIHRoaXMuY29ubmVjdG9yID0gY29ubmVjdG9yO1xyXG5cclxuICAgICAgICB0aGlzLnBvaW50ID0gcG9pbnQuY2xvbmUoKTtcclxuXHJcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcclxuXHJcbiAgICAgICAgdGhpcy5jb2xvciA9IENvbm5lY3Rpb25Qb2ludC5OT1JNQUxfQ09MT1I7XHJcblxyXG4gICAgICAgIHRoaXMub1R5cGUgPSAnQ29ubmVjdGlvblBvaW50JztcclxuXHJcbiAgICAgICAgdGhpcy5zaGFwZSA9IG5ldyBncmFwaGljLkNpcmNsZSh7XHJcbiAgICAgICAgICAgIHNoYXBlOiB7XHJcbiAgICAgICAgICAgICAgICBjeDogdGhpcy5wb2ludC54LFxyXG4gICAgICAgICAgICAgICAgY3k6IHRoaXMucG9pbnQueSxcclxuICAgICAgICAgICAgICAgIHI6IENvbm5lY3Rpb25Qb2ludC5SQURJVVNcclxuICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgIHN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgICBmaWxsOiB0aGlzLmNvbG9yLFxyXG4gICAgICAgICAgICAgICAgc3Ryb2tlOicjMDAwMDAwJ1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB6IDogb3B0aW9ucy56ICsgMiAgLy/oioLngrla5Li6MSDnur/mrrXkuLowO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuc2hhcGUudHlwZSA9ICB0aGlzLnR5cGU7XHJcblxyXG4gICAgICAgIHRoaXMuc2hhcGUuY29ubmVjdG9yID0gY29ubmVjdG9yO1xyXG4gICAgICAgIC8vcmV0dXJuIHRoaXMuY2lyY2xlO1xyXG4gICAgfVxyXG5cclxuICAgIENvbm5lY3Rpb25Qb2ludC5OT1JNQUxfQ09MT1IgPSBcIiNGRkZGMzNcIjsgLy95ZWxsb3cuXHJcblxyXG4gICAgQ29ubmVjdGlvblBvaW50Lk9WRVJfQ09MT1IgPSBcIiNGRjk5MDBcIjsgLy9vcmFuZ2VcclxuXHJcbiAgICBDb25uZWN0aW9uUG9pbnQuQ09OTkVDVEVEX0NPTE9SID0gXCIjZmYwMDAwXCI7IC8vcmVkXHJcblxyXG4gICAgQ29ubmVjdGlvblBvaW50LlJBRElVUyA9IDQ7XHJcblxyXG4gICAgQ29ubmVjdGlvblBvaW50LlRZUEVfRklHVVJFID0gJ2ZpZ3VyZSc7XHJcblxyXG4gICAgQ29ubmVjdGlvblBvaW50LlRZUEVfQ09OTkVDVE9SID0gJ2Nvbm5lY3Rvcic7XHJcblxyXG4gICAgQ29ubmVjdGlvblBvaW50LnByb3RvdHlwZSA9IHtcclxuXHJcbiAgICAgICAgY29uc3RydWN0b3IgOiBDb25uZWN0aW9uUG9pbnQsXHJcblxyXG4gICAgICAgIGVxdWFscyA6IGZ1bmN0aW9uKGFub3RoZXJDb25uZWN0aW9uUG9pbnQpe1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wb2ludC5lcXVhbHMoYW5vdGhlckNvbm5lY3Rpb25Qb2ludC5wb2ludClcclxuICAgICAgICAgICAgJiYgdGhpcy5jb25uZWN0b3IgPT0gYW5vdGhlckNvbm5lY3Rpb25Qb2ludC5jb25uZWN0b3JcclxuICAgICAgICAgICAgJiYgdGhpcy50eXBlID09IGFub3RoZXJDb25uZWN0aW9uUG9pbnQudHlwZVxyXG4gICAgICAgICAgICAmJiB0aGlzLmNvbG9yID09IGFub3RoZXJDb25uZWN0aW9uUG9pbnQuY29sb3JcclxuICAgICAgICAgICAgJiYgdGhpcy5yYWRpdXMgPT0gYW5vdGhlckNvbm5lY3Rpb25Qb2ludC5yYWRpdXM7XHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICB9O1xyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBDb25uZWN0aW9uUG9pbnQ7XHJcblxyXG5cclxuXHJcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9saWIvZmlzaC10b3BvLWNvcmUvbGliL3NoYXBlcy9Db25uZWN0aW9uUG9pbnQuanNcbiAqKiBtb2R1bGUgaWQgPSA4MVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXHJcbiAqIOmAieS4reiKgueCueWQju+8jOWHuueOsOeahOaTjeS9nOahhuWPiuaMiemSrlxyXG4gKiBAYXV0aG9yIHdhbmcueGlhb2h1XHJcbiAqL1xyXG5cclxuICAgIHZhciBOb2RlID0gcmVxdWlyZShcIi4uL05vZGVcIik7XHJcbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XHJcbiAgICB2YXIgZ3JhcGhpYyA9IHJlcXVpcmUoXCIuLi9ncmFwaGljLmpzXCIpO1xyXG4gICAgdmFyIENvbm5lY3RvciA9IHJlcXVpcmUoXCIuLi9zaGFwZXMvQ29ubmVjdG9yLmpzXCIpO1xyXG4gICAgdmFyIGVudiA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvZW52Jyk7XHJcblxyXG4gICAgZnVuY3Rpb24gT3BlcmF0aW9uTm9kZShub2RlLCB6ciwgZm9yYmlkRWRpdCkge1xyXG4gICAgICAgIE5vZGUuY2FsbCh0aGlzKTtcclxuICAgICAgICB0aGlzLm5vZGUgPSBub2RlO1xyXG4gICAgICAgIHRoaXMuenIgPSB6cjtcclxuICAgICAgICB0aGlzLmZvcmJpZEVkaXQgPSBmb3JiaWRFZGl0OyAvL1xyXG4gICAgICAgIHRoaXMucmVuZGVyKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy/kuovku7ZcclxuICAgIE9wZXJhdGlvbk5vZGUuQVJST1dfRFJBR0VORCA9IFwiT3BlcmF0aW9uTm9kZTpkcmFnZW5kQXJyb3dcIjtcclxuICAgIE9wZXJhdGlvbk5vZGUuQVJST1dfRFJBRyA9IFwiT3BlcmF0aW9uTm9kZTpkcmFnQXJyb3dcIjtcclxuICAgIE9wZXJhdGlvbk5vZGUuQVJST1dfRFJBR1NUQVJUID0gXCJPcGVyYXRpb25Ob2RlOmRyYWdzdGFydEFycm93XCI7XHJcbiAgICBPcGVyYXRpb25Ob2RlLkRFTEVURV9DTElDSyA9IFwiT3BlcmF0aW9uTm9kZTpkZWxldGVDbGlja1wiO1xyXG5cclxuICAgIGlmKCFlbnYuY2FudmFzU3VwcG9ydGVkKSB7XHJcbiAgICAgICAgLy/lhoXnva7mk43kvZzlm77moIfnmoTlm77lg49cclxuICAgICAgICBPcGVyYXRpb25Ob2RlLm9waWNvbnMgPSB7XHJcbiAgICAgICAgICAgIFNUUkFJR0hUOiAnTTEzLjk2MSwyLjMwOWMtMC4wNTEtMC4xMjItMC4xNDgtMC4yMi0wLjI3LTAuMjdMMTMuNSwyaC01QzguMjI0LDIsOCwyLjIyNCw4LDIuNVM4LjIyNCwzLDguNSwzaDMuNzkzTDIuMTQ2LDEzLjE0NmMtMC4xOTUsMC4xOTUtMC4xOTUsMC41MTIsMCwwLjcwN3MwLjUxMiwwLjE5NSwwLjcwNywwTDEzLDMuNzA3VjcuNUMxMyw3Ljc3NiwxMy4yMjUsOCwxMy41LDhTMTQsNy43NzYsMTQsNy41di01TDEzLjk2MSwyLjMwOXonLFxyXG4gICAgICAgICAgICBKQUdHRUQ6ICdNOTYuMDQ2LDEzLjYwNEg4NC4yMTNjLTEuMTA0LDAtMiwwLjg5Ni0yLDJ2NDIuMTg4SDM4LjMxNHYtMTAuNzdjMC0wLjcxNS0wLjM4MS0xLjM3NS0xLTEuNzMyYy0wLjYxOS0wLjM1Ny0xLjM4Mi0wLjM1NS0yLDBMMi45NTQsNjMuOTc3Yy0wLjYxOSwwLjM1Ny0xLDEuMDE4LTEsMS43MzJzMC4zODEsMS4zNzUsMSwxLjczMmwzMi4zNiwxOC42ODdjMC4zMDksMC4xNzksMC42NTUsMC4yNjgsMSwwLjI2OHMwLjY5LTAuMDg5LDEtMC4yNjhjMC42MTktMC4zNTcsMS0xLjAxOCwxLTEuNzMyVjczLjYyNWg1Ny43MzJjMS4xMDQsMCwyLTAuODk2LDItMlYxNS42MDRDOTguMDQ2LDE0LjUsOTcuMTUxLDEzLjYwNCw5Ni4wNDYsMTMuNjA0eicsXHJcbiAgICAgICAgICAgIENVUlZFOiAnTTUxMC41MzYsMjY4LjA5OGMxMy41NDEsMCwyNy4wNzgtNS4yMDcsMzcuMzQ3LTE1LjZjMjAuMzc5LTIwLjYyNSwyMC4xOC01My44NjYtMC40NDUtNzQuMjQ1TDQxNC4xNjcsNDYuNTdjLTkuOTA1LTkuNzg2LTIzLjMyNS0xNS4yNDQtMzcuMjE1LTE1LjE1NGMtMTMuOTIzLDAuMDgzLTI3LjI0NCw1LjY5NS0zNy4wMywxNS41OTlsLTEyOS45MTIsMTMxLjQ4Yy0yMC4zNzksMjAuNjI1LTIwLjE4LDUzLjg2NiwwLjQ0NSw3NC4yNDVjMjAuNjI1LDIwLjM3OSw1My44NjYsMjAuMTgsNzQuMjQ1LTAuNDQ1bDQwLjYxOC00MS4xMDhjMC4wMjEsMC40NjQsMC4wMjksMC45MjcsMC4wNjIsMS4zOTRjNC4xNzgsNTkuMDA4LDQuNjY4LDExOS44MzIsMTYuNjMzLDE3Ny45MzFjMjMuOTM3LDExNi4yMzIsMTAzLjcwNSwxOTEuOTYxLDE5MS40ODksMjY0LjAyNGM0Ny4yOTIsMzguODIzLDc5LjY2LDk0LjEyMiw5OC42MDEsMTUxLjY3M2M5Ljc2NSwyOS42NjksMTQuNzE0LDc3LjExNSwxNy4yMTUsMTA3LjE1N2MyLjI2MSwyNy4xNjEsMjUuMDgsNDcuOTc4LDUyLjMzMyw0Ny43MDlsMS4wNjEtMC4wMWMzMC4yMjgtMC4yOTgsNTMuODEtMjYuMjExLDUxLjMwNi01Ni4zMzZjLTIuOTIxLTM1LjE1LTguODU4LTg5LjgyOC0yMC45MjUtMTI3LjQ5Yy0xNi4yODMtNTAuODIxLTQwLjAxNi05OS40NjMtNzQuNzY2LTE0MC4yNDVjLTMzLjk5My0zOS44OTItNzUuNDU2LTcyLjQwMy0xMTMuMzM4LTEwOC4zNzNjLTQ3LjA5MS00NC43MTMtODQuOTc3LTk1LjE2MS05OC4wMDYtMTU5LjcxOWMtMTAuNTQxLTUyLjIzMS0xMi43ODktMTA1LjIxNS0xNi40NjEtMTU4LjU2Mmw0My4xMTgsNDIuNjA0QzQ4My44NywyNjMuMDUzLDQ5Ny4yMDUsMjY4LjA5OCw1MTAuNTM2LDI2OC4wOTh6JyxcclxuICAgICAgICAgICAgREVMOiAnTTczLjY0MSw0NS45NTdsLTAuMDIxLDAuMjUyYzAsMC4wMzIsMC4wMjEsMC4wNiwwLjAyMSwwLjA4OGMwLDAuMDY1LTAuMDIyLDAuMTI2LTAuMDI2LDAuMTkxbC0yLjY4NSw1NC44NzhINzAuOTFjLTAuMjMxLDQuMzA0LTUuMTY2LDEwLjgxLTMxLjc0OCwxMC44MWMtMjYuNTgsMC0zMS41MDktNi41MDYtMzEuNzQ2LTEwLjgxSDcuNDFMNC43MzEsNDYuNDg4Yy0wLjAwOS0wLjA2LTAuMDI4LTAuMTI2LTAuMDI4LTAuMTkxYzAtMC4wMzIsMC4wMS0wLjA2LDAuMDEtMC4wODhsLTAuMDEtMC4yNTJoMC4wMjhjMC4wOTktMC40NjYsMC4zNjQtMC45MTksMC43ODQtMS4zNTNjMy40MzksMy40NzcsMTcuMTkxLDQuMDUxLDMzLjY0Niw0LjA1MXMzMC4yMjEtMC41NzQsMzMuNjQyLTQuMDUxYzAuNDI2LDAuNDM0LDAuNzExLDAuODg3LDAuNzg0LDEuMzUzSDczLjY0MXogTTc4LjMzNSwyNS4xMDJ2Ni40MDdjMCwxLjMxNi0xLjM0LDIuNTY3LTMuNzE1LDMuNjk2Yy02LjI2NiwyLjkzNi0xOS43NzcsNC45NzUtMzUuNDU5LDQuOTc1Yy0xNS42NjYsMC0yOS4xODktMi4wMzktMzUuNDQyLTQuOTc1QzEuMzMsMzQuMDc1LDAsMzIuODI1LDAsMzEuNTA5di02LjQwN2MwLTMuMzc0LDguNjgxLTYuMjg2LDIxLjM1OS03LjcyNFYzLjkyOWMwLTIuMTYsMS43NjgtMy45MjksMy45My0zLjkyOWgyNi4zMTRjMi4xNjQsMCwzLjkzOCwxLjc3MywzLjkzOCwzLjkzOHYxMy4yOTZDNjguOTgsMTguNjA2LDc4LjMzMywyMS42MTEsNzguMzM1LDI1LjEwMnogTTQ4LjQxNiwxMS4zOTVjMC0yLjM0OC0wLjMyMS00LjI3LTAuNzE1LTQuMjdjLTAuMzkzLDAtMi42NDEsMC00Ljk3OSwwaC04LjU0NWMtMi4zNTIsMC00LjU5MiwwLTQuOTg5LDBjLTAuMzg4LDAtMC43MTQsMS45MjItMC43MTQsNC4yN3Y1LjM2N2wxLjA4My0wLjA2NWMzLjA2Ny0wLjE3Myw2LjI4Ni0wLjI3LDkuNTk1LTAuMjcxYzMuMjAyLDAsNi4yOTIsMC4wOTgsOS4yNjQsMC4yNTJWMTEuMzk1eidcclxuICAgICAgICB9O1xyXG4gICAgfWVsc2V7XHJcbiAgICAgICAgT3BlcmF0aW9uTm9kZS5vcGljb25zID0ge1xyXG4gICAgICAgICAgICBTVFJBSUdIVDogJ2RhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQXdBQUFBTUNBWUFBQUJXZFZ6bkFBQUFDWEJJV1hNQUFBc1RBQUFMRXdFQW1wd1lBQUFLVFdsRFExQlFhRzkwYjNOb2IzQWdTVU5ESUhCeWIyWnBiR1VBQUhqYW5WTjNXSlAzRmo3ZjkyVVBWa0xZOExHWGJJRUFJaU9zQ01nUVdhSVFrZ0JoaEJBU1FNV0ZpQXBXRkJVUm5FaFZ4SUxWQ2tpZGlPS2dLTGhuUVlxSVdvdFZYRGp1SDl5bnRYMTY3KzN0KzlmN3ZPZWM1L3pPZWM4UGdCRVNKcEhtb21vQU9WS0ZQRHJZSDQ5UFNNVEp2WUFDRlVqZ0JDQVE1c3ZDWndYRkFBRHdBM2w0Zm5Td1Avd0JyMjhBQWdCdzFTNGtFc2ZoLzRPNlVDWlhBQ0NSQU9BaUV1Y0xBWkJTQU1ndVZNZ1VBTWdZQUxCVHMyUUtBSlFBQUd4NWZFSWlBS29OQU96MFNUNEZBTmlwazl3WEFOaWlIS2tJQUkwQkFKa29SeVFDUUxzQVlGV0JVaXdDd01JQW9LeEFJaTRFd0s0QmdGbTJNa2NDZ0wwRkFIYU9XSkFQUUdBQWdKbENMTXdBSURnQ0FFTWVFODBESUV3RG9ERFN2K0NwWDNDRnVFZ0JBTURMbGMyWFM5SXpGTGlWMEJwMzh2RGc0aUhpd215eFFtRVhLUkJtQ2VRaW5KZWJJeE5JNXdOTXpnd0FBQnI1MGNIK09EK1E1K2JrNGVabTUyenY5TVdpL212d2J5SStJZkhmL3J5TUFnUUFFRTdQNzlwZjVlWFdBM0RIQWJCMXYydXBXd0RhVmdCbzMvbGRNOXNKb0ZvSzBIcjVpM2s0L0VBZW5xRlF5RHdkSEFvTEMrMGxZcUc5TU9PTFB2OHo0Vy9naTM3Mi9FQWUvdHQ2OEFCeG1rQ1pyY0NqZy8xeFlXNTJybEtPNThzRVFqRnU5K2NqL3NlRmYvMk9LZEhpTkxGY0xCV0s4VmlKdUZBaVRjZDV1VktSUkNISmxlSVM2WDh5OFIrVy9RbVRkdzBBcklaUHdFNjJCN1hMYk1CKzdnRUNpdzVZMG5ZQVFIN3pMWXdhQzVFQUVHYzBNbm4zQUFDVHYvbVBRQ3NCQU0yWHBPTUFBTHpvR0Z5b2xCZE14Z2dBQUVTZ2dTcXdRUWNNd1JTc3dBNmN3UjI4d0JjQ1lRWkVRQXdrd0R3UVFnYmtnQndLb1JpV1FSbFV3RHJZQkxXd0F4cWdFWnJoRUxUQk1UZ041K0FTWElIcmNCY0dZQmlld2hpOGhna0VRY2dJRTJFaE9vZ1JZbzdZSXM0SUY1bU9CQ0poU0RTU2dLUWc2WWdVVVNMRnlIS2tBcWxDYXBGZFNDUHlMWElVT1kxY1FQcVEyOGdnTW9yOGlyeEhNWlNCc2xFRDFBSjFRTG1vSHhxS3hxQnowWFEwRDEyQWxxSnIwUnEwSGoyQXRxS24wVXZvZFhRQWZZcU9ZNERSTVE1bWpObGhYSXlIUldDSldCb214eFpqNVZnMVZvODFZeDFZTjNZVkc4Q2VZZThJSkFLTGdCUHNDRjZFRU1Kc2dwQ1FSMWhNV0VPb0pld2p0Qks2Q0ZjSmc0UXh3aWNpazZoUHRDVjZFdm5FZUdJNnNaQllScXdtN2lFZUlaNGxYaWNPRTErVFNDUU95WkxrVGdvaEpaQXlTUXRKYTBqYlNDMmtVNlErMGhCcG5Fd202NUJ0eWQ3a0NMS0FyQ0NYa2JlUUQ1QlBrdnZKdytTM0ZEckZpT0pNQ2FJa1VxU1VFa28xWlQvbEJLV2ZNa0tab0twUnphbWUxQWlxaURxZldrbHRvSFpRTDFPSHFSTTBkWm9selpzV1E4dWtMYVBWMEpwcFoybjNhQy9wZExvSjNZTWVSWmZRbDlKcjZBZnA1K21EOUhjTURZWU5nOGRJWWlnWmF4bDdHYWNZdHhrdm1VeW1CZE9YbWNoVU1OY3lHNWxubUErWWIxVllLdllxZkJXUnloS1ZPcFZXbFg2VjU2cFVWWE5WUDlWNXFndFVxMVVQcTE1V2ZhWkdWYk5RNDZrSjFCYXIxYWtkVmJ1cE5xN09VbmRTajFEUFVWK2p2bC85Z3ZwakRiS0doVWFnaGtpalZHTzN4aG1OSVJiR01tWHhXRUxXY2xZRDZ5eHJtRTFpVzdMNTdFeDJCZnNiZGk5N1RGTkRjNnBtckdhUlpwM21jYzBCRHNheDRQQTUyWnhLemlIT0RjNTdMUU10UHkyeDFtcXRacTErclRmYWV0cSsybUx0Y3UwVzdldmE3M1Z3blVDZExKMzFPbTA2OTNVSnVqYTZVYnFGdXR0MXorbyswMlByZWVrSjljcjFEdW5kMFVmMWJmU2o5UmZxNzlidjBSODNNRFFJTnBBWmJERTRZL0RNa0dQb2E1aHB1Tkh3aE9Hb0VjdG91cEhFYUtQUlNhTW51Q2J1aDJmak5YZ1hQbWFzYnh4aXJEVGVaZHhyUEdGaWFUTGJwTVNreGVTK0tjMlVhNXBtdXRHMDAzVE16TWdzM0t6WXJNbnNqam5Wbkd1ZVliN1p2TnY4allXbFJaekZTb3MyaThlVzJwWjh5d1dXVFpiM3JKaFdQbFo1VnZWVzE2eEoxbHpyTE90dDFsZHNVQnRYbXd5Yk9wdkx0cWl0bTYzRWRwdHQzeFRpRkk4cDBpbjFVMjdhTWV6ODdBcnNtdXdHN1RuMllmWWw5bTMyengzTUhCSWQxanQwTzN4eWRIWE1kbXh3dk91azRUVERxY1NwdytsWFp4dG5vWE9kOHpVWHBrdVF5eEtYZHBjWFUyMm5pcWR1bjNyTGxlVWE3cnJTdGRQMW81dTdtOXl0MlczVTNjdzl4WDJyKzAwdW14dkpYY005NzBIMDhQZFk0bkhNNDUybm02ZkM4NURuTDE1MlhsbGUrNzBlVDdPY0pwN1dNRzNJMjhSYjRMM0xlMkE2UGoxbCtzN3BBejdHUGdLZmVwK0h2cWErSXQ4OXZpTisxbjZaZmdmOG52czcrc3Y5ai9pLzRYbnlGdkZPQldBQndRSGxBYjJCR29HekEyc0RId1NaQktVSE5RV05CYnNHTHd3K0ZVSU1DUTFaSDNLVGI4QVg4aHY1WXpQY1p5eWEwUlhLQ0owVldodjZNTXdtVEI3V0VZNkd6d2pmRUg1dnB2bE02Y3kyQ0lqZ1IyeUl1QjlwR1prWCtYMFVLU295cWk3cVViUlRkSEYwOXl6V3JPUlorMmU5anZHUHFZeTVPOXRxdG5KMlo2eHFiRkpzWSt5YnVJQzRxcmlCZUlmNFJmR1hFblFUSkFudGllVEUyTVE5aWVOekF1ZHNtak9jNUpwVWxuUmpydVhjb3JrWDV1bk95NTUzUEZrMVdaQjhPSVdZRXBleVArV0RJRUpRTHhoUDVhZHVUUjBUOG9TYmhVOUZ2cUtOb2xHeHQ3aEtQSkxtblZhVjlqamRPMzFEK21pR1QwWjF4ak1KVDFJcmVaRVprcmtqODAxV1JOYmVyTS9aY2RrdE9aU2NsSnlqVWcxcGxyUXIxekMzS0xkUFppc3JrdzNrZWVadHlodVRoOHIzNUNQNWMvUGJGV3lGVE5HanRGS3VVQTRXVEMrb0szaGJHRnQ0dUVpOVNGclVNOTltL3VyNUl3dUNGbnk5a0xCUXVMQ3oyTGg0V2ZIZ0lyOUZ1eFlqaTFNWGR5NHhYVks2WkhocDhOSjl5MmpMc3BiOVVPSllVbFh5YW5uYzhvNVNnOUtscFVNcmdsYzBsYW1VeWN0dXJ2UmF1V01WWVpWa1ZlOXFsOVZiVm44cUY1VmZySENzcUs3NHNFYTQ1dUpYVGwvVmZQVjViZHJhM2txM3l1M3JTT3VrNjI2czkxbS9yMHE5YWtIVjBJYndEYTBiOFkzbEcxOXRTdDUwb1hwcTlZN050TTNLelFNMVlUWHRXOHkyck52eW9UYWo5bnFkZjEzTFZ2MnRxN2UrMlNiYTFyL2RkM3Z6RG9NZEZUdmU3NVRzdkxVcmVGZHJ2VVY5OVc3UzdvTGRqeHBpRzdxLzVuN2R1RWQzVDhXZWozdWxld2YyUmUvcmFuUnZiTnl2djcreUNXMVNObzBlU0RwdzVadUFiOXFiN1pwM3RYQmFLZzdDUWVYQko5K21mSHZqVU9paHpzUGN3ODNmbVgrMzlRanJTSGtyMGpxL2Rhd3RvMjJnUGFHOTcraU1vNTBkWGgxSHZyZi9mdTh4NDJOMXh6V1BWNTZnblNnOThmbmtncFBqcDJTbm5wMU9QejNVbWR4NTkwejhtV3RkVVYyOVowUFBuajhYZE81TXQxLzN5ZlBlNTQ5ZDhMeHc5Q0wzWXRzbHQwdXRQYTQ5UjM1dy9lRklyMXR2NjJYM3krMVhQSzUwOUUzck85SHYwMy82YXNEVmM5ZjQxeTVkbjNtOTc4YnNHN2R1SnQwY3VDVzY5ZmgyOXUwWGR3cnVUTnhkZW85NHIveSsydjNxQi9vUDZuKzAvckZsd0czZytHREFZTS9EV1EvdkRnbUhudjZVLzlPSDRkSkh6RWZWSTBZampZK2RIeDhiRFJxOThtVE9rK0duc3FjVHo4cCtWdjk1NjNPcjU5Lzk0dnRMejFqODJQQUwrWXZQdjY1NXFmTnk3NnVwcnpySEk4Y2Z2TTU1UGZHbS9LM08yMzN2dU8rNjM4ZTlINWtvL0VEK1VQUFIrbVBIcDlCUDl6N25mUDc4TC9lRTgvc2wwcDh6QUFBQUlHTklVazBBQUhvbEFBQ0Fnd0FBK2Y4QUFJRHBBQUIxTUFBQTZtQUFBRHFZQUFBWGI1SmZ4VVlBQUFCUVNVUkJWSGphbEpGQkRvQXdDTUNxSDVlZjF3c2hJZXFHU3pnc3RFQUFsYThBQXJERlNuaVRUdmJQL2x0WHYxS0k2alNCMjNoVHVISi80SWV3ZzVzd2dVdVl3c25PWVpVajk0c2FneU55RHdEYTFobjdaQ09Ld3dBQUFBQkpSVTVFcmtKZ2dnPT0nLFxyXG4gICAgICAgICAgICBKQUdHRUQ6ICdkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUF3QUFBQU1DQVlBQUFCV2RWem5BQUFBQ1hCSVdYTUFBQXNUQUFBTEV3RUFtcHdZQUFBS1RXbERRMUJRYUc5MGIzTm9iM0FnU1VORElIQnliMlpwYkdVQUFIamFuVk4zV0pQM0ZqN2Y5MlVQVmtMWThMR1hiSUVBSWlPc0NNZ1FXYUlRa2dCaGhCQVNRTVdGaUFwV0ZCVVJuRWhWeElMVkNraWRpT0tnS0xoblFZcUlXb3RWWERqdUg5eW50WDE2NyszdCs5Zjd2T2VjNS96T2VjOFBnQkVTSnBIbW9tb0FPVktGUERyWUg0OVBTTVRKdllBQ0ZVamdCQ0FRNXN2Q1p3WEZBQUR3QTNsNGZuU3dQL3dCcjI4QUFnQncxUzRrRXNmaC80TzZVQ1pYQUNDUkFPQWlFdWNMQVpCU0FNZ3VWTWdVQU1nWUFMQlRzMlFLQUpRQUFHeDVmRUlpQUtvTkFPejBTVDRGQU5pcGs5d1hBTmlpSEtrSUFJMEJBSmtvUnlRQ1FMc0FZRldCVWl3Q3dNSUFvS3hBSWk0RXdLNEJnRm0yTWtjQ2dMMEZBSGFPV0pBUFFHQUFnSmxDTE13QUlEZ0NBRU1lRTgwRElFd0RvRERTditDcFgzQ0Z1RWdCQU1ETGxjMlhTOUl6RkxpVjBCcDM4dkRnNGlIaXdteXhRbUVYS1JCbUNlUWluSmViSXhOSTV3Tk16Z3dBQUJyNTBjSCtPRCtRNStiazRlWm01Mnp2OU1XaS9tdndieUkrSWZIZi9yeU1BZ1FBRUU3UDc5cGY1ZVhXQTNESEFiQjF2MnVwV3dEYVZnQm8zL2xkTTlzSm9Gb0swSHI1aTNrNC9FQWVucUZReUR3ZEhBb0xDKzBsWXFHOU1PT0xQdjh6NFcvZ2kzNzIvRUFlL3R0NjhBQnhta0NacmNDamcvMXhZVzUycmxLTzU4c0VRakZ1OStjai9zZUZmLzJPS2RIaU5MRmNMQldLOFZpSnVGQWlUY2Q1dVZLUlJDSEpsZUlTNlg4eThSK1cvUW1UZHcwQXJJWlB3RTYyQjdYTGJNQis3Z0VDaXc1WTBuWUFRSDd6TFl3YUM1RUFFR2MwTW5uM0FBQ1R2L21QUUNzQkFNMlhwT01BQUx6b0dGeW9sQmRNeGdnQUFFU2dnU3F3UVFjTXdSU3N3QTZjd1IyOHdCY0NZUVpFUUF3a3dEd1FRZ2JrZ0J3S29SaVdRUmxVd0RyWUJMV3dBeHFnRVpyaEVMVEJNVGdONStBU1hJSHJjQmNHWUJpZXdoaThoZ2tFUWNnSUUyRWhPb2dSWW83WUlzNElGNW1PQkNKaFNEU1NnS1FnNllnVVVTTEZ5SEtrQXFsQ2FwRmRTQ1B5TFhJVU9ZMWNRUHFRMjhnZ01vcjhpcnhITVpTQnNsRUQxQUoxUUxtb0h4cUt4cUJ6MFhRMEQxMkFscUpyMFJxMEhqMkF0cUtuMFV2b2RYUUFmWXFPWTREUk1RNW1qTmxoWEl5SFJXQ0pXQm9teHhaajVWZzFWbzgxWXgxWU4zWVZHOENlWWU4SUpBS0xnQlBzQ0Y2RUVNSnNncENRUjFoTVdFT29KZXdqdEJLNkNGY0pnNFF4d2ljaWs2aFB0Q1Y2RXZuRWVHSTZzWkJZUnF3bTdpRWVJWjRsWGljT0UxK1RTQ1FPeVpMa1Rnb2hKWkF5U1F0SmEwamJTQzJrVTZRKzBoQnBuRXdtNjVCdHlkN2tDTEtBckNDWGtiZVFENUJQa3Z2SncrUzNGRHJGaU9KTUNhSWtVcVNVRWtvMVpUL2xCS1dmTWtLWm9LcFJ6YW1lMUFpcWlEcWZXa2x0b0haUUwxT0hxUk0wZFpvbHpac1dROHVrTGFQVjBKcHBaMm4zYUMvcGRMb0ozWU1lUlpmUWw5SnI2QWZwNSttRDlIY01EWVlOZzhkSVlpZ1pheGw3R2FjWXR4a3ZtVXltQmRPWG1jaFVNTmN5RzVsbm1BK1liMVZZS3ZZcWZCV1J5aEtWT3BWV2xYNlY1NnBVVlhOVlA5VjVxZ3RVcTFVUHExNVdmYVpHVmJOUTQ2a0oxQmFyMWFrZFZidXBOcTdPVW5kU2oxRFBVVitqdmwvOWd2cGpEYktHaFVhZ2hraWpWR08zeGhtTklSYkdNbVh4V0VMV2NsWUQ2eXhybUUxaVc3TDU3RXgyQmZzYmRpOTdURk5EYzZwbXJHYVJacDNtY2MwQkRzYXg0UEE1Mlp4S3ppSE9EYzU3TFFNdFB5MngxbXF0WnExK3JUZmFldHErMm1MdGN1MFc3ZXZhNzNWd25VQ2RMSjMxT20wNjkzVUp1amE2VWJxRnV0dDF6K28rMDJQcmVla0o5Y3IxRHVuZDBVZjFiZlNqOVJmcTc5YnYwUjgzTURRSU5wQVpiREU0WS9ETWtHUG9hNWhwdU5Id2hPR29FY3RvdXBIRWFLUFJTYU1udUNidWgyZmpOWGdYUG1hc2J4eGlyRFRlWmR4clBHRmlhVExicE1Ta3hlUytLYzJVYTVwbXV0RzAwM1RNek1nczNLellyTW5zampuVm5HdWVZYjdadk52OGpZV2xSWnpGU29zMmk4ZVcycFo4eXdXV1RaYjNySmhXUGxaNVZ2VlcxNnhKMWx6ckxPdHQxbGRzVUJ0WG13eWJPcHZMdHFpdG02M0VkcHR0M3hUaUZJOHAwaW4xVTI3YU1lejg3QXJzbXV3RzdUbjJZZllsOW0zMnp4M01IQklkMWp0ME8zeHlkSFhNZG14d3ZPdWs0VFREcWNTcHcrbFhaeHRub1hPZDh6VVhwa3VReXhLWGRwY1hVMjJuaXFkdW4zckxsZVVhN3JyU3RkUDFvNXU3bTl5dDJXM1UzY3c5eFgyciswMHVteHZKWGNNOTcwSDA4UGRZNG5ITTQ1Mm5tNmZDODVEbkwxNTJYbGxlKzcwZVQ3T2NKcDdXTUczSTI4UmI0TDNMZTJBNlBqMWwrczdwQXo3R1BnS2ZlcCtIdnFhK0l0ODl2aU4rMW42WmZnZjhudnM3K3N2OWovaS80WG55RnZGT0JXQUJ3UUhsQWIyQkdvR3pBMnNESHdTWkJLVUhOUVdOQmJzR0x3dytGVUlNQ1ExWkgzS1RiOEFYOGh2NVl6UGNaeXlhMFJYS0NKMFZXaHY2TU13bVRCN1dFWTZHendqZkVINXZwdmxNNmN5MkNJamdSMnlJdUI5cEdaa1grWDBVS1NveXFpN3FVYlJUZEhGMDl5eldyT1JaKzJlOWp2R1BxWXk1Tzl0cXRuSjJaNnhxYkZKc1kreWJ1SUM0cXJpQmVJZjRSZkdYRW5RVEpBbnRpZVRFMk1ROWllTnpBdWRzbWpPYzVKcFVsblJqcnVYY29ya1g1dW5PeTU1M1BGazFXWkI4T0lXWUVwZXlQK1dESUVKUUx4aFA1YWR1VFIwVDhvU2JoVTlGdnFLTm9sR3h0N2hLUEpMbW5WYVY5ampkTzMxRCttaUdUMFoxeGpNSlQxSXJlWkVaa3JrajgwMVdSTmJlck0vWmNka3RPWlNjbEp5alVnMXBsclFyMXpDM0tMZFBaaXNya3cza2VlWnR5aHVUaDhyMzVDUDVjL1BiRld5RlROR2p0Rkt1VUE0V1RDK29LM2hiR0Z0NHVFaTlTRnJVTTk5bS91cjVJd3VDRm55OWtMQlF1TEN6MkxoNFdmSGdJcjlGdXhZamkxTVhkeTR4WFZLNlpIaHA4Tko5eTJqTHNwYjlVT0pZVWxYeWFubmM4bzVTZzlLbHBVTXJnbGMwbGFtVXljdHVydlJhdVdNVllaVmtWZTlxbDlWYlZuOHFGNVZmckhDc3FLNzRzRWE0NXVKWFRsL1ZmUFY1YmRyYTNrcTN5dTNyU091azYyNnM5MW0vcjBxOWFrSFYwSWJ3RGEwYjhZM2xHMTl0U3Q1MG9YcHE5WTdOdE0zS3pRTTFZVFh0Vzh5MnJOdnlvVGFqOW5xZGYxM0xWdjJ0cTdlKzJTYmExci9kZDN2ekRvTWRGVHZlNzVUc3ZMVXJlRmRydlVWOTlXN1M3b0xkanhwaUc3cS81bjdkdUVkM1Q4V2VqM3VsZXdmMlJlL3JhblJ2Yk55dnY3K3lDVzFTTm8wZVNEcHc1WnVBYjlxYjdacDN0WEJhS2c3Q1FlWEJKOSttZkh2alVPaWh6c1BjdzgzZm1YKzM5UWpyU0hrcjBqcS9kYXd0bzIyZ1BhRzk3K2lNbzUwZFhoMUh2cmYvZnU4eDQyTjF4eldQVjU2Z25TZzk4Zm5rZ3BQanAyU25ucDFPUHozVW1keDU5MHo4bVd0ZFVWMjlaMFBQbmo4WGRPNU10MS8zeWZQZTU0OWQ4THh3OUNMM1l0c2x0MHV0UGE0OVIzNXcvZUZJcjF0djYyWDN5KzFYUEs1MDlFM3JPOUh2MDMvNmFzRFZjOWY0MXk1ZG4zbTk3OGJzRzdkdUp0MGN1Q1c2OWZoMjl1MFhkd3J1VE54ZGVvOTRyL3krMnYzcUIvb1A2biswL3JGbHdHM2crR0RBWU0vRFdRL3ZEZ21IbnY2VS85T0g0ZEpIekVmVkkwWWpqWStkSHg4YkRScTk4bVRPaytHbnNxY1R6OHArVnY5NTYzT3I1OS85NHZ0THoxajgyUEFMK1l2UHY2NTVxZk55NzZ1cHJ6ckhJOGNmdk01NVBmR20vSzNPMjMzdnVPKzYzOGU5SDVrby9FRCtVUFBSK21QSHA5QlA5ejduZlA3OEwvZUU4L3NsMHA4ekFBQUFJR05JVWswQUFIb2xBQUNBZ3dBQStmOEFBSURwQUFCMU1BQUE2bUFBQURxWUFBQVhiNUpmeFVZQUFBQ2dTVVJCVkhqYWhOR3hEY0pBRElYaEw2R0tSRWRGaVZna0k1QTlhQkVGRFFWRE1BVUxVTEFCRXlEUkk3b0kycU94a0FpWDVDUTNKNy9uMzg5U1N2b0tlNlNmR2hMa1JLV0JWeFRGQkErOHY1OER6ald1NFh6Qk1ZdUVCVTdSZUVmemc5ZHBYc2Y0Rmp0VWY0WWR3U3FjdDcyb0dhUXpucGpsQkdVbmxUbGVtR0dUalM1Y3EyQnVZNGNEcGozcGFYQUw5aE9XSTRlVUl1OTY3T29wSlo4QkFQZFcvdURPdXdyekFBQUFBRWxGVGtTdVFtQ0MnLFxyXG4gICAgICAgICAgICBDVVJWRTogJ2RhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQXdBQUFBTUNBWUFBQUJXZFZ6bkFBQUFDWEJJV1hNQUFBc1RBQUFMRXdFQW1wd1lBQUFLVFdsRFExQlFhRzkwYjNOb2IzQWdTVU5ESUhCeWIyWnBiR1VBQUhqYW5WTjNXSlAzRmo3ZjkyVVBWa0xZOExHWGJJRUFJaU9zQ01nUVdhSVFrZ0JoaEJBU1FNV0ZpQXBXRkJVUm5FaFZ4SUxWQ2tpZGlPS2dLTGhuUVlxSVdvdFZYRGp1SDl5bnRYMTY3KzN0KzlmN3ZPZWM1L3pPZWM4UGdCRVNKcEhtb21vQU9WS0ZQRHJZSDQ5UFNNVEp2WUFDRlVqZ0JDQVE1c3ZDWndYRkFBRHdBM2w0Zm5Td1Avd0JyMjhBQWdCdzFTNGtFc2ZoLzRPNlVDWlhBQ0NSQU9BaUV1Y0xBWkJTQU1ndVZNZ1VBTWdZQUxCVHMyUUtBSlFBQUd4NWZFSWlBS29OQU96MFNUNEZBTmlwazl3WEFOaWlIS2tJQUkwQkFKa29SeVFDUUxzQVlGV0JVaXdDd01JQW9LeEFJaTRFd0s0QmdGbTJNa2NDZ0wwRkFIYU9XSkFQUUdBQWdKbENMTXdBSURnQ0FFTWVFODBESUV3RG9ERFN2K0NwWDNDRnVFZ0JBTURMbGMyWFM5SXpGTGlWMEJwMzh2RGc0aUhpd215eFFtRVhLUkJtQ2VRaW5KZWJJeE5JNXdOTXpnd0FBQnI1MGNIK09EK1E1K2JrNGVabTUyenY5TVdpL212d2J5SStJZkhmL3J5TUFnUUFFRTdQNzlwZjVlWFdBM0RIQWJCMXYydXBXd0RhVmdCbzMvbGRNOXNKb0ZvSzBIcjVpM2s0L0VBZW5xRlF5RHdkSEFvTEMrMGxZcUc5TU9PTFB2OHo0Vy9naTM3Mi9FQWUvdHQ2OEFCeG1rQ1pyY0NqZy8xeFlXNTJybEtPNThzRVFqRnU5K2NqL3NlRmYvMk9LZEhpTkxGY0xCV0s4VmlKdUZBaVRjZDV1VktSUkNISmxlSVM2WDh5OFIrVy9RbVRkdzBBcklaUHdFNjJCN1hMYk1CKzdnRUNpdzVZMG5ZQVFIN3pMWXdhQzVFQUVHYzBNbm4zQUFDVHYvbVBRQ3NCQU0yWHBPTUFBTHpvR0Z5b2xCZE14Z2dBQUVTZ2dTcXdRUWNNd1JTc3dBNmN3UjI4d0JjQ1lRWkVRQXdrd0R3UVFnYmtnQndLb1JpV1FSbFV3RHJZQkxXd0F4cWdFWnJoRUxUQk1UZ041K0FTWElIcmNCY0dZQmlld2hpOGhna0VRY2dJRTJFaE9vZ1JZbzdZSXM0SUY1bU9CQ0poU0RTU2dLUWc2WWdVVVNMRnlIS2tBcWxDYXBGZFNDUHlMWElVT1kxY1FQcVEyOGdnTW9yOGlyeEhNWlNCc2xFRDFBSjFRTG1vSHhxS3hxQnowWFEwRDEyQWxxSnIwUnEwSGoyQXRxS24wVXZvZFhRQWZZcU9ZNERSTVE1bWpObGhYSXlIUldDSldCb214eFpqNVZnMVZvODFZeDFZTjNZVkc4Q2VZZThJSkFLTGdCUHNDRjZFRU1Kc2dwQ1FSMWhNV0VPb0pld2p0Qks2Q0ZjSmc0UXh3aWNpazZoUHRDVjZFdm5FZUdJNnNaQllScXdtN2lFZUlaNGxYaWNPRTErVFNDUU95WkxrVGdvaEpaQXlTUXRKYTBqYlNDMmtVNlErMGhCcG5Fd202NUJ0eWQ3a0NMS0FyQ0NYa2JlUUQ1QlBrdnZKdytTM0ZEckZpT0pNQ2FJa1VxU1VFa28xWlQvbEJLV2ZNa0tab0twUnphbWUxQWlxaURxZldrbHRvSFpRTDFPSHFSTTBkWm9selpzV1E4dWtMYVBWMEpwcFoybjNhQy9wZExvSjNZTWVSWmZRbDlKcjZBZnA1K21EOUhjTURZWU5nOGRJWWlnWmF4bDdHYWNZdHhrdm1VeW1CZE9YbWNoVU1OY3lHNWxubUErWWIxVllLdllxZkJXUnloS1ZPcFZXbFg2VjU2cFVWWE5WUDlWNXFndFVxMVVQcTE1V2ZhWkdWYk5RNDZrSjFCYXIxYWtkVmJ1cE5xN09VbmRTajFEUFVWK2p2bC85Z3ZwakRiS0doVWFnaGtpalZHTzN4aG1OSVJiR01tWHhXRUxXY2xZRDZ5eHJtRTFpVzdMNTdFeDJCZnNiZGk5N1RGTkRjNnBtckdhUlpwM21jYzBCRHNheDRQQTUyWnhLemlIT0RjNTdMUU10UHkyeDFtcXRacTErclRmYWV0cSsybUx0Y3UwVzdldmE3M1Z3blVDZExKMzFPbTA2OTNVSnVqYTZVYnFGdXR0MXorbyswMlByZWVrSjljcjFEdW5kMFVmMWJmU2o5UmZxNzlidjBSODNNRFFJTnBBWmJERTRZL0RNa0dQb2E1aHB1Tkh3aE9Hb0VjdG91cEhFYUtQUlNhTW51Q2J1aDJmak5YZ1hQbWFzYnh4aXJEVGVaZHhyUEdGaWFUTGJwTVNreGVTK0tjMlVhNXBtdXRHMDAzVE16TWdzM0t6WXJNbnNqam5Wbkd1ZVliN1p2TnY4allXbFJaekZTb3MyaThlVzJwWjh5d1dXVFpiM3JKaFdQbFo1VnZWVzE2eEoxbHpyTE90dDFsZHNVQnRYbXd5Yk9wdkx0cWl0bTYzRWRwdHQzeFRpRkk4cDBpbjFVMjdhTWV6ODdBcnNtdXdHN1RuMllmWWw5bTMyengzTUhCSWQxanQwTzN4eWRIWE1kbXh3dk91azRUVERxY1NwdytsWFp4dG5vWE9kOHpVWHBrdVF5eEtYZHBjWFUyMm5pcWR1bjNyTGxlVWE3cnJTdGRQMW81dTdtOXl0MlczVTNjdzl4WDJyKzAwdW14dkpYY005NzBIMDhQZFk0bkhNNDUybm02ZkM4NURuTDE1MlhsbGUrNzBlVDdPY0pwN1dNRzNJMjhSYjRMM0xlMkE2UGoxbCtzN3BBejdHUGdLZmVwK0h2cWErSXQ4OXZpTisxbjZaZmdmOG52czcrc3Y5ai9pLzRYbnlGdkZPQldBQndRSGxBYjJCR29HekEyc0RId1NaQktVSE5RV05CYnNHTHd3K0ZVSU1DUTFaSDNLVGI4QVg4aHY1WXpQY1p5eWEwUlhLQ0owVldodjZNTXdtVEI3V0VZNkd6d2pmRUg1dnB2bE02Y3kyQ0lqZ1IyeUl1QjlwR1prWCtYMFVLU295cWk3cVViUlRkSEYwOXl6V3JPUlorMmU5anZHUHFZeTVPOXRxdG5KMlo2eHFiRkpzWSt5YnVJQzRxcmlCZUlmNFJmR1hFblFUSkFudGllVEUyTVE5aWVOekF1ZHNtak9jNUpwVWxuUmpydVhjb3JrWDV1bk95NTUzUEZrMVdaQjhPSVdZRXBleVArV0RJRUpRTHhoUDVhZHVUUjBUOG9TYmhVOUZ2cUtOb2xHeHQ3aEtQSkxtblZhVjlqamRPMzFEK21pR1QwWjF4ak1KVDFJcmVaRVprcmtqODAxV1JOYmVyTS9aY2RrdE9aU2NsSnlqVWcxcGxyUXIxekMzS0xkUFppc3JrdzNrZWVadHlodVRoOHIzNUNQNWMvUGJGV3lGVE5HanRGS3VVQTRXVEMrb0szaGJHRnQ0dUVpOVNGclVNOTltL3VyNUl3dUNGbnk5a0xCUXVMQ3oyTGg0V2ZIZ0lyOUZ1eFlqaTFNWGR5NHhYVks2WkhocDhOSjl5MmpMc3BiOVVPSllVbFh5YW5uYzhvNVNnOUtscFVNcmdsYzBsYW1VeWN0dXJ2UmF1V01WWVpWa1ZlOXFsOVZiVm44cUY1VmZySENzcUs3NHNFYTQ1dUpYVGwvVmZQVjViZHJhM2txM3l1M3JTT3VrNjI2czkxbS9yMHE5YWtIVjBJYndEYTBiOFkzbEcxOXRTdDUwb1hwcTlZN050TTNLelFNMVlUWHRXOHkyck52eW9UYWo5bnFkZjEzTFZ2MnRxN2UrMlNiYTFyL2RkM3Z6RG9NZEZUdmU3NVRzdkxVcmVGZHJ2VVY5OVc3UzdvTGRqeHBpRzdxLzVuN2R1RWQzVDhXZWozdWxld2YyUmUvcmFuUnZiTnl2djcreUNXMVNObzBlU0RwdzVadUFiOXFiN1pwM3RYQmFLZzdDUWVYQko5K21mSHZqVU9paHpzUGN3ODNmbVgrMzlRanJTSGtyMGpxL2Rhd3RvMjJnUGFHOTcraU1vNTBkWGgxSHZyZi9mdTh4NDJOMXh6V1BWNTZnblNnOThmbmtncFBqcDJTbm5wMU9QejNVbWR4NTkwejhtV3RkVVYyOVowUFBuajhYZE81TXQxLzN5ZlBlNTQ5ZDhMeHc5Q0wzWXRzbHQwdXRQYTQ5UjM1dy9lRklyMXR2NjJYM3krMVhQSzUwOUUzck85SHYwMy82YXNEVmM5ZjQxeTVkbjNtOTc4YnNHN2R1SnQwY3VDVzY5ZmgyOXUwWGR3cnVUTnhkZW85NHIveSsydjNxQi9vUDZuKzAvckZsd0czZytHREFZTS9EV1EvdkRnbUhudjZVLzlPSDRkSkh6RWZWSTBZampZK2RIeDhiRFJxOThtVE9rK0duc3FjVHo4cCtWdjk1NjNPcjU5Lzk0dnRMejFqODJQQUwrWXZQdjY1NXFmTnk3NnVwcnpySEk4Y2Z2TTU1UGZHbS9LM08yMzN2dU8rNjM4ZTlINWtvL0VEK1VQUFIrbVBIcDlCUDl6N25mUDc4TC9lRTgvc2wwcDh6QUFBQUlHTklVazBBQUhvbEFBQ0Fnd0FBK2Y4QUFJRHBBQUIxTUFBQTZtQUFBRHFZQUFBWGI1SmZ4VVlBQUFDYVNVUkJWSGphak5BOURnRUJFSWJoWjBVVW9oZVJLRjFCcTNVZUYxaVZRcVZRYVNRTzRnQ2k1QUlTalVZcGhORXN5U2E3ZGllWllyN00rODJQaUZDV1NCRzUvQWNVUVEzVjBjYjdXOVFCdXJoZ0JzMGF3QWluaUVpVEpGRzEvekRiZmZyVEtvQU43dWhWQXBoa3h5NXlla256R0RjYzBDb0ZNTUFTVHh6Ukx6QXp4eHA3dlBEQUNwMmk2VW5tZHMwY2Q5aEd4TG5zeDU4QkFHOGMzcFpwYk04L0FBQUFBRWxGVGtTdVFtQ0MnLFxyXG4gICAgICAgICAgICBERUw6ICdNNzMuNjQxLDQ1Ljk1N2wtMC4wMjEsMC4yNTJjMCwwLjAzMiwwLjAyMSwwLjA2LDAuMDIxLDAuMDg4YzAsMC4wNjUtMC4wMjIsMC4xMjYtMC4wMjYsMC4xOTFsLTIuNjg1LDU0Ljg3OEg3MC45MWMtMC4yMzEsNC4zMDQtNS4xNjYsMTAuODEtMzEuNzQ4LDEwLjgxYy0yNi41OCwwLTMxLjUwOS02LjUwNi0zMS43NDYtMTAuODFINy40MUw0LjczMSw0Ni40ODhjLTAuMDA5LTAuMDYtMC4wMjgtMC4xMjYtMC4wMjgtMC4xOTFjMC0wLjAzMiwwLjAxLTAuMDYsMC4wMS0wLjA4OGwtMC4wMS0wLjI1MmgwLjAyOGMwLjA5OS0wLjQ2NiwwLjM2NC0wLjkxOSwwLjc4NC0xLjM1M2MzLjQzOSwzLjQ3NywxNy4xOTEsNC4wNTEsMzMuNjQ2LDQuMDUxczMwLjIyMS0wLjU3NCwzMy42NDItNC4wNTFjMC40MjYsMC40MzQsMC43MTEsMC44ODcsMC43ODQsMS4zNTNINzMuNjQxeiBNNzguMzM1LDI1LjEwMnY2LjQwN2MwLDEuMzE2LTEuMzQsMi41NjctMy43MTUsMy42OTZjLTYuMjY2LDIuOTM2LTE5Ljc3Nyw0Ljk3NS0zNS40NTksNC45NzVjLTE1LjY2NiwwLTI5LjE4OS0yLjAzOS0zNS40NDItNC45NzVDMS4zMywzNC4wNzUsMCwzMi44MjUsMCwzMS41MDl2LTYuNDA3YzAtMy4zNzQsOC42ODEtNi4yODYsMjEuMzU5LTcuNzI0VjMuOTI5YzAtMi4xNiwxLjc2OC0zLjkyOSwzLjkzLTMuOTI5aDI2LjMxNGMyLjE2NCwwLDMuOTM4LDEuNzczLDMuOTM4LDMuOTM4djEzLjI5NkM2OC45OCwxOC42MDYsNzguMzMzLDIxLjYxMSw3OC4zMzUsMjUuMTAyeiBNNDguNDE2LDExLjM5NWMwLTIuMzQ4LTAuMzIxLTQuMjctMC43MTUtNC4yN2MtMC4zOTMsMC0yLjY0MSwwLTQuOTc5LDBoLTguNTQ1Yy0yLjM1MiwwLTQuNTkyLDAtNC45ODksMGMtMC4zODgsMC0wLjcxNCwxLjkyMi0wLjcxNCw0LjI3djUuMzY3bDEuMDgzLTAuMDY1YzMuMDY3LTAuMTczLDYuMjg2LTAuMjcsOS41OTUtMC4yNzFjMy4yMDIsMCw2LjI5MiwwLjA5OCw5LjI2NCwwLjI1MlYxMS4zOTV6J1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG5cclxuXHJcblxyXG4gICAgT3BlcmF0aW9uTm9kZS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJCYXNlKCk7XHJcbiAgICAgICAgaWYgKCF0aGlzLmZvcmJpZEVkaXQpIHtcclxuICAgICAgICAgICAgdGhpcy5yZW5kZXJPdGhlcigpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9O1xyXG5cclxuICAgIE9wZXJhdGlvbk5vZGUucHJvdG90eXBlLnJlbmRlckJhc2UgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB0aGlzLmNyZWF0ZU9wZXJhdGlvbigpO1xyXG4gICAgfTtcclxuXHJcbiAgICBPcGVyYXRpb25Ob2RlLnByb3RvdHlwZS5jcmVhdGVPcGVyYXRpb24gPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgbWUgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMudmlydHVhbFJlY3QgPSBuZXcgZ3JhcGhpYy5Qb2x5bGluZSh7IHN0eWxlOiB7IGxpbmVEYXNoOiBbMl0gfSB9KTtcclxuICAgICAgICB0aGlzLnZpcnR1YWxSZWN0LmlzU2VsZkNvbXB1dGVQb3MgPSB0cnVlOyAgLy8g6Ieq5bex6K6h566X5L2N572uXHJcbiAgICAgICAgdGhpcy5hZGQodGhpcy52aXJ0dWFsUmVjdCk7XHJcblxyXG5cclxuXHJcbiAgICAgICAgaWYgKHRoaXMubm9kZS5vcGVyYXRpb25JY29ucykge1xyXG4gICAgICAgICAgICB6clV0aWwuZWFjaCh0aGlzLm5vZGUub3BlcmF0aW9uSWNvbnMsIGZ1bmN0aW9uKGl0ZW0pIHtcclxuICAgICAgICAgICAgICAgIC8v5qOA5p+l5piv5ZCm5piv5YaF572u5Zu+5qCHXHJcbiAgICAgICAgICAgICAgICB2YXIgb3BJY29uSW5zdGFuY2UgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgaWYgKE9wZXJhdGlvbk5vZGUub3BpY29uc1tpdGVtLm5hbWUgKyBcIlwiXSkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5mb3JiaWRFZGl0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0ubmFtZSA9PSBcIkRFTFwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8v5Z6D5Zy+5qG2XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZWN0MSA9IHsgeDogMCwgeTogMCwgd2lkdGg6IDEwLCBoZWlnaHQ6IDE1IH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wSWNvbkluc3RhbmNlID0gZ3JhcGhpYy5tYWtlUGF0aChPcGVyYXRpb25Ob2RlLm9waWNvbnNbaXRlbS5uYW1lICsgXCJcIl0sIHsgc3R5bGU6IHsgZmlsbDogJyMwMDAwMDAnIH0gfSwgcmVjdDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihpdGVtLmNhbGxiYWNrKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wSWNvbkluc3RhbmNlLm9uKFwiY2xpY2tcIiwgZnVuY3Rpb24oZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUuZGF0YSA9IGl0ZW07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5ub2RlID0gbWUubm9kZTsgIC8vIOWwhuaJgOmZhOeahOiKgueCueS5n+S8oOmAkuWHuuWOu1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpdGVtLmNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0uY2FsbGJhY2soZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BJY29uSW5zdGFuY2Uub24oXCJjbGlja1wiLCBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhcmFtcyA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtcy5ldmVudCA9IGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zLnRhcmdldCA9IHRoaXM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zLnR5cGUgPSBPcGVyYXRpb25Ob2RlLkRFTEVURV9DTElDSztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZS50cmlnZ2VyKHBhcmFtcy50eXBlLCBwYXJhbXMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKCFlbnYuY2FudmFzU3VwcG9ydGVkKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZWN0ID0geyB4OiAwLCB5OiAwLCB3aWR0aDogMTUsIGhlaWdodDogMTUgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wSWNvbkluc3RhbmNlID0gZ3JhcGhpYy5tYWtlUGF0aChPcGVyYXRpb25Ob2RlLm9waWNvbnNbaXRlbS5uYW1lICsgXCJcIl0sIHsgc3R5bGU6IHsgZmlsbDogJyMwMDAwMDAnIH0sZHJhZ2dhYmxlOnRydWUsejoxOSxsaW5lVHlwZTogQ29ubmVjdG9yW1wiVFlQRV9cIiArIGl0ZW0ubmFtZV0gfSwgcmVjdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGltYWdlVXJsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW1nJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbWFnZVVybC5zcmMgPSBPcGVyYXRpb25Ob2RlLm9waWNvbnNbaXRlbS5uYW1lICsgXCJcIl07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcEljb25JbnN0YW5jZSA9IG5ldyBncmFwaGljLkltYWdlKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZToge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbWFnZTppbWFnZVVybCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3Vyc29yOiAnZGVmYXVsdCcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOjE1LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6MTVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRyYWdnYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB6OiAxOSwgLy96SW5kZXgg572u5LqO5pyA6auYXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZVR5cGU6IENvbm5lY3RvcltcIlRZUEVfXCIgKyBpdGVtLm5hbWVdIC8v5Yy65YiG5LiN5ZCM55qE57q/5q61XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIE1PVVNFX0VWRU5UX05BTUVTID0gWydkcmFnc3RhcnQnLCAnZHJhZycsICdkcmFnZW5kJ107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHpyVXRpbC5lYWNoKE1PVVNFX0VWRU5UX05BTUVTLCBmdW5jdGlvbihldmVOYW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcEljb25JbnN0YW5jZS5vbihldmVOYW1lLCBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhcmFtcyA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtcy5ldmVudCA9IGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zLnR5cGUgPSBcIk9wZXJhdGlvbk5vZGU6XCIgKyBldmVOYW1lICsgXCJBcnJvd1wiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lLnRyaWdnZXIocGFyYW1zLnR5cGUsIHBhcmFtcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy/nlKjmiLfoh6rlrprkuYnnmoTlm77moIfmlL7lnKjov5nph4zvvIznlKjmiLfkvKDov5vmnaXnmoTlm77moIflj6rog73lk43lupRjbGlja+S6i+S7tu+8jOWFtuWug+S6i+S7tuaaguS4jeaUr+aMgVxyXG4gICAgICAgICAgICAgICAgICAgIG9wSWNvbkluc3RhbmNlID0gbmV3IGdyYXBoaWMuSW1hZ2Uoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZToge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2U6IGl0ZW0uaWNvblBhdGgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogaXRlbS53aWR0aCB8fCAxNSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogaXRlbS5oZWlnaHQgfHwgMTVcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgejogMTkgLy96SW5kZXgg572u5LqO5pyA6auYXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgb3BJY29uSW5zdGFuY2Uub24oXCJjbGlja1wiLCBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGUuZGF0YSA9IGl0ZW07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGUubm9kZSA9IG1lLm5vZGU7ICAvLyDlsIbmiYDpmYTnmoToioLngrnkuZ/kvKDpgJLlh7rljrtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0uY2FsbGJhY2spIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0uY2FsbGJhY2soZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vdG9kbyDnlKjmiLfoh6rlrprlm77moIdjbGlja+S6i+S7tuaYr+WQpuimgea0vuWPkeWIsOWklumdolxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgb3BJY29uSW5zdGFuY2UubmFtZSA9IGl0ZW0ubmFtZTtcclxuICAgICAgICAgICAgICAgIG1lLmFkZChvcEljb25JbnN0YW5jZSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgT3BlcmF0aW9uTm9kZS5wcm90b3R5cGUucmVmcmVzaFBvc3Rpb24gPSBmdW5jdGlvbihub2RlLG5vZGVSZWN0KSB7XHJcbiAgICAgICAgdmFyIG1lID0gdGhpcztcclxuICAgICAgICB2YXIgaSA9IDA7XHJcbiAgICAgICAgdmFyIHJiUG9pbnQgPSBub2RlUmVjdC5wb2ludHNbMl07IC8v5Y+W5Y+z5LiL6KeS5Z2Q5qCHXHJcbiAgICAgICAgLy8xLuWumuS9jeiZmuahhlxyXG4gICAgICAgIHRoaXMudmlydHVhbFJlY3Quc2V0U2hhcGUoeyBwb2ludHM6IG5vZGVSZWN0LnBvaW50cyB9KTtcclxuICAgICAgICAvLzIu5a6a5L2N5q+P5Liq5bCP5Zu+5qCHXHJcbiAgICAgICAgdGhpcy5lYWNoQ2hpbGQoZnVuY3Rpb24obm9kZUl0ZW0pIHtcclxuICAgICAgICAgICAgaWYgKCFub2RlSXRlbS5pc1NlbGZDb21wdXRlUG9zKSB7XHJcbiAgICAgICAgICAgICAgICAvLyA4cHjmmK/nrKzkuIDkuKrmk43kvZzmjInpkq7lm77moIfnmoTot53nprsg6Z2g5aSq6L+R5LiN5aW955yLICAgIDIwcHjmmK/mr4/kuKrlm77moIfnmoTpl7TpmpQgIDEwcHjmmK/lm77moIflkJHlgY/nmoTot53nprtcclxuICAgICAgICAgICAgICAgIG5vZGVJdGVtLmF0dHIoXCJwb3NpdGlvblwiLCBbcmJQb2ludFswXSArIDggKyAoaSsrICogMjApLCByYlBvaW50WzFdIC0gMTBdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICB0aGlzLnJlZnJlc2hQb3NpdGlvbk90aGVyKG5vZGUsbm9kZVJlY3QpO1xyXG4gICAgfTtcclxuXHJcbiAgICBPcGVyYXRpb25Ob2RlLnByb3RvdHlwZS5yZW5kZXJPdGhlciA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIC8v55WZ57uZ5omp5bGV5L2/55SoXHJcbiAgICB9O1xyXG4gICAgT3BlcmF0aW9uTm9kZS5wcm90b3R5cGUucmVmcmVzaFBvc2l0aW9uT3RoZXIgPSBmdW5jdGlvbihub2RlLG5vZGVSZWN0KSB7XHJcbiAgICAgICAgLy/nlZnnu5nmianlsZXkvb/nlKhcclxuICAgICAgICAvLzMu5a6a5L2N5pW05Liqb3BlcmF0aW9uTm9kZVxyXG4gICAgICAgIGlmIChub2RlLnBhcmVudCAmJiBub2RlLnBhcmVudC5pc0JnICYmIG5vZGUucGFyZW50LmlzQmcgPT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICB0aGlzLmF0dHIoXCJwb3NpdGlvblwiLCBbbm9kZVJlY3QueCwgbm9kZVJlY3QueV0pXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5hdHRyKFwicG9zaXRpb25cIiwgW25vZGVSZWN0LnggKyBub2RlLnBhcmVudC5wb3NpdGlvblswXStub2RlLnNoYXBlLngsIG5vZGVSZWN0LnkgKyBub2RlLnBhcmVudC5wb3NpdGlvblsxXStub2RlLnNoYXBlLnldKVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICB6clV0aWwuaW5oZXJpdHMoT3BlcmF0aW9uTm9kZSwgTm9kZSk7XHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IE9wZXJhdGlvbk5vZGU7XHJcblxyXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vbGliL2Zpc2gtdG9wby1jb3JlL2xpYi9tYW5hZ2VyL09wZXJhdGlvbk5vZGUuanNcbiAqKiBtb2R1bGUgaWQgPSA4MlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXHJcbiAqIGZsb3fov57nur/nrqHnkIbnsbtcclxuICogQGF1dGhvciBtaWFvLmN1bnpoaVxyXG4gKi9cclxuXHJcblx0dmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xyXG5cdHZhciBDb25uZWN0aW9uTWFuYWdlciA9IHJlcXVpcmUoXCIuLi8uLi8uLi9maXNoLXRvcG8tY29yZS9saWIvbWFuYWdlci9Db25uZWN0aW9uTWFuYWdlci5qc1wiKTtcclxuXHR2YXIgQ29ubmVjdG9yID0gcmVxdWlyZShcIi4uLy4uLy4uL2Zpc2gtdG9wby1jb3JlL2xpYi9zaGFwZXMvQ29ubmVjdG9yLmpzXCIpO1xyXG4gICAgdmFyIFV0aWwgPSByZXF1aXJlKCcuLi8uLi8uLi9maXNoLXRvcG8tY29yZS9saWIvdXRpbCcpO1xyXG4gICAgdmFyIGdyYXBoaWMgPSByZXF1aXJlKFwiLi4vLi4vLi4vZmlzaC10b3BvLWNvcmUvbGliL2dyYXBoaWMuanNcIik7XHJcbiAgICB2YXIgUG9pbnQgPSByZXF1aXJlKFwiLi4vLi4vLi4vZmlzaC10b3BvLWNvcmUvbGliL1BvaW50LmpzXCIpO1xyXG4gICAgdmFyIENvbnN0YW50cyA9IHJlcXVpcmUoXCIuLi91dGlsL0Zsb3dDb25zdGFudHMuanNcIik7XHJcbiAgICB2YXIgTW9kZWwgPSByZXF1aXJlKFwiLi4vLi4vLi4vZmlzaC10b3BvLWNvcmUvbGliL21vZGVsLmpzXCIpO1xyXG4gICAgdmFyIExvZyA9IHJlcXVpcmUoXCIuLi8uLi8uLi9maXNoLXRvcG8tY29yZS9saWIvTG9nLmpzXCIpO1xyXG5cdHZhciBjb25uZWN0aW9uTWFuYWdlckV4dGVuZCA9IHtcclxuICAgICAgICBMaW5lT3BlcmF0aW9uczpbXSxcclxuICAgICAgICBidW5kbGVPZmZzZXQ6IDMwLFxyXG4gICAgICAgIGJ1bmRsZUdhcDogMjAsXHJcbiAgICAgICAgY29ubmVjdG9yTWFwOiBVdGlsLlN0YWNrZWRNYXAuY3JlYXRlTmV3KCksXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICog5Yib5bu66L+e57q/XHJcbiAgICAgICAgICogQHBhcmFtICB7W3R5cGVdfSBzdGFydE5vZGUgW+W8gOWni+iKgueCuV1cclxuICAgICAgICAgKiBAcGFyYW0gIHtbdHlwZV19IGVuZE5vZGUgICBb57uT5p2f6IqC54K5XVxyXG4gICAgICAgICAqIEBwYXJhbSAge1t0eXBlXX0gb3B0aW9ucyAgICAgIFvnsbvlnotdXHJcbiAgICAgICAgICogQHBhcmFtIHtbdHlwZV19IFthcGldIFtkZXNjcmlwdGlvbl1cclxuICAgICAgICAgKiBAcmV0dXJuIHtbdHlwZV19ICAgICAgICAgICBb6L+U5Zue6L+e57q/XVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGNvbm5lY3RvckNyZWF0ZTpmdW5jdGlvbihzdGFydE5vZGUsZW5kTm9kZSxvcHRpb25zLCBhcGkpe1xyXG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XHJcbiAgICAgICAgICAgIHZhciBtb2RlbCA9IG9wdGlvbnMubW9kZWw7XHJcbiAgICAgICAgICAgIC8vMS7liJvlu7rnur/mrrVcclxuICAgICAgICAgICAgdmFyIGNvbm5lY3RvciA9IG5ldyBDb25uZWN0b3Iob3B0aW9ucyk7XHJcbiAgICAgICAgICAgIGNvbm5lY3Rvci5zdGFydE5vZGUgPSBzdGFydE5vZGU7XHJcbiAgICAgICAgICAgIGNvbm5lY3Rvci5lbmROb2RlID0gZW5kTm9kZTtcclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMucG9zKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcG9zID0gb3B0aW9ucy5wb3Muc3BsaXQoXCIsXCIpO1xyXG4gICAgICAgICAgICAgICAgY29ubmVjdG9yLnNQb3MgPSBwb3NbMF07XHJcbiAgICAgICAgICAgICAgICBjb25uZWN0b3IuZVBvcyA9IHBvc1sxXTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdGhpcy5jb25uZWN0b3JzLnB1c2goY29ubmVjdG9yKTtcclxuXHJcbiAgICAgICAgICAgIHZhciBrZXkgPSB0aGlzLmdldFR3b05vZGVJZChzdGFydE5vZGUsZW5kTm9kZSk7XHJcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdG9yTWFwLmFkZChrZXksIGNvbm5lY3Rvcik7XHJcblxyXG4gICAgICAgICAgICBpZihjb25uZWN0b3IuY29uUG9pbnRzR3JvdXApIHtcclxuICAgICAgICAgICAgICAgIGNvbm5lY3Rvci5jb25Qb2ludHNHcm91cC5vbihcImNsaWNrXCIsIGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYXJyU3BsaXQgPSBlLnRhcmdldC50eXBlLnNwbGl0KENvbm5lY3Rvci5TRVBFUkFUT1IpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjb25uZWN0b3IgPSBlLnRhcmdldC5jb25uZWN0b3I7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFyclNwbGl0WzBdID09PSBDb25uZWN0b3IuU1RBUlRfTk9ERSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25uZWN0b3Iuc1BvcyA9IGFyclNwbGl0WzFdO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYXJyU3BsaXRbMF0gPT09IENvbm5lY3Rvci5FTkRfTk9ERSl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbm5lY3Rvci5lUG9zID0gYXJyU3BsaXRbMV07XHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICB0aGF0LnJlZnJlc2hDb25uZWN0b3IoY29ubmVjdG9yLHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGUuY2FuY2VsQnViYmxlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcGFyYW1zID0ge307XHJcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zLmV2ZW50ID0gZTtcclxuICAgICAgICAgICAgICAgICAgICBwYXJhbXMudHlwZSA9IFwiY29uUG9pbnRzR3JvdXA6Y2xpY2tcIjtcclxuICAgICAgICAgICAgICAgICAgICBwYXJhbXMubGluZU5vZGUgPSB0aGF0LnNlbENvbm5lY3RvcjtcclxuICAgICAgICAgICAgICAgICAgICBhcGkudHJpZ2dlcihwYXJhbXMudHlwZSwgcGFyYW1zKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAgICAgdmFyIE1PVVNFX0VWRU5UX05BTUVTID0gWyAnY2xpY2snLCAnZGJsY2xpY2snXTtcclxuICAgICAgICAgICAgenJVdGlsLmVhY2goTU9VU0VfRVZFTlRfTkFNRVMsIGZ1bmN0aW9uIChldmVOYW1lKSB7XHJcbiAgICAgICAgICAgICAgICBjb25uZWN0b3Iub24oXCJDb25uZWN0b3I6XCIgKyBldmVOYW1lLCBmdW5jdGlvbihlKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzZWxlY3RlZCA9IGUudGFyZ2V0O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIHRoYXQuc2VsQ29ubmVjdG9yICE9PSBzZWxlY3RlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGF0LnNlbENvbm5lY3RvciAmJiAgdGhhdC5yZWZyZXNoQ29ubmVjdG9yKHRoYXQuc2VsQ29ubmVjdG9yKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5zZWxDb25uZWN0b3IgPSBzZWxlY3RlZDtcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIGUuY2FuY2VsQnViYmxlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcGFyYW1zID0ge307XHJcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zLmV2ZW50ID0gZTtcclxuICAgICAgICAgICAgICAgICAgICBwYXJhbXMudHlwZSA9IGV2ZU5hbWU7XHJcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zLnRhcmdldCA9IHRoYXQuc2VsQ29ubmVjdG9yO1xyXG4gICAgICAgICAgICAgICAgICAgIGFwaS50cmlnZ2VyKHBhcmFtcy50eXBlLCBwYXJhbXMpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuXHJcblxyXG4gICAgICAgICAgICAvL+WPjOWHu+aUtue0p+S4uuS4gOadoee6v1xyXG4gICAgICAgICAgICBjb25uZWN0b3IubGluZS5vbihcImRibGNsaWNrXCIsIGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgICAgICAgIGlmKGNvbm5lY3Rvci5vcHRpb25zLmlzU2hyaW5rID09IGZhbHNlKXtyZXR1cm47fVxyXG4gICAgICAgICAgICAgICAgdmFyIGNvbiA9IHRoaXMucGFyZW50O1xyXG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0Tm9kZSA9IGNvbi5zdGFydE5vZGU7XHJcbiAgICAgICAgICAgICAgICB2YXIgZW5kTm9kZSA9IGNvbi5lbmROb2RlO1xyXG4gICAgICAgICAgICAgICAgLy8xLuiOt+WPluaJgOacieeahOe6v+autVxyXG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IHRoYXQuZ2V0VHdvTm9kZUlkKHN0YXJ0Tm9kZSxlbmROb2RlKTtcclxuICAgICAgICAgICAgICAgIHZhciBjb25zID0gdGhhdC5jb25uZWN0b3JNYXAuZ2V0KGtleSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoY29ucy5sZW5ndGggPT0gMSkge3JldHVybn07XHJcbiAgICAgICAgICAgICAgICAvLzIu5Yik5pat57q/5piv5ZCm5aSE5LqO6ZqQ6JeP54q25oCBXHJcblxyXG4gICAgICAgICAgICAgICAgLy8yLuWwhumZpOS4remXtOeahOS4gOadoee6v+i/m+ihjOmakOiXj1xyXG4gICAgICAgICAgICAgICAgdmFyIGhhbGYgPSBwYXJzZUludChjb25zLmxlbmd0aCAvIDIpO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb25zLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgIT0gKGhhbGYgKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29uc1tpXS5pZ25vcmUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNbaV0uc2hvdygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgY29uc1tpXS5oaWRlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgLy8gIHRoYXQucmVmcmVzaENvbm5lY3Rvcih0aGlzLnBhcmVudCx0cnVlKTtcclxuICAgICAgICAgICAgICAgIC8vYWxlcnQoXCJhYmNcIik7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5idW5kbGVPZmZzZXQgPSBvcHRpb25zLmJ1bmRsZU9mZnNldCB8fCB0aGlzLmJ1bmRsZU9mZnNldDtcclxuICAgICAgICAgICAgdGhpcy5idW5kbGVHYXAgPSBvcHRpb25zLmJ1bmRsZUdhcCB8fCB0aGlzLmJ1bmRsZUdhcDtcclxuICAgICAgICAgICAgLy8yLiDojrflj5bov5nkuKprZXnlr7nlupTnmoTnur/mrrXmlbDnu4RcclxuICAgICAgICAgICAgdmFyIGFyckNvbnMgPSB0aGlzLmNvbm5lY3Rvck1hcC5nZXQoa2V5KTtcclxuICAgICAgICAgICAgaWYgKGFyckNvbnMubGVuZ3RoID09IDEpIHtcclxuICAgICAgICAgICAgICAgIC8v5Lik5Liq6IqC54K55Y+q5pyJ5LiA5Liq6L+e57q/55qE5oOF5Ya1XHJcbiAgICAgICAgICAgICAgICAvL+WIpOaWreS4gOS4iyBtb2RlbOmHjOacieayoeaciWRvY2tlcnPvvIzlpoLmnpzmnInliJnosIPnlKjmnoTpgKBwb2ludOaVsOe7hCAg5oiW6ICF6LCD55SocmVmcmVzaENvbm5lY3Rvcuiuoeeul+WmguS9leeUu+e6v1xyXG4gICAgICAgICAgICAgICAgdmFyIGRvY2tlcnMgPSBvcHRpb25zLmRvY2tlcnM7XHJcbiAgICAgICAgICAgICAgICBpZiAoZG9ja2VycyAmJiBkb2NrZXJzLmxlbmd0aCA+PSAyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBvaW50cyA9IFBvaW50LmxvYWRBcnJheShkb2NrZXJzKTtcclxuICAgICAgICAgICAgICAgICAgICBjb25uZWN0b3IucmVmcmVzaChwb2ludHMpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpZihvcHRpb25zLnBvc2l0aW9uJiZvcHRpb25zLnBvc2l0aW9uLnBvaW50cyl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhcnJTdGFydEVuZFBvaW50ID0gdGhpcy5nZXRTdGFydEVuZFBvaW50KGNvbm5lY3Rvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwb2ludHMgPSBvcHRpb25zLnBvc2l0aW9uLnBvaW50cztcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzLnVuc2hpZnQoYXJyU3RhcnRFbmRQb2ludFswXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKGFyclN0YXJ0RW5kUG9pbnRbMV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25uZWN0b3IucmVmcmVzaChwb2ludHMpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlZnJlc2hDb25uZWN0b3IoYXJyQ29uc1swXSx0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChhcnJDb25zLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICAgICAgICAgIC8v5Lik5Liq6IqC54K55pyJ5aSa5Liq6L+e57q/55qE5oOF5Ya1XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlZnJlc2hDb25zKGFyckNvbnMpO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgLy8zLuiuvue9ruaooeWei1xyXG4gICAgICAgICAgICB2YXIgbW9kZWwgPSBuZXcgTW9kZWwoe30pO1xyXG4gICAgICAgICAgICBtb2RlbC5zZXQoQ29uc3RhbnRzLkVMRU1FTlRfVFlQRSwgQ29uc3RhbnRzLkNPTk5FQ1RJT04pO1xyXG4gICAgICAgICAgICBtb2RlbC5zZXQoQ29uc3RhbnRzLlNUQVJUX0lELCBzdGFydE5vZGUubW9kZWwuZ2V0KENvbnN0YW50cy5JRCkpO1xyXG4gICAgICAgICAgICBtb2RlbC5zZXQoQ29uc3RhbnRzLkVORF9JRCwgZW5kTm9kZS5tb2RlbC5nZXQoQ29uc3RhbnRzLklEKSk7XHJcbiAgICAgICAgICAgIG1vZGVsLnNldChDb25zdGFudHMuT1BUSU9OUywgenJVdGlsLmNsb25lKG9wdGlvbnMpKTtcclxuICAgICAgICAgICAgbW9kZWwuc2V0KENvbnN0YW50cy5ET0NLRVJTLCBjb25uZWN0b3IudHVybmluZ1BvaW50cyk7XHJcbiAgICAgICAgICAgIG1vZGVsLnNldChDb25zdGFudHMuU1RZTEVfTElORVRZUEUsIG9wdGlvbnMuc3R5bGUubGluZVR5cGUpO1xyXG4gICAgICAgICAgICBjb25uZWN0b3IubW9kZWwgPSBtb2RlbDtcclxuICAgICAgICAgICAgcmV0dXJuIGNvbm5lY3RvcjtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBnZXRUd29Ob2RlSWQ6IGZ1bmN0aW9uKHN0YXJ0Tm9kZSxlbmROb2RlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzdGFydE5vZGUuaWQgKyBcIixcIiArIGVuZE5vZGUuaWQ7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvL+WkhOeQhuWkmuadoee6v+autVxyXG4gICAgICAgIHJlZnJlc2hDb25zOiBmdW5jdGlvbihhcnJDb25zKSB7XHJcbiAgICAgICAgICAgIC8v5aaC5p6c5piv5oqY57q/55qE6K+dXHJcbiAgICAgICAgICAgIGlmIChhcnJDb25zWzBdLm9wdGlvbnMuc3R5bGUubGluZVR5cGUgPT0gQ29ubmVjdG9yLlRZUEVfSkFHR0VEICkge1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJDb25zLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWZyZXNoQ29ubmVjdG9yKGFyckNvbnNbaV0sdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9IGVsc2V7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlZnJlc2hDb25zU3RyYWlnaHQoYXJyQ29ucyk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLy/lpITnkIblpJrmnaHnur/mrrUo55u057q/KVxyXG4gICAgICAgIHJlZnJlc2hDb25zU3RyYWlnaHQ6IGZ1bmN0aW9uKGFyckNvbnMpIHtcclxuICAgICAgICAgICAgdmFyIGhhbGYgPSBwYXJzZUludChhcnJDb25zLmxlbmd0aCAvIDIpO1xyXG4gICAgICAgICAgICB2YXIgYXJyQ29ubmVjdFJlc3VsdCA9IFtdXHJcblxyXG4gICAgICAgICAgICB2YXIgc3RhcnROb2RlID0gYXJyQ29uc1swXS5zdGFydE5vZGU7XHJcbiAgICAgICAgICAgIHZhciBlbmROb2RlID0gYXJyQ29uc1swXS5lbmROb2RlO1xyXG4gICAgICAgICAgICB2YXIgc1JlY3QgPSBVdGlsLmdldFJlY3Qoc3RhcnROb2RlKS5ib3VuZGluZ1JlY3Q7XHJcbiAgICAgICAgICAgIHZhciBlUmVjdCA9IFV0aWwuZ2V0UmVjdChlbmROb2RlKS5ib3VuZGluZ1JlY3Q7XHJcbiAgICAgICAgICAgIHZhciBzQ29ubmVjdG9yUG9pbnQgPSBVdGlsLmdldENvbm5lY3RvclBvaW50cyhzUmVjdCk7XHJcbiAgICAgICAgICAgIHZhciBlQ29ubmVjdG9yUG9pbnQgPSBVdGlsLmdldENvbm5lY3RvclBvaW50cyhlUmVjdCk7XHJcbiAgICAgICAgICAgIC8v5Yik5pat5aaC5p6c5rKh5pyJ5oyH5a6a5L2N572u55qE6K+dLCDliKTmlq3lvIDlp4voioLngrnlnKjnu5PmnZ/nu5Pmnpzlt6bovrnliJnph4fnlKggcmlnaHQtbGVmdCDlkKbliJnph4fnlKhsZWZ0LXJpZ2h0XHJcblxyXG4gICAgICAgICAgICBpZiAoIWFyckNvbnNbMF0uc1BvcyB8fCAhYXJyQ29uc1swXS5lUG9zKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoc1JlY3QueCA8IGVSZWN0LngpIHtcclxuICAgICAgICAgICAgICAgICAgICBhcnJDb25zWzBdLnNQb3MgPSBcInJpZ2h0XCI7XHJcbiAgICAgICAgICAgICAgICAgICAgYXJyQ29uc1swXS5lUG9zID0gXCJsZWZ0XCI7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGFyckNvbnNbMF0uc1BvcyA9IFwibGVmdFwiO1xyXG4gICAgICAgICAgICAgICAgICAgIGFyckNvbnNbMF0uZVBvcyA9IFwicmlnaHRcIjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgc3RhcnRQb2ludCA9IHNDb25uZWN0b3JQb2ludFthcnJDb25zWzBdLnNQb3NdO1xyXG4gICAgICAgICAgICB2YXIgZW5kUG9pbnQgPSBlQ29ubmVjdG9yUG9pbnRbYXJyQ29uc1swXS5lUG9zXTtcclxuICAgICAgICAgICAgdmFyIGFuZ2xlID0gTWF0aC5hdGFuMihlbmRQb2ludC55IC0gc3RhcnRQb2ludC55ICwgZW5kUG9pbnQueCAtIHN0YXJ0UG9pbnQueCk7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSBoYWxmOyBpID49IDE7IGktLSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHBvaW50cyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgcG9pbnRzLnB1c2goc3RhcnRQb2ludCk7ICAvL1xyXG4gICAgICAgICAgICAgICAvLyBwb2ludHMucHVzaChuZXcgUG9pbnQoc3RhcnRQb2ludC54ICsgYnVuZGxlT2Zmc2V0ICwgc3RhcnRQb2ludC55ICsgaSAqIGJ1bmRsZUdhcCkpO1xyXG4gICAgICAgICAgICAgICAvLyBwb2ludHMucHVzaChuZXcgUG9pbnQoZW5kUG9pbnQueCAtIGJ1bmRsZU9mZnNldCAsIHN0YXJ0UG9pbnQueSArIGkgKiBidW5kbGVHYXApKTsgLy9zdGFydFBvaW50LnggKyBidW5kbGVPZmZzZXRcclxuICAgICAgICAgICAgICAgIHZhciBzZWNvbmRQb2ludCA9IHN0YXJ0UG9pbnQuY2xvbmUoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvL3NlY29uZFBvaW50LnggPSAgc2Vjb25kUG9pbnQueCArIHRoaXMuYnVuZGxlT2Zmc2V0O1xyXG4gICAgICAgICAgICAgICAgc2Vjb25kUG9pbnQudHJhbnNmb3JtKFV0aWwudHJhbnNsYXRpb25NYXRyaXgoMCwgdGhpcy5idW5kbGVHYXAqIGkpKTtcclxuICAgICAgICAgICAgICAgIC8vc2Vjb25kUG9pbnQgPSB0aGlzLmJvdW5kT2Zmc2V0WFkoc2Vjb25kUG9pbnQsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgICAgIC8v55u06KeS5Z2Q5qCHIHgsIOWSjCB5LCDorqHnrpflh7rmnoHlnZDmoIdcclxuXHJcblxyXG4gICAgICAgICAgICAgICAgLy/ku47mnoHlnZDmoIforqHnrpflh7rnm7Top5LlnZDmoIdcclxuICAgICAgICAgICAgICAgIHNlY29uZFBvaW50LnggPSAgc2Vjb25kUG9pbnQueCArIHRoaXMuYnVuZGxlT2Zmc2V0ICogTWF0aC5jb3MoYW5nbGUpO1xyXG4gICAgICAgICAgICAgICAgc2Vjb25kUG9pbnQueSA9ICBzZWNvbmRQb2ludC55ICsgdGhpcy5idW5kbGVPZmZzZXQgKiBNYXRoLnNpbihhbmdsZSk7XHJcblxyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAvL3NlY29uZFBvaW50LnRyYW5zZm9ybShVdGlsLnNjYWxlTWF0cml4KDAuNSkpO1xyXG4gICAgICAgICAgICAgICAgcG9pbnRzLnB1c2goc2Vjb25kUG9pbnQpO1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciB0aGlyZFBvaW50ID0gZW5kUG9pbnQuY2xvbmUoKTtcclxuICAgICAgICAgICAgICAgIC8vdGhpcmRQb2ludC54ID0gIHRoaXJkUG9pbnQueCAtIHRoaXMuYnVuZGxlT2Zmc2V0O1xyXG5cclxuXHJcblxyXG4gICAgICAgICAgICAgICAgdGhpcmRQb2ludC50cmFuc2Zvcm0oVXRpbC50cmFuc2xhdGlvbk1hdHJpeCgwLCB0aGlzLmJ1bmRsZUdhcCppKSk7XHJcbiAgICAgICAgICAgICAgICAvL3RoaXJkUG9pbnQgPSB0aGlzLmJvdW5kT2Zmc2V0WFkodGhpcmRQb2ludCwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgLy9zZWNvbmRQb2ludC50cmFuc2Zvcm0oVXRpbC5zY2FsZU1hdHJpeCgwLjUpKTtcclxuICAgICAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgICAgICAvL+ebtOinkuWdkOaghyB4LCDlkowgeSwg6K6h566X5Ye65p6B5Z2Q5qCHXHJcblxyXG4gICAgICAgICAgICAgICAgLy/ku47mnoHlnZDmoIforqHnrpflh7rnm7Top5LlnZDmoIdcclxuICAgICAgICAgICAgICAgIHRoaXJkUG9pbnQueCA9ICB0aGlyZFBvaW50LnggLSB0aGlzLmJ1bmRsZU9mZnNldCAqIE1hdGguY29zKGFuZ2xlKTtcclxuICAgICAgICAgICAgICAgIHRoaXJkUG9pbnQueSA9ICB0aGlyZFBvaW50LnkgLSB0aGlzLmJ1bmRsZU9mZnNldCAqIE1hdGguc2luKGFuZ2xlKTtcclxuXHJcbiAgICAgICAgICAgICAgICBwb2ludHMucHVzaCh0aGlyZFBvaW50KTtcclxuXHJcbiAgICAgICAgICAgICAgICBwb2ludHMucHVzaChlbmRQb2ludCk7XHJcbiAgICAgICAgICAgICAgICBhcnJDb25uZWN0UmVzdWx0LnB1c2gocG9pbnRzKTtcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIGFyckNvbm5lY3RSZXN1bHQucHVzaChbc3RhcnRQb2ludCwgZW5kUG9pbnRdKTtcclxuXHJcbiAgICAgICAgICAgIHZhciB1cEhhbGYgPSAgTWF0aC5jZWlsKGFyckNvbnMubGVuZ3RoIC8gMik7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgdXBIYWxmOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBwb2ludHMgPSBbXTtcclxuICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKHN0YXJ0UG9pbnQpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHNlY29uZFBvaW50ID0gc3RhcnRQb2ludC5jbG9uZSgpO1xyXG4gICAgICAgICAgICAgICAgLy9zZWNvbmRQb2ludC54ID0gIHNlY29uZFBvaW50LnggKyB0aGlzLmJ1bmRsZU9mZnNldDtcclxuICAgICAgICAgICAgICAgIHNlY29uZFBvaW50LnRyYW5zZm9ybShVdGlsLnRyYW5zbGF0aW9uTWF0cml4KDAsIC0gdGhpcy5idW5kbGVHYXAqIGkpKTtcclxuICAgICAgICAgICAgICAgIHNlY29uZFBvaW50LnggPSAgc2Vjb25kUG9pbnQueCArIHRoaXMuYnVuZGxlT2Zmc2V0ICogTWF0aC5jb3MoYW5nbGUpO1xyXG4gICAgICAgICAgICAgICAgc2Vjb25kUG9pbnQueSA9ICBzZWNvbmRQb2ludC55ICsgdGhpcy5idW5kbGVPZmZzZXQgKiBNYXRoLnNpbihhbmdsZSk7XHJcbiAgICAgICAgICAgICAgICBwb2ludHMucHVzaChzZWNvbmRQb2ludCk7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIHRoaXJkUG9pbnQgPSBlbmRQb2ludC5jbG9uZSgpO1xyXG4gICAgICAgICAgICAgICAgLy90aGlyZFBvaW50LnggPSAgdGhpcmRQb2ludC54IC0gdGhpcy5idW5kbGVPZmZzZXQ7XHJcbiAgICAgICAgICAgICAgICB0aGlyZFBvaW50LnRyYW5zZm9ybShVdGlsLnRyYW5zbGF0aW9uTWF0cml4KDAsIC0gdGhpcy5idW5kbGVHYXAqaSkpO1xyXG4gICAgICAgICAgICAgICAgLy/ku47mnoHlnZDmoIforqHnrpflh7rnm7Top5LlnZDmoIdcclxuICAgICAgICAgICAgICAgIHRoaXJkUG9pbnQueCA9ICB0aGlyZFBvaW50LnggLSB0aGlzLmJ1bmRsZU9mZnNldCAqIE1hdGguY29zKGFuZ2xlKTtcclxuICAgICAgICAgICAgICAgIHRoaXJkUG9pbnQueSA9ICB0aGlyZFBvaW50LnkgLSB0aGlzLmJ1bmRsZU9mZnNldCAqIE1hdGguc2luKGFuZ2xlKTtcclxuICAgICAgICAgICAgICAgIC8vc2Vjb25kUG9pbnQudHJhbnNmb3JtKFV0aWwuc2NhbGVNYXRyaXgoMC41KSk7XHJcbiAgICAgICAgICAgICAgICBwb2ludHMucHVzaCh0aGlyZFBvaW50KTtcclxuXHJcbiAgICAgICAgICAgICAgICBwb2ludHMucHVzaChlbmRQb2ludCk7XHJcbiAgICAgICAgICAgICAgICBhcnJDb25uZWN0UmVzdWx0LnB1c2gocG9pbnRzKTtcclxuICAgICAgICAgICB9O1xyXG5cclxuXHJcbiAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJDb25uZWN0UmVzdWx0Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgIGFyckNvbnNbaV0ucmVmcmVzaChhcnJDb25uZWN0UmVzdWx0W2ldKTtcclxuICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICB9LFxyXG4gICAgICAgIGJvdW5kT2Zmc2V0WFk6IGZ1bmN0aW9uKHBvaW50LCBpc1Bvc2l0aXZlKSB7XHJcbiAgICAgICAgICAgIHZhciByZXN1bHRQb2ludCA9IHBvaW50LmNsb25lKCk7XHJcbiAgICAgICAgICAgIC8v55u06KeS5Z2Q5qCHIHgsIOWSjCB5LCDorqHnrpflh7rmnoHlnZDmoIdcclxuICAgICAgICAgICAgdmFyIGFuZ2xlID0gTWF0aC5hdGFuMihyZXN1bHRQb2ludC55ICwgcmVzdWx0UG9pbnQueCk7XHJcbiAgICAgICAgICAgIHZhciByID0gTWF0aC5zcXJ0KCBNYXRoLnBvdyhyZXN1bHRQb2ludC54LCAyKSArIE1hdGgucG93KHJlc3VsdFBvaW50LnksIDIpKTtcclxuICAgICAgICAgICAgaWYoaXNQb3NpdGl2ZSkge1xyXG4gICAgICAgICAgICAgICAgciA9IHIgKyB0aGlzLmJ1bmRsZU9mZnNldDtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHIgPSByIC0gdGhpcy5idW5kbGVPZmZzZXQ7XHJcbiAgICAgICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgICAgICAvL+S7juaegeWdkOagh+iuoeeul+WHuuebtOinkuWdkOagh1xyXG4gICAgICAgICAgICByZXN1bHRQb2ludC54ID0gciAqIE1hdGguY29zKGFuZ2xlKTtcclxuICAgICAgICAgICAgcmVzdWx0UG9pbnQueSA9IHIgKiBNYXRoLnNpbihhbmdsZSk7XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHRQb2ludDtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiDorr7nva7nur/mrrXnmoTmqKHlnovmlbDmja4gICjnsbvlnosg5paH5a2XKVxyXG4gICAgICAgICAqIEBwYXJhbSB7W3R5cGVdfSBjb25uZWN0b3IgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICAgICAqIEBwYXJhbSB7W3R5cGVdfSBvcHRpb24gICAgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHNldE1vZGVsOiBmdW5jdGlvbihjb25uZWN0b3IsIG9wdGlvbikge1xyXG4gICAgICAgICAgICB2YXIgb3JpZ2luTGluZVR5cGUgPSAgY29ubmVjdG9yLm1vZGVsLmdldChcInN0eWxlLmxpbmVUeXBlXCIpO1xyXG4gICAgICAgICAgICBjb25uZWN0b3IubW9kZWwubWVyZ2VPcHRpb24ob3B0aW9uKTtcclxuICAgICAgICAgICAgaWYgKG9yaWdpbkxpbmVUeXBlICE9PSBvcHRpb24uc3R5bGUubGluZVR5cGUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVmcmVzaENvbm5lY3Rvcihjb25uZWN0b3IsIHRydWUpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0sXHJcblxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiDliLfmlrDov57mjqXnur9cclxuICAgICAgICAgKiBAcGFyYW0gIHtbdHlwZV19IG5vZGUgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICAgICAqIEByZXR1cm4ge1t0eXBlXX0gICAgICBbZGVzY3JpcHRpb25dXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgcmVmcmVzaExpbmVCeU5vZGU6IGZ1bmN0aW9uKG5vZGUpIHtcclxuICAgICAgICAgICAgLy8g5Yik5pat6L+Z5Liq6IqC54K55piv5ZCm5pyJ5aSa5p2h57q/5q61XHJcbiAgICAgICAgICAgIHZhciBrZXlzID0gdGhpcy5jb25uZWN0b3JNYXAua2V5cygpO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xyXG4gICAgICAgICAgICAgICAgaWYgKGtleS5pbmRleE9mKG5vZGUuaWQpICE9IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFyckNvbnMgPSB0aGlzLmNvbm5lY3Rvck1hcC5nZXQoa2V5KTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYXJyQ29ucy5sZW5ndGggPT0gMSApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy/kuKTkuKroioLngrnlj6rmnInkuIDkuKrov57nur/nmoTmg4XlhrVcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWZyZXNoQ29ubmVjdG9yKGFyckNvbnNbMF0sdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGFyckNvbnMubGVuZ3RoID4gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL+S4pOS4quiKgueCueacieWkmuS4qui/nue6v+eahOaDheWGtVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlZnJlc2hDb25zKGFyckNvbnMpO1xyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0sXHJcblx0fVxyXG5cclxuXHR2YXIgRmxvd0Nvbm5lY3Rpb25NYW5hZ2VyID0genJVdGlsLmV4dGVuZChDb25uZWN0aW9uTWFuYWdlciwgY29ubmVjdGlvbk1hbmFnZXJFeHRlbmQpXHJcblx0bW9kdWxlLmV4cG9ydHMgPSBGbG93Q29ubmVjdGlvbk1hbmFnZXI7XHJcblxyXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vbGliL2Zpc2gtdG9wby1mbG93L2xpYi9tYW5hZ2VyL0Zsb3dDb25uZWN0aW9uTWFuYWdlci5qc1xuICoqIG1vZHVsZSBpZCA9IDgzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcclxuICog6L+e57q/566h55CG57G7XHJcbiAqIEBhdXRob3Igd2FuZy54aWFvaHVcclxuICovXHJcblxyXG4gICAgdmFyIE5vZGUgPSByZXF1aXJlKFwiLi4vTm9kZVwiKTtcclxuICAgIHZhciBVdGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xyXG4gICAgdmFyIGdyYXBoaWMgPSByZXF1aXJlKFwiLi4vZ3JhcGhpYy5qc1wiKTtcclxuICAgIHZhciBQb2ludCA9IHJlcXVpcmUoXCIuLi9Qb2ludC5qc1wiKTtcclxuICAgIHZhciBDb25uZWN0b3IgPSByZXF1aXJlKFwiLi4vc2hhcGVzL0Nvbm5lY3Rvci5qc1wiKTtcclxuICAgIHZhciBMb2cgPSByZXF1aXJlKFwiLi4vTG9nLmpzXCIpO1xyXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xyXG4gICAgdmFyIENvbm5lY3Rpb25NYW5hZ2VyID0ge1xyXG5cclxuICAgICAgICBDTE9VRF9SQURJVVM6IDEyLFxyXG4gICAgICAgIENMT1VEX0xJTkVXSURUSDogMyxcclxuICAgICAgICBDTE9VRF9TVFJPS0VfU1RZTEU6IFwicmdiYSgyNTUsIDE1MywgMCwgMC44KVwiLCAvL29yYW5nZVxyXG4gICAgICAgIHN0ZW5jaWxUeXBlIDogXCJTZXF1ZW5jZUZsb3dcIixcclxuICAgICAgICBjb25uZWN0b3JzOiBbXSxcclxuICAgICAgICBzZWxDb25uZWN0b3I6IG51bGwsXHJcbiAgICAgICAgdGVtcENvbm5lY3RvcjogbnVsbCxcclxuXHJcblxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiDorr7nva7nur/nmoTkuI3lj6/nvJbovpFcclxuICAgICAgICAgKiBAcGFyYW0gIHtbdHlwZV19IGZvcmJpZEVkaXQgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICAgICAqIEByZXR1cm4ge1t0eXBlXX0gICAgICAgICAgICBbZGVzY3JpcHRpb25dXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgY29ubmVjdG9yRm9yYmlkRWRpdDpmdW5jdGlvbihmb3JiaWRFZGl0KXtcclxuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgICAgICAgICBmb3IodmFyIGkgPSAwO2kgPCB0aGlzLmNvbm5lY3RvcnMubGVuZ3RoO2krKyl7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3RvcnNbaV0ub3B0aW9ucy5pc0VkaXQgPSAhZm9yYmlkRWRpdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiDmuIXnqbrov57mjqXnur9cclxuICAgICAgICAgKiBAcmV0dXJuIHtbdHlwZV19IFtkZXNjcmlwdGlvbl1cclxuICAgICAgICAgKi9cclxuICAgICAgICBjbGVhclNlbGVjdENvbjogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIGlmIChDb25uZWN0aW9uTWFuYWdlci5zZWxDb25uZWN0b3IgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZWZyZXNoQ29ubmVjdG9yKHRoaXMuc2VsQ29ubmVjdG9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICog5Yig6Zmk6L+e5o6l57q/XHJcbiAgICAgICAgICogQHJldHVybiB7W3R5cGVdfSBbZGVzY3JpcHRpb25dXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZGVsZXRlU2VsZWN0Q29uOmZ1bmN0aW9uKG5vZGUsX3pyKXtcclxuICAgICAgICAgICAgdmFyIGRlbGV0ZUxpbmU9IFtdO1xyXG4gICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5jb25uZWN0b3JzLmxlbmd0aDsgaSsrKXtcclxuICAgICAgICAgICAgICAgIGlmKHRoaXMuY29ubmVjdG9yc1tpXS5zdGFydE5vZGUgPT0gbm9kZSB8fCB0aGlzLmNvbm5lY3RvcnNbaV0uZW5kTm9kZSA9PSBub2RlKXtcclxuICAgICAgICAgICAgICAgICAgICAvLzEu5bCG57q/IOaJgOiBlOeahHN0YXJ0Tm9kZeeahG91dGdvaW5n5pWw5o2u5Yig6ZmkXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXJ0Tm9kZU91dGdvaW5nID0gdGhpcy5jb25uZWN0b3JzW2ldLnN0YXJ0Tm9kZS5tb2RlbC5nZXQoXCJvdXRnb2luZ1wiKTtcclxuICAgICAgICAgICAgICAgICAgICBpbmRleCA9IHpyVXRpbC5pbmRleE9mKHN0YXJ0Tm9kZU91dGdvaW5nLCB0aGlzLmNvbm5lY3RvcnNbaV0ucmVzb3VyY2VJZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoaW5kZXggIT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnROb2RlT3V0Z29pbmcuc3BsaWNlKGluZGV4LDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAvLzIu5LuOX3py5LiK5Yig6ZmkXHJcbiAgICAgICAgICAgICAgICAgICAgX3pyLnJlbW92ZSh0aGlzLmNvbm5lY3RvcnNbaV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdG9ycy5zcGxpY2UoaSwgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaS0tO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsQ29ubmVjdG9yID0gbnVsbDtcclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIOWIoOmZpOmAieWumueahOe6v1xyXG4gICAgICAgICAqIEByZXR1cm4ge1t0eXBlXX0gW2Rlc2NyaXB0aW9uXVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGRlbGV0ZUxpbmU6ZnVuY3Rpb24oX3pyKXtcclxuICAgICAgICAgICAgLy8xLuWwhue6vyDmiYDogZTnmoRzdGFydE5vZGXnmoRvdXRnb2luZ+aVsOaNruWIoOmZpFxyXG4gICAgICAgICAgICB2YXIgc3RhcnROb2RlT3V0Z29pbmcgPSB0aGlzLnNlbENvbm5lY3Rvci5zdGFydE5vZGUubW9kZWwuZ2V0KFwib3V0Z29pbmdcIik7XHJcbiAgICAgICAgICAgIGluZGV4ID0genJVdGlsLmluZGV4T2Yoc3RhcnROb2RlT3V0Z29pbmcsIHRoaXMuc2VsQ29ubmVjdG9yLnJlc291cmNlSWQpO1xyXG4gICAgICAgICAgICBpZihpbmRleCAhPSAtMSkge1xyXG4gICAgICAgICAgICAgICAgc3RhcnROb2RlT3V0Z29pbmcuc3BsaWNlKGluZGV4LDEpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAodGhpcy5jb25uZWN0b3JNYXApIHtcclxuICAgICAgICAgICAgICAgIHZhciBrZXkgPSB0aGlzLmdldFR3b05vZGVJZCh0aGlzLnNlbENvbm5lY3Rvci5zdGFydE5vZGUsIHRoaXMuc2VsQ29ubmVjdG9yLmVuZE5vZGUpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jb25uZWN0b3JNYXAucmVtb3ZlSXRlbShrZXksIHRoaXMuc2VsQ29ubmVjdG9yKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8yLuS7jl96cuS4iuWIoOmZpFxyXG4gICAgICAgICAgICBfenIucmVtb3ZlKHRoaXMuc2VsQ29ubmVjdG9yKTtcclxuXHJcblxyXG4gICAgICAgICAgICAvLzMu5LuO57q/5pWw5o2u5Lit5Yig6ZmkXHJcbiAgICAgICAgICAgIHZhciBpbmRleCA9IHpyVXRpbC5pbmRleE9mKHRoaXMuY29ubmVjdG9ycywgdGhpcy5zZWxDb25uZWN0b3IpO1xyXG4gICAgICAgICAgICBpZihpbmRleCAhPSAtMSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jb25uZWN0b3JzLnNwbGljZShpbmRleCwxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnNlbENvbm5lY3RvciA9IG51bGw7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiDph43mlrDnlLvnur9cclxuICAgICAgICAgKiBAcGFyYW0gIHtbdHlwZV19IGNvbm5lY3RvciAgICAgICAgICBbZGVzY3JpcHRpb25dXHJcbiAgICAgICAgICogQHBhcmFtICB7W3R5cGVdfSBmb3JjZVxyXG4gICAgICAgICAqIEByZXR1cm4ge1t0eXBlXX0gICAgICAgICAgICAgICAgICAgIFtkZXNjcmlwdGlvbl1cclxuICAgICAgICAgKi9cclxuICAgICAgICByZWZyZXNoQ29ubmVjdG9yOiBmdW5jdGlvbiAoY29ubmVjdG9yLCBmb3JjZSkge1xyXG4gICAgICAgICAgICAvLyDlj6rmnInpnIDopoHlvLrliLbliLfmlrAgIOaIluiAhSDov57nur/kuLrnqbrvvIg8Minml7Yg5omN6L+b6KGM6YeN5paw6K6h566X6YeN57uYXHJcbiAgICAgICAgICAgIGlmKCBmb3JjZSB8fCAoIWNvbm5lY3Rvci50dXJuaW5nUG9pbnRzKSB8fCAoY29ubmVjdG9yLnR1cm5pbmdQb2ludHMubGVuZ3RoIDwgMikpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGlmIChjb25uZWN0b3IubW9kZWwgJiYgY29ubmVjdG9yLm1vZGVsLmdldChcInN0eWxlLmxpbmVUeXBlXCIpKSB7IGNvbm5lY3Rvci5vcHRpb25zLnN0eWxlLmxpbmVUeXBlID0gY29ubmVjdG9yLm1vZGVsLmdldChcInN0eWxlLmxpbmVUeXBlXCIpO31cclxuICAgICAgICAgICAgICAgIHZhciBhcnJTdGFydEVuZFBvaW50ID0gdGhpcy5nZXRTdGFydEVuZFBvaW50KGNvbm5lY3Rvcik7XHJcbiAgICAgICAgICAgICAgICB2YXIgZXNjYXBlRGlzdGFuY2UgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgaWYoY29ubmVjdG9yLm9wdGlvbnMucG9zaXRpb24mJmNvbm5lY3Rvci5vcHRpb25zLnBvc2l0aW9uLmVzY2FwZURpc3RhbmNlKXtcclxuICAgICAgICAgICAgICAgICAgICBlc2NhcGVEaXN0YW5jZSA9IGNvbm5lY3Rvci5vcHRpb25zLnBvc2l0aW9uLmVzY2FwZURpc3RhbmNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIHNvbHV0aW9ucyA9IHRoaXMuY29ubmVjdG9yMlBvaW50cyhjb25uZWN0b3Iub3B0aW9ucy5zdHlsZS5saW5lVHlwZSwgYXJyU3RhcnRFbmRQb2ludFswXSwgYXJyU3RhcnRFbmRQb2ludFsxXSxcclxuICAgICAgICAgICAgICAgICAgICBhcnJTdGFydEVuZFBvaW50WzJdLCBhcnJTdGFydEVuZFBvaW50WzNdLGVzY2FwZURpc3RhbmNlKTsgIC8vIFRZUEVfU1RSQUlHSFQgVFlQRV9KQUdHRURcclxuXHJcblxyXG4gICAgICAgICAgICAgICAgY29ubmVjdG9yLnJlZnJlc2goc29sdXRpb25zWzBdWzJdKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgY29ubmVjdG9yLmNsZWFySGFuZGxlcygpOyAgLy/muIXnqbpoYW5kbGVcclxuICAgICAgICB9LFxyXG5cclxuXHJcbiAgICAgICAgZ2V0U3RhcnRFbmRQb2ludDogZnVuY3Rpb24oY29ubmVjdG9yKSB7XHJcbiAgICAgICAgICAgIHZhciBzdGFydE5vZGUgPSBjb25uZWN0b3Iuc3RhcnROb2RlO1xyXG4gICAgICAgICAgICB2YXIgZW5kTm9kZSA9IGNvbm5lY3Rvci5lbmROb2RlO1xyXG5cclxuICAgICAgICAgICAgdmFyIHNSZWN0ID0gc3RhcnROb2RlLmdldFJlY3Q/IHN0YXJ0Tm9kZS5nZXRSZWN0KCkuYm91bmRpbmdSZWN0IDogVXRpbC5nZXRSZWN0KHN0YXJ0Tm9kZSkuYm91bmRpbmdSZWN0O1xyXG4gICAgICAgICAgICB2YXIgc0JvdW5kcyA9IFtOdW1iZXIoc1JlY3QueCksIE51bWJlcihzUmVjdC55KSwgTnVtYmVyKHNSZWN0LngpICsgTnVtYmVyKHNSZWN0LndpZHRoKSwgTnVtYmVyKHNSZWN0LnkpICsgTnVtYmVyKHNSZWN0LmhlaWdodCldO1xyXG5cclxuICAgICAgICAgICAgdmFyIGVSZWN0ID0gc3RhcnROb2RlLmdldFJlY3Q/IGVuZE5vZGUuZ2V0UmVjdCgpLmJvdW5kaW5nUmVjdCA6IFV0aWwuZ2V0UmVjdChlbmROb2RlKS5ib3VuZGluZ1JlY3Q7XHJcbiAgICAgICAgICAgIHZhciBlQm91bmRzID0gW051bWJlcihlUmVjdC54KSwgTnVtYmVyKGVSZWN0LnkpLCBOdW1iZXIoZVJlY3QueCkgKyBOdW1iZXIoZVJlY3Qud2lkdGgpLCBOdW1iZXIoZVJlY3QueSkgKyBOdW1iZXIoZVJlY3QuaGVpZ2h0KV07XHJcblxyXG5cclxuICAgICAgICAgICAgdmFyIHNDb25uZWN0b3JQb2ludCA9IFV0aWwuZ2V0Q29ubmVjdG9yUG9pbnRzKHNSZWN0KTtcclxuICAgICAgICAgICAgdmFyIGVDb25uZWN0b3JQb2ludCA9IFV0aWwuZ2V0Q29ubmVjdG9yUG9pbnRzKGVSZWN0KTtcclxuXHJcbiAgICAgICAgICAgIC8v5Yik5pat5aaC5p6c5rKh5pyJ5oyH5a6a5L2N572u55qE6K+dLCDliKTmlq3lvIDlp4voioLngrnlnKjnu5PmnZ/nu5Pmnpzlt6bovrnliJnph4fnlKggcmlnaHQtbGVmdCDlkKbliJnph4fnlKhsZWZ0LXJpZ2h0XHJcbiAgICAgICAgICAgIGlmICghY29ubmVjdG9yLnNQb3MgfHwgIWNvbm5lY3Rvci5lUG9zKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoc1JlY3QueCA8IGVSZWN0LngpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25uZWN0b3Iuc1BvcyA9IFwicmlnaHRcIjtcclxuICAgICAgICAgICAgICAgICAgICBjb25uZWN0b3IuZVBvcyA9IFwibGVmdFwiO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25uZWN0b3Iuc1BvcyA9IFwibGVmdFwiO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbm5lY3Rvci5lUG9zID0gXCJyaWdodFwiO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBzdGFydFBvaW50ID0gIHRoaXMuY2FsY1BvaW50RXhwcmVzc2lvbihjb25uZWN0b3Iuc1Bvcywgc0Nvbm5lY3RvclBvaW50KTtcclxuICAgICAgICAgICAgdmFyIGVuZFBvaW50ID0gIHRoaXMuY2FsY1BvaW50RXhwcmVzc2lvbihjb25uZWN0b3IuZVBvcywgZUNvbm5lY3RvclBvaW50KTtcclxuICAgICAgICAgICAgcmV0dXJuIFtzdGFydFBvaW50LCBlbmRQb2ludCxzQm91bmRzLCBlQm91bmRzXTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBjYWxjUG9pbnRFeHByZXNzaW9uOiBmdW5jdGlvbihwb3MsIHBvaW50KSB7XHJcbiAgICAgICAgICAgIHZhciB2YXJpYWJsZSA9IHt0b3A6cG9pbnQudG9wLngsXHJcbiAgICAgICAgICAgICAgICBsZWZ0OiBwb2ludC5sZWZ0LnksXHJcbiAgICAgICAgICAgICAgICByaWdodDpwb2ludC5yaWdodC55LFxyXG4gICAgICAgICAgICAgICAgYm90dG9tOnBvaW50LmJvdHRvbS54LFxyXG4gICAgICAgICAgICAgICAgY2VudGVyOnBvaW50LmNlbnRlci54XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICB2YXIgZXhwcmVzc2lvbiA9ICBcIjwlIHByaW50KFwiICsgcG9zICsgXCIpICU+XCI7XHJcbiAgICAgICAgICAgIHZhciB2YWwgPSBwYXJzZUludChVdGlsLnRlbXBsYXRlKGV4cHJlc3Npb24pKHZhcmlhYmxlKSk7XHJcbiAgICAgICAgICAgIGlmIChwb3MuaW5kZXhPZihcInRvcFwiKSE9IC0xKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFBvaW50KHZhbCwgcG9pbnQudG9wLnkpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHBvcy5pbmRleE9mKFwibGVmdFwiKSE9IC0xKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFBvaW50KHBvaW50LmxlZnQueCwgdmFsKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChwb3MuaW5kZXhPZihcInJpZ2h0XCIpIT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQocG9pbnQucmlnaHQueCwgdmFsKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChwb3MuaW5kZXhPZihcImJvdHRvbVwiKSE9IC0xKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFBvaW50KHZhbCwgcG9pbnQuYm90dG9tLnkpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHBvcy5pbmRleE9mKFwiY2VudGVyXCIpIT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQodmFsLCBwb2ludC5ib3R0b20ueSk7XHJcbiAgICAgICAgICAgIH1lbHNlIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInBvc+WPguaVsOmUmeivr1wiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIOWIm+W7uuaIluS/ruaUueS4tOaXtue6v1xyXG4gICAgICAgICAqIEBwYXJhbSAge1t0eXBlXX0gc3RhcnROb2RlICAgICAgICAgICAgIFtkZXNjcmlwdGlvbl1cclxuICAgICAgICAgKiBAcGFyYW0gIHtbdHlwZV19IHJFbmRQb2ludCAgICAgICAgICAgICBbZGVzY3JpcHRpb25dXHJcbiAgICAgICAgICogQHBhcmFtICB7W3R5cGVdfSBsaW5lVHlwZSBbZGVzY3JpcHRpb25dXHJcbiAgICAgICAgICogQHJldHVybiB7W3R5cGVdfSAgICAgICAgICAgICAgICAgICAgICAgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIG1hbmFnZVRlbXBDb25uZWN0b3I6IGZ1bmN0aW9uKHN0YXJ0Tm9kZSwgckVuZFBvaW50LCBsaW5lVHlwZSkge1xyXG5cclxuICAgICAgICAgICAgdmFyIHNSZWN0ID0gc3RhcnROb2RlLmdldFJlY3Q/IHN0YXJ0Tm9kZS5nZXRSZWN0KCkuYm91bmRpbmdSZWN0IDogVXRpbC5nZXRSZWN0KHN0YXJ0Tm9kZSkuYm91bmRpbmdSZWN0O1xyXG5cclxuICAgICAgICAgICAgdmFyIHNCb3VuZHMgPSBbc1JlY3QueCwgc1JlY3QueSwgc1JlY3QueCArIHNSZWN0LndpZHRoLCBzUmVjdC55ICsgc1JlY3QuaGVpZ2h0XTtcclxuICAgICAgICAgICAgdmFyIHNDb25uZWN0b3JQb2ludCA9IFV0aWwuZ2V0Q29ubmVjdG9yUG9pbnRzKHNSZWN0KTtcclxuXHJcbiAgICAgICAgICAgIGlmICghQ29ubmVjdGlvbk1hbmFnZXIudGVtcENvbm5lY3Rvcikge1xyXG4gICAgICAgICAgICAgICAgQ29ubmVjdGlvbk1hbmFnZXIudGVtcENvbm5lY3RvciA9IG5ldyBDb25uZWN0b3Ioe2lzRWRpdDogZmFsc2UsIHN0eWxlOiB7bGluZVR5cGU6bGluZVR5cGV9fSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBjb25uZWN0b3IgPSAgQ29ubmVjdGlvbk1hbmFnZXIudGVtcENvbm5lY3RvcjtcclxuICAgICAgICAgICAgLy/liKTmlq3lpoLmnpzmsqHmnInmjIflrprkvY3nva7nmoTor50sIOWIpOaWreW8gOWni+iKgueCueWcqOe7k+adn+e7k+aenOW3pui+ueWImemHh+eUqCByaWdodC1sZWZ0IOWQpuWImemHh+eUqGxlZnQtcmlnaHRcclxuICAgICAgICAgICAgaWYgKHNSZWN0LnggPCByRW5kUG9pbnQueCkge1xyXG4gICAgICAgICAgICAgICAgY29ubmVjdG9yLnNQb3MgPSBcInJpZ2h0XCI7XHJcbiAgICAgICAgICAgICAgICBjb25uZWN0b3IuZVBvcyA9IFwibGVmdFwiO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29ubmVjdG9yLnNQb3MgPSBcImxlZnRcIjtcclxuICAgICAgICAgICAgICAgIGNvbm5lY3Rvci5lUG9zID0gXCJyaWdodFwiO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBjb25uZWN0b3Iub3B0aW9ucy5zdHlsZS5saW5lVHlwZSA9IGxpbmVUeXBlO1xyXG4gICAgICAgICAgICB2YXIgc29sdXRpb25zID0gdGhpcy5jb25uZWN0b3IyUG9pbnRzKGxpbmVUeXBlLCBzQ29ubmVjdG9yUG9pbnRbY29ubmVjdG9yLnNQb3NdLCByRW5kUG9pbnQsXHJcbiAgICAgICAgICAgICAgICBzQm91bmRzLCBudWxsKTsgIC8vIFRZUEVfU1RSQUlHSFQgVFlQRV9KQUdHRURcclxuXHJcbiAgICAgICAgICAgIGNvbm5lY3Rvci5yZWZyZXNoKHNvbHV0aW9uc1swXVsyXSk7XHJcbiAgICAgICAgICAgIHJldHVybiBjb25uZWN0b3I7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICog5Yig6Zmk5Li05pe257q/XHJcbiAgICAgICAgICogQHBhcmFtICB7W3R5cGVdfSB6ciAgICAgICAgICAgICBbZGVzY3JpcHRpb25dXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgcmVtb3ZlVGVtcENvbm5lY3RvcjogZnVuY3Rpb24oenIpIHtcclxuICAgICAgICAgICAgaWYgKENvbm5lY3Rpb25NYW5hZ2VyLnRlbXBDb25uZWN0b3IpIHtcclxuICAgICAgICAgICAgICAgIHpyLnJlbW92ZShDb25uZWN0aW9uTWFuYWdlci50ZW1wQ29ubmVjdG9yKTtcclxuICAgICAgICAgICAgICAgIENvbm5lY3Rpb25NYW5hZ2VyLnRlbXBDb25uZWN0b3IgPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIOeul+WHuiDkuKTkuKroioLngrkg5oyH5a6a5Lik5Liq54K55aaC5L2V6IGU57q/XHJcbiAgICAgICAgICogQHBhcmFtICB7W3R5cGVdfSB0eXBlICAgICAgIFtkZXNjcmlwdGlvbl1cclxuICAgICAgICAgKiBAcGFyYW0gIHtbdHlwZV19IHN0YXJ0UG9pbnQgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICAgICAqIEBwYXJhbSAge1t0eXBlXX0gZW5kUG9pbnQgICBbZGVzY3JpcHRpb25dXHJcbiAgICAgICAgICogQHBhcmFtICB7W3R5cGVdfSBzQm91bmRzICAgIFtkZXNjcmlwdGlvbl1cclxuICAgICAgICAgKiBAcGFyYW0gIHtbdHlwZV19IGVCb3VuZHMgICAgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICAgICAqIEByZXR1cm4ge1t0eXBlXX0gICAgICAgICAgICBbZGVzY3JpcHRpb25dXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgY29ubmVjdG9yMlBvaW50czogZnVuY3Rpb24odHlwZSwgIHN0YXJ0UG9pbnQsIGVuZFBvaW50LCBzQm91bmRzLCBlQm91bmRzICxlc2NhcGVEaXN0YW5jZSl7XHJcbiAgICAgICAgICAgIHZhciAgZmlndXJlRXNjYXBlRGlzdGFuY2UgPSBbMzAsIDMwXTtcclxuICAgICAgICAgICAgaWYgKGVzY2FwZURpc3RhbmNlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXpyVXRpbC5pc0FycmF5KGVzY2FwZURpc3RhbmNlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGZpZ3VyZUVzY2FwZURpc3RhbmNlID0gW2VzY2FwZURpc3RhbmNlLCBlc2NhcGVEaXN0YW5jZV07XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGZpZ3VyZUVzY2FwZURpc3RhbmNlID0gZXNjYXBlRGlzdGFuY2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIExvZy5ncm91cChcImNvbm5lY3Rpb25NYW5hZ2VyOiBjb25uZWN0b3IyUG9pbnRzXCIpO1xyXG5cclxuXHJcbiAgICAgICAgICAgIExvZy5pbmZvKFwiQ29ubmVjdGlvbk1hbmFnZXI6IGNvbm5lY3RvcjJQb2ludHMgKFwiICsgdHlwZSArIFwiLCBcIiArIHN0YXJ0UG9pbnQgKyBcIiwgXCIgKyBlbmRQb2ludCArIFwiLCBcIiArIHNCb3VuZHMgKyBcIiwgXCIgKyBlQm91bmRzICsgJyknKTtcclxuICAgICAgICAgICAgdmFyIHNvbHV0aW9ucyA9IFtdO1xyXG5cclxuXHJcblxyXG4gICAgICAgICAgICBzd2l0Y2godHlwZSl7XHJcbiAgICAgICAgICAgICAgICBjYXNlIENvbm5lY3Rvci5UWVBFX1NUUkFJR0hUOiAgLy/nm7Tnur9cclxuICAgICAgICAgICAgICAgICAgICB2YXIgcG9pbnRzID0gW3N0YXJ0UG9pbnQuY2xvbmUoKSwgZW5kUG9pbnQuY2xvbmUoKV07XHJcbiAgICAgICAgICAgICAgICAgICAgc29sdXRpb25zLnB1c2goIFsnc3RyYWlnaHQnLCAnc3RyYWlnaHQnLCBwb2ludHNdICk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgY2FzZSBDb25uZWN0b3IuVFlQRV9DVVJWRTogIC8v5puy57q/XHJcblxyXG4gICAgICAgICAgICAgICAgY2FzZSBDb25uZWN0b3IuVFlQRV9KQUdHRUQ6ICAgIC8v5oqY57q/XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXJ0RXhpdFBvaW50ID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZW5kRXhpdFBvaW50ID0gbnVsbDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9maW5kIHN0YXJ0IGV4aXQgcG9pbnQgIOWvu+aJvuW8gOWni+WHuuWPo1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKHNCb3VuZHMgIT0gbnVsbCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwb3RlbnRpYWxFeGl0cyA9IFtdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgcG90ZW50aWFsRXhpdHMucHVzaChuZXcgUG9pbnQoc3RhcnRQb2ludC54LCBzQm91bmRzWzFdIC0gZmlndXJlRXNjYXBlRGlzdGFuY2VbMF0pKTsgLy9ub3J0aCDljJdcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG90ZW50aWFsRXhpdHMucHVzaChuZXcgUG9pbnQoc0JvdW5kc1syXSArIGZpZ3VyZUVzY2FwZURpc3RhbmNlWzBdLCBzdGFydFBvaW50LnkpKTsgLy9lYXN0ICDkuJxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG90ZW50aWFsRXhpdHMucHVzaChuZXcgUG9pbnQoc3RhcnRQb2ludC54LCBzQm91bmRzWzNdICsgZmlndXJlRXNjYXBlRGlzdGFuY2VbMF0pKTsgLy9zb3V0aCAg5Y2XXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvdGVudGlhbEV4aXRzLnB1c2gobmV3IFBvaW50KHNCb3VuZHNbMF0gLSBmaWd1cmVFc2NhcGVEaXN0YW5jZVswXSwgc3RhcnRQb2ludC55KSk7IC8vd2VzdCAg6KW/XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL3BpY2sgY2xvc2VzdCBleGl0IHBvaW50ICDlr7vmib7kuI4gc3RhcnRQb2ludCDmnIDpnaDov5HnmoTlh7rlj6PngrlcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRFeGl0UG9pbnQgPSBwb3RlbnRpYWxFeGl0c1swXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yKHZhciBpPTE7IGkgPCBwb3RlbnRpYWxFeGl0cy5sZW5ndGg7IGkrKyl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihVdGlsLmRpc3RhbmNlKHN0YXJ0UG9pbnQsIHBvdGVudGlhbEV4aXRzW2ldKSA8IFV0aWwuZGlzdGFuY2Uoc3RhcnRQb2ludCwgc3RhcnRFeGl0UG9pbnQpKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydEV4aXRQb2ludCA9IHBvdGVudGlhbEV4aXRzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9maW5kIGVuZCBleGl0IHBvaW50ICDlr7vmib7nu5PmnZ/lh7rlj6NcclxuICAgICAgICAgICAgICAgICAgICBpZihlQm91bmRzICE9IG51bGwpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcG90ZW50aWFsRXhpdHMgPSBbXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvdGVudGlhbEV4aXRzLnB1c2gobmV3IFBvaW50KGVuZFBvaW50LngsIGVCb3VuZHNbMV0gLSBmaWd1cmVFc2NhcGVEaXN0YW5jZVsxXSkpOyAvL25vcnRoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvdGVudGlhbEV4aXRzLnB1c2gobmV3IFBvaW50KGVCb3VuZHNbMl0gKyBmaWd1cmVFc2NhcGVEaXN0YW5jZVsxXSwgZW5kUG9pbnQueSkpOyAvL2Vhc3RcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG90ZW50aWFsRXhpdHMucHVzaChuZXcgUG9pbnQoZW5kUG9pbnQueCwgZUJvdW5kc1szXSArIGZpZ3VyZUVzY2FwZURpc3RhbmNlWzFdKSk7IC8vc291dGhcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG90ZW50aWFsRXhpdHMucHVzaChuZXcgUG9pbnQoZUJvdW5kc1swXSAtIGZpZ3VyZUVzY2FwZURpc3RhbmNlWzFdLCBlbmRQb2ludC55KSk7IC8vd2VzdFxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9waWNrIGNsb3Nlc3QgZXhpdCBwb2ludCAg5a+75om+5LiOIGVuZFBvaW50IOacgOmdoOi/keeahOWHuuWPo+eCuVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmRFeGl0UG9pbnQgPSBwb3RlbnRpYWxFeGl0c1swXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yKHZhciBpPTE7IGkgPCBwb3RlbnRpYWxFeGl0cy5sZW5ndGg7IGkrKyl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihVdGlsLmRpc3RhbmNlKGVuZFBvaW50LCBwb3RlbnRpYWxFeGl0c1tpXSkgPCBVdGlsLmRpc3RhbmNlKGVuZFBvaW50LCBlbmRFeGl0UG9pbnQpKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmRFeGl0UG9pbnQgPSBwb3RlbnRpYWxFeGl0c1tpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9CYXNpYyBzb2x1dGlvbiDmnIDln7rmnKznmoTop6PlhrPmlrnmoYggICDkuLrlhbbku5bop6PlhrPmlrnmoYjlgZrlh4blpIdcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcyA9IFtzdGFydFBvaW50XTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZ2FwSW5kZXggPSAwOyAvL3RoZSBpbmRleCBvZiB0aGUgZ2FwICh3aGVyZSBkbyB3ZSBuZWVkIHRvIGluc2VydCBuZXcgcG9pbnRzKSBETyBOT1QgQ0hBTkdFIElUXHJcbiAgICAgICAgICAgICAgICAgICAgaWYoc3RhcnRFeGl0UG9pbnQpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzLnB1c2goc3RhcnRFeGl0UG9pbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBnYXBJbmRleCA9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmKGVuZEV4aXRQb2ludCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHMucHVzaChlbmRFeGl0UG9pbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBzLnB1c2goZW5kUG9pbnQpO1xyXG5cclxuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vU08gLSBubyBhZGRpdGlvbmFsIHBvaW50cyAgICAgUzAg6Kej5Yaz5pa55qGIIOS4jea3u+WKoOS7u+S9leeCuSAg5Z+65pys5LiN5Lya6KKr6YeH55SoXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHMwID0gUG9pbnQuY2xvbmVBcnJheShzKTtcclxuICAgICAgICAgICAgICAgICAgICBzb2x1dGlvbnMucHVzaChbJ3MwJywgJ3MwJywgczBdKTtcclxuXHJcblxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL1MxICAgUzEg6Kej5Yaz5pa55qGIICDlj6rmnInkuIDkuKrmipjngrlcclxuICAgICAgICAgICAgICAgICAgICB2YXIgczEgPSBQb2ludC5jbG9uZUFycmF5KHMpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL2ZpcnN0IHZhcmlhbnQgICDnrKzkuIDkuKrlj5jkvZMgczEgczFfMeaWueahiCAg5oqY57q/54K55ZyoIHN0YXJ0RXhpdFBvaW5055qEWCDkuI4gZW5kRXhpdFBvaW5055qEIFnkvY3nva5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgczFfMSA9IFBvaW50LmNsb25lQXJyYXkoczEpO1xyXG4gICAgICAgICAgICAgICAgICAgIHMxXzEuc3BsaWNlKGdhcEluZGV4ICsgMSwgMCwgbmV3IFBvaW50KHMxXzFbZ2FwSW5kZXhdLnggLCBzMV8xW2dhcEluZGV4KzFdLnkpICk7XHJcbiAgICAgICAgICAgICAgICAgICAgc29sdXRpb25zLnB1c2goWydzMScsICdzMV8xJywgczFfMV0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL3NlY29uZCB2YXJpYW50ICDnrKzkuozlj5jkvZMgczEgczEtMuaWueahiCAg5oqY57q/54K55ZyoIGVuZEV4aXRQb2ludOeahFgg5LiOICBzdGFydEV4aXRQb2ludOeahFnkvY3nva5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgczFfMiA9IFBvaW50LmNsb25lQXJyYXkoczEpO1xyXG4gICAgICAgICAgICAgICAgICAgIHMxXzIuc3BsaWNlKGdhcEluZGV4ICsgMSwgMCwgbmV3IFBvaW50KHMxXzJbZ2FwSW5kZXgrMV0ueCAsIHMxXzJbZ2FwSW5kZXhdLnkpICk7XHJcbiAgICAgICAgICAgICAgICAgICAgc29sdXRpb25zLnB1c2goWydzMScsICdzMV8yJywgczFfMl0pO1xyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9TMiAgUzIg6Kej5Yaz5pa55qGIICDmt7vliqDkuKTkuKrmipjngrlcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9WYXJpYW50IEkgICBzMl8x5pa55qGIXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHMyXzEgPSBQb2ludC5jbG9uZUFycmF5KHMpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzMl8xXzEgPSBuZXcgUG9pbnQoIChzMl8xW2dhcEluZGV4XS54ICsgczJfMVtnYXBJbmRleCsxXS54KSAvIDIsICBzMl8xW2dhcEluZGV4XS55KTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgczJfMV8yID0gbmV3IFBvaW50KCAoczJfMVtnYXBJbmRleF0ueCArIHMyXzFbZ2FwSW5kZXgrMV0ueCkgLyAyLCAgczJfMVtnYXBJbmRleCsxXS55KTtcclxuICAgICAgICAgICAgICAgICAgICBzMl8xLnNwbGljZShnYXBJbmRleCArIDEsIDAsIHMyXzFfMSwgczJfMV8yKTtcclxuICAgICAgICAgICAgICAgICAgICBzb2x1dGlvbnMucHVzaChbJ3MyJywgJ3MyXzEnLCBzMl8xXSk7XHJcblxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL1ZhcmlhbnQgSUkgIHMyXzHmlrnmoYggIDHmipjnur/ngrkgeDogc3RhcnRFeGl0UG9pbnTnmoRYIOS9jee9riB5OiBzdGFydEV4aXRQb2ludOeahHkrZW5kRXhpdFBvaW5055qEeS8yXHJcbiAgICAgICAgICAgICAgICAgICAgLy8x5oqY57q/54K5IHg6ZW5kRXhpdFBvaW5055qEeCAgeTpzdGFydEV4aXRQb2ludOeahHkrZW5kRXhpdFBvaW5055qEeS8yXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHMyXzIgPSBQb2ludC5jbG9uZUFycmF5KHMpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzMl8yXzEgPSBuZXcgUG9pbnQoIHMyXzJbZ2FwSW5kZXhdLngsIChzMl8yW2dhcEluZGV4XS55ICsgczJfMltnYXBJbmRleCsxXS55KS8yICk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHMyXzJfMiA9IG5ldyBQb2ludCggczJfMltnYXBJbmRleCsxXS54LCAoczJfMltnYXBJbmRleF0ueSArIHMyXzJbZ2FwSW5kZXgrMV0ueSkvMik7XHJcbiAgICAgICAgICAgICAgICAgICAgczJfMi5zcGxpY2UoZ2FwSW5kZXggKyAxLCAwLCBzMl8yXzEsIHMyXzJfMik7XHJcbiAgICAgICAgICAgICAgICAgICAgc29sdXRpb25zLnB1c2goWydzMicsICdzMl8yJywgczJfMl0pO1xyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9WYXJpYW50IElJSVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzMl8zID0gUG9pbnQuY2xvbmVBcnJheShzKTtcclxuICAgICAgICAgICAgICAgICAgICAvL2ZpbmQgdGhlIGFtb3VudCAoc3RvcmVkIGluIGRlbHRhKSBvZiBwaXhlbHMgd2UgbmVlZCB0byBtb3ZlIHJpZ2h0IHNvIG5vIGludGVyc2VjdGlvbiB3aXRoIGEgZmlndXJlIHdpbGwgYmUgcHJlc2VudFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIVNlZTogIC9kb2N1bWVudHMvc3BlY3MvY29ubmVjdGVkX2ZpZ3VyZXNfZGVsdGFzLmpwZyBmaWxlXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBlYXN0RXhpdHMgPSBbczJfM1tnYXBJbmRleF0ueCArIDIwLCBzMl8zW2dhcEluZGV4KzFdLnggKyAyMF07IC8vYWRkIHBvaW50cyBYIGNvb3JkaW5hdGVzIHRvIGJlIGFibGUgdG8gZ2VuZXJhdGUgVmFyaWFudCBJSUkgZXZlbiBpbiB0aGUgYWJzZW5jZSBvZiBmaWd1cmVzIDpwXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmKHNCb3VuZHMpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlYXN0RXhpdHMucHVzaChzQm91bmRzWzJdICsgMjApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYoZUJvdW5kcyl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVhc3RFeGl0cy5wdXNoKGVCb3VuZHNbMl0gKyAyMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgZWFzdEV4aXQgPSBVdGlsLm1heChlYXN0RXhpdHMpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzMl8zXzEgPSBuZXcgUG9pbnQoIGVhc3RFeGl0LCBzMl8zW2dhcEluZGV4XS55ICk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHMyXzNfMiA9IG5ldyBQb2ludCggZWFzdEV4aXQsIHMyXzNbZ2FwSW5kZXgrMV0ueSApO1xyXG4gICAgICAgICAgICAgICAgICAgIHMyXzMuc3BsaWNlKGdhcEluZGV4ICsgMSwgMCwgczJfM18xLCBzMl8zXzIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHNvbHV0aW9ucy5wdXNoKFsnczInLCAnczJfMycsIHMyXzNdKTtcclxuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vVmFyaWFudCBJViAgczJfNOaWueahiFxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzMl80ID0gUG9pbnQuY2xvbmVBcnJheShzKTtcclxuICAgICAgICAgICAgICAgICAgICAvL2ZpbmQgdGhlIGFtb3VudCAoc3RvcmVkIGluIGRlbHRhKSBvZiBwaXhlbHMgd2UgbmVlZCB0byBtb3ZlIHVwIHNvIG5vIGludGVyc2VjdGlvbiB3aXRoIGEgZmlndXJlIHdpbGwgYmUgcHJlc2VudFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIVNlZTogIC9kb2N1bWVudHMvc3BlY3MvY29ubmVjdGVkX2ZpZ3VyZXNfZGVsdGFzLmpwZyBmaWxlXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBub3J0aEV4aXRzID0gW3MyXzRbZ2FwSW5kZXhdLnkgLSAyMCwgczJfNFtnYXBJbmRleCsxXS55IC0gMjBdOyAvL2FkZCBwb2ludHMgeSBjb29yZGluYXRlcyB0byBiZSBhYmxlIHRvIGdlbmVyYXRlIFZhcmlhbnQgSUlJIGV2ZW4gaW4gdGhlIGFic2VuY2Ugb2YgZmlndXJlcyA6cFxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZihzQm91bmRzKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbm9ydGhFeGl0cy5wdXNoKHNCb3VuZHNbMV0gLSAyMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZihlQm91bmRzKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbm9ydGhFeGl0cy5wdXNoKGVCb3VuZHNbMV0gLSAyMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgbm9ydGhFeGl0ID0gVXRpbC5taW4obm9ydGhFeGl0cyk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHMyXzRfMSA9IG5ldyBQb2ludCggczJfNFtnYXBJbmRleF0ueCwgbm9ydGhFeGl0KTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgczJfNF8yID0gbmV3IFBvaW50KCBzMl80W2dhcEluZGV4KzFdLngsIG5vcnRoRXhpdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgczJfNC5zcGxpY2UoZ2FwSW5kZXggKyAxLCAwLCBzMl80XzEsIHMyXzRfMik7XHJcbiAgICAgICAgICAgICAgICAgICAgc29sdXRpb25zLnB1c2goWydzMicsICdzMl80JywgczJfNF0pO1xyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9WYXJpYW50IFZcclxuICAgICAgICAgICAgICAgICAgICB2YXIgczJfNSA9IFBvaW50LmNsb25lQXJyYXkocyk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9maW5kIHRoZSBhbW91bnQgKHN0b3JlZCBpbiBkZWx0YSkgb2YgcGl4ZWxzIHdlIG5lZWQgdG8gbW92ZSBsZWZ0IHNvIG5vIGludGVyc2VjdGlvbiB3aXRoIGEgZmlndXJlIHdpbGwgYmUgcHJlc2VudFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIVNlZTogIC9kb2N1bWVudHMvc3BlY3MvY29ubmVjdGVkX2ZpZ3VyZXNfZGVsdGFzLmpwZyBmaWxlXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciB3ZXN0RXhpdHMgPSBbczJfNVtnYXBJbmRleF0ueCAtIDIwLCBzMl81W2dhcEluZGV4KzFdLnggLSAyMF07IC8vYWRkIHBvaW50cyB4IGNvb3JkaW5hdGVzIHRvIGJlIGFibGUgdG8gZ2VuZXJhdGUgVmFyaWFudCBJSUkgZXZlbiBpbiB0aGUgYWJzZW5jZSBvZiBmaWd1cmVzIDpwXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmKHNCb3VuZHMpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB3ZXN0RXhpdHMucHVzaChzQm91bmRzWzBdIC0gMjApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYoZUJvdW5kcyl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdlc3RFeGl0cy5wdXNoKGVCb3VuZHNbMF0gLSAyMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgd2VzdEV4aXQgPSBVdGlsLm1pbih3ZXN0RXhpdHMpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzMl81XzEgPSBuZXcgUG9pbnQoIHdlc3RFeGl0LCBzMl81W2dhcEluZGV4XS55KTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgczJfNV8yID0gbmV3IFBvaW50KCB3ZXN0RXhpdCwgczJfNVtnYXBJbmRleCsxXS55KTtcclxuICAgICAgICAgICAgICAgICAgICBzMl81LnNwbGljZShnYXBJbmRleCArIDEsIDAsIHMyXzVfMSwgczJfNV8yKTtcclxuICAgICAgICAgICAgICAgICAgICBzb2x1dGlvbnMucHVzaChbJ3MyJywgJ3MyXzUnLCBzMl81XSk7XHJcblxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL1ZhcmlhbnQgVklcclxuICAgICAgICAgICAgICAgICAgICB2YXIgczJfNiA9IFBvaW50LmNsb25lQXJyYXkocyk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9maW5kIHRoZSBhbW91bnQgKHN0b3JlZCBpbiBkZWx0YSkgb2YgcGl4ZWxzIHdlIG5lZWQgdG8gbW92ZSBkb3duIHNvIG5vIGludGVyc2VjdGlvbiB3aXRoIGEgZmlndXJlIHdpbGwgYmUgcHJlc2VudFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIVNlZTogIC9kb2N1bWVudHMvc3BlY3MvY29ubmVjdGVkX2ZpZ3VyZXNfZGVsdGFzLmpwZyBmaWxlXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzb3V0aEV4aXRzID0gW3MyXzZbZ2FwSW5kZXhdLnkgKyAyMCwgczJfNltnYXBJbmRleCsxXS55ICsgMjBdOyAvL2FkZCBwb2ludHMgeSBjb29yZGluYXRlcyB0byBiZSBhYmxlIHRvIGdlbmVyYXRlIFZhcmlhbnQgSUlJIGV2ZW4gaW4gdGhlIGFic2VuY2Ugb2YgZmlndXJlcyA6cFxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZihzQm91bmRzKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc291dGhFeGl0cy5wdXNoKHNCb3VuZHNbM10gKyAyMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZihlQm91bmRzKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc291dGhFeGl0cy5wdXNoKGVCb3VuZHNbM10gKyAyMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgc291dGhFeGl0ID0gVXRpbC5tYXgoc291dGhFeGl0cyk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHMyXzZfMSA9IG5ldyBQb2ludCggczJfNltnYXBJbmRleF0ueCwgc291dGhFeGl0KTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgczJfNl8yID0gbmV3IFBvaW50KCBzMl82W2dhcEluZGV4KzFdLngsIHNvdXRoRXhpdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgczJfNi5zcGxpY2UoZ2FwSW5kZXggKyAxLCAwLCBzMl82XzEsIHMyXzZfMik7XHJcbiAgICAgICAgICAgICAgICAgICAgc29sdXRpb25zLnB1c2goWydzMicsICdzMl82JywgczJfNl0pO1xyXG5cclxuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vRklMVEVSIHNvbHV0aW9uc1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvKkFsZ29yaXRobVxyXG4gICAgICAgICAgICAgICAgICAgICAqIDAuIHNvbHV0aW9ucyBhcmUgb3JkZXJlZCBmcm9tIG1pbmltbXVuIG5yIG9mIHBvaW50cyB0byBtYXhpbXVtID46KVxyXG4gICAgICAgICAgICAgICAgICAgICAqIDEuIHJlbW92ZSBhbGwgc29sdXRpb25zIHRoYXQgYXJlIG5vdCBvcnRob2dvbmFsIChtYWlubHkgczAgc29sdXRpb24pXHJcbiAgICAgICAgICAgICAgICAgICAgICogMi4gcmVtb3ZlIGFsbCBzb2x1dGlvbnMgdGhhdCBnbyBiYWNrd2FyZCAod2Ugd2lsbCBub3QgbmVlZCB0aGVtIGV2ZXIpXHJcbiAgICAgICAgICAgICAgICAgICAgICogMy4gcmVtb3ZlIGFsbCBzb2x1dGlvbnMgd2l0aCBpbnRlcnNlY3Rpb25zXHJcbiAgICAgICAgICAgICAgICAgICAgICogNC4gcGljayBmaXJzdCBjbGFzcyBvZiBzb2x1dGlvbnMgd2l0aCBzYW1lIG5yIG9mIHBvaW50cyAoZXg6IDIpXHJcbiAgICAgICAgICAgICAgICAgICAgICogNS4gcGljayB0aGUgZmlyc3Qgc29sdXRpb24gd2l0aCA5MCBkZWdyZWUgYW5nbGVzIChsZXNzIHR1cm5hcm91bmRzKVxyXG4gICAgICAgICAgICAgICAgICAgICAqIChub3QgaW50ZXJlc3RldGVkKSBzb3J0IGJ5IGxlbmd0aCA6cFxyXG4gICAgICAgICAgICAgICAgICAgICAqL1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLzEuIGZpbHRlciBub24gb3J0b2dvbmFsIHNvbHV0aW9ucyDliKDpmaTkuI3mmK/mraPkuqTnm7Tnur/nmoTmlrnmoYhcclxuICAgICAgICAgICAgICAgICAgICBpZih0cnVlKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgTG9nLmluZm8oXCJGaWx0ZXIgb3J0aG9nb25hbCBzb2x1dGlvbnMuIEluaXRpYWwgbnVtYmVyIG9mIHNvbHV0aW9ucyA9IFwiICsgc29sdXRpb25zLmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvcnRob2dvbmFsU29sdXRpb24gPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yKHZhciBsPTA7IGw8c29sdXRpb25zLmxlbmd0aDsgbCsrKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzb2x1dGlvbiA9IHNvbHV0aW9uc1tsXVsyXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKFV0aWwub3J0aG9nb25hbFBhdGgoc29sdXRpb24pKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcnRob2dvbmFsU29sdXRpb24ucHVzaChzb2x1dGlvbnNbbF0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvbHV0aW9ucyA9IG9ydGhvZ29uYWxTb2x1dGlvbjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgTG9nLmluZm8oXCJcXG5cXHRPcnRob2dvbmFsU29sdXRpb25zID0gXCIgKyBzb2x1dGlvbnMubGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vMi4gZmlsdGVyIGJhY2t3YXJkIHNvbHV0aW9ucyAg6L+H5rukIOWAkumAgOeahOaWueahiFxyXG4gICAgICAgICAgICAgICAgICAgIGlmKHRydWUpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2RvIG5vdCBhbGxvdyBzdGFydCBhbmQgZW5kIHBvaW50cyB0byBjb2luY2lkZSAtIGlnbm9yZSB0aGVtXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHN0YXJ0UG9pbnQuZXF1YWxzKGVuZFBvaW50KSl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBMb2cuaW5mbyhcIlN0YXJ0IGFuZCBlbmQgcG9pbnQgY29pbmNpZGUuLi5za2lwIGJhY2t3YXJkIHNvbHV0aW9uLiBJIHRoaW5rIHdlIHdpbGwganVzdCBmYWxsIG9uIHMwIDopXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2V7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBMb2cuaW5mbyhcIkZpbHRlciBiYWNrd2FyZCBzb2x1dGlvbnMuIEluaXRpYWwgbnVtYmVyIG9mIHNvbHV0aW9ucyA9IFwiICsgc29sdXRpb25zLmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZm9yd2FyZFNvbHV0aW9ucyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRlbXAgPSAnJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcih2YXIgbD0wOyBsPHNvbHV0aW9ucy5sZW5ndGg7IGwrKyl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNvbHV0aW9uID0gc29sdXRpb25zW2xdWzJdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKFV0aWwuZm9yd2FyZFBhdGgoc29sdXRpb24pKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yd2FyZFNvbHV0aW9ucy5wdXNoKHNvbHV0aW9uc1tsXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2V7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlbXAgPSB0ZW1wICsgIFwiXFxuXFx0XCIgKyBzb2x1dGlvbjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb2x1dGlvbnMgPSBmb3J3YXJkU29sdXRpb25zO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgTG9nLmluZm8oXCJcXG5cXHQgRm9yd2FyZFNvbHV0aW9ucyA9IFwiICsgc29sdXRpb25zLmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihzb2x1dGlvbnMubGVuZ3RoID09IDApe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIExvZy5pbmZvKFwiRGlzY2FyZGVkIHNvbHV0aW9uczogXCIgKyB0ZW1wKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vMy4gRmlsdGVyIG5vbiBpbnRlcnNlY3Rpbmcgc29sdXRpb25zICDljrvpmaTmsqHmnInkuqTpm4YoKeeahOaWueahiFxyXG4gICAgICAgICAgICAgICAgICAgIGlmKHRydWUpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBMb2cuaW5mbyhcIkZpbHRlciBub24gaW50ZXJzZWN0aW5nIHNvbHV0aW9ucy4gSW5pdGlhbCBudW1iZXIgb2Ygc29sdXRpb25zID0gXCIgKyBzb2x1dGlvbnMubGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5vbkludGVyc2VjdGlvblNvbHV0aW9ucyA9IFtdXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcih2YXIgbD0wOyBsPHNvbHV0aW9ucy5sZW5ndGg7IGwrKyl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc29sdXRpb24gPSBzb2x1dGlvbnNbbF1bMl07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL0xvZy5pbmZvKFwiU29sdXRpb24gaWQ9IFwiICsgc29sdXRpb25zW2xdWzFdICsgJyBuciBwb2ludHMgPSAnICsgc29sdXRpb24ubGVuZ3RoICsgXCIsIHBvaW50cyA9IFwiICsgc29sdXRpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGludGVyc2VjdCA9IGZhbHNlO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbm5lckxpbmVzID0gc29sdXRpb24uc2xpY2UoKTsgLy9qdXN0IGEgc2hhbGxvdyBjb3B5XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLypJZiBhbnkgYm91bmRzIGp1c3QgdHJpbSB0aGUgc29sdXRpb24uIFNvIHdlIGF2b2lkIHRoZSBzdHJhbmdlIGNhc2Ugd2hlbiBhIGNvbm5lY3Rpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqc3RhcnRlcyBmcm9tIGEgcG9pbnQgb24gYSBmaWd1cmUgYW5kIGVuZHMgaW5zaWRlIG9mIHRoZSBzYW1lIGZpZ3VyZSwgYnV0IG5vdCBvbiBhIGNvbm5lY3Rpb24gcG9pbnQqL1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoZUJvdW5kcyB8fCBzQm91bmRzKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2kwbm5lckxpbmVzID0gaW5uZXJMaW5lcy5zbGljZSgwLCBpbm5lckxpbmVzLmxlbmd0aCAtIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlubmVyTGluZXMgPSBpbm5lckxpbmVzLnNsaWNlKDEsIGlubmVyTGluZXMubGVuZ3RoIC0gMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9Mb2cuaW5mbyhcIlxcdCBlQm91bmRzIHByZXNlbnQsaW5uZXJMaW5lcyBuci4gcG9pbnRzID0gXCIgKyBpbm5lckxpbmVzLmxlbmd0aCArIFwiLCBwb2ludHMgPSBcIiArIGlubmVyTGluZXMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9ub3cgdGVzdCBmb3IgaW50ZXJzZWN0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihzQm91bmRzKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnRlcnNlY3QgPSBpbnRlcnNlY3QgfHwgVXRpbC5wb2x5bGluZUludGVyc2VjdHNSZWN0YW5nbGUoaW5uZXJMaW5lcywgc0JvdW5kcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihlQm91bmRzKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnRlcnNlY3QgPSBpbnRlcnNlY3QgfHwgVXRpbC5wb2x5bGluZUludGVyc2VjdHNSZWN0YW5nbGUoaW5uZXJMaW5lcywgZUJvdW5kcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoIWludGVyc2VjdCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9uSW50ZXJzZWN0aW9uU29sdXRpb25zLnB1c2goc29sdXRpb25zW2xdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9JZiBhbGwgc29sdXRpb25zIGludGVyc2VjdCB0aGFuIHRoaXMgaXMgZGVzdGlueSAgOikgYW5kIGp1c3QgaWdub3JlIHRoZSBpbnRlcnNlY3Rpb24gZmlsdGVyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKG5vbkludGVyc2VjdGlvblNvbHV0aW9ucy5sZW5ndGggIT0gMCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3JlYXNpZ24gdG8gc29sdXRpb25zXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb2x1dGlvbnMgPSBub25JbnRlcnNlY3Rpb25Tb2x1dGlvbnM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIExvZy5pbmZvKFwiXFxuXFx0IG5vbkludGVyc2VjdGlvblNvbHV0aW9ucyA9IFwiICsgc29sdXRpb25zLmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy80LiBnZXQgZmlyc3QgY2xhc3Mgb2Ygc29sdXRpb25zIHdpdGggc2FtZSBuciBvZiBwb2ludHMg6YCJ5oup5LiO56ys5LiA5Liq5pa55qGI54K55pWw5LiA5qC35aSa55qE5pa55qGI77yI5Zug5Li656ys5LiA5Liq5pa55qGI54K55pWw5pyA5bCR77yJXHJcbiAgICAgICAgICAgICAgICAgICAgaWYodHJ1ZSl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIExvZy5pbmZvKFwiR2V0IGZpcnN0IGNsYXNzIG9mIHNvbHV0aW9ucyB3aXRoIHNhbWUgbnIgb2YgcG9pbnRzXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihzb2x1dGlvbnMubGVuZ3RoID09IDApe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgTG9nLmluZm8oXCJUaGlzIGlzIG5vdCBwb3NzaWJsZVwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZpcnN0U29sdXRpb24gPSBzb2x1dGlvbnNbMF1bMl07IC8vcGljayBmaXJzdCBzb2x1dGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbnJPZlBvaW50cyA9IGZpcnN0U29sdXRpb24ubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2FtZU5yUG9pbnRzU29sdXRpb24gPSBbXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcih2YXIgbD0wOyBsPHNvbHV0aW9ucy5sZW5ndGg7IGwrKyl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc29sdXRpb24gPSBzb2x1dGlvbnNbbF1bMl07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihzb2x1dGlvbi5sZW5ndGggPT0gbnJPZlBvaW50cyl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2FtZU5yUG9pbnRzU29sdXRpb24ucHVzaChzb2x1dGlvbnNbbF0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzb2x1dGlvbnMgPSBzYW1lTnJQb2ludHNTb2x1dGlvbjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cclxuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8qNS4gIOiuoeeul+i3r+W+hOWIhuaVsCDvvIzlj5bmnIDliIbmlbDpq5jnmoRcclxuICAgICAgICAgICAgICAgICAgICAgUGljayB0aGUgZmlyc3Qgc29sdXRpb24gd2l0aCA5MCBkZWdyZWUgYW5nbGVzIChsZXNzIHR1cm5hcm91bmRzKVxyXG4gICAgICAgICAgICAgICAgICAgICAqaW4gY2FzZSB3ZSBoYXZlIG1vcmUgdGhhbiBvbmUgc29sdXRpb24gaW4gb3VyIGNsYXNzXHJcbiAgICAgICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICAgICAgaWYodHJ1ZSl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIExvZy5pbmZvKFwicGljayB0aGUgZmlyc3Qgc29sdXRpb24gd2l0aCA5MCBkZWdyZWUgYW5nbGVzIChsZXNzIHR1cm5hcm91bmRzKVwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNvbEluZGV4ID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yKHZhciBsPTA7IGw8c29sdXRpb25zLmxlbmd0aDsgbCsrKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzb2x1dGlvbiA9IHNvbHV0aW9uc1tsXVsyXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKFV0aWwuc2NvcmVQYXRoKCBzb2x1dGlvbnNbc29sSW5kZXhdWzJdICkgPCBVdGlsLnNjb3JlUGF0aCggc29sdXRpb25zW2xdWzJdICkgKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb2xJbmRleCA9IGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgc29sdXRpb25zID0gW3NvbHV0aW9uc1tzb2xJbmRleF1dO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvL1NNT09USElORyBjdXJ2ZVxyXG4gICAgICAgICAgICBpZih0eXBlID09PSBDb25uZWN0b3IuVFlQRV9DVVJWRSl7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNtb290aEN1cnZlKHNvbHV0aW9ucyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy9FTkQgU01PT1RISU5HIGN1cnZlXHJcblxyXG4gICAgICAgICAgICBMb2cuZ3JvdXBFbmQoKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBzb2x1dGlvbnM7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc21vb3RoQ3VydmU6IGZ1bmN0aW9uKHNvbHV0aW9ucyl7XHJcbiAgICAgICAgICAgIHZhciBvcHRpb24gPSAzO1xyXG5cclxuICAgICAgICAgICAgc3dpdGNoKG9wdGlvbil7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgLy9kbyBub3RoaW5nXHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgY2FzZSAxOiAvL2FkZCBpbnRlcm1lZGlhdGUgcG9pbnRzXHJcbiAgICAgICAgICAgICAgICAgICAgLy9BZGQgdGhlIG1pZGRsZSBwb2ludCBmb3Igc3RhcnQgYW5kIGVuZCBzZWdtZW50IHNvIHRoYXQgd2UgXCJmb3JjZVwiIHRoZVxyXG4gICAgICAgICAgICAgICAgICAgIC8vY3VydmUgdG8gYm90aCBjb21lIFwicGVycGVuZGljdWxhclwiIG9uIGJvdW5kcyBhbmQgYWxzbyBtYWtlIHRoZSBjdXJ2ZVxyXG4gICAgICAgICAgICAgICAgICAgIC8vXCJmbGVlXCIgbW9yZSBmcm9tIGJvdW5kcyAob24gZXhpdClcclxuICAgICAgICAgICAgICAgICAgICBmb3IodmFyIHM9MDsgczxzb2x1dGlvbnMubGVuZ3RoOyBzKyspe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc29sVHVybmluZ1BvaW50cyA9IHNvbHV0aW9uc1tzXVsyXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vZmlyc3Qgc2VnbWVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYTEgPSBzb2xUdXJuaW5nUG9pbnRzWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYTIgPSBzb2xUdXJuaW5nUG9pbnRzWzFdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3RhcnRNaWRkbGVQb2ludCA9IFV0aWwuZ2V0TWlkZGxlKGExLCBhMik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvbFR1cm5pbmdQb2ludHMuc3BsaWNlKDEsMCwgc3RhcnRNaWRkbGVQb2ludCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2xhc3Qgc2VnbWVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYTMgPSBzb2xUdXJuaW5nUG9pbnRzW3NvbFR1cm5pbmdQb2ludHMubGVuZ3RoIC0gMl07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhNCA9IHNvbFR1cm5pbmdQb2ludHNbc29sVHVybmluZ1BvaW50cy5sZW5ndGggLSAxXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVuZE1pZGRsZVBvaW50ID0gVXRpbC5nZXRNaWRkbGUoYTMsIGE0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc29sVHVybmluZ1BvaW50cy5zcGxpY2Uoc29sVHVybmluZ1BvaW50cy5sZW5ndGggLSAxLCAwLCBlbmRNaWRkbGVQb2ludCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIGNhc2UgMjogLy9yZW1vdmUgcG9pbnRzXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yKHZhciBzPTA7IHM8c29sdXRpb25zLmxlbmd0aDsgcysrKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNvbFR5cGU9IHNvbHV0aW9uc1tzXVswXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoc29sVHlwZSA9PSAnczEnIHx8IHNvbFR5cGUgPT0gJ3MyJyl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc29sVHVybmluZ1BvaW50cyA9IHNvbHV0aW9uc1tzXVsyXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvbFR1cm5pbmdQb2ludHMuc3BsaWNlKDEsMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb2xUdXJuaW5nUG9pbnRzLnNwbGljZShzb2xUdXJuaW5nUG9pbnRzLmxlbmd0aCAtIDIsIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIGNhc2UgMzpcclxuICAgICAgICAgICAgICAgICAgICAvKnJlbW92ZSBjb2xpbmVhciBwb2ludCBmb3IgczEgYXMgaXQgc2VlbXMgdGhhdCBtb3JlIGNvbGluZWFyIHBvaW50cyBkbyBub3QgbG9vayBnb29kXHJcbiAgICAgICAgICAgICAgICAgICAgICogb24gb3JnYW5pYyBzb2x1dGlvbnMgPjpEKi9cclxuICAgICAgICAgICAgICAgICAgICBmb3IodmFyIHM9MDsgczxzb2x1dGlvbnMubGVuZ3RoOyBzKyspe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc29sVHlwZT0gc29sdXRpb25zW3NdWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihzb2xUeXBlID09ICdzMScpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNvbFR1cm5pbmdQb2ludHMgPSBzb2x1dGlvbnNbc11bMl07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVkdWNlZFNvbHV0aW9uID0gVXRpbC5jb2xsaW5lYXJSZWR1Y3Rpb24oc29sVHVybmluZ1BvaW50cyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb2x1dGlvbnNbc11bMl0gPSByZWR1Y2VkU29sdXRpb247XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH0vL2VuZCBzd2l0Y2hcclxuXHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIG1vZHVsZS5leHBvcnRzID0gQ29ubmVjdGlvbk1hbmFnZXI7XHJcblxyXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vbGliL2Zpc2gtdG9wby1jb3JlL2xpYi9tYW5hZ2VyL0Nvbm5lY3Rpb25NYW5hZ2VyLmpzXG4gKiogbW9kdWxlIGlkID0gODRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxyXG4gKiDml6Xlv5fnsbtcclxuICogQGF1dGhvciB3YW5nLnhpYW9odVxyXG4gKi9cclxuXHJcblxyXG4gICAgdmFyIExvZyAgPSB7XHJcbiAgICAgICAgTE9HX0xFVkVMX05PTkUgIDogMCxcclxuXHJcbiAgICAgICAgTE9HX0xFVkVMX0RFQlVHIDogMSxcclxuXHJcbiAgICAgICAgTE9HX0xFVkVMX0lORk8gOiAyLFxyXG5cclxuICAgICAgICBMT0dfTEVWRUxfRVJST1IgOiAzLFxyXG5cclxuICAgICAgICBsZXZlbCA6IHRoaXMuTE9HX0xFVkVMX0VSUk9SLFxyXG4gICAgICAgIFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICogVGhlIGxlc3MgaW1wb3J0YW50IG9mIGFsbCBtZXNzYWdlc1xyXG4gICAgICAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgLSB0aGUgbWVzc2FnZSB0byBiZSBsb2dnZWRcclxuICAgICAgICAqKi9cclxuICAgICAgICBkZWJ1ZzogZnVuY3Rpb24gKG1lc3NhZ2Upe1xyXG4gICAgICAgICAgICBpZih0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpe1xyXG4gICAgICAgICAgICAgICAgaWYodGhpcy5sZXZlbCA8PSB0aGlzLkxPR19MRVZFTF9ERUJVRyl7XHJcbiAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgLy9pbiBGRiBpcyBkZWJ1Z1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKHR5cGVvZiBjb25zb2xlLmRlYnVnID09ICdmdW5jdGlvbicpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmRlYnVnKG1lc3NhZ2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNley8vVE9ETzogaW4gSUUgaXMgbG9nXHJcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgY29uc29sZS5pbmZvKG1lc3NhZ2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAqIFRoZSBjb21tb25seSB1c2VkIGxvZyBtZXNzYWdlXHJcbiAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSAtIHRoZSBtZXNzYWdlIHRvIGJlIGxvZ2dlZFxyXG4gICAgICAgICoqL1xyXG4gICAgICAgIGluZm8gOiBmdW5jdGlvbiAobWVzc2FnZSl7XHJcbiAgICAgICAgICAgIGlmKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyl7XHJcbiAgICAgICAgICAgICAgICBpZih0aGlzLmxldmVsIDw9IHRoaXMuTE9HX0xFVkVMX0lORk8pe1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhtZXNzYWdlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICogVGhlIHdvcnNlIGtpbmQgb2YgbWVzc2FnZS4gVXN1YWxseSBhIGNyYXNoXHJcbiAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSAtIHRoZSBtZXNzYWdlIHRvIGJlIGxvZ2dlZFxyXG4gICAgICAgICoqL1xyXG4gICAgICAgIGVycm9yIDogZnVuY3Rpb24gKG1lc3NhZ2Upe1xyXG4gICAgICAgICAgICBpZih0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpe1xyXG4gICAgICAgICAgICAgICAgaWYodGhpcy5sZXZlbCA8PSB0aGlzLkxPR19MRVZFTF9FUlJPUil7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqU3RhcnQgZ3JvdXBpbmcgdGhlIGxvZyBtZXNzYWdlc1xyXG4gICAgICAgICAqQHBhcmFtIHtTdHJpbmd9IHRpdGxlIC0gdGhlIHRpdGxlIG9mIHRoZSBncm91cFxyXG4gICAgICAgICAqQHNlZSA8YSBocmVmPVwiaHR0cDovL2dldGZpcmVidWcuY29tL2xvZ2dpbmdcIj5odHRwOi8vZ2V0ZmlyZWJ1Zy5jb20vbG9nZ2luZzwvYT5cclxuICAgICAgICAgKiovXHJcbiAgICAgICAgZ3JvdXAgOiBmdW5jdGlvbih0aXRsZSl7XHJcbiAgICAgICAgICAgIGlmKHRoaXMubGV2ZWwgPD0gdGhpcy5MT0dfTEVWRUxfSU5GTyl7IC8vaWdub3JlIGdyb3VwIGlmIGxldmVsIG5vdCBkZWJ1ZyBvciBpbmZvXHJcbiAgICAgICAgICAgICAgICBpZih0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpeyAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgLyoqSWYgd2UgZG8gbm90IHRlc3QgZm9yIGdyb3VwKCkgZnVuY3Rpb24geW91IHdpbGwgZ2V0IGFuIGVycm9yIGluIE9wZXJhXHJcbiAgICAgICAgICAgICAgICAgICAgICphcyBPcGVyYSBoYXMgaXQncyBvd24gY29uc29sZS4uLndoaWNoIGRvZXMgbm90IGhhdmUgYSBncm91cCgpIGZ1bmN0aW9uKi9cclxuICAgICAgICAgICAgICAgICAgICBpZih0eXBlb2YgY29uc29sZS5ncm91cCA9PT0gJ2Z1bmN0aW9uJyl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZ3JvdXAodGl0bGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKkVuZHMgY3VycmVudCBtZXNzYWdlIGdyb3VwaW5nKi9cclxuICAgICAgICBncm91cEVuZCA6IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgICAgIGlmKHRoaXMubGV2ZWwgPD0gdGhpcy5MT0dfTEVWRUxfSU5GTyl7IC8vaWdub3JlIGdyb3VwIGlmIGxldmVsIG5vdCBkZWJ1ZyBvciBpbmZvXHJcbiAgICAgICAgICAgICAgICBpZih0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpe1xyXG4gICAgICAgICAgICAgICAgICAgIC8qKklmIHdlIGRvIG5vdCB0ZXN0IGZvciBncm91cEVuZCgpIGZ1bmN0aW9uIHlvdSB3aWxsIGdldCBhbiBlcnJvciBpbiBPcGVyYVxyXG4gICAgICAgICAgICAgICAgICAgICAqYXMgT3BlcmEgaGFzIGl0J3Mgb3duIGNvbnNvbGUuLi53aGljaCBkb2VzIG5vdCBoYXZlIGEgZ3JvdXAoKSBmdW5jdGlvbiovXHJcbiAgICAgICAgICAgICAgICAgICAgaWYodHlwZW9mIGNvbnNvbGUuZ3JvdXBFbmQgPT09ICdmdW5jdGlvbicpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmdyb3VwRW5kKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH07XHJcblxyXG4gICAgLy9Mb2cubGV2ZWwgPSBMb2cuTE9HX0xFVkVMX0RFQlVHOyBcclxuICAgIExvZy5sZXZlbCA9IExvZy5MT0dfTEVWRUxfRVJST1I7IFxyXG4gICAgLy9Mb2cubGV2ZWwgPSBMb2cuTE9HX0xFVkVMX0VSUk9SO1xyXG4gICAgLy9Mb2cubGV2ZWwgPSBMb2cuTE9HX0xFVkVMX05PTkU7XHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IExvZztcclxuICAgIFxyXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vbGliL2Zpc2gtdG9wby1jb3JlL2xpYi9Mb2cuanNcbiAqKiBtb2R1bGUgaWQgPSA4NVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXHJcbiAqIOW4uOmHj+WumuS5iVxyXG4gKi9cclxuXHJcblx0bW9kdWxlLmV4cG9ydHMgPSBcdHtcclxuXHRcdEVMRU1FTlRfVFlQRTogXCJlbGVtZW50VHlwZVwiLFxyXG5cdFx0TU9ERTogXCJtb2RlXCIsXHJcblx0XHRCQUNLR1JPVU5EOiBcImJhY2tncm91ZFwiLFxyXG5cdFx0T1BUSU9OUzogXCJvcHRpb25zXCIsXHJcblx0XHRVU0VSREFUQTogXCJ1c2VyRGF0YVwiLFxyXG5cdFx0SUQ6IFwiaWRcIixcclxuXHRcdFNUQVJUX0lEOiBcInN0YXJ0Tm9kZUlkXCIsXHJcblx0XHRFTkRfSUQ6IFwiZW5kTm9kZUlkXCIsXHJcblx0XHRBTEFSTTogXCJBbGFybVwiLFxyXG5cdFx0UkVMQVRJT05JRDpcInJlbGF0aW9uSWRcIixcclxuXHRcdFJFTEFUSU9OX0lNQUdFOlwicmVsYXRpb25JbWFnZVwiLFxyXG5cdFx0R1JPVVA6IFwiR3JvdXBcIixcclxuXHRcdENPTk5FQ1RJT046IFwiY29ubmVjdGlvblwiLFxyXG5cdFx0Q0hJTERTOiBcImNoaWxkc1wiLFxyXG5cdFx0VFJFRV9ST09UOiBcInRyZWVSb290XCIsXHJcblx0XHRET0NLRVJTOlwib3B0aW9ucy5kb2NrZXJzXCIsXHJcblx0XHRTVFlMRV9MSU5FVFlQRTpcInN0eWxlLmxpbmVUeXBlXCIsXHJcblx0XHRMSU5FT1BFUkFUSU9OSUNPTjpcIkxpbmVPcGVyYXRpb25JY29uXCIsXHJcblx0fTtcclxuXHJcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9saWIvZmlzaC10b3BvLWZsb3cvbGliL3V0aWwvRmxvd0NvbnN0YW50cy5qc1xuICoqIG1vZHVsZSBpZCA9IDg2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcclxuICog6IqC54K5562J55qE5qih5Z6LXHJcbiAqIOmHjOmdouWtmOeahOaVsOaNrueUqOadpeWkhOeQhuW6j+WIl+WMluWSjOWPjeW6j+WIl+WMllxyXG4gKiBAY2xhc3MgZmlzaC50b3BvLm1vZGVsXHJcbiAqL1xyXG5cclxuXHJcbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XHJcbiAgICB2YXIgY2xhenpVdGlsID0gcmVxdWlyZSgnLi9jbGF6eicpO1xyXG5cclxuICAgIGZ1bmN0aW9uIE1vZGVsKG9wdGlvbiwgcGFyZW50TW9kZWwsICBleHRyYU9wdCkge1xyXG4gICAgICAgIHRoaXMucGFyZW50TW9kZWwgPSBwYXJlbnRNb2RlbDtcclxuICAgICAgICB0aGlzLm9wdGlvbiA9IG9wdGlvbjtcclxuXHJcbiAgICAgICAgLy8gU2ltcGxlIG9wdGltaXphdGlvblxyXG4gICAgICAgIGlmICh0aGlzLmluaXQpIHtcclxuICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPD0gMykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pbml0KG9wdGlvbiwgcGFyZW50TW9kZWwsICBleHRyYU9wdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmluaXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBNb2RlbC5wcm90b3R5cGUgPSB7XHJcblxyXG4gICAgICAgIGNvbnN0cnVjdG9yOiBNb2RlbCxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogTW9kZWwg55qE5Yid5aeL5YyW5Ye95pWwXHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgaW5pdDogZnVuY3Rpb24gKG9wdGlvbikge1xyXG4gICAgICAgICAgICB6clV0aWwubWVyZ2Uob3B0aW9uLCB0aGlzLmdldERlZmF1bHRPcHRpb24oKSk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgZ2V0RGVmYXVsdE9wdGlvbjogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuaGFzT3duUHJvcGVydHkoJ19fZGVmYXVsdE9wdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgb3B0TGlzdCA9IFtdO1xyXG4gICAgICAgICAgICAgICAgdmFyIENsYXNzID0gdGhpcy5jb25zdHJ1Y3RvcjtcclxuICAgICAgICAgICAgICAgIHdoaWxlIChDbGFzcykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBvcHQgPSBDbGFzcy5wcm90b3R5cGUuZGVmYXVsdE9wdGlvbjtcclxuICAgICAgICAgICAgICAgICAgICBvcHQgJiYgb3B0TGlzdC5wdXNoKG9wdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgQ2xhc3MgPSBDbGFzcy5zdXBlckNsYXNzO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHZhciBkZWZhdWx0T3B0aW9uID0ge307XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gb3B0TGlzdC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHRPcHRpb24gPSB6clV0aWwubWVyZ2UoZGVmYXVsdE9wdGlvbiwgb3B0TGlzdFtpXSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9fZGVmYXVsdE9wdGlvbiA9IGRlZmF1bHRPcHRpb247XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX19kZWZhdWx0T3B0aW9uO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgbWVyZ2VPcHRpb246IGZ1bmN0aW9uIChvcHRpb24pIHtcclxuICAgICAgICAgICAgenJVdGlsLm1lcmdlKHRoaXMub3B0aW9uLCBvcHRpb24sIHRydWUpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIOiOt+WPlm1vZGVs55qE5p+Q5Liq5bGe5oCn55qE5YC8XHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGggbW9kZWzkuK3nmoTlsZ7mgKdcclxuICAgICAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAqKuS9v+eUqOiMg+S+iyoq77yaXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgIEBleGFtcGxlXHJcbiAgICAgICAgICogICAgICAgICAgbm9kZS5tb2RlbC5nZXQoXCJvcHRpb25zLnRleHRcIik7XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAocGF0aCwgaWdub3JlUGFyZW50KSB7XHJcbiAgICAgICAgICAgIGlmICghcGF0aCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9uO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHBhdGggPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgICAgICBwYXRoID0gcGF0aC5zcGxpdCgnLicpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgb2JqID0gdGhpcy5vcHRpb247XHJcbiAgICAgICAgICAgIHZhciBwYXJlbnRNb2RlbCA9IHRoaXMucGFyZW50TW9kZWw7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0aC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgLy8gb2JqIGNvdWxkIGJlIG51bWJlci9zdHJpbmcvLi4uIChsaWtlIDApXHJcbiAgICAgICAgICAgICAgICBvYmogPSAob2JqICYmIHR5cGVvZiBvYmogPT09ICdvYmplY3QnKSA/IG9ialtwYXRoW2ldXSA6IG51bGw7XHJcbiAgICAgICAgICAgICAgICBpZiAob2JqID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAob2JqID09IG51bGwgJiYgcGFyZW50TW9kZWwgJiYgIWlnbm9yZVBhcmVudCkge1xyXG4gICAgICAgICAgICAgICAgb2JqID0gcGFyZW50TW9kZWwuZ2V0KHBhdGgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBvYmo7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICog6K6+572ubW9kZWznmoTmn5DkuKrlsZ7mgKfnmoTlgLxcclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBtb2RlbOS4reeahOWxnuaAp1xyXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZSDmiYDpnIDopoHorr7nva7nmoTlgLxcclxuICAgICAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAqKuS9v+eUqOiMg+S+iyoq77yaXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgIEBleGFtcGxlXHJcbiAgICAgICAgICogICAgICAgICAgbm9kZS5tb2RlbC5zZXQoXCJvcHRpb25zLnRleHRcIixcIuS+i+WtkFwiKTtcclxuICAgICAgICAgKi9cclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChwYXRoLCB2YWx1ZSkge1xyXG4gICAgICAgICAgICB2YXIgb2JqID0gdGhpcy5vcHRpb247XHJcblxyXG4gICAgICAgICAgICBpZiAocGF0aC5pbmRleE9mKFwiLlwiKSA9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgb2JqW3BhdGhdID0gdmFsdWU7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZmllbGRBcnJheSAgPSBwYXRoLnNwbGl0KCcuJyk7XHJcbiAgICAgICAgICAgICAgICB2YXIgbiA9IGZpZWxkQXJyYXkubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgdmFyIGN1cnJlbnRSZWYgPSBvYmo7XHJcbiAgICAgICAgICAgICAgICB2YXIgZmllbGROYW1lO1xyXG5cclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbiAtIDE7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGZpZWxkTmFtZSA9IGZpZWxkQXJyYXlbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoY3VycmVudFJlZltmaWVsZE5hbWVdID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFJlZltmaWVsZE5hbWVdID0ge307XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRSZWYgPSBjdXJyZW50UmVmW2ZpZWxkTmFtZV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBmaWVsZE5hbWUgPSBmaWVsZEFycmF5W24tMV07XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50UmVmW2ZpZWxkTmFtZV0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0U2hhbGxvdzogZnVuY3Rpb24gKGtleSwgaWdub3JlUGFyZW50KSB7XHJcbiAgICAgICAgICAgIHZhciBvcHRpb24gPSB0aGlzLm9wdGlvbjtcclxuICAgICAgICAgICAgdmFyIHZhbCA9IG9wdGlvbiAmJiBvcHRpb25ba2V5XTtcclxuICAgICAgICAgICAgdmFyIHBhcmVudE1vZGVsID0gdGhpcy5wYXJlbnRNb2RlbDtcclxuICAgICAgICAgICAgaWYgKHZhbCA9PSBudWxsICYmIHBhcmVudE1vZGVsICYmICFpZ25vcmVQYXJlbnQpIHtcclxuICAgICAgICAgICAgICAgIHZhbCA9IHBhcmVudE1vZGVsLmdldFNoYWxsb3coa2V5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdmFsO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0TW9kZWw6IGZ1bmN0aW9uIChwYXRoLCBwYXJlbnRNb2RlbCkge1xyXG4gICAgICAgICAgICB2YXIgb2JqID0gdGhpcy5nZXQocGF0aCwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIHZhciB0aGlzUGFyZW50TW9kZWwgPSB0aGlzLnBhcmVudE1vZGVsO1xyXG4gICAgICAgICAgICB2YXIgbW9kZWwgPSBuZXcgTW9kZWwoXHJcbiAgICAgICAgICAgICAgICBvYmosIHBhcmVudE1vZGVsIHx8ICh0aGlzUGFyZW50TW9kZWwgJiYgdGhpc1BhcmVudE1vZGVsLmdldE1vZGVsKHBhdGgpKVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICByZXR1cm4gbW9kZWw7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICrmuIXnqbptb2RlbOeahG9wdGlvblxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgaXNFbXB0eTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vcHRpb24gPT0gbnVsbDtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICByZXN0b3JlRGF0YTogZnVuY3Rpb24gKCkge30sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgY2xvbmU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIEN0b3IgPSB0aGlzLmNvbnN0cnVjdG9yO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEN0b3IoenJVdGlsLmNsb25lKHRoaXMub3B0aW9uKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvLyBFbmFibGUgTW9kZWwuZXh0ZW5kLlxyXG4gICAgY2xhenpVdGlsLmVuYWJsZUNsYXNzRXh0ZW5kKE1vZGVsKTtcclxuXHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IE1vZGVsO1xyXG5cclxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2xpYi9maXNoLXRvcG8tY29yZS9saWIvbW9kZWwuanNcbiAqKiBtb2R1bGUgaWQgPSA4N1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXHJcblxyXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xyXG5cclxuICAgIHZhciBjbGF6eiA9IHt9O1xyXG5cclxuICAgIHZhciBUWVBFX0RFTElNSVRFUiA9ICcuJztcclxuICAgIHZhciBJU19DT05UQUlORVIgPSAnX19fRlRfX0NPTVBPTkVOVF9fQ09OVEFJTkVSX19fJztcclxuICAgIC8qKlxyXG4gICAgICogQHB1YmxpY1xyXG4gICAgICovXHJcbiAgICB2YXIgcGFyc2VDbGFzc1R5cGUgPSBjbGF6ei5wYXJzZUNsYXNzVHlwZSA9IGZ1bmN0aW9uIChjb21wb25lbnRUeXBlKSB7XHJcbiAgICAgICAgdmFyIHJldCA9IHttYWluOiAnJywgc3ViOiAnJ307XHJcbiAgICAgICAgaWYgKGNvbXBvbmVudFR5cGUpIHtcclxuICAgICAgICAgICAgY29tcG9uZW50VHlwZSA9IGNvbXBvbmVudFR5cGUuc3BsaXQoVFlQRV9ERUxJTUlURVIpO1xyXG4gICAgICAgICAgICByZXQubWFpbiA9IGNvbXBvbmVudFR5cGVbMF0gfHwgJyc7XHJcbiAgICAgICAgICAgIHJldC5zdWIgPSBjb21wb25lbnRUeXBlWzFdIHx8ICcnO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmV0O1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHB1YmxpYyAg55u45q+UIOebtOaOpeeUqHpyVXRpbC5pbmhlcml0cyDlpb3lpITmmK8gIOWPr+S7peebtOaOpeiwg+eUqOeItuexu+eahOaehOmAoOWHveaVsFxyXG4gICAgICovXHJcbiAgICBjbGF6ei5lbmFibGVDbGFzc0V4dGVuZCA9IGZ1bmN0aW9uIChSb290Q2xhc3MsIHByZUNvbnN0cnVjdCkge1xyXG4gICAgICAgIFJvb3RDbGFzcy5leHRlbmQgPSBmdW5jdGlvbiAocHJvdG8pIHtcclxuICAgICAgICAgICAgdmFyIEV4dGVuZGVkQ2xhc3MgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBwcmVDb25zdHJ1Y3QgJiYgcHJlQ29uc3RydWN0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgICAgICBSb290Q2xhc3MuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIHpyVXRpbC5leHRlbmQoRXh0ZW5kZWRDbGFzcy5wcm90b3R5cGUsIHByb3RvKTtcclxuXHJcbiAgICAgICAgICAgIEV4dGVuZGVkQ2xhc3MuZXh0ZW5kID0gdGhpcy5leHRlbmQ7XHJcbiAgICAgICAgICAgIEV4dGVuZGVkQ2xhc3Muc3VwZXJDYWxsID0gc3VwZXJDYWxsO1xyXG4gICAgICAgICAgICBFeHRlbmRlZENsYXNzLnN1cGVyQXBwbHkgPSBzdXBlckFwcGx5O1xyXG4gICAgICAgICAgICB6clV0aWwuaW5oZXJpdHMoRXh0ZW5kZWRDbGFzcywgdGhpcyk7XHJcbiAgICAgICAgICAgIEV4dGVuZGVkQ2xhc3Muc3VwZXJDbGFzcyA9IHRoaXM7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gRXh0ZW5kZWRDbGFzcztcclxuICAgICAgICB9O1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyBzdXBlckNhbGwgc2hvdWxkIGhhdmUgY2xhc3MgaW5mbywgd2hpY2ggY2FuIG5vdCBiZSBmZXRjaCBmcm9tICd0aGlzJy5cclxuICAgIC8vIENvbnNpZGVyIHRoaXMgY2FzZTpcclxuICAgIC8vIGNsYXNzIEEgaGFzIG1ldGhvZCBmLFxyXG4gICAgLy8gY2xhc3MgQiBpbmhlcml0cyBjbGFzcyBBLCBvdmVycmlkZXMgbWV0aG9kIGYsIGYgY2FsbCBzdXBlckFwcGx5KCdmJyksXHJcbiAgICAvLyBjbGFzcyBDIGluaGVyaXRzIGNsYXNzIEIsIGRvIG5vdCBvdmVycmlkZXMgbWV0aG9kIGYsXHJcbiAgICAvLyB0aGVuIHdoZW4gbWV0aG9kIG9mIGNsYXNzIEMgaXMgY2FsbGVkLCBkZWFkIGxvb3Agb2NjdXJlZC5cclxuICAgIGZ1bmN0aW9uIHN1cGVyQ2FsbChjb250ZXh0LCBtZXRob2ROYW1lKSB7XHJcbiAgICAgICAgdmFyIGFyZ3MgPSB6clV0aWwuc2xpY2UoYXJndW1lbnRzLCAyKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5zdXBlckNsYXNzLnByb3RvdHlwZVttZXRob2ROYW1lXS5hcHBseShjb250ZXh0LCBhcmdzKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBzdXBlckFwcGx5KGNvbnRleHQsIG1ldGhvZE5hbWUsIGFyZ3MpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zdXBlckNsYXNzLnByb3RvdHlwZVttZXRob2ROYW1lXS5hcHBseShjb250ZXh0LCBhcmdzKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlbnRpdHlcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnJlZ2lzdGVyV2hlbkV4dGVuZF1cclxuICAgICAqIEBwdWJsaWNcclxuICAgICAqL1xyXG4gICAgY2xhenouZW5hYmxlQ2xhc3NNYW5hZ2VtZW50ID0gZnVuY3Rpb24gKGVudGl0eSwgb3B0aW9ucykge1xyXG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDb21wb25lbnQgbW9kZWwgY2xhc3Nlc1xyXG4gICAgICAgICAqIGtleTogY29tcG9uZW50VHlwZSxcclxuICAgICAgICAgKiB2YWx1ZTpcclxuICAgICAgICAgKiAgICAgY29tcG9uZW50Q2xhc3MsIHdoZW4gY29tcG9uZW50VHlwZSBpcyAneHh4J1xyXG4gICAgICAgICAqICAgICBvciBPYmplY3QuPHN1YktleSwgY29tcG9uZW50Q2xhc3M+LCB3aGVuIGNvbXBvbmVudFR5cGUgaXMgJ3h4eC55eSdcclxuICAgICAgICAgKiBAdHlwZSB7T2JqZWN0fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHZhciBzdG9yYWdlID0ge307XHJcblxyXG4gICAgICAgIGVudGl0eS5yZWdpc3RlckNsYXNzID0gZnVuY3Rpb24gKENsYXp6LCBjb21wb25lbnRUeXBlKSB7XHJcbiAgICAgICAgICAgIGlmIChjb21wb25lbnRUeXBlKSB7XHJcbiAgICAgICAgICAgICAgICBjb21wb25lbnRUeXBlID0gcGFyc2VDbGFzc1R5cGUoY29tcG9uZW50VHlwZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCFjb21wb25lbnRUeXBlLnN1Yikge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdG9yYWdlW2NvbXBvbmVudFR5cGUubWFpbl0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy/lt7Lnu4/ms6jlhozov4fkuobvvIznm7TmjqXov5Tlm55cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBzdG9yYWdlW2NvbXBvbmVudFR5cGUubWFpbl0gPSBDbGF6ejtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNvbXBvbmVudFR5cGUuc3ViICE9PSBJU19DT05UQUlORVIpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY29udGFpbmVyID0gbWFrZUNvbnRhaW5lcihjb21wb25lbnRUeXBlKTtcclxuICAgICAgICAgICAgICAgICAgICBjb250YWluZXJbY29tcG9uZW50VHlwZS5zdWJdID0gQ2xheno7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIENsYXp6O1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIGVudGl0eS5nZXRDbGFzcyA9IGZ1bmN0aW9uIChjb21wb25lbnRUeXBlTWFpbiwgc3ViVHlwZSwgdGhyb3dXaGVuTm90Rm91bmQpIHtcclxuICAgICAgICAgICAgdmFyIENsYXp6ID0gc3RvcmFnZVtjb21wb25lbnRUeXBlTWFpbl07XHJcblxyXG4gICAgICAgICAgICBpZiAoQ2xhenogJiYgQ2xhenpbSVNfQ09OVEFJTkVSXSkge1xyXG4gICAgICAgICAgICAgICAgQ2xhenogPSBzdWJUeXBlID8gQ2xhenpbc3ViVHlwZV0gOiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAodGhyb3dXaGVuTm90Rm91bmQgJiYgIUNsYXp6KSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXHJcbiAgICAgICAgICAgICAgICAgICAgJ0NvbXBvbmVudCAnICsgY29tcG9uZW50VHlwZU1haW4gKyAnLicgKyAoc3ViVHlwZSB8fCAnJykgKyAnIG5vdCBleGlzdHMuIExvYWQgaXQgZmlyc3QuJ1xyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIENsYXp6O1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIGVudGl0eS5nZXRDbGFzc2VzQnlNYWluVHlwZSA9IGZ1bmN0aW9uIChjb21wb25lbnRUeXBlKSB7XHJcbiAgICAgICAgICAgIGNvbXBvbmVudFR5cGUgPSBwYXJzZUNsYXNzVHlwZShjb21wb25lbnRUeXBlKTtcclxuXHJcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBbXTtcclxuICAgICAgICAgICAgdmFyIG9iaiA9IHN0b3JhZ2VbY29tcG9uZW50VHlwZS5tYWluXTtcclxuXHJcbiAgICAgICAgICAgIGlmIChvYmogJiYgb2JqW0lTX0NPTlRBSU5FUl0pIHtcclxuICAgICAgICAgICAgICAgIHpyVXRpbC5lYWNoKG9iaiwgZnVuY3Rpb24gKG8sIHR5cGUpIHtcclxuICAgICAgICAgICAgICAgICAgICB0eXBlICE9PSBJU19DT05UQUlORVIgJiYgcmVzdWx0LnB1c2gobyk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG9iaik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgZW50aXR5Lmhhc0NsYXNzID0gZnVuY3Rpb24gKGNvbXBvbmVudFR5cGUpIHtcclxuICAgICAgICAgICAgLy8gSnVzdCBjb25zaWRlciBjb21wb25lbnRUeXBlLm1haW4uXHJcbiAgICAgICAgICAgIGNvbXBvbmVudFR5cGUgPSBwYXJzZUNsYXNzVHlwZShjb21wb25lbnRUeXBlKTtcclxuICAgICAgICAgICAgcmV0dXJuICEhc3RvcmFnZVtjb21wb25lbnRUeXBlLm1haW5dO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEByZXR1cm4ge0FycmF5LjxzdHJpbmc+fSBMaWtlIFsnYWEnLCAnYmInXSwgYnV0IGNhbiBub3QgYmUgWydhYS54eCddXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZW50aXR5LmdldEFsbENsYXNzTWFpblR5cGVzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgdHlwZXMgPSBbXTtcclxuICAgICAgICAgICAgenJVdGlsLmVhY2goc3RvcmFnZSwgZnVuY3Rpb24gKG9iaiwgdHlwZSkge1xyXG4gICAgICAgICAgICAgICAgdHlwZXMucHVzaCh0eXBlKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiB0eXBlcztcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJZiBhIG1haW4gdHlwZSBpcyBjb250YWluZXIgYW5kIGhhcyBzdWIgdHlwZXNcclxuICAgICAgICAgKiBAcGFyYW0gIHtzdHJpbmd9ICBjb21wb25lbnRUeXBlXHJcbiAgICAgICAgICogQHJldHVybiB7Ym9vbGVhbn1cclxuICAgICAgICAgKi9cclxuICAgICAgICBlbnRpdHkuaGFzU3ViVHlwZXMgPSBmdW5jdGlvbiAoY29tcG9uZW50VHlwZSkge1xyXG4gICAgICAgICAgICBjb21wb25lbnRUeXBlID0gcGFyc2VDbGFzc1R5cGUoY29tcG9uZW50VHlwZSk7XHJcbiAgICAgICAgICAgIHZhciBvYmogPSBzdG9yYWdlW2NvbXBvbmVudFR5cGUubWFpbl07XHJcbiAgICAgICAgICAgIHJldHVybiBvYmogJiYgb2JqW0lTX0NPTlRBSU5FUl07XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgZW50aXR5LnBhcnNlQ2xhc3NUeXBlID0gcGFyc2VDbGFzc1R5cGU7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIG1ha2VDb250YWluZXIoY29tcG9uZW50VHlwZSkge1xyXG4gICAgICAgICAgICB2YXIgY29udGFpbmVyID0gc3RvcmFnZVtjb21wb25lbnRUeXBlLm1haW5dO1xyXG4gICAgICAgICAgICBpZiAoIWNvbnRhaW5lciB8fCAhY29udGFpbmVyW0lTX0NPTlRBSU5FUl0pIHtcclxuICAgICAgICAgICAgICAgIGNvbnRhaW5lciA9IHN0b3JhZ2VbY29tcG9uZW50VHlwZS5tYWluXSA9IHt9O1xyXG4gICAgICAgICAgICAgICAgY29udGFpbmVyW0lTX0NPTlRBSU5FUl0gPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBjb250YWluZXI7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAob3B0aW9ucy5yZWdpc3RlcldoZW5FeHRlbmQpIHtcclxuICAgICAgICAgICAgdmFyIG9yaWdpbmFsRXh0ZW5kID0gZW50aXR5LmV4dGVuZDtcclxuICAgICAgICAgICAgaWYgKG9yaWdpbmFsRXh0ZW5kKSB7XHJcbiAgICAgICAgICAgICAgICBlbnRpdHkuZXh0ZW5kID0gZnVuY3Rpb24gKHByb3RvKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIEV4dGVuZGVkQ2xhc3MgPSBvcmlnaW5hbEV4dGVuZC5jYWxsKHRoaXMsIHByb3RvKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZW50aXR5LnJlZ2lzdGVyQ2xhc3MoRXh0ZW5kZWRDbGFzcywgcHJvdG8udHlwZSk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gZW50aXR5O1xyXG4gICAgfTtcclxuXHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGNsYXp6O1xyXG5cclxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2xpYi9maXNoLXRvcG8tY29yZS9saWIvY2xhenouanNcbiAqKiBtb2R1bGUgaWQgPSA4OFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXHJcblxyXG4gICAgdmFyIGZvcmNlSGVscGVyID0gcmVxdWlyZSgnLi9mb3JjZUhlbHBlcicpO1xyXG4gICAgdmFyIHZlYzIgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3ZlY3RvcicpO1xyXG4gICAgdmFyIEJvdW5kaW5nUmVjdCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvQm91bmRpbmdSZWN0LmpzJyk7XHJcbiAgICB2YXIgVXRpbCA9IHJlcXVpcmUoJy4uLy4uLy4uL2Zpc2gtdG9wby1jb3JlL2xpYi91dGlsJyk7XHJcbiAgICB2YXIgQ29ubmVjdGlvbk1hbmFnZXIgPSByZXF1aXJlKFwiLi4vLi4vLi4vZmlzaC10b3BvLWNvcmUvbGliL21hbmFnZXIvQ29ubmVjdGlvbk1hbmFnZXIuanNcIik7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDlipvlr7zlkJHluIPlsYBcclxuICAgICAqIEBwYXJhbSAge1t0eXBlXX0gYWxsTm9kZXMgICBb5omA5pyJ6IqC54K5XVxyXG4gICAgICogQHBhcmFtICB7W3R5cGVdfSBhbGxDb25zICAgIFvmiYDmnInnur9dXHJcbiAgICAgKiBAcGFyYW0gIHtbdHlwZV19IHJlcHVsc2lvbiAgW+iKgueCueS5i+mXtOeahOaWpeWKm+WboOWtkOOAguivpeWAvOi2iuWkp+iKgueCueS5i+mXtOeahOaWpeWKm+i2iuWkp++8jOS4pOS4quiKgueCuemXtOeahOi3neemu+S5n+S8mui2iui/nOOAgl1cclxuICAgICAqIEBwYXJhbSAge1t0eXBlXX0gZWRnZUxlbmd0aCBb6L6555qE5Lik5Liq6IqC54K55LmL6Ze055qE6Led56a777yM6L+Z5Liq6Led56a75Lmf5Lya5Y+XIHJlcHVsc2lvbuOAgl1cclxuICAgICAqIEBwYXJhbSAge1t0eXBlXX0gZ3Jhdml0eSAgICBb6IqC54K55Y+X5Yiw55qE5ZCR5Lit5b+D55qE5byV5Yqb5Zug5a2Q44CC6K+l5YC86LaK5aSn6IqC54K56LaK5b6A5Lit5b+D54K56Z2g5oui44CCXVxyXG4gICAgICogQHJldHVybiB7W3R5cGVdfSAgICAgICAgICAgIFtkZXNjcmlwdGlvbl1cclxuICAgICAqL1xyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihmb3JjZUxheW91dE9wdGlvbikge1xyXG4gICAgICAgIHZhciByZXB1bHNpb24gPSBmb3JjZUxheW91dE9wdGlvbi5yZXB1bHNpb24gfHwgMTAwO1xyXG4gICAgICAgIHZhciBncmF2aXR5ID0gZm9yY2VMYXlvdXRPcHRpb24uZ3Jhdml0eSB8fCAwLjE7XHJcbiAgICAgICAgdmFyIGVkZ2VMZW5ndGggPSBmb3JjZUxheW91dE9wdGlvbi5lZGdlTGVuZ3RoIHx8IDMwO1xyXG4gICAgICAgIHZhciBwcmVzZXJ2ZWRQb2ludHMgPSBmb3JjZUxheW91dE9wdGlvbi5wcmVzZXJ2ZWRQb2ludHMgfHwge307XHJcbiAgICAgICAgdmFyIGFsbE5vZGVzID0gdGhpcy5mb3JjZUxheW91dE9wdGlvbi5hbGxOb2RlcztcclxuICAgICAgICB2YXIgYWxsQ29ucyA9IHRoaXMuZm9yY2VMYXlvdXRPcHRpb24uYWxsQ29ucztcclxuICAgICAgICB2YXIgcmVjdCA9IHRoaXMuZm9yY2VMYXlvdXRPcHRpb24ucmVjdDtcclxuICAgICAgICB2YXIgbm9kZXMgPSBfLm1hcChhbGxOb2RlcywgZnVuY3Rpb24obm9kZSwgaWR4KSB7XHJcbiAgICAgICAgICAgIHZhciByZXAgPSByZXB1bHNpb247IG5vZGUudyA9IHJlcDsgbm9kZS5yZXAgPSByZXA7IG5vZGUucCA9IG51bGw7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICB3OiByZXAsXHJcbiAgICAgICAgICAgICAgICByZXA6IHJlcCxcclxuICAgICAgICAgICAgICAgIHA6IG51bGxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgdmFyIGVkZ2VzID0gXy5tYXAoYWxsQ29ucywgZnVuY3Rpb24oY29uLCBpZHgpIHtcclxuICAgICAgICAgICAgY29uLm4xID0gY29uLnN0YXJ0Tm9kZTtcclxuICAgICAgICAgICAgY29uLm4yID0gY29uLmVuZE5vZGU7XHJcbiAgICAgICAgICAgIGNvbi5kID0gZWRnZUxlbmd0aDtcclxuICAgICAgICAgICAgY29uLmN1cnZlbmVzcyA9IDA7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBuMTogY29uLnN0YXJ0Tm9kZSxcclxuICAgICAgICAgICAgICAgIG4yOiBjb24uZW5kTm9kZSxcclxuICAgICAgICAgICAgICAgIGQ6IGVkZ2VMZW5ndGgsXHJcbiAgICAgICAgICAgICAgICBjdXJ2ZW5lc3M6IDBcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgdmFyIGZvcmNlSW5zdGFuY2UgPSBmb3JjZUhlbHBlcihhbGxOb2RlcywgYWxsQ29ucywge1xyXG4gICAgICAgICAgICByZWN0OiByZWN0LFxyXG4gICAgICAgICAgICBncmF2aXR5OiBncmF2aXR5XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdmFyIG9sZFN0ZXAgPSBmb3JjZUluc3RhbmNlLnN0ZXA7XHJcbiAgICAgICAgZm9yY2VJbnN0YW5jZS5zdGVwID0gZnVuY3Rpb24oY2IpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBhbGxOb2Rlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGlmIChub2Rlc1tpXS5maXhlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFdyaXRlIGJhY2sgdG8gbGF5b3V0IGluc3RhbmNlXHJcbiAgICAgICAgICAgICAgICAgICAgdmVjMi5jb3B5KG5vZGVzW2ldLnAsIG5vZGVzW2ldLnBvc2l0aW9uKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBvbGRTdGVwKGZ1bmN0aW9uKGFsbE5vZGVzLCBhbGxDb25zLCBzdG9wcGVkKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGFsbE5vZGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghYWxsTm9kZXNbaV0uZml4ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWxsTm9kZXNbaV0uYXR0cihcInBvc2l0aW9uXCIsIGFsbE5vZGVzW2ldLnApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBwcmVzZXJ2ZWRQb2ludHNbaV0gPSBhbGxOb2Rlc1tpXS5wO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBhbGxDb25zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHZhciBlID0gYWxsQ29uc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICAvLyB2YXIgcDEgPSBlLm4xLnA7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdmFyIHAyID0gZS5uMi5wO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHZhciBwb2ludHMgPSBbcDEsIHAyXTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBpZiAoZS5jdXJ2ZW5lc3MgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgIHBvaW50cy5wdXNoKFtcclxuICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgIChwMVswXSArIHAyWzBdKSAvIDIgLSAocDFbMV0gLSBwMlsxXSkgKiBlLmN1cnZlbmVzcyxcclxuICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgIChwMVsxXSArIHAyWzFdKSAvIDIgLSAocDJbMF0gLSBwMVswXSkgKiBlLmN1cnZlbmVzc1xyXG4gICAgICAgICAgICAgICAgICAgIC8vICAgICBdKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyB9XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdmFyIG5ld1BvaW50cyA9IFV0aWwudHJhc2xhdGVQb2ludHMocG9pbnRzLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBlLnJlZnJlc2gobmV3UG9pbnRzKTtcclxuICAgICAgICAgICAgICAgICAgICBDb25uZWN0aW9uTWFuYWdlci5yZWZyZXNoQ29ubmVjdG9yKGFsbENvbnNbaV0sIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIGxheW91dFxyXG5cclxuICAgICAgICAgICAgICAgIGNiICYmIGNiKHN0b3BwZWQpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIGZvcmNlTGF5b3V0T3B0aW9uLmZvcmNlTGF5b3V0ID0gZm9yY2VJbnN0YW5jZTtcclxuICAgICAgICBmb3JjZUxheW91dE9wdGlvbi5wcmVzZXJ2ZWRQb2ludHMgPSBwcmVzZXJ2ZWRQb2ludHM7XHJcbiAgICAgICAgLy8gU3RlcCB0byBnZXQgdGhlIGxheW91dFxyXG4gICAgICAgIGZvcmNlSW5zdGFuY2Uuc3RlcCgpO1xyXG4gICAgfVxyXG5cclxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2xpYi9maXNoLXRvcG8tZmxvdy9saWIvbGF5b3V0L2ZvcmNlTGF5b3V0LmpzXG4gKiogbW9kdWxlIGlkID0gODlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlxyXG5cclxuICAgIHZhciB2ZWMyID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS92ZWN0b3InKTtcclxuICAgIHZhciBzY2FsZUFuZEFkZCA9IHZlYzIuc2NhbGVBbmRBZGQ7XHJcblxyXG4gICAgLy8gZnVuY3Rpb24gYWRqYWNlbnROb2RlKG4sIGUpIHtcclxuICAgIC8vICAgICByZXR1cm4gZS5uMSA9PT0gbiA/IGUubjIgOiBlLm4xO1xyXG4gICAgLy8gfVxyXG5cclxuICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG5vZGVzLCBlZGdlcywgb3B0cykge1xyXG4gICAgICAgIHZhciByZWN0ID0gb3B0cy5yZWN0O1xyXG4gICAgICAgIHZhciB3aWR0aCA9IHJlY3Qud2lkdGg7XHJcbiAgICAgICAgdmFyIGhlaWdodCA9IHJlY3QuaGVpZ2h0O1xyXG4gICAgICAgIHZhciBjZW50ZXIgPSBbcmVjdC54ICsgd2lkdGggLyAyLCByZWN0LnkgKyBoZWlnaHQgLyAyXTtcclxuICAgICAgICAvLyB2YXIgc2NhbGUgPSBvcHRzLnNjYWxlIHx8IDE7XHJcbiAgICAgICAgdmFyIGdyYXZpdHkgPSBvcHRzLmdyYXZpdHkgPT0gbnVsbCA/IDAuMSA6IG9wdHMuZ3Jhdml0eTtcclxuXHJcbiAgICAgICAgLy8gZm9yICh2YXIgaSA9IDA7IGkgPCBlZGdlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIC8vICAgICB2YXIgZSA9IGVkZ2VzW2ldO1xyXG4gICAgICAgIC8vICAgICB2YXIgbjEgPSBlLm4xO1xyXG4gICAgICAgIC8vICAgICB2YXIgbjIgPSBlLm4yO1xyXG4gICAgICAgIC8vICAgICBuMS5lZGdlcyA9IG4xLmVkZ2VzIHx8IFtdO1xyXG4gICAgICAgIC8vICAgICBuMi5lZGdlcyA9IG4yLmVkZ2VzIHx8IFtdO1xyXG4gICAgICAgIC8vICAgICBuMS5lZGdlcy5wdXNoKGUpO1xyXG4gICAgICAgIC8vICAgICBuMi5lZGdlcy5wdXNoKGUpO1xyXG4gICAgICAgIC8vIH1cclxuICAgICAgICAvLyBJbml0IHBvc2l0aW9uXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgbiA9IG5vZGVzW2ldO1xyXG4gICAgICAgICAgICBpZiAoIW4ucCkge1xyXG4gICAgICAgICAgICAgICAgLy8gVXNlIHRoZSBwb3NpdGlvbiBmcm9tIGZpcnN0IGFkamVjZW50IG5vZGUgd2l0aCBkZWZpbmVkIHBvc2l0aW9uXHJcbiAgICAgICAgICAgICAgICAvLyBPciB1c2UgYSByYW5kb20gcG9zaXRpb25cclxuICAgICAgICAgICAgICAgIC8vIEZyb20gZDNcclxuICAgICAgICAgICAgICAgIC8vIGlmIChuLmVkZ2VzKSB7XHJcbiAgICAgICAgICAgICAgICAvLyAgICAgdmFyIGogPSAtMTtcclxuICAgICAgICAgICAgICAgIC8vICAgICB3aGlsZSAoKytqIDwgbi5lZGdlcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIC8vICAgICAgICAgdmFyIGUgPSBuLmVkZ2VzW2pdO1xyXG4gICAgICAgICAgICAgICAgLy8gICAgICAgICB2YXIgb3RoZXIgPSBhZGphY2VudE5vZGUobiwgZSk7XHJcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgIGlmIChvdGhlci5wKSB7XHJcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICBuLnAgPSB2ZWMyLmNsb25lKG90aGVyLnApO1xyXG4gICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyB9XHJcbiAgICAgICAgICAgICAgICAvLyBpZiAoIW4ucCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG4ucCA9IHZlYzIuY3JlYXRlKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aCAqIChNYXRoLnJhbmRvbSgpIC0gMC41KSArIGNlbnRlclswXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0ICogKE1hdGgucmFuZG9tKCkgLSAwLjUpICsgY2VudGVyWzFdXHJcbiAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgIC8vIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBuLnBwID0gdmVjMi5jbG9uZShuLnApO1xyXG4gICAgICAgICAgICBuLmVkZ2VzID0gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEZvcm11bGEgaW4gJ0dyYXBoIERyYXdpbmcgYnkgRm9yY2UtZGlyZWN0ZWQgUGxhY2VtZW50J1xyXG4gICAgICAgIC8vIHZhciBrID0gc2NhbGUgKiBNYXRoLnNxcnQod2lkdGggKiBoZWlnaHQgLyBub2Rlcy5sZW5ndGgpO1xyXG4gICAgICAgIC8vIHZhciBrMiA9IGsgKiBrO1xyXG5cclxuICAgICAgICB2YXIgZnJpY3Rpb24gPSAwLjY7XHJcblxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHdhcm1VcDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgZnJpY3Rpb24gPSAwLjU7XHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICBzZXRGaXhlZDogZnVuY3Rpb24gKGlkeCkge1xyXG4gICAgICAgICAgICAgICAgbm9kZXNbaWR4XS5maXhlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICBzZXRVbmZpeGVkOiBmdW5jdGlvbiAoaWR4KSB7XHJcbiAgICAgICAgICAgICAgICBub2Rlc1tpZHhdLmZpeGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICBzdGVwOiBmdW5jdGlvbiAoY2IpIHtcclxuICAgICAgICAgICAgICAgIHZhciB2MTIgPSBbXTtcclxuICAgICAgICAgICAgICAgIHZhciBuTGVuID0gbm9kZXMubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlZGdlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBlID0gZWRnZXNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG4xID0gZS5uMTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbjIgPSBlLm4yO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB2ZWMyLnN1Yih2MTIsIG4yLnAsIG4xLnApO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBkID0gdmVjMi5sZW4odjEyKSAtIGUuZDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdyA9IG4yLncgLyAobjEudyArIG4yLncpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZlYzIubm9ybWFsaXplKHYxMiwgdjEyKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgIW4xLmZpeGVkICYmIHNjYWxlQW5kQWRkKG4xLnAsIG4xLnAsIHYxMiwgdyAqIGQgKiBmcmljdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgIW4yLmZpeGVkICYmIHNjYWxlQW5kQWRkKG4yLnAsIG4yLnAsIHYxMiwgLSgxIC0gdykgKiBkICogZnJpY3Rpb24pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gR3Jhdml0eVxyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuTGVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbiA9IG5vZGVzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghbi5maXhlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2ZWMyLnN1Yih2MTIsIGNlbnRlciwgbi5wKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdmFyIGQgPSB2ZWMyLmxlbih2MTIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB2ZWMyLnNjYWxlKHYxMiwgdjEyLCAxIC8gZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHZhciBncmF2aXR5RmFjdG9yID0gZ3Jhdml0eTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmVjMi5zY2FsZUFuZEFkZChuLnAsIG4ucCwgdjEyLCBncmF2aXR5ICogZnJpY3Rpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBSZXB1bHNpdmVcclxuICAgICAgICAgICAgICAgIC8vIFBFTkRJTkdcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbkxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG4xID0gbm9kZXNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IGkgKyAxOyBqIDwgbkxlbjsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuMiA9IG5vZGVzW2pdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2ZWMyLnN1Yih2MTIsIG4yLnAsIG4xLnApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZCA9IHZlYzIubGVuKHYxMik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBSYW5kb20gcmVwdWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVjMi5zZXQodjEyLCBNYXRoLnJhbmRvbSgpIC0gMC41LCBNYXRoLnJhbmRvbSgpIC0gMC41KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGQgPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXBGYWN0ID0gKG4xLnJlcCArIG4yLnJlcCkgLyBkIC8gZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgIW4xLmZpeGVkICYmIHNjYWxlQW5kQWRkKG4xLnBwLCBuMS5wcCwgdjEyLCByZXBGYWN0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgIW4yLmZpeGVkICYmIHNjYWxlQW5kQWRkKG4yLnBwLCBuMi5wcCwgdjEyLCAtcmVwRmFjdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIHYgPSBbXTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbkxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG4gPSBub2Rlc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIW4uZml4ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmVjMi5zdWIodiwgbi5wLCBuLnBwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmVjMi5zY2FsZUFuZEFkZChuLnAsIG4ucCwgdiwgZnJpY3Rpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2ZWMyLmNvcHkobi5wcCwgbi5wKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgZnJpY3Rpb24gPSBmcmljdGlvbiAqIDAuOTkyO1xyXG5cclxuICAgICAgICAgICAgICAgIGNiICYmIGNiKG5vZGVzLCBlZGdlcywgZnJpY3Rpb24gPCAwLjAxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vbGliL2Zpc2gtdG9wby1mbG93L2xpYi9sYXlvdXQvZm9yY2VIZWxwZXIuanNcbiAqKiBtb2R1bGUgaWQgPSA5MFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXHJcbiAgICB2YXIgZ3JhcGhpYyA9IHJlcXVpcmUoXCIuLi8uLi8uLi9maXNoLXRvcG8tY29yZS9saWIvZ3JhcGhpYy5qc1wiKTtcclxuICAgIHZhciBDb25uZWN0aW9uTWFuYWdlciA9IHJlcXVpcmUoXCIuLi9tYW5hZ2VyL0Zsb3dDb25uZWN0aW9uTWFuYWdlci5qc1wiKTtcclxuICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9wdGlvbikge1xyXG4gICAgICAgIGZ1bmN0aW9uIGNoZWNrTm9kZShkb20pe1xyXG4gICAgICAgICAgICBkb20udHJlZVR5cGUgPSBvcHRpb24udHlwZTtcclxuICAgICAgICAgICAgZG9tLm1vZGVsLnNldChcIm9wdGlvbnMudHJlZVR5cGVcIixvcHRpb24udHlwZSk7XHJcbiAgICAgICAgICAgIC8vMeOAgeagueaNrui/nue6vyAg5om+5Ye66LW35aeL6IqC54K5IOaJgOacieeahOWtkOe7k+iKglxyXG4gICAgICAgICAgICB2YXIgY2hpbGRyZW5Ob2RlID0gW107XHJcbiAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7aSA8IENvbm5lY3Rpb25NYW5hZ2VyLmNvbm5lY3RvcnMubGVuZ3RoOyBpKyspe1xyXG4gICAgICAgICAgICAgICAgaWYoQ29ubmVjdGlvbk1hbmFnZXIuY29ubmVjdG9yc1tpXS5zdGFydE5vZGUgPT0gZG9tKXtcclxuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbk5vZGUucHVzaChDb25uZWN0aW9uTWFuYWdlci5jb25uZWN0b3JzW2ldLmVuZE5vZGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBpZihjaGlsZHJlbk5vZGUubGVuZ3RoID4gMCl7XHJcblxyXG5cclxuICAgICAgICAgICAgICAgIC8vIDIuIOmBjeWOhuWtkOe7k+eCuVxyXG4gICAgICAgICAgICAgICAgZm9yKHZhciBtID0gMDttIDwgY2hpbGRyZW5Ob2RlLmxlbmd0aDttKyspe1xyXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuTm9kZVttXS50cmVlVHlwZSA9IG9wdGlvbi50eXBlO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB4LHk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYob3B0aW9uLnR5cGUgPT0gXCJob3Jpem9udGFsXCIpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXZlcmFnZSA9ZG9tLmxheW91dC5oZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIDIuMSDniLbnu5Pngrkg5aaC5p6c5ZyG5b2iIOS9nOS4jeWQjOeahOWkhOeQhlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihkb20gaW5zdGFuY2VvZiBncmFwaGljLkNpcmNsZSl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLzIuMiDlrZDoioLngrkg5aaC5p6c5piv5ZyG5b2iICB2dlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoY2hpbGRyZW5Ob2RlW21dIGluc3RhbmNlb2YgZ3JhcGhpYy5DaXJjbGUpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkgPSBkb20ucG9zaXRpb25bMV0tYXZlcmFnZSooY2hpbGRyZW5Ob2RlLmxlbmd0aC0xKS8yK2F2ZXJhZ2UqbTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4ID0gZG9tLnBvc2l0aW9uWzBdK2RvbS5sYXlvdXQud2lkdGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9ZWxzZSBpZihjaGlsZHJlbk5vZGVbbV0gaW5zdGFuY2VvZiBncmFwaGljLkltYWdlKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5ID0gZG9tLnBvc2l0aW9uWzFdLWF2ZXJhZ2UqKGNoaWxkcmVuTm9kZS5sZW5ndGgtMSkvMithdmVyYWdlKm0tY2hpbGRyZW5Ob2RlW21dLnN0eWxlLmhlaWdodC8yO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHggPSBkb20ucG9zaXRpb25bMF0rZG9tLmxheW91dC53aWR0aC1jaGlsZHJlbk5vZGVbbV0uc3R5bGUud2lkdGgvMlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeSA9IGRvbS5wb3NpdGlvblsxXS1hdmVyYWdlKihjaGlsZHJlbk5vZGUubGVuZ3RoLTEpLzIrYXZlcmFnZSptLWNoaWxkcmVuTm9kZVttXS5zaGFwZS5oZWlnaHQvMjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4ID0gZG9tLnBvc2l0aW9uWzBdK2RvbS5sYXlvdXQud2lkdGgtY2hpbGRyZW5Ob2RlW21dLnNoYXBlLndpZHRoLzJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoY2hpbGRyZW5Ob2RlW21dIGluc3RhbmNlb2YgZ3JhcGhpYy5DaXJjbGUpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkgPSBkb20ucG9zaXRpb25bMV0rZG9tLnNoYXBlLmhlaWdodC8yLWF2ZXJhZ2UqKGNoaWxkcmVuTm9kZS5sZW5ndGgtMSkvMithdmVyYWdlKm07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeCA9IGRvbS5wb3NpdGlvblswXStkb20uc2hhcGUud2lkdGgvMitkb20ubGF5b3V0LndpZHRoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfWVsc2UgaWYoY2hpbGRyZW5Ob2RlW21dIGluc3RhbmNlb2YgZ3JhcGhpYy5JbWFnZSl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeSA9IGRvbS5wb3NpdGlvblsxXStkb20uc3R5bGUuaGVpZ2h0LzItYXZlcmFnZSooY2hpbGRyZW5Ob2RlLmxlbmd0aC0xKS8yK2F2ZXJhZ2UqbS1jaGlsZHJlbk5vZGVbbV0uc3R5bGUuaGVpZ2h0LzI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeCA9IGRvbS5wb3NpdGlvblswXStkb20uc3R5bGUud2lkdGgvMitkb20ubGF5b3V0LndpZHRoLWNoaWxkcmVuTm9kZVttXS5zdHlsZS53aWR0aC8yXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5ID0gZG9tLnBvc2l0aW9uWzFdK2RvbS5zaGFwZS5oZWlnaHQvMi1hdmVyYWdlKihjaGlsZHJlbk5vZGUubGVuZ3RoLTEpLzIrYXZlcmFnZSptLWNoaWxkcmVuTm9kZVttXS5zaGFwZS5oZWlnaHQvMjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4ID0gZG9tLnBvc2l0aW9uWzBdK2RvbS5zaGFwZS53aWR0aC8yK2RvbS5sYXlvdXQud2lkdGgtY2hpbGRyZW5Ob2RlW21dLnNoYXBlLndpZHRoLzJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXZlcmFnZSA9ZG9tLmxheW91dC53aWR0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gMi4xIOeItue7k+eCuSDlpoLmnpzlnIblvaIg5L2c5LiN5ZCM55qE5aSE55CGXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGRvbSBpbnN0YW5jZW9mIGdyYXBoaWMuQ2lyY2xlKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vMi4yIOWtkOiKgueCuSDlpoLmnpzmmK/lnIblvaIgIHZ2XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihjaGlsZHJlbk5vZGVbbV0gaW5zdGFuY2VvZiBncmFwaGljLkNpcmNsZSl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeCA9IGRvbS5wb3NpdGlvblswXS1hdmVyYWdlKihjaGlsZHJlbk5vZGUubGVuZ3RoLTEpLzIrYXZlcmFnZSptO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkgPSBkb20ucG9zaXRpb25bMV0rZG9tLmxheW91dC5oZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9ZWxzZSBpZihjaGlsZHJlbk5vZGVbbV0gaW5zdGFuY2VvZiBncmFwaGljLkltYWdlKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4ID0gZG9tLnBvc2l0aW9uWzBdLWF2ZXJhZ2UqKGNoaWxkcmVuTm9kZS5sZW5ndGgtMSkvMithdmVyYWdlKm0tY2hpbGRyZW5Ob2RlW21dLnN0eWxlLndpZHRoLzI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeSA9IGRvbS5wb3NpdGlvblsxXStkb20ubGF5b3V0LmhlaWdodC1jaGlsZHJlbk5vZGVbbV0uc3R5bGUuaGVpZ2h0LzJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHggPSBkb20ucG9zaXRpb25bMF0tYXZlcmFnZSooY2hpbGRyZW5Ob2RlLmxlbmd0aC0xKS8yK2F2ZXJhZ2UqbS1jaGlsZHJlbk5vZGVbbV0uc2hhcGUud2lkdGgvMjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5ID0gZG9tLnBvc2l0aW9uWzFdK2RvbS5sYXlvdXQuaGVpZ2h0LWNoaWxkcmVuTm9kZVttXS5zaGFwZS5oZWlnaHQvMlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihjaGlsZHJlbk5vZGVbbV0gaW5zdGFuY2VvZiBncmFwaGljLkNpcmNsZSl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeCA9IGRvbS5wb3NpdGlvblswXStkb20uc2hhcGUud2lkdGgvMi1hdmVyYWdlKihjaGlsZHJlbk5vZGUubGVuZ3RoLTEpLzIrYXZlcmFnZSptO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkgPSBkb20ucG9zaXRpb25bMV0rZG9tLnNoYXBlLmhlaWdodC8yK2RvbS5sYXlvdXQuaGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfWVsc2UgaWYoY2hpbGRyZW5Ob2RlW21dIGluc3RhbmNlb2YgZ3JhcGhpYy5JbWFnZSl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeCA9IGRvbS5wb3NpdGlvblswXStkb20uc3R5bGUud2lkdGgvMi1hdmVyYWdlKihjaGlsZHJlbk5vZGUubGVuZ3RoLTEpLzIrYXZlcmFnZSptLWNoaWxkcmVuTm9kZVttXS5zdHlsZS53aWR0aC8yO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkgPSBkb20ucG9zaXRpb25bMV0rZG9tLnN0eWxlLmhlaWdodC8yK2RvbS5sYXlvdXQuaGVpZ2h0LWNoaWxkcmVuTm9kZVttXS5zdHlsZS5oZWlnaHQvMlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeCA9IGRvbS5wb3NpdGlvblswXStkb20uc2hhcGUud2lkdGgvMi1hdmVyYWdlKihjaGlsZHJlbk5vZGUubGVuZ3RoLTEpLzIrYXZlcmFnZSptLWNoaWxkcmVuTm9kZVttXS5zaGFwZS53aWR0aC8yO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkgPSBkb20ucG9zaXRpb25bMV0rZG9tLnNoYXBlLmhlaWdodC8yK2RvbS5sYXlvdXQuaGVpZ2h0LWNoaWxkcmVuTm9kZVttXS5zaGFwZS5oZWlnaHQvMlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbk5vZGVbbV0uYXR0cihcInBvc2l0aW9uXCIsIFt4LHldKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIDMuIOiKgueCueS9jee9ruWPmOWMlu+8jOWIt+aWsOe6v1xyXG4gICAgICAgICAgICAgICAgQ29ubmVjdGlvbk1hbmFnZXIucmVmcmVzaExpbmVCeU5vZGUoZG9tKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyA0LumAkuW9kiDlrZDoioLngrlcclxuICAgICAgICAgICAgZm9yKHZhciBqID0gMDtqIDwgY2hpbGRyZW5Ob2RlLmxlbmd0aDtqKyspe1xyXG4gICAgICAgICAgICAgICAgY2hlY2tOb2RlKGNoaWxkcmVuTm9kZVtqXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgY2hlY2tOb2RlKG9wdGlvbi5ub2RlKTtcclxuICAgIH1cclxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2xpYi9maXNoLXRvcG8tZmxvdy9saWIvbGF5b3V0L3RyZWVMYXlvdXQuanNcbiAqKiBtb2R1bGUgaWQgPSA5MVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXHJcbiAqIEZsb3flt6XlhbfnsbtcclxuICovXHJcblxyXG4gICAgdmFyIE1vZGVsID0gcmVxdWlyZShcIi4uLy4uLy4uL2Zpc2gtdG9wby1jb3JlL2xpYi9tb2RlbC5qc1wiKTtcclxuICAgIHZhciBDb25zdGFudHMgPSByZXF1aXJlKFwiLi9GbG93Q29uc3RhbnRzLmpzXCIpO1xyXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xyXG4gICAgdmFyIEdyb3VwTm9kZSA9IHJlcXVpcmUoXCIuLi9ub2RlL0dyb3VwTm9kZS5qc1wiKTtcclxuICAgIHZhciBDb25uZWN0b3IgPSByZXF1aXJlKFwiLi4vLi4vLi4vZmlzaC10b3BvLWNvcmUvbGliL3NoYXBlcy9Db25uZWN0b3IuanNcIik7XHJcbiAgICAvKipcclxuICAgICAqIOagueaNrue7k+eCueaVsOe7hCDlr7zlh7pKU09O5qC85byP55qE5pWw5o2uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gbW9kZWwg5oC755qE5qih5Z6LXHJcbiAgICAgKiBAcmV0dXJuIHtKU09OfSBKU09O5qC85byP55qE5pWw5o2uXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHRvSnNvbihtb2RlbCwgZ3JvdXApIHtcclxuICAgICAgICB2YXIganNvbkFyciA9IFtdO1xyXG4gICAgICAgIGdyb3VwLmVhY2hDaGlsZChmdW5jdGlvbihub2RlKSB7XHJcbiAgICAgICAgICAgIGlmIChub2RlLm1vZGVsKSB7XHJcbiAgICAgICAgICAgICAgICAvL+WmguaenOaYr+e7hOeahOivnVxyXG4gICAgICAgICAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBHcm91cE5vZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY2hpbGRBcnIgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICBub2RlLmVhY2hDaGlsZChmdW5jdGlvbihjaGlsZE5vZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkTm9kZS5tb2RlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRBcnIucHVzaChjaGlsZE5vZGUubW9kZWwub3B0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICBub2RlLm1vZGVsLnNldChDb25zdGFudHMuQ0hJTERTLCBjaGlsZEFycik7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBDb25uZWN0b3IpIHtcclxuICAgICAgICAgICAgICAgICAgICBub2RlLnJlZnJlc2hNb2RlbCgpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIGpzb25BcnIucHVzaChub2RlLm1vZGVsLm9wdGlvbik7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICB9KVxyXG4gICAgICAgIG1vZGVsLnNldChDb25zdGFudHMuQ0hJTERTLCBqc29uQXJyKTtcclxuICAgICAgICByZXR1cm4gbW9kZWwub3B0aW9uO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog5qC55o2uIEpTT04g55Sf5oiQ6IqC54K5XHJcbiAgICAgKiBAcGFyYW0gIHtbdHlwZV19IGZpc2hUb3BvZmxvdyBbZGVzY3JpcHRpb25dXHJcbiAgICAgKiBAcGFyYW0gIHtbdHlwZV19IGpzb24gICAgICAgICBbZGVzY3JpcHRpb25dXHJcbiAgICAgKiBAcmV0dXJuIHtbdHlwZV19ICAgICAgICAgICAgICBbZGVzY3JpcHRpb25dXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGZyb21Kc29uKGZpc2hUb3BvZmxvdywgZ3JvdXAsIGNoaWxkU2hhcGVzLCBpc0NoaWxkLCBsYXlvdXRSb290Tm9kZSkge1xyXG4gICAgICAgIC8vIDEu5riF56m655S75biDXHJcblxyXG4gICAgICAgIHZhciBjb25uZWN0b3JzID0gW107XHJcbiAgICAgICAgLy8gMi7lhYjliJvlu7roioLngrkgIOmBjeWOhuW9oueKtiDojrflj5bmqKHlnotcclxuXHJcblxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRTaGFwZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIHNoYXBlID0gY2hpbGRTaGFwZXNbaV07XHJcbiAgICAgICAgICAgIGlmIChzaGFwZS5lbGVtZW50VHlwZSA9PT0gQ29uc3RhbnRzLkNPTk5FQ1RJT04pIHtcclxuICAgICAgICAgICAgICAgIGNvbm5lY3RvcnMucHVzaChzaGFwZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoc2hhcGUuZWxlbWVudFR5cGUgPT09IENvbnN0YW50cy5BTEFSTSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHJlbGF0aW9uTm9kZSA9IGZpbmROb2RlQnlJZChmaXNoVG9wb2Zsb3cuZ3JvdXAsIHNoYXBlLnJlbGF0aW9uSWQpO1xyXG4gICAgICAgICAgICAgICAgZmlzaFRvcG9mbG93LmNyZWF0QWxhcm0ocmVsYXRpb25Ob2RlLCBzaGFwZS5vcHRpb25zKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChzaGFwZS5lbGVtZW50VHlwZSA9PT0gQ29uc3RhbnRzLkdST1VQKSB7XHJcbiAgICAgICAgICAgICAgICBzaGFwZS5vcHRpb25zLmlkID0gc2hhcGUuaWQ7XHJcbiAgICAgICAgICAgICAgICB2YXIgZ3JvdXAgPSBmaXNoVG9wb2Zsb3cuY3JlYXROb2RlKHNoYXBlLmVsZW1lbnRUeXBlLCBzaGFwZS5vcHRpb25zLCBzaGFwZS51c2VyRGF0YSk7XHJcbiAgICAgICAgICAgICAgICBmcm9tSnNvbihmaXNoVG9wb2Zsb3csIGdyb3VwLCBzaGFwZS5jaGlsZHMsIHRydWUsIGxheW91dFJvb3ROb2RlKTtcclxuXHJcbiAgICAgICAgICAgICAgICBmaXNoVG9wb2Zsb3cuYWRkTm9kZShncm91cCk7XHJcblxyXG5cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIOWwhuaooeWei+S4reeahGlkIOS8oOmAkue7meWIm+W7uueahOiKgueCuVxyXG4gICAgICAgICAgICAgICAgc2hhcGUub3B0aW9ucy5pZCA9IHNoYXBlLmlkO1xyXG4gICAgICAgICAgICAgICAgdmFyIG5vZGUgPSBmaXNoVG9wb2Zsb3cuY3JlYXROb2RlKHNoYXBlLmVsZW1lbnRUeXBlLCBzaGFwZS5vcHRpb25zLCBzaGFwZS51c2VyRGF0YSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNDaGlsZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGdyb3VwLmFkZChub2RlKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZmlzaFRvcG9mbG93LmFkZE5vZGUobm9kZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHNoYXBlLm9wdGlvbnMubGF5b3V0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNoYXBlLm9wdGlvbnMubGF5b3V0LmxheW91dCA9PT0gQ29uc3RhbnRzLlRSRUVfUk9PVCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IGZpbmROb2RlQnlJZChncm91cCwgc2hhcGUuaWQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxheW91dFJvb3ROb2RlLnB1c2gobm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gIGZpc2hUb3BvLmxheW91dE5vZGUoXCJ0cmVlXCIse1wibm9kZVwiOm5vZGV9KTtcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIH07XHJcblxyXG5cclxuXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLy8gMy4g5YaN5Yib5bu657q/XHJcbiAgICAgICAgZm9yKHZhciBpID0gMCwgbGVuID0gY29ubmVjdG9ycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgbGluZSA9IGNvbm5lY3RvcnNbaV07XHJcbiAgICAgICAgICAgIHZhciBzdGFydE5vZGUgPSBmaW5kTm9kZUJ5SWQoZ3JvdXAsIGxpbmUuc3RhcnROb2RlSWQpO1xyXG4gICAgICAgICAgICB2YXIgZW5kTm9kZSA9IGZpbmROb2RlQnlJZChncm91cCwgbGluZS5lbmROb2RlSWQpO1xyXG4gICAgICAgICAgICBpZiAoc3RhcnROb2RlICYmIGVuZE5vZGUpIHtcclxuICAgICAgICAgICAgICAgIHZhciBsaW5rID0gZmlzaFRvcG9mbG93LmNyZWF0TGluayhzdGFydE5vZGUsZW5kTm9kZSxsaW5lLm9wdGlvbnMsbGluZS51c2VyRGF0YSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNDaGlsZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGdyb3VwLmFkZChsaW5rKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZmlzaFRvcG9mbG93LmFkZE5vZGUobGluayk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyDkuLrkuoYg57q/5LiK54K55Ye75LmL5ZCO5pi+56S66YKj5Lqb6ZmE5Yqg55qE5bCP5Zu+5qCHXHJcbiAgICAgICAgICAgICAgICBsaW5rLm9uKFwiY2xpY2tcIixmdW5jdGlvbigpe1xyXG4gICAgICAgICAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7aSA8IGxpbmUuaWNvbnMubGVuZ3RoO2krKyl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsaW5lLmljb25zW2ldWzBdID09ICdkZWxldGUnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaXNoVG9wb2Zsb3cuYWRkTGluZURlbGV0ZUljb24obGluayk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1lbHNlIGlmKGxpbmUuaWNvbnNbaV1bMF0gPT0gJ2NoYW5nZScpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlzaFRvcG9mbG93LmFkZExpbmVDaGFuZ2VJY29uKGxpbmspO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpc2hUb3BvZmxvdy5hZGRJY29uKGxpbmUuaWNvbnNbaV1bMF0se1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGljb246bGluZS5pY29uc1tpXVsxXS5pY29uLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiBsaW5lLmljb25zW2ldWzFdLndpZHRoLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogbGluZS5pY29uc1tpXVsxXS5oZWlnaHQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZU5vZGU6bGlua1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KVxyXG5cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDmoLnmja5pZOWcqGdyb3Vw5Lit5p+l5om+XHJcbiAgICAgKiBAcGFyYW0gIHtbdHlwZV19IGdyb3VwICBbZGVzY3JpcHRpb25dXHJcbiAgICAgKiBAcGFyYW0gIHtbdHlwZV19IG5vZGVJZCBbZGVzY3JpcHRpb25dXHJcbiAgICAgKiBAcmV0dXJuIHtbdHlwZV19ICAgICAgICBbZGVzY3JpcHRpb25dXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGZpbmROb2RlQnlJZCAoZ3JvdXAsIG5vZGVJZCkge1xyXG4gICAgICAgIHZhciByZXROb2RlID0gbnVsbDtcclxuICAgICAgICBncm91cC5lYWNoQ2hpbGQoZnVuY3Rpb24obm9kZSkge1xyXG4gICAgICAgICAgICBpZiAobm9kZS5tb2RlbCAmJiBub2RlLm1vZGVsLmdldChDb25zdGFudHMuSUQpID09PSBub2RlSWQpIHtcclxuICAgICAgICAgICAgICAgIHJldE5vZGUgPSBub2RlO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgcmV0dXJuIHJldE5vZGU7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0IGNhbnZhcyB3aGljaCBoYXMgYWxsIHRoaW5nIHJlbmRlcmVkXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0c1xyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmJhY2tncm91bmRDb2xvcl1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZ2V0UmVuZGVyZWRDYW52YXMoenIsIG9wdHMpIHtcclxuICAgICAgICBvcHRzID0gb3B0cyB8fCB7fTtcclxuICAgICAgICBvcHRzLnBpeGVsUmF0aW8gPSBvcHRzLnBpeGVsUmF0aW8gfHwgMTtcclxuICAgICAgICBvcHRzLmJhY2tncm91bmRDb2xvciA9IG9wdHMuYmFja2dyb3VuZENvbG9yXHJcbiAgICAgICAgICAgIHx8IFwiI0ZGRkZGRlwiO1xyXG4gICAgICAgIHZhciBsaXN0ID0genIuc3RvcmFnZS5nZXREaXNwbGF5TGlzdCgpO1xyXG4gICAgICAgIC8vIFN0b3AgYW5pbWF0aW9uc1xyXG4gICAgICAgIHpyVXRpbC5lYWNoKGxpc3QsIGZ1bmN0aW9uIChlbCkge1xyXG4gICAgICAgICAgICBlbC5zdG9wQW5pbWF0aW9uKHRydWUpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiB6ci5wYWludGVyLmdldFJlbmRlcmVkQ2FudmFzKG9wdHMpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHRvRGF0YVVSTCAoenIsIG9wdHMpIHtcclxuICAgICAgICBvcHRzID0gb3B0cyB8fCB7fTtcclxuICAgICAgICB2YXIgdXJsID0gZ2V0UmVuZGVyZWRDYW52YXMoenIsIG9wdHMpLnRvRGF0YVVSTChcclxuICAgICAgICAgICAgJ2ltYWdlLycgKyAob3B0cyAmJiBvcHRzLnR5cGUgfHwgJ3BuZycpXHJcbiAgICAgICAgKTtcclxuICAgICAgICByZXR1cm4gdXJsO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBmdW5jdGlvbiBpbml0Tm9kZUV2ZW50IChub2RlLCBhcGkpIHtcclxuICAgICAgICB2YXIgTU9VU0VfRVZFTlRfTkFNRVMgPSBbJ2RibGNsaWNrJywgJ2NsaWNrJ107Ly8nY2xpY2snLCAnZGJsY2xpY2snLCAnbW91c2VvdmVyJywgJ21vdXNlb3V0J1xyXG5cclxuXHJcbiAgICAgICAgenJVdGlsLmVhY2goTU9VU0VfRVZFTlRfTkFNRVMsIGZ1bmN0aW9uIChldmVOYW1lKSB7XHJcbiAgICAgICAgICAgIG5vZGUub24oZXZlTmFtZSwgZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgICAgIHZhciBwYXJhbXMgPSB7fTtcclxuICAgICAgICAgICAgICAgIHBhcmFtcy5ldmVudCA9IGU7XHJcbiAgICAgICAgICAgICAgICBwYXJhbXMudHlwZSA9IGV2ZU5hbWU7XHJcbiAgICAgICAgICAgICAgICBwYXJhbXMudGFyZ2V0ID0gbm9kZTtcclxuICAgICAgICAgICAgICAgIGFwaS50cmlnZ2VyKGV2ZU5hbWUsIHBhcmFtcyk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIG1vZHVsZS5leHBvcnRzID0ge1xyXG4gICAgICAgIHRvSnNvbjogdG9Kc29uLFxyXG4gICAgICAgIGZyb21Kc29uOiBmcm9tSnNvbixcclxuICAgICAgICB0b0RhdGFVUkw6dG9EYXRhVVJMXHJcbiAgICB9O1xyXG5cclxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2xpYi9maXNoLXRvcG8tZmxvdy9saWIvdXRpbC9GbG93VXRpbC5qc1xuICoqIG1vZHVsZSBpZCA9IDkyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcclxuICog6L+e57q/5pON5L2c57G7XHJcbiAqIEBhdXRob3IgbWlhby5jdW56aGlcclxuICovXHJcblxyXG5cdHZhciBOb2RlID0gcmVxdWlyZShcIi4uL05vZGVcIik7XHJcblx0dmFyIFV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XHJcblx0dmFyIGdyYXBoaWMgPSByZXF1aXJlKFwiLi4vZ3JhcGhpYy5qc1wiKTtcclxuICAgIHZhciBQb2ludCA9IHJlcXVpcmUoXCIuLi9Qb2ludC5qc1wiKTtcclxuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcclxuICAgIHZhciBDb25uZWN0aW9uTWFuYWdlciA9IHJlcXVpcmUoJy4vQ29ubmVjdGlvbk1hbmFnZXIuanMnKTtcclxuICAgIHZhciBMaW5lT3BlcmF0aW9uTWFuYWdlciA9IHtcclxuICAgICAgICBMaW5lT3BlcmF0aW9uczpbXSxcclxuICAgICAgICBpc0VkaXQ6dHJ1ZSxcclxuICAgICAgICBjcmVhdE9wZXJhdGlvbjpmdW5jdGlvbihrZXksb2JqLGFwaSl7XHJcbiAgICAgICAgICAgIHZhciBsaW5lT3BlcmF0aW9uID0gbmV3IGdyYXBoaWMuSW1hZ2Uoe1xyXG4gICAgICAgICAgICAgICAgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgICAgICBpbWFnZTpvYmouaWNvbixcclxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogb2JqLndpZHRofHwxNSxcclxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IG9iai5oZWlnaHR8fDE1XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBsaW5lT3BlcmF0aW9uLmtleSA9IGtleTtcclxuICAgICAgICAgICAgbGluZU9wZXJhdGlvbi5vcGVyYXRpb24gPSB0cnVlO1xyXG4gICAgICAgICAgICBsaW5lT3BlcmF0aW9uLmhpZGUoKTtcclxuICAgICAgICAgICAgb2JqLmxpbmVOb2RlLmljb25zLnB1c2gobGluZU9wZXJhdGlvbik7XHJcbiAgICAgICAgICAgIExpbmVPcGVyYXRpb25NYW5hZ2VyLkxpbmVPcGVyYXRpb25zLnB1c2gobGluZU9wZXJhdGlvbik7XHJcblxyXG4gICAgICAgICAgICAvL+Wwj+WbvuaghyDngrnlh7vkuovku7YgIOWmguaenOacieWbnuiwg+WImeiwg+eUqOWbnuiwg++8jOWQpuWImea0vuWPkeS6i+S7tlxyXG4gICAgICAgICAgICBsaW5lT3BlcmF0aW9uLm9uKFwiY2xpY2tcIixmdW5jdGlvbihlKXtcclxuICAgICAgICAgICAgICAgIGlmKG9iai5jYWxsYmFjayl7XHJcbiAgICAgICAgICAgICAgICAgICAgb2JqLmNhbGxiYWNrKG9iai5saW5lTm9kZSk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXJhbXMgPSB7fTtcclxuICAgICAgICAgICAgICAgICAgICBwYXJhbXMuZXZlbnQgPSBlO1xyXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtcy50eXBlID0gXCJjbGlja1wiO1xyXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtcy5lbGVtZW50VHlwZSA9IFwiTGluZU9wZXJhdGlvbkljb25cIjtcclxuICAgICAgICAgICAgICAgICAgICBhcGkudHJpZ2dlcihwYXJhbXMudHlwZSwgcGFyYW1zKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gbGluZU9wZXJhdGlvbjtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiDorqHnrpflsI/lm77moIfnmoTkvY3nva7vvIzlubbmmL7npLpcclxuICAgICAgICAgKiBAcGFyYW0gIHtbdHlwZV19IGNvbm5lY3RvciBbZGVzY3JpcHRpb25dXHJcbiAgICAgICAgICogQHJldHVybiB7W3R5cGVdfSAgICAgICAgICAgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGJpbmRPcGVyYXRpb246ZnVuY3Rpb24oY29ubmVjdG9yKXtcclxuICAgICAgICAgICAgaWYoTGluZU9wZXJhdGlvbk1hbmFnZXIuaXNFZGl0ID09IGZhbHNlKXtyZXR1cm47fVxyXG4gICAgICAgICAgICB2YXIgcG9pbnRQb3NpdGlvbiA9IGNvbm5lY3Rvci5taWRkbGUoKTtcclxuICAgICAgICAgICAgdmFyIGxlbmd0aCA9IFtdO1xyXG4gICAgICAgICAgICBmb3IodmFyIGogPSAwOyBqIDwgY29ubmVjdG9yLmljb25zLmxlbmd0aDsgaisrKXtcclxuICAgICAgICAgICAgICAgIGxlbmd0aC5wdXNoKGNvbm5lY3Rvci5pY29uc1tqXS5zdHlsZS53aWR0aCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHRvdGFsTGVuZ3RoID0gMDtcclxuICAgICAgICAgICAgZm9yKHZhciBtID0gMDsgbSA8IGNvbm5lY3Rvci5pY29ucy5sZW5ndGg7IG0rKyl7XHJcbiAgICAgICAgICAgICAgICAgICAgdG90YWxMZW5ndGggKz0gbGVuZ3RoW21dKzEwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBjb25uZWN0b3IuaWNvbnMubGVuZ3RoOyBpKyspe1xyXG4gICAgICAgICAgICAgICAgdmFyIGNvbm5lY3RvclBvc2l0aW9uID0gMDtcclxuICAgICAgICAgICAgICAgIGZvcih2YXIgayA9IDA7IGsgPCBpOyBrKyspe1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbm5lY3RvclBvc2l0aW9uICs9IGxlbmd0aFtrXSsxMDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbm5lY3Rvci5pY29uc1tpXS5hdHRyKFwicG9zaXRpb25cIixbcG9pbnRQb3NpdGlvblswXStjb25uZWN0b3JQb3NpdGlvbi10b3RhbExlbmd0aC8yLHBvaW50UG9zaXRpb25bMV0rNV0pO1xyXG4gICAgICAgICAgICAgICAgY29ubmVjdG9yLmljb25zW2ldLnNob3coKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGhpZGVBbGxMaW5lT3BlcmF0aW9uOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgbGkgPSAwOyBsaSA8IExpbmVPcGVyYXRpb25NYW5hZ2VyLkxpbmVPcGVyYXRpb25zLmxlbmd0aDsgbGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGljb24gPSAgTGluZU9wZXJhdGlvbk1hbmFnZXIuTGluZU9wZXJhdGlvbnNbbGldO1xyXG4gICAgICAgICAgICAgICAgaWNvbi5oaWRlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBhZGRJY29uOiBmdW5jdGlvbihrZXksIG9iaiwgenIsIGFwaSkge1xyXG4gICAgICAgICAgICAvL+WIpOaWreaYr+Wwj+Wbvuagh+WQpuWtmOWcqCDvvIzlrZjlnKjliJnnm7TmjqXov5Tlm55cclxuICAgICAgICAgICAgaWYob2JqLmxpbmVOb2RlLmljb25zKXtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqLmxpbmVOb2RlLmljb25zLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9iai5saW5lTm9kZS5pY29uc1tpXS5rZXkgPT0ga2V5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIExpbmVPcGVyYXRpb25NYW5hZ2VyLmJpbmRPcGVyYXRpb24ob2JqLmxpbmVOb2RlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIGxpbmVPcGVyYXRpb24gPSBMaW5lT3BlcmF0aW9uTWFuYWdlci5jcmVhdE9wZXJhdGlvbihrZXksIG9iaiwgYXBpKTtcclxuICAgICAgICAgICAgenIuYWRkKGxpbmVPcGVyYXRpb24pO1xyXG4gICAgICAgICAgICBMaW5lT3BlcmF0aW9uTWFuYWdlci5iaW5kT3BlcmF0aW9uKG9iai5saW5lTm9kZSk7XHJcbiAgICAgICAgICAgIHJldHVybiBsaW5lT3BlcmF0aW9uO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGRlbGV0ZUljb25PYmo6IGZ1bmN0aW9uKHBhcmVudFpyLGxpbmVOb2RlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBpY29uOlwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFBd0FBQUFPQkFNQUFBRHBrK0RmQUFBQUJHZEJUVUVBQUxHUEMveGhCUUFBQUFGelVrZENBSzdPSE9rQUFBQXRVRXhVUlFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQU1HZ0tENEFBQUFQZEZKT1V3REgvZythZ0VTajRZNnpVaVJuaDdsbndia0FBQUJMU1VSQlZBalhZMkJnWURaZ0FJRW5ua0NhN2E1Y1lHd0N3d2tsSU9oaE1CRUVnbUlHbmxBZ09NREFwcmhRVUdnREE1dldkSmNpWEpSR1IwZFRBZ1B6UTBGQlNhQnB6TWJHQmd3QUlvVVczc1EyRWRrQUFBQUFTVVZPUks1Q1lJST1cIixcclxuICAgICAgICAgICAgICAgIHdpZHRoOiAxMixcclxuICAgICAgICAgICAgICAgIGhlaWdodDogMTQsXHJcbiAgICAgICAgICAgICAgICBsaW5lTm9kZTpsaW5lTm9kZSxcclxuICAgICAgICAgICAgICAgIGNhbGxiYWNrOmZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpPGxpbmVOb2RlLmljb25zLmxlbmd0aDtpKyspe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRaci5yZW1vdmUobGluZU5vZGUuaWNvbnNbaV0pXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIENvbm5lY3Rpb25NYW5hZ2VyLmRlbGV0ZUxpbmUocGFyZW50WnIpO1xyXG4gICAgICAgICAgICAgICAgICAgIExpbmVPcGVyYXRpb25NYW5hZ2VyLmhpZGVBbGxMaW5lT3BlcmF0aW9uKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZS5jYW5jZWxCdWJibGUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH07XHJcblxyXG5cdG1vZHVsZS5leHBvcnRzID0gTGluZU9wZXJhdGlvbk1hbmFnZXI7XHJcblxyXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vbGliL2Zpc2gtdG9wby1jb3JlL2xpYi9tYW5hZ2VyL0xpbmVPcGVyYXRpb25NYW5hZ2VyLmpzXG4gKiogbW9kdWxlIGlkID0gOTNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxyXG4gKiBGbG936Z2Z5oCB5pa55rOV57G7XHJcbiAqIEBjbGFzcyBmaXNoLnRvcG8uRmlzaFRvcG9GbG93LkZsb3dcclxuICovXHJcblxyXG5cclxuICAgIHZhciBDb25zdGFudHMgPSByZXF1aXJlKFwiLi91dGlsL0Zsb3dDb25zdGFudHMuanNcIik7XHJcbiAgICB2YXIgRmxvdyA9IHtcclxuICAgICAgICBGTE9XX1RZUEU6IFwiZWxlbWVudFR5cGVcIixcclxuICAgICAgICBMSU5LOiBcImNvbm5lY3Rpb25cIixcclxuICAgICAgICBSRUNUOiBcIlJlY3RcIixcclxuICAgICAgICBHcm91cDogJ0dyb3VwJyxcclxuICAgICAgICBJTUFHRTogJ0ltYWdlJyxcclxuICAgICAgICBURVhUOiAnVGV4dCcsXHJcbiAgICAgICAgQ0lSQ0xFOiAnQ2lyY2xlJyxcclxuICAgICAgICBTRUNUT1I6ICdTZWN0b3InLFxyXG4gICAgICAgIFJJTkc6ICdSaW5nJyxcclxuICAgICAgICBQT0xZR09OOiAnUG9seWdvbicsXHJcbiAgICAgICAgUE9MWUxJTkU6ICdQb2x5bGluZScsXHJcbiAgICAgICAgTElORTogJ0xpbmUnLFxyXG4gICAgICAgIEJFWklFUkNVUlZFOiAnQmV6aWVyY3VydmUnLFxyXG4gICAgICAgIEFSQzogJ0FyYycsXHJcbiAgICAgICAgU0NFTkU6J3NjZW5lJyxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQG1ldGhvZCBzZXRVc2VyRGF0YVxyXG4gICAgICAgICAqIOiuvue9rueUqOaIt+aVsOaNrlxyXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBub2RlIOmcgOimgeiuvue9ruaVsOaNrueahOiKgueCuVxyXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmog5pWw5o2uXHJcbiAgICAgICAgICogKirkvb/nlKjojIPkvosqKu+8mlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgICBAZXhhbXBsZVxyXG4gICAgICAgICAqICAgICAgLy/orr7nva7oh6rlrprkuYnmlbDmja5cclxuICAgICAgICAgKiAgICAgIHRoaXMuZmlzaFRvcG8uRmxvdy5zZXRVc2VyRGF0YShyZWN0LCB7IGN1c3RvbU9iajogXCJyZWN0XCIgfSk7XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgc2V0VXNlckRhdGE6IGZ1bmN0aW9uKG5vZGUsIG9iaikge1xyXG4gICAgICAgICAgICBub2RlLm1vZGVsLnNldChDb25zdGFudHMuVVNFUkRBVEEsIG9iaik7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiDojrflj5borr7nva7nmoTnlKjmiLfmlbDmja5cclxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gbm9kZSDpnIDopoHojrflj5bmlbDmja7nmoToioLngrlcclxuICAgICAgICAgKiBAcmV0dXJuIHtTdHJpbmd9ICAgICAg5pWw5o2uXHJcbiAgICAgICAgICogKirkvb/nlKjojIPkvosqKu+8mlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgICBAZXhhbXBsZVxyXG4gICAgICAgICAqICAgICAgLy/ojrflj5boh6rlrprkuYnmlbDmja5cclxuICAgICAgICAgKiAgICAgIHRoaXMuZmlzaFRvcG8uRmxvdy5nZXRVc2VyRGF0YShyZWN0KTtcclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXRVc2VyRGF0YTogZnVuY3Rpb24obm9kZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbm9kZS5tb2RlbC5nZXQoQ29uc3RhbnRzLlVTRVJEQVRBKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIOWIpOaWreaYr+WQpuaYr+i/nue6v1xyXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtb2RlbCDlr7nosaHnmoRtb2RlbFxyXG4gICAgICAgICAqIEByZXR1cm4ge0Jvb2xlYW59ICAgICAg5pivIOWQplxyXG4gICAgICAgICAqICoq5L2/55So6IyD5L6LKirvvJpcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICAgQGV4YW1wbGVcclxuICAgICAgICAgKiAgICAgIC8v5Yik5pat5piv5ZCm5piv6L+e57q/XHJcbiAgICAgICAgICogICAgICB2YXIgbm9kZU1vZGVsID0gZS50YXJnZXQubW9kZWw7XHJcbiAgICAgICAgICogICAgICBpZiAodGhpcy5maXNoVG9wby5GbG93LmlzTGluayhub2RlTW9kZWwpKSB7IHJldHVybiB0cnVlO31cclxuICAgICAgICAgKi9cclxuICAgICAgICBpc0xpbms6IGZ1bmN0aW9uKG1vZGVsKSB7XHJcbiAgICAgICAgICAgIHZhciBlbGVtZW50VHlwZSA9IG1vZGVsLmdldChGbG93LkZMT1dfVFlQRSk7XHJcbiAgICAgICAgICAgIHJldHVybiBlbGVtZW50VHlwZSA9PSBGbG93LkxJTks7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiDliKTmlq3mmK/lkKbmmK/oioLngrlcclxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gbW9kZWwg5a+56LGh55qEbW9kZWxcclxuICAgICAgICAgKiBAcmV0dXJuIHtCb29sZWFufSAgICAgIOaYryDlkKZcclxuICAgICAgICAgKiAqKuS9v+eUqOiMg+S+iyoq77yaXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgIEBleGFtcGxlXHJcbiAgICAgICAgICogICAgICAvL+WIpOaWreaYr+WQpuaYr+iKgueCuVxyXG4gICAgICAgICAqICAgICAgdmFyIG5vZGVNb2RlbCA9IGUudGFyZ2V0Lm1vZGVsO1xyXG4gICAgICAgICAqICAgICAgaWYgKHRoaXMuZmlzaFRvcG8uRmxvdy5pc05vZGUobm9kZU1vZGVsKSkgeyByZXR1cm4gdHJ1ZTt9XHJcbiAgICAgICAgICovXHJcblxyXG4gICAgICAgIGlzTm9kZTogZnVuY3Rpb24obW9kZWwpIHtcclxuICAgICAgICAgICAgdmFyIGVsZW1lbnRUeXBlID0gbW9kZWwuZ2V0KEZsb3cuRkxPV19UWVBFKTtcclxuICAgICAgICAgICAgdmFyIGlzTm9kZTtcclxuICAgICAgICAgICAgaWYoZWxlbWVudFR5cGUgIT0gIEZsb3cuTElOSyAmJiBlbGVtZW50VHlwZSAhPSAgRmxvdy5TQ0VORSl7XHJcbiAgICAgICAgICAgICAgICBpc05vZGUgPSB0cnVlO1xyXG4gICAgICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgICAgIGlzTm9kZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBpc05vZGU7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICog5Yik5pat6IqC54K55piv5ZCm5piv55+p5b2i6IqC54K5XHJcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG1vZGVsIOiKgueCueeahG1vZGVsXHJcbiAgICAgICAgICogQHJldHVybiB7Qm9vbGVhbn0gICAgICDmmK8g5ZCmXHJcbiAgICAgICAgICogKirkvb/nlKjojIPkvosqKu+8mlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgICBAZXhhbXBsZVxyXG4gICAgICAgICAqICAgICAgLy/liKTmlq3mmK/lkKbmmK/nn6nlvaLoioLngrlcclxuICAgICAgICAgKiAgICAgIHZhciBub2RlTW9kZWwgPSBlLnRhcmdldC5tb2RlbDtcclxuICAgICAgICAgKiAgICAgIGlmICh0aGlzLmZpc2hUb3BvLkZsb3cuaXNSZWN0KG5vZGVNb2RlbCkpIHsgcmV0dXJuIHRydWU7fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGlzUmVjdDogZnVuY3Rpb24obW9kZWwpIHtcclxuICAgICAgICAgICAgdmFyIGVsZW1lbnRUeXBlID0gbW9kZWwuZ2V0KEZsb3cuRkxPV19UWVBFKTtcclxuICAgICAgICAgICAgcmV0dXJuICBlbGVtZW50VHlwZSA9PSBGbG93LlJFQ1Q7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiDliKTmlq3oioLngrnmmK/lkKbmmK/lm77niYfoioLngrlcclxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gbW9kZWwg6IqC54K555qEbW9kZWxcclxuICAgICAgICAgKiBAcmV0dXJuIHtCb29sZWFufSAgICAgIOaYryDlkKZcclxuICAgICAgICAgKiAqKuS9v+eUqOiMg+S+iyoq77yaXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgIEBleGFtcGxlXHJcbiAgICAgICAgICogICAgICAvL+WIpOaWreaYr+WQpuaYr+WbvueJh+iKgueCuVxyXG4gICAgICAgICAqICAgICAgdmFyIG5vZGVNb2RlbCA9IGUudGFyZ2V0Lm1vZGVsO1xyXG4gICAgICAgICAqICAgICAgaWYgKHRoaXMuZmlzaFRvcG8uRmxvdy5pc0ltYWdlKG5vZGVNb2RlbCkpIHsgcmV0dXJuIHRydWU7fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGlzSW1hZ2U6IGZ1bmN0aW9uKG1vZGVsKSB7XHJcbiAgICAgICAgICAgIHZhciBlbGVtZW50VHlwZSA9IG1vZGVsLmdldChGbG93LkZMT1dfVFlQRSk7XHJcbiAgICAgICAgICAgIHJldHVybiBlbGVtZW50VHlwZSA9PSBGbG93LklNQUdFO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICog5Yik5pat6IqC54K55piv5ZCm5piv5paH5a2X6IqC54K5XHJcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG1vZGVsIOiKgueCueeahG1vZGVsXHJcbiAgICAgICAgICogQHJldHVybiB7Qm9vbGVhbn0gICAgICDmmK8g5ZCmXHJcbiAgICAgICAgICogKirkvb/nlKjojIPkvosqKu+8mlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgICBAZXhhbXBsZVxyXG4gICAgICAgICAqICAgICAgLy/liKTmlq3mmK/lkKbmmK/mloflrZfoioLngrlcclxuICAgICAgICAgKiAgICAgIHZhciBub2RlTW9kZWwgPSBlLnRhcmdldC5tb2RlbDtcclxuICAgICAgICAgKiAgICAgIGlmICh0aGlzLmZpc2hUb3BvLkZsb3cuaXNUZXh0KG5vZGVNb2RlbCkpIHsgcmV0dXJuIHRydWU7fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGlzVGV4dDogZnVuY3Rpb24obW9kZWwpIHtcclxuICAgICAgICAgICAgdmFyIGVsZW1lbnRUeXBlID0gbW9kZWwuZ2V0KEZsb3cuRkxPV19UWVBFKTtcclxuICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnRUeXBlID09IEZsb3cuVEVYVDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIOWIpOaWreiKgueCueaYr+WQpuaYr+WchuW9ouiKgueCuVxyXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtb2RlbCDoioLngrnnmoRtb2RlbFxyXG4gICAgICAgICAqIEByZXR1cm4ge0Jvb2xlYW59ICAgICAg5pivIOWQplxyXG4gICAgICAgICAqICoq5L2/55So6IyD5L6LKirvvJpcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICAgQGV4YW1wbGVcclxuICAgICAgICAgKiAgICAgIC8v5Yik5pat5piv5ZCm5piv5ZyG5b2i6IqC54K5XHJcbiAgICAgICAgICogICAgICB2YXIgbm9kZU1vZGVsID0gZS50YXJnZXQubW9kZWw7XHJcbiAgICAgICAgICogICAgICBpZiAodGhpcy5maXNoVG9wby5GbG93LmlzQ2lyY2xlKG5vZGVNb2RlbCkpIHsgcmV0dXJuIHRydWU7fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGlzQ2lyY2xlOiBmdW5jdGlvbihtb2RlbCkge1xyXG4gICAgICAgICAgICB2YXIgZWxlbWVudFR5cGUgPSBtb2RlbC5nZXQoRmxvdy5GTE9XX1RZUEUpO1xyXG4gICAgICAgICAgICByZXR1cm4gZWxlbWVudFR5cGUgPT0gRmxvdy5DSVJDTEU7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiDojrflj5boioLngrnnmoTnsbvlnotcclxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gbW9kZWwg6IqC54K555qEbW9kZWxcclxuICAgICAgICAgKiAqKuS9v+eUqOiMg+S+iyoq77yaXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgIEBleGFtcGxlXHJcbiAgICAgICAgICogICAgICAvL+iOt+WPluiKgueCueexu+Wei1xyXG4gICAgICAgICAqICAgICAgdmFyIG5vZGVNb2RlbCA9IGUudGFyZ2V0Lm1vZGVsO1xyXG4gICAgICAgICAqICAgICAgcmV0dXJuIHRoaXMuZmlzaFRvcG8uRmxvdy5nZXRUeXBlKG5vZGVNb2RlbCk7XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0VHlwZTogZnVuY3Rpb24obW9kZWwpIHtcclxuICAgICAgICAgICAgdmFyIGVsZW1lbnRUeXBlID0gbW9kZWwuZ2V0KEZsb3cuRkxPV19UWVBFKTtcclxuICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnRUeXBlO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBGbG93O1xyXG5cclxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2xpYi9maXNoLXRvcG8tZmxvdy9saWIvRmxvdy5qc1xuICoqIG1vZHVsZSBpZCA9IDk0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcclxuICAgIC8v5Y2V5L6LXHJcbiAgICB2YXIgaW5zdGFuY2UgPSBudWxsO1xyXG4gICAgdmFyIGVtcHR5Rm4gPSBmdW5jdGlvbigpIHt9O1xyXG4gICAgLy/liJ3lp4vpu5jorqTphY3nva5cclxuICAgIHZhciBjb25maWdfZGVmYXVsdCA9IHtcclxuICAgICAgICAvL+e6v+eoi+axoFwi57q/56iLXCLmlbDph49cclxuICAgICAgICB0aHJlYWQ6IDUsXHJcbiAgICAgICAgLy/lm77niYfliqDovb3lpLHotKXph43or5XmrKHmlbBcclxuICAgICAgICAvL+mHjeivlTLmrKHvvIzliqDkuIrljp/mnInnmoTkuIDmrKHvvIzmgLvlhbHmmK8z5qyhXHJcbiAgICAgICAgXCJ0cmllc1wiOiAyXHJcbiAgICB9O1xyXG4gICAgLy/lt6XlhbdcclxuICAgIHZhciBfaGVscGVycyA9IHtcclxuICAgICAgICAvL+iuvue9rmRvbeWxnuaAp1xyXG4gICAgICAgIHNldEF0dHI6IChmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdmFyIGltZyA9IG5ldyBJbWFnZSgpO1xyXG4gICAgICAgICAgICAvL+WIpOaWrea1j+iniOWZqOaYr+WQpuaUr+aMgUhUTUw1IGRhdGFzZXRcclxuICAgICAgICAgICAgaWYgKGltZy5kYXRhc2V0KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oZG9tLCBuYW1lLCB2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRvbS5kYXRhc2V0W25hbWVdID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihkb20sIG5hbWUsIHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZG9tLnNldEF0dHJpYnV0ZShcImRhdGEtXCIgKyBuYW1lLCB2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0oKSksXHJcbiAgICAgICAgLy/ojrflj5Zkb23lsZ7mgKdcclxuICAgICAgICBnZXRBdHRyOiAoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHZhciBpbWcgPSBuZXcgSW1hZ2UoKTtcclxuICAgICAgICAgICAgLy/liKTmlq3mtY/op4jlmajmmK/lkKbmlK/mjIFIVE1MNSBkYXRhc2V0XHJcbiAgICAgICAgICAgIGlmIChpbWcuZGF0YXNldCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGRvbSwgbmFtZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKCFkb20uZGF0YXNldFtuYW1lXSl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkb20uZ2V0QXR0cmlidXRlKFwiZGF0YS1cIiArIG5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZG9tLmRhdGFzZXRbbmFtZV07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihkb20sIG5hbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZG9tLmdldEF0dHJpYnV0ZShcImRhdGEtXCIgKyBuYW1lKTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KCkpXHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiDmnoTpgKDmlrnms5VcclxuICAgICAqIEBwYXJhbSBtYXgg5pyA5aSn6L+e5o6l5pWw44CC5pWw5YC844CCXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIEltYWdlUG9vbChtYXgpIHtcclxuICAgICAgICAvL+acgOWkp+W5tuWPkeaVsOmHj1xyXG4gICAgICAgIHRoaXMubWF4ID0gbWF4IHx8IGNvbmZpZ19kZWZhdWx0LnRocmVhZDtcclxuICAgICAgICB0aGlzLmxpbmtIZWFkID0gbnVsbDtcclxuICAgICAgICB0aGlzLmxpbmtOb2RlID0gbnVsbDtcclxuICAgICAgICAvL+WKoOi9veaxoFxyXG4gICAgICAgIC8vW3tpbWc6IGRvbSxmcmVlOiB0cnVlLCBub2RlOiBub2RlfV1cclxuICAgICAgICAvL25vZGVcclxuICAgICAgICAvL3tzcmM6IFwiXCIsIG9wdGlvbnM6IHtzdWNjZXNzOiBcImZuXCIsZXJyb3I6IFwiZm5cIiwgb25jZTogdHJ1ZX0sIHRyaWVzOiAwfVxyXG4gICAgICAgIHRoaXMucG9vbCA9IFtdO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiDliJ3lp4vljJZcclxuICAgICAqL1xyXG4gICAgSW1hZ2VQb29sLnByb3RvdHlwZS5pbml0UG9vbCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBpLCBpbWcsIG9iaiwgX3M7XHJcbiAgICAgICAgX3MgPSB0aGlzO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLm1heDsgaSsrKSB7XHJcbiAgICAgICAgICAgIG9iaiA9IHt9O1xyXG4gICAgICAgICAgICBpbWcgPSBuZXcgSW1hZ2UoKTtcclxuICAgICAgICAgICAgX2hlbHBlcnMuc2V0QXR0cihpbWcsIFwiaWRcIiwgaSk7XHJcbiAgICAgICAgICAgIGltZy5vbmxvYWQgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIHZhciBpZCwgc3JjO1xyXG4gICAgICAgICAgICAgICAgLy/lm57osINcclxuICAgICAgICAgICAgICAgIF9zLm5vdGljZShfcy5nZXROb2RlKHRoaXMpLCBcInN1Y2Nlc3NcIiwgdGhpcyk7XHJcbiAgICAgICAgICAgICAgICAvL+WkhOeQhuS7u+WKoVxyXG4gICAgICAgICAgICAgICAgX3MuZXhlY3V0ZUxpbmsodGhpcyk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGltZy5vbmVycm9yID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IF9zLmdldE5vZGUodGhpcyk7XHJcbiAgICAgICAgICAgICAgICAvL+WIpOaWreWwneivleasoeaVsFxyXG4gICAgICAgICAgICAgICAgaWYgKG5vZGUudHJpZXMgPCBjb25maWdfZGVmYXVsdC50cmllcykge1xyXG4gICAgICAgICAgICAgICAgICAgIG5vZGUudHJpZXMgPSBub2RlLnRyaWVzKzE7XHJcbiAgICAgICAgICAgICAgICAgICAgLy/lho3mrKHov73liqDliLDku7vliqHpk77ooajmnKvlsL5cclxuICAgICAgICAgICAgICAgICAgICBfcy5hcHBlbmROb2RlKF9zLmNyZWF0ZU5vZGUobm9kZS5zcmMsIG5vZGUub3B0aW9ucywgbm9kZS5ub3RpY2UsIG5vZGUuZ3JvdXAsIG5vZGUudHJpZXMpKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9lcnJvcuWbnuiwg1xyXG4gICAgICAgICAgICAgICAgICAgIC8vbm9kZS5vcHRpb25zLmVycm9yLmNhbGwobnVsbCwgdGhpcy5zcmMpO1xyXG4gICAgICAgICAgICAgICAgICAgIF9zLm5vdGljZShub2RlLCBcImVycm9yXCIsIHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy/lpITnkIbku7vliqFcclxuICAgICAgICAgICAgICAgIF9zLmV4ZWN1dGVMaW5rKHRoaXMpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBvYmouaW1nID0gaW1nO1xyXG4gICAgICAgICAgICBvYmouZnJlZSA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMucG9vbC5wdXNoKG9iaik7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICog5Zue6LCD5bCB6KOFXHJcbiAgICAgKiBAcGFyYW0gbm9kZSDoioLngrnjgILlr7nosaHjgIJcclxuICAgICAqIEBwYXJhbSBzdGF0dXMg54q25oCB44CC5a2X56ym5Liy44CC5Y+v6YCJ5YC877yac3VjY2VzcyjmiJDlip8pfGVycm9yKOWksei0pSlcclxuICAgICAqIEBwYXJhbSBpbWcg5Zu+54mH44CCXHJcbiAgICAgKi9cclxuICAgIEltYWdlUG9vbC5wcm90b3R5cGUubm90aWNlID0gZnVuY3Rpb24obm9kZSwgc3RhdHVzLCBpbWcpIHtcclxuICAgICAgICBub2RlLm5vdGljZShzdGF0dXMsIGltZyk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiDlpITnkIbpk77ooajku7vliqFcclxuICAgICAqIEBwYXJhbSBkb20g5Zu+5YOPZG9t5a+56LGh44CC5a+56LGh44CCXHJcbiAgICAgKi9cclxuICAgIEltYWdlUG9vbC5wcm90b3R5cGUuZXhlY3V0ZUxpbmsgPSBmdW5jdGlvbihkb20pIHtcclxuICAgICAgICAvL+WIpOaWremTvuihqOaYr+WQpuWtmOWcqOiKgueCuVxyXG4gICAgICAgIGlmICh0aGlzLmxpbmtIZWFkKSB7XHJcbiAgICAgICAgICAgIC8v5Yqg6L295LiL5LiA5Liq5Zu+54mHXHJcbiAgICAgICAgICAgIHRoaXMuc2V0U3JjKGRvbSwgdGhpcy5saW5rSGVhZCk7XHJcbiAgICAgICAgICAgIC8v5Y676Zmk6ZO+6KGo5aS0XHJcbiAgICAgICAgICAgIHRoaXMuc2hpZnROb2RlKCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy/orr7nva7oh6rouqvnirbmgIHkuLrnqbrpl7JcclxuICAgICAgICAgICAgdGhpcy5zdGF0dXMoZG9tLCB0cnVlKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiDojrflj5bnqbrpl7JcIue6v+eoi1wiXHJcbiAgICAgKi9cclxuICAgIEltYWdlUG9vbC5wcm90b3R5cGUuZ2V0RnJlZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBsZW5ndGgsIGk7XHJcbiAgICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gdGhpcy5wb29sLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnBvb2xbaV0uZnJlZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucG9vbFtpXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIOWwgeijhXNyY+WxnuaAp+iuvue9rlxyXG4gICAgICog5Zug5Li65pS55Y+Yc3Jj5bGe5oCn55u45b2T5LqO5Yqg6L295Zu+54mH77yM5omA5Lul5oqK5pON5L2c5bCB6KOF6LW35p2lXHJcbiAgICAgKiBAcGFyYW0gZG9tIOWbvuWDj2RvbeWvueixoeOAguWvueixoeOAglxyXG4gICAgICogQHBhcmFtIG5vZGUg6IqC54K544CC5a+56LGh44CCXHJcbiAgICAgKi9cclxuICAgIEltYWdlUG9vbC5wcm90b3R5cGUuc2V0U3JjID0gZnVuY3Rpb24oZG9tLCBub2RlKSB7XHJcbiAgICAgICAgLy/orr7nva7msaDkuK3nmoRcIue6v+eoi1wi5Li66Z2e56m66Zey54q25oCBXHJcbiAgICAgICAgdGhpcy5zdGF0dXMoZG9tLCBmYWxzZSk7XHJcbiAgICAgICAgLy/lhbPogZToioLngrlcclxuICAgICAgICB0aGlzLnNldE5vZGUoZG9tLCBub2RlKTtcclxuICAgICAgICAvL+WKoOi9veWbvueJh1xyXG4gICAgICAgIGRvbS5zcmMgPSBub2RlLnNyYztcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIOabtOaWsOaxoOS4reeahFwi57q/56iLXCLnirbmgIFcclxuICAgICAqIEBwYXJhbSBkb20g5Zu+5YOPZG9t5a+56LGh44CC5a+56LGh44CCXHJcbiAgICAgKiBAcGFyYW0gc3RhdHVzIOeKtuaAgeOAguW4g+WwlOOAguWPr+mAieWAvO+8mnRydWUo56m66ZeyKXxmYWxzZSjpnZ7nqbrpl7IpXHJcbiAgICAgKi9cclxuICAgIEltYWdlUG9vbC5wcm90b3R5cGUuc3RhdHVzID0gZnVuY3Rpb24oZG9tLCBzdGF0dXMpIHtcclxuICAgICAgICB2YXIgaWQgPSBfaGVscGVycy5nZXRBdHRyKGRvbSwgXCJpZFwiKTtcclxuICAgICAgICBpZihpZCl7XHJcbiAgICAgICAgICAgIHRoaXMucG9vbFtpZF0uZnJlZSA9IHN0YXR1cztcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy/nqbrpl7LnirbmgIHvvIzmuIXpmaTlhbPogZTnmoToioLngrlcclxuICAgICAgICBpZiAoc3RhdHVzKSB7XHJcbiAgICAgICAgICAgIHRoaXMucG9vbFtpZF0ubm9kZSA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICog5pu05paw5rGg5Lit55qEXCLnur/nqItcIueahOWFs+iBlOiKgueCuVxyXG4gICAgICogQHBhcmFtIGRvbSDlm77lg49kb23lr7nosaHjgILlr7nosaHjgIJcclxuICAgICAqIEBwYXJhbSBub2RlIOiKgueCueOAguWvueixoeOAglxyXG4gICAgICovXHJcbiAgICBJbWFnZVBvb2wucHJvdG90eXBlLnNldE5vZGUgPSBmdW5jdGlvbihkb20sIG5vZGUpIHtcclxuICAgICAgICB2YXIgaWQgPSBfaGVscGVycy5nZXRBdHRyKGRvbSwgXCJpZFwiKTtcclxuICAgICAgICBpZihpZCl7XHJcbiAgICAgICAgICAgIHRoaXMucG9vbFtpZF0ubm9kZSA9IG5vZGU7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBvb2xbaWRdLm5vZGUgPT09IG5vZGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICog6I635Y+W5rGg5Lit55qEXCLnur/nqItcIueahOWFs+iBlOiKgueCuVxyXG4gICAgICogQHBhcmFtIGRvbSDlm77lg49kb23lr7nosaHjgILlr7nosaHjgIJcclxuICAgICAqL1xyXG4gICAgSW1hZ2VQb29sLnByb3RvdHlwZS5nZXROb2RlID0gZnVuY3Rpb24oZG9tKSB7XHJcbiAgICAgICAgdmFyIGlkID0gX2hlbHBlcnMuZ2V0QXR0cihkb20sIFwiaWRcIik7XHJcbiAgICAgICAgaWYoaWQpe1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wb29sW2lkXS5ub2RlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIOWvueWkluaOpeWPo++8jOWKoOi9veWbvueJh1xyXG4gICAgICogQHBhcmFtIHNyYyDlj6/ku6XmmK9zcmPlrZfnrKbkuLLvvIzkuZ/lj6/ku6XmmK9zcmPlrZfnrKbkuLLmlbDnu4TjgIJcclxuICAgICAqIEBwYXJhbSBvcHRpb25zIOeUqOaIt+iHquWumuS5ieWPguaVsOOAguWMheWQq++8mnN1Y2Nlc3Plm57osIPjgIFlcnJvcuWbnuiwg+OAgW9uY2XmoIfor4bjgIJcclxuICAgICAqL1xyXG4gICAgSW1hZ2VQb29sLnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24oc3JjLCBvcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIHNyY3MgPSBbXSxcclxuICAgICAgICAgICAgZnJlZSA9IG51bGwsXHJcbiAgICAgICAgICAgIGxlbmd0aCA9IDAsXHJcbiAgICAgICAgICAgIGkgPSAwLFxyXG4gICAgICAgICAgICAvL+WPquWIneWni+WMluS4gOasoeWbnuiwg+etlueVpVxyXG4gICAgICAgICAgICBub3RpY2UgPSAoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5vbmNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHN0YXR1cywgaW1nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBnID0gdGhpcy5ncm91cCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG8gPSB0aGlzLm9wdGlvbnM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8v6K6w5b2VXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGdbc3RhdHVzXS5wdXNoKGltZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8v5Yik5pat5pS557uE5piv5ZCm5YWo6YOo5aSE55CG5a6M5oiQXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChnLnN1Y2Nlc3MubGVuZ3RoICsgZy5lcnJvci5sZW5ndGggPT09IGcuY291bnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8v5byC5q2lXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL+WunumZheS4iuaYr+S9nOS4uuWPpuS4gOS4quS7u+WKoeWNleeLrOaJp+ihjO+8jOmYsuatouWbnuiwg+WHveaVsOaJp+ihjOaXtumXtOi/h+mVv+W9seWTjeWbvueJh+WKoOi9vemAn+W6plxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvLnN1Y2Nlc3MuY2FsbChudWxsLCBnLnN1Y2Nlc3MsIGcuZXJyb3IsIGcuY291bnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oc3RhdHVzLCBpbWcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG8gPSB0aGlzLm9wdGlvbnM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8v55u05o6l5Zue6LCDXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvW3N0YXR1c10uY2FsbChudWxsLCBpbWcpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCAxKTtcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KCkpLFxyXG4gICAgICAgICAgICBncm91cCA9IHtcclxuICAgICAgICAgICAgICAgIGNvdW50OiAwLFxyXG4gICAgICAgICAgICAgICAgc3VjY2VzczogW10sXHJcbiAgICAgICAgICAgICAgICBlcnJvcjogW11cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgbm9kZSA9IG51bGw7XHJcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcbiAgICAgICAgb3B0aW9ucy5zdWNjZXNzID0gb3B0aW9ucy5zdWNjZXNzIHx8IGVtcHR5Rm47XHJcbiAgICAgICAgb3B0aW9ucy5lcnJvciA9IG9wdGlvbnMuZXJyb3IgfHwgZW1wdHlGbjtcclxuICAgICAgICBzcmNzID0gc3Jjcy5jb25jYXQoc3JjKTtcclxuICAgICAgICAvL+iuvue9rue7hOWFg+e0oOS4quaVsFxyXG4gICAgICAgIGdyb3VwLmNvdW50ID0gc3Jjcy5sZW5ndGg7XHJcbiAgICAgICAgLy/pgY3ljobpnIDopoHliqDovb3nmoTlm77niYdcclxuICAgICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBzcmNzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIC8v5Yib5bu66IqC54K5XHJcbiAgICAgICAgICAgIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoc3Jjc1tpXSwgb3B0aW9ucywgbm90aWNlLCBncm91cCk7XHJcbiAgICAgICAgICAgIC8v5Yik5pat57q/56iL5rGg5piv5ZCm5pyJ56m66ZeyXHJcbiAgICAgICAgICAgIGZyZWUgPSB0aGlzLmdldEZyZWUoKTtcclxuICAgICAgICAgICAgaWYgKGZyZWUpIHtcclxuICAgICAgICAgICAgICAgIC8v5pyJ56m66Zey77yM5YiZ56uL5Y2z5Yqg6L295Zu+54mHXHJcbiAgICAgICAgICAgICAgICB0aGlzLnNldFNyYyhmcmVlLmltZywgbm9kZSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvL+ayoeacieepuumXsu+8jOWwhuS7u+WKoea3u+WKoOWIsOmTvuihqFxyXG4gICAgICAgICAgICAgICAgdGhpcy5hcHBlbmROb2RlKG5vZGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICog6I635Y+W5YaF6YOo54q25oCB5L+h5oGvXHJcbiAgICAgKiBAcmV0dXJucyB7e319XHJcbiAgICAgKi9cclxuICAgIEltYWdlUG9vbC5wcm90b3R5cGUuaW5mbyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBpbmZvID0ge30sXHJcbiAgICAgICAgICAgIGxlbmd0aCA9IDAsXHJcbiAgICAgICAgICAgIGkgPSAwLFxyXG4gICAgICAgICAgICBub2RlID0gbnVsbDtcclxuICAgICAgICAvL+e6v+eoi1xyXG4gICAgICAgIGluZm8udGhyZWFkID0ge307XHJcbiAgICAgICAgLy/nur/nqIvmgLvmlbDph49cclxuICAgICAgICBpbmZvLnRocmVhZC5jb3VudCA9IHRoaXMucG9vbC5sZW5ndGg7XHJcbiAgICAgICAgLy/nqbrpl7Lnur/nqIvmlbDph49cclxuICAgICAgICBpbmZvLnRocmVhZC5mcmVlID0gMDtcclxuICAgICAgICAvL+S7u+WKoVxyXG4gICAgICAgIGluZm8udGFzayA9IHt9O1xyXG4gICAgICAgIC8v5b6F5aSE55CG5Lu75Yqh5pWw6YePXHJcbiAgICAgICAgaW5mby50YXNrLmNvdW50ID0gMDtcclxuICAgICAgICAvL+iOt+WPluepuumXslwi57q/56iLXCLmlbDph49cclxuICAgICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSB0aGlzLnBvb2wubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMucG9vbFtpXS5mcmVlKSB7XHJcbiAgICAgICAgICAgICAgICBpbmZvLnRocmVhZC5mcmVlID0gaW5mby50aHJlYWQuZnJlZSArIDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy/ojrflj5bku7vliqHmlbDph48o5Lu75Yqh6ZO+6ZW/5bqmKVxyXG4gICAgICAgIG5vZGUgPSB0aGlzLmxpbmtIZWFkO1xyXG4gICAgICAgIGlmIChub2RlKSB7XHJcbiAgICAgICAgICAgIGluZm8udGFzay5jb3VudCA9IGluZm8udGFzay5jb3VudCArIDE7XHJcbiAgICAgICAgICAgIHdoaWxlIChub2RlLm5leHQpIHtcclxuICAgICAgICAgICAgICAgIGluZm8udGFzay5jb3VudCA9IGluZm8udGFzay5jb3VudCArIDE7XHJcbiAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5uZXh0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBpbmZvO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICog5Yib5bu66IqC54K5XHJcbiAgICAgKiBAcGFyYW0gc3JjIOWbvueJh+i3r+W+hOOAguWtl+espuS4suOAglxyXG4gICAgICogQHBhcmFtIG9wdGlvbnMg55So5oi36Ieq5a6a5LmJ5Y+C5pWw44CC5YyF5ZCr77yac3VjY2Vzc+Wbnuiwg+OAgWVycm9y5Zue6LCD44CBb25jZeagh+ivhuOAglxyXG4gICAgICogQHBhcmFtIG5vdGljZSDlm57osIPnrZbnlaXjgIIg5Ye95pWw44CCXHJcbiAgICAgKiBAcGFyYW0gZ3JvdXAg57uE5L+h5oGv44CC5a+56LGh44CCe2NvdW50OiAwLCBzdWNjZXNzOiBbXSwgZXJyb3I6IFtdfVxyXG4gICAgICogQHBhcmFtIHRyIOWHuumUmemHjeivleasoeaVsOOAguaVsOWAvOOAgum7mOiupOS4ujDjgIJcclxuICAgICAqIEByZXR1cm5zIHt7fX1cclxuICAgICAqL1xyXG4gICAgSW1hZ2VQb29sLnByb3RvdHlwZS5jcmVhdGVOb2RlID0gZnVuY3Rpb24oc3JjLCBvcHRpb25zLCBub3RpY2UsIGdyb3VwLCB0cikge1xyXG4gICAgICAgIHZhciBub2RlID0ge307XHJcbiAgICAgICAgbm9kZS5zcmMgPSBzcmM7XHJcbiAgICAgICAgbm9kZS5vcHRpb25zID0gb3B0aW9ucztcclxuICAgICAgICBub2RlLm5vdGljZSA9IG5vdGljZTtcclxuICAgICAgICBub2RlLmdyb3VwID0gZ3JvdXA7XHJcbiAgICAgICAgbm9kZS50cmllcyA9IHRyIHx8IDA7XHJcbiAgICAgICAgcmV0dXJuIG5vZGU7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiDlkJHku7vliqHpk77ooajmnKvlsL7ov73liqDoioLngrlcclxuICAgICAqIEBwYXJhbSBub2RlIOiKgueCueOAguWvueixoeOAglxyXG4gICAgICovXHJcbiAgICBJbWFnZVBvb2wucHJvdG90eXBlLmFwcGVuZE5vZGUgPSBmdW5jdGlvbihub2RlKSB7XHJcbiAgICAgICAgLy/liKTmlq3pk77ooajmmK/lkKbkuLrnqbpcclxuICAgICAgICBpZiAoIXRoaXMubGlua0hlYWQpIHtcclxuICAgICAgICAgICAgdGhpcy5saW5rSGVhZCA9IG5vZGU7XHJcbiAgICAgICAgICAgIHRoaXMubGlua05vZGUgPSBub2RlO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMubGlua05vZGUubmV4dCA9IG5vZGU7XHJcbiAgICAgICAgICAgIHRoaXMubGlua05vZGUgPSBub2RlO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIOWIoOmZpOmTvuihqOWktFxyXG4gICAgICovXHJcbiAgICBJbWFnZVBvb2wucHJvdG90eXBlLnNoaWZ0Tm9kZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIC8v5Yik5pat6ZO+6KGo5piv5ZCm5a2Y5Zyo6IqC54K5XHJcbiAgICAgICAgaWYgKHRoaXMubGlua0hlYWQpIHtcclxuICAgICAgICAgICAgLy/kv67mlLnpk77ooajlpLRcclxuICAgICAgICAgICAgdGhpcy5saW5rSGVhZCA9IHRoaXMubGlua0hlYWQubmV4dCB8fCBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIOWvvOWHuuWvueWkluaOpeWPo1xyXG4gICAgICogQHBhcmFtIG1heCDmnIDlpKfov57mjqXmlbDjgILmlbDlgLzjgIJcclxuICAgICAqIEByZXR1cm5zIHt7bG9hZDogRnVuY3Rpb24sIGluZm86IEZ1bmN0aW9ufX1cclxuICAgICAqL1xyXG4gICAgdmFyIGluaXRJbWFnZVBvb2wgPSBmdW5jdGlvbihtYXgpIHtcclxuICAgICAgICBpZiAoIWluc3RhbmNlKSB7XHJcbiAgICAgICAgICAgIGluc3RhbmNlID0gbmV3IEltYWdlUG9vbChtYXgpO1xyXG4gICAgICAgICAgICBpbnN0YW5jZS5pbml0UG9vbCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICog5Yqg6L295Zu+54mHXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBsb2FkOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIGluc3RhbmNlLmxvYWQuYXBwbHkoaW5zdGFuY2UsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiDlhoXpg6jkv6Hmga9cclxuICAgICAgICAgICAgICogQHJldHVybnMgeyp8YW55fHZvaWR9XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBpbmZvOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBpbnN0YW5jZS5pbmZvLmNhbGwoaW5zdGFuY2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcblxyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7IGluaXRJbWFnZVBvb2w6IGluaXRJbWFnZVBvb2wgfVxyXG5cclxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2xpYi9maXNoLXRvcG8tY29yZS9saWIvSW1hZ2VQb29sLmpzXG4gKiogbW9kdWxlIGlkID0gOTVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlxuICAgIHJlcXVpcmUoJy4vZ3JhcGhpYycpO1xuICAgIHJlcXVpcmUoJy4uL3pyZW5kZXInKS5yZWdpc3RlclBhaW50ZXIoJ3ZtbCcsIHJlcXVpcmUoJy4vUGFpbnRlcicpKTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3pyZW5kZXIvbGliL3ZtbC92bWwuanNcbiAqKiBtb2R1bGUgaWQgPSA5NlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gaHR0cDovL3d3dy53My5vcmcvVFIvTk9URS1WTUxcbi8vIFRPRE8gVXNlIHByb3h5IGxpa2Ugc3ZnIGluc3RlYWQgb2Ygb3ZlcndyaXRlIGJydXNoIG1ldGhvZHNcblxuXG5pZiAoIXJlcXVpcmUoJy4uL2NvcmUvZW52JykuY2FudmFzU3VwcG9ydGVkKSB7XG4gICAgdmFyIHZlYzIgPSByZXF1aXJlKCcuLi9jb3JlL3ZlY3RvcicpO1xuICAgIHZhciBCb3VuZGluZ1JlY3QgPSByZXF1aXJlKCcuLi9jb3JlL0JvdW5kaW5nUmVjdCcpO1xuICAgIHZhciBDTUQgPSByZXF1aXJlKCcuLi9jb3JlL1BhdGhQcm94eScpLkNNRDtcbiAgICB2YXIgY29sb3JUb29sID0gcmVxdWlyZSgnLi4vdG9vbC9jb2xvcicpO1xuICAgIHZhciB0ZXh0Q29udGFpbiA9IHJlcXVpcmUoJy4uL2NvbnRhaW4vdGV4dCcpO1xuICAgIHZhciBSZWN0VGV4dCA9IHJlcXVpcmUoJy4uL2dyYXBoaWMvbWl4aW4vUmVjdFRleHQnKTtcbiAgICB2YXIgRGlzcGxheWFibGUgPSByZXF1aXJlKCcuLi9ncmFwaGljL0Rpc3BsYXlhYmxlJyk7XG4gICAgdmFyIFpJbWFnZSA9IHJlcXVpcmUoJy4uL2dyYXBoaWMvSW1hZ2UnKTtcbiAgICB2YXIgVGV4dCA9IHJlcXVpcmUoJy4uL2dyYXBoaWMvVGV4dCcpO1xuICAgIHZhciBQYXRoID0gcmVxdWlyZSgnLi4vZ3JhcGhpYy9QYXRoJyk7XG5cbiAgICB2YXIgR3JhZGllbnQgPSByZXF1aXJlKCcuLi9ncmFwaGljL0dyYWRpZW50Jyk7XG5cbiAgICB2YXIgdm1sQ29yZSA9IHJlcXVpcmUoJy4vY29yZScpO1xuXG4gICAgdmFyIHJvdW5kID0gTWF0aC5yb3VuZDtcbiAgICB2YXIgc3FydCA9IE1hdGguc3FydDtcbiAgICB2YXIgYWJzID0gTWF0aC5hYnM7XG4gICAgdmFyIGNvcyA9IE1hdGguY29zO1xuICAgIHZhciBzaW4gPSBNYXRoLnNpbjtcbiAgICB2YXIgbWF0aE1heCA9IE1hdGgubWF4O1xuXG4gICAgdmFyIGFwcGx5VHJhbnNmb3JtID0gdmVjMi5hcHBseVRyYW5zZm9ybTtcblxuICAgIHZhciBjb21tYSA9ICcsJztcbiAgICB2YXIgaW1hZ2VUcmFuc2Zvcm1QcmVmaXggPSAncHJvZ2lkOkRYSW1hZ2VUcmFuc2Zvcm0uTWljcm9zb2Z0JztcblxuICAgIHZhciBaID0gMjE2MDA7XG4gICAgdmFyIFoyID0gWiAvIDI7XG5cbiAgICB2YXIgWkxFVkVMX0JBU0UgPSAxMDAwMDA7XG4gICAgdmFyIFpfQkFTRSA9IDEwMDA7XG5cbiAgICB2YXIgaW5pdFJvb3RFbFN0eWxlID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgIGVsLnN0eWxlLmNzc1RleHQgPSAncG9zaXRpb246YWJzb2x1dGU7bGVmdDowO3RvcDowO3dpZHRoOjFweDtoZWlnaHQ6MXB4Oyc7XG4gICAgICAgIGVsLmNvb3Jkc2l6ZSA9IFogKyAnLCcgICsgWjtcbiAgICAgICAgZWwuY29vcmRvcmlnaW4gPSAnMCwwJztcbiAgICB9O1xuXG4gICAgdmFyIGVuY29kZUh0bWxBdHRyaWJ1dGUgPSBmdW5jdGlvbiAocykge1xuICAgICAgICByZXR1cm4gU3RyaW5nKHMpLnJlcGxhY2UoLyYvZywgJyZhbXA7JykucmVwbGFjZSgvXCIvZywgJyZxdW90OycpO1xuICAgIH07XG5cbiAgICB2YXIgcmdiMlN0ciA9IGZ1bmN0aW9uIChyLCBnLCBiKSB7XG4gICAgICAgIHJldHVybiAncmdiKCcgKyBbciwgZywgYl0uam9pbignLCcpICsgJyknO1xuICAgIH07XG5cbiAgICB2YXIgYXBwZW5kID0gZnVuY3Rpb24gKHBhcmVudCwgY2hpbGQpIHtcbiAgICAgICAgaWYgKGNoaWxkICYmIHBhcmVudCAmJiBjaGlsZC5wYXJlbnROb2RlICE9PSBwYXJlbnQpIHtcbiAgICAgICAgICAgIHBhcmVudC5hcHBlbmRDaGlsZChjaGlsZCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIHJlbW92ZSA9IGZ1bmN0aW9uIChwYXJlbnQsIGNoaWxkKSB7XG4gICAgICAgIGlmIChjaGlsZCAmJiBwYXJlbnQgJiYgY2hpbGQucGFyZW50Tm9kZSA9PT0gcGFyZW50KSB7XG4gICAgICAgICAgICBwYXJlbnQucmVtb3ZlQ2hpbGQoY2hpbGQpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciBnZXRaSW5kZXggPSBmdW5jdGlvbiAoemxldmVsLCB6LCB6Mikge1xuICAgICAgICAvLyB6IOeahOWPluWAvOiMg+WbtOS4uiBbMCwgMTAwMF1cbiAgICAgICAgcmV0dXJuIChwYXJzZUZsb2F0KHpsZXZlbCkgfHwgMCkgKiBaTEVWRUxfQkFTRSArIChwYXJzZUZsb2F0KHopIHx8IDApICogWl9CQVNFICsgejI7XG4gICAgfTtcblxuICAgIHZhciBwYXJzZVBlcmNlbnQgPSBmdW5jdGlvbiAodmFsdWUsIG1heFZhbHVlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUubGFzdEluZGV4T2YoJyUnKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQodmFsdWUpIC8gMTAwICogbWF4VmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VGbG9hdCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG5cbiAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgICogUEFUSFxuICAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgIHZhciBzZXRDb2xvckFuZE9wYWNpdHkgPSBmdW5jdGlvbiAoZWwsIGNvbG9yLCBvcGFjaXR5KSB7XG4gICAgICAgIHZhciBjb2xvckFyciA9IGNvbG9yVG9vbC5wYXJzZShjb2xvcik7XG4gICAgICAgIG9wYWNpdHkgPSArb3BhY2l0eTtcbiAgICAgICAgaWYgKGlzTmFOKG9wYWNpdHkpKSB7XG4gICAgICAgICAgICBvcGFjaXR5ID0gMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29sb3JBcnIpIHtcbiAgICAgICAgICAgIGVsLmNvbG9yID0gcmdiMlN0cihjb2xvckFyclswXSwgY29sb3JBcnJbMV0sIGNvbG9yQXJyWzJdKTtcbiAgICAgICAgICAgIGVsLm9wYWNpdHkgPSBvcGFjaXR5ICogY29sb3JBcnJbM107XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIGdldENvbG9yQW5kQWxwaGEgPSBmdW5jdGlvbiAoY29sb3IpIHtcbiAgICAgICAgdmFyIGNvbG9yQXJyID0gY29sb3JUb29sLnBhcnNlKGNvbG9yKTtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHJnYjJTdHIoY29sb3JBcnJbMF0sIGNvbG9yQXJyWzFdLCBjb2xvckFyclsyXSksXG4gICAgICAgICAgICBjb2xvckFyclszXVxuICAgICAgICBdO1xuICAgIH07XG5cbiAgICB2YXIgdXBkYXRlRmlsbE5vZGUgPSBmdW5jdGlvbiAoZWwsIHN0eWxlLCB6ckVsKSB7XG4gICAgICAgIC8vIFRPRE8gcGF0dGVyblxuICAgICAgICB2YXIgZmlsbCA9IHN0eWxlLmZpbGw7XG4gICAgICAgIGlmIChmaWxsICE9IG51bGwpIHtcbiAgICAgICAgICAgIC8vIE1vZGlmaWVkIGZyb20gZXhjYW52YXNcbiAgICAgICAgICAgIGlmIChmaWxsIGluc3RhbmNlb2YgR3JhZGllbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgZ3JhZGllbnRUeXBlO1xuICAgICAgICAgICAgICAgIHZhciBhbmdsZSA9IDA7XG4gICAgICAgICAgICAgICAgdmFyIGZvY3VzID0gWzAsIDBdO1xuICAgICAgICAgICAgICAgIC8vIGFkZGl0aW9uYWwgb2Zmc2V0XG4gICAgICAgICAgICAgICAgdmFyIHNoaWZ0ID0gMDtcbiAgICAgICAgICAgICAgICAvLyBzY2FsZSBmYWN0b3IgZm9yIG9mZnNldFxuICAgICAgICAgICAgICAgIHZhciBleHBhbnNpb24gPSAxO1xuICAgICAgICAgICAgICAgIHZhciByZWN0ID0genJFbC5nZXRCb3VuZGluZ1JlY3QoKTtcbiAgICAgICAgICAgICAgICB2YXIgcmVjdFdpZHRoID0gcmVjdC53aWR0aDtcbiAgICAgICAgICAgICAgICB2YXIgcmVjdEhlaWdodCA9IHJlY3QuaGVpZ2h0O1xuICAgICAgICAgICAgICAgIGlmIChmaWxsLnR5cGUgPT09ICdsaW5lYXInKSB7XG4gICAgICAgICAgICAgICAgICAgIGdyYWRpZW50VHlwZSA9ICdncmFkaWVudCc7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0cmFuc2Zvcm0gPSB6ckVsLnRyYW5zZm9ybTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHAwID0gW2ZpbGwueCAqIHJlY3RXaWR0aCwgZmlsbC55ICogcmVjdEhlaWdodF07XG4gICAgICAgICAgICAgICAgICAgIHZhciBwMSA9IFtmaWxsLngyICogcmVjdFdpZHRoLCBmaWxsLnkyICogcmVjdEhlaWdodF07XG4gICAgICAgICAgICAgICAgICAgIGlmICh0cmFuc2Zvcm0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFwcGx5VHJhbnNmb3JtKHAwLCBwMCwgdHJhbnNmb3JtKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFwcGx5VHJhbnNmb3JtKHAxLCBwMSwgdHJhbnNmb3JtKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgZHggPSBwMVswXSAtIHAwWzBdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZHkgPSBwMVsxXSAtIHAwWzFdO1xuICAgICAgICAgICAgICAgICAgICBhbmdsZSA9IE1hdGguYXRhbjIoZHgsIGR5KSAqIDE4MCAvIE1hdGguUEk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSBhbmdsZSBzaG91bGQgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyLlxuICAgICAgICAgICAgICAgICAgICBpZiAoYW5nbGUgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbmdsZSArPSAzNjA7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBWZXJ5IHNtYWxsIGFuZ2xlcyBwcm9kdWNlIGFuIHVuZXhwZWN0ZWQgcmVzdWx0IGJlY2F1c2UgdGhleSBhcmVcbiAgICAgICAgICAgICAgICAgICAgLy8gY29udmVydGVkIHRvIGEgc2NpZW50aWZpYyBub3RhdGlvbiBzdHJpbmcuXG4gICAgICAgICAgICAgICAgICAgIGlmIChhbmdsZSA8IDFlLTYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFuZ2xlID0gMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZ3JhZGllbnRUeXBlID0gJ2dyYWRpZW50cmFkaWFsJztcbiAgICAgICAgICAgICAgICAgICAgdmFyIHAwID0gW2ZpbGwueCAqIHJlY3RXaWR0aCwgZmlsbC55ICogcmVjdEhlaWdodF07XG4gICAgICAgICAgICAgICAgICAgIHZhciB0cmFuc2Zvcm0gPSB6ckVsLnRyYW5zZm9ybTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNjYWxlID0genJFbC5zY2FsZTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHdpZHRoID0gcmVjdFdpZHRoO1xuICAgICAgICAgICAgICAgICAgICB2YXIgaGVpZ2h0ID0gcmVjdEhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgZm9jdXMgPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBQZXJjZW50IGluIGJvdW5kaW5nIHJlY3RcbiAgICAgICAgICAgICAgICAgICAgICAgIChwMFswXSAtIHJlY3QueCkgLyB3aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIChwMFsxXSAtIHJlY3QueSkgLyBoZWlnaHRcbiAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRyYW5zZm9ybSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXBwbHlUcmFuc2Zvcm0ocDAsIHAwLCB0cmFuc2Zvcm0pO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgd2lkdGggLz0gc2NhbGVbMF0gKiBaO1xuICAgICAgICAgICAgICAgICAgICBoZWlnaHQgLz0gc2NhbGVbMV0gKiBaO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGltZW5zaW9uID0gbWF0aE1heCh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgc2hpZnQgPSAyICogMCAvIGRpbWVuc2lvbjtcbiAgICAgICAgICAgICAgICAgICAgZXhwYW5zaW9uID0gMiAqIGZpbGwuciAvIGRpbWVuc2lvbiAtIHNoaWZ0O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gc29ydCB0aGUgY29sb3Igc3RvcHMgaW4gYXNjZW5kaW5nIG9yZGVyIGJ5IG9mZnNldCxcbiAgICAgICAgICAgICAgICAvLyBvdGhlcndpc2UgSUUgd29uJ3QgaW50ZXJwcmV0IGl0IGNvcnJlY3RseS5cbiAgICAgICAgICAgICAgICB2YXIgc3RvcHMgPSBmaWxsLmNvbG9yU3RvcHMuc2xpY2UoKTtcbiAgICAgICAgICAgICAgICBzdG9wcy5zb3J0KGZ1bmN0aW9uKGNzMSwgY3MyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjczEub2Zmc2V0IC0gY3MyLm9mZnNldDtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIHZhciBsZW5ndGggPSBzdG9wcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgLy8gQ29sb3IgYW5kIGFscGhhIGxpc3Qgb2YgZmlyc3QgYW5kIGxhc3Qgc3RvcFxuICAgICAgICAgICAgICAgIHZhciBjb2xvckFuZEFscGhhTGlzdCA9IFtdO1xuICAgICAgICAgICAgICAgIHZhciBjb2xvcnMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzdG9wID0gc3RvcHNbaV07XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb2xvckFuZEFscGhhID0gZ2V0Q29sb3JBbmRBbHBoYShzdG9wLmNvbG9yKTtcbiAgICAgICAgICAgICAgICAgICAgY29sb3JzLnB1c2goc3RvcC5vZmZzZXQgKiBleHBhbnNpb24gKyBzaGlmdCArICcgJyArIGNvbG9yQW5kQWxwaGFbMF0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaSA9PT0gMCB8fCBpID09PSBsZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvckFuZEFscGhhTGlzdC5wdXNoKGNvbG9yQW5kQWxwaGEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGxlbmd0aCA+PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb2xvcjEgPSBjb2xvckFuZEFscGhhTGlzdFswXVswXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbG9yMiA9IGNvbG9yQW5kQWxwaGFMaXN0WzFdWzBdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgb3BhY2l0eTEgPSBjb2xvckFuZEFscGhhTGlzdFswXVsxXSAqIHN0eWxlLm9wYWNpdHk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBvcGFjaXR5MiA9IGNvbG9yQW5kQWxwaGFMaXN0WzFdWzFdICogc3R5bGUub3BhY2l0eTtcblxuICAgICAgICAgICAgICAgICAgICBlbC50eXBlID0gZ3JhZGllbnRUeXBlO1xuICAgICAgICAgICAgICAgICAgICBlbC5tZXRob2QgPSAnbm9uZSc7XG4gICAgICAgICAgICAgICAgICAgIGVsLmZvY3VzID0gJzEwMCUnO1xuICAgICAgICAgICAgICAgICAgICBlbC5hbmdsZSA9IGFuZ2xlO1xuICAgICAgICAgICAgICAgICAgICBlbC5jb2xvciA9IGNvbG9yMTtcbiAgICAgICAgICAgICAgICAgICAgZWwuY29sb3IyID0gY29sb3IyO1xuICAgICAgICAgICAgICAgICAgICBlbC5jb2xvcnMgPSBjb2xvcnMuam9pbignLCcpO1xuICAgICAgICAgICAgICAgICAgICAvLyBXaGVuIGNvbG9ycyBhdHRyaWJ1dGUgaXMgdXNlZCwgdGhlIG1lYW5pbmdzIG9mIG9wYWNpdHkgYW5kIG86b3BhY2l0eTJcbiAgICAgICAgICAgICAgICAgICAgLy8gYXJlIHJldmVyc2VkLlxuICAgICAgICAgICAgICAgICAgICBlbC5vcGFjaXR5ID0gb3BhY2l0eTI7XG4gICAgICAgICAgICAgICAgICAgIC8vIEZJWE1FIGdfb186b3BhY2l0eSA/XG4gICAgICAgICAgICAgICAgICAgIGVsLm9wYWNpdHkyID0gb3BhY2l0eTE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChncmFkaWVudFR5cGUgPT09ICdyYWRpYWwnKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsLmZvY3VzcG9zaXRpb24gPSBmb2N1cy5qb2luKCcsJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gRklYTUUgQ2hhbmdlIGZyb20gR3JhZGllbnQgZmlsbCB0byBjb2xvciBmaWxsXG4gICAgICAgICAgICAgICAgc2V0Q29sb3JBbmRPcGFjaXR5KGVsLCBmaWxsLCBzdHlsZS5vcGFjaXR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgdXBkYXRlU3Ryb2tlTm9kZSA9IGZ1bmN0aW9uIChlbCwgc3R5bGUpIHtcbiAgICAgICAgLy8gaWYgKHN0eWxlLmxpbmVKb2luICE9IG51bGwpIHtcbiAgICAgICAgLy8gICAgIGVsLmpvaW5zdHlsZSA9IHN0eWxlLmxpbmVKb2luO1xuICAgICAgICAvLyB9XG4gICAgICAgIC8vIGlmIChzdHlsZS5taXRlckxpbWl0ICE9IG51bGwpIHtcbiAgICAgICAgLy8gICAgIGVsLm1pdGVybGltaXQgPSBzdHlsZS5taXRlckxpbWl0ICogWjtcbiAgICAgICAgLy8gfVxuICAgICAgICAvLyBpZiAoc3R5bGUubGluZUNhcCAhPSBudWxsKSB7XG4gICAgICAgIC8vICAgICBlbC5lbmRjYXAgPSBzdHlsZS5saW5lQ2FwO1xuICAgICAgICAvLyB9XG4gICAgICAgIGlmIChzdHlsZS5saW5lRGFzaCAhPSBudWxsKSB7XG4gICAgICAgICAgICBlbC5kYXNoc3R5bGUgPSBzdHlsZS5saW5lRGFzaC5qb2luKCcgJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0eWxlLnN0cm9rZSAhPSBudWxsICYmICEoc3R5bGUuc3Ryb2tlIGluc3RhbmNlb2YgR3JhZGllbnQpKSB7XG4gICAgICAgICAgICBzZXRDb2xvckFuZE9wYWNpdHkoZWwsIHN0eWxlLnN0cm9rZSwgc3R5bGUub3BhY2l0eSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIHVwZGF0ZUZpbGxBbmRTdHJva2UgPSBmdW5jdGlvbiAodm1sRWwsIHR5cGUsIHN0eWxlLCB6ckVsKSB7XG4gICAgICAgIHZhciBpc0ZpbGwgPSB0eXBlID09ICdmaWxsJztcbiAgICAgICAgdmFyIGVsID0gdm1sRWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUodHlwZSlbMF07XG4gICAgICAgIC8vIFN0cm9rZSBtdXN0IGhhdmUgbGluZVdpZHRoXG4gICAgICAgIGlmIChzdHlsZVt0eXBlXSAhPSBudWxsICYmIHN0eWxlW3R5cGVdICE9PSAnbm9uZScgJiYgKGlzRmlsbCB8fCAoIWlzRmlsbCAmJiBzdHlsZS5saW5lV2lkdGgpKSkge1xuICAgICAgICAgICAgdm1sRWxbaXNGaWxsID8gJ2ZpbGxlZCcgOiAnc3Ryb2tlZCddID0gJ3RydWUnO1xuICAgICAgICAgICAgLy8gRklYTUUgUmVtb3ZlIGJlZm9yZSB1cGRhdGluZywgb3Igc2V0IGBjb2xvcnNgIHdpbGwgdGhyb3cgZXJyb3JcbiAgICAgICAgICAgIGlmIChzdHlsZVt0eXBlXSBpbnN0YW5jZW9mIEdyYWRpZW50KSB7XG4gICAgICAgICAgICAgICAgcmVtb3ZlKHZtbEVsLCBlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWVsKSB7XG4gICAgICAgICAgICAgICAgZWwgPSB2bWxDb3JlLmNyZWF0ZU5vZGUodHlwZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlzRmlsbCA/IHVwZGF0ZUZpbGxOb2RlKGVsLCBzdHlsZSwgenJFbCkgOiB1cGRhdGVTdHJva2VOb2RlKGVsLCBzdHlsZSk7XG4gICAgICAgICAgICBhcHBlbmQodm1sRWwsIGVsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZtbEVsW2lzRmlsbCA/ICdmaWxsZWQnIDogJ3N0cm9rZWQnXSA9ICdmYWxzZSc7XG4gICAgICAgICAgICByZW1vdmUodm1sRWwsIGVsKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgcG9pbnRzID0gW1tdLCBbXSwgW11dO1xuICAgIHZhciBwYXRoRGF0YVRvU3RyaW5nID0gZnVuY3Rpb24gKGRhdGEsIG0pIHtcbiAgICAgICAgdmFyIE0gPSBDTUQuTTtcbiAgICAgICAgdmFyIEMgPSBDTUQuQztcbiAgICAgICAgdmFyIEwgPSBDTUQuTDtcbiAgICAgICAgdmFyIEEgPSBDTUQuQTtcbiAgICAgICAgdmFyIFEgPSBDTUQuUTtcblxuICAgICAgICB2YXIgc3RyID0gW107XG4gICAgICAgIHZhciBuUG9pbnQ7XG4gICAgICAgIHZhciBjbWRTdHI7XG4gICAgICAgIHZhciBjbWQ7XG4gICAgICAgIHZhciBpO1xuICAgICAgICB2YXIgeGk7XG4gICAgICAgIHZhciB5aTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGRhdGEubGVuZ3RoOykge1xuICAgICAgICAgICAgY21kID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgY21kU3RyID0gJyc7XG4gICAgICAgICAgICBuUG9pbnQgPSAwO1xuICAgICAgICAgICAgc3dpdGNoIChjbWQpIHtcbiAgICAgICAgICAgICAgICBjYXNlIE06XG4gICAgICAgICAgICAgICAgICAgIGNtZFN0ciA9ICcgbSAnO1xuICAgICAgICAgICAgICAgICAgICBuUG9pbnQgPSAxO1xuICAgICAgICAgICAgICAgICAgICB4aSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgeWkgPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgIHBvaW50c1swXVswXSA9IHhpO1xuICAgICAgICAgICAgICAgICAgICBwb2ludHNbMF1bMV0gPSB5aTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBMOlxuICAgICAgICAgICAgICAgICAgICBjbWRTdHIgPSAnIGwgJztcbiAgICAgICAgICAgICAgICAgICAgblBvaW50ID0gMTtcbiAgICAgICAgICAgICAgICAgICAgeGkgPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgIHlpID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICBwb2ludHNbMF1bMF0gPSB4aTtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRzWzBdWzFdID0geWk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgUTpcbiAgICAgICAgICAgICAgICBjYXNlIEM6XG4gICAgICAgICAgICAgICAgICAgIGNtZFN0ciA9ICcgYyAnO1xuICAgICAgICAgICAgICAgICAgICBuUG9pbnQgPSAzO1xuICAgICAgICAgICAgICAgICAgICB2YXIgeDEgPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgIHZhciB5MSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHgyID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgeTIgPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgIHZhciB4MztcbiAgICAgICAgICAgICAgICAgICAgdmFyIHkzO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY21kID09PSBRKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDb252ZXJ0IHF1YWRyYXRpYyB0byBjdWJpYyB1c2luZyBkZWdyZWUgZWxldmF0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICB4MyA9IHgyO1xuICAgICAgICAgICAgICAgICAgICAgICAgeTMgPSB5MjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHgyID0gKHgyICsgMiAqIHgxKSAvIDM7XG4gICAgICAgICAgICAgICAgICAgICAgICB5MiA9ICh5MiArIDIgKiB5MSkgLyAzO1xuICAgICAgICAgICAgICAgICAgICAgICAgeDEgPSAoeGkgKyAyICogeDEpIC8gMztcbiAgICAgICAgICAgICAgICAgICAgICAgIHkxID0gKHlpICsgMiAqIHkxKSAvIDM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4MyA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHkzID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHBvaW50c1swXVswXSA9IHgxO1xuICAgICAgICAgICAgICAgICAgICBwb2ludHNbMF1bMV0gPSB5MTtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRzWzFdWzBdID0geDI7XG4gICAgICAgICAgICAgICAgICAgIHBvaW50c1sxXVsxXSA9IHkyO1xuICAgICAgICAgICAgICAgICAgICBwb2ludHNbMl1bMF0gPSB4MztcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRzWzJdWzFdID0geTM7XG5cbiAgICAgICAgICAgICAgICAgICAgeGkgPSB4MztcbiAgICAgICAgICAgICAgICAgICAgeWkgPSB5MztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBBOlxuICAgICAgICAgICAgICAgICAgICB2YXIgeCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHZhciB5ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN4ID0gMTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN5ID0gMTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFuZ2xlID0gMDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEV4dHJhY3QgU1JUIGZyb20gbWF0cml4XG4gICAgICAgICAgICAgICAgICAgICAgICB4ID0gbVs0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHkgPSBtWzVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3ggPSBzcXJ0KG1bMF0gKiBtWzBdICsgbVsxXSAqIG1bMV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3kgPSBzcXJ0KG1bMl0gKiBtWzJdICsgbVszXSAqIG1bM10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYW5nbGUgPSBNYXRoLmF0YW4yKC1tWzFdIC8gc3ksIG1bMF0gLyBzeCk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB2YXIgY3ggPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgIHZhciBjeSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJ4ID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcnkgPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgIHZhciBzdGFydEFuZ2xlID0gZGF0YVtpKytdICsgYW5nbGU7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlbmRBbmdsZSA9IGRhdGFbaSsrXSArIHN0YXJ0QW5nbGUgKyBhbmdsZTtcbiAgICAgICAgICAgICAgICAgICAgLy8gRklYTUVcbiAgICAgICAgICAgICAgICAgICAgLy8gdmFyIHBzaSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2xvY2t3aXNlID0gZGF0YVtpKytdO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciB4MCA9IGN4ICsgY29zKHN0YXJ0QW5nbGUpICogcng7XG4gICAgICAgICAgICAgICAgICAgIHZhciB5MCA9IGN5ICsgc2luKHN0YXJ0QW5nbGUpICogcnk7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHgxID0gY3ggKyBjb3MoZW5kQW5nbGUpICogcng7XG4gICAgICAgICAgICAgICAgICAgIHZhciB5MSA9IGN5ICsgc2luKGVuZEFuZ2xlKSAqIHJ5O1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciB0eXBlID0gY2xvY2t3aXNlID8gJyB3YSAnIDogJyBhdCAnO1xuICAgICAgICAgICAgICAgICAgICBpZiAoTWF0aC5hYnMoeDAgLSB4MSkgPCAxZS0xMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSUUgd29uJ3QgcmVuZGVyIGFyY2hlcyBkcmF3biBjb3VudGVyIGNsb2Nrd2lzZSBpZiB4MCA9PSB4MS5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyhlbmRBbmdsZSAtIHN0YXJ0QW5nbGUpID4gMWUtMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9mZnNldCB4MCBieSAxLzgwIG9mIGEgcGl4ZWwuIFVzZSBzb21ldGhpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGF0IGNhbiBiZSByZXByZXNlbnRlZCBpbiBiaW5hcnlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2xvY2t3aXNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHgwICs9IDI3MCAvIFo7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQXZvaWQgY2FzZSBkcmF3IGZ1bGwgY2lyY2xlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKE1hdGguYWJzKHkwIC0gY3kpIDwgMWUtMTApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChjbG9ja3dpc2UgJiYgeDAgPCBjeCkgfHwgKCFjbG9ja3dpc2UgJiYgeDAgPiBjeCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkxIC09IDI3MCAvIFo7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5MSArPSAyNzAgLyBaO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKChjbG9ja3dpc2UgJiYgeTAgPCBjeSkgfHwgKCFjbG9ja3dpc2UgJiYgeTAgPiBjeSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeDEgKz0gMjcwIC8gWjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHgxIC09IDI3MCAvIFo7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHN0ci5wdXNoKFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdW5kKCgoY3ggLSByeCkgKiBzeCArIHgpICogWiAtIFoyKSwgY29tbWEsXG4gICAgICAgICAgICAgICAgICAgICAgICByb3VuZCgoKGN5IC0gcnkpICogc3kgKyB5KSAqIFogLSBaMiksIGNvbW1hLFxuICAgICAgICAgICAgICAgICAgICAgICAgcm91bmQoKChjeCArIHJ4KSAqIHN4ICsgeCkgKiBaIC0gWjIpLCBjb21tYSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdW5kKCgoY3kgKyByeSkgKiBzeSArIHkpICogWiAtIFoyKSwgY29tbWEsXG4gICAgICAgICAgICAgICAgICAgICAgICByb3VuZCgoeDAgKiBzeCArIHgpICogWiAtIFoyKSwgY29tbWEsXG4gICAgICAgICAgICAgICAgICAgICAgICByb3VuZCgoeTAgKiBzeSArIHkpICogWiAtIFoyKSwgY29tbWEsXG4gICAgICAgICAgICAgICAgICAgICAgICByb3VuZCgoeDEgKiBzeCArIHgpICogWiAtIFoyKSwgY29tbWEsXG4gICAgICAgICAgICAgICAgICAgICAgICByb3VuZCgoeTEgKiBzeSArIHkpICogWiAtIFoyKVxuICAgICAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgICAgIHhpID0geDE7XG4gICAgICAgICAgICAgICAgICAgIHlpID0geTE7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgQ01ELlI6XG4gICAgICAgICAgICAgICAgICAgIHZhciBwMCA9IHBvaW50c1swXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHAxID0gcG9pbnRzWzFdO1xuICAgICAgICAgICAgICAgICAgICAvLyB4MCwgeTBcbiAgICAgICAgICAgICAgICAgICAgcDBbMF0gPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgIHAwWzFdID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICAvLyB4MSwgeTFcbiAgICAgICAgICAgICAgICAgICAgcDFbMF0gPSBwMFswXSArIGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgcDFbMV0gPSBwMFsxXSArIGRhdGFbaSsrXTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAobSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXBwbHlUcmFuc2Zvcm0ocDAsIHAwLCBtKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFwcGx5VHJhbnNmb3JtKHAxLCBwMSwgbSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBwMFswXSA9IHJvdW5kKHAwWzBdICogWiAtIFoyKTtcbiAgICAgICAgICAgICAgICAgICAgcDFbMF0gPSByb3VuZChwMVswXSAqIFogLSBaMik7XG4gICAgICAgICAgICAgICAgICAgIHAwWzFdID0gcm91bmQocDBbMV0gKiBaIC0gWjIpO1xuICAgICAgICAgICAgICAgICAgICBwMVsxXSA9IHJvdW5kKHAxWzFdICogWiAtIFoyKTtcbiAgICAgICAgICAgICAgICAgICAgc3RyLnB1c2goXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB4MCwgeTBcbiAgICAgICAgICAgICAgICAgICAgICAgICcgbSAnLCBwMFswXSwgY29tbWEsIHAwWzFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8geDEsIHkwXG4gICAgICAgICAgICAgICAgICAgICAgICAnIGwgJywgcDFbMF0sIGNvbW1hLCBwMFsxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHgxLCB5MVxuICAgICAgICAgICAgICAgICAgICAgICAgJyBsICcsIHAxWzBdLCBjb21tYSwgcDFbMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB4MCwgeTFcbiAgICAgICAgICAgICAgICAgICAgICAgICcgbCAnLCBwMFswXSwgY29tbWEsIHAxWzFdXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgQ01ELlo6XG4gICAgICAgICAgICAgICAgICAgIC8vIEZJWE1FIFVwZGF0ZSB4aSwgeWlcbiAgICAgICAgICAgICAgICAgICAgc3RyLnB1c2goJyB4ICcpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoblBvaW50ID4gMCkge1xuICAgICAgICAgICAgICAgIHN0ci5wdXNoKGNtZFN0cik7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBuUG9pbnQ7IGsrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcCA9IHBvaW50c1trXTtcblxuICAgICAgICAgICAgICAgICAgICBtICYmIGFwcGx5VHJhbnNmb3JtKHAsIHAsIG0pO1xuICAgICAgICAgICAgICAgICAgICAvLyDkuI0gcm91bmQg5Lya6Z2e5bi45oWiXG4gICAgICAgICAgICAgICAgICAgIHN0ci5wdXNoKFxuICAgICAgICAgICAgICAgICAgICAgICAgcm91bmQocFswXSAqIFogLSBaMiksIGNvbW1hLCByb3VuZChwWzFdICogWiAtIFoyKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGsgPCBuUG9pbnQgLSAxID8gY29tbWEgOiAnJ1xuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzdHIuam9pbignJyk7XG4gICAgfTtcblxuICAgIC8vIFJld3JpdGUgdGhlIG9yaWdpbmFsIHBhdGggbWV0aG9kXG4gICAgUGF0aC5wcm90b3R5cGUuYnJ1c2hWTUwgPSBmdW5jdGlvbiAodm1sUm9vdCkge1xuICAgICAgICB2YXIgc3R5bGUgPSB0aGlzLnN0eWxlO1xuXG4gICAgICAgIHZhciB2bWxFbCA9IHRoaXMuX3ZtbEVsO1xuICAgICAgICBpZiAoIXZtbEVsKSB7XG4gICAgICAgICAgICB2bWxFbCA9IHZtbENvcmUuY3JlYXRlTm9kZSgnc2hhcGUnKTtcbiAgICAgICAgICAgIGluaXRSb290RWxTdHlsZSh2bWxFbCk7XG5cbiAgICAgICAgICAgIHRoaXMuX3ZtbEVsID0gdm1sRWw7XG4gICAgICAgIH1cblxuICAgICAgICB1cGRhdGVGaWxsQW5kU3Ryb2tlKHZtbEVsLCAnZmlsbCcsIHN0eWxlLCB0aGlzKTtcbiAgICAgICAgdXBkYXRlRmlsbEFuZFN0cm9rZSh2bWxFbCwgJ3N0cm9rZScsIHN0eWxlLCB0aGlzKTtcblxuICAgICAgICB2YXIgbSA9IHRoaXMudHJhbnNmb3JtO1xuICAgICAgICB2YXIgbmVlZFRyYW5zZm9ybSA9IG0gIT0gbnVsbDtcbiAgICAgICAgdmFyIHN0cm9rZUVsID0gdm1sRWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3N0cm9rZScpWzBdO1xuICAgICAgICBpZiAoc3Ryb2tlRWwpIHtcbiAgICAgICAgICAgIHZhciBsaW5lV2lkdGggPSBzdHlsZS5saW5lV2lkdGg7XG4gICAgICAgICAgICAvLyBHZXQgdGhlIGxpbmUgc2NhbGUuXG4gICAgICAgICAgICAvLyBEZXRlcm1pbmFudCBvZiB0aGlzLm1fIG1lYW5zIGhvdyBtdWNoIHRoZSBhcmVhIGlzIGVubGFyZ2VkIGJ5IHRoZVxuICAgICAgICAgICAgLy8gdHJhbnNmb3JtYXRpb24uIFNvIGl0cyBzcXVhcmUgcm9vdCBjYW4gYmUgdXNlZCBhcyBhIHNjYWxlIGZhY3RvclxuICAgICAgICAgICAgLy8gZm9yIHdpZHRoLlxuICAgICAgICAgICAgaWYgKG5lZWRUcmFuc2Zvcm0gJiYgIXN0eWxlLnN0cm9rZU5vU2NhbGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGV0ID0gbVswXSAqIG1bM10gLSBtWzFdICogbVsyXTtcbiAgICAgICAgICAgICAgICBsaW5lV2lkdGggKj0gc3FydChhYnMoZGV0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdHJva2VFbC53ZWlnaHQgPSBsaW5lV2lkdGggKyAncHgnO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHBhdGggPSB0aGlzLnBhdGg7XG4gICAgICAgIGlmICh0aGlzLl9fZGlydHlQYXRoKSB7XG4gICAgICAgICAgICBwYXRoLmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgdGhpcy5idWlsZFBhdGgocGF0aCwgdGhpcy5zaGFwZSk7XG4gICAgICAgICAgICBwYXRoLnRvU3RhdGljKCk7XG4gICAgICAgICAgICB0aGlzLl9fZGlydHlQYXRoID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICB2bWxFbC5wYXRoID0gcGF0aERhdGFUb1N0cmluZyhwYXRoLmRhdGEsIHRoaXMudHJhbnNmb3JtKTtcblxuICAgICAgICB2bWxFbC5zdHlsZS56SW5kZXggPSBnZXRaSW5kZXgodGhpcy56bGV2ZWwsIHRoaXMueiwgdGhpcy56Mik7XG5cbiAgICAgICAgLy8gQXBwZW5kIHRvIHJvb3RcbiAgICAgICAgYXBwZW5kKHZtbFJvb3QsIHZtbEVsKTtcblxuICAgICAgICAvLyBUZXh0XG4gICAgICAgIGlmIChzdHlsZS50ZXh0KSB7XG4gICAgICAgICAgICB0aGlzLmRyYXdSZWN0VGV4dCh2bWxSb290LCB0aGlzLmdldEJvdW5kaW5nUmVjdCgpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlUmVjdFRleHQodm1sUm9vdCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgUGF0aC5wcm90b3R5cGUub25SZW1vdmUgPSBmdW5jdGlvbiAodm1sUm9vdCkge1xuICAgICAgICByZW1vdmUodm1sUm9vdCwgdGhpcy5fdm1sRWwpO1xuICAgICAgICB0aGlzLnJlbW92ZVJlY3RUZXh0KHZtbFJvb3QpO1xuICAgIH07XG5cbiAgICBQYXRoLnByb3RvdHlwZS5vbkFkZCA9IGZ1bmN0aW9uICh2bWxSb290KSB7XG4gICAgICAgIGFwcGVuZCh2bWxSb290LCB0aGlzLl92bWxFbCk7XG4gICAgICAgIHRoaXMuYXBwZW5kUmVjdFRleHQodm1sUm9vdCk7XG4gICAgfTtcblxuICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAgKiBJTUFHRVxuICAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgICB2YXIgaXNJbWFnZSA9IGZ1bmN0aW9uIChpbWcpIHtcbiAgICAgICAgLy8gRklYTUUgaW1nIGluc3RhbmNlb2YgSW1hZ2Ug5aaC5p6cIGltZyDmmK/kuIDkuKrlrZfnrKbkuLLnmoTml7blgJnvvIxJRTgg5LiL5Lya5oql6ZSZXG4gICAgICAgIHJldHVybiAodHlwZW9mIGltZyA9PT0gJ29iamVjdCcpICYmIGltZy50YWdOYW1lICYmIGltZy50YWdOYW1lLnRvVXBwZXJDYXNlKCkgPT09ICdJTUcnO1xuICAgICAgICAvLyByZXR1cm4gaW1nIGluc3RhbmNlb2YgSW1hZ2U7XG4gICAgfTtcblxuICAgIC8vIFJld3JpdGUgdGhlIG9yaWdpbmFsIHBhdGggbWV0aG9kXG4gICAgWkltYWdlLnByb3RvdHlwZS5icnVzaFZNTCA9IGZ1bmN0aW9uICh2bWxSb290KSB7XG4gICAgICAgIHZhciBzdHlsZSA9IHRoaXMuc3R5bGU7XG4gICAgICAgIHZhciBpbWFnZSA9IHN0eWxlLmltYWdlO1xuXG4gICAgICAgIC8vIEltYWdlIG9yaWdpbmFsIHdpZHRoLCBoZWlnaHRcbiAgICAgICAgdmFyIG93O1xuICAgICAgICB2YXIgb2g7XG5cbiAgICAgICAgaWYgKGlzSW1hZ2UoaW1hZ2UpKSB7XG4gICAgICAgICAgICB2YXIgc3JjID0gaW1hZ2Uuc3JjO1xuICAgICAgICAgICAgaWYgKHNyYyA9PT0gdGhpcy5faW1hZ2VTcmMpIHtcbiAgICAgICAgICAgICAgICBvdyA9IHRoaXMuX2ltYWdlV2lkdGg7XG4gICAgICAgICAgICAgICAgb2ggPSB0aGlzLl9pbWFnZUhlaWdodDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBpbWFnZVJ1bnRpbWVTdHlsZSA9IGltYWdlLnJ1bnRpbWVTdHlsZTtcbiAgICAgICAgICAgICAgICB2YXIgb2xkUnVudGltZVdpZHRoID0gaW1hZ2VSdW50aW1lU3R5bGUud2lkdGg7XG4gICAgICAgICAgICAgICAgdmFyIG9sZFJ1bnRpbWVIZWlnaHQgPSBpbWFnZVJ1bnRpbWVTdHlsZS5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgaW1hZ2VSdW50aW1lU3R5bGUud2lkdGggPSAnYXV0byc7XG4gICAgICAgICAgICAgICAgaW1hZ2VSdW50aW1lU3R5bGUuaGVpZ2h0ID0gJ2F1dG8nO1xuXG4gICAgICAgICAgICAgICAgLy8gZ2V0IHRoZSBvcmlnaW5hbCBzaXplXG4gICAgICAgICAgICAgICAgb3cgPSBpbWFnZS53aWR0aDtcbiAgICAgICAgICAgICAgICBvaCA9IGltYWdlLmhlaWdodDtcblxuICAgICAgICAgICAgICAgIC8vIGFuZCByZW1vdmUgb3ZlcmlkZXNcbiAgICAgICAgICAgICAgICBpbWFnZVJ1bnRpbWVTdHlsZS53aWR0aCA9IG9sZFJ1bnRpbWVXaWR0aDtcbiAgICAgICAgICAgICAgICBpbWFnZVJ1bnRpbWVTdHlsZS5oZWlnaHQgPSBvbGRSdW50aW1lSGVpZ2h0O1xuXG4gICAgICAgICAgICAgICAgLy8gQ2FjaGluZyBpbWFnZSBvcmlnaW5hbCB3aWR0aCwgaGVpZ2h0IGFuZCBzcmNcbiAgICAgICAgICAgICAgICB0aGlzLl9pbWFnZVNyYyA9IHNyYztcbiAgICAgICAgICAgICAgICB0aGlzLl9pbWFnZVdpZHRoID0gb3c7XG4gICAgICAgICAgICAgICAgdGhpcy5faW1hZ2VIZWlnaHQgPSBvaDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGltYWdlID0gc3JjO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGltYWdlID09PSB0aGlzLl9pbWFnZVNyYykge1xuICAgICAgICAgICAgICAgIG93ID0gdGhpcy5faW1hZ2VXaWR0aDtcbiAgICAgICAgICAgICAgICBvaCA9IHRoaXMuX2ltYWdlSGVpZ2h0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghaW1hZ2UpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB4ID0gc3R5bGUueCB8fCAwO1xuICAgICAgICB2YXIgeSA9IHN0eWxlLnkgfHwgMDtcblxuICAgICAgICB2YXIgZHcgPSBzdHlsZS53aWR0aDtcbiAgICAgICAgdmFyIGRoID0gc3R5bGUuaGVpZ2h0O1xuXG4gICAgICAgIHZhciBzdyA9IHN0eWxlLnNXaWR0aDtcbiAgICAgICAgdmFyIHNoID0gc3R5bGUuc0hlaWdodDtcbiAgICAgICAgdmFyIHN4ID0gc3R5bGUuc3ggfHwgMDtcbiAgICAgICAgdmFyIHN5ID0gc3R5bGUuc3kgfHwgMDtcblxuICAgICAgICB2YXIgaGFzQ3JvcCA9IHN3ICYmIHNoO1xuXG4gICAgICAgIHZhciB2bWxFbCA9IHRoaXMuX3ZtbEVsO1xuICAgICAgICBpZiAoIXZtbEVsKSB7XG4gICAgICAgICAgICAvLyBGSVhNRSDkvb/nlKggZ3JvdXAg5ZyoIGxlZnQsIHRvcCDpg73kuI3mmK8gMCDnmoTml7blgJnlsLHml6Dms5XmmL7npLrkuobjgIJcbiAgICAgICAgICAgIC8vIHZtbEVsID0gdm1sQ29yZS5jcmVhdGVOb2RlKCdncm91cCcpO1xuICAgICAgICAgICAgdm1sRWwgPSB2bWxDb3JlLmRvYy5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgIGluaXRSb290RWxTdHlsZSh2bWxFbCk7XG5cbiAgICAgICAgICAgIHRoaXMuX3ZtbEVsID0gdm1sRWw7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdm1sRWxTdHlsZSA9IHZtbEVsLnN0eWxlO1xuICAgICAgICB2YXIgaGFzUm90YXRpb24gPSBmYWxzZTtcbiAgICAgICAgdmFyIG07XG4gICAgICAgIHZhciBzY2FsZVggPSAxO1xuICAgICAgICB2YXIgc2NhbGVZID0gMTtcbiAgICAgICAgaWYgKHRoaXMudHJhbnNmb3JtKSB7XG4gICAgICAgICAgICBtID0gdGhpcy50cmFuc2Zvcm07XG4gICAgICAgICAgICBzY2FsZVggPSBzcXJ0KG1bMF0gKiBtWzBdICsgbVsxXSAqIG1bMV0pO1xuICAgICAgICAgICAgc2NhbGVZID0gc3FydChtWzJdICogbVsyXSArIG1bM10gKiBtWzNdKTtcblxuICAgICAgICAgICAgaGFzUm90YXRpb24gPSBtWzFdIHx8IG1bMl07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhhc1JvdGF0aW9uKSB7XG4gICAgICAgICAgICAvLyBJZiBmaWx0ZXJzIGFyZSBuZWNlc3NhcnkgKHJvdGF0aW9uIGV4aXN0cyksIGNyZWF0ZSB0aGVtXG4gICAgICAgICAgICAvLyBmaWx0ZXJzIGFyZSBib2ctc2xvdywgc28gb25seSBjcmVhdGUgdGhlbSBpZiBhYmJzb2x1dGVseSBuZWNlc3NhcnlcbiAgICAgICAgICAgIC8vIFRoZSBmb2xsb3dpbmcgY2hlY2sgZG9lc24ndCBhY2NvdW50IGZvciBza2V3cyAod2hpY2ggZG9uJ3QgZXhpc3RcbiAgICAgICAgICAgIC8vIGluIHRoZSBjYW52YXMgc3BlYyAoeWV0KSBhbnl3YXkuXG4gICAgICAgICAgICAvLyBGcm9tIGV4Y2FudmFzXG4gICAgICAgICAgICB2YXIgcDAgPSBbeCwgeV07XG4gICAgICAgICAgICB2YXIgcDEgPSBbeCArIGR3LCB5XTtcbiAgICAgICAgICAgIHZhciBwMiA9IFt4LCB5ICsgZGhdO1xuICAgICAgICAgICAgdmFyIHAzID0gW3ggKyBkdywgeSArIGRoXTtcbiAgICAgICAgICAgIGFwcGx5VHJhbnNmb3JtKHAwLCBwMCwgbSk7XG4gICAgICAgICAgICBhcHBseVRyYW5zZm9ybShwMSwgcDEsIG0pO1xuICAgICAgICAgICAgYXBwbHlUcmFuc2Zvcm0ocDIsIHAyLCBtKTtcbiAgICAgICAgICAgIGFwcGx5VHJhbnNmb3JtKHAzLCBwMywgbSk7XG5cbiAgICAgICAgICAgIHZhciBtYXhYID0gbWF0aE1heChwMFswXSwgcDFbMF0sIHAyWzBdLCBwM1swXSk7XG4gICAgICAgICAgICB2YXIgbWF4WSA9IG1hdGhNYXgocDBbMV0sIHAxWzFdLCBwMlsxXSwgcDNbMV0pO1xuXG4gICAgICAgICAgICB2YXIgdHJhbnNmb3JtRmlsdGVyID0gW107XG4gICAgICAgICAgICB0cmFuc2Zvcm1GaWx0ZXIucHVzaCgnTTExPScsIG1bMF0gLyBzY2FsZVgsIGNvbW1hLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ00xMj0nLCBtWzJdIC8gc2NhbGVZLCBjb21tYSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdNMjE9JywgbVsxXSAvIHNjYWxlWCwgY29tbWEsXG4gICAgICAgICAgICAgICAgICAgICAgICAnTTIyPScsIG1bM10gLyBzY2FsZVksIGNvbW1hLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0R4PScsIHJvdW5kKHggKiBzY2FsZVggKyBtWzRdKSwgY29tbWEsXG4gICAgICAgICAgICAgICAgICAgICAgICAnRHk9Jywgcm91bmQoeSAqIHNjYWxlWSArIG1bNV0pKTtcblxuICAgICAgICAgICAgdm1sRWxTdHlsZS5wYWRkaW5nID0gJzAgJyArIHJvdW5kKG1heFgpICsgJ3B4ICcgKyByb3VuZChtYXhZKSArICdweCAwJztcbiAgICAgICAgICAgIC8vIEZJWE1FIERYSW1hZ2VUcmFuc2Zvcm0g5ZyoIElFMTEg55qE5YW85a655qih5byP5LiL5LiN6LW35L2c55SoXG4gICAgICAgICAgICB2bWxFbFN0eWxlLmZpbHRlciA9IGltYWdlVHJhbnNmb3JtUHJlZml4ICsgJy5NYXRyaXgoJ1xuICAgICAgICAgICAgICAgICsgdHJhbnNmb3JtRmlsdGVyLmpvaW4oJycpICsgJywgU2l6aW5nTWV0aG9kPWNsaXApJztcblxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKG0pIHtcbiAgICAgICAgICAgICAgICB4ID0geCAqIHNjYWxlWCArIG1bNF07XG4gICAgICAgICAgICAgICAgeSA9IHkgKiBzY2FsZVkgKyBtWzVdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdm1sRWxTdHlsZS5maWx0ZXIgPSAnJztcbiAgICAgICAgICAgIHZtbEVsU3R5bGUubGVmdCA9IHJvdW5kKHgpICsgJ3B4JztcbiAgICAgICAgICAgIHZtbEVsU3R5bGUudG9wID0gcm91bmQoeSkgKyAncHgnO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGltYWdlRWwgPSB0aGlzLl9pbWFnZUVsO1xuICAgICAgICB2YXIgY3JvcEVsID0gdGhpcy5fY3JvcEVsO1xuXG4gICAgICAgIGlmICghaW1hZ2VFbCkge1xuICAgICAgICAgICAgaW1hZ2VFbCA9IHZtbENvcmUuZG9jLmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgdGhpcy5faW1hZ2VFbCA9IGltYWdlRWw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGltYWdlRUxTdHlsZSA9IGltYWdlRWwuc3R5bGU7XG4gICAgICAgIGlmIChoYXNDcm9wKSB7XG4gICAgICAgICAgICAvLyBOZWVkcyBrbm93IGltYWdlIG9yaWdpbmFsIHdpZHRoIGFuZCBoZWlnaHRcbiAgICAgICAgICAgIGlmICghIChvdyAmJiBvaCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgdG1wSW1hZ2UgPSBuZXcgSW1hZ2UoKTtcbiAgICAgICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICAgICAgdG1wSW1hZ2Uub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB0bXBJbWFnZS5vbmxvYWQgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBvdyA9IHRtcEltYWdlLndpZHRoO1xuICAgICAgICAgICAgICAgICAgICBvaCA9IHRtcEltYWdlLmhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgLy8gQWRqdXN0IGltYWdlIHdpZHRoIGFuZCBoZWlnaHQgdG8gZml0IHRoZSByYXRpbyBkZXN0aW5hdGlvblNpemUgLyBzb3VyY2VTaXplXG4gICAgICAgICAgICAgICAgICAgIGltYWdlRUxTdHlsZS53aWR0aCA9IHJvdW5kKHNjYWxlWCAqIG93ICogZHcgLyBzdykgKyAncHgnO1xuICAgICAgICAgICAgICAgICAgICBpbWFnZUVMU3R5bGUuaGVpZ2h0ID0gcm91bmQoc2NhbGVZICogb2ggKiBkaCAvIHNoKSArICdweCc7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQ2FjaGluZyBpbWFnZSBvcmlnaW5hbCB3aWR0aCwgaGVpZ2h0IGFuZCBzcmNcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5faW1hZ2VXaWR0aCA9IG93O1xuICAgICAgICAgICAgICAgICAgICBzZWxmLl9pbWFnZUhlaWdodCA9IG9oO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLl9pbWFnZVNyYyA9IGltYWdlO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdG1wSW1hZ2Uuc3JjID0gaW1hZ2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbWFnZUVMU3R5bGUud2lkdGggPSByb3VuZChzY2FsZVggKiBvdyAqIGR3IC8gc3cpICsgJ3B4JztcbiAgICAgICAgICAgICAgICBpbWFnZUVMU3R5bGUuaGVpZ2h0ID0gcm91bmQoc2NhbGVZICogb2ggKiBkaCAvIHNoKSArICdweCc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghIGNyb3BFbCkge1xuICAgICAgICAgICAgICAgIGNyb3BFbCA9IHZtbENvcmUuZG9jLmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgICAgIGNyb3BFbC5zdHlsZS5vdmVyZmxvdyA9ICdoaWRkZW4nO1xuICAgICAgICAgICAgICAgIHRoaXMuX2Nyb3BFbCA9IGNyb3BFbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBjcm9wRWxTdHlsZSA9IGNyb3BFbC5zdHlsZTtcbiAgICAgICAgICAgIGNyb3BFbFN0eWxlLndpZHRoID0gcm91bmQoKGR3ICsgc3ggKiBkdyAvIHN3KSAqIHNjYWxlWCk7XG4gICAgICAgICAgICBjcm9wRWxTdHlsZS5oZWlnaHQgPSByb3VuZCgoZGggKyBzeSAqIGRoIC8gc2gpICogc2NhbGVZKTtcbiAgICAgICAgICAgIGNyb3BFbFN0eWxlLmZpbHRlciA9IGltYWdlVHJhbnNmb3JtUHJlZml4ICsgJy5NYXRyaXgoRHg9J1xuICAgICAgICAgICAgICAgICAgICArICgtc3ggKiBkdyAvIHN3ICogc2NhbGVYKSArICcsRHk9JyArICgtc3kgKiBkaCAvIHNoICogc2NhbGVZKSArICcpJztcblxuICAgICAgICAgICAgaWYgKCEgY3JvcEVsLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICB2bWxFbC5hcHBlbmRDaGlsZChjcm9wRWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGltYWdlRWwucGFyZW50Tm9kZSAhPSBjcm9wRWwpIHtcbiAgICAgICAgICAgICAgICBjcm9wRWwuYXBwZW5kQ2hpbGQoaW1hZ2VFbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpbWFnZUVMU3R5bGUud2lkdGggPSByb3VuZChzY2FsZVggKiBkdykgKyAncHgnO1xuICAgICAgICAgICAgaW1hZ2VFTFN0eWxlLmhlaWdodCA9IHJvdW5kKHNjYWxlWSAqIGRoKSArICdweCc7XG5cbiAgICAgICAgICAgIHZtbEVsLmFwcGVuZENoaWxkKGltYWdlRWwpO1xuXG4gICAgICAgICAgICBpZiAoY3JvcEVsICYmIGNyb3BFbC5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgdm1sRWwucmVtb3ZlQ2hpbGQoY3JvcEVsKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9jcm9wRWwgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGZpbHRlclN0ciA9ICcnO1xuICAgICAgICB2YXIgYWxwaGEgPSBzdHlsZS5vcGFjaXR5O1xuICAgICAgICBpZiAoYWxwaGEgPCAxKSB7XG4gICAgICAgICAgICBmaWx0ZXJTdHIgKz0gJy5BbHBoYShvcGFjaXR5PScgKyByb3VuZChhbHBoYSAqIDEwMCkgKyAnKSAnO1xuICAgICAgICB9XG4gICAgICAgIGZpbHRlclN0ciArPSBpbWFnZVRyYW5zZm9ybVByZWZpeCArICcuQWxwaGFJbWFnZUxvYWRlcihzcmM9JyArIGltYWdlICsgJywgU2l6aW5nTWV0aG9kPXNjYWxlKSc7XG5cbiAgICAgICAgaW1hZ2VFTFN0eWxlLmZpbHRlciA9IGZpbHRlclN0cjtcblxuICAgICAgICB2bWxFbC5zdHlsZS56SW5kZXggPSBnZXRaSW5kZXgodGhpcy56bGV2ZWwsIHRoaXMueiwgdGhpcy56Mik7XG5cbiAgICAgICAgLy8gQXBwZW5kIHRvIHJvb3RcbiAgICAgICAgYXBwZW5kKHZtbFJvb3QsIHZtbEVsKTtcblxuICAgICAgICAvLyBUZXh0XG4gICAgICAgIGlmIChzdHlsZS50ZXh0KSB7XG4gICAgICAgICAgICB0aGlzLmRyYXdSZWN0VGV4dCh2bWxSb290LCB0aGlzLmdldEJvdW5kaW5nUmVjdCgpKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBaSW1hZ2UucHJvdG90eXBlLm9uUmVtb3ZlID0gZnVuY3Rpb24gKHZtbFJvb3QpIHtcbiAgICAgICAgcmVtb3ZlKHZtbFJvb3QsIHRoaXMuX3ZtbEVsKTtcblxuICAgICAgICB0aGlzLl92bWxFbCA9IG51bGw7XG4gICAgICAgIHRoaXMuX2Nyb3BFbCA9IG51bGw7XG4gICAgICAgIHRoaXMuX2ltYWdlRWwgPSBudWxsO1xuXG4gICAgICAgIHRoaXMucmVtb3ZlUmVjdFRleHQodm1sUm9vdCk7XG4gICAgfTtcblxuICAgIFpJbWFnZS5wcm90b3R5cGUub25BZGQgPSBmdW5jdGlvbiAodm1sUm9vdCkge1xuICAgICAgICBhcHBlbmQodm1sUm9vdCwgdGhpcy5fdm1sRWwpO1xuICAgICAgICB0aGlzLmFwcGVuZFJlY3RUZXh0KHZtbFJvb3QpO1xuICAgIH07XG5cblxuICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAgKiBURVhUXG4gICAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgdmFyIERFRkFVTFRfU1RZTEVfTk9STUFMID0gJ25vcm1hbCc7XG5cbiAgICB2YXIgZm9udFN0eWxlQ2FjaGUgPSB7fTtcbiAgICB2YXIgZm9udFN0eWxlQ2FjaGVDb3VudCA9IDA7XG4gICAgdmFyIE1BWF9GT05UX0NBQ0hFX1NJWkUgPSAxMDA7XG4gICAgdmFyIGZvbnRFbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXG4gICAgdmFyIGdldEZvbnRTdHlsZSA9IGZ1bmN0aW9uIChmb250U3RyaW5nKSB7XG4gICAgICAgIHZhciBmb250U3R5bGUgPSBmb250U3R5bGVDYWNoZVtmb250U3RyaW5nXTtcbiAgICAgICAgaWYgKCFmb250U3R5bGUpIHtcbiAgICAgICAgICAgIC8vIENsZWFyIGNhY2hlXG4gICAgICAgICAgICBpZiAoZm9udFN0eWxlQ2FjaGVDb3VudCA+IE1BWF9GT05UX0NBQ0hFX1NJWkUpIHtcbiAgICAgICAgICAgICAgICBmb250U3R5bGVDYWNoZUNvdW50ID0gMDtcbiAgICAgICAgICAgICAgICBmb250U3R5bGVDYWNoZSA9IHt9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgc3R5bGUgPSBmb250RWwuc3R5bGU7XG4gICAgICAgICAgICB2YXIgZm9udEZhbWlseTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgc3R5bGUuZm9udCA9IGZvbnRTdHJpbmc7XG4gICAgICAgICAgICAgICAgZm9udEZhbWlseSA9IHN0eWxlLmZvbnRGYW1pbHkuc3BsaXQoJywnKVswXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvbnRTdHlsZSA9IHtcbiAgICAgICAgICAgICAgICBzdHlsZTogc3R5bGUuZm9udFN0eWxlIHx8IERFRkFVTFRfU1RZTEVfTk9STUFMLFxuICAgICAgICAgICAgICAgIHZhcmlhbnQ6IHN0eWxlLmZvbnRWYXJpYW50IHx8IERFRkFVTFRfU1RZTEVfTk9STUFMLFxuICAgICAgICAgICAgICAgIHdlaWdodDogc3R5bGUuZm9udFdlaWdodCB8fCBERUZBVUxUX1NUWUxFX05PUk1BTCxcbiAgICAgICAgICAgICAgICBzaXplOiBwYXJzZUZsb2F0KHN0eWxlLmZvbnRTaXplIHx8IDEyKSB8IDAsXG4gICAgICAgICAgICAgICAgZmFtaWx5OiBmb250RmFtaWx5IHx8ICdNaWNyb3NvZnQgWWFIZWknXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBmb250U3R5bGVDYWNoZVtmb250U3RyaW5nXSA9IGZvbnRTdHlsZTtcbiAgICAgICAgICAgIGZvbnRTdHlsZUNhY2hlQ291bnQrKztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm9udFN0eWxlO1xuICAgIH07XG5cbiAgICB2YXIgdGV4dE1lYXN1cmVFbDtcbiAgICAvLyBPdmVyd3JpdGUgbWVhc3VyZSB0ZXh0IG1ldGhvZFxuICAgIHRleHRDb250YWluLm1lYXN1cmVUZXh0ID0gZnVuY3Rpb24gKHRleHQsIHRleHRGb250KSB7XG4gICAgICAgIHZhciBkb2MgPSB2bWxDb3JlLmRvYztcbiAgICAgICAgaWYgKCF0ZXh0TWVhc3VyZUVsKSB7XG4gICAgICAgICAgICB0ZXh0TWVhc3VyZUVsID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgdGV4dE1lYXN1cmVFbC5zdHlsZS5jc3NUZXh0ID0gJ3Bvc2l0aW9uOmFic29sdXRlO3RvcDotMjAwMDBweDtsZWZ0OjA7J1xuICAgICAgICAgICAgICAgICsgJ3BhZGRpbmc6MDttYXJnaW46MDtib3JkZXI6bm9uZTt3aGl0ZS1zcGFjZTpwcmU7JztcbiAgICAgICAgICAgIHZtbENvcmUuZG9jLmJvZHkuYXBwZW5kQ2hpbGQodGV4dE1lYXN1cmVFbCk7XG4gICAgICAgIH1cblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGV4dE1lYXN1cmVFbC5zdHlsZS5mb250ID0gdGV4dEZvbnQ7XG4gICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgICAvLyBJZ25vcmUgZmFpbHVyZXMgdG8gc2V0IHRvIGludmFsaWQgZm9udC5cbiAgICAgICAgfVxuICAgICAgICB0ZXh0TWVhc3VyZUVsLmlubmVySFRNTCA9ICcnO1xuICAgICAgICAvLyBEb24ndCB1c2UgaW5uZXJIVE1MIG9yIGlubmVyVGV4dCBiZWNhdXNlIHRoZXkgYWxsb3cgbWFya3VwL3doaXRlc3BhY2UuXG4gICAgICAgIHRleHRNZWFzdXJlRWwuYXBwZW5kQ2hpbGQoZG9jLmNyZWF0ZVRleHROb2RlKHRleHQpKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHdpZHRoOiB0ZXh0TWVhc3VyZUVsLm9mZnNldFdpZHRoXG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciB0bXBSZWN0ID0gbmV3IEJvdW5kaW5nUmVjdCgpO1xuXG4gICAgdmFyIGRyYXdSZWN0VGV4dCA9IGZ1bmN0aW9uICh2bWxSb290LCByZWN0LCB0ZXh0UmVjdCwgZnJvbVRleHRFbCkge1xuXG4gICAgICAgIHZhciBzdHlsZSA9IHRoaXMuc3R5bGU7XG4gICAgICAgIHZhciB0ZXh0ID0gc3R5bGUudGV4dDtcbiAgICAgICAgaWYgKCF0ZXh0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgeDtcbiAgICAgICAgdmFyIHk7XG4gICAgICAgIHZhciBhbGlnbiA9IHN0eWxlLnRleHRBbGlnbjtcbiAgICAgICAgdmFyIGZvbnRTdHlsZSA9IGdldEZvbnRTdHlsZShzdHlsZS50ZXh0Rm9udCk7XG4gICAgICAgIC8vIEZJWE1FIGVuY29kZUh0bWxBdHRyaWJ1dGUgP1xuICAgICAgICB2YXIgZm9udCA9IGZvbnRTdHlsZS5zdHlsZSArICcgJyArIGZvbnRTdHlsZS52YXJpYW50ICsgJyAnICsgZm9udFN0eWxlLndlaWdodCArICcgJ1xuICAgICAgICAgICAgKyBmb250U3R5bGUuc2l6ZSArICdweCBcIicgKyBmb250U3R5bGUuZmFtaWx5ICsgJ1wiJztcblxuICAgICAgICB2YXIgYmFzZWxpbmUgPSBzdHlsZS50ZXh0QmFzZWxpbmU7XG4gICAgICAgIHZhciB2ZXJ0aWNhbEFsaWduID0gc3R5bGUudGV4dFZlcnRpY2FsQWxpZ247XG5cbiAgICAgICAgdGV4dFJlY3QgPSB0ZXh0UmVjdCB8fCB0ZXh0Q29udGFpbi5nZXRCb3VuZGluZ1JlY3QodGV4dCwgZm9udCwgYWxpZ24sIGJhc2VsaW5lKTtcblxuICAgICAgICAvLyBUcmFuc2Zvcm0gcmVjdCB0byB2aWV3IHNwYWNlXG4gICAgICAgIHZhciBtID0gdGhpcy50cmFuc2Zvcm07XG4gICAgICAgIC8vIElnbm9yZSB0cmFuc2Zvcm0gZm9yIHRleHQgaW4gb3RoZXIgZWxlbWVudFxuICAgICAgICBpZiAobSAmJiAhZnJvbVRleHRFbCkge1xuICAgICAgICAgICAgdG1wUmVjdC5jb3B5KHJlY3QpO1xuICAgICAgICAgICAgdG1wUmVjdC5hcHBseVRyYW5zZm9ybShtKTtcbiAgICAgICAgICAgIHJlY3QgPSB0bXBSZWN0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFmcm9tVGV4dEVsKSB7XG4gICAgICAgICAgICB2YXIgdGV4dFBvc2l0aW9uID0gc3R5bGUudGV4dFBvc2l0aW9uO1xuICAgICAgICAgICAgdmFyIGRpc3RhbmNlID0gc3R5bGUudGV4dERpc3RhbmNlO1xuICAgICAgICAgICAgLy8gVGV4dCBwb3NpdGlvbiByZXByZXNlbnRlZCBieSBjb29yZFxuICAgICAgICAgICAgaWYgKHRleHRQb3NpdGlvbiBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICAgICAgeCA9IHJlY3QueCArIHBhcnNlUGVyY2VudCh0ZXh0UG9zaXRpb25bMF0sIHJlY3Qud2lkdGgpO1xuICAgICAgICAgICAgICAgIHkgPSByZWN0LnkgKyBwYXJzZVBlcmNlbnQodGV4dFBvc2l0aW9uWzFdLCByZWN0LmhlaWdodCk7XG5cbiAgICAgICAgICAgICAgICBhbGlnbiA9IGFsaWduIHx8ICdsZWZ0JztcbiAgICAgICAgICAgICAgICBiYXNlbGluZSA9IGJhc2VsaW5lIHx8ICd0b3AnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlcyA9IHRleHRDb250YWluLmFkanVzdFRleHRQb3NpdGlvbk9uUmVjdChcbiAgICAgICAgICAgICAgICAgICAgdGV4dFBvc2l0aW9uLCByZWN0LCB0ZXh0UmVjdCwgZGlzdGFuY2VcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHggPSByZXMueDtcbiAgICAgICAgICAgICAgICB5ID0gcmVzLnk7XG5cbiAgICAgICAgICAgICAgICAvLyBEZWZhdWx0IGFsaWduIGFuZCBiYXNlbGluZSB3aGVuIGhhcyB0ZXh0UG9zaXRpb25cbiAgICAgICAgICAgICAgICBhbGlnbiA9IGFsaWduIHx8IHJlcy50ZXh0QWxpZ247XG4gICAgICAgICAgICAgICAgYmFzZWxpbmUgPSBiYXNlbGluZSB8fCByZXMudGV4dEJhc2VsaW5lO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgeCA9IHJlY3QueDtcbiAgICAgICAgICAgIHkgPSByZWN0Lnk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZlcnRpY2FsQWxpZ24pIHtcbiAgICAgICAgICAgIHN3aXRjaCAodmVydGljYWxBbGlnbikge1xuICAgICAgICAgICAgICAgIGNhc2UgJ21pZGRsZSc6XG4gICAgICAgICAgICAgICAgICAgIHkgLT0gdGV4dFJlY3QuaGVpZ2h0IC8gMjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnYm90dG9tJzpcbiAgICAgICAgICAgICAgICAgICAgeSAtPSB0ZXh0UmVjdC5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIC8vICd0b3AnXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZ25vcmUgYmFzZWxpbmVcbiAgICAgICAgICAgIGJhc2VsaW5lID0gJ3RvcCc7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZm9udFNpemUgPSBmb250U3R5bGUuc2l6ZTtcbiAgICAgICAgLy8gMS43NSBpcyBhbiBhcmJpdHJhcnkgbnVtYmVyLCBhcyB0aGVyZSBpcyBubyBpbmZvIGFib3V0IHRoZSB0ZXh0IGJhc2VsaW5lXG4gICAgICAgIHN3aXRjaCAoYmFzZWxpbmUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2hhbmdpbmcnOlxuICAgICAgICAgICAgY2FzZSAndG9wJzpcbiAgICAgICAgICAgICAgICB5ICs9IGZvbnRTaXplIC8gMS43NTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ21pZGRsZSc6XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgLy8gY2FzZSBudWxsOlxuICAgICAgICAgICAgLy8gY2FzZSAnYWxwaGFiZXRpYyc6XG4gICAgICAgICAgICAvLyBjYXNlICdpZGVvZ3JhcGhpYyc6XG4gICAgICAgICAgICAvLyBjYXNlICdib3R0b20nOlxuICAgICAgICAgICAgICAgIHkgLT0gZm9udFNpemUgLyAyLjI1O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAoYWxpZ24pIHtcbiAgICAgICAgICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnY2VudGVyJzpcbiAgICAgICAgICAgICAgICB4IC09IHRleHRSZWN0LndpZHRoIC8gMjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgICAgICAgICB4IC09IHRleHRSZWN0LndpZHRoO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgLy8gY2FzZSAnZW5kJzpcbiAgICAgICAgICAgICAgICAvLyBhbGlnbiA9IGVsZW1lbnRTdHlsZS5kaXJlY3Rpb24gPT0gJ2x0cicgPyAncmlnaHQnIDogJ2xlZnQnO1xuICAgICAgICAgICAgICAgIC8vIGJyZWFrO1xuICAgICAgICAgICAgLy8gY2FzZSAnc3RhcnQnOlxuICAgICAgICAgICAgICAgIC8vIGFsaWduID0gZWxlbWVudFN0eWxlLmRpcmVjdGlvbiA9PSAncnRsJyA/ICdyaWdodCcgOiAnbGVmdCc7XG4gICAgICAgICAgICAgICAgLy8gYnJlYWs7XG4gICAgICAgICAgICAvLyBkZWZhdWx0OlxuICAgICAgICAgICAgLy8gICAgIGFsaWduID0gJ2xlZnQnO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNyZWF0ZU5vZGUgPSB2bWxDb3JlLmNyZWF0ZU5vZGU7XG5cbiAgICAgICAgdmFyIHRleHRWbWxFbCA9IHRoaXMuX3RleHRWbWxFbDtcbiAgICAgICAgdmFyIHBhdGhFbDtcbiAgICAgICAgdmFyIHRleHRQYXRoRWw7XG4gICAgICAgIHZhciBza2V3RWw7XG4gICAgICAgIGlmICghdGV4dFZtbEVsKSB7XG4gICAgICAgICAgICB0ZXh0Vm1sRWwgPSBjcmVhdGVOb2RlKCdsaW5lJyk7XG4gICAgICAgICAgICBwYXRoRWwgPSBjcmVhdGVOb2RlKCdwYXRoJyk7XG4gICAgICAgICAgICB0ZXh0UGF0aEVsID0gY3JlYXRlTm9kZSgndGV4dHBhdGgnKTtcbiAgICAgICAgICAgIHNrZXdFbCA9IGNyZWF0ZU5vZGUoJ3NrZXcnKTtcblxuICAgICAgICAgICAgLy8gRklYTUUgV2h5IGhlcmUgaXMgbm90IGNhbW1lbCBjYXNlXG4gICAgICAgICAgICAvLyBBbGlnbiAnY2VudGVyJyBzZWVtcyB3cm9uZ1xuICAgICAgICAgICAgdGV4dFBhdGhFbC5zdHlsZVsndi10ZXh0LWFsaWduJ10gPSAnbGVmdCc7XG5cbiAgICAgICAgICAgIGluaXRSb290RWxTdHlsZSh0ZXh0Vm1sRWwpO1xuXG4gICAgICAgICAgICBwYXRoRWwudGV4dHBhdGhvayA9IHRydWU7XG4gICAgICAgICAgICB0ZXh0UGF0aEVsLm9uID0gdHJ1ZTtcblxuICAgICAgICAgICAgdGV4dFZtbEVsLmZyb20gPSAnMCAwJztcbiAgICAgICAgICAgIHRleHRWbWxFbC50byA9ICcxMDAwIDAuMDUnO1xuXG4gICAgICAgICAgICBhcHBlbmQodGV4dFZtbEVsLCBza2V3RWwpO1xuICAgICAgICAgICAgYXBwZW5kKHRleHRWbWxFbCwgcGF0aEVsKTtcbiAgICAgICAgICAgIGFwcGVuZCh0ZXh0Vm1sRWwsIHRleHRQYXRoRWwpO1xuXG4gICAgICAgICAgICB0aGlzLl90ZXh0Vm1sRWwgPSB0ZXh0Vm1sRWw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyDov5nph4zmmK/lnKjliY3pnaIgYXBwZW5kQ2hpbGQg5L+d6K+B6aG65bqP55qE5YmN5o+Q5LiLXG4gICAgICAgICAgICBza2V3RWwgPSB0ZXh0Vm1sRWwuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgIHBhdGhFbCA9IHNrZXdFbC5uZXh0U2libGluZztcbiAgICAgICAgICAgIHRleHRQYXRoRWwgPSBwYXRoRWwubmV4dFNpYmxpbmc7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY29vcmRzID0gW3gsIHldO1xuICAgICAgICB2YXIgdGV4dFZtbEVsU3R5bGUgPSB0ZXh0Vm1sRWwuc3R5bGU7XG4gICAgICAgIC8vIElnbm9yZSB0cmFuc2Zvcm0gZm9yIHRleHQgaW4gb3RoZXIgZWxlbWVudFxuICAgICAgICBpZiAobSAmJiBmcm9tVGV4dEVsKSB7XG4gICAgICAgICAgICBhcHBseVRyYW5zZm9ybShjb29yZHMsIGNvb3JkcywgbSk7XG5cbiAgICAgICAgICAgIHNrZXdFbC5vbiA9IHRydWU7XG5cbiAgICAgICAgICAgIHNrZXdFbC5tYXRyaXggPSBtWzBdLnRvRml4ZWQoMykgKyBjb21tYSArIG1bMl0udG9GaXhlZCgzKSArIGNvbW1hICtcbiAgICAgICAgICAgIG1bMV0udG9GaXhlZCgzKSArIGNvbW1hICsgbVszXS50b0ZpeGVkKDMpICsgJywwLDAnO1xuXG4gICAgICAgICAgICAvLyBUZXh0IHBvc2l0aW9uXG4gICAgICAgICAgICBza2V3RWwub2Zmc2V0ID0gKHJvdW5kKGNvb3Jkc1swXSkgfHwgMCkgKyAnLCcgKyAocm91bmQoY29vcmRzWzFdKSB8fCAwKTtcbiAgICAgICAgICAgIC8vIExlZnQgdG9wIHBvaW50IGFzIG9yaWdpblxuICAgICAgICAgICAgc2tld0VsLm9yaWdpbiA9ICcwIDAnO1xuXG4gICAgICAgICAgICB0ZXh0Vm1sRWxTdHlsZS5sZWZ0ID0gJzBweCc7XG4gICAgICAgICAgICB0ZXh0Vm1sRWxTdHlsZS50b3AgPSAnMHB4JztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNrZXdFbC5vbiA9IGZhbHNlO1xuICAgICAgICAgICAgdGV4dFZtbEVsU3R5bGUubGVmdCA9IHJvdW5kKHgpICsgJ3B4JztcbiAgICAgICAgICAgIHRleHRWbWxFbFN0eWxlLnRvcCA9IHJvdW5kKHkpICsgJ3B4JztcbiAgICAgICAgfVxuXG4gICAgICAgIHRleHRQYXRoRWwuc3RyaW5nID0gZW5jb2RlSHRtbEF0dHJpYnV0ZSh0ZXh0KTtcbiAgICAgICAgLy8gVE9ET1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGV4dFBhdGhFbC5zdHlsZS5mb250ID0gZm9udDtcbiAgICAgICAgfVxuICAgICAgICAvLyBFcnJvciBmb250IGZvcm1hdFxuICAgICAgICBjYXRjaCAoZSkge31cblxuICAgICAgICB1cGRhdGVGaWxsQW5kU3Ryb2tlKHRleHRWbWxFbCwgJ2ZpbGwnLCB7XG4gICAgICAgICAgICBmaWxsOiBmcm9tVGV4dEVsID8gc3R5bGUuZmlsbCA6IHN0eWxlLnRleHRGaWxsLFxuICAgICAgICAgICAgb3BhY2l0eTogc3R5bGUub3BhY2l0eVxuICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgdXBkYXRlRmlsbEFuZFN0cm9rZSh0ZXh0Vm1sRWwsICdzdHJva2UnLCB7XG4gICAgICAgICAgICBzdHJva2U6IGZyb21UZXh0RWwgPyBzdHlsZS5zdHJva2UgOiBzdHlsZS50ZXh0U3Ryb2tlLFxuICAgICAgICAgICAgb3BhY2l0eTogc3R5bGUub3BhY2l0eSxcbiAgICAgICAgICAgIGxpbmVEYXNoOiBzdHlsZS5saW5lRGFzaFxuICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICB0ZXh0Vm1sRWwuc3R5bGUuekluZGV4ID0gZ2V0WkluZGV4KHRoaXMuemxldmVsLCB0aGlzLnosIHRoaXMuejIpO1xuXG4gICAgICAgIC8vIEF0dGFjaGVkIHRvIHJvb3RcbiAgICAgICAgYXBwZW5kKHZtbFJvb3QsIHRleHRWbWxFbCk7XG4gICAgfTtcblxuICAgIHZhciByZW1vdmVSZWN0VGV4dCA9IGZ1bmN0aW9uICh2bWxSb290KSB7XG4gICAgICAgIHJlbW92ZSh2bWxSb290LCB0aGlzLl90ZXh0Vm1sRWwpO1xuICAgICAgICB0aGlzLl90ZXh0Vm1sRWwgPSBudWxsO1xuICAgIH07XG5cbiAgICB2YXIgYXBwZW5kUmVjdFRleHQgPSBmdW5jdGlvbiAodm1sUm9vdCkge1xuICAgICAgICBhcHBlbmQodm1sUm9vdCwgdGhpcy5fdGV4dFZtbEVsKTtcbiAgICB9O1xuXG4gICAgdmFyIGxpc3QgPSBbUmVjdFRleHQsIERpc3BsYXlhYmxlLCBaSW1hZ2UsIFBhdGgsIFRleHRdO1xuXG4gICAgLy8gSW4gY2FzZSBEaXNwbGF5YWJsZSBoYXMgYmVlbiBtaXhlZCBpbiBSZWN0VGV4dFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcHJvdG8gPSBsaXN0W2ldLnByb3RvdHlwZTtcbiAgICAgICAgcHJvdG8uZHJhd1JlY3RUZXh0ID0gZHJhd1JlY3RUZXh0O1xuICAgICAgICBwcm90by5yZW1vdmVSZWN0VGV4dCA9IHJlbW92ZVJlY3RUZXh0O1xuICAgICAgICBwcm90by5hcHBlbmRSZWN0VGV4dCA9IGFwcGVuZFJlY3RUZXh0O1xuICAgIH1cblxuICAgIFRleHQucHJvdG90eXBlLmJydXNoVk1MID0gZnVuY3Rpb24gKHZtbFJvb3QpIHtcbiAgICAgICAgdmFyIHN0eWxlID0gdGhpcy5zdHlsZTtcbiAgICAgICAgaWYgKHN0eWxlLnRleHQpIHtcbiAgICAgICAgICAgIHRoaXMuZHJhd1JlY3RUZXh0KHZtbFJvb3QsIHtcbiAgICAgICAgICAgICAgICB4OiBzdHlsZS54IHx8IDAsIHk6IHN0eWxlLnkgfHwgMCxcbiAgICAgICAgICAgICAgICB3aWR0aDogMCwgaGVpZ2h0OiAwXG4gICAgICAgICAgICB9LCB0aGlzLmdldEJvdW5kaW5nUmVjdCgpLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlUmVjdFRleHQodm1sUm9vdCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgVGV4dC5wcm90b3R5cGUub25SZW1vdmUgPSBmdW5jdGlvbiAodm1sUm9vdCkge1xuICAgICAgICB0aGlzLnJlbW92ZVJlY3RUZXh0KHZtbFJvb3QpO1xuICAgIH07XG5cbiAgICBUZXh0LnByb3RvdHlwZS5vbkFkZCA9IGZ1bmN0aW9uICh2bWxSb290KSB7XG4gICAgICAgIHRoaXMuYXBwZW5kUmVjdFRleHQodm1sUm9vdCk7XG4gICAgfTtcbn1cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3pyZW5kZXIvbGliL3ZtbC9ncmFwaGljLmpzXG4gKiogbW9kdWxlIGlkID0gOTdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlxuXG5pZiAoIXJlcXVpcmUoJy4uL2NvcmUvZW52JykuY2FudmFzU3VwcG9ydGVkKSB7XG4gICAgdmFyIHVybiA9ICd1cm46c2NoZW1hcy1taWNyb3NvZnQtY29tOnZtbCc7XG5cbiAgICB2YXIgY3JlYXRlTm9kZTtcbiAgICB2YXIgd2luID0gd2luZG93O1xuICAgIHZhciBkb2MgPSB3aW4uZG9jdW1lbnQ7XG5cbiAgICB2YXIgdm1sSW5pdGVkID0gZmFsc2U7XG5cbiAgICB0cnkge1xuICAgICAgICAhZG9jLm5hbWVzcGFjZXMuenJ2bWwgJiYgZG9jLm5hbWVzcGFjZXMuYWRkKCd6cnZtbCcsIHVybik7XG4gICAgICAgIGNyZWF0ZU5vZGUgPSBmdW5jdGlvbiAodGFnTmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIGRvYy5jcmVhdGVFbGVtZW50KCc8enJ2bWw6JyArIHRhZ05hbWUgKyAnIGNsYXNzPVwienJ2bWxcIj4nKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgY3JlYXRlTm9kZSA9IGZ1bmN0aW9uICh0YWdOYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gZG9jLmNyZWF0ZUVsZW1lbnQoJzwnICsgdGFnTmFtZSArICcgeG1sbnM9XCInICsgdXJuICsgJ1wiIGNsYXNzPVwienJ2bWxcIj4nKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBGcm9tIHJhcGhhZWxcbiAgICB2YXIgaW5pdFZNTCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHZtbEluaXRlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZtbEluaXRlZCA9IHRydWU7XG5cbiAgICAgICAgdmFyIHN0eWxlU2hlZXRzID0gZG9jLnN0eWxlU2hlZXRzO1xuICAgICAgICBpZiAoc3R5bGVTaGVldHMubGVuZ3RoIDwgMzEpIHtcbiAgICAgICAgICAgIGRvYy5jcmVhdGVTdHlsZVNoZWV0KCkuYWRkUnVsZSgnLnpydm1sJywgJ2JlaGF2aW9yOnVybCgjZGVmYXVsdCNWTUwpJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvbXM1MzExOTQlMjhWUy44NSUyOS5hc3B4XG4gICAgICAgICAgICBzdHlsZVNoZWV0c1swXS5hZGRSdWxlKCcuenJ2bWwnLCAnYmVoYXZpb3I6dXJsKCNkZWZhdWx0I1ZNTCknKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBOb3QgdXNlaW5nIHJldHVybiB0byBhdm9pZCBlcnJvciB3aGVuIGNvbnZlcnRpbmcgdG8gQ29tbW9uSlMgbW9kdWxlXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgICAgIGRvYzogZG9jLFxuICAgICAgICBpbml0Vk1MOiBpbml0Vk1MLFxuICAgICAgICBjcmVhdGVOb2RlOiBjcmVhdGVOb2RlXG4gICAgfTtcbn1cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3pyZW5kZXIvbGliL3ZtbC9jb3JlLmpzXG4gKiogbW9kdWxlIGlkID0gOThcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogVk1MIFBhaW50ZXIuXG4gKlxuICogQG1vZHVsZSB6cmVuZGVyL3ZtbC9QYWludGVyXG4gKi9cblxuXG5cbiAgICB2YXIgenJMb2cgPSByZXF1aXJlKCcuLi9jb3JlL2xvZycpO1xuICAgIHZhciB2bWxDb3JlID0gcmVxdWlyZSgnLi9jb3JlJyk7XG5cbiAgICBmdW5jdGlvbiBwYXJzZUludDEwKHZhbCkge1xuICAgICAgICByZXR1cm4gcGFyc2VJbnQodmFsLCAxMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGFsaWFzIG1vZHVsZTp6cmVuZGVyL3ZtbC9QYWludGVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gVk1MUGFpbnRlcihyb290LCBzdG9yYWdlKSB7XG5cbiAgICAgICAgdm1sQ29yZS5pbml0Vk1MKCk7XG5cbiAgICAgICAgdGhpcy5yb290ID0gcm9vdDtcblxuICAgICAgICB0aGlzLnN0b3JhZ2UgPSBzdG9yYWdlO1xuXG4gICAgICAgIHZhciB2bWxWaWV3cG9ydCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXG4gICAgICAgIHZhciB2bWxSb290ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cbiAgICAgICAgdm1sVmlld3BvcnQuc3R5bGUuY3NzVGV4dCA9ICdkaXNwbGF5OmlubGluZS1ibG9jaztvdmVyZmxvdzpoaWRkZW47cG9zaXRpb246cmVsYXRpdmU7d2lkdGg6MzAwcHg7aGVpZ2h0OjE1MHB4Oyc7XG5cbiAgICAgICAgdm1sUm9vdC5zdHlsZS5jc3NUZXh0ID0gJ3Bvc2l0aW9uOmFic29sdXRlO2xlZnQ6MDt0b3A6MDsnO1xuXG4gICAgICAgIHJvb3QuYXBwZW5kQ2hpbGQodm1sVmlld3BvcnQpO1xuXG4gICAgICAgIHRoaXMuX3ZtbFJvb3QgPSB2bWxSb290O1xuICAgICAgICB0aGlzLl92bWxWaWV3cG9ydCA9IHZtbFZpZXdwb3J0O1xuXG4gICAgICAgIHRoaXMucmVzaXplKCk7XG5cbiAgICAgICAgLy8gTW9kaWZ5IHN0b3JhZ2VcbiAgICAgICAgdmFyIG9sZERlbEZyb21NYXAgPSBzdG9yYWdlLmRlbEZyb21NYXA7XG4gICAgICAgIHZhciBvbGRBZGRUb01hcCA9IHN0b3JhZ2UuYWRkVG9NYXA7XG4gICAgICAgIHN0b3JhZ2UuZGVsRnJvbU1hcCA9IGZ1bmN0aW9uIChlbElkKSB7XG4gICAgICAgICAgICB2YXIgZWwgPSBzdG9yYWdlLmdldChlbElkKTtcblxuICAgICAgICAgICAgb2xkRGVsRnJvbU1hcC5jYWxsKHN0b3JhZ2UsIGVsSWQpO1xuXG4gICAgICAgICAgICBpZiAoZWwpIHtcbiAgICAgICAgICAgICAgICBlbC5vblJlbW92ZSAmJiBlbC5vblJlbW92ZSh2bWxSb290KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBzdG9yYWdlLmFkZFRvTWFwID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICAvLyBEaXNwbGF5YWJsZSBhbHJlYWR5IGhhcyBhIHZtbCBub2RlXG4gICAgICAgICAgICBlbC5vbkFkZCAmJiBlbC5vbkFkZCh2bWxSb290KTtcblxuICAgICAgICAgICAgb2xkQWRkVG9NYXAuY2FsbChzdG9yYWdlLCBlbCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5fZmlyc3RQYWludCA9IHRydWU7XG4gICAgfVxuXG4gICAgVk1MUGFpbnRlci5wcm90b3R5cGUgPSB7XG5cbiAgICAgICAgY29uc3RydWN0b3I6IFZNTFBhaW50ZXIsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4ge0hUTUxEaXZFbGVtZW50fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0Vmlld3BvcnRSb290OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdm1sVmlld3BvcnQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWIt+aWsFxuICAgICAgICAgKi9cbiAgICAgICAgcmVmcmVzaDogZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICB2YXIgbGlzdCA9IHRoaXMuc3RvcmFnZS5nZXREaXNwbGF5TGlzdCh0cnVlLCB0cnVlKTtcblxuICAgICAgICAgICAgdGhpcy5fcGFpbnRMaXN0KGxpc3QpO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9wYWludExpc3Q6IGZ1bmN0aW9uIChsaXN0KSB7XG4gICAgICAgICAgICB2YXIgdm1sUm9vdCA9IHRoaXMuX3ZtbFJvb3Q7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgZWwgPSBsaXN0W2ldO1xuICAgICAgICAgICAgICAgIGlmIChlbC5pbnZpc2libGUgfHwgZWwuaWdub3JlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZWwuX19hbHJlYWR5Tm90VmlzaWJsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWwub25SZW1vdmUodm1sUm9vdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gU2V0IGFzIGFscmVhZHkgaW52aXNpYmxlXG4gICAgICAgICAgICAgICAgICAgIGVsLl9fYWxyZWFkeU5vdFZpc2libGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVsLl9fYWxyZWFkeU5vdFZpc2libGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsLm9uQWRkKHZtbFJvb3QpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsLl9fYWxyZWFkeU5vdFZpc2libGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVsLl9fZGlydHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsLmJlZm9yZUJydXNoICYmIGVsLmJlZm9yZUJydXNoKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAoZWwuYnJ1c2hWTUwgfHwgZWwuYnJ1c2gpLmNhbGwoZWwsIHZtbFJvb3QpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWwuYWZ0ZXJCcnVzaCAmJiBlbC5hZnRlckJydXNoKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWwuX19kaXJ0eSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5fZmlyc3RQYWludCkge1xuICAgICAgICAgICAgICAgIC8vIERldGFjaGVkIGZyb20gZG9jdW1lbnQgYXQgZmlyc3QgdGltZVxuICAgICAgICAgICAgICAgIC8vIHRvIGF2b2lkIHBhZ2UgcmVmcmVzaGluZyB0b28gbWFueSB0aW1lc1xuXG4gICAgICAgICAgICAgICAgLy8gRklYTUUg5aaC5p6c5q+P5qyh6YO95YWIIHJlbW92ZUNoaWxkIOWPr+iDveS8muWvvOiHtOS4gOS6m+Whq+WFheWSjOaPj+i+ueeahOaViOaenOaUueWPmFxuICAgICAgICAgICAgICAgIHRoaXMuX3ZtbFZpZXdwb3J0LmFwcGVuZENoaWxkKHZtbFJvb3QpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2ZpcnN0UGFpbnQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICByZXNpemU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB3aWR0aCA9IHRoaXMuX2dldFdpZHRoKCk7XG4gICAgICAgICAgICB2YXIgaGVpZ2h0ID0gdGhpcy5fZ2V0SGVpZ2h0KCk7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl93aWR0aCAhPSB3aWR0aCAmJiB0aGlzLl9oZWlnaHQgIT0gaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fd2lkdGggPSB3aWR0aDtcbiAgICAgICAgICAgICAgICB0aGlzLl9oZWlnaHQgPSBoZWlnaHQ7XG5cbiAgICAgICAgICAgICAgICB2YXIgdm1sVmlld3BvcnRTdHlsZSA9IHRoaXMuX3ZtbFZpZXdwb3J0LnN0eWxlO1xuICAgICAgICAgICAgICAgIHZtbFZpZXdwb3J0U3R5bGUud2lkdGggPSB3aWR0aCArICdweCc7XG4gICAgICAgICAgICAgICAgdm1sVmlld3BvcnRTdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyAncHgnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGRpc3Bvc2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMucm9vdC5pbm5lckhUTUwgPSAnJztcblxuICAgICAgICAgICAgdGhpcy5fdm1sUm9vdCA9XG4gICAgICAgICAgICB0aGlzLl92bWxWaWV3cG9ydCA9XG4gICAgICAgICAgICB0aGlzLnN0b3JhZ2UgPSBudWxsO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldFdpZHRoOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fd2lkdGg7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0SGVpZ2h0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faGVpZ2h0O1xuICAgICAgICB9LFxuXG4gICAgICAgIGNsZWFyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLnJvb3QucmVtb3ZlQ2hpbGQodGhpcy52bWxWaWV3cG9ydCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2dldFdpZHRoOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcm9vdCA9IHRoaXMucm9vdDtcbiAgICAgICAgICAgIHZhciBzdGwgPSByb290LmN1cnJlbnRTdHlsZTtcblxuICAgICAgICAgICAgcmV0dXJuICgocm9vdC5jbGllbnRXaWR0aCB8fCBwYXJzZUludDEwKHN0bC53aWR0aCkpXG4gICAgICAgICAgICAgICAgICAgIC0gcGFyc2VJbnQxMChzdGwucGFkZGluZ0xlZnQpXG4gICAgICAgICAgICAgICAgICAgIC0gcGFyc2VJbnQxMChzdGwucGFkZGluZ1JpZ2h0KSkgfCAwO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9nZXRIZWlnaHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciByb290ID0gdGhpcy5yb290O1xuICAgICAgICAgICAgdmFyIHN0bCA9IHJvb3QuY3VycmVudFN0eWxlO1xuXG4gICAgICAgICAgICByZXR1cm4gKChyb290LmNsaWVudEhlaWdodCB8fCBwYXJzZUludDEwKHN0bC5oZWlnaHQpKVxuICAgICAgICAgICAgICAgICAgICAtIHBhcnNlSW50MTAoc3RsLnBhZGRpbmdUb3ApXG4gICAgICAgICAgICAgICAgICAgIC0gcGFyc2VJbnQxMChzdGwucGFkZGluZ0JvdHRvbSkpIHwgMDtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBOb3Qgc3VwcG9ydGVkIG1ldGhvZHNcbiAgICBmdW5jdGlvbiBjcmVhdGVNZXRob2ROb3RTdXBwb3J0KG1ldGhvZCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgenJMb2coJ0luIElFOC4wIFZNTCBtb2RlIHBhaW50ZXIgbm90IHN1cHBvcnQgbWV0aG9kIFwiJyArIG1ldGhvZCArICdcIicpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHZhciBub3RTdXBwb3J0ZWRNZXRob2RzID0gW1xuICAgICAgICAnZ2V0TGF5ZXInLCAnaW5zZXJ0TGF5ZXInLCAnZWFjaExheWVyJywgJ2VhY2hCdWlsZGluTGF5ZXInLCAnZWFjaE90aGVyTGF5ZXInLCAnZ2V0TGF5ZXJzJyxcbiAgICAgICAgJ21vZExheWVyJywgJ2RlbExheWVyJywgJ2NsZWFyTGF5ZXInLCAndG9EYXRhVVJMJywgJ3BhdGhUb0ltYWdlJ1xuICAgIF07XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vdFN1cHBvcnRlZE1ldGhvZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG5hbWUgPSBub3RTdXBwb3J0ZWRNZXRob2RzW2ldO1xuICAgICAgICBWTUxQYWludGVyLnByb3RvdHlwZVtuYW1lXSA9IGNyZWF0ZU1ldGhvZE5vdFN1cHBvcnQobmFtZSk7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBWTUxQYWludGVyO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34venJlbmRlci9saWIvdm1sL1BhaW50ZXIuanNcbiAqKiBtb2R1bGUgaWQgPSA5OVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==