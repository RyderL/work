(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["fishTopoBpmn"] = factory();
	else
		root["fishTopoBpmn"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(1);


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Export fishTopo as CommonJS module
	 */
	module.exports = __webpack_require__(2);
	//兼容IE8 引入VML 如果不需要兼容IE8请删除
	__webpack_require__(109);
	


/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * BPMN对象
	 * @class fish.topo.FishTopoBpmn
	 */
	
	/**
	 * @event click
	 * 节点或者线段的click事件
	 * @param {Object} event 事件 event.target为目标对象 event.target.model为目标对象的业务数据
	 *
	 * **使用范例**：
	 *
	 *      @example
	 *      this.fishTopoBpmn.on("click",function(e) {
	 *          var target = e.target;
	 *          if(FishTopoBpmn.Bpmn.isFlow(target)) { //判断类型
	 *              var lineNode = e.target;
	 *              that.fishTopoBpmn.bindLineDelete(lineNode); //给线段增加删除图标
	 *              //todo
	 *          }
	 *      }
	 */
	
	/**
	 * @event dblclick
	 * 节点或者线段的双击事件
	 * @param {Object} event 事件 event.target为目标对象 event.target.model为目标对象的业务数据
	 *
	 * **使用范例**：
	 *
	 *      @example
	 *          //双击弹出节点对应的json
	 *          this.fishTopoBpmn.on("dblclick",function(e) {
	 *              var target = e.target;
	 *
	 *              if(FishTopoBpmn.Bpmn.isFlow(target)) {
	 *                  console.log("dblclick line");
	 *              }
	 *              else{
	 *                  var json = nodeModel.option;
	 *                  fish.popupView({
	 *                      url: "views/dialog/ExportJsonDlg.js",
	 *                      viewOption:{bpmnJson:JSON.stringify(json,null,4)},
	 *                      callback: function(popup,view) {
	 *                          console.log("OK");
	 *                      },
	 *                      close: function(msg) {
	 *                          console.log("return value: " + msg);
	 *                      }
	 *                  });
	 *              }
	 *          });
	 */
	
	/**
	 * @event create
	 * 节点与线段创建完毕的事件
	 * @param {Object} event 事件 event.target为目标对象 event.target.model为目标对象的业务数据
	 *
	 * **使用范例**：
	 *
	 *      @example
	 *          this.fishTopoBpmn.on("create", function(e) {
	 *              if(FishTopoBpmn.Bpmn.isFlow(e.target)) {
	 *                  var line = e.target;
	 *                  console.log("连线创建完毕，从" + line.startNode.model.get("properties.name") + " 至 " + line.endNode.model.get("properties.name"));
	 *              } else {
	 *                  var node = e.target;
	 *                  console.log("节点：" + node.model.get("properties.name") + " 创建完毕");
	 *              }
	 *          });
	 */
	
	/**
	 * @event delete
	 * 节点与线段创建完毕的事件
	 * @param {Object} event 事件 event.target为目标对象 event.target.model为目标对象的业务数据
	 *
	 * **使用范例**：
	 *
	 *      @example
	 *          //节点删除完毕事件
	 *          this.fishTopoBpmn.on("delete", function(event) {
	 *              console.log("删除的是：" + event.target);
	 *          });
	 */
	
	
	    var graphic = __webpack_require__(3);
	    var ExtensionAPI = __webpack_require__(58);
	    var Point = __webpack_require__(59);
	    var Eventful = __webpack_require__(11);
	    var zrender = __webpack_require__(60);
	    var zrUtil = __webpack_require__(4);
	    var BoundingRect = __webpack_require__(24);
	    var BpmnUtil = __webpack_require__(72);
	    var util = __webpack_require__(73);
	    var BPMNModel = __webpack_require__(78);
	    var BPMNNode = __webpack_require__(75);
	    var OperationNode = __webpack_require__(102);
	    var BpmnConnectionManager = __webpack_require__(104);
	    var Connector = __webpack_require__(96);
	    var LineOperationManager = __webpack_require__(107);
	    var Guidelines = __webpack_require__(108);
	    var Bpmn = __webpack_require__(101);
	
	    function FishTopoBpmn(dom, opts) {
	        this.id;
	        this.group;
	        this._dom = dom;
	        this._zr = zrender.init(dom, {
	            renderer: opts.renderer || 'canvas',
	            devicePixelRatio: opts.devicePixelRatio
	        });
	        this.allNodes = []; //存放所有节点
	        this.subProcessNode = [];  //存放子节点
	        this.domArray = []; //存放节点的位置信息，拖动的时候用到
	        this.overlapArray = []; // 存放节点的位置信息，判断重叠用到，除去了子流程里面的节点
	        this.selectedNode = null;  //选中的节点
	        this.isNode = false;
	        this.rect;  // 对齐线和移动框节点
	        this.operationNode;
	        this.step = 0;//前进后退计步数
	        this.stepJson = [];//存放每步的json
	        this.opts = opts;
	        this._api = new ExtensionAPI(this);
	        /**
	         * @cfg {Boolean} forbidEdit 是否禁用编辑功能
	         */
	        this.forbidEdit = false;
	
	        this.model = new BPMNModel({});
	        this.model.set(Bpmn.RESOURCE_ID, util.getUUID());
	        this.model.set(Bpmn.BPMN_TYPE, Bpmn.TEMPLATE);
	        Eventful.call(this);
	        BpmnUtil.registerBPMNNode();
	    }
	
	    var fishTopoProto = FishTopoBpmn.prototype;
	
	    /**
	     * 获取 fishTopo 实例容器的 dom 节点
	     * @return {HTMLElement}
	     */
	    fishTopoProto.getDom = function() {
	        return this._dom;
	    };
	
	    /**
	     * @private
	     */
	    fishTopoProto.getZr = function() {
	        return this._zr;
	    };
	    /**
	     * 获取 fishTopo 实例容器的宽度。
	     * @return {number}
	     */
	    fishTopoProto.getWidth = function() {
	        return this._zr.getWidth();
	    };
	
	    /**
	     * 获取 fishTopo 实例容器的高度。
	     * @return {number}
	     */
	    fishTopoProto.getHeight = function() {
	        return this._zr.getHeight();
	    };
	
	
	    /**
	     * 当前实例是否已经被释放。
	     * @return {boolean}
	     */
	    fishTopoProto.isDisposed = function() {
	        return this._disposed;
	    };
	
	    /**
	     * Dispose instance
	     */
	    fishTopoProto.dispose = function() {
	        this._disposed = true;
	
	        this._zr.dispose();
	
	        instances[this.id] = null;
	    };
	
	
	    /**
	     * 调整尺寸  在窗口大小发生改变时需要手工调用
	     * @param {number} width 宽度
	     * @param {number} height 高度
	     */
	    fishTopoProto.resize = function(width, height) {
	        $(this.getDom()).css("width", width);
	        $(this.getDom()).css("height", height);
	        this._zr.resize();
	        this._zr.remove(this.group);
	        this.group = new graphic.Group();
	        this.gridLine(0.2);
	        this._zr.add(this.group);
	    };
	
	    /** @private 初始化 */
	    fishTopoProto.init = function() {
	        var that = this;
	        this.group = new graphic.Group();
	        if (this.opts.showGridLine == true || opts.showGridLine == "true") {
	            this.gridLine(0.2);
	            this._zr.add(this.group);
	        }
	
	        //mouseup 会在各个node或线的点击事件之前执行  在选中节点或线前 先清空选中效果
	        this._zr.on("mouseup", function(e) {
	            if (that.operationNode) {
	                that._zr.remove(that.operationNode);
	                that.operationNode = null;
	            }
	            var shape = e.target;
	            if (shape && shape.connector instanceof Connector) {
	                return;
	            }
	            BpmnConnectionManager.clearSelectCon();
	            if (shape && shape.operation && shape.operation == true) {
	                return;
	            }
	            LineOperationManager.hideAllLineOperation();
	        });
	        //派发不是节点或线 的画布点击事件
	        this._zr.on("click", function(e) {
	
	            var shape = e.target;
	            //点击的线
	            if (shape && shape.parent && shape.parent.resourceId) {
	                return;
	            } else {
	                var params = {};
	                params.event = e;
	                params.type = "click";
	                params.target = that;
	                that._api.trigger(params.type, params);
	            }
	        });
	        this.on('conPointsGroup:click', function(argument) {
	            LineOperationManager.bindOperation(argument.lineNode);
	        })
	    };
	
	    /**
	     * 根据传过来的值  设置节点模型
	     * @param {Object} shape  节点或线
	     * @param {Object} option 模型数据
	     * @param {number} width 宽度(仅用于调整画布大小)
	     * @param {number} height 高度(仅用于调整画布大小)
	     */
	    fishTopoProto.setShapeModel = function(shape, option, width, height) {
	        if (Bpmn.isTemplate(shape)) {
	            this.model.mergeOption(option);
	            if (width > 0 && height > 0) {
	                this.resize(width, height);
	            }
	        } else if (Bpmn.isFlow(shape)) {
	            BpmnConnectionManager.setModel(shape, option);
	        } else {
	            shape.setModel(option);
	        }
	    };
	
	    /**
	     * 清空当前实例，会移除实例中所有的节点与线
	     * @method clear
	     */
	    fishTopoProto.clear = function(isNoCount) {
	        this.allNodes = [];
	
	        this.subProcessNode = [];
	
	        this.domArray = [];
	
	        this.overlapArray = [];
	
	        this.selectedNode = null;
	        this.rect = null;
	        BpmnConnectionManager.connectors = [];
	        this._zr.clear();
	        this._zr.add(this.group); // 画网格线  代码放这比较恶心 后面改
	        if (isNoCount != true) {
	            this.stepCounter();
	        }
	    };
	
	    /**
	     * 设置是否显示网络线
	     * @param  {Boolean} isForbidden 是否显示网络线
	     */
	    fishTopoProto.forbidGridLine = function(isForbidden) {
	        if (isForbidden == true) {
	            this._zr.remove(this.group);
	        } else {
	            this._zr.remove(this.group);
	            this.group = new graphic.Group();
	            this.gridLine(0.2);
	            this._zr.add(this.group);
	        }
	    };
	
	    /**
	     * 导出json
	     * @return {string} json字符串
	     */
	    fishTopoProto.toJson = function() {
	        return BpmnUtil.toJson(this.model, this.allNodes, BpmnConnectionManager.connectors);
	    };
	
	    /**
	     * 导入json
	     * @param  {string} json json格式的字符串
	     */
	    fishTopoProto.fromJson = function(json) {
	        BpmnUtil.fromJson(this, json);
	    };
	
	    //背景网格线
	    fishTopoProto.gridLine = function(opacity) {
	        var pixel = this.opts.gridLineSpacing;
	        var widthLen = parseInt(this.getWidth() / pixel);
	        for (var x = 0; x <= widthLen; x++) {
	            var lineX = new graphic.Line({
	                shape: {
	                    x1: x * pixel,
	                    y1: 0,
	                    x2: x * pixel,
	                    y2: this.getHeight()
	                },
	                style: {
	                    lineDash: [1],
	                    opacity: opacity
	                },
	                z: 0,
	                draggable: false,
	                cursor: 'default'
	            });
	            this.group.add(lineX);
	        }
	
	        var heightLen = parseInt(this.getHeight() / pixel, pixel);
	        for (var y = 0; y <= heightLen; y++) {
	            var lineY = new graphic.Line({
	                shape: {
	                    x1: 0,
	                    y1: y * pixel,
	                    x2: this.getWidth(),
	                    y2: y * pixel
	                },
	                style: {
	                    lineDash: [1],
	                    opacity: opacity
	                },
	                z: 0,
	                draggable: false,
	                cursor: 'default'
	            });
	            this.group.add(lineY);
	        }
	    };
	
	
	    /**
	     * 通过界面拖动 增加节点
	     * @param {string} itemType 创建节点的类型（已有预定义类型包括StartNoneEvent、EndNoneEvent、UserTask、ManualTask、ScriptTask、MailTask、CatchTimerEvent、CatchSignalEvent、ThrowSignalEvent、InclusiveGateway、ExclusiveGateway、ParallelGateway、SubProcess）
	     * @param {number} x        节点创建的x坐标
	     * @param {number} y        节点创建的y坐标
	     * @param {Object} options 选项
	     * @param {Object} [options.name] 节点下面显示名称
	     * @param {Array} [options.operationIcons] 设置选中节点时 显示的操作小图标， 默认提供了 删除、直线、折线、曲线4种图标，也可以自定图标 eg.
	     * <pre>
	     *          operationIcons: [{ name: 'DEL' },
	     *              { name: 'STRAIGHT' },
	     *              { name: 'JAGGED' },
	     *              { name: 'CURVE' },
	     *              {
	     *                  name: "custom1",
	     *                  iconPath: "img/host.png",
	     *                  callback: function(e) { alert(e.data.name + " clicked") }  //e.node是当前的节点
	     *              }
	     *          ]
	     * </pre>
	     * @param {Object} userData 用户传递的业务数据
	     *
	     * **使用范例**：
	     *
	     *      @example
	     *      fishTopo.addNode(itemType, x, y, {
	     *                      name: itemType,   //节点的名称
	     *                      operationIcons:[{name:'DEL'},{ name: 'STRAIGHT' },{name:'JAGGED'},{ name: 'CURVE' }],
	     *                      // 增加节点操作图标 上面分别是"删除、直线、折线、曲线"，
	     *                      // 也可以增加自定图标 如{name: "custom1", iconPath: "img/host.png", callback: function(e) { alert(e.data.name + " clicked") }} //e.node是当前的节点
	     *                      userData:{businessData:'我是业务数据,通过Bpmn.getUserData可获取'}
	     *                      // 增加节点的自定义业务，可以通过Bpmn.getUserData(node)获取
	     *                  });
	     */
	    fishTopoProto.addNode = function(itemType, x, y, options) {
	
	        //判断是否在范围内
	        if (x >= 0 && y >= 0) {
	            var model = new BPMNModel({});
	            model.set(Bpmn.BPMN_TYPE, itemType);
	            model.set("bounds.upperLeft", {x: x, y: y});
	            if (options) {
	                model.set("properties", options);
	            }
	
	            return this.addNodeByModel(model, true);
	        }
	    };
	
	    /**
	     * 根据模型增加节点
	     * @private
	     * @param {Object} model [description]
	     * @return {Object} 创建完成的节点
	     */
	    fishTopoProto.addNodeByModel = function(model, isFromDrag, isNoCount) {
	        var that = this;
	        var Shape = BPMNNode.getClass(model.get(Bpmn.BPMN_TYPE));
	        var mesArray;
	        if (Shape) {
	            var node = new Shape(model, this._api);
	            if (this.subProcessNode.length == 0) {
	                this._zr.add(node);
	                mesArray = {
	                    id: node.id,
	                    position: [node.getRect().x, node.getRect().y],
	                    width: node.getRect().width,
	                    height: node.getRect().height
	                };
	                if (!Bpmn.isSlotEvent(node)) {
	                    this.overlapArray.push(mesArray);
	                }
	
	            } else {
	                this._zr.add(node);
	                mesArray = {
	                    id: node.id,
	                    position: [node.getRect().x, node.getRect().y],
	                    width: node.getRect().width,
	                    height: node.getRect().height
	                };
	                if (!Bpmn.isSlotEvent(node)) {
	                    this.overlapArray.push(mesArray);
	                }
	                if (isFromDrag) {
	                    //1.判断所有的子节点
	                    for (var i = 0; i < this.subProcessNode.length; i++) {
	                        //2.如果节点拖放在 子节点中
	                        if (this.subProcessNode[i].rectContain(node.getRect().x, node.getRect().y)) {
	                            //2.1重新计算节点在 子节点中的位置  并加入到子节点
	                            var groupNodePositionX = this.subProcessNode[i].getRect().width / 2 + (node.getRect().x - this.subProcessNode[i].getRect().x);
	                            var groupNodePositionY = this.subProcessNode[i].getRect().height / 2 + (node.getRect().y - this.subProcessNode[i].getRect().y);
	                            node.setPosition(groupNodePositionX, groupNodePositionY);
	                            this.subProcessNode[i].add(node);
	                            //2.2从zr中删除
	                            this._zr.remove(node);
	                            //2.3从 节点位置 信息数组中删除此节点
	                            for (var j = 0; j < that.overlapArray.length; j++) {
	                                if (node.id == that.overlapArray[j].id) {
	                                    that.overlapArray.splice(j, 1);
	                                }
	                            }
	                            break;
	                        }
	                    }
	                }
	
	            }
	            //2.如果是子节点 则加入到子节点数组中
	            if (Bpmn.isSubProcess(node)) {
	                this.subProcessNode.push(node);
	            }
	            this.allNodes.push(node);
	            //放入节点位置信息 用于拖拽
	            this.domArray.push(mesArray);
	
	            //侦听节点的事件 并把事件给取消掉 防止 如果父是子节点侦听到
	            node.on('mousedown', function(e) {
	                if (that.forbidEdit == true) {
	                    return;
	                }
	                that.newDrag(this, e.event.clientX, e.event.clientY);
	                //如果选择的是事件节点，则为其他task绑定插槽
	                if (Bpmn.isSlotEvent(this)) {
	                    that.bindEventNode();
	                }
	                e.cancelBubble = true;
	            });
	            node.on('click', function(e) {
	
	                that.nodeClickHandler(this);
	                e.cancelBubble = true;
	            });
	
	            //添加tip
	            if (Bpmn.isActivity(node)) {
	                that.creatTip(node);
	            }
	
	            node.on("mouseover", function() {
	                if (this.alarm && this.alarm.isShow == true) {
	
	                    this.alarm.show();
	                    this.alarm.eachChild(function(child) {
	                        child.show();
	                    });
	                    //根据字内容更改tip外框的大小
	                    var text = this.alarm.childOfName("Text");
	                    var groupWidth = text.getBoundingRect().width + 4;
	                    var groupHeight = text.getBoundingRect().height + 8;
	                    var points = [
	                        [0, 0],
	                        [groupWidth, 0],
	                        [groupWidth, groupHeight],
	                        [groupWidth / 2 - 3, groupHeight],
	                        [groupWidth / 2, groupHeight + 3],
	                        [groupWidth / 2 + 3, groupHeight],
	                        [0, groupHeight],
	                        [0, 0]
	                    ];
	                    var Polyline = this.alarm.childOfName("Polyline");
	                    Polyline.attr("shape", {points: points});
	                    var groupPosition = [node.position[0] + node.getBoundingRect().width - this.alarm.getBoundingRect().width / 2, node.position[1] - this.alarm.getBoundingRect().height - 3];
	                    this.alarm.attr("position", groupPosition);
	                }
	            });
	            node.on("mouseout", function() {
	                if (this.alarm) {
	                    this.alarm.hide();
	                    this.alarm.eachChild(function(child) {
	                        child.hide();
	                    });
	                }
	            });
	            this._triggerCreateEvent(node);
	            if (isNoCount != true) {
	                this.stepCounter();
	            }
	            return node;
	        }
	    };
	
	    /**
	     * 根据name获取节点
	     * @param  {String} name 在创建节点中  name属性设置的值
	     * @return {Object}      name对应的节点
	     */
	    fishTopoProto.childOfName = function(name) {
	        var arrResult = [];
	        for (var i = 0; i < this.allNodes.length; i++) {
	            if (this.allNodes[i].model.get("properties.name") == name) {
	                arrResult.push(this.allNodes[i]);
	            }
	        }
	        if (arrResult.length > 1) {
	            return arrResult;
	        } else {
	            return arrResult[0];
	        }
	    };
	
	    /**
	     * 查找场景中的对象   例如: x坐标大于100的节点 findElements(function(e){ return e.position[0] > 100; });
	     * @param  {Function} cb      回调函数
	     * @param  {Object}   context 回调函数执行的上下文
	     * @return {Array}           返回查找到的对象
	     */
	    fishTopoProto.findElements = function(cb, context) {
	        var childrenNode = this.allNodes;
	        var childrenLine = BpmnConnectionManager.connectors;
	        var arr = [];
	        for (var i = 0; i < childrenNode.length; i++) {
	            var child = childrenNode[i];
	            if (cb.call(context, child, i)) {
	                arr.push(child);
	            }
	        }
	        for (var j = 0; j < childrenLine.length; j++) {
	            var childLine = childrenLine[j];
	            if (cb.call(context, childLine, j)) {
	                arr.push(childLine);
	            }
	        }
	        return arr;
	    };
	
	    /**
	     * @private
	     * 根据模型增加线
	     */
	    fishTopoProto.addConnectorByModel = function(model, parentZr) {
	        var that = this;
	        //找出 startNode 与 endNode
	        var startNode = null,
	            endNode = null;
	        zrUtil.each(this.allNodes, function(node) {
	            //startNode: 从allNode中找出outgoing为 线的id的起始节点
	            var nodeOutgoing = node.model.get("outgoing");
	            if (nodeOutgoing.indexOf(model.get("resourceId")) !== -1) {
	                startNode = node;
	            }
	            //endNode : 从allNode中找出 id 为线的outgoing的结束节点
	            var connectorOutgoing = model.get("outgoing");
	            if (connectorOutgoing.indexOf(node.resourceId) !== -1) {
	                endNode = node;
	            }
	        });
	        if (startNode && endNode) {
	            var connector = BpmnConnectionManager.connectorCreateByOptions(startNode, endNode, {model: model}, this._api);
	            if (parentZr) {
	                parentZr.add(connector);
	            } else {
	
	                this._zr.add(connector);
	            }
	            connector.on("mousedown", function() {
	                BpmnConnectionManager.connectorForbidEdit(that.forbidEdit);
	                LineOperationManager.isEdit = !that.forbidEdit;
	                that.isNode = false;
	            });
	        }
	
	    };
	
	    /**
	     * 创建连线的小图标操作
	     * @param {string} key 小图标的名称
	     * @param {Object} obj 小图标的相关参数
	     * @param {Object} options 小图标选项
	     * @param {String} [options.icon] 小图标路径
	     * @param {Object} [options.lineNode] 线段实例
	     * @param {Function} [options.callback] 点击后的回调
	     *
	     * **使用范例**：
	     *
	     *      @example
	     *      fishTopoBpmn.addIcon("icon1",{  //线上图标的名称
	     *                    icon:"bpmn2.0/icons/activity/list/mail.send.png", //线上图标的路径
	     *                     lineNode:lineNode,  //线
	     *                     callback:function(lineNode){  //回调
	     *                          alert(JSON.stringify(lineNode))
	     *                      },
	     *                  });*
	     */
	    fishTopoProto.addIcon = function(key, obj) {
	        LineOperationManager.addIcon(key, obj, this._zr, this._api);
	    };
	
	    /**
	     * 创建连线的默认删除操作
	     * @param  {Object} lineNode 线
	     *
	     *  **使用范例**：
	     *
	     *      @example
	     *      fishTopoBpmn.bindLineDelete(lineNode);
	     */
	    fishTopoProto.bindLineDelete = function(lineNode) {
	        var that = this;
	        var parentZr;
	        if (lineNode.parent) {
	            parentZr = lineNode.parent;
	        } else {
	            parentZr = that._zr;
	        }
	        //创建删除
	        var lineOperation = LineOperationManager.addIcon("delete", LineOperationManager.deleteIconObj(parentZr, lineNode), parentZr, this._api);
	        if (lineOperation) {
	            lineOperation.on("click", function() {
	                that._triggerDeleteEvent(lineNode);
	            });
	        }
	    };
	    /**
	     * @private
	     * 返回 连向该节点的节点数组：nodeArray[0]  以及该节点连向的节点数组 nodeArray[0]
	     */
	    fishTopoProto.checkLineNode = function(node) {
	        var startArray = [],
	            endArray = [];
	        var lineArray = BpmnConnectionManager.connectors;
	        for (var i = 0, len = lineArray.length; i < len; i++) {
	            if (lineArray[i].startNode == node) {
	                endArray.push(lineArray[i].endNode);
	            }
	        }
	        for (var j = 0, lenEnd = lineArray.length; j < lenEnd; j++) {
	            if (lineArray[j].endNode == node) {
	                startArray.push(lineArray[j].startNode);
	            }
	        }
	        return [startArray, endArray];
	    };
	    /**
	     * @private
	     * 初始化 操作的虚线框
	     */
	    fishTopoProto.initOperationNode = function(node) {
	        var that = this;
	        this.operationNode = new OperationNode(node, that._zr, this.forbidEdit);
	        // 侦听 箭头 拖拽开始事件
	        this.operationNode.on(OperationNode.ARROW_DRAGSTART, function(e) {
	            var x = e.event.offsetX;
	            var y = e.event.offsetY;
	            //拖拽开始先把 箭头图标 给隐藏
	            var arrow = e.event.target;
	            arrow.hide();
	            var rEndPoint = new Point(x, y);
	            if (that.selectedNode.parent && Bpmn.isSubProcess(that.selectedNode.parent)) {
	                var subProcessNode = that.selectedNode.parent;
	                rEndPoint = new Point(x - subProcessNode.position[0], y - subProcessNode.position[1]);
	            }
	
	            var connector = BpmnConnectionManager.manageTempConnector(that.selectedNode, rEndPoint, arrow.lineType);
	            if (that.selectedNode.parent && Bpmn.isSubProcess(that.selectedNode.parent)) {
	                that.selectedNode.parent.add(connector);
	            } else {
	                that._zr.add(connector);
	            }
	        });
	
	        // 侦听 箭头 拖拽事件
	        this.operationNode.on(OperationNode.ARROW_DRAG, function(e) {
	            var x = e.event.offsetX;
	            var y = e.event.offsetY;
	            var rEndPoint = new Point(x, y);
	            var arrow = e.event.target;
	            if (that.selectedNode.parent && Bpmn.isSubProcess(that.selectedNode.parent)) {
	                var subProcessNode = that.selectedNode.parent;
	                rEndPoint = new Point(x - subProcessNode.position[0], y - subProcessNode.position[1]);
	            }
	            BpmnConnectionManager.manageTempConnector(that.selectedNode, rEndPoint, arrow.lineType);
	        });
	
	        //侦听 箭头 拖拽结束事件 画线
	        this.operationNode.on(OperationNode.ARROW_DRAGEND, function(e) {
	            var x = e.event.offsetX;
	            var y = e.event.offsetY;
	            var targetNode = null;
	            //拖拽结束先把 箭头图标 给显示
	            var arrow = e.event.target;
	            arrow.show();
	
	            //1.如果是子节点 内 节点拖拽 则 增加排除子节点的参数
	            if (node.parent) {
	                if (Bpmn.isSubProcess(node.parent)) {
	                    //删除临时线
	                    BpmnConnectionManager.removeTempConnector(node.parent);
	                    targetNode = BpmnUtil.findHover(that.allNodes, x, y, that.subProcessNode);
	                }
	            } else {
	                targetNode = BpmnUtil.findHover(that.allNodes, x, y);
	                //删除临时线
	                BpmnConnectionManager.removeTempConnector(that._zr);
	            }
	            //2.如果找到目标结点 则画线
	            if (targetNode && (that.selectedNode != targetNode)) {
	                that._createConnectorByNodes(that.selectedNode, targetNode, arrow.lineType);
	            }
	            var shapeRect = that.selectedNode.getRect();
	            that.operationNode.render(node, that._zr, shapeRect);
	            that.stepCounter();
	        });
	        //删除按钮点击事件
	        this.operationNode.on("OperationNode:deleteClick", function() {
	            that._triggerDeleteEvent(that.selectedNode);
	            that.removeNode(that.selectedNode);
	            that.stepCounter();
	        });
	        //放大缩小拖动过程
	        this.operationNode.on("OperationNode:scaleDragLeft", function(e) {
	            this.virtualRect.setShape({points: e.points});
	        });
	        this.operationNode.on("OperationNode:scaleDragRight", function(e) {
	            this.virtualRect.setShape({points: e.points});
	        });
	        //放大缩小拖动结束
	        this.operationNode.on("OperationNode:scaleDragEnd", function(e) {
	            //1.进行节点大小的设置，并维护位置信息数组
	            if (this.virtualRect.shape.points || this.virtualRect.shape.points != null) {
	                var width = this.virtualRect.shape.points[1][0] - this.virtualRect.shape.points[0][0] - 1;
	                var height = this.virtualRect.shape.points[2][1] - this.virtualRect.shape.points[1][1] - 1;
	                var position;
	                if (e.arrowName == "left") {
	                    position = [that.selectedNode.position[0] - (width + 1 - that.selectedNode.getRect().width), that.selectedNode.position[1] - (height + 1 - that.selectedNode.getRect().height)];
	                }
	                if (e.arrowName == "right") {
	                    position = [that.selectedNode.position[0], that.selectedNode.position[1]];
	                }
	                that.selectedNode.refresh({shape: {width: width, height: height}});
	                var isChange = true;
	                if (height + 1 < that.selectedNode.getBoundingRect().height) {
	                    that.selectedNode.refresh({shape: {height: that.selectedNode.getBoundingRect().height}});
	                    isChange = false;
	                }
	                if (width + 1 < that.selectedNode.getBoundingRect().width) {
	                    that.selectedNode.refresh({shape: {width: that.selectedNode.getBoundingRect().width}});
	                    isChange = false;
	                }
	                if (isChange == true) {
	                    that.selectedNode.refresh({position: position});
	                }
	                for (var m = 0; m < that.domArray.length; m++) {
	                    if (that.selectedNode.id == that.domArray[m].id) {
	                        that.domArray[m].position = [position[0] + (width + 1) / 2, position[1] + (height + 1) / 2];
	                    }
	                }
	                that.nodeClickHandler(that.selectedNode);
	                for (var n = 0; n < that.overlapArray.length; n++) {
	                    if (that.selectedNode.id == that.overlapArray[n].id) {
	                        that.overlapArray[n] = {
	                            id: that.selectedNode.id,
	                            position: [that.selectedNode.getRect().x, that.selectedNode.getRect().y],
	                            width: that.selectedNode.getRect().width,
	                            height: that.selectedNode.getRect().height
	                        };
	                    }
	                }
	            }
	            //2.刷新线
	            BpmnConnectionManager.refreshLineByNode(that.selectedNode);
	            var endSlotPoints = util.getSoltPoints(that.selectedNode);
	            if (that.selectedNode.slotEvent && that.selectedNode.slotEvent.length > 0) {
	                for (var i = 0; i < that.selectedNode.slotEvent.length; i++) {
	                    var slotNode = that.selectedNode.slotEvent[i];
	                    for (var j = 0; j < e.startSlotPoints.length; j++) {
	                        if (that.selectedNode.slotEvent[i].position[0] - e.startPosition[0] == e.startSlotPoints[j][0] && that.selectedNode.slotEvent[i].position[1] - e.startPosition[1] == e.startSlotPoints[j][1]) {
	                            that.selectedNode.slotEvent[i].attr("position", [endSlotPoints[j][0] + that.selectedNode.position[0], endSlotPoints[j][1] + that.selectedNode.position[1]]);
	                            BpmnConnectionManager.refreshLineByNode(that.selectedNode.slotEvent[i]);
	                        }
	                    }
	                }
	            }
	            that.stepCounter();
	        });
	        this._zr.add(this.operationNode);
	
	
	    };
	
	    /**
	     * 移除场景中的某个节点
	     * @param  {Object} selectedNode 待删除的节点
	     */
	    fishTopoProto.removeNode = function(selectedNode) {
	        var that = this;
	        //1.如果是子节点 内 节点  则 调用子节点的删除
	        var parentZr;
	        if (selectedNode.parent) {
	            parentZr = selectedNode.parent;
	        } else {
	            parentZr = that._zr;
	        }
	        parentZr.remove(selectedNode);
	        //2.从allNodes数组中删除
	        for (var i = 0; i < that.allNodes.length; i++) {
	            if (selectedNode.id == that.allNodes[i].id) {
	                that.allNodes.splice(i, 1);
	            }
	        }
	        for (var j = 0; j < that.domArray.length; j++) {
	            if (selectedNode.id == that.domArray[j].id) {
	                that.domArray.splice(j, 1);
	            }
	        }
	        for (var k = 0; k < that.overlapArray.length; k++) {
	            if (selectedNode.id == that.overlapArray[k].id) {
	                that.overlapArray.splice(k, 1);
	            }
	        }
	        //3.将此节点交联的线也删除
	        BpmnConnectionManager.deleteSelectCon(selectedNode, parentZr);
	        //如果删除节点是task节点，需要将依附它的事件节点删除
	        if (Bpmn.isActivity(selectedNode) || Bpmn.isSubProcess(selectedNode)) {
	            if (selectedNode.slotEvent && selectedNode.slotEvent.length > 0) {
	                for (var m = 0; m < selectedNode.slotEvent.length; m++) {
	                    if (selectedNode.slotEvent[m].parent) {
	                        if (Bpmn.isSubProcess(selectedNode.slotEvent[m].parent)) {
	                            selectedNode.slotEvent[m].parent.remove(selectedNode.slotEvent[m]);
	                        }
	                    } else {
	                        that._zr.remove(selectedNode.slotEvent[m]);
	                    }
	                    for (var n = 0; n < that.allNodes.length; n++) {
	                        if (selectedNode.slotEvent[m].id == that.allNodes[n].id) {
	                            that.allNodes.splice(n, 1);
	                        }
	                    }
	                    for (var a = 0; a < that.domArray.length; a++) {
	                        if (selectedNode.slotEvent[m].id == that.domArray[a].id) {
	                            that.domArray.splice(a, 1);
	                        }
	                    }
	                }
	            }
	        }
	        //4.如果删除的是事件节点，需要将绑定它的task节点的标识删除
	        if (Bpmn.isSlotEvent(selectedNode)) {
	            for (var b = 0; b < that.allNodes.length; b++) {
	                if (that.allNodes[b].isCanSlot) {
	                    if (that.allNodes[b].slotEvent && that.allNodes[b].slotEvent.length > 0) {
	                        for (var c = 0; c < that.allNodes[b].slotEvent.length; c++) {
	                            if (selectedNode.id == that.allNodes[b].slotEvent[c].id) {
	                                that.allNodes[b].slotEvent.splice(c, 1);
	                            }
	                        }
	                    }
	                }
	            }
	        }
	        this.stepCounter();
	    };
	
	    fishTopoProto._createConnectorByNodes = function(startNode, endNode, lineType) {
	        var connector = BpmnConnectionManager.connectorCreate(startNode, endNode, lineType, this._api);
	        if (startNode.parent && endNode.parent) {
	            endNode.parent.add(connector);
	        } else {
	            this._zr.add(connector);
	        }
	        connector.on("mousedown", zrUtil.bind(function() {
	            BpmnConnectionManager.connectorForbidEdit(this.forbidEdit);
	            LineOperationManager.isEdit = !this.forbidEdit;
	            this.isNode = false;
	        }, this));
	
	        this._triggerCreateEvent(connector);
	        return connector;
	    };
	
	    fishTopoProto._triggerDeleteEvent = function(target) {
	        var eventParams = {};
	        eventParams.type = "delete";
	        eventParams.target = target;
	        this._api.trigger(eventParams.type, eventParams);
	    };
	    fishTopoProto._triggerCreateEvent = function(target) {
	        var eventParams = {};
	        eventParams.type = "create";
	        eventParams.target = target;
	        this._api.trigger(eventParams.type, eventParams);
	    };
	
	    /**
	     * @private
	     * 鼠标点下 将操作框 移到对应的节点上
	     * @param  {Object} node [description]
	     * @return {Object}      [description]
	     */
	    fishTopoProto.nodeClickHandler = function(node) {
	        var that = this;
	        this.selectedNode = node;
	        var shapeRect = node.getRect();
	        if (!this.operationNode) {
	            this.initOperationNode(node);
	        }
	        if (!this.forbidEdit) {
	            that.rect.attr("style", {
	                stroke: "rgba(0, 0, 0, 1)"
	            });
	        }
	
	        this.operationNode.refreshPostion(node, shapeRect);
	    };
	
	    /**
	     * 初始化虚框对齐线
	     * @private
	     * @param  {Object} shapeList [description]
	     */
	    fishTopoProto.initVirtualLine = function(shapeList) {
	        Guidelines.createGuidelines(this._zr);
	        this.rect = new graphic.Polyline({
	            position: [shapeList.x, shapeList.y],
	            shape: {
	                points: shapeList.points
	            },
	            style: {
	                lineDash: [2]
	            },
	            z: 3
	        });
	        this._zr.add(this.rect);
	    };
	    //绑定事件节点
	    fishTopoProto.bindEventNode = function() {
	        var that = this;
	        //mousedown的时候为每个task创建插槽
	        for (var i = 0; i < that.allNodes.length; i++) {
	            if (that.allNodes[i].isCanSlot) {
	                that.creatSlot(that.allNodes[i]);
	            }
	        }
	        //mouseup的时候删除插槽
	        that._zr.on("mouseup", function() {
	            for (var i = 0; i < that.allNodes.length; i++) {
	                if (that.allNodes[i].isCanSlot) {
	                    if (that.allNodes[i].slot && that.allNodes[i].slot.length > 0) {
	                        for (var m = 0; m < that.allNodes[i].slot.length; m++) {
	                            that.allNodes[i].remove(that.allNodes[i].slot[m]);
	                        }
	                    }
	                }
	            }
	        })
	
	    };
	
	    /**
	     * @private
	     */
	    fishTopoProto.creatSlot = function(node) {
	        //给task创建8个插槽
	        node.slot = [];
	        var position = util.getSoltPoints(node);
	        for (var j = 0; j < 8; j++) {
	            var Circle = new graphic.Circle({
	                position: position[j],
	                shape: {
	                    cx: 0,
	                    cy: 0,
	                    r: 10
	                },
	                style: {
	                    lineWidth: 1,
	                    stroke: 'rgba(0,0,0,0.6)',
	                    fill: 'transparent'
	                }
	            });
	            node.slot.push(Circle);
	            node.add(Circle);
	        }
	    };
	
	    /**
	     * @private
	     * mousedown后 开始拖动
	     */
	    fishTopoProto.newDrag = function(dom, sX, sY) {
	        var that = this;
	        that.selectedNode = dom;
	        that.isNode = true;
	        var pixel = this.opts.gridLineSpacing;
	        var shapeList = dom.getRect();
	        var domArray = that.domArray;
	        //zrender不支持键盘事件，只能侦听body元素上的了
	        $('body').one('keydown', function(e) {
	            var ev = e || window.event;
	            //判断 delete按键
	            if (ev.keycode == 46 || ev.charCode == 46 || ev.which == 46) {
	                //1.如果是节点,移除事件,进行删除  如果是子节点 通过parent删除
	                if (that.isNode == true) {
	                    that.selectedNode.off();
	                    if (that.selectedNode.parent) {
	                        if (Bpmn.isSubProcess(that.selectedNode.parent)) {
	                            that.selectedNode.parent.remove(that.selectedNode);
	                        }
	                    } else {
	                        that._zr.remove(that.selectedNode);
	                    }
	                    //2.删除维护的节点数组
	                    for (var i = 0; i < that.allNodes.length; i++) {
	                        if (that.selectedNode.id == that.allNodes[i].id) {
	                            that.allNodes.splice(i, 1);
	                        }
	                    }
	                    for (var j = 0; j < domArray.length; j++) {
	                        if (that.selectedNode.id == domArray[j].id) {
	                            domArray.splice(j, 1);
	                        }
	                    }
	                    for (var k = 0; k < that.overlapArray.length; k++) {
	                        if (that.selectedNode.id == that.overlapArray[k].id) {
	                            that.overlapArray.splice(k, 1);
	                        }
	                    }
	                    //3.移去操作框
	                    if (that.operationNode) {
	                        that._zr.remove(that.operationNode);
	                        that.operationNode = null;
	                    }
	                    //3.删除对应的线
	                    BpmnConnectionManager.deleteSelectCon(that.selectedNode, that._zr);
	                } else { //否则直接删除线
	                    BpmnConnectionManager.deleteLine(that._zr);
	                }
	                this.stepCounter();
	            }
	        });
	
	        //初始化 对齐线
	        var startX, startY, rectPositionX, rectPositionY;
	        startX = sX;
	        startY = sY;
	        if (dom.parent) {
	            if (Bpmn.isSubProcess(dom.parent)) {
	                rectPositionX = shapeList.x + dom.parent.position[0];
	                rectPositionY = shapeList.y + dom.parent.position[1];
	            }
	        } else {
	            rectPositionX = shapeList.x;
	            rectPositionY = shapeList.y;
	        }
	        if (!that.rect) {
	            that.initVirtualLine(shapeList);
	            that.rect.attr("position", [rectPositionX, rectPositionY]);
	        } else {
	            that.rect.attr("position", [rectPositionX, rectPositionY]);
	            that.rect.setShape({points: shapeList.points});
	            that.rect.show();
	        }
	
	        var nowRectPosition = [rectPositionX, rectPositionY];
	        var isLap = 0;
	        var isMove = 0;
	        var moveFunction = function(e) {
	            moveDrag(e);
	        };
	        var upFunction = function(e) {
	            endDrag(e);
	        };
	        this._zr.on('mousemove', moveFunction);
	
	        //开始移动
	        function moveDrag(e) {
	            //以10个像素为单位进行移动
	            var maxRectPosition = [that.getWidth() - (that.rect.shape.points[1][0] - that.rect.shape.points[0][0]) / 2, that.getHeight() - (that.rect.shape.points[2][1] - that.rect.shape.points[1][1]) / 2];
	            var minRectPosition = [(that.rect.shape.points[1][0] - that.rect.shape.points[0][0]) / 2, (that.rect.shape.points[2][1] - that.rect.shape.points[1][1]) / 2];
	            for (var n = 0; n < Math.abs(parseInt((e.event.clientX - startX) / pixel)); n++) {
	                isMove = 1;
	                if (e.event.clientX - startX < 0) {
	                    nowRectPosition[0] = rectPositionX - pixel * (n);
	                } else {
	                    nowRectPosition[0] = rectPositionX + pixel * (n);
	                }
	                if (nowRectPosition[0] < minRectPosition[0]) {
	                    nowRectPosition[0] = minRectPosition[0];
	                }
	                if (nowRectPosition[0] > maxRectPosition[0]) {
	                    nowRectPosition[0] = maxRectPosition[0];
	                }
	            }
	            for (var m = 0; m < Math.abs(parseInt((e.event.clientY - startY) / pixel)); m++) {
	                isMove = 1;
	                if (e.event.clientY - startY < 0) {
	                    nowRectPosition[1] = rectPositionY - pixel * (m);
	                } else {
	                    nowRectPosition[1] = rectPositionY + pixel * (m);
	                }
	                if (nowRectPosition[1] < minRectPosition[1]) {
	                    nowRectPosition[1] = minRectPosition[1];
	                }
	                if (nowRectPosition[1] > maxRectPosition[1]) {
	                    nowRectPosition[1] = maxRectPosition[1];
	                }
	            }
	            that.rect.attr('position', nowRectPosition);
	
	            Guidelines.judgeAlignment(nowRectPosition, domArray, that.getWidth(), that.getHeight());
	            // 如果处于子节点内部  则不允许拖到外面 虚框标红
	            if (dom.parent) {
	                var centerX = Math.abs(nowRectPosition[0] - dom.parent.getRect().x);
	                var widthX = Math.abs(dom.getRect().width / 2 - dom.parent.getRect().width / 2);
	                var centerY = Math.abs(nowRectPosition[1] - dom.parent.getRect().y);
	                var heightY = Math.abs(dom.getRect().height / 2 - dom.parent.getRect().height / 2);
	                if (centerX > (widthX - pixel) || centerY > (heightY - pixel)) {
	                    resultFalse();
	                } else {
	                    resultSuccess();
	                }
	            }
	
	            function resultSuccess() {
	                isLap = 0;
	                that.rect.attr("style", {
	                    stroke: "rgba(0, 0, 0, 1)"
	                });
	            }
	
	            function resultFalse() {
	                isLap = 1;
	                that.rect.attr("style", {
	                    stroke: "rgba(255, 0, 0, 1)"
	                });
	            }
	
	            //判断是否有重叠  排除去了子流程里面的节点
	            if (!dom.parent) {
	                for (var l = 0, len = that.overlapArray.length; l < len; l++) {
	                    var rectDom = that.overlapArray[l];
	                    resultSuccess();
	                    //与拖拽节点不相等
	                    if (rectDom.id != that.rect.id && rectDom.id != dom.id) {
	                        if (shapeList.width > rectDom.width) {
	                            ////移动的位置 减去当前节点的位置 小于拖拽节点高度及宽度一半， 则有重叠 标红
	                            if (shapeList.height > rectDom.height) {
	                                if (Math.abs(nowRectPosition[0] - (rectDom.position[0])) < shapeList.width / 2 && Math.abs(nowRectPosition[1] - (rectDom.position[1])) < shapeList.height / 2) {
	                                    resultFalse();
	                                    break;
	                                } else {
	                                    resultSuccess();
	                                }
	                            } else {
	                                if (Math.abs(nowRectPosition[0] - (rectDom.position[0])) < shapeList.width / 2 && Math.abs(nowRectPosition[1] - (rectDom.position[1])) < rectDom.height / 2) {
	                                    resultFalse();
	                                    break;
	                                } else {
	                                    resultSuccess();
	                                }
	                            }
	
	                        } else {
	                            if (shapeList.height > rectDom.height) {
	                                if (Math.abs(nowRectPosition[0] - (rectDom.position[0])) < rectDom.width / 2 && Math.abs(nowRectPosition[1] - (rectDom.position[1])) < shapeList.height / 2) {
	                                    resultFalse();
	                                    break;
	                                } else {
	                                    resultSuccess();
	                                }
	                            } else {
	                                if (Math.abs(nowRectPosition[0] - (rectDom.position[0])) < (rectDom.width / 2) && Math.abs(nowRectPosition[1] - (rectDom.position[1])) < (rectDom.height / 2)) {
	                                    resultFalse();
	                                    break;
	                                } else {
	                                    resultSuccess();
	                                }
	                            }
	
	                        }
	
	                    }
	                }
	            }
	            //判断事件节点是否可以依附，可以依附显示绿框
	            if (Bpmn.isSlotEvent(dom)) {
	                for (var i = 0; i < that.allNodes.length; i++) {
	                    if (that.allNodes[i].isCanSlot) {
	                        if (that.allNodes[i].slot && that.allNodes[i].slot.length > 0) {
	                            for (var a = 0; a < that.allNodes[i].slot.length; a++) {
	                                var slotPosition = [that.allNodes[i].slot[a].position[0] + that.allNodes[i].position[0], that.allNodes[i].slot[a].position[1] + that.allNodes[i].position[1]];
	                                if (nowRectPosition[0] == slotPosition[0] && nowRectPosition[1] == slotPosition[1]) {
	                                    that.rect.attr("style", {
	                                        stroke: "rgba(0, 255, 0, 1)"
	                                    });
	                                    break;
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	
	        }
	
	        function endDrag() {
	            that._zr.off('mousemove', moveFunction);
	            that._zr.off('mouseup', upFunction);
	            that._zr.off('globalout', upFunction);
	            if (dom.parent) {
	                dom.parent.off("globalout", upFunction);
	            }
	            that.rect.hide();
	            Guidelines.virtualXLine.attr("shape", {
	                x2: 0
	            });
	            Guidelines.virtualYLine.attr("shape", {
	                y2: 0
	            });
	            if (isLap == 0) {
	                if (dom.parent) {
	                    if (Bpmn.isSubProcess(dom.parent)) {
	                        var groupNodePositionX = dom.parent.getRect().width / 2 + (nowRectPosition[0] - dom.parent.getRect().x);
	                        var groupNodePositionY = dom.parent.getRect().height / 2 + (nowRectPosition[1] - dom.parent.getRect().y);
	                        if (dom.slotEvent && dom.slotEvent.length > 0) {
	                            for (var m = 0; m < dom.slotEvent.length; m++) {
	                                var slotEventPosition = [dom.slotEvent[m].position[0] + groupNodePositionX - zrUtil.clone(dom.position[0]) - dom.getBoundingRect().width / 2, dom.slotEvent[m].position[1] + groupNodePositionY - zrUtil.clone(dom.position[1]) - dom.getBoundingRect().height / 2];
	                                dom.slotEvent[m].attr("position", slotEventPosition);
	                                BpmnConnectionManager.refreshLineByNode(dom.slotEvent[m]);
	                            }
	                        }
	                        dom.setPosition(groupNodePositionX, groupNodePositionY);
	                    }
	                } else {
	                    if (dom.slotEvent && dom.slotEvent.length > 0) {
	                        for (var n = 0; n < dom.slotEvent.length; n++) {
	                            var slotEventPosition = [dom.slotEvent[n].position[0] + nowRectPosition[0] - zrUtil.clone(dom.position[0]) - dom.getBoundingRect().width / 2, dom.slotEvent[n].position[1] + nowRectPosition[1] - zrUtil.clone(dom.position[1]) - dom.getBoundingRect().height / 2];
	                            dom.slotEvent[n].attr("position", slotEventPosition);
	                            BpmnConnectionManager.refreshLineByNode(dom.slotEvent[n]);
	                        }
	                    }
	                    dom.setPosition(nowRectPosition[0], nowRectPosition[1]);
	                }
	                // if (dom.alarm) {
	                //     var newAlarmPosition = [nowRectPosition[0] - dom.getBoundingRect().width / 2 - (dom.alarm.getBoundingRect().width - 6), nowRectPosition[1] - dom.getBoundingRect().height / 2 - dom.alarm.getBoundingRect().height - 3];
	                //     dom.alarm.attr("position", newAlarmPosition);
	                // };
	                for (var b = 0; b < that.domArray.length; b++) {
	                    if (dom.id == that.domArray[b].id) {
	                        that.domArray[b].position = [nowRectPosition[0], nowRectPosition[1]];
	                    }
	                }
	                for (var j = 0; j < that.overlapArray.length; j++) {
	                    if (dom.id == that.overlapArray[j].id) {
	                        that.overlapArray[j] = {
	                            id: dom.id,
	                            position: [nowRectPosition[0], nowRectPosition[1]],
	                            width: dom.getRect().width,
	                            height: dom.getRect().height
	                        };
	                    }
	                }
	            }
	
	            if (isMove == 1) {
	                that.nodeClickHandler(dom);
	                BpmnConnectionManager.refreshLineByNode(dom);
	                that.stepCounter();
	            }
	
	            //将事件节点与task节点绑定或解绑
	            if (Bpmn.isSlotEvent(dom)) {
	                for (var i = 0; i < that.allNodes.length; i++) {
	                    if (that.allNodes[i].isCanSlot) {
	                        if (that.allNodes[i].slot && that.allNodes[i].slot.length > 0) {
	                            for (var c = 0; c < that.allNodes[i].slot.length; c++) {
	                                var slotPosition = [that.allNodes[i].slot[c].position[0] + that.allNodes[i].position[0], that.allNodes[i].slot[c].position[1] + that.allNodes[i].position[1]];
	                                var newRectPosition = [];
	                                if (dom.parent) {
	                                    if (Bpmn.isSubProcess(dom.parent)) {
	                                        newRectPosition[0] = dom.parent.getRect().width / 2 + (nowRectPosition[0] - dom.parent.getRect().x);
	                                        newRectPosition[1] = dom.parent.getRect().height / 2 + (nowRectPosition[1] - dom.parent.getRect().y);
	                                    }
	                                } else {
	                                    newRectPosition = nowRectPosition;
	                                }
	                                if (newRectPosition[0] == slotPosition[0] && newRectPosition[1] == slotPosition[1]) {
	                                    that.allNodes[i].slotEvent.push(dom);
	                                    break;
	                                } else {
	                                    for (var k = 0; k < that.allNodes[i].slotEvent.length; k++) {
	                                        if (dom.id == that.allNodes[i].slotEvent[k].id) {
	                                            that.allNodes[i].slotEvent.splice(k, 1);
	                                        }
	                                    }
	                                }
	
	                            }
	                        }
	                    }
	                }
	            }
	        }
	
	        this._zr.on("mouseup", upFunction);
	        this._zr.on("globalout", upFunction);
	    };
	
	    /**
	     * @private
	     */
	    fishTopoProto.creatTip = function(node) {
	        //创建task内容的提示
	        var that = this;
	        var group = new graphic.Group();
	        group.isShow = false;
	        var name = node.model.get("properties.name") || "";
	        var showName;
	        if (name.length > 64) {
	            showName = name.substr(0, 64) + '..';
	        } else {
	            showName = name;
	        }
	        var text = new graphic.Text({
	            style: {
	                text: showName,
	                textFont: '16px Microsoft YaHei',
	                fill: "#000000",
	                textBaseline: "top" //垂直对齐
	            },
	            position: [2, 0],
	            z: 2
	        });
	        text.name = "Text";
	        group.add(text);
	        var Polyline = new graphic.Polyline({
	            style: {
	                fill: '#f9f9f9',
	                stroke: '#bbbbbb'
	            },
	            z: 1
	        });
	        Polyline.name = "Polyline";
	        group.add(Polyline);
	        // var groupPosition = [node.position[0] - node.getBoundingRect().width/2 - (group.getBoundingRect().width - 6), node.position[1]- node.getBoundingRect().height / 2 - group.getBoundingRect().height - 3];
	        // group.attr("position", groupPosition);
	        that._zr.add(group);
	        node.alarm = group;
	        group.hide();
	        group.eachChild(function(child) {
	            child.hide();
	        });
	    };
	
	    fishTopoProto.stepCounter = function() {
	        this.stepJson.splice(this.step, this.stepJson.length - (this.step));
	        this.step += 1;
	        var json = this.toJson();
	        this.stepJson.push(JSON.stringify(json));
	    };
	    // fishTopoProto.stepForward = function() {
	    //     if (this.step < this.stepJson.length) {
	    //         this.clear(true);
	    //         this.step += 1;
	    //         var json = JSON.parse(this.stepJson[this.step - 1]);
	    //         this.fromJson(json);
	    //     }
	    // };
	    // fishTopoProto.stepBack = function() {
	    //     if (this.step > 0) {
	    //         this.clear(true);
	    //         this.step -= 1;
	    //         if (this.step - 1 >= 0) {
	    //             var json = JSON.parse(this.stepJson[this.step - 1]);
	    //             this.fromJson(json);
	    //         }
	    //     }
	    // };
	
	
	    zrUtil.mixin(FishTopoBpmn, Eventful);
	
	    // ---------对外暴露fishTopoBpmn------------------
	    var idBase = new Date() - 0;
	    var instances = {};
	    var DOM_ATTRIBUTE_KEY = '_fishTopoBpmn_instance_';
	
	    /**
	     * fishTopoBpmn全局对象，如果是amd方式加载，则直接返回
	     * @class fishTopoBpmn
	     * @singleton
	     */
	    var fishTopoBpmn = {
	        /**
	         * 版本号
	         * @type {String}
	         */
	        version: '1.3.0',
	        dependencies: {
	            zrender: '3.0.4'
	        }
	    };
	
	    /**
	     * 初始化dom元素为 bpmn对象
	     * @member fishTopoBpmn
	     * @param {HTMLElement} dom  一个div元素
	     * @param {Object} opts  传递的选项参数
	     * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg' or 'vml'
	     * @param {number} [opts.devicePixelRatio=1] retina 屏幕优化
	     * @return {fish.topo.FishTopoBpmn}
	     */
	    fishTopoBpmn.init = function(dom, opts) {
	        if (!dom) {
	            throw new Error('Initialize failed: invalid dom.');
	        }
	
	        opts = opts || {};
	        // Default value
	        zrUtil.defaults(opts, {
	            type: "bpmn",
	            showGridLine: true,
	            devicePixelRatio: 1,
	            gridLineSpacing: 10
	        });
	
	        var fishTopoBpmn = new FishTopoBpmn(dom, opts);
	        fishTopoBpmn.init();
	
	        fishTopoBpmn.id = 'ft_' + idBase++;
	        instances[fishTopoBpmn.id] = fishTopoBpmn;
	
	        dom.setAttribute && dom.setAttribute(DOM_ATTRIBUTE_KEY, fishTopoBpmn.id);
	
	        return fishTopoBpmn;
	    };
	
	
	    /**
	     * 获取 dom 容器上的实例。
	     * @member fishTopoBpmn
	     * @param  {HTMLElement} dom 一个div元素
	     * @return {fish.topo.FishTopoBpmn}
	     */
	    fishTopoBpmn.getInstanceByDom = function(dom) {
	        var key = dom.getAttribute(DOM_ATTRIBUTE_KEY);
	        return instances[key];
	    };
	
	    /**
	     * 销毁实例，实例销毁后无法再被使用。
	     * @member fishTopoBpmn
	     * @param  {Object|string} chart fishTopoBpmn实例 或 fishTopoBpmn的id
	     */
	    fishTopoBpmn.dispose = function(chart) {
	        var topo;
	        if (zrUtil.isDom(chart)) {
	            topo = fishTopoBpmn.getInstanceByDom(chart);
	        } else if (typeof chart === 'string') {
	            topo = instances[chart];
	        }
	        if ((topo instanceof fishTopoBpmn) && !topo.isDisposed()) {
	            topo.dispose();
	        }
	    };
	    //暴露出去的类 方便用户扩展图元
	    fishTopoBpmn.Bpmn = Bpmn;
	    fishTopoBpmn.BPMNNode = BPMNNode;
	    fishTopoBpmn.graphic = graphic;
	    fishTopoBpmn.BoundingRect = BoundingRect;
	
	    fishTopoBpmn.util = {};
	    zrUtil.each([
	            'map', 'each', 'filter', 'indexOf', 'inherits',
	            'reduce', 'filter', 'bind', 'curry', 'isArray',
	            'isString', 'isObject', 'isFunction', 'extend'
	        ],
	        function(name) {
	            fishTopoBpmn.util[name] = zrUtil[name];
	        }
	    );
	    module.exports = fishTopoBpmn;
	


/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	
	    var zrUtil = __webpack_require__(4);
	
	    var pathTool = __webpack_require__(5);
	    var round = Math.round;
	    var Path = __webpack_require__(6);
	    var colorTool = __webpack_require__(19);
	    var matrix = __webpack_require__(13);
	    var vector = __webpack_require__(14);
	    var Gradient = __webpack_require__(37);
	    var Draggable = __webpack_require__(38);
	
	    var graphic = {};
	    graphic.Util = zrUtil;
	    graphic.Group = __webpack_require__(39);
	
	    graphic.Image = __webpack_require__(40);
	
	    graphic.Text = __webpack_require__(42);
	
	    graphic.textContain = __webpack_require__(23);
	
	    graphic.Circle = __webpack_require__(43);
	
	    graphic.Sector = __webpack_require__(44);
	
	    graphic.Ring = __webpack_require__(45);
	
	    graphic.Polygon = __webpack_require__(46);
	
	    graphic.Polyline = __webpack_require__(50);
	
	    graphic.Rect = __webpack_require__(51);
	
	    graphic.Line = __webpack_require__(53);
	
	    graphic.BezierCurve = __webpack_require__(54);
	
	    graphic.Arc = __webpack_require__(55);
	
	    graphic.LinearGradient = __webpack_require__(56);
	
	    graphic.RadialGradient = __webpack_require__(57);
	
	    graphic.BoundingRect = __webpack_require__(24);
	
	    /**
	     * Extend shape with parameters
	     */
	    graphic.extendShape = function (opts) {
	        return Path.extend(opts);
	    };
	
	    /**
	     * Extend path
	     */
	    graphic.extendPath = function (pathData, opts) {
	        return pathTool.extendFromString(pathData, opts);
	    };
	
	    /**
	     * Create a path element from path data string
	     * @param {string} pathData
	     * @param {Object} opts
	     * @param {module:zrender/core/BoundingRect} rect
	     * @param {string} [layout=cover] 'center' or 'cover'
	     */
	    graphic.makePath = function (pathData, opts, rect, layout) {
	        var path = pathTool.createFromString(pathData, opts);
	        Draggable.call(path);
	        var boundingRect = path.getBoundingRect();
	        if (rect) {
	            var aspect = boundingRect.width / boundingRect.height;
	
	            if (layout === 'center') {
	                // Set rect to center, keep width / height ratio.
	                var width = rect.height * aspect;
	                var height;
	                if (width <= rect.width) {
	                    height = rect.height;
	                }
	                else {
	                    width = rect.width;
	                    height = width / aspect;
	                }
	                var cx = rect.x + rect.width / 2;
	                var cy = rect.y + rect.height / 2;
	
	                rect.x = cx - width / 2;
	                rect.y = cy - height / 2;
	                rect.width = width;
	                rect.height = height;
	            }
	
	            this.resizePath(path, rect);
	        }
	
	        zrUtil.inherits(path, Draggable);
	        return path;
	    };
	
	    graphic.mergePath = pathTool.mergePath;
	
	    /**
	     * Resize a path to fit the rect
	     * @param {module:zrender/graphic/Path} path
	     * @param {Object} rect
	     */
	    graphic.resizePath = function (path, rect) {
	        if (!path.applyTransform) {
	            return;
	        }
	
	        var pathRect = path.getBoundingRect();
	
	        var m = pathRect.calculateTransform(rect);
	
	        path.applyTransform(m);
	    };
	
	    /**
	     * Sub pixel optimize line for canvas
	     *
	     * @param {Object} param
	     * @param {Object} [param.shape]
	     * @param {number} [param.shape.x1]
	     * @param {number} [param.shape.y1]
	     * @param {number} [param.shape.x2]
	     * @param {number} [param.shape.y2]
	     * @param {Object} [param.style]
	     * @param {number} [param.style.lineWidth]
	     * @return {Object} Modified param
	     */
	    graphic.subPixelOptimizeLine = function (param) {
	        var subPixelOptimize = graphic.subPixelOptimize;
	        var shape = param.shape;
	        var lineWidth = param.style.lineWidth;
	
	        if (round(shape.x1 * 2) === round(shape.x2 * 2)) {
	            shape.x1 = shape.x2 = subPixelOptimize(shape.x1, lineWidth, true);
	        }
	        if (round(shape.y1 * 2) === round(shape.y2 * 2)) {
	            shape.y1 = shape.y2 = subPixelOptimize(shape.y1, lineWidth, true);
	        }
	        return param;
	    };
	
	    /**
	     * Sub pixel optimize rect for canvas
	     *
	     * @param {Object} param
	     * @param {Object} [param.shape]
	     * @param {number} [param.shape.x]
	     * @param {number} [param.shape.y]
	     * @param {number} [param.shape.width]
	     * @param {number} [param.shape.height]
	     * @param {Object} [param.style]
	     * @param {number} [param.style.lineWidth]
	     * @return {Object} Modified param
	     */
	    graphic.subPixelOptimizeRect = function (param) {
	        var subPixelOptimize = graphic.subPixelOptimize;
	        var shape = param.shape;
	        var lineWidth = param.style.lineWidth;
	        var originX = shape.x;
	        var originY = shape.y;
	        var originWidth = shape.width;
	        var originHeight = shape.height;
	        shape.x = subPixelOptimize(shape.x, lineWidth, true);
	        shape.y = subPixelOptimize(shape.y, lineWidth, true);
	        shape.width = Math.max(
	            subPixelOptimize(originX + originWidth, lineWidth, false) - shape.x,
	            originWidth === 0 ? 0 : 1
	        );
	        shape.height = Math.max(
	            subPixelOptimize(originY + originHeight, lineWidth, false) - shape.y,
	            originHeight === 0 ? 0 : 1
	        );
	        return param;
	    };
	
	    /**
	     * Sub pixel optimize for canvas
	     *
	     * @param {number} position Coordinate, such as x, y
	     * @param {number} lineWidth Should be nonnegative integer.
	     * @param {boolean=} positiveOrNegative Default false (negative).
	     * @return {number} Optimized position.
	     */
	    graphic.subPixelOptimize = function (position, lineWidth, positiveOrNegative) {
	        // Assure that (position + lineWidth / 2) is near integer edge,
	        // otherwise line will be fuzzy in canvas.
	        var doubledPosition = round(position * 2);
	        return (doubledPosition + round(lineWidth)) % 2 === 0
	            ? doubledPosition / 2
	            : (doubledPosition + (positiveOrNegative ? 1 : -1)) / 2;
	    };
	
	    /**
	     * @private
	     */
	    function doSingleEnterHover(el) {
	        if (el.__isHover) {
	            return;
	        }
	        if (el.__hoverStlDirty) {
	            var stroke = el.style.stroke;
	            var fill = el.style.fill;
	
	            // Create hoverStyle on mouseover
	            var hoverStyle = el.__hoverStl;
	            var lift = colorTool.lift;
	            hoverStyle.fill = hoverStyle.fill
	                || (fill && (fill instanceof Gradient ? fill : lift(fill, -0.1)));
	            hoverStyle.stroke = hoverStyle.stroke
	                || (stroke && (stroke instanceof Gradient ? stroke : lift(stroke, -0.1)));
	
	            var normalStyle = {};
	            for (var name in hoverStyle) {
	                if (hoverStyle.hasOwnProperty(name)) {
	                    normalStyle[name] = el.style[name];
	                }
	            }
	
	            el.__normalStl = normalStyle;
	
	            el.__hoverStlDirty = false;
	        }
	        el.setStyle(el.__hoverStl);
	        el.z2 += 1;
	
	        el.__isHover = true;
	    }
	
	    /**
	     * @inner
	     */
	    function doSingleLeaveHover(el) {
	        if (!el.__isHover) {
	            return;
	        }
	
	        var normalStl = el.__normalStl;
	        normalStl && el.setStyle(normalStl);
	        el.z2 -= 1;
	
	        el.__isHover = false;
	    }
	
	    /**
	     * @inner
	     */
	    function doEnterHover(el) {
	        el.type === 'group'
	            ? el.traverse(function (child) {
	                if (child.type !== 'group') {
	                    doSingleEnterHover(child);
	                }
	            })
	            : doSingleEnterHover(el);
	    }
	    graphic.doEnterHover = doEnterHover;
	    function doLeaveHover(el) {
	        el.type === 'group'
	            ? el.traverse(function (child) {
	                if (child.type !== 'group') {
	                    doSingleLeaveHover(child);
	                }
	            })
	            : doSingleLeaveHover(el);
	    }
	    graphic.doLeaveHover = doLeaveHover;
	    /**
	     * @inner
	     */
	    function setElementHoverStl(el, hoverStl) {
	        // If element has sepcified hoverStyle, then use it instead of given hoverStyle
	        // Often used when item group has a label element and it's hoverStyle is different
	        el.__hoverStl = el.hoverStyle || hoverStl || {};
	        el.__hoverStlDirty = true;
	    }
	    graphic.setElementHoverStl = setElementHoverStl;
	    /**
	     * @inner
	     */
	    function onElementMouseOver() {
	        // Only if element is not in emphasis status
	        !this.__isEmphasis && doEnterHover(this);
	    }
	
	    /**
	     * @inner
	     */
	    function onElementMouseOut() {
	        // Only if element is not in emphasis status
	        !this.__isEmphasis && doLeaveHover(this);
	    }
	
	    /**
	     * @inner
	     */
	    function enterEmphasis() {
	        this.__isEmphasis = true;
	        doEnterHover(this);
	    }
	
	    /**
	     * @inner
	     */
	    function leaveEmphasis() {
	        this.__isEmphasis = false;
	        doLeaveHover(this);
	    }
	
	    /**
	     * Set hover style of element
	     * @param {module:zrender/Element} el
	     * @param {Object} [hoverStyle]
	     */
	    graphic.setHoverStyle = function (el, hoverStyle) {
	        el.type === 'group'
	            ? el.traverse(function (child) {
	                if (child.type !== 'group') {
	                    setElementHoverStl(child, hoverStyle);
	                }
	            })
	            : setElementHoverStl(el, hoverStyle);
	        // Remove previous bound handlers
	        el.on('mouseover', onElementMouseOver)
	          .on('mouseout', onElementMouseOut);
	
	        // Emphasis, normal can be triggered manually
	        el.on('emphasis', enterEmphasis)
	          .on('normal', leaveEmphasis);
	    };
	
	    graphic.setNormalStyle = function(el, options) {
	        if (el.__normalStl) {
	            for (var name in options) {
	                if (el.__normalStl.hasOwnProperty(name)) {
	                    el.__normalStl[name] = options[name];
	                }
	            }
	        }
	    };
	
	    /**
	     * Set text option in the style
	     * @param {Object} textStyle
	     * @param {module:echarts/model/Model} labelModel
	     * @param {string} color
	     */
	    graphic.setText = function (textStyle, labelModel, color) {
	        var labelPosition = labelModel.getShallow('position') || 'inside';
	        var labelColor = labelPosition.indexOf('inside') >= 0 ? 'white' : color;
	        var textStyleModel = labelModel.getModel('textStyle');
	        zrUtil.extend(textStyle, {
	            textDistance: labelModel.getShallow('distance') || 5,
	            textFont: textStyleModel.getFont(),
	            textPosition: labelPosition,
	            textFill: textStyleModel.getTextColor() || labelColor
	        });
	    };
	
	    function animateOrSetProps(isUpdate, el, props, animatableModel, cb) {
	        var postfix = isUpdate ? 'Update' : '';
	        var duration = animatableModel
	            && animatableModel.getShallow('animationDuration' + postfix);
	        var animationEasing = animatableModel
	            && animatableModel.getShallow('animationEasing' + postfix);
	
	        animatableModel && animatableModel.getShallow('animation')
	            ? el.animateTo(props, duration, animationEasing, cb)
	            : (el.attr(props), cb && cb());
	    }
	    /**
	     * Update graphic element properties with or without animation according to the configuration in series
	     * @param {module:zrender/Element} el
	     * @param {Object} props
	     * @param {module:echarts/model/Model} [animatableModel]
	     * @param {Function} cb
	     */
	    graphic.updateProps = zrUtil.curry(animateOrSetProps, true);
	
	    /**
	     * Init graphic element properties with or without animation according to the configuration in series
	     * @param {module:zrender/Element} el
	     * @param {Object} props
	     * @param {module:echarts/model/Model} [animatableModel]
	     * @param {Function} cb
	     */
	    graphic.initProps = zrUtil.curry(animateOrSetProps, false);
	
	    /**
	     * Get transform matrix of target (param target),
	     * in coordinate of its ancestor (param ancestor)
	     *
	     * @param {module:zrender/mixin/Transformable} target
	     * @param {module:zrender/mixin/Transformable} ancestor
	     */
	    graphic.getTransform = function (target, ancestor) {
	        var mat = matrix.identity([]);
	
	        while (target && target !== ancestor) {
	            matrix.mul(mat, target.getLocalTransform(), mat);
	            target = target.parent;
	        }
	
	        return mat;
	    };
	
	    /**
	     * Apply transform to an vertex.
	     * @param {Array.<number>} vertex [x, y]
	     * @param {Array.<number>} transform Transform matrix: like [1, 0, 0, 1, 0, 0]
	     * @param {boolean=} invert Whether use invert matrix.
	     * @return {Array.<number>} [x, y]
	     */
	    graphic.applyTransform = function (vertex, transform, invert) {
	        if (invert) {
	            transform = matrix.invert([], transform);
	        }
	        return vector.applyTransform([], vertex, transform);
	    };
	
	    /**
	     * @param {string} direction 'left' 'right' 'top' 'bottom'
	     * @param {Array.<number>} transform Transform matrix: like [1, 0, 0, 1, 0, 0]
	     * @param {boolean=} invert Whether use invert matrix.
	     * @return {string} Transformed direction. 'left' 'right' 'top' 'bottom'
	     */
	    graphic.transformDirection = function (direction, transform, invert) {
	
	        // Pick a base, ensure that transform result will not be (0, 0).
	        var hBase = (transform[4] === 0 || transform[5] === 0 || transform[0] === 0)
	            ? 1 : Math.abs(2 * transform[4] / transform[0]);
	        var vBase = (transform[4] === 0 || transform[5] === 0 || transform[2] === 0)
	            ? 1 : Math.abs(2 * transform[4] / transform[2]);
	
	        var vertex = [
	            direction === 'left' ? -hBase : direction === 'right' ? hBase : 0,
	            direction === 'top' ? -vBase : direction === 'bottom' ? vBase : 0
	        ];
	
	        vertex = graphic.applyTransform(vertex, transform, invert);
	
	        return Math.abs(vertex[0]) > Math.abs(vertex[1])
	            ? (vertex[0] > 0 ? 'right' : 'left')
	            : (vertex[1] > 0 ? 'bottom' : 'top');
	    };
	
	    module.exports = graphic;
	


/***/ },
/* 4 */
/***/ function(module, exports) {

	/**
	 * @module zrender/core/util
	 */
	
	
	    // 用于处理merge时无法遍历Date等对象的问题
	    var BUILTIN_OBJECT = {
	        '[object Function]': 1,
	        '[object RegExp]': 1,
	        '[object Date]': 1,
	        '[object Error]': 1,
	        '[object CanvasGradient]': 1,
	        '[object CanvasPattern]': 1,
	        // In node-canvas Image can be Canvas.Image
	        '[object Image]': 1
	    };
	
	    var objToString = Object.prototype.toString;
	
	    var arrayProto = Array.prototype;
	    var nativeForEach = arrayProto.forEach;
	    var nativeFilter = arrayProto.filter;
	    var nativeSlice = arrayProto.slice;
	    var nativeMap = arrayProto.map;
	    var nativeReduce = arrayProto.reduce;
	
	    /**
	     * @param {*} source
	     * @return {*} 拷贝后的新对象
	     */
	    function clone(source) {
	        if (typeof source == 'object' && source !== null) {
	            var result = source;
	            if (source instanceof Array) {
	                result = [];
	                for (var i = 0, len = source.length; i < len; i++) {
	                    result[i] = clone(source[i]);
	                }
	            }
	            else if (
	                !isBuildInObject(source)
	                // 是否为 dom 对象
	                && !isDom(source)
	            ) {
	                result = {};
	                for (var key in source) {
	                    if (source.hasOwnProperty(key)) {
	                        result[key] = clone(source[key]);
	                    }
	                }
	            }
	
	            return result;
	        }
	
	        return source;
	    }
	
	    /**
	     * @memberOf module:zrender/core/util
	     * @param {*} target
	     * @param {*} source
	     * @param {boolean} [overwrite=false]
	     */
	    function merge(target, source, overwrite) {
	        // We should escapse that source is string
	        // and enter for ... in ...
	        if (!isObject(source) || !isObject(target)) {
	            return overwrite ? clone(source) : target;
	        }
	
	        for (var key in source) {
	            if (source.hasOwnProperty(key)) {
	                var targetProp = target[key];
	                var sourceProp = source[key];
	
	                if (isObject(sourceProp)
	                    && isObject(targetProp)
	                    && !isArray(sourceProp)
	                    && !isArray(targetProp)
	                    && !isDom(sourceProp)
	                    && !isDom(targetProp)
	                    && !isBuildInObject(sourceProp)
	                    && !isBuildInObject(targetProp)
	                ) {
	                    // 如果需要递归覆盖，就递归调用merge
	                    merge(targetProp, sourceProp, overwrite);
	                }
	                else if (overwrite || !(key in target)) {
	                    // 否则只处理overwrite为true，或者在目标对象中没有此属性的情况
	                    // NOTE，在 target[key] 不存在的时候也是直接覆盖
	                    target[key] = clone(source[key], true);
	                }
	            }
	        }
	
	        return target;
	    }
	
	    /**
	     * @param {Array} targetAndSources The first item is target, and the rests are source.
	     * @param {boolean} [overwrite=false]
	     * @return {*} target
	     */
	    function mergeAll(targetAndSources, overwrite) {
	        var result = targetAndSources[0];
	        for (var i = 1, len = targetAndSources.length; i < len; i++) {
	            result = merge(result, targetAndSources[i], overwrite);
	        }
	        return result;
	    }
	
	    /**
	     * @param {*} target
	     * @param {*} source
	     * @memberOf module:zrender/core/util
	     */
	    function extend(target, source) {
	        for (var key in source) {
	            if (source.hasOwnProperty(key)) {
	                target[key] = source[key];
	            }
	        }
	        return target;
	    }
	
	    /**
	     * @param {*} target
	     * @param {*} source
	     * @param {boolen} [overlay=false]
	     * @memberOf module:zrender/core/util
	     */
	    function defaults(target, source, overlay) {
	        for (var key in source) {
	            if (source.hasOwnProperty(key)
	                && (overlay ? source[key] != null : target[key] == null)
	            ) {
	                target[key] = source[key];
	            }
	        }
	        return target;
	    }
	
	    function createCanvas() {
	        return document.createElement('canvas');
	    }
	    // FIXME
	    var _ctx;
	    function getContext() {
	        if (!_ctx) {
	            // Use util.createCanvas instead of createCanvas
	            // because createCanvas may be overwritten in different environment
	            _ctx = util.createCanvas().getContext('2d');
	        }
	        return _ctx;
	    }
	
	    /**
	     * 查询数组中元素的index
	     * @memberOf module:zrender/core/util
	     */
	    function indexOf(array, value) {
	        if (array) {
	            if (array.indexOf) {
	                return array.indexOf(value);
	            }
	            for (var i = 0, len = array.length; i < len; i++) {
	                if (array[i] === value) {
	                    return i;
	                }
	            }
	        }
	        return -1;
	    }
	
	    /**
	     * 构造类继承关系
	     *
	     * @memberOf module:zrender/core/util
	     * @param {Function} clazz 源类
	     * @param {Function} baseClazz 基类
	     */
	    function inherits(clazz, baseClazz) {
	        var clazzPrototype = clazz.prototype;
	        function F() {}
	        F.prototype = baseClazz.prototype;
	        clazz.prototype = new F();
	
	        for (var prop in clazzPrototype) {
	            clazz.prototype[prop] = clazzPrototype[prop];
	        }
	        clazz.prototype.constructor = clazz;
	        clazz.superClass = baseClazz;
	    }
	
	    /**
	     * @memberOf module:zrender/core/util
	     * @param {Object|Function} target
	     * @param {Object|Function} sorce
	     * @param {boolean} overlay
	     */
	    function mixin(target, source, overlay) {
	        target = 'prototype' in target ? target.prototype : target;
	        source = 'prototype' in source ? source.prototype : source;
	
	        defaults(target, source, overlay);
	    }
	
	    /**
	     * @param {Array|TypedArray} data
	     */
	    function isArrayLike(data) {
	        if (! data) {
	            return;
	        }
	        if (typeof data == 'string') {
	            return false;
	        }
	        return typeof data.length == 'number';
	    }
	
	    /**
	     * 数组或对象遍历
	     * @memberOf module:zrender/core/util
	     * @param {Object|Array} obj
	     * @param {Function} cb
	     * @param {*} [context]
	     */
	    function each(obj, cb, context) {
	        if (!(obj && cb)) {
	            return;
	        }
	        if (obj.forEach && obj.forEach === nativeForEach) {
	            obj.forEach(cb, context);
	        }
	        else if (obj.length === +obj.length) {
	            for (var i = 0, len = obj.length; i < len; i++) {
	                cb.call(context, obj[i], i, obj);
	            }
	        }
	        else {
	            for (var key in obj) {
	                if (obj.hasOwnProperty(key)) {
	                    cb.call(context, obj[key], key, obj);
	                }
	            }
	        }
	    }
	
	    /**
	     * 数组映射
	     * @memberOf module:zrender/core/util
	     * @param {Array} obj
	     * @param {Function} cb
	     * @param {*} [context]
	     * @return {Array}
	     */
	    function map(obj, cb, context) {
	        if (!(obj && cb)) {
	            return;
	        }
	        if (obj.map && obj.map === nativeMap) {
	            return obj.map(cb, context);
	        }
	        else {
	            var result = [];
	            for (var i = 0, len = obj.length; i < len; i++) {
	                result.push(cb.call(context, obj[i], i, obj));
	            }
	            return result;
	        }
	    }
	
	    /**
	     * @memberOf module:zrender/core/util
	     * @param {Array} obj
	     * @param {Function} cb
	     * @param {Object} [memo]
	     * @param {*} [context]
	     * @return {Array}
	     */
	    function reduce(obj, cb, memo, context) {
	        if (!(obj && cb)) {
	            return;
	        }
	        if (obj.reduce && obj.reduce === nativeReduce) {
	            return obj.reduce(cb, memo, context);
	        }
	        else {
	            for (var i = 0, len = obj.length; i < len; i++) {
	                memo = cb.call(context, memo, obj[i], i, obj);
	            }
	            return memo;
	        }
	    }
	
	    /**
	     * 数组过滤
	     * @memberOf module:zrender/core/util
	     * @param {Array} obj
	     * @param {Function} cb
	     * @param {*} [context]
	     * @return {Array}
	     */
	    function filter(obj, cb, context) {
	        if (!(obj && cb)) {
	            return;
	        }
	        if (obj.filter && obj.filter === nativeFilter) {
	            return obj.filter(cb, context);
	        }
	        else {
	            var result = [];
	            for (var i = 0, len = obj.length; i < len; i++) {
	                if (cb.call(context, obj[i], i, obj)) {
	                    result.push(obj[i]);
	                }
	            }
	            return result;
	        }
	    }
	
	    /**
	     * 数组项查找
	     * @memberOf module:zrender/core/util
	     * @param {Array} obj
	     * @param {Function} cb
	     * @param {*} [context]
	     * @return {Array}
	     */
	    function find(obj, cb, context) {
	        if (!(obj && cb)) {
	            return;
	        }
	        for (var i = 0, len = obj.length; i < len; i++) {
	            if (cb.call(context, obj[i], i, obj)) {
	                return obj[i];
	            }
	        }
	    }
	
	    /**
	     * @memberOf module:zrender/core/util
	     * @param {Function} func
	     * @param {*} context
	     * @return {Function}
	     */
	    function bind(func, context) {
	        var args = nativeSlice.call(arguments, 2);
	        return function () {
	            return func.apply(context, args.concat(nativeSlice.call(arguments)));
	        };
	    }
	
	    /**
	     * @memberOf module:zrender/core/util
	     * @param {Function} func
	     * @return {Function}
	     */
	    function curry(func) {
	        var args = nativeSlice.call(arguments, 1);
	        return function () {
	            return func.apply(this, args.concat(nativeSlice.call(arguments)));
	        };
	    }
	
	    /**
	     * @memberOf module:zrender/core/util
	     * @param {*} value
	     * @return {boolean}
	     */
	    function isArray(value) {
	        return objToString.call(value) === '[object Array]';
	    }
	
	    /**
	     * @memberOf module:zrender/core/util
	     * @param {*} value
	     * @return {boolean}
	     */
	    function isFunction(value) {
	        return typeof value === 'function';
	    }
	
	    /**
	     * @memberOf module:zrender/core/util
	     * @param {*} value
	     * @return {boolean}
	     */
	    function isString(value) {
	        return objToString.call(value) === '[object String]';
	    }
	
	    /**
	     * @memberOf module:zrender/core/util
	     * @param {*} value
	     * @return {boolean}
	     */
	    function isObject(value) {
	        // Avoid a V8 JIT bug in Chrome 19-20.
	        // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
	        var type = typeof value;
	        return type === 'function' || (!!value && type == 'object');
	    }
	
	    /**
	     * @memberOf module:zrender/core/util
	     * @param {*} value
	     * @return {boolean}
	     */
	    function isBuildInObject(value) {
	        return !!BUILTIN_OBJECT[objToString.call(value)];
	    }
	
	    /**
	     * @memberOf module:zrender/core/util
	     * @param {*} value
	     * @return {boolean}
	     */
	    function isDom(value) {
	        return value && value.nodeType === 1
	               && typeof(value.nodeName) == 'string';
	    }
	
	    /**
	     * If value1 is not null, then return value1, otherwise judget rest of values.
	     * @memberOf module:zrender/core/util
	     * @return {*} Final value
	     */
	    function retrieve(values) {
	        for (var i = 0, len = arguments.length; i < len; i++) {
	            if (arguments[i] != null) {
	                return arguments[i];
	            }
	        }
	    }
	
	    /**
	     * @memberOf module:zrender/core/util
	     * @param {Array} arr
	     * @param {number} startIndex
	     * @param {number} endIndex
	     * @return {Array}
	     */
	    function slice() {
	        return Function.call.apply(nativeSlice, arguments);
	    }
	
	    /**
	     * @memberOf module:zrender/core/util
	     * @param {boolean} condition
	     * @param {string} message
	     */
	    function assert(condition, message) {
	        if (!condition) {
	            throw new Error(message);
	        }
	    }
	
	    var util = {
	        inherits: inherits,
	        mixin: mixin,
	        clone: clone,
	        merge: merge,
	        mergeAll: mergeAll,
	        extend: extend,
	        defaults: defaults,
	        getContext: getContext,
	        createCanvas: createCanvas,
	        indexOf: indexOf,
	        slice: slice,
	        find: find,
	        isArrayLike: isArrayLike,
	        each: each,
	        map: map,
	        reduce: reduce,
	        filter: filter,
	        bind: bind,
	        curry: curry,
	        isArray: isArray,
	        isString: isString,
	        isObject: isObject,
	        isFunction: isFunction,
	        isBuildInObject: isBuildInObject,
	        isDom: isDom,
	        retrieve: retrieve,
	        assert: assert,
	        noop: function () {}
	    };
	    module.exports = util;
	


/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	
	
	    var Path = __webpack_require__(6);
	    var PathProxy = __webpack_require__(25);
	    var transformPath = __webpack_require__(36);
	    var matrix = __webpack_require__(13);
	
	    // command chars
	    var cc = [
	        'm', 'M', 'l', 'L', 'v', 'V', 'h', 'H', 'z', 'Z',
	        'c', 'C', 'q', 'Q', 't', 'T', 's', 'S', 'a', 'A'
	    ];
	
	    var mathSqrt = Math.sqrt;
	    var mathSin = Math.sin;
	    var mathCos = Math.cos;
	    var PI = Math.PI;
	
	    var vMag = function(v) {
	        return Math.sqrt(v[0] * v[0] + v[1] * v[1]);
	    };
	    var vRatio = function(u, v) {
	        return (u[0] * v[0] + u[1] * v[1]) / (vMag(u) * vMag(v));
	    };
	    var vAngle = function(u, v) {
	        return (u[0] * v[1] < u[1] * v[0] ? -1 : 1)
	                * Math.acos(vRatio(u, v));
	    };
	
	    function processArc(x1, y1, x2, y2, fa, fs, rx, ry, psiDeg, cmd, path) {
	        var psi = psiDeg * (PI / 180.0);
	        var xp = mathCos(psi) * (x1 - x2) / 2.0
	                 + mathSin(psi) * (y1 - y2) / 2.0;
	        var yp = -1 * mathSin(psi) * (x1 - x2) / 2.0
	                 + mathCos(psi) * (y1 - y2) / 2.0;
	
	        var lambda = (xp * xp) / (rx * rx) + (yp * yp) / (ry * ry);
	
	        if (lambda > 1) {
	            rx *= mathSqrt(lambda);
	            ry *= mathSqrt(lambda);
	        }
	
	        var f = (fa === fs ? -1 : 1)
	            * mathSqrt((((rx * rx) * (ry * ry))
	                    - ((rx * rx) * (yp * yp))
	                    - ((ry * ry) * (xp * xp))) / ((rx * rx) * (yp * yp)
	                    + (ry * ry) * (xp * xp))
	                ) || 0;
	
	        var cxp = f * rx * yp / ry;
	        var cyp = f * -ry * xp / rx;
	
	        var cx = (x1 + x2) / 2.0
	                 + mathCos(psi) * cxp
	                 - mathSin(psi) * cyp;
	        var cy = (y1 + y2) / 2.0
	                + mathSin(psi) * cxp
	                + mathCos(psi) * cyp;
	
	        var theta = vAngle([ 1, 0 ], [ (xp - cxp) / rx, (yp - cyp) / ry ]);
	        var u = [ (xp - cxp) / rx, (yp - cyp) / ry ];
	        var v = [ (-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry ];
	        var dTheta = vAngle(u, v);
	
	        if (vRatio(u, v) <= -1) {
	            dTheta = PI;
	        }
	        if (vRatio(u, v) >= 1) {
	            dTheta = 0;
	        }
	        if (fs === 0 && dTheta > 0) {
	            dTheta = dTheta - 2 * PI;
	        }
	        if (fs === 1 && dTheta < 0) {
	            dTheta = dTheta + 2 * PI;
	        }
	
	        path.addData(cmd, cx, cy, rx, ry, theta, dTheta, psi, fs);
	    }
	
	    function createPathProxyFromString(data) {
	        if (!data) {
	            return [];
	        }
	
	        // command string
	        var cs = data.replace(/-/g, ' -')
	            .replace(/  /g, ' ')
	            .replace(/ /g, ',')
	            .replace(/,,/g, ',');
	
	        var n;
	        // create pipes so that we can split the data
	        for (n = 0; n < cc.length; n++) {
	            cs = cs.replace(new RegExp(cc[n], 'g'), '|' + cc[n]);
	        }
	
	        // create array
	        var arr = cs.split('|');
	        // init context point
	        var cpx = 0;
	        var cpy = 0;
	
	        var path = new PathProxy();
	        var CMD = PathProxy.CMD;
	
	        var prevCmd;
	        for (n = 1; n < arr.length; n++) {
	            var str = arr[n];
	            var c = str.charAt(0);
	            var off = 0;
	            var p = str.slice(1).replace(/e,-/g, 'e-').split(',');
	            var cmd;
	
	            if (p.length > 0 && p[0] === '') {
	                p.shift();
	            }
	
	            for (var i = 0; i < p.length; i++) {
	                p[i] = parseFloat(p[i]);
	            }
	            while (off < p.length && !isNaN(p[off])) {
	                if (isNaN(p[0])) {
	                    break;
	                }
	                var ctlPtx;
	                var ctlPty;
	
	                var rx;
	                var ry;
	                var psi;
	                var fa;
	                var fs;
	
	                var x1 = cpx;
	                var y1 = cpy;
	
	                // convert l, H, h, V, and v to L
	                switch (c) {
	                    case 'l':
	                        cpx += p[off++];
	                        cpy += p[off++];
	                        cmd = CMD.L;
	                        path.addData(cmd, cpx, cpy);
	                        break;
	                    case 'L':
	                        cpx = p[off++];
	                        cpy = p[off++];
	                        cmd = CMD.L;
	                        path.addData(cmd, cpx, cpy);
	                        break;
	                    case 'm':
	                        cpx += p[off++];
	                        cpy += p[off++];
	                        cmd = CMD.M;
	                        path.addData(cmd, cpx, cpy);
	                        c = 'l';
	                        break;
	                    case 'M':
	                        cpx = p[off++];
	                        cpy = p[off++];
	                        cmd = CMD.M;
	                        path.addData(cmd, cpx, cpy);
	                        c = 'L';
	                        break;
	                    case 'h':
	                        cpx += p[off++];
	                        cmd = CMD.L;
	                        path.addData(cmd, cpx, cpy);
	                        break;
	                    case 'H':
	                        cpx = p[off++];
	                        cmd = CMD.L;
	                        path.addData(cmd, cpx, cpy);
	                        break;
	                    case 'v':
	                        cpy += p[off++];
	                        cmd = CMD.L;
	                        path.addData(cmd, cpx, cpy);
	                        break;
	                    case 'V':
	                        cpy = p[off++];
	                        cmd = CMD.L;
	                        path.addData(cmd, cpx, cpy);
	                        break;
	                    case 'C':
	                        cmd = CMD.C;
	                        path.addData(
	                            cmd, p[off++], p[off++], p[off++], p[off++], p[off++], p[off++]
	                        );
	                        cpx = p[off - 2];
	                        cpy = p[off - 1];
	                        break;
	                    case 'c':
	                        cmd = CMD.C;
	                        path.addData(
	                            cmd,
	                            p[off++] + cpx, p[off++] + cpy,
	                            p[off++] + cpx, p[off++] + cpy,
	                            p[off++] + cpx, p[off++] + cpy
	                        );
	                        cpx += p[off - 2];
	                        cpy += p[off - 1];
	                        break;
	                    case 'S':
	                        ctlPtx = cpx;
	                        ctlPty = cpy;
	                        var len = path.len();
	                        var pathData = path.data;
	                        if (prevCmd === CMD.C) {
	                            ctlPtx += cpx - pathData[len - 4];
	                            ctlPty += cpy - pathData[len - 3];
	                        }
	                        cmd = CMD.C;
	                        x1 = p[off++];
	                        y1 = p[off++];
	                        cpx = p[off++];
	                        cpy = p[off++];
	                        path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);
	                        break;
	                    case 's':
	                        ctlPtx = cpx;
	                        ctlPty = cpy;
	                        var len = path.len();
	                        var pathData = path.data;
	                        if (prevCmd === CMD.C) {
	                            ctlPtx += cpx - pathData[len - 4];
	                            ctlPty += cpy - pathData[len - 3];
	                        }
	                        cmd = CMD.C;
	                        x1 = cpx + p[off++];
	                        y1 = cpy + p[off++];
	                        cpx += p[off++];
	                        cpy += p[off++];
	                        path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);
	                        break;
	                    case 'Q':
	                        x1 = p[off++];
	                        y1 = p[off++];
	                        cpx = p[off++];
	                        cpy = p[off++];
	                        cmd = CMD.Q;
	                        path.addData(cmd, x1, y1, cpx, cpy);
	                        break;
	                    case 'q':
	                        x1 = p[off++] + cpx;
	                        y1 = p[off++] + cpy;
	                        cpx += p[off++];
	                        cpy += p[off++];
	                        cmd = CMD.Q;
	                        path.addData(cmd, x1, y1, cpx, cpy);
	                        break;
	                    case 'T':
	                        ctlPtx = cpx;
	                        ctlPty = cpy;
	                        var len = path.len();
	                        var pathData = path.data;
	                        if (prevCmd === CMD.Q) {
	                            ctlPtx += cpx - pathData[len - 4];
	                            ctlPty += cpy - pathData[len - 3];
	                        }
	                        cpx = p[off++];
	                        cpy = p[off++];
	                        cmd = CMD.Q;
	                        path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);
	                        break;
	                    case 't':
	                        ctlPtx = cpx;
	                        ctlPty = cpy;
	                        var len = path.len();
	                        var pathData = path.data;
	                        if (prevCmd === CMD.Q) {
	                            ctlPtx += cpx - pathData[len - 4];
	                            ctlPty += cpy - pathData[len - 3];
	                        }
	                        cpx += p[off++];
	                        cpy += p[off++];
	                        cmd = CMD.Q;
	                        path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);
	                        break;
	                    case 'A':
	                        rx = p[off++];
	                        ry = p[off++];
	                        psi = p[off++];
	                        fa = p[off++];
	                        fs = p[off++];
	
	                        x1 = cpx, y1 = cpy;
	                        cpx = p[off++];
	                        cpy = p[off++];
	                        cmd = CMD.A;
	                        processArc(
	                            x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path
	                        );
	                        break;
	                    case 'a':
	                        rx = p[off++];
	                        ry = p[off++];
	                        psi = p[off++];
	                        fa = p[off++];
	                        fs = p[off++];
	
	                        x1 = cpx, y1 = cpy;
	                        cpx += p[off++];
	                        cpy += p[off++];
	                        cmd = CMD.A;
	                        processArc(
	                            x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path
	                        );
	                        break;
	                }
	            }
	
	            if (c === 'z' || c === 'Z') {
	                cmd = CMD.Z;
	                path.addData(cmd);
	            }
	
	            prevCmd = cmd;
	        }
	
	        path.toStatic();
	
	        return path;
	    }
	
	    // TODO Optimize double memory cost problem
	    function createPathOptions(str, opts) {
	        var pathProxy = createPathProxyFromString(str);
	        var transform;
	        opts = opts || {};
	        opts.buildPath = function (path) {
	            path.setData(pathProxy.data);
	            transform && transformPath(path, transform);
	            // Svg and vml renderer don't have context
	            var ctx = path.getContext();
	            if (ctx) {
	                path.rebuildPath(ctx);
	            }
	        };
	
	        opts.applyTransform = function (m) {
	            if (!transform) {
	                transform = matrix.create();
	            }
	            matrix.mul(transform, m, transform);
	            this.dirty(true);
	        };
	
	        return opts;
	    }
	
	    module.exports = {
	        /**
	         * Create a Path object from path string data
	         * http://www.w3.org/TR/SVG/paths.html#PathData
	         * @param  {Object} opts Other options
	         */
	        createFromString: function (str, opts) {
	            return new Path(createPathOptions(str, opts));
	        },
	
	        /**
	         * Create a Path class from path string data
	         * @param  {string} str
	         * @param  {Object} opts Other options
	         */
	        extendFromString: function (str, opts) {
	            return Path.extend(createPathOptions(str, opts));
	        },
	
	        /**
	         * Merge multiple paths
	         */
	        // TODO Apply transform
	        // TODO stroke dash
	        // TODO Optimize double memory cost problem
	        mergePath: function (pathEls, opts) {
	            var pathList = [];
	            var len = pathEls.length;
	            for (var i = 0; i < len; i++) {
	                var pathEl = pathEls[i];
	                if (pathEl.__dirty) {
	                    pathEl.buildPath(pathEl.path, pathEl.shape, true);
	                }
	                pathList.push(pathEl.path);
	            }
	
	            var pathBundle = new Path(opts);
	            pathBundle.buildPath = function (path) {
	                path.appendPath(pathList);
	                // Svg and vml renderer don't have context
	                var ctx = path.getContext();
	                if (ctx) {
	                    path.rebuildPath(ctx);
	                }
	            };
	
	            return pathBundle;
	        }
	    };


/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Path element
	 * @module zrender/graphic/Path
	 */
	
	
	
	    var Displayable = __webpack_require__(7);
	    var zrUtil = __webpack_require__(4);
	    var PathProxy = __webpack_require__(25);
	    var pathContain = __webpack_require__(28);
	
	    var Pattern = __webpack_require__(35);
	    var getCanvasPattern = Pattern.prototype.getCanvasPattern;
	
	    var abs = Math.abs;
	
	    /**
	     * @alias module:zrender/graphic/Path
	     * @extends module:zrender/graphic/Displayable
	     * @constructor
	     * @param {Object} opts
	     */
	    function Path(opts) {
	        Displayable.call(this, opts);
	
	        /**
	         * @type {module:zrender/core/PathProxy}
	         * @readOnly
	         */
	        this.path = new PathProxy();
	    }
	
	    Path.prototype = {
	
	        constructor: Path,
	
	        type: 'path',
	
	        __dirtyPath: true,
	
	        strokeContainThreshold: 5,
	
	        brush: function (ctx, prevEl) {
	            var style = this.style;
	            var path = this.path;
	            var hasStroke = style.hasStroke();
	            var hasFill = style.hasFill();
	            var fill = style.fill;
	            var stroke = style.stroke;
	            var hasFillGradient = hasFill && !!(fill.colorStops);
	            var hasStrokeGradient = hasStroke && !!(stroke.colorStops);
	            var hasFillPattern = hasFill && !!(fill.image);
	            var hasStrokePattern = hasStroke && !!(stroke.image);
	
	            style.bind(ctx, this, prevEl);
	            this.setTransform(ctx);
	
	            if (this.__dirty) {
	                var rect = this.getBoundingRect();
	                // Update gradient because bounding rect may changed
	                if (hasFillGradient) {
	                    this._fillGradient = style.getGradient(ctx, fill, rect);
	                }
	                if (hasStrokeGradient) {
	                    this._strokeGradient = style.getGradient(ctx, stroke, rect);
	                }
	            }
	            // Use the gradient or pattern
	            if (hasFillGradient) {
	                // PENDING If may have affect the state
	                ctx.fillStyle = this._fillGradient;
	            }
	            else if (hasFillPattern) {
	                ctx.fillStyle = getCanvasPattern.call(fill, ctx);
	            }
	            if (hasStrokeGradient) {
	                ctx.strokeStyle = this._strokeGradient;
	            }
	            else if (hasStrokePattern) {
	                ctx.strokeStyle = getCanvasPattern.call(stroke, ctx);
	            }
	
	            var lineDash = style.lineDash;
	            var lineDashOffset = style.lineDashOffset;
	
	            var ctxLineDash = !!ctx.setLineDash;
	
	            // Update path sx, sy
	            var scale = this.getGlobalScale();
	            path.setScale(scale[0], scale[1]);
	
	            // Proxy context
	            // Rebuild path in following 2 cases
	            // 1. Path is dirty
	            // 2. Path needs javascript implemented lineDash stroking.
	            //    In this case, lineDash information will not be saved in PathProxy
	            if (this.__dirtyPath || (
	                lineDash && !ctxLineDash && hasStroke
	            )) {
	                path = this.path.beginPath(ctx);
	
	                // Setting line dash before build path
	                if (lineDash && !ctxLineDash) {
	                    path.setLineDash(lineDash);
	                    path.setLineDashOffset(lineDashOffset);
	                }
	
	                this.buildPath(path, this.shape, false);
	
	                // Clear path dirty flag
	                this.__dirtyPath = false;
	            }
	            else {
	                // Replay path building
	                ctx.beginPath();
	                this.path.rebuildPath(ctx);
	            }
	
	            hasFill && path.fill(ctx);
	
	            if (lineDash && ctxLineDash) {
	                ctx.setLineDash(lineDash);
	                ctx.lineDashOffset = lineDashOffset;
	            }
	
	            hasStroke && path.stroke(ctx);
	
	            if (lineDash && ctxLineDash) {
	                // PENDING
	                // Remove lineDash
	                ctx.setLineDash([]);
	            }
	
	
	            this.restoreTransform(ctx);
	
	            // Draw rect text
	            if (style.text || style.text === 0) {
	                // var rect = this.getBoundingRect();
	                this.drawRectText(ctx, this.getBoundingRect());
	            }
	        },
	
	        // When bundling path, some shape may decide if use moveTo to begin a new subpath or closePath
	        // Like in circle
	        buildPath: function (ctx, shapeCfg, inBundle) {},
	
	        getBoundingRect: function () {
	            var rect = this._rect;
	            var style = this.style;
	            var needsUpdateRect = !rect;
	            if (needsUpdateRect) {
	                var path = this.path;
	                if (this.__dirtyPath) {
	                    path.beginPath();
	                    this.buildPath(path, this.shape, false);
	                }
	                rect = path.getBoundingRect();
	            }
	            this._rect = rect;
	
	            if (style.hasStroke()) {
	                // Needs update rect with stroke lineWidth when
	                // 1. Element changes scale or lineWidth
	                // 2. Shape is changed
	                var rectWithStroke = this._rectWithStroke || (this._rectWithStroke = rect.clone());
	                if (this.__dirty || needsUpdateRect) {
	                    rectWithStroke.copy(rect);
	                    // FIXME Must after updateTransform
	                    var w = style.lineWidth;
	                    // PENDING, Min line width is needed when line is horizontal or vertical
	                    var lineScale = style.strokeNoScale ? this.getLineScale() : 1;
	
	                    // Only add extra hover lineWidth when there are no fill
	                    if (!style.hasFill()) {
	                        w = Math.max(w, this.strokeContainThreshold || 4);
	                    }
	                    // Consider line width
	                    // Line scale can't be 0;
	                    if (lineScale > 1e-10) {
	                        rectWithStroke.width += w / lineScale;
	                        rectWithStroke.height += w / lineScale;
	                        rectWithStroke.x -= w / lineScale / 2;
	                        rectWithStroke.y -= w / lineScale / 2;
	                    }
	                }
	
	                // Return rect with stroke
	                return rectWithStroke;
	            }
	
	            return rect;
	        },
	
	        contain: function (x, y) {
	            var localPos = this.transformCoordToLocal(x, y);
	            var rect = this.getBoundingRect();
	            var style = this.style;
	            x = localPos[0];
	            y = localPos[1];
	
	            if (rect.contain(x, y)) {
	                var pathData = this.path.data;
	                if (style.hasStroke()) {
	                    var lineWidth = style.lineWidth;
	                    var lineScale = style.strokeNoScale ? this.getLineScale() : 1;
	                    // Line scale can't be 0;
	                    if (lineScale > 1e-10) {
	                        // Only add extra hover lineWidth when there are no fill
	                        if (!style.hasFill()) {
	                            lineWidth = Math.max(lineWidth, this.strokeContainThreshold);
	                        }
	                        if (pathContain.containStroke(
	                            pathData, lineWidth / lineScale, x, y
	                        )) {
	                            return true;
	                        }
	                    }
	                }
	                if (style.hasFill()) {
	                    return pathContain.contain(pathData, x, y);
	                }
	            }
	            return false;
	        },
	
	        /**
	         * @param  {boolean} dirtyPath
	         */
	        dirty: function (dirtyPath) {
	            if (dirtyPath == null) {
	                dirtyPath = true;
	            }
	            // Only mark dirty, not mark clean
	            if (dirtyPath) {
	                this.__dirtyPath = dirtyPath;
	                this._rect = null;
	            }
	
	            this.__dirty = true;
	
	            this.__zr && this.__zr.refresh();
	
	            // Used as a clipping path
	            if (this.__clipTarget) {
	                this.__clipTarget.dirty();
	            }
	        },
	
	        /**
	         * Alias for animate('shape')
	         * @param {boolean} loop
	         */
	        animateShape: function (loop) {
	            return this.animate('shape', loop);
	        },
	
	        // Overwrite attrKV
	        attrKV: function (key, value) {
	            // FIXME
	            if (key === 'shape') {
	                this.setShape(value);
	                this.__dirtyPath = true;
	                this._rect = null;
	            }
	            else {
	                Displayable.prototype.attrKV.call(this, key, value);
	            }
	        },
	
	        /**
	         * @param {Object|string} key
	         * @param {*} value
	         */
	        setShape: function (key, value) {
	            var shape = this.shape;
	            // Path from string may not have shape
	            if (shape) {
	                if (zrUtil.isObject(key)) {
	                    for (var name in key) {
	                        shape[name] = key[name];
	                    }
	                }
	                else {
	                    shape[key] = value;
	                }
	                this.dirty(true);
	            }
	            return this;
	        },
	
	        getLineScale: function () {
	            var m = this.transform;
	            // Get the line scale.
	            // Determinant of `m` means how much the area is enlarged by the
	            // transformation. So its square root can be used as a scale factor
	            // for width.
	            return m && abs(m[0] - 1) > 1e-10 && abs(m[3] - 1) > 1e-10
	                ? Math.sqrt(abs(m[0] * m[3] - m[2] * m[1]))
	                : 1;
	        }
	    };
	
	    /**
	     * 扩展一个 Path element, 比如星形，圆等。
	     * Extend a path element
	     * @param {Object} props
	     * @param {string} props.type Path type
	     * @param {Function} props.init Initialize
	     * @param {Function} props.buildPath Overwrite buildPath method
	     * @param {Object} [props.style] Extended default style config
	     * @param {Object} [props.shape] Extended default shape config
	     */
	    Path.extend = function (defaults) {
	        var Sub = function (opts) {
	            Path.call(this, opts);
	
	            if (defaults.style) {
	                // Extend default style
	                this.style.extendFrom(defaults.style, false);
	            }
	
	            // Extend default shape
	            var defaultShape = defaults.shape;
	            if (defaultShape) {
	                this.shape = this.shape || {};
	                var thisShape = this.shape;
	                for (var name in defaultShape) {
	                    if (
	                        ! thisShape.hasOwnProperty(name)
	                        && defaultShape.hasOwnProperty(name)
	                    ) {
	                        thisShape[name] = defaultShape[name];
	                    }
	                }
	            }
	
	            defaults.init && defaults.init.call(this, opts);
	        };
	
	        zrUtil.inherits(Sub, Path);
	
	        // FIXME 不能 extend position, rotation 等引用对象
	        for (var name in defaults) {
	            // Extending prototype values and methods
	            if (name !== 'style' && name !== 'shape') {
	                Sub.prototype[name] = defaults[name];
	            }
	        }
	
	        return Sub;
	    };
	
	    zrUtil.inherits(Path, Displayable);
	
	    module.exports = Path;


/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * 可绘制的图形基类
	 * Base class of all displayable graphic objects
	 * @module zrender/graphic/Displayable
	 */
	
	
	
	    var zrUtil = __webpack_require__(4);
	
	    var Style = __webpack_require__(8);
	
	    var Element = __webpack_require__(9);
	    var RectText = __webpack_require__(22);
	    // var Stateful = require('./mixin/Stateful');
	
	    /**
	     * @alias module:zrender/graphic/Displayable
	     * @extends module:zrender/Element
	     * @extends module:zrender/graphic/mixin/RectText
	     */
	    function Displayable(opts) {
	
	        opts = opts || {};
	
	        Element.call(this, opts);
	
	        // Extend properties
	        for (var name in opts) {
	            if (
	                opts.hasOwnProperty(name) &&
	                name !== 'style'
	            ) {
	                this[name] = opts[name];
	            }
	        }
	
	        /**
	         * @type {module:zrender/graphic/Style}
	         */
	        this.style = new Style(opts.style);
	
	        this._rect = null;
	        // Shapes for cascade clipping.
	        this.__clipPaths = [];
	
	        // FIXME Stateful must be mixined after style is setted
	        // Stateful.call(this, opts);
	    }
	
	    Displayable.prototype = {
	
	        constructor: Displayable,
	
	        type: 'displayable',
	
	        /**
	         * Displayable 是否为脏，Painter 中会根据该标记判断是否需要是否需要重新绘制
	         * Dirty flag. From which painter will determine if this displayable object needs brush
	         * @name module:zrender/graphic/Displayable#__dirty
	         * @type {boolean}
	         */
	        __dirty: true,
	
	        /**
	         * 图形是否可见，为true时不绘制图形，但是仍能触发鼠标事件
	         * If ignore drawing of the displayable object. Mouse event will still be triggered
	         * @name module:/zrender/graphic/Displayable#invisible
	         * @type {boolean}
	         * @default false
	         */
	        invisible: false,
	
	        /**
	         * @name module:/zrender/graphic/Displayable#z
	         * @type {number}
	         * @default 0
	         */
	        z: 0,
	
	        /**
	         * @name module:/zrender/graphic/Displayable#z
	         * @type {number}
	         * @default 0
	         */
	        z2: 0,
	
	        /**
	         * z层level，决定绘画在哪层canvas中
	         * @name module:/zrender/graphic/Displayable#zlevel
	         * @type {number}
	         * @default 0
	         */
	        zlevel: 0,
	
	        /**
	         * 是否可拖拽
	         * @name module:/zrender/graphic/Displayable#draggable
	         * @type {boolean}
	         * @default false
	         */
	        draggable: false,
	
	        /**
	         * 是否正在拖拽
	         * @name module:/zrender/graphic/Displayable#draggable
	         * @type {boolean}
	         * @default false
	         */
	        dragging: false,
	
	        /**
	         * 是否相应鼠标事件
	         * @name module:/zrender/graphic/Displayable#silent
	         * @type {boolean}
	         * @default false
	         */
	        silent: false,
	
	        /**
	         * If enable culling
	         * @type {boolean}
	         * @default false
	         */
	        culling: false,
	
	        /**
	         * Mouse cursor when hovered
	         * @name module:/zrender/graphic/Displayable#cursor
	         * @type {string}
	         */
	        cursor: 'pointer',
	
	        /**
	         * If hover area is bounding rect
	         * @name module:/zrender/graphic/Displayable#rectHover
	         * @type {string}
	         */
	        rectHover: false,
	
	        /**
	         * Render the element progressively when the value >= 0,
	         * usefull for large data.
	         * @type {number}
	         */
	        progressive: -1,
	
	        beforeBrush: function (ctx) {},
	
	        afterBrush: function (ctx) {},
	
	        /**
	         * 图形绘制方法
	         * @param {Canvas2DRenderingContext} ctx
	         */
	        // Interface
	        brush: function (ctx, prevEl) {},
	
	        /**
	         * 获取最小包围盒
	         * @return {module:zrender/core/BoundingRect}
	         */
	        // Interface
	        getBoundingRect: function () {},
	
	        /**
	         * 判断坐标 x, y 是否在图形上
	         * If displayable element contain coord x, y
	         * @param  {number} x
	         * @param  {number} y
	         * @return {boolean}
	         */
	        contain: function (x, y) {
	            return this.rectContain(x, y);
	        },
	
	        /**
	         * @param  {Function} cb
	         * @param  {}   context
	         */
	        traverse: function (cb, context) {
	            cb.call(context, this);
	        },
	
	        /**
	         * 判断坐标 x, y 是否在图形的包围盒上
	         * If bounding rect of element contain coord x, y
	         * @param  {number} x
	         * @param  {number} y
	         * @return {boolean}
	         */
	        rectContain: function (x, y) {
	            var coord = this.transformCoordToLocal(x, y);
	            var rect = this.getBoundingRect();
	            return rect.contain(coord[0], coord[1]);
	        },
	
	        /**
	         * 标记图形元素为脏，并且在下一帧重绘
	         * Mark displayable element dirty and refresh next frame
	         */
	        dirty: function () {
	            this.__dirty = true;
	
	            this._rect = null;
	
	            this.__zr && this.__zr.refresh();
	        },
	
	        /**
	         * 图形是否会触发事件
	         * If displayable object binded any event
	         * @return {boolean}
	         */
	        // TODO, 通过 bind 绑定的事件
	        // isSilent: function () {
	        //     return !(
	        //         this.hoverable || this.draggable
	        //         || this.onmousemove || this.onmouseover || this.onmouseout
	        //         || this.onmousedown || this.onmouseup || this.onclick
	        //         || this.ondragenter || this.ondragover || this.ondragleave
	        //         || this.ondrop
	        //     );
	        // },
	        /**
	         * Alias for animate('style')
	         * @param {boolean} loop
	         */
	        animateStyle: function (loop) {
	            return this.animate('style', loop);
	        },
	
	        attrKV: function (key, value) {
	            if (key !== 'style') {
	                Element.prototype.attrKV.call(this, key, value);
	            }
	            else {
	                this.style.set(value);
	            }
	        },
	
	        /**
	         * @param {Object|string} key
	         * @param {*} value
	         */
	        setStyle: function (key, value) {
	            this.style.set(key, value);
	            this.dirty(false);
	            return this;
	        },
	
	        /**
	         * Use given style object
	         * @param  {Object} obj
	         */
	        useStyle: function (obj) {
	            this.style = new Style(obj);
	            this.dirty(false);
	            return this;
	        }
	    };
	
	    zrUtil.inherits(Displayable, Element);
	
	    zrUtil.mixin(Displayable, RectText);
	    // zrUtil.mixin(Displayable, Stateful);
	
	    module.exports = Displayable;


/***/ },
/* 8 */
/***/ function(module, exports) {

	/**
	 * @module zrender/graphic/Style
	 */
	
	
	    var STYLE_COMMON_PROPS = [
	        ['shadowBlur', 0], ['shadowOffsetX', 0], ['shadowOffsetY', 0], ['shadowColor', '#000'],
	        ['lineCap', 'butt'], ['lineJoin', 'miter'], ['miterLimit', 10]
	    ];
	
	    // var SHADOW_PROPS = STYLE_COMMON_PROPS.slice(0, 4);
	    // var LINE_PROPS = STYLE_COMMON_PROPS.slice(4);
	
	    var Style = function (opts) {
	        this.extendFrom(opts);
	    };
	
	    function createLinearGradient(ctx, obj, rect) {
	        // var size =
	        var x = obj.x;
	        var x2 = obj.x2;
	        var y = obj.y;
	        var y2 = obj.y2;
	
	        if (!obj.global) {
	            x = x * rect.width + rect.x;
	            x2 = x2 * rect.width + rect.x;
	            y = y * rect.height + rect.y;
	            y2 = y2 * rect.height + rect.y;
	        }
	
	        var canvasGradient = ctx.createLinearGradient(x, y, x2, y2);
	
	        return canvasGradient;
	    }
	
	    function createRadialGradient(ctx, obj, rect) {
	        var width = rect.width;
	        var height = rect.height;
	        var min = Math.min(width, height);
	
	        var x = obj.x;
	        var y = obj.y;
	        var r = obj.r;
	        if (!obj.global) {
	            x = x * width + rect.x;
	            y = y * height + rect.y;
	            r = r * min;
	        }
	
	        var canvasGradient = ctx.createRadialGradient(x, y, 0, x, y, r);
	
	        return canvasGradient;
	    }
	
	
	    Style.prototype = {
	
	        constructor: Style,
	
	        /**
	         * @type {string}
	         */
	        fill: '#000000',
	
	        /**
	         * @type {string}
	         */
	        stroke: null,
	
	        /**
	         * @type {number}
	         */
	        opacity: 1,
	
	        /**
	         * @type {Array.<number>}
	         */
	        lineDash: null,
	
	        /**
	         * @type {number}
	         */
	        lineDashOffset: 0,
	
	        /**
	         * @type {number}
	         */
	        shadowBlur: 0,
	
	        /**
	         * @type {number}
	         */
	        shadowOffsetX: 0,
	
	        /**
	         * @type {number}
	         */
	        shadowOffsetY: 0,
	
	        /**
	         * @type {number}
	         */
	        lineWidth: 1,
	
	        /**
	         * If stroke ignore scale
	         * @type {Boolean}
	         */
	        strokeNoScale: false,
	
	        // Bounding rect text configuration
	        // Not affected by element transform
	        /**
	         * @type {string}
	         */
	        text: null,
	
	        /**
	         * @type {string}
	         */
	        textFill: '#000',
	
	        /**
	         * @type {string}
	         */
	        textStroke: null,
	
	        /**
	         * 'inside', 'left', 'right', 'top', 'bottom'
	         * [x, y]
	         * @type {string|Array.<number>}
	         * @default 'inside'
	         */
	        textPosition: 'inside',
	
	        /**
	         * @type {string}
	         */
	        textBaseline: null,
	
	        /**
	         * @type {string}
	         */
	        textAlign: null,
	
	        /**
	         * @type {string}
	         */
	        textVerticalAlign: null,
	
	        /**
	         * Only useful in Path and Image element
	         * @type {number}
	         */
	        textDistance: 5,
	
	        /**
	         * Only useful in Path and Image element
	         * @type {number}
	         */
	        textShadowBlur: 0,
	
	        /**
	         * Only useful in Path and Image element
	         * @type {number}
	         */
	        textShadowOffsetX: 0,
	
	        /**
	         * Only useful in Path and Image element
	         * @type {number}
	         */
	        textShadowOffsetY: 0,
	
	        /**
	         * If transform text
	         * Only useful in Path and Image element
	         * @type {boolean}
	         */
	        textTransform: false,
	
	        /**
	         * Text rotate around position of Path or Image
	         * Only useful in Path and Image element and textTransform is false.
	         */
	        textRotation: 0,
	
	        /**
	         * @type {string}
	         * https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation
	         */
	        blend: null,
	
	        /**
	         * @param {CanvasRenderingContext2D} ctx
	         */
	        bind: function (ctx, el, prevEl) {
	            var style = this;
	            var prevStyle = prevEl && prevEl.style;
	            var firstDraw = !prevStyle;
	
	            for (var i = 0; i < STYLE_COMMON_PROPS.length; i++) {
	                var prop = STYLE_COMMON_PROPS[i];
	                var styleName = prop[0];
	
	                if (firstDraw || style[styleName] !== prevStyle[styleName]) {
	                    // FIXME Invalid property value will cause style leak from previous element.
	                    ctx[styleName] = style[styleName] || prop[1];
	                }
	            }
	
	            if ((firstDraw || style.fill !== prevStyle.fill)) {
	                ctx.fillStyle = style.fill;
	            }
	            if ((firstDraw || style.stroke !== prevStyle.stroke)) {
	                ctx.strokeStyle = style.stroke;
	            }
	            if ((firstDraw || style.opacity !== prevStyle.opacity)) {
	                ctx.globalAlpha = style.opacity == null ? 1 : style.opacity;
	            }
	
	            if ((firstDraw || style.blend !== prevStyle.blend)) {
	                ctx.globalCompositeOperation = style.blend || 'source-over';
	            }
	            if (this.hasStroke()) {
	                var lineWidth = style.lineWidth;
	                ctx.lineWidth = lineWidth / (
	                    (this.strokeNoScale && el && el.getLineScale) ? el.getLineScale() : 1
	                );
	            }
	        },
	
	        hasFill: function () {
	            var fill = this.fill;
	            return fill != null && fill !== 'none';
	        },
	
	        hasStroke: function () {
	            var stroke = this.stroke;
	            return stroke != null && stroke !== 'none' && this.lineWidth > 0;
	        },
	
	        /**
	         * Extend from other style
	         * @param {zrender/graphic/Style} otherStyle
	         * @param {boolean} overwrite
	         */
	        extendFrom: function (otherStyle, overwrite) {
	            if (otherStyle) {
	                var target = this;
	                for (var name in otherStyle) {
	                    if (otherStyle.hasOwnProperty(name)
	                        && (overwrite || ! target.hasOwnProperty(name))
	                    ) {
	                        target[name] = otherStyle[name];
	                    }
	                }
	            }
	        },
	
	        /**
	         * Batch setting style with a given object
	         * @param {Object|string} obj
	         * @param {*} [obj]
	         */
	        set: function (obj, value) {
	            if (typeof obj === 'string') {
	                this[obj] = value;
	            }
	            else {
	                this.extendFrom(obj, true);
	            }
	        },
	
	        /**
	         * Clone
	         * @return {zrender/graphic/Style} [description]
	         */
	        clone: function () {
	            var newStyle = new this.constructor();
	            newStyle.extendFrom(this, true);
	            return newStyle;
	        },
	
	        getGradient: function (ctx, obj, rect) {
	            var method = obj.type === 'radial' ? createRadialGradient : createLinearGradient;
	            var canvasGradient = method(ctx, obj, rect);
	            var colorStops = obj.colorStops;
	            for (var i = 0; i < colorStops.length; i++) {
	                canvasGradient.addColorStop(
	                    colorStops[i].offset, colorStops[i].color
	                );
	            }
	            return canvasGradient;
	        }
	    };
	
	    var styleProto = Style.prototype;
	    for (var i = 0; i < STYLE_COMMON_PROPS.length; i++) {
	        var prop = STYLE_COMMON_PROPS[i];
	        if (!(prop[0] in styleProto)) {
	            styleProto[prop[0]] = prop[1];
	        }
	    }
	
	    // Provide for others
	    Style.getGradient = styleProto.getGradient;
	
	    module.exports = Style;


/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	/**
	 * @module zrender/Element
	 */
	
	
	    var guid = __webpack_require__(10);
	    var Eventful = __webpack_require__(11);
	    var Transformable = __webpack_require__(12);
	    var Animatable = __webpack_require__(15);
	    var zrUtil = __webpack_require__(4);
	
	    /**
	     * @alias module:zrender/Element
	     * @constructor
	     * @extends {module:zrender/mixin/Animatable}
	     * @extends {module:zrender/mixin/Transformable}
	     * @extends {module:zrender/mixin/Eventful}
	     */
	    var Element = function (opts) {
	
	        Transformable.call(this, opts);
	        Eventful.call(this, opts);
	        Animatable.call(this, opts);
	
	        /**
	         * 画布元素ID
	         * @type {string}
	         */
	        this.id = opts.id || guid();
	    };
	
	    Element.prototype = {
	
	        /**
	         * 元素类型
	         * Element type
	         * @type {string}
	         */
	        type: 'element',
	
	        /**
	         * 元素名字
	         * Element name
	         * @type {string}
	         */
	        name: '',
	
	        /**
	         * ZRender 实例对象，会在 element 添加到 zrender 实例中后自动赋值
	         * ZRender instance will be assigned when element is associated with zrender
	         * @name module:/zrender/Element#__zr
	         * @type {module:zrender/ZRender}
	         */
	        __zr: null,
	
	        /**
	         * 图形是否忽略，为true时忽略图形的绘制以及事件触发
	         * If ignore drawing and events of the element object
	         * @name module:/zrender/Element#ignore
	         * @type {boolean}
	         * @default false
	         */
	        ignore: false,
	
	        /**
	         * 用于裁剪的路径(shape)，所有 Group 内的路径在绘制时都会被这个路径裁剪
	         * 该路径会继承被裁减对象的变换
	         * @type {module:zrender/graphic/Path}
	         * @see http://www.w3.org/TR/2dcontext/#clipping-region
	         * @readOnly
	         */
	        clipPath: null,
	
	        /**
	         * Drift element
	         * @param  {number} dx dx on the global space
	         * @param  {number} dy dy on the global space
	         */
	        drift: function (dx, dy) {
	            switch (this.draggable) {
	                case 'horizontal':
	                    dy = 0;
	                    break;
	                case 'vertical':
	                    dx = 0;
	                    break;
	            }
	
	            var m = this.transform;
	            if (!m) {
	                m = this.transform = [1, 0, 0, 1, 0, 0];
	            }
	            m[4] += dx;
	            m[5] += dy;
	
	            this.decomposeTransform();
	            this.dirty(false);
	        },
	
	        /**
	         * Hook before update
	         */
	        beforeUpdate: function () {},
	        /**
	         * Hook after update
	         */
	        afterUpdate: function () {},
	        /**
	         * Update each frame
	         */
	        update: function () {
	            this.updateTransform();
	        },
	
	        /**
	         * @param  {Function} cb
	         * @param  {}   context
	         */
	        traverse: function (cb, context) {},
	
	        /**
	         * @protected
	         */
	        attrKV: function (key, value) {
	            if (key === 'position' || key === 'scale' || key === 'origin') {
	                // Copy the array
	                if (value) {
	                    var target = this[key];
	                    if (!target) {
	                        target = this[key] = [];
	                    }
	                    target[0] = value[0];
	                    target[1] = value[1];
	                }
	            }
	            else {
	                this[key] = value;
	            }
	        },
	
	        /**
	         * Hide the element
	         */
	        hide: function () {
	            this.ignore = true;
	            this.__zr && this.__zr.refresh();
	        },
	
	        /**
	         * Show the element
	         */
	        show: function () {
	            this.ignore = false;
	            this.__zr && this.__zr.refresh();
	        },
	
	        /**
	         * @param {string|Object} key
	         * @param {*} value
	         */
	        attr: function (key, value) {
	            if (typeof key === 'string') {
	                this.attrKV(key, value);
	            }
	            else if (zrUtil.isObject(key)) {
	                for (var name in key) {
	                    if (key.hasOwnProperty(name)) {
	                        this.attrKV(name, key[name]);
	                    }
	                }
	            }
	
	            this.dirty(false);
	
	            return this;
	        },
	
	        /**
	         * @param {module:zrender/graphic/Path} clipPath
	         */
	        setClipPath: function (clipPath) {
	            var zr = this.__zr;
	            if (zr) {
	                clipPath.addSelfToZr(zr);
	            }
	
	            // Remove previous clip path
	            if (this.clipPath && this.clipPath !== clipPath) {
	                this.removeClipPath();
	            }
	
	            this.clipPath = clipPath;
	            clipPath.__zr = zr;
	            clipPath.__clipTarget = this;
	
	            this.dirty(false);
	        },
	
	        /**
	         */
	        removeClipPath: function () {
	            var clipPath = this.clipPath;
	            if (clipPath) {
	                if (clipPath.__zr) {
	                    clipPath.removeSelfFromZr(clipPath.__zr);
	                }
	
	                clipPath.__zr = null;
	                clipPath.__clipTarget = null;
	                this.clipPath = null;
	
	                this.dirty(false);
	            }
	        },
	
	        /**
	         * Add self from zrender instance.
	         * Not recursively because it will be invoked when element added to storage.
	         * @param {module:zrender/ZRender} zr
	         */
	        addSelfToZr: function (zr) {
	            this.__zr = zr;
	            // 添加动画
	            var animators = this.animators;
	            if (animators) {
	                for (var i = 0; i < animators.length; i++) {
	                    zr.animation.addAnimator(animators[i]);
	                }
	            }
	
	            if (this.clipPath) {
	                this.clipPath.addSelfToZr(zr);
	            }
	        },
	
	        /**
	         * Remove self from zrender instance.
	         * Not recursively because it will be invoked when element added to storage.
	         * @param {module:zrender/ZRender} zr
	         */
	        removeSelfFromZr: function (zr) {
	            this.__zr = null;
	            // 移除动画
	            var animators = this.animators;
	            if (animators) {
	                for (var i = 0; i < animators.length; i++) {
	                    zr.animation.removeAnimator(animators[i]);
	                }
	            }
	
	            if (this.clipPath) {
	                this.clipPath.removeSelfFromZr(zr);
	            }
	        }
	    };
	
	    zrUtil.mixin(Element, Animatable);
	    zrUtil.mixin(Element, Transformable);
	    zrUtil.mixin(Element, Eventful);
	
	    module.exports = Element;


/***/ },
/* 10 */
/***/ function(module, exports) {

	/**
	 * zrender: 生成唯一id
	 *
	 * @author errorrik (errorrik@gmail.com)
	 */
	
	
	    var idStart = 0x0907;
	
	    module.exports = function () {
	        return idStart++;
	    };
	


/***/ },
/* 11 */
/***/ function(module, exports) {

	/**
	 * 事件扩展
	 * @module zrender/mixin/Eventful
	 * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)
	 *         pissang (https://www.github.com/pissang)
	 */
	
	
	    var arrySlice = Array.prototype.slice;
	
	    /**
	     * 事件分发器
	     * @alias module:zrender/mixin/Eventful
	     * @constructor
	     */
	    var Eventful = function () {
	        this._$handlers = {};
	    };
	
	    Eventful.prototype = {
	
	        constructor: Eventful,
	
	        /**
	         * 单次触发绑定，trigger后销毁
	         *
	         * @param {string} event 事件名
	         * @param {Function} handler 响应函数
	         * @param {Object} context
	         */
	        one: function (event, handler, context) {
	            var _h = this._$handlers;
	
	            if (!handler || !event) {
	                return this;
	            }
	
	            if (!_h[event]) {
	                _h[event] = [];
	            }
	
	            for (var i = 0; i < _h[event].length; i++) {
	                if (_h[event][i].h === handler) {
	                    return this;
	                }
	            }
	
	            _h[event].push({
	                h: handler,
	                one: true,
	                ctx: context || this
	            });
	
	            return this;
	        },
	
	        /**
	         * 绑定事件
	         * @param {string} event 事件名
	         * @param {Function} handler 事件处理函数
	         * @param {Object} [context]
	         */
	        on: function (event, handler, context) {
	            var _h = this._$handlers;
	
	            if (!handler || !event) {
	                return this;
	            }
	
	            if (!_h[event]) {
	                _h[event] = [];
	            }
	
	            for (var i = 0; i < _h[event].length; i++) {
	                if (_h[event][i].h === handler) {
	                    return this;
	                }
	            }
	
	            _h[event].push({
	                h: handler,
	                one: false,
	                ctx: context || this
	            });
	
	            return this;
	        },
	
	        /**
	         * 是否绑定了事件
	         * @param  {string}  event
	         * @return {boolean}
	         */
	        isSilent: function (event) {
	            var _h = this._$handlers;
	            return _h[event] && _h[event].length;
	        },
	
	        /**
	         * 解绑事件
	         * @param {string} event 事件名
	         * @param {Function} [handler] 事件处理函数
	         */
	        off: function (event, handler) {
	            var _h = this._$handlers;
	
	            if (!event) {
	                this._$handlers = {};
	                return this;
	            }
	
	            if (handler) {
	                if (_h[event]) {
	                    var newList = [];
	                    for (var i = 0, l = _h[event].length; i < l; i++) {
	                        if (_h[event][i]['h'] != handler) {
	                            newList.push(_h[event][i]);
	                        }
	                    }
	                    _h[event] = newList;
	                }
	
	                if (_h[event] && _h[event].length === 0) {
	                    delete _h[event];
	                }
	            }
	            else {
	                delete _h[event];
	            }
	
	            return this;
	        },
	
	        /**
	         * 事件分发
	         *
	         * @param {string} type 事件类型
	         */
	        trigger: function (type) {
	            if (this._$handlers[type]) {
	                var args = arguments;
	                var argLen = args.length;
	
	                if (argLen > 3) {
	                    args = arrySlice.call(args, 1);
	                }
	
	                var _h = this._$handlers[type];
	                var len = _h.length;
	                for (var i = 0; i < len;) {
	                    // Optimize advise from backbone
	                    switch (argLen) {
	                        case 1:
	                            _h[i]['h'].call(_h[i]['ctx']);
	                            break;
	                        case 2:
	                            _h[i]['h'].call(_h[i]['ctx'], args[1]);
	                            break;
	                        case 3:
	                            _h[i]['h'].call(_h[i]['ctx'], args[1], args[2]);
	                            break;
	                        default:
	                            // have more than 2 given arguments
	                            _h[i]['h'].apply(_h[i]['ctx'], args);
	                            break;
	                    }
	
	                    if (_h[i]['one']) {
	                        _h.splice(i, 1);
	                        len--;
	                    }
	                    else {
	                        i++;
	                    }
	                }
	            }
	
	            return this;
	        },
	
	        /**
	         * 带有context的事件分发, 最后一个参数是事件回调的context
	         * @param {string} type 事件类型
	         */
	        triggerWithContext: function (type) {
	            if (this._$handlers[type]) {
	                var args = arguments;
	                var argLen = args.length;
	
	                if (argLen > 4) {
	                    args = arrySlice.call(args, 1, args.length - 1);
	                }
	                var ctx = args[args.length - 1];
	
	                var _h = this._$handlers[type];
	                var len = _h.length;
	                for (var i = 0; i < len;) {
	                    // Optimize advise from backbone
	                    switch (argLen) {
	                        case 1:
	                            _h[i]['h'].call(ctx);
	                            break;
	                        case 2:
	                            _h[i]['h'].call(ctx, args[1]);
	                            break;
	                        case 3:
	                            _h[i]['h'].call(ctx, args[1], args[2]);
	                            break;
	                        default:
	                            // have more than 2 given arguments
	                            _h[i]['h'].apply(ctx, args);
	                            break;
	                    }
	
	                    if (_h[i]['one']) {
	                        _h.splice(i, 1);
	                        len--;
	                    }
	                    else {
	                        i++;
	                    }
	                }
	            }
	
	            return this;
	        }
	    };
	
	    // 对象可以通过 onxxxx 绑定事件
	    /**
	     * @event module:zrender/mixin/Eventful#onclick
	     * @type {Function}
	     * @default null
	     */
	    /**
	     * @event module:zrender/mixin/Eventful#onmouseover
	     * @type {Function}
	     * @default null
	     */
	    /**
	     * @event module:zrender/mixin/Eventful#onmouseout
	     * @type {Function}
	     * @default null
	     */
	    /**
	     * @event module:zrender/mixin/Eventful#onmousemove
	     * @type {Function}
	     * @default null
	     */
	    /**
	     * @event module:zrender/mixin/Eventful#onmousewheel
	     * @type {Function}
	     * @default null
	     */
	    /**
	     * @event module:zrender/mixin/Eventful#onmousedown
	     * @type {Function}
	     * @default null
	     */
	    /**
	     * @event module:zrender/mixin/Eventful#onmouseup
	     * @type {Function}
	     * @default null
	     */
	    /**
	     * @event module:zrender/mixin/Eventful#ondragstart
	     * @type {Function}
	     * @default null
	     */
	    /**
	     * @event module:zrender/mixin/Eventful#ondragend
	     * @type {Function}
	     * @default null
	     */
	    /**
	     * @event module:zrender/mixin/Eventful#ondragenter
	     * @type {Function}
	     * @default null
	     */
	    /**
	     * @event module:zrender/mixin/Eventful#ondragleave
	     * @type {Function}
	     * @default null
	     */
	    /**
	     * @event module:zrender/mixin/Eventful#ondragover
	     * @type {Function}
	     * @default null
	     */
	    /**
	     * @event module:zrender/mixin/Eventful#ondrop
	     * @type {Function}
	     * @default null
	     */
	
	    module.exports = Eventful;
	


/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	/**
	 * 提供变换扩展
	 * @module zrender/mixin/Transformable
	 * @author pissang (https://www.github.com/pissang)
	 */
	
	
	    var matrix = __webpack_require__(13);
	    var vector = __webpack_require__(14);
	    var mIdentity = matrix.identity;
	
	    var EPSILON = 5e-5;
	
	    function isNotAroundZero(val) {
	        return val > EPSILON || val < -EPSILON;
	    }
	
	    /**
	     * @alias module:zrender/mixin/Transformable
	     * @constructor
	     */
	    var Transformable = function (opts) {
	        opts = opts || {};
	        // If there are no given position, rotation, scale
	        if (!opts.position) {
	            /**
	             * 平移
	             * @type {Array.<number>}
	             * @default [0, 0]
	             */
	            this.position = [0, 0];
	        }
	        if (opts.rotation == null) {
	            /**
	             * 旋转
	             * @type {Array.<number>}
	             * @default 0
	             */
	            this.rotation = 0;
	        }
	        if (!opts.scale) {
	            /**
	             * 缩放
	             * @type {Array.<number>}
	             * @default [1, 1]
	             */
	            this.scale = [1, 1];
	        }
	        /**
	         * 旋转和缩放的原点
	         * @type {Array.<number>}
	         * @default null
	         */
	        this.origin = this.origin || null;
	    };
	
	    var transformableProto = Transformable.prototype;
	    transformableProto.transform = null;
	
	    /**
	     * 判断是否需要有坐标变换
	     * 如果有坐标变换, 则从position, rotation, scale以及父节点的transform计算出自身的transform矩阵
	     */
	    transformableProto.needLocalTransform = function () {
	        return isNotAroundZero(this.rotation)
	            || isNotAroundZero(this.position[0])
	            || isNotAroundZero(this.position[1])
	            || isNotAroundZero(this.scale[0] - 1)
	            || isNotAroundZero(this.scale[1] - 1);
	    };
	
	    transformableProto.updateTransform = function () {
	        var parent = this.parent;
	        var parentHasTransform = parent && parent.transform;
	        var needLocalTransform = this.needLocalTransform();
	
	        var m = this.transform;
	        if (!(needLocalTransform || parentHasTransform)) {
	            m && mIdentity(m);
	            return;
	        }
	
	        m = m || matrix.create();
	
	        if (needLocalTransform) {
	            this.getLocalTransform(m);
	        }
	        else {
	            mIdentity(m);
	        }
	
	        // 应用父节点变换
	        if (parentHasTransform) {
	            if (needLocalTransform) {
	                matrix.mul(m, parent.transform, m);
	            }
	            else {
	                matrix.copy(m, parent.transform);
	            }
	        }
	        // 保存这个变换矩阵
	        this.transform = m;
	
	        this.invTransform = this.invTransform || matrix.create();
	        matrix.invert(this.invTransform, m);
	    };
	
	    transformableProto.getLocalTransform = function (m) {
	        m = m || [];
	        mIdentity(m);
	
	        var origin = this.origin;
	
	        var scale = this.scale;
	        var rotation = this.rotation;
	        var position = this.position;
	        if (origin) {
	            // Translate to origin
	            m[4] -= origin[0];
	            m[5] -= origin[1];
	        }
	        matrix.scale(m, m, scale);
	        if (rotation) {
	            matrix.rotate(m, m, rotation);
	        }
	        if (origin) {
	            // Translate back from origin
	            m[4] += origin[0];
	            m[5] += origin[1];
	        }
	
	        m[4] += position[0];
	        m[5] += position[1];
	
	        return m;
	    };
	    /**
	     * 将自己的transform应用到context上
	     * @param {Context2D} ctx
	     */
	    transformableProto.setTransform = function (ctx) {
	        var m = this.transform;
	        var dpr = ctx.dpr || 1;
	        if (m) {
	            ctx.setTransform(dpr * m[0], dpr * m[1], dpr * m[2], dpr * m[3], dpr * m[4], dpr * m[5]);
	        }
	        else {
	            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
	        }
	    };
	
	    transformableProto.restoreTransform = function (ctx) {
	        var m = this.transform;
	        var dpr = ctx.dpr || 1;
	        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
	    }
	
	    var tmpTransform = [];
	
	    /**
	     * 分解`transform`矩阵到`position`, `rotation`, `scale`
	     */
	    transformableProto.decomposeTransform = function () {
	        if (!this.transform) {
	            return;
	        }
	        var parent = this.parent;
	        var m = this.transform;
	        if (parent && parent.transform) {
	            // Get local transform and decompose them to position, scale, rotation
	            matrix.mul(tmpTransform, parent.invTransform, m);
	            m = tmpTransform;
	        }
	        var sx = m[0] * m[0] + m[1] * m[1];
	        var sy = m[2] * m[2] + m[3] * m[3];
	        var position = this.position;
	        var scale = this.scale;
	        if (isNotAroundZero(sx - 1)) {
	            sx = Math.sqrt(sx);
	        }
	        if (isNotAroundZero(sy - 1)) {
	            sy = Math.sqrt(sy);
	        }
	        if (m[0] < 0) {
	            sx = -sx;
	        }
	        if (m[3] < 0) {
	            sy = -sy;
	        }
	        position[0] = m[4];
	        position[1] = m[5];
	        scale[0] = sx;
	        scale[1] = sy;
	        this.rotation = Math.atan2(-m[1] / sy, m[0] / sx);
	    };
	
	    /**
	     * Get global scale
	     * @return {Array.<number>}
	     */
	    transformableProto.getGlobalScale = function () {
	        var m = this.transform;
	        if (!m) {
	            return [1, 1];
	        }
	        var sx = Math.sqrt(m[0] * m[0] + m[1] * m[1]);
	        var sy = Math.sqrt(m[2] * m[2] + m[3] * m[3]);
	        if (m[0] < 0) {
	            sx = -sx;
	        }
	        if (m[3] < 0) {
	            sy = -sy;
	        }
	        return [sx, sy];
	    };
	    /**
	     * 变换坐标位置到 shape 的局部坐标空间
	     * @method
	     * @param {number} x
	     * @param {number} y
	     * @return {Array.<number>}
	     */
	    transformableProto.transformCoordToLocal = function (x, y) {
	        var v2 = [x, y];
	        var invTransform = this.invTransform;
	        if (invTransform) {
	            vector.applyTransform(v2, v2, invTransform);
	        }
	        return v2;
	    };
	
	    /**
	     * 变换局部坐标位置到全局坐标空间
	     * @method
	     * @param {number} x
	     * @param {number} y
	     * @return {Array.<number>}
	     */
	    transformableProto.transformCoordToGlobal = function (x, y) {
	        var v2 = [x, y];
	        var transform = this.transform;
	        if (transform) {
	            vector.applyTransform(v2, v2, transform);
	        }
	        return v2;
	    };
	
	    module.exports = Transformable;
	


/***/ },
/* 13 */
/***/ function(module, exports) {

	
	    var ArrayCtor = typeof Float32Array === 'undefined'
	        ? Array
	        : Float32Array;
	    /**
	     * 3x2矩阵操作类
	     * @exports zrender/tool/matrix
	     */
	    var matrix = {
	        /**
	         * 创建一个单位矩阵
	         * @return {Float32Array|Array.<number>}
	         */
	        create : function() {
	            var out = new ArrayCtor(6);
	            matrix.identity(out);
	
	            return out;
	        },
	        /**
	         * 设置矩阵为单位矩阵
	         * @param {Float32Array|Array.<number>} out
	         */
	        identity : function(out) {
	            out[0] = 1;
	            out[1] = 0;
	            out[2] = 0;
	            out[3] = 1;
	            out[4] = 0;
	            out[5] = 0;
	            return out;
	        },
	        /**
	         * 复制矩阵
	         * @param {Float32Array|Array.<number>} out
	         * @param {Float32Array|Array.<number>} m
	         */
	        copy: function(out, m) {
	            out[0] = m[0];
	            out[1] = m[1];
	            out[2] = m[2];
	            out[3] = m[3];
	            out[4] = m[4];
	            out[5] = m[5];
	            return out;
	        },
	        /**
	         * 矩阵相乘
	         * @param {Float32Array|Array.<number>} out
	         * @param {Float32Array|Array.<number>} m1
	         * @param {Float32Array|Array.<number>} m2
	         */
	        mul : function (out, m1, m2) {
	            // Consider matrix.mul(m, m2, m);
	            // where out is the same as m2.
	            // So use temp variable to escape error.
	            var out0 = m1[0] * m2[0] + m1[2] * m2[1];
	            var out1 = m1[1] * m2[0] + m1[3] * m2[1];
	            var out2 = m1[0] * m2[2] + m1[2] * m2[3];
	            var out3 = m1[1] * m2[2] + m1[3] * m2[3];
	            var out4 = m1[0] * m2[4] + m1[2] * m2[5] + m1[4];
	            var out5 = m1[1] * m2[4] + m1[3] * m2[5] + m1[5];
	            out[0] = out0;
	            out[1] = out1;
	            out[2] = out2;
	            out[3] = out3;
	            out[4] = out4;
	            out[5] = out5;
	            return out;
	        },
	        /**
	         * 平移变换
	         * @param {Float32Array|Array.<number>} out
	         * @param {Float32Array|Array.<number>} a
	         * @param {Float32Array|Array.<number>} v
	         */
	        translate : function(out, a, v) {
	            out[0] = a[0];
	            out[1] = a[1];
	            out[2] = a[2];
	            out[3] = a[3];
	            out[4] = a[4] + v[0];
	            out[5] = a[5] + v[1];
	            return out;
	        },
	        /**
	         * 旋转变换
	         * @param {Float32Array|Array.<number>} out
	         * @param {Float32Array|Array.<number>} a
	         * @param {number} rad
	         */
	        rotate : function(out, a, rad) {
	            var aa = a[0];
	            var ac = a[2];
	            var atx = a[4];
	            var ab = a[1];
	            var ad = a[3];
	            var aty = a[5];
	            var st = Math.sin(rad);
	            var ct = Math.cos(rad);
	
	            out[0] = aa * ct + ab * st;
	            out[1] = -aa * st + ab * ct;
	            out[2] = ac * ct + ad * st;
	            out[3] = -ac * st + ct * ad;
	            out[4] = ct * atx + st * aty;
	            out[5] = ct * aty - st * atx;
	            return out;
	        },
	        /**
	         * 缩放变换
	         * @param {Float32Array|Array.<number>} out
	         * @param {Float32Array|Array.<number>} a
	         * @param {Float32Array|Array.<number>} v
	         */
	        scale : function(out, a, v) {
	            var vx = v[0];
	            var vy = v[1];
	            out[0] = a[0] * vx;
	            out[1] = a[1] * vy;
	            out[2] = a[2] * vx;
	            out[3] = a[3] * vy;
	            out[4] = a[4] * vx;
	            out[5] = a[5] * vy;
	            return out;
	        },
	        /**
	         * 求逆矩阵
	         * @param {Float32Array|Array.<number>} out
	         * @param {Float32Array|Array.<number>} a
	         */
	        invert : function(out, a) {
	
	            var aa = a[0];
	            var ac = a[2];
	            var atx = a[4];
	            var ab = a[1];
	            var ad = a[3];
	            var aty = a[5];
	
	            var det = aa * ad - ab * ac;
	            if (!det) {
	                return null;
	            }
	            det = 1.0 / det;
	
	            out[0] = ad * det;
	            out[1] = -ab * det;
	            out[2] = -ac * det;
	            out[3] = aa * det;
	            out[4] = (ac * aty - ad * atx) * det;
	            out[5] = (ab * atx - aa * aty) * det;
	            return out;
	        }
	    };
	
	    module.exports = matrix;
	


/***/ },
/* 14 */
/***/ function(module, exports) {

	
	    var ArrayCtor = typeof Float32Array === 'undefined'
	        ? Array
	        : Float32Array;
	
	    /**
	     * @typedef {Float32Array|Array.<number>} Vector2
	     */
	    /**
	     * 二维向量类
	     * @exports zrender/tool/vector
	     */
	    var vector = {
	        /**
	         * 创建一个向量
	         * @param {number} [x=0]
	         * @param {number} [y=0]
	         * @return {Vector2}
	         */
	        create: function (x, y) {
	            var out = new ArrayCtor(2);
	            if (x == null) {
	                x = 0;
	            }
	            if (y == null) {
	                y = 0;
	            }
	            out[0] = x;
	            out[1] = y;
	            return out;
	        },
	
	        /**
	         * 复制向量数据
	         * @param {Vector2} out
	         * @param {Vector2} v
	         * @return {Vector2}
	         */
	        copy: function (out, v) {
	            out[0] = v[0];
	            out[1] = v[1];
	            return out;
	        },
	
	        /**
	         * 克隆一个向量
	         * @param {Vector2} v
	         * @return {Vector2}
	         */
	        clone: function (v) {
	            var out = new ArrayCtor(2);
	            out[0] = v[0];
	            out[1] = v[1];
	            return out;
	        },
	
	        /**
	         * 设置向量的两个项
	         * @param {Vector2} out
	         * @param {number} a
	         * @param {number} b
	         * @return {Vector2} 结果
	         */
	        set: function (out, a, b) {
	            out[0] = a;
	            out[1] = b;
	            return out;
	        },
	
	        /**
	         * 向量相加
	         * @param {Vector2} out
	         * @param {Vector2} v1
	         * @param {Vector2} v2
	         */
	        add: function (out, v1, v2) {
	            out[0] = v1[0] + v2[0];
	            out[1] = v1[1] + v2[1];
	            return out;
	        },
	
	        /**
	         * 向量缩放后相加
	         * @param {Vector2} out
	         * @param {Vector2} v1
	         * @param {Vector2} v2
	         * @param {number} a
	         */
	        scaleAndAdd: function (out, v1, v2, a) {
	            out[0] = v1[0] + v2[0] * a;
	            out[1] = v1[1] + v2[1] * a;
	            return out;
	        },
	
	        /**
	         * 向量相减
	         * @param {Vector2} out
	         * @param {Vector2} v1
	         * @param {Vector2} v2
	         */
	        sub: function (out, v1, v2) {
	            out[0] = v1[0] - v2[0];
	            out[1] = v1[1] - v2[1];
	            return out;
	        },
	
	        /**
	         * 向量长度
	         * @param {Vector2} v
	         * @return {number}
	         */
	        len: function (v) {
	            return Math.sqrt(this.lenSquare(v));
	        },
	
	        /**
	         * 向量长度平方
	         * @param {Vector2} v
	         * @return {number}
	         */
	        lenSquare: function (v) {
	            return v[0] * v[0] + v[1] * v[1];
	        },
	
	        /**
	         * 向量乘法
	         * @param {Vector2} out
	         * @param {Vector2} v1
	         * @param {Vector2} v2
	         */
	        mul: function (out, v1, v2) {
	            out[0] = v1[0] * v2[0];
	            out[1] = v1[1] * v2[1];
	            return out;
	        },
	
	        /**
	         * 向量除法
	         * @param {Vector2} out
	         * @param {Vector2} v1
	         * @param {Vector2} v2
	         */
	        div: function (out, v1, v2) {
	            out[0] = v1[0] / v2[0];
	            out[1] = v1[1] / v2[1];
	            return out;
	        },
	
	        /**
	         * 向量点乘
	         * @param {Vector2} v1
	         * @param {Vector2} v2
	         * @return {number}
	         */
	        dot: function (v1, v2) {
	            return v1[0] * v2[0] + v1[1] * v2[1];
	        },
	
	        /**
	         * 向量缩放
	         * @param {Vector2} out
	         * @param {Vector2} v
	         * @param {number} s
	         */
	        scale: function (out, v, s) {
	            out[0] = v[0] * s;
	            out[1] = v[1] * s;
	            return out;
	        },
	
	        /**
	         * 向量归一化
	         * @param {Vector2} out
	         * @param {Vector2} v
	         */
	        normalize: function (out, v) {
	            var d = vector.len(v);
	            if (d === 0) {
	                out[0] = 0;
	                out[1] = 0;
	            }
	            else {
	                out[0] = v[0] / d;
	                out[1] = v[1] / d;
	            }
	            return out;
	        },
	
	        /**
	         * 计算向量间距离
	         * @param {Vector2} v1
	         * @param {Vector2} v2
	         * @return {number}
	         */
	        distance: function (v1, v2) {
	            return Math.sqrt(
	                (v1[0] - v2[0]) * (v1[0] - v2[0])
	                + (v1[1] - v2[1]) * (v1[1] - v2[1])
	            );
	        },
	
	        /**
	         * 向量距离平方
	         * @param {Vector2} v1
	         * @param {Vector2} v2
	         * @return {number}
	         */
	        distanceSquare: function (v1, v2) {
	            return (v1[0] - v2[0]) * (v1[0] - v2[0])
	                + (v1[1] - v2[1]) * (v1[1] - v2[1]);
	        },
	
	        /**
	         * 求负向量
	         * @param {Vector2} out
	         * @param {Vector2} v
	         */
	        negate: function (out, v) {
	            out[0] = -v[0];
	            out[1] = -v[1];
	            return out;
	        },
	
	        /**
	         * 插值两个点
	         * @param {Vector2} out
	         * @param {Vector2} v1
	         * @param {Vector2} v2
	         * @param {number} t
	         */
	        lerp: function (out, v1, v2, t) {
	            out[0] = v1[0] + t * (v2[0] - v1[0]);
	            out[1] = v1[1] + t * (v2[1] - v1[1]);
	            return out;
	        },
	
	        /**
	         * 矩阵左乘向量
	         * @param {Vector2} out
	         * @param {Vector2} v
	         * @param {Vector2} m
	         */
	        applyTransform: function (out, v, m) {
	            var x = v[0];
	            var y = v[1];
	            out[0] = m[0] * x + m[2] * y + m[4];
	            out[1] = m[1] * x + m[3] * y + m[5];
	            return out;
	        },
	        /**
	         * 求两个向量最小值
	         * @param  {Vector2} out
	         * @param  {Vector2} v1
	         * @param  {Vector2} v2
	         */
	        min: function (out, v1, v2) {
	            out[0] = Math.min(v1[0], v2[0]);
	            out[1] = Math.min(v1[1], v2[1]);
	            return out;
	        },
	        /**
	         * 求两个向量最大值
	         * @param  {Vector2} out
	         * @param  {Vector2} v1
	         * @param  {Vector2} v2
	         */
	        max: function (out, v1, v2) {
	            out[0] = Math.max(v1[0], v2[0]);
	            out[1] = Math.max(v1[1], v2[1]);
	            return out;
	        }
	    };
	
	    vector.length = vector.len;
	    vector.lengthSquare = vector.lenSquare;
	    vector.dist = vector.distance;
	    vector.distSquare = vector.distanceSquare;
	
	    module.exports = vector;
	


/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	/**
	 * @module zrender/mixin/Animatable
	 */
	
	
	    var Animator = __webpack_require__(16);
	    var util = __webpack_require__(4);
	    var isString = util.isString;
	    var isFunction = util.isFunction;
	    var isObject = util.isObject;
	    var log = __webpack_require__(20);
	
	    /**
	     * @alias modue:zrender/mixin/Animatable
	     * @constructor
	     */
	    var Animatable = function () {
	
	        /**
	         * @type {Array.<module:zrender/animation/Animator>}
	         * @readOnly
	         */
	        this.animators = [];
	    };
	
	    Animatable.prototype = {
	
	        constructor: Animatable,
	
	        /**
	         * 动画
	         *
	         * @param {string} path 需要添加动画的属性获取路径，可以通过a.b.c来获取深层的属性
	         * @param {boolean} [loop] 动画是否循环
	         * @return {module:zrender/animation/Animator}
	         * @example:
	         *     el.animate('style', false)
	         *         .when(1000, {x: 10} )
	         *         .done(function(){ // Animation done })
	         *         .start()
	         */
	        animate: function (path, loop) {
	            var target;
	            var animatingShape = false;
	            var el = this;
	            var zr = this.__zr;
	            if (path) {
	                var pathSplitted = path.split('.');
	                var prop = el;
	                // If animating shape
	                animatingShape = pathSplitted[0] === 'shape';
	                for (var i = 0, l = pathSplitted.length; i < l; i++) {
	                    if (!prop) {
	                        continue;
	                    }
	                    prop = prop[pathSplitted[i]];
	                }
	                if (prop) {
	                    target = prop;
	                }
	            }
	            else {
	                target = el;
	            }
	
	            if (!target) {
	                log(
	                    'Property "'
	                    + path
	                    + '" is not existed in element '
	                    + el.id
	                );
	                return;
	            }
	
	            var animators = el.animators;
	
	            var animator = new Animator(target, loop);
	
	            animator.during(function (target) {
	                el.dirty(animatingShape);
	            })
	            .done(function () {
	                // FIXME Animator will not be removed if use `Animator#stop` to stop animation
	                animators.splice(util.indexOf(animators, animator), 1);
	            });
	
	            animators.push(animator);
	
	            // If animate after added to the zrender
	            if (zr) {
	                zr.animation.addAnimator(animator);
	            }
	
	            return animator;
	        },
	
	        /**
	         * 停止动画
	         * @param {boolean} forwardToLast If move to last frame before stop
	         */
	        stopAnimation: function (forwardToLast) {
	            var animators = this.animators;
	            var len = animators.length;
	            for (var i = 0; i < len; i++) {
	                animators[i].stop(forwardToLast);
	            }
	            animators.length = 0;
	
	            return this;
	        },
	
	        /**
	         * @param {Object} target
	         * @param {number} [time=500] Time in ms
	         * @param {string} [easing='linear']
	         * @param {number} [delay=0]
	         * @param {Function} [callback]
	         *
	         * @example
	         *  // Animate position
	         *  el.animateTo({
	         *      position: [10, 10]
	         *  }, function () { // done })
	         *
	         *  // Animate shape, style and position in 100ms, delayed 100ms, with cubicOut easing
	         *  el.animateTo({
	         *      shape: {
	         *          width: 500
	         *      },
	         *      style: {
	         *          fill: 'red'
	         *      }
	         *      position: [10, 10]
	         *  }, 100, 100, 'cubicOut', function () { // done })
	         */
	         // TODO Return animation key
	        animateTo: function (target, time, delay, easing, callback) {
	            // animateTo(target, time, easing, callback);
	            if (isString(delay)) {
	                callback = easing;
	                easing = delay;
	                delay = 0;
	            }
	            // animateTo(target, time, delay, callback);
	            else if (isFunction(easing)) {
	                callback = easing;
	                easing = 'linear';
	                delay = 0;
	            }
	            // animateTo(target, time, callback);
	            else if (isFunction(delay)) {
	                callback = delay;
	                delay = 0;
	            }
	            // animateTo(target, callback)
	            else if (isFunction(time)) {
	                callback = time;
	                time = 500;
	            }
	            // animateTo(target)
	            else if (!time) {
	                time = 500;
	            }
	            // Stop all previous animations
	            this.stopAnimation();
	            this._animateToShallow('', this, target, time, delay, easing, callback);
	
	            // Animators may be removed immediately after start
	            // if there is nothing to animate
	            var animators = this.animators.slice();
	            var count = animators.length;
	            function done() {
	                count--;
	                if (!count) {
	                    callback && callback();
	                }
	            }
	
	            // No animators. This should be checked before animators[i].start(),
	            // because 'done' may be executed immediately if no need to animate.
	            if (!count) {
	                callback && callback();
	            }
	            // Start after all animators created
	            // Incase any animator is done immediately when all animation properties are not changed
	            for (var i = 0; i < animators.length; i++) {
	                animators[i]
	                    .done(done)
	                    .start(easing);
	            }
	        },
	
	        /**
	         * @private
	         * @param {string} path=''
	         * @param {Object} source=this
	         * @param {Object} target
	         * @param {number} [time=500]
	         * @param {number} [delay=0]
	         *
	         * @example
	         *  // Animate position
	         *  el._animateToShallow({
	         *      position: [10, 10]
	         *  })
	         *
	         *  // Animate shape, style and position in 100ms, delayed 100ms
	         *  el._animateToShallow({
	         *      shape: {
	         *          width: 500
	         *      },
	         *      style: {
	         *          fill: 'red'
	         *      }
	         *      position: [10, 10]
	         *  }, 100, 100)
	         */
	        _animateToShallow: function (path, source, target, time, delay) {
	            var objShallow = {};
	            var propertyCount = 0;
	            for (var name in target) {
	                if (source[name] != null) {
	                    if (isObject(target[name]) && !util.isArrayLike(target[name])) {
	                        this._animateToShallow(
	                            path ? path + '.' + name : name,
	                            source[name],
	                            target[name],
	                            time,
	                            delay
	                        );
	                    }
	                    else {
	                        objShallow[name] = target[name];
	                        propertyCount++;
	                    }
	                }
	                else if (target[name] != null) {
	                    // Attr directly if not has property
	                    // FIXME, if some property not needed for element ?
	                    if (!path) {
	                        this.attr(name, target[name]);
	                    }
	                    else {  // Shape or style
	                        var props = {};
	                        props[path] = {};
	                        props[path][name] = target[name];
	                        this.attr(props);
	                    }
	                }
	            }
	
	            if (propertyCount > 0) {
	                this.animate(path, false)
	                    .when(time == null ? 500 : time, objShallow)
	                    .delay(delay || 0);
	            }
	
	            return this;
	        }
	    };
	
	    module.exports = Animatable;


/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @module echarts/animation/Animator
	 */
	
	
	    var Clip = __webpack_require__(17);
	    var color = __webpack_require__(19);
	    var util = __webpack_require__(4);
	    var isArrayLike = util.isArrayLike;
	
	    var arraySlice = Array.prototype.slice;
	
	    function defaultGetter(target, key) {
	        return target[key];
	    }
	
	    function defaultSetter(target, key, value) {
	        target[key] = value;
	    }
	
	    /**
	     * @param  {number} p0
	     * @param  {number} p1
	     * @param  {number} percent
	     * @return {number}
	     */
	    function interpolateNumber(p0, p1, percent) {
	        return (p1 - p0) * percent + p0;
	    }
	
	    /**
	     * @param  {string} p0
	     * @param  {string} p1
	     * @param  {number} percent
	     * @return {string}
	     */
	    function interpolateString(p0, p1, percent) {
	        return percent > 0.5 ? p1 : p0;
	    }
	
	    /**
	     * @param  {Array} p0
	     * @param  {Array} p1
	     * @param  {number} percent
	     * @param  {Array} out
	     * @param  {number} arrDim
	     */
	    function interpolateArray(p0, p1, percent, out, arrDim) {
	        var len = p0.length;
	        if (arrDim == 1) {
	            for (var i = 0; i < len; i++) {
	                out[i] = interpolateNumber(p0[i], p1[i], percent);
	            }
	        }
	        else {
	            var len2 = p0[0].length;
	            for (var i = 0; i < len; i++) {
	                for (var j = 0; j < len2; j++) {
	                    out[i][j] = interpolateNumber(
	                        p0[i][j], p1[i][j], percent
	                    );
	                }
	            }
	        }
	    }
	
	    // arr0 is source array, arr1 is target array.
	    // Do some preprocess to avoid error happened when interpolating from arr0 to arr1
	    function fillArr(arr0, arr1, arrDim) {
	        var arr0Len = arr0.length;
	        var arr1Len = arr1.length;
	        if (arr0Len !== arr1Len) {
	            // FIXME Not work for TypedArray
	            var isPreviousLarger = arr0Len > arr1Len;
	            if (isPreviousLarger) {
	                // Cut the previous
	                arr0.length = arr1Len;
	            }
	            else {
	                // Fill the previous
	                for (var i = arr0Len; i < arr1Len; i++) {
	                    arr0.push(
	                        arrDim === 1 ? arr1[i] : arraySlice.call(arr1[i])
	                    );
	                }
	            }
	        }
	        // Handling NaN value
	        var len2 = arr0[0] && arr0[0].length;
	        for (var i = 0; i < arr0.length; i++) {
	            if (arrDim === 1) {
	                if (isNaN(arr0[i])) {
	                    arr0[i] = arr1[i];
	                }
	            }
	            else {
	                for (var j = 0; j < len2; j++) {
	                    if (isNaN(arr0[i][j])) {
	                        arr0[i][j] = arr1[i][j];
	                    }
	                }
	            }
	        }
	    }
	
	    /**
	     * @param  {Array} arr0
	     * @param  {Array} arr1
	     * @param  {number} arrDim
	     * @return {boolean}
	     */
	    function isArraySame(arr0, arr1, arrDim) {
	        if (arr0 === arr1) {
	            return true;
	        }
	        var len = arr0.length;
	        if (len !== arr1.length) {
	            return false;
	        }
	        if (arrDim === 1) {
	            for (var i = 0; i < len; i++) {
	                if (arr0[i] !== arr1[i]) {
	                    return false;
	                }
	            }
	        }
	        else {
	            var len2 = arr0[0].length;
	            for (var i = 0; i < len; i++) {
	                for (var j = 0; j < len2; j++) {
	                    if (arr0[i][j] !== arr1[i][j]) {
	                        return false;
	                    }
	                }
	            }
	        }
	        return true;
	    }
	
	    /**
	     * Catmull Rom interpolate array
	     * @param  {Array} p0
	     * @param  {Array} p1
	     * @param  {Array} p2
	     * @param  {Array} p3
	     * @param  {number} t
	     * @param  {number} t2
	     * @param  {number} t3
	     * @param  {Array} out
	     * @param  {number} arrDim
	     */
	    function catmullRomInterpolateArray(
	        p0, p1, p2, p3, t, t2, t3, out, arrDim
	    ) {
	        var len = p0.length;
	        if (arrDim == 1) {
	            for (var i = 0; i < len; i++) {
	                out[i] = catmullRomInterpolate(
	                    p0[i], p1[i], p2[i], p3[i], t, t2, t3
	                );
	            }
	        }
	        else {
	            var len2 = p0[0].length;
	            for (var i = 0; i < len; i++) {
	                for (var j = 0; j < len2; j++) {
	                    out[i][j] = catmullRomInterpolate(
	                        p0[i][j], p1[i][j], p2[i][j], p3[i][j],
	                        t, t2, t3
	                    );
	                }
	            }
	        }
	    }
	
	    /**
	     * Catmull Rom interpolate number
	     * @param  {number} p0
	     * @param  {number} p1
	     * @param  {number} p2
	     * @param  {number} p3
	     * @param  {number} t
	     * @param  {number} t2
	     * @param  {number} t3
	     * @return {number}
	     */
	    function catmullRomInterpolate(p0, p1, p2, p3, t, t2, t3) {
	        var v0 = (p2 - p0) * 0.5;
	        var v1 = (p3 - p1) * 0.5;
	        return (2 * (p1 - p2) + v0 + v1) * t3
	                + (-3 * (p1 - p2) - 2 * v0 - v1) * t2
	                + v0 * t + p1;
	    }
	
	    function cloneValue(value) {
	        if (isArrayLike(value)) {
	            var len = value.length;
	            if (isArrayLike(value[0])) {
	                var ret = [];
	                for (var i = 0; i < len; i++) {
	                    ret.push(arraySlice.call(value[i]));
	                }
	                return ret;
	            }
	
	            return arraySlice.call(value);
	        }
	
	        return value;
	    }
	
	    function rgba2String(rgba) {
	        rgba[0] = Math.floor(rgba[0]);
	        rgba[1] = Math.floor(rgba[1]);
	        rgba[2] = Math.floor(rgba[2]);
	
	        return 'rgba(' + rgba.join(',') + ')';
	    }
	
	    function createTrackClip (animator, easing, oneTrackDone, keyframes, propName) {
	        var getter = animator._getter;
	        var setter = animator._setter;
	        var useSpline = easing === 'spline';
	
	        var trackLen = keyframes.length;
	        if (!trackLen) {
	            return;
	        }
	        // Guess data type
	        var firstVal = keyframes[0].value;
	        var isValueArray = isArrayLike(firstVal);
	        var isValueColor = false;
	        var isValueString = false;
	
	        // For vertices morphing
	        var arrDim = (
	                isValueArray
	                && isArrayLike(firstVal[0])
	            )
	            ? 2 : 1;
	        var trackMaxTime;
	        // Sort keyframe as ascending
	        keyframes.sort(function(a, b) {
	            return a.time - b.time;
	        });
	
	        trackMaxTime = keyframes[trackLen - 1].time;
	        // Percents of each keyframe
	        var kfPercents = [];
	        // Value of each keyframe
	        var kfValues = [];
	        var prevValue = keyframes[0].value;
	        var isAllValueEqual = true;
	        for (var i = 0; i < trackLen; i++) {
	            kfPercents.push(keyframes[i].time / trackMaxTime);
	            // Assume value is a color when it is a string
	            var value = keyframes[i].value;
	
	            // Check if value is equal, deep check if value is array
	            if (!((isValueArray && isArraySame(value, prevValue, arrDim))
	                || (!isValueArray && value === prevValue))) {
	                isAllValueEqual = false;
	            }
	            prevValue = value;
	
	            // Try converting a string to a color array
	            if (typeof value == 'string') {
	                var colorArray = color.parse(value);
	                if (colorArray) {
	                    value = colorArray;
	                    isValueColor = true;
	                }
	                else {
	                    isValueString = true;
	                }
	            }
	            kfValues.push(value);
	        }
	        if (isAllValueEqual) {
	            return;
	        }
	
	        var lastValue = kfValues[trackLen - 1];
	        // Polyfill array and NaN value
	        for (var i = 0; i < trackLen - 1; i++) {
	            if (isValueArray) {
	                fillArr(kfValues[i], lastValue, arrDim);
	            }
	            else {
	                if (isNaN(kfValues[i]) && !isNaN(lastValue) && !isValueString && !isValueColor) {
	                    kfValues[i] = lastValue;
	                }
	            }
	        }
	        isValueArray && fillArr(getter(animator._target, propName), lastValue, arrDim);
	
	        // Cache the key of last frame to speed up when
	        // animation playback is sequency
	        var lastFrame = 0;
	        var lastFramePercent = 0;
	        var start;
	        var w;
	        var p0;
	        var p1;
	        var p2;
	        var p3;
	
	        if (isValueColor) {
	            var rgba = [0, 0, 0, 0];
	        }
	
	        var onframe = function (target, percent) {
	            // Find the range keyframes
	            // kf1-----kf2---------current--------kf3
	            // find kf2 and kf3 and do interpolation
	            var frame;
	            // In the easing function like elasticOut, percent may less than 0
	            if (percent < 0) {
	                frame = 0;
	            }
	            else if (percent < lastFramePercent) {
	                // Start from next key
	                // PENDING start from lastFrame ?
	                start = Math.min(lastFrame + 1, trackLen - 1);
	                for (frame = start; frame >= 0; frame--) {
	                    if (kfPercents[frame] <= percent) {
	                        break;
	                    }
	                }
	                // PENDING really need to do this ?
	                frame = Math.min(frame, trackLen - 2);
	            }
	            else {
	                for (frame = lastFrame; frame < trackLen; frame++) {
	                    if (kfPercents[frame] > percent) {
	                        break;
	                    }
	                }
	                frame = Math.min(frame - 1, trackLen - 2);
	            }
	            lastFrame = frame;
	            lastFramePercent = percent;
	
	            var range = (kfPercents[frame + 1] - kfPercents[frame]);
	            if (range === 0) {
	                return;
	            }
	            else {
	                w = (percent - kfPercents[frame]) / range;
	            }
	            if (useSpline) {
	                p1 = kfValues[frame];
	                p0 = kfValues[frame === 0 ? frame : frame - 1];
	                p2 = kfValues[frame > trackLen - 2 ? trackLen - 1 : frame + 1];
	                p3 = kfValues[frame > trackLen - 3 ? trackLen - 1 : frame + 2];
	                if (isValueArray) {
	                    catmullRomInterpolateArray(
	                        p0, p1, p2, p3, w, w * w, w * w * w,
	                        getter(target, propName),
	                        arrDim
	                    );
	                }
	                else {
	                    var value;
	                    if (isValueColor) {
	                        value = catmullRomInterpolateArray(
	                            p0, p1, p2, p3, w, w * w, w * w * w,
	                            rgba, 1
	                        );
	                        value = rgba2String(rgba);
	                    }
	                    else if (isValueString) {
	                        // String is step(0.5)
	                        return interpolateString(p1, p2, w);
	                    }
	                    else {
	                        value = catmullRomInterpolate(
	                            p0, p1, p2, p3, w, w * w, w * w * w
	                        );
	                    }
	                    setter(
	                        target,
	                        propName,
	                        value
	                    );
	                }
	            }
	            else {
	                if (isValueArray) {
	                    interpolateArray(
	                        kfValues[frame], kfValues[frame + 1], w,
	                        getter(target, propName),
	                        arrDim
	                    );
	                }
	                else {
	                    var value;
	                    if (isValueColor) {
	                        interpolateArray(
	                            kfValues[frame], kfValues[frame + 1], w,
	                            rgba, 1
	                        );
	                        value = rgba2String(rgba);
	                    }
	                    else if (isValueString) {
	                        // String is step(0.5)
	                        return interpolateString(kfValues[frame], kfValues[frame + 1], w);
	                    }
	                    else {
	                        value = interpolateNumber(kfValues[frame], kfValues[frame + 1], w);
	                    }
	                    setter(
	                        target,
	                        propName,
	                        value
	                    );
	                }
	            }
	        };
	
	        var clip = new Clip({
	            target: animator._target,
	            life: trackMaxTime,
	            loop: animator._loop,
	            delay: animator._delay,
	            onframe: onframe,
	            ondestroy: oneTrackDone
	        });
	
	        if (easing && easing !== 'spline') {
	            clip.easing = easing;
	        }
	
	        return clip;
	    }
	
	    /**
	     * @alias module:zrender/animation/Animator
	     * @constructor
	     * @param {Object} target
	     * @param {boolean} loop
	     * @param {Function} getter
	     * @param {Function} setter
	     */
	    var Animator = function(target, loop, getter, setter) {
	        this._tracks = {};
	        this._target = target;
	
	        this._loop = loop || false;
	
	        this._getter = getter || defaultGetter;
	        this._setter = setter || defaultSetter;
	
	        this._clipCount = 0;
	
	        this._delay = 0;
	
	        this._doneList = [];
	
	        this._onframeList = [];
	
	        this._clipList = [];
	    };
	
	    Animator.prototype = {
	        /**
	         * 设置动画关键帧
	         * @param  {number} time 关键帧时间，单位是ms
	         * @param  {Object} props 关键帧的属性值，key-value表示
	         * @return {module:zrender/animation/Animator}
	         */
	        when: function(time /* ms */, props) {
	            var tracks = this._tracks;
	            for (var propName in props) {
	                if (!tracks[propName]) {
	                    tracks[propName] = [];
	                    // Invalid value
	                    var value = this._getter(this._target, propName);
	                    if (value == null) {
	                        // zrLog('Invalid property ' + propName);
	                        continue;
	                    }
	                    // If time is 0
	                    //  Then props is given initialize value
	                    // Else
	                    //  Initialize value from current prop value
	                    if (time !== 0) {
	                        tracks[propName].push({
	                            time: 0,
	                            value: cloneValue(value)
	                        });
	                    }
	                }
	                tracks[propName].push({
	                    time: time,
	                    value: props[propName]
	                });
	            }
	            return this;
	        },
	        /**
	         * 添加动画每一帧的回调函数
	         * @param  {Function} callback
	         * @return {module:zrender/animation/Animator}
	         */
	        during: function (callback) {
	            this._onframeList.push(callback);
	            return this;
	        },
	
	        _doneCallback: function () {
	            // Clear all tracks
	            this._tracks = {};
	            // Clear all clips
	            this._clipList.length = 0;
	
	            var doneList = this._doneList;
	            var len = doneList.length;
	            for (var i = 0; i < len; i++) {
	                doneList[i].call(this);
	            }
	        },
	        /**
	         * 开始执行动画
	         * @param  {string|Function} easing
	         *         动画缓动函数，详见{@link module:zrender/animation/easing}
	         * @return {module:zrender/animation/Animator}
	         */
	        start: function (easing) {
	
	            var self = this;
	            var clipCount = 0;
	
	            var oneTrackDone = function() {
	                clipCount--;
	                if (!clipCount) {
	                    self._doneCallback();
	                }
	            };
	
	            var lastClip;
	            for (var propName in this._tracks) {
	                var clip = createTrackClip(
	                    this, easing, oneTrackDone,
	                    this._tracks[propName], propName
	                );
	                if (clip) {
	                    this._clipList.push(clip);
	                    clipCount++;
	
	                    // If start after added to animation
	                    if (this.animation) {
	                        this.animation.addClip(clip);
	                    }
	
	                    lastClip = clip;
	                }
	            }
	
	            // Add during callback on the last clip
	            if (lastClip) {
	                var oldOnFrame = lastClip.onframe;
	                lastClip.onframe = function (target, percent) {
	                    oldOnFrame(target, percent);
	
	                    for (var i = 0; i < self._onframeList.length; i++) {
	                        self._onframeList[i](target, percent);
	                    }
	                };
	            }
	
	            if (!clipCount) {
	                this._doneCallback();
	            }
	            return this;
	        },
	        /**
	         * 停止动画
	         * @param {boolean} forwardToLast If move to last frame before stop
	         */
	        stop: function (forwardToLast) {
	            var clipList = this._clipList;
	            var animation = this.animation;
	            for (var i = 0; i < clipList.length; i++) {
	                var clip = clipList[i];
	                if (forwardToLast) {
	                    // Move to last frame before stop
	                    clip.onframe(this._target, 1);
	                }
	                animation && animation.removeClip(clip);
	            }
	            clipList.length = 0;
	        },
	        /**
	         * 设置动画延迟开始的时间
	         * @param  {number} time 单位ms
	         * @return {module:zrender/animation/Animator}
	         */
	        delay: function (time) {
	            this._delay = time;
	            return this;
	        },
	        /**
	         * 添加动画结束的回调
	         * @param  {Function} cb
	         * @return {module:zrender/animation/Animator}
	         */
	        done: function(cb) {
	            if (cb) {
	                this._doneList.push(cb);
	            }
	            return this;
	        },
	
	        /**
	         * @return {Array.<module:zrender/animation/Clip>}
	         */
	        getClips: function () {
	            return this._clipList;
	        }
	    };
	
	    module.exports = Animator;


/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * 动画主控制器
	 * @config target 动画对象，可以是数组，如果是数组的话会批量分发onframe等事件
	 * @config life(1000) 动画时长
	 * @config delay(0) 动画延迟时间
	 * @config loop(true)
	 * @config gap(0) 循环的间隔时间
	 * @config onframe
	 * @config easing(optional)
	 * @config ondestroy(optional)
	 * @config onrestart(optional)
	 *
	 * TODO pause
	 */
	
	
	    var easingFuncs = __webpack_require__(18);
	
	    function Clip(options) {
	
	        this._target = options.target;
	
	        // 生命周期
	        this._life = options.life || 1000;
	        // 延时
	        this._delay = options.delay || 0;
	        // 开始时间
	        // this._startTime = new Date().getTime() + this._delay;// 单位毫秒
	        this._initialized = false;
	
	        // 是否循环
	        this.loop = options.loop == null ? false : options.loop;
	
	        this.gap = options.gap || 0;
	
	        this.easing = options.easing || 'Linear';
	
	        this.onframe = options.onframe;
	        this.ondestroy = options.ondestroy;
	        this.onrestart = options.onrestart;
	    }
	
	    Clip.prototype = {
	
	        constructor: Clip,
	
	        step: function (globalTime) {
	            // Set startTime on first step, or _startTime may has milleseconds different between clips
	            // PENDING
	            if (!this._initialized) {
	                this._startTime = globalTime + this._delay;
	                this._initialized = true;
	            }
	
	            var percent = (globalTime - this._startTime) / this._life;
	
	            // 还没开始
	            if (percent < 0) {
	                return;
	            }
	
	            percent = Math.min(percent, 1);
	
	            var easing = this.easing;
	            var easingFunc = typeof easing == 'string' ? easingFuncs[easing] : easing;
	            var schedule = typeof easingFunc === 'function'
	                ? easingFunc(percent)
	                : percent;
	
	            this.fire('frame', schedule);
	
	            // 结束
	            if (percent == 1) {
	                if (this.loop) {
	                    this.restart (globalTime);
	                    // 重新开始周期
	                    // 抛出而不是直接调用事件直到 stage.update 后再统一调用这些事件
	                    return 'restart';
	                }
	
	                // 动画完成将这个控制器标识为待删除
	                // 在Animation.update中进行批量删除
	                this._needsRemove = true;
	                return 'destroy';
	            }
	
	            return null;
	        },
	
	        restart: function (globalTime) {
	            var remainder = (globalTime - this._startTime) % this._life;
	            this._startTime = globalTime - remainder + this.gap;
	
	            this._needsRemove = false;
	        },
	
	        fire: function(eventType, arg) {
	            eventType = 'on' + eventType;
	            if (this[eventType]) {
	                this[eventType](this._target, arg);
	            }
	        }
	    };
	
	    module.exports = Clip;
	


/***/ },
/* 18 */
/***/ function(module, exports) {

	/**
	 * 缓动代码来自 https://github.com/sole/tween.js/blob/master/src/Tween.js
	 * @see http://sole.github.io/tween.js/examples/03_graphs.html
	 * @exports zrender/animation/easing
	 */
	
	    var easing = {
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        linear: function (k) {
	            return k;
	        },
	
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        quadraticIn: function (k) {
	            return k * k;
	        },
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        quadraticOut: function (k) {
	            return k * (2 - k);
	        },
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        quadraticInOut: function (k) {
	            if ((k *= 2) < 1) {
	                return 0.5 * k * k;
	            }
	            return -0.5 * (--k * (k - 2) - 1);
	        },
	
	        // 三次方的缓动（t^3）
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        cubicIn: function (k) {
	            return k * k * k;
	        },
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        cubicOut: function (k) {
	            return --k * k * k + 1;
	        },
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        cubicInOut: function (k) {
	            if ((k *= 2) < 1) {
	                return 0.5 * k * k * k;
	            }
	            return 0.5 * ((k -= 2) * k * k + 2);
	        },
	
	        // 四次方的缓动（t^4）
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        quarticIn: function (k) {
	            return k * k * k * k;
	        },
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        quarticOut: function (k) {
	            return 1 - (--k * k * k * k);
	        },
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        quarticInOut: function (k) {
	            if ((k *= 2) < 1) {
	                return 0.5 * k * k * k * k;
	            }
	            return -0.5 * ((k -= 2) * k * k * k - 2);
	        },
	
	        // 五次方的缓动（t^5）
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        quinticIn: function (k) {
	            return k * k * k * k * k;
	        },
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        quinticOut: function (k) {
	            return --k * k * k * k * k + 1;
	        },
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        quinticInOut: function (k) {
	            if ((k *= 2) < 1) {
	                return 0.5 * k * k * k * k * k;
	            }
	            return 0.5 * ((k -= 2) * k * k * k * k + 2);
	        },
	
	        // 正弦曲线的缓动（sin(t)）
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        sinusoidalIn: function (k) {
	            return 1 - Math.cos(k * Math.PI / 2);
	        },
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        sinusoidalOut: function (k) {
	            return Math.sin(k * Math.PI / 2);
	        },
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        sinusoidalInOut: function (k) {
	            return 0.5 * (1 - Math.cos(Math.PI * k));
	        },
	
	        // 指数曲线的缓动（2^t）
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        exponentialIn: function (k) {
	            return k === 0 ? 0 : Math.pow(1024, k - 1);
	        },
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        exponentialOut: function (k) {
	            return k === 1 ? 1 : 1 - Math.pow(2, -10 * k);
	        },
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        exponentialInOut: function (k) {
	            if (k === 0) {
	                return 0;
	            }
	            if (k === 1) {
	                return 1;
	            }
	            if ((k *= 2) < 1) {
	                return 0.5 * Math.pow(1024, k - 1);
	            }
	            return 0.5 * (-Math.pow(2, -10 * (k - 1)) + 2);
	        },
	
	        // 圆形曲线的缓动（sqrt(1-t^2)）
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        circularIn: function (k) {
	            return 1 - Math.sqrt(1 - k * k);
	        },
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        circularOut: function (k) {
	            return Math.sqrt(1 - (--k * k));
	        },
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        circularInOut: function (k) {
	            if ((k *= 2) < 1) {
	                return -0.5 * (Math.sqrt(1 - k * k) - 1);
	            }
	            return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);
	        },
	
	        // 创建类似于弹簧在停止前来回振荡的动画
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        elasticIn: function (k) {
	            var s;
	            var a = 0.1;
	            var p = 0.4;
	            if (k === 0) {
	                return 0;
	            }
	            if (k === 1) {
	                return 1;
	            }
	            if (!a || a < 1) {
	                a = 1; s = p / 4;
	            }
	            else {
	                s = p * Math.asin(1 / a) / (2 * Math.PI);
	            }
	            return -(a * Math.pow(2, 10 * (k -= 1)) *
	                        Math.sin((k - s) * (2 * Math.PI) / p));
	        },
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        elasticOut: function (k) {
	            var s;
	            var a = 0.1;
	            var p = 0.4;
	            if (k === 0) {
	                return 0;
	            }
	            if (k === 1) {
	                return 1;
	            }
	            if (!a || a < 1) {
	                a = 1; s = p / 4;
	            }
	            else {
	                s = p * Math.asin(1 / a) / (2 * Math.PI);
	            }
	            return (a * Math.pow(2, -10 * k) *
	                    Math.sin((k - s) * (2 * Math.PI) / p) + 1);
	        },
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        elasticInOut: function (k) {
	            var s;
	            var a = 0.1;
	            var p = 0.4;
	            if (k === 0) {
	                return 0;
	            }
	            if (k === 1) {
	                return 1;
	            }
	            if (!a || a < 1) {
	                a = 1; s = p / 4;
	            }
	            else {
	                s = p * Math.asin(1 / a) / (2 * Math.PI);
	            }
	            if ((k *= 2) < 1) {
	                return -0.5 * (a * Math.pow(2, 10 * (k -= 1))
	                    * Math.sin((k - s) * (2 * Math.PI) / p));
	            }
	            return a * Math.pow(2, -10 * (k -= 1))
	                    * Math.sin((k - s) * (2 * Math.PI) / p) * 0.5 + 1;
	
	        },
	
	        // 在某一动画开始沿指示的路径进行动画处理前稍稍收回该动画的移动
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        backIn: function (k) {
	            var s = 1.70158;
	            return k * k * ((s + 1) * k - s);
	        },
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        backOut: function (k) {
	            var s = 1.70158;
	            return --k * k * ((s + 1) * k + s) + 1;
	        },
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        backInOut: function (k) {
	            var s = 1.70158 * 1.525;
	            if ((k *= 2) < 1) {
	                return 0.5 * (k * k * ((s + 1) * k - s));
	            }
	            return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);
	        },
	
	        // 创建弹跳效果
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        bounceIn: function (k) {
	            return 1 - easing.bounceOut(1 - k);
	        },
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        bounceOut: function (k) {
	            if (k < (1 / 2.75)) {
	                return 7.5625 * k * k;
	            }
	            else if (k < (2 / 2.75)) {
	                return 7.5625 * (k -= (1.5 / 2.75)) * k + 0.75;
	            }
	            else if (k < (2.5 / 2.75)) {
	                return 7.5625 * (k -= (2.25 / 2.75)) * k + 0.9375;
	            }
	            else {
	                return 7.5625 * (k -= (2.625 / 2.75)) * k + 0.984375;
	            }
	        },
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        bounceInOut: function (k) {
	            if (k < 0.5) {
	                return easing.bounceIn(k * 2) * 0.5;
	            }
	            return easing.bounceOut(k * 2 - 1) * 0.5 + 0.5;
	        }
	    };
	
	    module.exports = easing;
	
	


/***/ },
/* 19 */
/***/ function(module, exports) {

	/**
	 * @module zrender/tool/color
	 */
	
	
	    var kCSSColorTable = {
	        'transparent': [0,0,0,0], 'aliceblue': [240,248,255,1],
	        'antiquewhite': [250,235,215,1], 'aqua': [0,255,255,1],
	        'aquamarine': [127,255,212,1], 'azure': [240,255,255,1],
	        'beige': [245,245,220,1], 'bisque': [255,228,196,1],
	        'black': [0,0,0,1], 'blanchedalmond': [255,235,205,1],
	        'blue': [0,0,255,1], 'blueviolet': [138,43,226,1],
	        'brown': [165,42,42,1], 'burlywood': [222,184,135,1],
	        'cadetblue': [95,158,160,1], 'chartreuse': [127,255,0,1],
	        'chocolate': [210,105,30,1], 'coral': [255,127,80,1],
	        'cornflowerblue': [100,149,237,1], 'cornsilk': [255,248,220,1],
	        'crimson': [220,20,60,1], 'cyan': [0,255,255,1],
	        'darkblue': [0,0,139,1], 'darkcyan': [0,139,139,1],
	        'darkgoldenrod': [184,134,11,1], 'darkgray': [169,169,169,1],
	        'darkgreen': [0,100,0,1], 'darkgrey': [169,169,169,1],
	        'darkkhaki': [189,183,107,1], 'darkmagenta': [139,0,139,1],
	        'darkolivegreen': [85,107,47,1], 'darkorange': [255,140,0,1],
	        'darkorchid': [153,50,204,1], 'darkred': [139,0,0,1],
	        'darksalmon': [233,150,122,1], 'darkseagreen': [143,188,143,1],
	        'darkslateblue': [72,61,139,1], 'darkslategray': [47,79,79,1],
	        'darkslategrey': [47,79,79,1], 'darkturquoise': [0,206,209,1],
	        'darkviolet': [148,0,211,1], 'deeppink': [255,20,147,1],
	        'deepskyblue': [0,191,255,1], 'dimgray': [105,105,105,1],
	        'dimgrey': [105,105,105,1], 'dodgerblue': [30,144,255,1],
	        'firebrick': [178,34,34,1], 'floralwhite': [255,250,240,1],
	        'forestgreen': [34,139,34,1], 'fuchsia': [255,0,255,1],
	        'gainsboro': [220,220,220,1], 'ghostwhite': [248,248,255,1],
	        'gold': [255,215,0,1], 'goldenrod': [218,165,32,1],
	        'gray': [128,128,128,1], 'green': [0,128,0,1],
	        'greenyellow': [173,255,47,1], 'grey': [128,128,128,1],
	        'honeydew': [240,255,240,1], 'hotpink': [255,105,180,1],
	        'indianred': [205,92,92,1], 'indigo': [75,0,130,1],
	        'ivory': [255,255,240,1], 'khaki': [240,230,140,1],
	        'lavender': [230,230,250,1], 'lavenderblush': [255,240,245,1],
	        'lawngreen': [124,252,0,1], 'lemonchiffon': [255,250,205,1],
	        'lightblue': [173,216,230,1], 'lightcoral': [240,128,128,1],
	        'lightcyan': [224,255,255,1], 'lightgoldenrodyellow': [250,250,210,1],
	        'lightgray': [211,211,211,1], 'lightgreen': [144,238,144,1],
	        'lightgrey': [211,211,211,1], 'lightpink': [255,182,193,1],
	        'lightsalmon': [255,160,122,1], 'lightseagreen': [32,178,170,1],
	        'lightskyblue': [135,206,250,1], 'lightslategray': [119,136,153,1],
	        'lightslategrey': [119,136,153,1], 'lightsteelblue': [176,196,222,1],
	        'lightyellow': [255,255,224,1], 'lime': [0,255,0,1],
	        'limegreen': [50,205,50,1], 'linen': [250,240,230,1],
	        'magenta': [255,0,255,1], 'maroon': [128,0,0,1],
	        'mediumaquamarine': [102,205,170,1], 'mediumblue': [0,0,205,1],
	        'mediumorchid': [186,85,211,1], 'mediumpurple': [147,112,219,1],
	        'mediumseagreen': [60,179,113,1], 'mediumslateblue': [123,104,238,1],
	        'mediumspringgreen': [0,250,154,1], 'mediumturquoise': [72,209,204,1],
	        'mediumvioletred': [199,21,133,1], 'midnightblue': [25,25,112,1],
	        'mintcream': [245,255,250,1], 'mistyrose': [255,228,225,1],
	        'moccasin': [255,228,181,1], 'navajowhite': [255,222,173,1],
	        'navy': [0,0,128,1], 'oldlace': [253,245,230,1],
	        'olive': [128,128,0,1], 'olivedrab': [107,142,35,1],
	        'orange': [255,165,0,1], 'orangered': [255,69,0,1],
	        'orchid': [218,112,214,1], 'palegoldenrod': [238,232,170,1],
	        'palegreen': [152,251,152,1], 'paleturquoise': [175,238,238,1],
	        'palevioletred': [219,112,147,1], 'papayawhip': [255,239,213,1],
	        'peachpuff': [255,218,185,1], 'peru': [205,133,63,1],
	        'pink': [255,192,203,1], 'plum': [221,160,221,1],
	        'powderblue': [176,224,230,1], 'purple': [128,0,128,1],
	        'red': [255,0,0,1], 'rosybrown': [188,143,143,1],
	        'royalblue': [65,105,225,1], 'saddlebrown': [139,69,19,1],
	        'salmon': [250,128,114,1], 'sandybrown': [244,164,96,1],
	        'seagreen': [46,139,87,1], 'seashell': [255,245,238,1],
	        'sienna': [160,82,45,1], 'silver': [192,192,192,1],
	        'skyblue': [135,206,235,1], 'slateblue': [106,90,205,1],
	        'slategray': [112,128,144,1], 'slategrey': [112,128,144,1],
	        'snow': [255,250,250,1], 'springgreen': [0,255,127,1],
	        'steelblue': [70,130,180,1], 'tan': [210,180,140,1],
	        'teal': [0,128,128,1], 'thistle': [216,191,216,1],
	        'tomato': [255,99,71,1], 'turquoise': [64,224,208,1],
	        'violet': [238,130,238,1], 'wheat': [245,222,179,1],
	        'white': [255,255,255,1], 'whitesmoke': [245,245,245,1],
	        'yellow': [255,255,0,1], 'yellowgreen': [154,205,50,1]
	    };
	
	    function clampCssByte(i) {  // Clamp to integer 0 .. 255.
	        i = Math.round(i);  // Seems to be what Chrome does (vs truncation).
	        return i < 0 ? 0 : i > 255 ? 255 : i;
	    }
	
	    function clampCssAngle(i) {  // Clamp to integer 0 .. 360.
	        i = Math.round(i);  // Seems to be what Chrome does (vs truncation).
	        return i < 0 ? 0 : i > 360 ? 360 : i;
	    }
	
	    function clampCssFloat(f) {  // Clamp to float 0.0 .. 1.0.
	        return f < 0 ? 0 : f > 1 ? 1 : f;
	    }
	
	    function parseCssInt(str) {  // int or percentage.
	        if (str.length && str.charAt(str.length - 1) === '%') {
	            return clampCssByte(parseFloat(str) / 100 * 255);
	        }
	        return clampCssByte(parseInt(str, 10));
	    }
	
	    function parseCssFloat(str) {  // float or percentage.
	        if (str.length && str.charAt(str.length - 1) === '%') {
	            return clampCssFloat(parseFloat(str) / 100);
	        }
	        return clampCssFloat(parseFloat(str));
	    }
	
	    function cssHueToRgb(m1, m2, h) {
	        if (h < 0) {
	            h += 1;
	        }
	        else if (h > 1) {
	            h -= 1;
	        }
	
	        if (h * 6 < 1) {
	            return m1 + (m2 - m1) * h * 6;
	        }
	        if (h * 2 < 1) {
	            return m2;
	        }
	        if (h * 3 < 2) {
	            return m1 + (m2 - m1) * (2/3 - h) * 6;
	        }
	        return m1;
	    }
	
	    function lerp(a, b, p) {
	        return a + (b - a) * p;
	    }
	
	    /**
	     * @param {string} colorStr
	     * @return {Array.<number>}
	     * @memberOf module:zrender/util/color
	     */
	    function parse(colorStr) {
	        if (!colorStr) {
	            return;
	        }
	        // colorStr may be not string
	        colorStr = colorStr + '';
	        // Remove all whitespace, not compliant, but should just be more accepting.
	        var str = colorStr.replace(/ /g, '').toLowerCase();
	
	        // Color keywords (and transparent) lookup.
	        if (str in kCSSColorTable) {
	            return kCSSColorTable[str].slice();  // dup.
	        }
	
	        // #abc and #abc123 syntax.
	        if (str.charAt(0) === '#') {
	            if (str.length === 4) {
	                var iv = parseInt(str.substr(1), 16);  // TODO(deanm): Stricter parsing.
	                if (!(iv >= 0 && iv <= 0xfff)) {
	                    return;  // Covers NaN.
	                }
	                return [
	                    ((iv & 0xf00) >> 4) | ((iv & 0xf00) >> 8),
	                    (iv & 0xf0) | ((iv & 0xf0) >> 4),
	                    (iv & 0xf) | ((iv & 0xf) << 4),
	                    1
	                ];
	            }
	            else if (str.length === 7) {
	                var iv = parseInt(str.substr(1), 16);  // TODO(deanm): Stricter parsing.
	                if (!(iv >= 0 && iv <= 0xffffff)) {
	                    return;  // Covers NaN.
	                }
	                return [
	                    (iv & 0xff0000) >> 16,
	                    (iv & 0xff00) >> 8,
	                    iv & 0xff,
	                    1
	                ];
	            }
	
	            return;
	        }
	        var op = str.indexOf('('), ep = str.indexOf(')');
	        if (op !== -1 && ep + 1 === str.length) {
	            var fname = str.substr(0, op);
	            var params = str.substr(op + 1, ep - (op + 1)).split(',');
	            var alpha = 1;  // To allow case fallthrough.
	            switch (fname) {
	                case 'rgba':
	                    if (params.length !== 4) {
	                        return;
	                    }
	                    alpha = parseCssFloat(params.pop()); // jshint ignore:line
	                // Fall through.
	                case 'rgb':
	                    if (params.length !== 3) {
	                        return;
	                    }
	                    return [
	                        parseCssInt(params[0]),
	                        parseCssInt(params[1]),
	                        parseCssInt(params[2]),
	                        alpha
	                    ];
	                case 'hsla':
	                    if (params.length !== 4) {
	                        return;
	                    }
	                    params[3] = parseCssFloat(params[3]);
	                    return hsla2rgba(params);
	                case 'hsl':
	                    if (params.length !== 3) {
	                        return;
	                    }
	                    return hsla2rgba(params);
	                default:
	                    return;
	            }
	        }
	
	        return;
	    }
	
	    /**
	     * @param {Array.<number>} hsla
	     * @return {Array.<number>} rgba
	     */
	    function hsla2rgba(hsla) {
	        var h = (((parseFloat(hsla[0]) % 360) + 360) % 360) / 360;  // 0 .. 1
	        // NOTE(deanm): According to the CSS spec s/l should only be
	        // percentages, but we don't bother and let float or percentage.
	        var s = parseCssFloat(hsla[1]);
	        var l = parseCssFloat(hsla[2]);
	        var m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;
	        var m1 = l * 2 - m2;
	
	        var rgba = [
	            clampCssByte(cssHueToRgb(m1, m2, h + 1 / 3) * 255),
	            clampCssByte(cssHueToRgb(m1, m2, h) * 255),
	            clampCssByte(cssHueToRgb(m1, m2, h - 1 / 3) * 255)
	        ];
	
	        if (hsla.length === 4) {
	            rgba[3] = hsla[3];
	        }
	
	        return rgba;
	    }
	
	    /**
	     * @param {Array.<number>} rgba
	     * @return {Array.<number>} hsla
	     */
	    function rgba2hsla(rgba) {
	        if (!rgba) {
	            return;
	        }
	
	        // RGB from 0 to 255
	        var R = rgba[0] / 255;
	        var G = rgba[1] / 255;
	        var B = rgba[2] / 255;
	
	        var vMin = Math.min(R, G, B); // Min. value of RGB
	        var vMax = Math.max(R, G, B); // Max. value of RGB
	        var delta = vMax - vMin; // Delta RGB value
	
	        var L = (vMax + vMin) / 2;
	        var H;
	        var S;
	        // HSL results from 0 to 1
	        if (delta === 0) {
	            H = 0;
	            S = 0;
	        }
	        else {
	            if (L < 0.5) {
	                S = delta / (vMax + vMin);
	            }
	            else {
	                S = delta / (2 - vMax - vMin);
	            }
	
	            var deltaR = (((vMax - R) / 6) + (delta / 2)) / delta;
	            var deltaG = (((vMax - G) / 6) + (delta / 2)) / delta;
	            var deltaB = (((vMax - B) / 6) + (delta / 2)) / delta;
	
	            if (R === vMax) {
	                H = deltaB - deltaG;
	            }
	            else if (G === vMax) {
	                H = (1 / 3) + deltaR - deltaB;
	            }
	            else if (B === vMax) {
	                H = (2 / 3) + deltaG - deltaR;
	            }
	
	            if (H < 0) {
	                H += 1;
	            }
	
	            if (H > 1) {
	                H -= 1;
	            }
	        }
	
	        var hsla = [H * 360, S, L];
	
	        if (rgba[3] != null) {
	            hsla.push(rgba[3]);
	        }
	
	        return hsla;
	    }
	
	    /**
	     * @param {string} color
	     * @param {number} level
	     * @return {string}
	     * @memberOf module:zrender/util/color
	     */
	    function lift(color, level) {
	        var colorArr = parse(color);
	        if (colorArr) {
	            for (var i = 0; i < 3; i++) {
	                if (level < 0) {
	                    colorArr[i] = colorArr[i] * (1 - level) | 0;
	                }
	                else {
	                    colorArr[i] = ((255 - colorArr[i]) * level + colorArr[i]) | 0;
	                }
	            }
	            return stringify(colorArr, colorArr.length === 4 ? 'rgba' : 'rgb');
	        }
	    }
	
	    /**
	     * @param {string} color
	     * @return {string}
	     * @memberOf module:zrender/util/color
	     */
	    function toHex(color, level) {
	        var colorArr = parse(color);
	        if (colorArr) {
	            return ((1 << 24) + (colorArr[0] << 16) + (colorArr[1] << 8) + (+colorArr[2])).toString(16).slice(1);
	        }
	    }
	
	    /**
	     * Map value to color. Faster than mapToColor methods because color is represented by rgba array
	     * @param {number} normalizedValue A float between 0 and 1.
	     * @param {Array.<Array.<number>>} colors List of rgba color array
	     * @param {Array.<number>} [out] Mapped gba color array
	     * @return {Array.<number>}
	     */
	    function fastMapToColor(normalizedValue, colors, out) {
	        if (!(colors && colors.length)
	            || !(normalizedValue >= 0 && normalizedValue <= 1)
	        ) {
	            return;
	        }
	        out = out || [0, 0, 0, 0];
	        var value = normalizedValue * (colors.length - 1);
	        var leftIndex = Math.floor(value);
	        var rightIndex = Math.ceil(value);
	        var leftColor = colors[leftIndex];
	        var rightColor = colors[rightIndex];
	        var dv = value - leftIndex;
	        out[0] = clampCssByte(lerp(leftColor[0], rightColor[0], dv));
	        out[1] = clampCssByte(lerp(leftColor[1], rightColor[1], dv));
	        out[2] = clampCssByte(lerp(leftColor[2], rightColor[2], dv));
	        out[3] = clampCssByte(lerp(leftColor[3], rightColor[3], dv));
	        return out;
	    }
	    /**
	     * @param {number} normalizedValue A float between 0 and 1.
	     * @param {Array.<string>} colors Color list.
	     * @param {boolean=} fullOutput Default false.
	     * @return {(string|Object)} Result color. If fullOutput,
	     *                           return {color: ..., leftIndex: ..., rightIndex: ..., value: ...},
	     * @memberOf module:zrender/util/color
	     */
	    function mapToColor(normalizedValue, colors, fullOutput) {
	        if (!(colors && colors.length)
	            || !(normalizedValue >= 0 && normalizedValue <= 1)
	        ) {
	            return;
	        }
	
	        var value = normalizedValue * (colors.length - 1);
	        var leftIndex = Math.floor(value);
	        var rightIndex = Math.ceil(value);
	        var leftColor = parse(colors[leftIndex]);
	        var rightColor = parse(colors[rightIndex]);
	        var dv = value - leftIndex;
	
	        var color = stringify(
	            [
	                clampCssByte(lerp(leftColor[0], rightColor[0], dv)),
	                clampCssByte(lerp(leftColor[1], rightColor[1], dv)),
	                clampCssByte(lerp(leftColor[2], rightColor[2], dv)),
	                clampCssFloat(lerp(leftColor[3], rightColor[3], dv))
	            ],
	            'rgba'
	        );
	
	        return fullOutput
	            ? {
	                color: color,
	                leftIndex: leftIndex,
	                rightIndex: rightIndex,
	                value: value
	            }
	            : color;
	    }
	
	    /**
	     * @param {string} color
	     * @param {number=} h 0 ~ 360, ignore when null.
	     * @param {number=} s 0 ~ 1, ignore when null.
	     * @param {number=} l 0 ~ 1, ignore when null.
	     * @return {string} Color string in rgba format.
	     * @memberOf module:zrender/util/color
	     */
	    function modifyHSL(color, h, s, l) {
	        color = parse(color);
	
	        if (color) {
	            color = rgba2hsla(color);
	            h != null && (color[0] = clampCssAngle(h));
	            s != null && (color[1] = parseCssFloat(s));
	            l != null && (color[2] = parseCssFloat(l));
	
	            return stringify(hsla2rgba(color), 'rgba');
	        }
	    }
	
	    /**
	     * @param {string} color
	     * @param {number=} alpha 0 ~ 1
	     * @return {string} Color string in rgba format.
	     * @memberOf module:zrender/util/color
	     */
	    function modifyAlpha(color, alpha) {
	        color = parse(color);
	
	        if (color && alpha != null) {
	            color[3] = clampCssFloat(alpha);
	            return stringify(color, 'rgba');
	        }
	    }
	
	    /**
	     * @param {Array.<string>} colors Color list.
	     * @param {string} type 'rgba', 'hsva', ...
	     * @return {string} Result color.
	     */
	    function stringify(arrColor, type) {
	        var colorStr = arrColor[0] + ',' + arrColor[1] + ',' + arrColor[2];
	        if (type === 'rgba' || type === 'hsva' || type === 'hsla') {
	            colorStr += ',' + arrColor[3];
	        }
	        return type + '(' + colorStr + ')';
	    }
	
	    module.exports = {
	        parse: parse,
	        lift: lift,
	        toHex: toHex,
	        fastMapToColor: fastMapToColor,
	        mapToColor: mapToColor,
	        modifyHSL: modifyHSL,
	        modifyAlpha: modifyAlpha,
	        stringify: stringify
	    };
	
	


/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	
	        var config = __webpack_require__(21);
	
	        /**
	         * @exports zrender/tool/log
	         * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)
	         */
	        module.exports = function() {
	            if (config.debugMode === 0) {
	                return;
	            }
	            else if (config.debugMode == 1) {
	                for (var k in arguments) {
	                    throw new Error(arguments[k]);
	                }
	            }
	            else if (config.debugMode > 1) {
	                for (var k in arguments) {
	                    console.log(arguments[k]);
	                }
	            }
	        };
	
	        /* for debug
	        return function(mes) {
	            document.getElementById('wrong-message').innerHTML =
	                mes + ' ' + (new Date() - 0)
	                + '<br/>' 
	                + document.getElementById('wrong-message').innerHTML;
	        };
	        */
	    


/***/ },
/* 21 */
/***/ function(module, exports) {

	
	    var dpr = 1;
	    // If in browser environment
	    if (typeof window !== 'undefined') {
	        dpr = Math.max(window.devicePixelRatio || 1, 1);
	    }
	    /**
	     * config默认配置项
	     * @exports zrender/config
	     * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)
	     */
	    var config = {
	        /**
	         * debug日志选项：catchBrushException为true下有效
	         * 0 : 不生成debug数据，发布用
	         * 1 : 异常抛出，调试用
	         * 2 : 控制台输出，调试用
	         */
	        debugMode: 0,
	
	        // retina 屏幕优化
	        devicePixelRatio: dpr
	    };
	    module.exports = config;
	
	


/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Mixin for drawing text in a element bounding rect
	 * @module zrender/mixin/RectText
	 */
	
	
	
	    var textContain = __webpack_require__(23);
	    var BoundingRect = __webpack_require__(24);
	
	    var tmpRect = new BoundingRect();
	
	    var RectText = function () {};
	
	    function parsePercent(value, maxValue) {
	        if (typeof value === 'string') {
	            if (value.lastIndexOf('%') >= 0) {
	                return parseFloat(value) / 100 * maxValue;
	            }
	            return parseFloat(value);
	        }
	        return value;
	    }
	
	    RectText.prototype = {
	
	        constructor: RectText,
	
	        /**
	         * Draw text in a rect with specified position.
	         * @param  {CanvasRenderingContext} ctx
	         * @param  {Object} rect Displayable rect
	         * @return {Object} textRect Alternative precalculated text bounding rect
	         */
	        drawRectText: function (ctx, rect, textRect) {
	            var style = this.style;
	            var text = style.text;
	            // Convert to string
	            text != null && (text += '');
	            if (!text) {
	                return;
	            }
	
	            // FIXME
	            ctx.save();
	
	            var x;
	            var y;
	            var textPosition = style.textPosition;
	            var distance = style.textDistance;
	            var align = style.textAlign;
	            var font = style.textFont || style.font;
	            var baseline = style.textBaseline;
	            var verticalAlign = style.textVerticalAlign;
	
	            textRect = textRect || textContain.getBoundingRect(text, font, align, baseline);
	
	            // Transform rect to view space
	            var transform = this.transform;
	            if (!style.textTransform) {
	                if (transform) {
	                    tmpRect.copy(rect);
	                    tmpRect.applyTransform(transform);
	                    rect = tmpRect;
	                }
	            }
	            else {
	                this.setTransform(ctx);
	            }
	
	            // Text position represented by coord
	            if (textPosition instanceof Array) {
	                // Percent
	                x = rect.x + parsePercent(textPosition[0], rect.width);
	                y = rect.y + parsePercent(textPosition[1], rect.height);
	                align = align || 'left';
	                baseline = baseline || 'top';
	
	                if (verticalAlign) {
	                    switch (verticalAlign) {
	                        case 'middle':
	                            y -= textRect.height / 2 - textRect.lineHeight / 2;
	                            break;
	                        case 'bottom':
	                            y -= textRect.height - textRect.lineHeight / 2;
	                            break;
	                        default:
	                            y += textRect.lineHeight / 2;
	                    }
	                    // Force bseline to be middle
	                    baseline = 'middle';
	                }
	            }
	            else {
	                var res = textContain.adjustTextPositionOnRect(
	                    textPosition, rect, textRect, distance
	                );
	                x = res.x;
	                y = res.y;
	                // Default align and baseline when has textPosition
	                align = align || res.textAlign;
	                baseline = baseline || res.textBaseline;
	            }
	
	            // Use canvas default left textAlign. Giving invalid value will cause state not change
	            ctx.textAlign = align || 'left';
	            // Use canvas default alphabetic baseline
	            ctx.textBaseline = baseline || 'alphabetic';
	
	            var textFill = style.textFill;
	            var textStroke = style.textStroke;
	            textFill && (ctx.fillStyle = textFill);
	            textStroke && (ctx.strokeStyle = textStroke);
	
	            // TODO Invalid font
	            ctx.font = font || '12px sans-serif';
	
	            // Text shadow
	            // Always set shadowBlur and shadowOffset to avoid leak from displayable
	            ctx.shadowBlur = style.textShadowBlur;
	            ctx.shadowColor = style.textShadowColor || 'transparent';
	            ctx.shadowOffsetX = style.textShadowOffsetX;
	            ctx.shadowOffsetY = style.textShadowOffsetY;
	
	            var textLines = text.split('\n');
	
	            if (style.textRotation) {
	                transform && ctx.translate(transform[4], transform[5]);
	                ctx.rotate(style.textRotation);
	                transform && ctx.translate(-transform[4], -transform[5]);
	            }
	
	            for (var i = 0; i < textLines.length; i++) {
	                textFill && ctx.fillText(textLines[i], x, y);
	                textStroke && ctx.strokeText(textLines[i], x, y);
	                y += textRect.lineHeight;
	            }
	
	            ctx.restore();
	        }
	    };
	
	    module.exports = RectText;


/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	
	
	    var textWidthCache = {};
	    var textWidthCacheCounter = 0;
	    var TEXT_CACHE_MAX = 5000;
	
	    var util = __webpack_require__(4);
	    var BoundingRect = __webpack_require__(24);
	    var retrieve = util.retrieve;
	
	    function getTextWidth(text, textFont) {
	        var key = text + ':' + textFont;
	        if (textWidthCache[key]) {
	            return textWidthCache[key];
	        }
	
	        var textLines = (text + '').split('\n');
	        var width = 0;
	
	        for (var i = 0, l = textLines.length; i < l; i++) {
	            // measureText 可以被覆盖以兼容不支持 Canvas 的环境
	            width = Math.max(textContain.measureText(textLines[i], textFont).width, width);
	        }
	
	        if (textWidthCacheCounter > TEXT_CACHE_MAX) {
	            textWidthCacheCounter = 0;
	            textWidthCache = {};
	        }
	        textWidthCacheCounter++;
	        textWidthCache[key] = width;
	
	        return width;
	    }
	
	    function getTextRect(text, textFont, textAlign, textBaseline) {
	        var textLineLen = ((text || '') + '').split('\n').length;
	
	        var width = getTextWidth(text, textFont);
	        // FIXME 高度计算比较粗暴
	        var lineHeight = getTextWidth('国', textFont);
	        var height = textLineLen * lineHeight;
	
	        var rect = new BoundingRect(0, 0, width, height);
	        // Text has a special line height property
	        rect.lineHeight = lineHeight;
	
	        switch (textBaseline) {
	            case 'bottom':
	            case 'alphabetic':
	                rect.y -= lineHeight;
	                break;
	            case 'middle':
	                rect.y -= lineHeight / 2;
	                break;
	            // case 'hanging':
	            // case 'top':
	        }
	
	        // FIXME Right to left language
	        switch (textAlign) {
	            case 'end':
	            case 'right':
	                rect.x -= rect.width;
	                break;
	            case 'center':
	                rect.x -= rect.width / 2;
	                break;
	            // case 'start':
	            // case 'left':
	        }
	
	        return rect;
	    }
	
	    function adjustTextPositionOnRect(textPosition, rect, textRect, distance) {
	
	        var x = rect.x;
	        var y = rect.y;
	
	        var height = rect.height;
	        var width = rect.width;
	
	        var textHeight = textRect.height;
	
	        var halfHeight = height / 2 - textHeight / 2;
	
	        var textAlign = 'left';
	
	        switch (textPosition) {
	            case 'left':
	                x -= distance;
	                y += halfHeight;
	                textAlign = 'right';
	                break;
	            case 'right':
	                x += distance + width;
	                y += halfHeight;
	                textAlign = 'left';
	                break;
	            case 'top':
	                x += width / 2;
	                y -= distance + textHeight;
	                textAlign = 'center';
	                break;
	            case 'bottom':
	                x += width / 2;
	                y += height + distance;
	                textAlign = 'center';
	                break;
	            case 'inside':
	                x += width / 2;
	                y += halfHeight;
	                textAlign = 'center';
	                break;
	            case 'insideLeft':
	                x += distance;
	                y += halfHeight;
	                textAlign = 'left';
	                break;
	            case 'insideRight':
	                x += width - distance;
	                y += halfHeight;
	                textAlign = 'right';
	                break;
	            case 'insideTop':
	                x += width / 2;
	                y += distance;
	                textAlign = 'center';
	                break;
	            case 'insideBottom':
	                x += width / 2;
	                y += height - textHeight - distance;
	                textAlign = 'center';
	                break;
	            case 'insideTopLeft':
	                x += distance;
	                y += distance;
	                textAlign = 'left';
	                break;
	            case 'insideTopRight':
	                x += width - distance;
	                y += distance;
	                textAlign = 'right';
	                break;
	            case 'insideBottomLeft':
	                x += distance;
	                y += height - textHeight - distance;
	                break;
	            case 'insideBottomRight':
	                x += width - distance;
	                y += height - textHeight - distance;
	                textAlign = 'right';
	                break;
	        }
	
	        return {
	            x: x,
	            y: y,
	            textAlign: textAlign,
	            textBaseline: 'top'
	        };
	    }
	
	    /**
	     * Show ellipsis if overflow.
	     *
	     * @param  {string} text
	     * @param  {string} containerWidth
	     * @param  {string} textFont
	     * @param  {number} [ellipsis='...']
	     * @param  {Object} [options]
	     * @param  {number} [options.maxIterations=3]
	     * @param  {number} [options.minChar=0] If truncate result are less
	     *                  then minChar, ellipsis will not show, which is
	     *                  better for user hint in some cases.
	     * @param  {number} [options.placeholder=''] When all truncated, use the placeholder.
	     * @return {string}
	     */
	    function truncateText(text, containerWidth, textFont, ellipsis, options) {
	        if (!containerWidth) {
	            return '';
	        }
	
	        options = options || {};
	
	        ellipsis = retrieve(ellipsis, '...');
	        var maxIterations = retrieve(options.maxIterations, 2);
	        var minChar = retrieve(options.minChar, 0);
	        // FIXME
	        // Other languages?
	        var cnCharWidth = getTextWidth('国', textFont);
	        // FIXME
	        // Consider proportional font?
	        var ascCharWidth = getTextWidth('a', textFont);
	        var placeholder = retrieve(options.placeholder, '');
	
	        // Example 1: minChar: 3, text: 'asdfzxcv', truncate result: 'asdf', but not: 'a...'.
	        // Example 2: minChar: 3, text: '维度', truncate result: '维', but not: '...'.
	        var contentWidth = containerWidth = Math.max(0, containerWidth - 1); // Reserve some gap.
	        for (var i = 0; i < minChar && contentWidth >= ascCharWidth; i++) {
	            contentWidth -= ascCharWidth;
	        }
	
	        var ellipsisWidth = getTextWidth(ellipsis);
	        if (ellipsisWidth > contentWidth) {
	            ellipsis = '';
	            ellipsisWidth = 0;
	        }
	
	        contentWidth = containerWidth - ellipsisWidth;
	
	        var textLines = (text + '').split('\n');
	
	        for (var i = 0, len = textLines.length; i < len; i++) {
	            var textLine = textLines[i];
	            var lineWidth = getTextWidth(textLine, textFont);
	
	            if (lineWidth <= containerWidth) {
	                continue;
	            }
	
	            for (var j = 0;; j++) {
	                if (lineWidth <= contentWidth || j >= maxIterations) {
	                    textLine += ellipsis;
	                    break;
	                }
	
	                var subLength = j === 0
	                    ? estimateLength(textLine, contentWidth, ascCharWidth, cnCharWidth)
	                    : lineWidth > 0
	                    ? Math.floor(textLine.length * contentWidth / lineWidth)
	                    : 0;
	
	                textLine = textLine.substr(0, subLength);
	                lineWidth = getTextWidth(textLine, textFont);
	            }
	
	            if (textLine === '') {
	                textLine = placeholder;
	            }
	
	            textLines[i] = textLine;
	        }
	
	        return textLines.join('\n');
	    }
	
	    function estimateLength(text, contentWidth, ascCharWidth, cnCharWidth) {
	        var width = 0;
	        var i = 0;
	        for (var len = text.length; i < len && width < contentWidth; i++) {
	            var charCode = text.charCodeAt(i);
	            width += (0 <= charCode && charCode <= 127) ? ascCharWidth : cnCharWidth;
	        }
	        return i;
	    }
	
	    var textContain = {
	
	        getWidth: getTextWidth,
	
	        getBoundingRect: getTextRect,
	
	        adjustTextPositionOnRect: adjustTextPositionOnRect,
	
	        truncateText: truncateText,
	
	        measureText: function (text, textFont) {
	            var ctx = util.getContext();
	            ctx.font = textFont || '12px sans-serif';
	            return ctx.measureText(text);
	        }
	    };
	
	    module.exports = textContain;


/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	/**
	 * @module echarts/core/BoundingRect
	 */
	
	
	    var vec2 = __webpack_require__(14);
	    var matrix = __webpack_require__(13);
	
	    var v2ApplyTransform = vec2.applyTransform;
	    var mathMin = Math.min;
	    var mathAbs = Math.abs;
	    var mathMax = Math.max;
	    /**
	     * @alias module:echarts/core/BoundingRect
	     */
	    function BoundingRect(x, y, width, height) {
	        /**
	         * @type {number}
	         */
	        this.x = x;
	        /**
	         * @type {number}
	         */
	        this.y = y;
	        /**
	         * @type {number}
	         */
	        this.width = width;
	        /**
	         * @type {number}
	         */
	        this.height = height;
	    }
	
	    BoundingRect.prototype = {
	
	        constructor: BoundingRect,
	
	        /**
	         * @param {module:echarts/core/BoundingRect} other
	         */
	        union: function (other) {
	            var x = mathMin(other.x, this.x);
	            var y = mathMin(other.y, this.y);
	
	            this.width = mathMax(
	                    other.x + other.width,
	                    this.x + this.width
	                ) - x;
	            this.height = mathMax(
	                    other.y + other.height,
	                    this.y + this.height
	                ) - y;
	            this.x = x;
	            this.y = y;
	        },
	
	        /**
	         * @param {Array.<number>} m
	         * @methods
	         */
	        applyTransform: (function () {
	            var min = [];
	            var max = [];
	            return function (m) {
	                // In case usage like this
	                // el.getBoundingRect().applyTransform(el.transform)
	                // And element has no transform
	                if (!m) {
	                    return;
	                }
	                min[0] = this.x;
	                min[1] = this.y;
	                max[0] = this.x + this.width;
	                max[1] = this.y + this.height;
	
	                v2ApplyTransform(min, min, m);
	                v2ApplyTransform(max, max, m);
	
	                this.x = mathMin(min[0], max[0]);
	                this.y = mathMin(min[1], max[1]);
	                this.width = mathAbs(max[0] - min[0]);
	                this.height = mathAbs(max[1] - min[1]);
	            };
	        })(),
	
	        /**
	         * Calculate matrix of transforming from self to target rect
	         * @param  {module:zrender/core/BoundingRect} b
	         * @return {Array.<number>}
	         */
	        calculateTransform: function (b) {
	            var a = this;
	            var sx = b.width / a.width;
	            var sy = b.height / a.height;
	
	            var m = matrix.create();
	
	            // 矩阵右乘
	            matrix.translate(m, m, [-a.x, -a.y]);
	            matrix.scale(m, m, [sx, sy]);
	            matrix.translate(m, m, [b.x, b.y]);
	
	            return m;
	        },
	
	        /**
	         * @param {(module:echarts/core/BoundingRect|Object)} b
	         * @return {boolean}
	         */
	        intersect: function (b) {
	            var a = this;
	            var ax0 = a.x;
	            var ax1 = a.x + a.width;
	            var ay0 = a.y;
	            var ay1 = a.y + a.height;
	
	            var bx0 = b.x;
	            var bx1 = b.x + b.width;
	            var by0 = b.y;
	            var by1 = b.y + b.height;
	
	            return ! (ax1 < bx0 || bx1 < ax0 || ay1 < by0 || by1 < ay0);
	        },
	
	        contain: function (x, y) {
	            var rect = this;
	            return x >= rect.x
	                && x <= (rect.x + rect.width)
	                && y >= rect.y
	                && y <= (rect.y + rect.height);
	        },
	
	        /**
	         * @return {module:echarts/core/BoundingRect}
	         */
	        clone: function () {
	            return new BoundingRect(this.x, this.y, this.width, this.height);
	        },
	
	        /**
	         * Copy from another rect
	         */
	        copy: function (other) {
	            this.x = other.x;
	            this.y = other.y;
	            this.width = other.width;
	            this.height = other.height;
	        }
	    };
	
	    module.exports = BoundingRect;


/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	/**
	 * Path 代理，可以在`buildPath`中用于替代`ctx`, 会保存每个path操作的命令到pathCommands属性中
	 * 可以用于 isInsidePath 判断以及获取boundingRect
	 *
	 * @module zrender/core/PathProxy
	 * @author Yi Shen (http://www.github.com/pissang)
	 */
	
	 // TODO getTotalLength, getPointAtLength
	
	
	    var curve = __webpack_require__(26);
	    var vec2 = __webpack_require__(14);
	    var bbox = __webpack_require__(27);
	    var BoundingRect = __webpack_require__(24);
	    var dpr = __webpack_require__(21).devicePixelRatio;
	
	    var CMD = {
	        M: 1,
	        L: 2,
	        C: 3,
	        Q: 4,
	        A: 5,
	        Z: 6,
	        // Rect
	        R: 7
	    };
	
	    var min = [];
	    var max = [];
	    var min2 = [];
	    var max2 = [];
	    var mathMin = Math.min;
	    var mathMax = Math.max;
	    var mathCos = Math.cos;
	    var mathSin = Math.sin;
	    var mathSqrt = Math.sqrt;
	    var mathAbs = Math.abs;
	
	    var hasTypedArray = typeof Float32Array != 'undefined';
	
	    /**
	     * @alias module:zrender/core/PathProxy
	     * @constructor
	     */
	    var PathProxy = function () {
	
	        /**
	         * Path data. Stored as flat array
	         * @type {Array.<Object>}
	         */
	        this.data = [];
	
	        this._len = 0;
	
	        this._ctx = null;
	
	        this._xi = 0;
	        this._yi = 0;
	
	        this._x0 = 0;
	        this._y0 = 0;
	
	        // Unit x, Unit y. Provide for avoiding drawing that too short line segment
	        this._ux = 0;
	        this._uy = 0;
	    };
	
	    /**
	     * 快速计算Path包围盒（并不是最小包围盒）
	     * @return {Object}
	     */
	    PathProxy.prototype = {
	
	        constructor: PathProxy,
	
	        _lineDash: null,
	
	        _dashOffset: 0,
	
	        _dashIdx: 0,
	
	        _dashSum: 0,
	
	        /**
	         * @readOnly
	         */
	        setScale: function (sx, sy) {
	            this._ux = mathAbs(1 / dpr / sx) || 0;
	            this._uy = mathAbs(1 / dpr / sy) || 0;
	        },
	
	        getContext: function () {
	            return this._ctx;
	        },
	
	        /**
	         * @param  {CanvasRenderingContext2D} ctx
	         * @return {module:zrender/core/PathProxy}
	         */
	        beginPath: function (ctx) {
	
	            this._ctx = ctx;
	
	            ctx && ctx.beginPath();
	
	            ctx && (this.dpr = ctx.dpr);
	
	            // Reset
	            this._len = 0;
	
	            if (this._lineDash) {
	                this._lineDash = null;
	
	                this._dashOffset = 0;
	            }
	
	            return this;
	        },
	
	        /**
	         * @param  {number} x
	         * @param  {number} y
	         * @return {module:zrender/core/PathProxy}
	         */
	        moveTo: function (x, y) {
	            this.addData(CMD.M, x, y);
	            this._ctx && this._ctx.moveTo(x, y);
	
	            // x0, y0, xi, yi 是记录在 _dashedXXXXTo 方法中使用
	            // xi, yi 记录当前点, x0, y0 在 closePath 的时候回到起始点。
	            // 有可能在 beginPath 之后直接调用 lineTo，这时候 x0, y0 需要
	            // 在 lineTo 方法中记录，这里先不考虑这种情况，dashed line 也只在 IE10- 中不支持
	            this._x0 = x;
	            this._y0 = y;
	
	            this._xi = x;
	            this._yi = y;
	
	            return this;
	        },
	
	        /**
	         * @param  {number} x
	         * @param  {number} y
	         * @return {module:zrender/core/PathProxy}
	         */
	        lineTo: function (x, y) {
	            var exceedUnit = mathAbs(x - this._xi) > this._ux
	                || mathAbs(y - this._yi) > this._uy
	                // Force draw the first segment
	                || this._len < 5;
	
	            this.addData(CMD.L, x, y);
	
	            if (this._ctx && exceedUnit) {
	                this._needsDash() ? this._dashedLineTo(x, y)
	                    : this._ctx.lineTo(x, y);
	            }
	            if (exceedUnit) {
	                this._xi = x;
	                this._yi = y;
	            }
	
	            return this;
	        },
	
	        /**
	         * @param  {number} x1
	         * @param  {number} y1
	         * @param  {number} x2
	         * @param  {number} y2
	         * @param  {number} x3
	         * @param  {number} y3
	         * @return {module:zrender/core/PathProxy}
	         */
	        bezierCurveTo: function (x1, y1, x2, y2, x3, y3) {
	            this.addData(CMD.C, x1, y1, x2, y2, x3, y3);
	            if (this._ctx) {
	                this._needsDash() ? this._dashedBezierTo(x1, y1, x2, y2, x3, y3)
	                    : this._ctx.bezierCurveTo(x1, y1, x2, y2, x3, y3);
	            }
	            this._xi = x3;
	            this._yi = y3;
	            return this;
	        },
	
	        /**
	         * @param  {number} x1
	         * @param  {number} y1
	         * @param  {number} x2
	         * @param  {number} y2
	         * @return {module:zrender/core/PathProxy}
	         */
	        quadraticCurveTo: function (x1, y1, x2, y2) {
	            this.addData(CMD.Q, x1, y1, x2, y2);
	            if (this._ctx) {
	                this._needsDash() ? this._dashedQuadraticTo(x1, y1, x2, y2)
	                    : this._ctx.quadraticCurveTo(x1, y1, x2, y2);
	            }
	            this._xi = x2;
	            this._yi = y2;
	            return this;
	        },
	
	        /**
	         * @param  {number} cx
	         * @param  {number} cy
	         * @param  {number} r
	         * @param  {number} startAngle
	         * @param  {number} endAngle
	         * @param  {boolean} anticlockwise
	         * @return {module:zrender/core/PathProxy}
	         */
	        arc: function (cx, cy, r, startAngle, endAngle, anticlockwise) {
	            this.addData(
	                CMD.A, cx, cy, r, r, startAngle, endAngle - startAngle, 0, anticlockwise ? 0 : 1
	            );
	            this._ctx && this._ctx.arc(cx, cy, r, startAngle, endAngle, anticlockwise);
	
	            this._xi = mathCos(endAngle) * r + cx;
	            this._xi = mathSin(endAngle) * r + cx;
	            return this;
	        },
	
	        // TODO
	        arcTo: function (x1, y1, x2, y2, radius) {
	            if (this._ctx) {
	                this._ctx.arcTo(x1, y1, x2, y2, radius);
	            }
	            return this;
	        },
	
	        // TODO
	        rect: function (x, y, w, h) {
	            this._ctx && this._ctx.rect(x, y, w, h);
	            this.addData(CMD.R, x, y, w, h);
	            return this;
	        },
	
	        /**
	         * @return {module:zrender/core/PathProxy}
	         */
	        closePath: function () {
	            this.addData(CMD.Z);
	
	            var ctx = this._ctx;
	            var x0 = this._x0;
	            var y0 = this._y0;
	            if (ctx) {
	                this._needsDash() && this._dashedLineTo(x0, y0);
	                ctx.closePath();
	            }
	
	            this._xi = x0;
	            this._yi = y0;
	            return this;
	        },
	
	        /**
	         * Context 从外部传入，因为有可能是 rebuildPath 完之后再 fill。
	         * stroke 同样
	         * @param {CanvasRenderingContext2D} ctx
	         * @return {module:zrender/core/PathProxy}
	         */
	        fill: function (ctx) {
	            ctx && ctx.fill();
	            this.toStatic();
	        },
	
	        /**
	         * @param {CanvasRenderingContext2D} ctx
	         * @return {module:zrender/core/PathProxy}
	         */
	        stroke: function (ctx) {
	            ctx && ctx.stroke();
	            this.toStatic();
	        },
	
	        /**
	         * 必须在其它绘制命令前调用
	         * Must be invoked before all other path drawing methods
	         * @return {module:zrender/core/PathProxy}
	         */
	        setLineDash: function (lineDash) {
	            if (lineDash instanceof Array) {
	                this._lineDash = lineDash;
	
	                this._dashIdx = 0;
	
	                var lineDashSum = 0;
	                for (var i = 0; i < lineDash.length; i++) {
	                    lineDashSum += lineDash[i];
	                }
	                this._dashSum = lineDashSum;
	            }
	            return this;
	        },
	
	        /**
	         * 必须在其它绘制命令前调用
	         * Must be invoked before all other path drawing methods
	         * @return {module:zrender/core/PathProxy}
	         */
	        setLineDashOffset: function (offset) {
	            this._dashOffset = offset;
	            return this;
	        },
	
	        /**
	         *
	         * @return {boolean}
	         */
	        len: function () {
	            return this._len;
	        },
	
	        /**
	         * 直接设置 Path 数据
	         */
	        setData: function (data) {
	
	            var len = data.length;
	
	            if (! (this.data && this.data.length == len) && hasTypedArray) {
	                this.data = new Float32Array(len);
	            }
	
	            for (var i = 0; i < len; i++) {
	                this.data[i] = data[i];
	            }
	
	            this._len = len;
	        },
	
	        /**
	         * 添加子路径
	         * @param {module:zrender/core/PathProxy|Array.<module:zrender/core/PathProxy>} path
	         */
	        appendPath: function (path) {
	            if (!(path instanceof Array)) {
	                path = [path];
	            }
	            var len = path.length;
	            var appendSize = 0;
	            var offset = this._len;
	            for (var i = 0; i < len; i++) {
	                appendSize += path[i].len();
	            }
	            if (hasTypedArray && (this.data instanceof Float32Array)) {
	                this.data = new Float32Array(offset + appendSize);
	            }
	            for (var i = 0; i < len; i++) {
	                var appendPathData = path[i].data;
	                for (var k = 0; k < appendPathData.length; k++) {
	                    this.data[offset++] = appendPathData[k];
	                }
	            }
	            this._len = offset;
	        },
	
	        /**
	         * 填充 Path 数据。
	         * 尽量复用而不申明新的数组。大部分图形重绘的指令数据长度都是不变的。
	         */
	        addData: function (cmd) {
	            var data = this.data;
	            if (this._len + arguments.length > data.length) {
	                // 因为之前的数组已经转换成静态的 Float32Array
	                // 所以不够用时需要扩展一个新的动态数组
	                this._expandData();
	                data = this.data;
	            }
	            for (var i = 0; i < arguments.length; i++) {
	                data[this._len++] = arguments[i];
	            }
	
	            this._prevCmd = cmd;
	        },
	
	        _expandData: function () {
	            // Only if data is Float32Array
	            if (!(this.data instanceof Array)) {
	                var newData = [];
	                for (var i = 0; i < this._len; i++) {
	                    newData[i] = this.data[i];
	                }
	                this.data = newData;
	            }
	        },
	
	        /**
	         * If needs js implemented dashed line
	         * @return {boolean}
	         * @private
	         */
	        _needsDash: function () {
	            return this._lineDash;
	        },
	
	        _dashedLineTo: function (x1, y1) {
	            var dashSum = this._dashSum;
	            var offset = this._dashOffset;
	            var lineDash = this._lineDash;
	            var ctx = this._ctx;
	
	            var x0 = this._xi;
	            var y0 = this._yi;
	            var dx = x1 - x0;
	            var dy = y1 - y0;
	            var dist = mathSqrt(dx * dx + dy * dy);
	            var x = x0;
	            var y = y0;
	            var dash;
	            var nDash = lineDash.length;
	            var idx;
	            dx /= dist;
	            dy /= dist;
	
	            if (offset < 0) {
	                // Convert to positive offset
	                offset = dashSum + offset;
	            }
	            offset %= dashSum;
	            x -= offset * dx;
	            y -= offset * dy;
	
	            while ((dx > 0 && x <= x1) || (dx < 0 && x >= x1)
	            || (dx == 0 && ((dy > 0 && y <= y1) || (dy < 0 && y >= y1)))) {
	                idx = this._dashIdx;
	                dash = lineDash[idx];
	                x += dx * dash;
	                y += dy * dash;
	                this._dashIdx = (idx + 1) % nDash;
	                // Skip positive offset
	                if ((dx > 0 && x < x0) || (dx < 0 && x > x0) || (dy > 0 && y < y0) || (dy < 0 && y > y0)) {
	                    continue;
	                }
	                ctx[idx % 2 ? 'moveTo' : 'lineTo'](
	                    dx >= 0 ? mathMin(x, x1) : mathMax(x, x1),
	                    dy >= 0 ? mathMin(y, y1) : mathMax(y, y1)
	                );
	            }
	            // Offset for next lineTo
	            dx = x - x1;
	            dy = y - y1;
	            this._dashOffset = -mathSqrt(dx * dx + dy * dy);
	        },
	
	        // Not accurate dashed line to
	        _dashedBezierTo: function (x1, y1, x2, y2, x3, y3) {
	            var dashSum = this._dashSum;
	            var offset = this._dashOffset;
	            var lineDash = this._lineDash;
	            var ctx = this._ctx;
	
	            var x0 = this._xi;
	            var y0 = this._yi;
	            var t;
	            var dx;
	            var dy;
	            var cubicAt = curve.cubicAt;
	            var bezierLen = 0;
	            var idx = this._dashIdx;
	            var nDash = lineDash.length;
	
	            var x;
	            var y;
	
	            var tmpLen = 0;
	
	            if (offset < 0) {
	                // Convert to positive offset
	                offset = dashSum + offset;
	            }
	            offset %= dashSum;
	            // Bezier approx length
	            for (t = 0; t < 1; t += 0.1) {
	                dx = cubicAt(x0, x1, x2, x3, t + 0.1)
	                    - cubicAt(x0, x1, x2, x3, t);
	                dy = cubicAt(y0, y1, y2, y3, t + 0.1)
	                    - cubicAt(y0, y1, y2, y3, t);
	                bezierLen += mathSqrt(dx * dx + dy * dy);
	            }
	
	            // Find idx after add offset
	            for (; idx < nDash; idx++) {
	                tmpLen += lineDash[idx];
	                if (tmpLen > offset) {
	                    break;
	                }
	            }
	            t = (tmpLen - offset) / bezierLen;
	
	            while (t <= 1) {
	
	                x = cubicAt(x0, x1, x2, x3, t);
	                y = cubicAt(y0, y1, y2, y3, t);
	
	                // Use line to approximate dashed bezier
	                // Bad result if dash is long
	                idx % 2 ? ctx.moveTo(x, y)
	                    : ctx.lineTo(x, y);
	
	                t += lineDash[idx] / bezierLen;
	
	                idx = (idx + 1) % nDash;
	            }
	
	            // Finish the last segment and calculate the new offset
	            (idx % 2 !== 0) && ctx.lineTo(x3, y3);
	            dx = x3 - x;
	            dy = y3 - y;
	            this._dashOffset = -mathSqrt(dx * dx + dy * dy);
	        },
	
	        _dashedQuadraticTo: function (x1, y1, x2, y2) {
	            // Convert quadratic to cubic using degree elevation
	            var x3 = x2;
	            var y3 = y2;
	            x2 = (x2 + 2 * x1) / 3;
	            y2 = (y2 + 2 * y1) / 3;
	            x1 = (this._xi + 2 * x1) / 3;
	            y1 = (this._yi + 2 * y1) / 3;
	
	            this._dashedBezierTo(x1, y1, x2, y2, x3, y3);
	        },
	
	        /**
	         * 转成静态的 Float32Array 减少堆内存占用
	         * Convert dynamic array to static Float32Array
	         */
	        toStatic: function () {
	            var data = this.data;
	            if (data instanceof Array) {
	                data.length = this._len;
	                if (hasTypedArray) {
	                    this.data = new Float32Array(data);
	                }
	            }
	        },
	
	        /**
	         * @return {module:zrender/core/BoundingRect}
	         */
	        getBoundingRect: function () {
	            min[0] = min[1] = min2[0] = min2[1] = Number.MAX_VALUE;
	            max[0] = max[1] = max2[0] = max2[1] = -Number.MAX_VALUE;
	
	            var data = this.data;
	            var xi = 0;
	            var yi = 0;
	            var x0 = 0;
	            var y0 = 0;
	
	            for (var i = 0; i < data.length;) {
	                var cmd = data[i++];
	
	                if (i == 1) {
	                    // 如果第一个命令是 L, C, Q
	                    // 则 previous point 同绘制命令的第一个 point
	                    //
	                    // 第一个命令为 Arc 的情况下会在后面特殊处理
	                    xi = data[i];
	                    yi = data[i + 1];
	
	                    x0 = xi;
	                    y0 = yi;
	                }
	
	                switch (cmd) {
	                    case CMD.M:
	                        // moveTo 命令重新创建一个新的 subpath, 并且更新新的起点
	                        // 在 closePath 的时候使用
	                        x0 = data[i++];
	                        y0 = data[i++];
	                        xi = x0;
	                        yi = y0;
	                        min2[0] = x0;
	                        min2[1] = y0;
	                        max2[0] = x0;
	                        max2[1] = y0;
	                        break;
	                    case CMD.L:
	                        bbox.fromLine(xi, yi, data[i], data[i + 1], min2, max2);
	                        xi = data[i++];
	                        yi = data[i++];
	                        break;
	                    case CMD.C:
	                        bbox.fromCubic(
	                            xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1],
	                            min2, max2
	                        );
	                        xi = data[i++];
	                        yi = data[i++];
	                        break;
	                    case CMD.Q:
	                        bbox.fromQuadratic(
	                            xi, yi, data[i++], data[i++], data[i], data[i + 1],
	                            min2, max2
	                        );
	                        xi = data[i++];
	                        yi = data[i++];
	                        break;
	                    case CMD.A:
	                        // TODO Arc 判断的开销比较大
	                        var cx = data[i++];
	                        var cy = data[i++];
	                        var rx = data[i++];
	                        var ry = data[i++];
	                        var startAngle = data[i++];
	                        var endAngle = data[i++] + startAngle;
	                        // TODO Arc 旋转
	                        var psi = data[i++];
	                        var anticlockwise = 1 - data[i++];
	
	                        if (i == 1) {
	                            // 直接使用 arc 命令
	                            // 第一个命令起点还未定义
	                            x0 = mathCos(startAngle) * rx + cx;
	                            y0 = mathSin(startAngle) * ry + cy;
	                        }
	
	                        bbox.fromArc(
	                            cx, cy, rx, ry, startAngle, endAngle,
	                            anticlockwise, min2, max2
	                        );
	
	                        xi = mathCos(endAngle) * rx + cx;
	                        yi = mathSin(endAngle) * ry + cy;
	                        break;
	                    case CMD.R:
	                        x0 = xi = data[i++];
	                        y0 = yi = data[i++];
	                        var width = data[i++];
	                        var height = data[i++];
	                        // Use fromLine
	                        bbox.fromLine(x0, y0, x0 + width, y0 + height, min2, max2);
	                        break;
	                    case CMD.Z:
	                        xi = x0;
	                        yi = y0;
	                        break;
	                }
	
	                // Union
	                vec2.min(min, min, min2);
	                vec2.max(max, max, max2);
	            }
	
	            // No data
	            if (i === 0) {
	                min[0] = min[1] = max[0] = max[1] = 0;
	            }
	
	            return new BoundingRect(
	                min[0], min[1], max[0] - min[0], max[1] - min[1]
	            );
	        },
	
	        /**
	         * Rebuild path from current data
	         * Rebuild path will not consider javascript implemented line dash.
	         * @param {CanvasRenderingContext} ctx
	         */
	        rebuildPath: function (ctx) {
	            var d = this.data;
	            var x0, y0;
	            var xi, yi;
	            var x, y;
	            var ux = this._ux;
	            var uy = this._uy;
	            var len = this._len;
	            for (var i = 0; i < len;) {
	                var cmd = d[i++];
	
	                if (i == 1) {
	                    // 如果第一个命令是 L, C, Q
	                    // 则 previous point 同绘制命令的第一个 point
	                    //
	                    // 第一个命令为 Arc 的情况下会在后面特殊处理
	                    xi = d[i];
	                    yi = d[i + 1];
	
	                    x0 = xi;
	                    y0 = yi;
	                }
	                switch (cmd) {
	                    case CMD.M:
	                        x0 = xi = d[i++];
	                        y0 = yi = d[i++];
	                        ctx.moveTo(xi, yi);
	                        break;
	                    case CMD.L:
	                        x = d[i++];
	                        y = d[i++];
	                        // Not draw too small seg between
	                        if (mathAbs(x - xi) > ux || mathAbs(y - yi) > uy || i === len - 1) {
	                            ctx.lineTo(x, y);
	                            xi = x;
	                            yi = y;
	                        }
	                        break;
	                    case CMD.C:
	                        ctx.bezierCurveTo(
	                            d[i++], d[i++], d[i++], d[i++], d[i++], d[i++]
	                        );
	                        xi = d[i - 2];
	                        yi = d[i - 1];
	                        break;
	                    case CMD.Q:
	                        ctx.quadraticCurveTo(d[i++], d[i++], d[i++], d[i++]);
	                        xi = d[i - 2];
	                        yi = d[i - 1];
	                        break;
	                    case CMD.A:
	                        var cx = d[i++];
	                        var cy = d[i++];
	                        var rx = d[i++];
	                        var ry = d[i++];
	                        var theta = d[i++];
	                        var dTheta = d[i++];
	                        var psi = d[i++];
	                        var fs = d[i++];
	                        var r = (rx > ry) ? rx : ry;
	                        var scaleX = (rx > ry) ? 1 : rx / ry;
	                        var scaleY = (rx > ry) ? ry / rx : 1;
	                        var isEllipse = Math.abs(rx - ry) > 1e-3;
	                        var endAngle = theta + dTheta;
	                        if (isEllipse) {
	                            ctx.translate(cx, cy);
	                            ctx.rotate(psi);
	                            ctx.scale(scaleX, scaleY);
	                            ctx.arc(0, 0, r, theta, endAngle, 1 - fs);
	                            ctx.scale(1 / scaleX, 1 / scaleY);
	                            ctx.rotate(-psi);
	                            ctx.translate(-cx, -cy);
	                        }
	                        else {
	                            ctx.arc(cx, cy, r, theta, endAngle, 1 - fs);
	                        }
	
	                        if (i == 1) {
	                            // 直接使用 arc 命令
	                            // 第一个命令起点还未定义
	                            x0 = mathCos(theta) * rx + cx;
	                            y0 = mathSin(theta) * ry + cy;
	                        }
	                        xi = mathCos(endAngle) * rx + cx;
	                        yi = mathSin(endAngle) * ry + cy;
	                        break;
	                    case CMD.R:
	                        x0 = xi = d[i];
	                        y0 = yi = d[i + 1];
	                        ctx.rect(d[i++], d[i++], d[i++], d[i++]);
	                        break;
	                    case CMD.Z:
	                        ctx.closePath();
	                        xi = x0;
	                        yi = y0;
	                }
	            }
	        }
	    };
	
	    PathProxy.CMD = CMD;
	
	    module.exports = PathProxy;


/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	/**
	 * 曲线辅助模块
	 * @module zrender/core/curve
	 * @author pissang(https://www.github.com/pissang)
	 */
	
	
	    var vec2 = __webpack_require__(14);
	    var v2Create = vec2.create;
	    var v2DistSquare = vec2.distSquare;
	    var mathPow = Math.pow;
	    var mathSqrt = Math.sqrt;
	
	    var EPSILON = 1e-8;
	    var EPSILON_NUMERIC = 1e-4;
	
	    var THREE_SQRT = mathSqrt(3);
	    var ONE_THIRD = 1 / 3;
	
	    // 临时变量
	    var _v0 = v2Create();
	    var _v1 = v2Create();
	    var _v2 = v2Create();
	    // var _v3 = vec2.create();
	
	    function isAroundZero(val) {
	        return val > -EPSILON && val < EPSILON;
	    }
	    function isNotAroundZero(val) {
	        return val > EPSILON || val < -EPSILON;
	    }
	    /**
	     * 计算三次贝塞尔值
	     * @memberOf module:zrender/core/curve
	     * @param  {number} p0
	     * @param  {number} p1
	     * @param  {number} p2
	     * @param  {number} p3
	     * @param  {number} t
	     * @return {number}
	     */
	    function cubicAt(p0, p1, p2, p3, t) {
	        var onet = 1 - t;
	        return onet * onet * (onet * p0 + 3 * t * p1)
	             + t * t * (t * p3 + 3 * onet * p2);
	    }
	
	    /**
	     * 计算三次贝塞尔导数值
	     * @memberOf module:zrender/core/curve
	     * @param  {number} p0
	     * @param  {number} p1
	     * @param  {number} p2
	     * @param  {number} p3
	     * @param  {number} t
	     * @return {number}
	     */
	    function cubicDerivativeAt(p0, p1, p2, p3, t) {
	        var onet = 1 - t;
	        return 3 * (
	            ((p1 - p0) * onet + 2 * (p2 - p1) * t) * onet
	            + (p3 - p2) * t * t
	        );
	    }
	
	    /**
	     * 计算三次贝塞尔方程根，使用盛金公式
	     * @memberOf module:zrender/core/curve
	     * @param  {number} p0
	     * @param  {number} p1
	     * @param  {number} p2
	     * @param  {number} p3
	     * @param  {number} val
	     * @param  {Array.<number>} roots
	     * @return {number} 有效根数目
	     */
	    function cubicRootAt(p0, p1, p2, p3, val, roots) {
	        // Evaluate roots of cubic functions
	        var a = p3 + 3 * (p1 - p2) - p0;
	        var b = 3 * (p2 - p1 * 2 + p0);
	        var c = 3 * (p1  - p0);
	        var d = p0 - val;
	
	        var A = b * b - 3 * a * c;
	        var B = b * c - 9 * a * d;
	        var C = c * c - 3 * b * d;
	
	        var n = 0;
	
	        if (isAroundZero(A) && isAroundZero(B)) {
	            if (isAroundZero(b)) {
	                roots[0] = 0;
	            }
	            else {
	                var t1 = -c / b;  //t1, t2, t3, b is not zero
	                if (t1 >= 0 && t1 <= 1) {
	                    roots[n++] = t1;
	                }
	            }
	        }
	        else {
	            var disc = B * B - 4 * A * C;
	
	            if (isAroundZero(disc)) {
	                var K = B / A;
	                var t1 = -b / a + K;  // t1, a is not zero
	                var t2 = -K / 2;  // t2, t3
	                if (t1 >= 0 && t1 <= 1) {
	                    roots[n++] = t1;
	                }
	                if (t2 >= 0 && t2 <= 1) {
	                    roots[n++] = t2;
	                }
	            }
	            else if (disc > 0) {
	                var discSqrt = mathSqrt(disc);
	                var Y1 = A * b + 1.5 * a * (-B + discSqrt);
	                var Y2 = A * b + 1.5 * a * (-B - discSqrt);
	                if (Y1 < 0) {
	                    Y1 = -mathPow(-Y1, ONE_THIRD);
	                }
	                else {
	                    Y1 = mathPow(Y1, ONE_THIRD);
	                }
	                if (Y2 < 0) {
	                    Y2 = -mathPow(-Y2, ONE_THIRD);
	                }
	                else {
	                    Y2 = mathPow(Y2, ONE_THIRD);
	                }
	                var t1 = (-b - (Y1 + Y2)) / (3 * a);
	                if (t1 >= 0 && t1 <= 1) {
	                    roots[n++] = t1;
	                }
	            }
	            else {
	                var T = (2 * A * b - 3 * a * B) / (2 * mathSqrt(A * A * A));
	                var theta = Math.acos(T) / 3;
	                var ASqrt = mathSqrt(A);
	                var tmp = Math.cos(theta);
	
	                var t1 = (-b - 2 * ASqrt * tmp) / (3 * a);
	                var t2 = (-b + ASqrt * (tmp + THREE_SQRT * Math.sin(theta))) / (3 * a);
	                var t3 = (-b + ASqrt * (tmp - THREE_SQRT * Math.sin(theta))) / (3 * a);
	                if (t1 >= 0 && t1 <= 1) {
	                    roots[n++] = t1;
	                }
	                if (t2 >= 0 && t2 <= 1) {
	                    roots[n++] = t2;
	                }
	                if (t3 >= 0 && t3 <= 1) {
	                    roots[n++] = t3;
	                }
	            }
	        }
	        return n;
	    }
	
	    /**
	     * 计算三次贝塞尔方程极限值的位置
	     * @memberOf module:zrender/core/curve
	     * @param  {number} p0
	     * @param  {number} p1
	     * @param  {number} p2
	     * @param  {number} p3
	     * @param  {Array.<number>} extrema
	     * @return {number} 有效数目
	     */
	    function cubicExtrema(p0, p1, p2, p3, extrema) {
	        var b = 6 * p2 - 12 * p1 + 6 * p0;
	        var a = 9 * p1 + 3 * p3 - 3 * p0 - 9 * p2;
	        var c = 3 * p1 - 3 * p0;
	
	        var n = 0;
	        if (isAroundZero(a)) {
	            if (isNotAroundZero(b)) {
	                var t1 = -c / b;
	                if (t1 >= 0 && t1 <=1) {
	                    extrema[n++] = t1;
	                }
	            }
	        }
	        else {
	            var disc = b * b - 4 * a * c;
	            if (isAroundZero(disc)) {
	                extrema[0] = -b / (2 * a);
	            }
	            else if (disc > 0) {
	                var discSqrt = mathSqrt(disc);
	                var t1 = (-b + discSqrt) / (2 * a);
	                var t2 = (-b - discSqrt) / (2 * a);
	                if (t1 >= 0 && t1 <= 1) {
	                    extrema[n++] = t1;
	                }
	                if (t2 >= 0 && t2 <= 1) {
	                    extrema[n++] = t2;
	                }
	            }
	        }
	        return n;
	    }
	
	    /**
	     * 细分三次贝塞尔曲线
	     * @memberOf module:zrender/core/curve
	     * @param  {number} p0
	     * @param  {number} p1
	     * @param  {number} p2
	     * @param  {number} p3
	     * @param  {number} t
	     * @param  {Array.<number>} out
	     */
	    function cubicSubdivide(p0, p1, p2, p3, t, out) {
	        var p01 = (p1 - p0) * t + p0;
	        var p12 = (p2 - p1) * t + p1;
	        var p23 = (p3 - p2) * t + p2;
	
	        var p012 = (p12 - p01) * t + p01;
	        var p123 = (p23 - p12) * t + p12;
	
	        var p0123 = (p123 - p012) * t + p012;
	        // Seg0
	        out[0] = p0;
	        out[1] = p01;
	        out[2] = p012;
	        out[3] = p0123;
	        // Seg1
	        out[4] = p0123;
	        out[5] = p123;
	        out[6] = p23;
	        out[7] = p3;
	    }
	
	    /**
	     * 投射点到三次贝塞尔曲线上，返回投射距离。
	     * 投射点有可能会有一个或者多个，这里只返回其中距离最短的一个。
	     * @param {number} x0
	     * @param {number} y0
	     * @param {number} x1
	     * @param {number} y1
	     * @param {number} x2
	     * @param {number} y2
	     * @param {number} x3
	     * @param {number} y3
	     * @param {number} x
	     * @param {number} y
	     * @param {Array.<number>} [out] 投射点
	     * @return {number}
	     */
	    function cubicProjectPoint(
	        x0, y0, x1, y1, x2, y2, x3, y3,
	        x, y, out
	    ) {
	        // http://pomax.github.io/bezierinfo/#projections
	        var t;
	        var interval = 0.005;
	        var d = Infinity;
	        var prev;
	        var next;
	        var d1;
	        var d2;
	
	        _v0[0] = x;
	        _v0[1] = y;
	
	        // 先粗略估计一下可能的最小距离的 t 值
	        // PENDING
	        for (var _t = 0; _t < 1; _t += 0.05) {
	            _v1[0] = cubicAt(x0, x1, x2, x3, _t);
	            _v1[1] = cubicAt(y0, y1, y2, y3, _t);
	            d1 = v2DistSquare(_v0, _v1);
	            if (d1 < d) {
	                t = _t;
	                d = d1;
	            }
	        }
	        d = Infinity;
	
	        // At most 32 iteration
	        for (var i = 0; i < 32; i++) {
	            if (interval < EPSILON_NUMERIC) {
	                break;
	            }
	            prev = t - interval;
	            next = t + interval;
	            // t - interval
	            _v1[0] = cubicAt(x0, x1, x2, x3, prev);
	            _v1[1] = cubicAt(y0, y1, y2, y3, prev);
	
	            d1 = v2DistSquare(_v1, _v0);
	
	            if (prev >= 0 && d1 < d) {
	                t = prev;
	                d = d1;
	            }
	            else {
	                // t + interval
	                _v2[0] = cubicAt(x0, x1, x2, x3, next);
	                _v2[1] = cubicAt(y0, y1, y2, y3, next);
	                d2 = v2DistSquare(_v2, _v0);
	
	                if (next <= 1 && d2 < d) {
	                    t = next;
	                    d = d2;
	                }
	                else {
	                    interval *= 0.5;
	                }
	            }
	        }
	        // t
	        if (out) {
	            out[0] = cubicAt(x0, x1, x2, x3, t);
	            out[1] = cubicAt(y0, y1, y2, y3, t);
	        }
	        // console.log(interval, i);
	        return mathSqrt(d);
	    }
	
	    /**
	     * 计算二次方贝塞尔值
	     * @param  {number} p0
	     * @param  {number} p1
	     * @param  {number} p2
	     * @param  {number} t
	     * @return {number}
	     */
	    function quadraticAt(p0, p1, p2, t) {
	        var onet = 1 - t;
	        return onet * (onet * p0 + 2 * t * p1) + t * t * p2;
	    }
	
	    /**
	     * 计算二次方贝塞尔导数值
	     * @param  {number} p0
	     * @param  {number} p1
	     * @param  {number} p2
	     * @param  {number} t
	     * @return {number}
	     */
	    function quadraticDerivativeAt(p0, p1, p2, t) {
	        return 2 * ((1 - t) * (p1 - p0) + t * (p2 - p1));
	    }
	
	    /**
	     * 计算二次方贝塞尔方程根
	     * @param  {number} p0
	     * @param  {number} p1
	     * @param  {number} p2
	     * @param  {number} t
	     * @param  {Array.<number>} roots
	     * @return {number} 有效根数目
	     */
	    function quadraticRootAt(p0, p1, p2, val, roots) {
	        var a = p0 - 2 * p1 + p2;
	        var b = 2 * (p1 - p0);
	        var c = p0 - val;
	
	        var n = 0;
	        if (isAroundZero(a)) {
	            if (isNotAroundZero(b)) {
	                var t1 = -c / b;
	                if (t1 >= 0 && t1 <= 1) {
	                    roots[n++] = t1;
	                }
	            }
	        }
	        else {
	            var disc = b * b - 4 * a * c;
	            if (isAroundZero(disc)) {
	                var t1 = -b / (2 * a);
	                if (t1 >= 0 && t1 <= 1) {
	                    roots[n++] = t1;
	                }
	            }
	            else if (disc > 0) {
	                var discSqrt = mathSqrt(disc);
	                var t1 = (-b + discSqrt) / (2 * a);
	                var t2 = (-b - discSqrt) / (2 * a);
	                if (t1 >= 0 && t1 <= 1) {
	                    roots[n++] = t1;
	                }
	                if (t2 >= 0 && t2 <= 1) {
	                    roots[n++] = t2;
	                }
	            }
	        }
	        return n;
	    }
	
	    /**
	     * 计算二次贝塞尔方程极限值
	     * @memberOf module:zrender/core/curve
	     * @param  {number} p0
	     * @param  {number} p1
	     * @param  {number} p2
	     * @return {number}
	     */
	    function quadraticExtremum(p0, p1, p2) {
	        var divider = p0 + p2 - 2 * p1;
	        if (divider === 0) {
	            // p1 is center of p0 and p2
	            return 0.5;
	        }
	        else {
	            return (p0 - p1) / divider;
	        }
	    }
	
	    /**
	     * 细分二次贝塞尔曲线
	     * @memberOf module:zrender/core/curve
	     * @param  {number} p0
	     * @param  {number} p1
	     * @param  {number} p2
	     * @param  {number} t
	     * @param  {Array.<number>} out
	     */
	    function quadraticSubdivide(p0, p1, p2, t, out) {
	        var p01 = (p1 - p0) * t + p0;
	        var p12 = (p2 - p1) * t + p1;
	        var p012 = (p12 - p01) * t + p01;
	
	        // Seg0
	        out[0] = p0;
	        out[1] = p01;
	        out[2] = p012;
	
	        // Seg1
	        out[3] = p012;
	        out[4] = p12;
	        out[5] = p2;
	    }
	
	    /**
	     * 投射点到二次贝塞尔曲线上，返回投射距离。
	     * 投射点有可能会有一个或者多个，这里只返回其中距离最短的一个。
	     * @param {number} x0
	     * @param {number} y0
	     * @param {number} x1
	     * @param {number} y1
	     * @param {number} x2
	     * @param {number} y2
	     * @param {number} x
	     * @param {number} y
	     * @param {Array.<number>} out 投射点
	     * @return {number}
	     */
	    function quadraticProjectPoint(
	        x0, y0, x1, y1, x2, y2,
	        x, y, out
	    ) {
	        // http://pomax.github.io/bezierinfo/#projections
	        var t;
	        var interval = 0.005;
	        var d = Infinity;
	
	        _v0[0] = x;
	        _v0[1] = y;
	
	        // 先粗略估计一下可能的最小距离的 t 值
	        // PENDING
	        for (var _t = 0; _t < 1; _t += 0.05) {
	            _v1[0] = quadraticAt(x0, x1, x2, _t);
	            _v1[1] = quadraticAt(y0, y1, y2, _t);
	            var d1 = v2DistSquare(_v0, _v1);
	            if (d1 < d) {
	                t = _t;
	                d = d1;
	            }
	        }
	        d = Infinity;
	
	        // At most 32 iteration
	        for (var i = 0; i < 32; i++) {
	            if (interval < EPSILON_NUMERIC) {
	                break;
	            }
	            var prev = t - interval;
	            var next = t + interval;
	            // t - interval
	            _v1[0] = quadraticAt(x0, x1, x2, prev);
	            _v1[1] = quadraticAt(y0, y1, y2, prev);
	
	            var d1 = v2DistSquare(_v1, _v0);
	
	            if (prev >= 0 && d1 < d) {
	                t = prev;
	                d = d1;
	            }
	            else {
	                // t + interval
	                _v2[0] = quadraticAt(x0, x1, x2, next);
	                _v2[1] = quadraticAt(y0, y1, y2, next);
	                var d2 = v2DistSquare(_v2, _v0);
	                if (next <= 1 && d2 < d) {
	                    t = next;
	                    d = d2;
	                }
	                else {
	                    interval *= 0.5;
	                }
	            }
	        }
	        // t
	        if (out) {
	            out[0] = quadraticAt(x0, x1, x2, t);
	            out[1] = quadraticAt(y0, y1, y2, t);
	        }
	        // console.log(interval, i);
	        return mathSqrt(d);
	    }
	
	    module.exports = {
	
	        cubicAt: cubicAt,
	
	        cubicDerivativeAt: cubicDerivativeAt,
	
	        cubicRootAt: cubicRootAt,
	
	        cubicExtrema: cubicExtrema,
	
	        cubicSubdivide: cubicSubdivide,
	
	        cubicProjectPoint: cubicProjectPoint,
	
	        quadraticAt: quadraticAt,
	
	        quadraticDerivativeAt: quadraticDerivativeAt,
	
	        quadraticRootAt: quadraticRootAt,
	
	        quadraticExtremum: quadraticExtremum,
	
	        quadraticSubdivide: quadraticSubdivide,
	
	        quadraticProjectPoint: quadraticProjectPoint
	    };


/***/ },
/* 27 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @author Yi Shen(https://github.com/pissang)
	 */
	
	
	    var vec2 = __webpack_require__(14);
	    var curve = __webpack_require__(26);
	
	    var bbox = {};
	    var mathMin = Math.min;
	    var mathMax = Math.max;
	    var mathSin = Math.sin;
	    var mathCos = Math.cos;
	
	    var start = vec2.create();
	    var end = vec2.create();
	    var extremity = vec2.create();
	
	    var PI2 = Math.PI * 2;
	    /**
	     * 从顶点数组中计算出最小包围盒，写入`min`和`max`中
	     * @module zrender/core/bbox
	     * @param {Array<Object>} points 顶点数组
	     * @param {number} min
	     * @param {number} max
	     */
	    bbox.fromPoints = function(points, min, max) {
	        if (points.length === 0) {
	            return;
	        }
	        var p = points[0];
	        var left = p[0];
	        var right = p[0];
	        var top = p[1];
	        var bottom = p[1];
	        var i;
	
	        for (i = 1; i < points.length; i++) {
	            p = points[i];
	            left = mathMin(left, p[0]);
	            right = mathMax(right, p[0]);
	            top = mathMin(top, p[1]);
	            bottom = mathMax(bottom, p[1]);
	        }
	
	        min[0] = left;
	        min[1] = top;
	        max[0] = right;
	        max[1] = bottom;
	    };
	
	    /**
	     * @memberOf module:zrender/core/bbox
	     * @param {number} x0
	     * @param {number} y0
	     * @param {number} x1
	     * @param {number} y1
	     * @param {Array.<number>} min
	     * @param {Array.<number>} max
	     */
	    bbox.fromLine = function (x0, y0, x1, y1, min, max) {
	        min[0] = mathMin(x0, x1);
	        min[1] = mathMin(y0, y1);
	        max[0] = mathMax(x0, x1);
	        max[1] = mathMax(y0, y1);
	    };
	
	    var xDim = [];
	    var yDim = [];
	    /**
	     * 从三阶贝塞尔曲线(p0, p1, p2, p3)中计算出最小包围盒，写入`min`和`max`中
	     * @memberOf module:zrender/core/bbox
	     * @param {number} x0
	     * @param {number} y0
	     * @param {number} x1
	     * @param {number} y1
	     * @param {number} x2
	     * @param {number} y2
	     * @param {number} x3
	     * @param {number} y3
	     * @param {Array.<number>} min
	     * @param {Array.<number>} max
	     */
	    bbox.fromCubic = function(
	        x0, y0, x1, y1, x2, y2, x3, y3, min, max
	    ) {
	        var cubicExtrema = curve.cubicExtrema;
	        var cubicAt = curve.cubicAt;
	        var i;
	        var n = cubicExtrema(x0, x1, x2, x3, xDim);
	        min[0] = Infinity;
	        min[1] = Infinity;
	        max[0] = -Infinity;
	        max[1] = -Infinity;
	
	        for (i = 0; i < n; i++) {
	            var x = cubicAt(x0, x1, x2, x3, xDim[i]);
	            min[0] = mathMin(x, min[0]);
	            max[0] = mathMax(x, max[0]);
	        }
	        n = cubicExtrema(y0, y1, y2, y3, yDim);
	        for (i = 0; i < n; i++) {
	            var y = cubicAt(y0, y1, y2, y3, yDim[i]);
	            min[1] = mathMin(y, min[1]);
	            max[1] = mathMax(y, max[1]);
	        }
	
	        min[0] = mathMin(x0, min[0]);
	        max[0] = mathMax(x0, max[0]);
	        min[0] = mathMin(x3, min[0]);
	        max[0] = mathMax(x3, max[0]);
	
	        min[1] = mathMin(y0, min[1]);
	        max[1] = mathMax(y0, max[1]);
	        min[1] = mathMin(y3, min[1]);
	        max[1] = mathMax(y3, max[1]);
	    };
	
	    /**
	     * 从二阶贝塞尔曲线(p0, p1, p2)中计算出最小包围盒，写入`min`和`max`中
	     * @memberOf module:zrender/core/bbox
	     * @param {number} x0
	     * @param {number} y0
	     * @param {number} x1
	     * @param {number} y1
	     * @param {number} x2
	     * @param {number} y2
	     * @param {Array.<number>} min
	     * @param {Array.<number>} max
	     */
	    bbox.fromQuadratic = function(x0, y0, x1, y1, x2, y2, min, max) {
	        var quadraticExtremum = curve.quadraticExtremum;
	        var quadraticAt = curve.quadraticAt;
	        // Find extremities, where derivative in x dim or y dim is zero
	        var tx =
	            mathMax(
	                mathMin(quadraticExtremum(x0, x1, x2), 1), 0
	            );
	        var ty =
	            mathMax(
	                mathMin(quadraticExtremum(y0, y1, y2), 1), 0
	            );
	
	        var x = quadraticAt(x0, x1, x2, tx);
	        var y = quadraticAt(y0, y1, y2, ty);
	
	        min[0] = mathMin(x0, x2, x);
	        min[1] = mathMin(y0, y2, y);
	        max[0] = mathMax(x0, x2, x);
	        max[1] = mathMax(y0, y2, y);
	    };
	
	    /**
	     * 从圆弧中计算出最小包围盒，写入`min`和`max`中
	     * @method
	     * @memberOf module:zrender/core/bbox
	     * @param {number} x
	     * @param {number} y
	     * @param {number} rx
	     * @param {number} ry
	     * @param {number} startAngle
	     * @param {number} endAngle
	     * @param {number} anticlockwise
	     * @param {Array.<number>} min
	     * @param {Array.<number>} max
	     */
	    bbox.fromArc = function (
	        x, y, rx, ry, startAngle, endAngle, anticlockwise, min, max
	    ) {
	        var vec2Min = vec2.min;
	        var vec2Max = vec2.max;
	
	        var diff = Math.abs(startAngle - endAngle);
	
	
	        if (diff % PI2 < 1e-4 && diff > 1e-4) {
	            // Is a circle
	            min[0] = x - rx;
	            min[1] = y - ry;
	            max[0] = x + rx;
	            max[1] = y + ry;
	            return;
	        }
	
	        start[0] = mathCos(startAngle) * rx + x;
	        start[1] = mathSin(startAngle) * ry + y;
	
	        end[0] = mathCos(endAngle) * rx + x;
	        end[1] = mathSin(endAngle) * ry + y;
	
	        vec2Min(min, start, end);
	        vec2Max(max, start, end);
	
	        // Thresh to [0, Math.PI * 2]
	        startAngle = startAngle % (PI2);
	        if (startAngle < 0) {
	            startAngle = startAngle + PI2;
	        }
	        endAngle = endAngle % (PI2);
	        if (endAngle < 0) {
	            endAngle = endAngle + PI2;
	        }
	
	        if (startAngle > endAngle && !anticlockwise) {
	            endAngle += PI2;
	        }
	        else if (startAngle < endAngle && anticlockwise) {
	            startAngle += PI2;
	        }
	        if (anticlockwise) {
	            var tmp = endAngle;
	            endAngle = startAngle;
	            startAngle = tmp;
	        }
	
	        // var number = 0;
	        // var step = (anticlockwise ? -Math.PI : Math.PI) / 2;
	        for (var angle = 0; angle < endAngle; angle += Math.PI / 2) {
	            if (angle > startAngle) {
	                extremity[0] = mathCos(angle) * rx + x;
	                extremity[1] = mathSin(angle) * ry + y;
	
	                vec2Min(min, extremity, min);
	                vec2Max(max, extremity, max);
	            }
	        }
	    };
	
	    module.exports = bbox;
	


/***/ },
/* 28 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	
	    var CMD = __webpack_require__(25).CMD;
	    var line = __webpack_require__(29);
	    var cubic = __webpack_require__(30);
	    var quadratic = __webpack_require__(31);
	    var arc = __webpack_require__(32);
	    var normalizeRadian = __webpack_require__(33).normalizeRadian;
	    var curve = __webpack_require__(26);
	
	    var windingLine = __webpack_require__(34);
	
	    var containStroke = line.containStroke;
	
	    var PI2 = Math.PI * 2;
	
	    var EPSILON = 1e-4;
	
	    function isAroundEqual(a, b) {
	        return Math.abs(a - b) < EPSILON;
	    }
	
	    // 临时数组
	    var roots = [-1, -1, -1];
	    var extrema = [-1, -1];
	
	    function swapExtrema() {
	        var tmp = extrema[0];
	        extrema[0] = extrema[1];
	        extrema[1] = tmp;
	    }
	
	    function windingCubic(x0, y0, x1, y1, x2, y2, x3, y3, x, y) {
	        // Quick reject
	        if (
	            (y > y0 && y > y1 && y > y2 && y > y3)
	            || (y < y0 && y < y1 && y < y2 && y < y3)
	        ) {
	            return 0;
	        }
	        var nRoots = curve.cubicRootAt(y0, y1, y2, y3, y, roots);
	        if (nRoots === 0) {
	            return 0;
	        }
	        else {
	            var w = 0;
	            var nExtrema = -1;
	            var y0_, y1_;
	            for (var i = 0; i < nRoots; i++) {
	                var t = roots[i];
	
	                // Avoid winding error when intersection point is the connect point of two line of polygon
	                var unit = (t === 0 || t === 1) ? 0.5 : 1;
	
	                var x_ = curve.cubicAt(x0, x1, x2, x3, t);
	                if (x_ < x) { // Quick reject
	                    continue;
	                }
	                if (nExtrema < 0) {
	                    nExtrema = curve.cubicExtrema(y0, y1, y2, y3, extrema);
	                    if (extrema[1] < extrema[0] && nExtrema > 1) {
	                        swapExtrema();
	                    }
	                    y0_ = curve.cubicAt(y0, y1, y2, y3, extrema[0]);
	                    if (nExtrema > 1) {
	                        y1_ = curve.cubicAt(y0, y1, y2, y3, extrema[1]);
	                    }
	                }
	                if (nExtrema == 2) {
	                    // 分成三段单调函数
	                    if (t < extrema[0]) {
	                        w += y0_ < y0 ? unit : -unit;
	                    }
	                    else if (t < extrema[1]) {
	                        w += y1_ < y0_ ? unit : -unit;
	                    }
	                    else {
	                        w += y3 < y1_ ? unit : -unit;
	                    }
	                }
	                else {
	                    // 分成两段单调函数
	                    if (t < extrema[0]) {
	                        w += y0_ < y0 ? unit : -unit;
	                    }
	                    else {
	                        w += y3 < y0_ ? unit : -unit;
	                    }
	                }
	            }
	            return w;
	        }
	    }
	
	    function windingQuadratic(x0, y0, x1, y1, x2, y2, x, y) {
	        // Quick reject
	        if (
	            (y > y0 && y > y1 && y > y2)
	            || (y < y0 && y < y1 && y < y2)
	        ) {
	            return 0;
	        }
	        var nRoots = curve.quadraticRootAt(y0, y1, y2, y, roots);
	        if (nRoots === 0) {
	            return 0;
	        }
	        else {
	            var t = curve.quadraticExtremum(y0, y1, y2);
	            if (t >= 0 && t <= 1) {
	                var w = 0;
	                var y_ = curve.quadraticAt(y0, y1, y2, t);
	                for (var i = 0; i < nRoots; i++) {
	                    // Remove one endpoint.
	                    var unit = (roots[i] === 0 || roots[i] === 1) ? 0.5 : 1;
	
	                    var x_ = curve.quadraticAt(x0, x1, x2, roots[i]);
	                    if (x_ < x) {   // Quick reject
	                        continue;
	                    }
	                    if (roots[i] < t) {
	                        w += y_ < y0 ? unit : -unit;
	                    }
	                    else {
	                        w += y2 < y_ ? unit : -unit;
	                    }
	                }
	                return w;
	            }
	            else {
	                // Remove one endpoint.
	                var unit = (roots[0] === 0 || roots[0] === 1) ? 0.5 : 1;
	
	                var x_ = curve.quadraticAt(x0, x1, x2, roots[0]);
	                if (x_ < x) {   // Quick reject
	                    return 0;
	                }
	                return y2 < y0 ? unit : -unit;
	            }
	        }
	    }
	
	    // TODO
	    // Arc 旋转
	    function windingArc(
	        cx, cy, r, startAngle, endAngle, anticlockwise, x, y
	    ) {
	        y -= cy;
	        if (y > r || y < -r) {
	            return 0;
	        }
	        var tmp = Math.sqrt(r * r - y * y);
	        roots[0] = -tmp;
	        roots[1] = tmp;
	
	        var diff = Math.abs(startAngle - endAngle);
	        if (diff < 1e-4) {
	            return 0;
	        }
	        if (diff % PI2 < 1e-4) {
	            // Is a circle
	            startAngle = 0;
	            endAngle = PI2;
	            var dir = anticlockwise ? 1 : -1;
	            if (x >= roots[0] + cx && x <= roots[1] + cx) {
	                return dir;
	            } else {
	                return 0;
	            }
	        }
	
	        if (anticlockwise) {
	            var tmp = startAngle;
	            startAngle = normalizeRadian(endAngle);
	            endAngle = normalizeRadian(tmp);
	        }
	        else {
	            startAngle = normalizeRadian(startAngle);
	            endAngle = normalizeRadian(endAngle);
	        }
	        if (startAngle > endAngle) {
	            endAngle += PI2;
	        }
	
	        var w = 0;
	        for (var i = 0; i < 2; i++) {
	            var x_ = roots[i];
	            if (x_ + cx > x) {
	                var angle = Math.atan2(y, x_);
	                var dir = anticlockwise ? 1 : -1;
	                if (angle < 0) {
	                    angle = PI2 + angle;
	                }
	                if (
	                    (angle >= startAngle && angle <= endAngle)
	                    || (angle + PI2 >= startAngle && angle + PI2 <= endAngle)
	                ) {
	                    if (angle > Math.PI / 2 && angle < Math.PI * 1.5) {
	                        dir = -dir;
	                    }
	                    w += dir;
	                }
	            }
	        }
	        return w;
	    }
	
	    function containPath(data, lineWidth, isStroke, x, y) {
	        var w = 0;
	        var xi = 0;
	        var yi = 0;
	        var x0 = 0;
	        var y0 = 0;
	
	        for (var i = 0; i < data.length;) {
	            var cmd = data[i++];
	            // Begin a new subpath
	            if (cmd === CMD.M && i > 1) {
	                // Close previous subpath
	                if (!isStroke) {
	                    w += windingLine(xi, yi, x0, y0, x, y);
	                }
	                // 如果被任何一个 subpath 包含
	                // if (w !== 0) {
	                //     return true;
	                // }
	            }
	
	            if (i == 1) {
	                // 如果第一个命令是 L, C, Q
	                // 则 previous point 同绘制命令的第一个 point
	                //
	                // 第一个命令为 Arc 的情况下会在后面特殊处理
	                xi = data[i];
	                yi = data[i + 1];
	
	                x0 = xi;
	                y0 = yi;
	            }
	
	            switch (cmd) {
	                case CMD.M:
	                    // moveTo 命令重新创建一个新的 subpath, 并且更新新的起点
	                    // 在 closePath 的时候使用
	                    x0 = data[i++];
	                    y0 = data[i++];
	                    xi = x0;
	                    yi = y0;
	                    break;
	                case CMD.L:
	                    if (isStroke) {
	                        if (containStroke(xi, yi, data[i], data[i + 1], lineWidth, x, y)) {
	                            return true;
	                        }
	                    }
	                    else {
	                        // NOTE 在第一个命令为 L, C, Q 的时候会计算出 NaN
	                        w += windingLine(xi, yi, data[i], data[i + 1], x, y) || 0;
	                    }
	                    xi = data[i++];
	                    yi = data[i++];
	                    break;
	                case CMD.C:
	                    if (isStroke) {
	                        if (cubic.containStroke(xi, yi,
	                            data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1],
	                            lineWidth, x, y
	                        )) {
	                            return true;
	                        }
	                    }
	                    else {
	                        w += windingCubic(
	                            xi, yi,
	                            data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1],
	                            x, y
	                        ) || 0;
	                    }
	                    xi = data[i++];
	                    yi = data[i++];
	                    break;
	                case CMD.Q:
	                    if (isStroke) {
	                        if (quadratic.containStroke(xi, yi,
	                            data[i++], data[i++], data[i], data[i + 1],
	                            lineWidth, x, y
	                        )) {
	                            return true;
	                        }
	                    }
	                    else {
	                        w += windingQuadratic(
	                            xi, yi,
	                            data[i++], data[i++], data[i], data[i + 1],
	                            x, y
	                        ) || 0;
	                    }
	                    xi = data[i++];
	                    yi = data[i++];
	                    break;
	                case CMD.A:
	                    // TODO Arc 判断的开销比较大
	                    var cx = data[i++];
	                    var cy = data[i++];
	                    var rx = data[i++];
	                    var ry = data[i++];
	                    var theta = data[i++];
	                    var dTheta = data[i++];
	                    // TODO Arc 旋转
	                    var psi = data[i++];
	                    var anticlockwise = 1 - data[i++];
	                    var x1 = Math.cos(theta) * rx + cx;
	                    var y1 = Math.sin(theta) * ry + cy;
	                    // 不是直接使用 arc 命令
	                    if (i > 1) {
	                        w += windingLine(xi, yi, x1, y1, x, y);
	                    }
	                    else {
	                        // 第一个命令起点还未定义
	                        x0 = x1;
	                        y0 = y1;
	                    }
	                    // zr 使用scale来模拟椭圆, 这里也对x做一定的缩放
	                    var _x = (x - cx) * ry / rx + cx;
	                    if (isStroke) {
	                        if (arc.containStroke(
	                            cx, cy, ry, theta, theta + dTheta, anticlockwise,
	                            lineWidth, _x, y
	                        )) {
	                            return true;
	                        }
	                    }
	                    else {
	                        w += windingArc(
	                            cx, cy, ry, theta, theta + dTheta, anticlockwise,
	                            _x, y
	                        );
	                    }
	                    xi = Math.cos(theta + dTheta) * rx + cx;
	                    yi = Math.sin(theta + dTheta) * ry + cy;
	                    break;
	                case CMD.R:
	                    x0 = xi = data[i++];
	                    y0 = yi = data[i++];
	                    var width = data[i++];
	                    var height = data[i++];
	                    var x1 = x0 + width;
	                    var y1 = y0 + height;
	                    if (isStroke) {
	                        if (containStroke(x0, y0, x1, y0, lineWidth, x, y)
	                          || containStroke(x1, y0, x1, y1, lineWidth, x, y)
	                          || containStroke(x1, y1, x0, y1, lineWidth, x, y)
	                          || containStroke(x0, y1, x0, y0, lineWidth, x, y)
	                        ) {
	                            return true;
	                        }
	                    }
	                    else {
	                        // FIXME Clockwise ?
	                        w += windingLine(x1, y0, x1, y1, x, y);
	                        w += windingLine(x0, y1, x0, y0, x, y);
	                    }
	                    break;
	                case CMD.Z:
	                    if (isStroke) {
	                        if (containStroke(
	                            xi, yi, x0, y0, lineWidth, x, y
	                        )) {
	                            return true;
	                        }
	                    }
	                    else {
	                        // Close a subpath
	                        w += windingLine(xi, yi, x0, y0, x, y);
	                        // 如果被任何一个 subpath 包含
	                        // FIXME subpaths may overlap
	                        // if (w !== 0) {
	                        //     return true;
	                        // }
	                    }
	                    xi = x0;
	                    yi = y0;
	                    break;
	            }
	        }
	        if (!isStroke && !isAroundEqual(yi, y0)) {
	            w += windingLine(xi, yi, x0, y0, x, y) || 0;
	        }
	        return w !== 0;
	    }
	
	    module.exports = {
	        contain: function (pathData, x, y) {
	            return containPath(pathData, 0, false, x, y);
	        },
	
	        containStroke: function (pathData, lineWidth, x, y) {
	            return containPath(pathData, lineWidth, true, x, y);
	        }
	    };


/***/ },
/* 29 */
/***/ function(module, exports) {

	
	    module.exports = {
	        /**
	         * 线段包含判断
	         * @param  {number}  x0
	         * @param  {number}  y0
	         * @param  {number}  x1
	         * @param  {number}  y1
	         * @param  {number}  lineWidth
	         * @param  {number}  x
	         * @param  {number}  y
	         * @return {boolean}
	         */
	        containStroke: function (x0, y0, x1, y1, lineWidth, x, y) {
	            if (lineWidth === 0) {
	                return false;
	            }
	            var _l = lineWidth;
	            var _a = 0;
	            var _b = x0;
	            // Quick reject
	            if (
	                (y > y0 + _l && y > y1 + _l)
	                || (y < y0 - _l && y < y1 - _l)
	                || (x > x0 + _l && x > x1 + _l)
	                || (x < x0 - _l && x < x1 - _l)
	            ) {
	                return false;
	            }
	
	            if (x0 !== x1) {
	                _a = (y0 - y1) / (x0 - x1);
	                _b = (x0 * y1 - x1 * y0) / (x0 - x1) ;
	            }
	            else {
	                return Math.abs(x - x0) <= _l / 2;
	            }
	            var tmp = _a * x - y + _b;
	            var _s = tmp * tmp / (_a * _a + 1);
	            return _s <= _l / 2 * _l / 2;
	        }
	    };


/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

	
	
	    var curve = __webpack_require__(26);
	
	    module.exports = {
	        /**
	         * 三次贝塞尔曲线描边包含判断
	         * @param  {number}  x0
	         * @param  {number}  y0
	         * @param  {number}  x1
	         * @param  {number}  y1
	         * @param  {number}  x2
	         * @param  {number}  y2
	         * @param  {number}  x3
	         * @param  {number}  y3
	         * @param  {number}  lineWidth
	         * @param  {number}  x
	         * @param  {number}  y
	         * @return {boolean}
	         */
	        containStroke: function(x0, y0, x1, y1, x2, y2, x3, y3, lineWidth, x, y) {
	            if (lineWidth === 0) {
	                return false;
	            }
	            var _l = lineWidth;
	            // Quick reject
	            if (
	                (y > y0 + _l && y > y1 + _l && y > y2 + _l && y > y3 + _l)
	                || (y < y0 - _l && y < y1 - _l && y < y2 - _l && y < y3 - _l)
	                || (x > x0 + _l && x > x1 + _l && x > x2 + _l && x > x3 + _l)
	                || (x < x0 - _l && x < x1 - _l && x < x2 - _l && x < x3 - _l)
	            ) {
	                return false;
	            }
	            var d = curve.cubicProjectPoint(
	                x0, y0, x1, y1, x2, y2, x3, y3,
	                x, y, null
	            );
	            return d <= _l / 2;
	        }
	    };


/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	
	
	    var curve = __webpack_require__(26);
	
	    module.exports = {
	        /**
	         * 二次贝塞尔曲线描边包含判断
	         * @param  {number}  x0
	         * @param  {number}  y0
	         * @param  {number}  x1
	         * @param  {number}  y1
	         * @param  {number}  x2
	         * @param  {number}  y2
	         * @param  {number}  lineWidth
	         * @param  {number}  x
	         * @param  {number}  y
	         * @return {boolean}
	         */
	        containStroke: function (x0, y0, x1, y1, x2, y2, lineWidth, x, y) {
	            if (lineWidth === 0) {
	                return false;
	            }
	            var _l = lineWidth;
	            // Quick reject
	            if (
	                (y > y0 + _l && y > y1 + _l && y > y2 + _l)
	                || (y < y0 - _l && y < y1 - _l && y < y2 - _l)
	                || (x > x0 + _l && x > x1 + _l && x > x2 + _l)
	                || (x < x0 - _l && x < x1 - _l && x < x2 - _l)
	            ) {
	                return false;
	            }
	            var d = curve.quadraticProjectPoint(
	                x0, y0, x1, y1, x2, y2,
	                x, y, null
	            );
	            return d <= _l / 2;
	        }
	    };


/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

	
	
	    var normalizeRadian = __webpack_require__(33).normalizeRadian;
	    var PI2 = Math.PI * 2;
	
	    module.exports = {
	        /**
	         * 圆弧描边包含判断
	         * @param  {number}  cx
	         * @param  {number}  cy
	         * @param  {number}  r
	         * @param  {number}  startAngle
	         * @param  {number}  endAngle
	         * @param  {boolean}  anticlockwise
	         * @param  {number} lineWidth
	         * @param  {number}  x
	         * @param  {number}  y
	         * @return {Boolean}
	         */
	        containStroke: function (
	            cx, cy, r, startAngle, endAngle, anticlockwise,
	            lineWidth, x, y
	        ) {
	
	            if (lineWidth === 0) {
	                return false;
	            }
	            var _l = lineWidth;
	
	            x -= cx;
	            y -= cy;
	            var d = Math.sqrt(x * x + y * y);
	
	            if ((d - _l > r) || (d + _l < r)) {
	                return false;
	            }
	            if (Math.abs(startAngle - endAngle) % PI2 < 1e-4) {
	                // Is a circle
	                return true;
	            }
	            if (anticlockwise) {
	                var tmp = startAngle;
	                startAngle = normalizeRadian(endAngle);
	                endAngle = normalizeRadian(tmp);
	            } else {
	                startAngle = normalizeRadian(startAngle);
	                endAngle = normalizeRadian(endAngle);
	            }
	            if (startAngle > endAngle) {
	                endAngle += PI2;
	            }
	
	            var angle = Math.atan2(y, x);
	            if (angle < 0) {
	                angle += PI2;
	            }
	            return (angle >= startAngle && angle <= endAngle)
	                || (angle + PI2 >= startAngle && angle + PI2 <= endAngle);
	        }
	    };


/***/ },
/* 33 */
/***/ function(module, exports) {

	
	
	    var PI2 = Math.PI * 2;
	    module.exports = {
	        normalizeRadian: function(angle) {
	            angle %= PI2;
	            if (angle < 0) {
	                angle += PI2;
	            }
	            return angle;
	        }
	    };


/***/ },
/* 34 */
/***/ function(module, exports) {

	
	    module.exports = function windingLine(x0, y0, x1, y1, x, y) {
	        if ((y > y0 && y > y1) || (y < y0 && y < y1)) {
	            return 0;
	        }
	        // Ignore horizontal line
	        if (y1 === y0) {
	            return 0;
	        }
	        var dir = y1 < y0 ? 1 : -1;
	        var t = (y - y0) / (y1 - y0);
	
	        // Avoid winding error when intersection point is the connect point of two line of polygon
	        if (t === 1 || t === 0) {
	            dir = y1 < y0 ? 0.5 : -0.5;
	        }
	
	        var x_ = t * (x1 - x0) + x0;
	
	        return x_ > x ? dir : 0;
	    };


/***/ },
/* 35 */
/***/ function(module, exports) {

	
	
	    var Pattern = function (image, repeat) {
	        this.image = image;
	        this.repeat = repeat;
	
	        // Can be cloned
	        this.type = 'pattern';
	    };
	
	    Pattern.prototype.getCanvasPattern = function (ctx) {
	
	        return this._canvasPattern
	            || (this._canvasPattern = ctx.createPattern(this.image, this.repeat));
	    };
	
	    module.exports = Pattern;


/***/ },
/* 36 */
/***/ function(module, exports, __webpack_require__) {

	
	
	    var CMD = __webpack_require__(25).CMD;
	    var vec2 = __webpack_require__(14);
	    var v2ApplyTransform = vec2.applyTransform;
	
	    var points = [[], [], []];
	    var mathSqrt = Math.sqrt;
	    var mathAtan2 = Math.atan2;
	    function transformPath(path, m) {
	        var data = path.data;
	        var cmd;
	        var nPoint;
	        var i;
	        var j;
	        var k;
	        var p;
	
	        var M = CMD.M;
	        var C = CMD.C;
	        var L = CMD.L;
	        var R = CMD.R;
	        var A = CMD.A;
	        var Q = CMD.Q;
	
	        for (i = 0, j = 0; i < data.length;) {
	            cmd = data[i++];
	            j = i;
	            nPoint = 0;
	
	            switch (cmd) {
	                case M:
	                    nPoint = 1;
	                    break;
	                case L:
	                    nPoint = 1;
	                    break;
	                case C:
	                    nPoint = 3;
	                    break;
	                case Q:
	                    nPoint = 2;
	                    break;
	                case A:
	                    var x = m[4];
	                    var y = m[5];
	                    var sx = mathSqrt(m[0] * m[0] + m[1] * m[1]);
	                    var sy = mathSqrt(m[2] * m[2] + m[3] * m[3]);
	                    var angle = mathAtan2(-m[1] / sy, m[0] / sx);
	                    // cx
	                    data[i++] += x;
	                    // cy
	                    data[i++] += y;
	                    // Scale rx and ry
	                    // FIXME Assume psi is 0 here
	                    data[i++] *= sx;
	                    data[i++] *= sy;
	
	                    // Start angle
	                    data[i++] += angle;
	                    // end angle
	                    data[i++] += angle;
	                    // FIXME psi
	                    i += 2;
	                    j = i;
	                    break;
	                case R:
	                    // x0, y0
	                    p[0] = data[i++];
	                    p[1] = data[i++];
	                    v2ApplyTransform(p, p, m);
	                    data[j++] = p[0];
	                    data[j++] = p[1];
	                    // x1, y1
	                    p[0] += data[i++];
	                    p[1] += data[i++];
	                    v2ApplyTransform(p, p, m);
	                    data[j++] = p[0];
	                    data[j++] = p[1];
	            }
	
	            for (k = 0; k < nPoint; k++) {
	                var p = points[k];
	                p[0] = data[i++];
	                p[1] = data[i++];
	
	                v2ApplyTransform(p, p, m);
	                // Write back
	                data[j++] = p[0];
	                data[j++] = p[1];
	            }
	        }
	    }
	
	    module.exports = transformPath;


/***/ },
/* 37 */
/***/ function(module, exports) {

	
	
	    /**
	     * @param {Array.<Object>} colorStops
	     */
	    var Gradient = function (colorStops) {
	
	        this.colorStops = colorStops || [];
	    };
	
	    Gradient.prototype = {
	
	        constructor: Gradient,
	
	        addColorStop: function (offset, color) {
	            this.colorStops.push({
	
	                offset: offset,
	
	                color: color
	            });
	        }
	    };
	
	    module.exports = Gradient;


/***/ },
/* 38 */
/***/ function(module, exports) {

	// TODO Draggable for group
	// FIXME Draggable on element which has parent rotation or scale
	
	    function Draggable() {
	
	        this.on('mousedown', this._dragStart, this);
	        this.on('mousemove', this._drag, this);
	        this.on('mouseup', this._dragEnd, this);
	        this.on('globalout', this._dragEnd, this);
	        // this._dropTarget = null;
	        // this._draggingTarget = null;
	
	        // this._x = 0;
	        // this._y = 0;
	    }
	
	    Draggable.prototype = {
	
	        constructor: Draggable,
	
	        _dragStart: function (e) {
	            var draggingTarget = e.target;
	            if (draggingTarget && draggingTarget.draggable) {
	                this._draggingTarget = draggingTarget;
	                draggingTarget.dragging = true;
	                this._x = e.offsetX;
	                this._y = e.offsetY;
	
	                this.dispatchToElement(draggingTarget, 'dragstart', e.event);
	            }
	        },
	
	        _drag: function (e) {
	            var draggingTarget = this._draggingTarget;
	            if (draggingTarget) {
	
	                var x = e.offsetX;
	                var y = e.offsetY;
	
	                var dx = x - this._x;
	                var dy = y - this._y;
	                this._x = x;
	                this._y = y;
	
	                draggingTarget.drift(dx, dy, e);
	                this.dispatchToElement(draggingTarget, 'drag', e.event);
	
	                var dropTarget = this.findHover(x, y, draggingTarget);
	                var lastDropTarget = this._dropTarget;
	                this._dropTarget = dropTarget;
	
	                if (draggingTarget !== dropTarget) {
	                    if (lastDropTarget && dropTarget !== lastDropTarget) {
	                        this.dispatchToElement(lastDropTarget, 'dragleave', e.event);
	                    }
	                    if (dropTarget && dropTarget !== lastDropTarget) {
	                        this.dispatchToElement(dropTarget, 'dragenter', e.event);
	                    }
	                }
	            }
	        },
	
	        _dragEnd: function (e) {
	            var draggingTarget = this._draggingTarget;
	
	            if (draggingTarget) {
	                draggingTarget.dragging = false;
	            }
	
	            this.dispatchToElement(draggingTarget, 'dragend', e.event);
	
	            if (this._dropTarget) {
	                this.dispatchToElement(this._dropTarget, 'drop', e.event);
	            }
	
	            this._draggingTarget = null;
	            this._dropTarget = null;
	        }
	
	    };
	
	    module.exports = Draggable;


/***/ },
/* 39 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Group是一个容器，可以插入子节点，Group的变换也会被应用到子节点上
	 * @module zrender/graphic/Group
	 * @example
	 *     var Group = require('zrender/lib/container/Group');
	 *     var Circle = require('zrender/lib/graphic/shape/Circle');
	 *     var g = new Group();
	 *     g.position[0] = 100;
	 *     g.position[1] = 100;
	 *     g.add(new Circle({
	 *         style: {
	 *             x: 100,
	 *             y: 100,
	 *             r: 20,
	 *         }
	 *     }));
	 *     zr.add(g);
	 */
	
	
	    var zrUtil = __webpack_require__(4);
	    var Element = __webpack_require__(9);
	    var BoundingRect = __webpack_require__(24);
	
	    /**
	     * @alias module:zrender/graphic/Group
	     * @constructor
	     * @extends module:zrender/mixin/Transformable
	     * @extends module:zrender/mixin/Eventful
	     */
	    var Group = function (opts) {
	
	        opts = opts || {};
	
	        Element.call(this, opts);
	
	        for (var key in opts) {
	            this[key] = opts[key];
	        }
	
	        this._children = [];
	
	        this.__storage = null;
	
	        this.__dirty = true;
	    };
	
	    Group.prototype = {
	
	        constructor: Group,
	
	        isGroup: true,
	
	        /**
	         * @type {string}
	         */
	        type: 'group',
	
	        /**
	         * 所有子孙元素是否响应鼠标事件
	         * @name module:/zrender/container/Group#silent
	         * @type {boolean}
	         * @default false
	         */
	        silent: false,
	
	        /**
	         * @return {Array.<module:zrender/Element>}
	         */
	        children: function () {
	            return this._children.slice();
	        },
	
	        /**
	         * 获取指定 index 的儿子节点
	         * @param  {number} idx
	         * @return {module:zrender/Element}
	         */
	        childAt: function (idx) {
	            return this._children[idx];
	        },
	
	        /**
	         * 获取指定名字的儿子节点
	         * @param  {string} name
	         * @return {module:zrender/Element}
	         */
	        childOfName: function (name) {
	            var children = this._children;
	            for (var i = 0; i < children.length; i++) {
	                if (children[i].name === name) {
	                    return children[i];
	                }
	             }
	        },
	
	        /**
	         * @return {number}
	         */
	        childCount: function () {
	            return this._children.length;
	        },
	
	        /**
	         * 添加子节点到最后
	         * @param {module:zrender/Element} child
	         */
	        add: function (child) {
	            if (child && child !== this && child.parent !== this) {
	
	                this._children.push(child);
	
	                this._doAdd(child);
	            }
	
	            return this;
	        },
	
	        /**
	         * 添加子节点在 nextSibling 之前
	         * @param {module:zrender/Element} child
	         * @param {module:zrender/Element} nextSibling
	         */
	        addBefore: function (child, nextSibling) {
	            if (child && child !== this && child.parent !== this
	                && nextSibling && nextSibling.parent === this) {
	
	                var children = this._children;
	                var idx = children.indexOf(nextSibling);
	
	                if (idx >= 0) {
	                    children.splice(idx, 0, child);
	                    this._doAdd(child);
	                }
	            }
	
	            return this;
	        },
	
	        _doAdd: function (child) {
	            if (child.parent) {
	                child.parent.remove(child);
	            }
	
	            child.parent = this;
	
	            var storage = this.__storage;
	            var zr = this.__zr;
	            if (storage && storage !== child.__storage) {
	
	                storage.addToMap(child);
	
	                if (child instanceof Group) {
	                    child.addChildrenToStorage(storage);
	                }
	            }
	
	            zr && zr.refresh();
	        },
	
	        /**
	         * 移除子节点
	         * @param {module:zrender/Element} child
	         */
	        remove: function (child) {
	            var zr = this.__zr;
	            var storage = this.__storage;
	            var children = this._children;
	
	            var idx = zrUtil.indexOf(children, child);
	            if (idx < 0) {
	                return this;
	            }
	            children.splice(idx, 1);
	
	            child.parent = null;
	
	            if (storage) {
	
	                storage.delFromMap(child.id);
	
	                if (child instanceof Group) {
	                    child.delChildrenFromStorage(storage);
	                }
	            }
	
	            zr && zr.refresh();
	
	            return this;
	        },
	
	        /**
	         * 移除所有子节点
	         */
	        removeAll: function () {
	            var children = this._children;
	            var storage = this.__storage;
	            var child;
	            var i;
	            for (i = 0; i < children.length; i++) {
	                child = children[i];
	                if (storage) {
	                    storage.delFromMap(child.id);
	                    if (child instanceof Group) {
	                        child.delChildrenFromStorage(storage);
	                    }
	                }
	                child.parent = null;
	            }
	            children.length = 0;
	
	            return this;
	        },
	
	        /**
	         * 遍历所有子节点
	         * @param  {Function} cb
	         * @param  {}   context
	         */
	        eachChild: function (cb, context) {
	            var children = this._children;
	            for (var i = 0; i < children.length; i++) {
	                var child = children[i];
	                cb.call(context, child, i);
	            }
	            return this;
	        },
	
	        /**
	         * 深度优先遍历所有子孙节点
	         * @param  {Function} cb
	         * @param  {}   context
	         */
	        traverse: function (cb, context) {
	            for (var i = 0; i < this._children.length; i++) {
	                var child = this._children[i];
	                cb.call(context, child);
	
	                if (child.type === 'group') {
	                    child.traverse(cb, context);
	                }
	            }
	            return this;
	        },
	
	        addChildrenToStorage: function (storage) {
	            for (var i = 0; i < this._children.length; i++) {
	                var child = this._children[i];
	                storage.addToMap(child);
	                if (child instanceof Group) {
	                    child.addChildrenToStorage(storage);
	                }
	            }
	        },
	
	        delChildrenFromStorage: function (storage) {
	            for (var i = 0; i < this._children.length; i++) {
	                var child = this._children[i];
	                storage.delFromMap(child.id);
	                if (child instanceof Group) {
	                    child.delChildrenFromStorage(storage);
	                }
	            }
	        },
	
	        dirty: function () {
	            this.__dirty = true;
	            this.__zr && this.__zr.refresh();
	            return this;
	        },
	
	        /**
	         * @return {module:zrender/core/BoundingRect}
	         */
	        getBoundingRect: function (includeChildren) {
	            // TODO Caching
	            // TODO Transform
	            var rect = null;
	            var tmpRect = new BoundingRect(0, 0, 0, 0);
	            var children = includeChildren || this._children;
	            var tmpMat = [];
	
	            for (var i = 0; i < children.length; i++) {
	                var child = children[i];
	                if (child.ignore || child.invisible) {
	                    continue;
	                }
	
	                var childRect = child.getBoundingRect();
	                var transform = child.getLocalTransform(tmpMat);
	                if (transform) {
	                    tmpRect.copy(childRect);
	                    tmpRect.applyTransform(transform);
	                    rect = rect || tmpRect.clone();
	                    rect.union(tmpRect);
	                }
	                else {
	                    rect = rect || childRect.clone();
	                    rect.union(childRect);
	                }
	            }
	            return rect || tmpRect;
	        }
	    };
	
	    zrUtil.inherits(Group, Element);
	
	    module.exports = Group;


/***/ },
/* 40 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Image element
	 * @module zrender/graphic/Image
	 */
	
	
	
	    var Displayable = __webpack_require__(7);
	    var BoundingRect = __webpack_require__(24);
	    var zrUtil = __webpack_require__(4);
	
	    var LRU = __webpack_require__(41);
	    var globalImageCache = new LRU(50);
	    /**
	     * @alias zrender/graphic/Image
	     * @extends module:zrender/graphic/Displayable
	     * @constructor
	     * @param {Object} opts
	     */
	    function ZImage(opts) {
	        Displayable.call(this, opts);
	    }
	
	    ZImage.prototype = {
	
	        constructor: ZImage,
	
	        type: 'image',
	
	        brush: function (ctx, prevEl) {
	            var style = this.style;
	            var src = style.image;
	            var image;
	
	            // Must bind each time
	            style.bind(ctx, this, prevEl);
	            // style.image is a url string
	            if (typeof src === 'string') {
	                image = this._image;
	            }
	            // style.image is an HTMLImageElement or HTMLCanvasElement or Canvas
	            else {
	                image = src;
	            }
	            // FIXME Case create many images with src
	            if (!image && src) {
	                // Try get from global image cache
	                var cachedImgObj = globalImageCache.get(src);
	                if (!cachedImgObj) {
	                    // Create a new image
	                    image = new Image();
	                    image.onload = function () {
	                        image.onload = null;
	                        for (var i = 0; i < cachedImgObj.pending.length; i++) {
	                            cachedImgObj.pending[i].dirty();
	                        }
	                    };
	                    cachedImgObj = {
	                        image: image,
	                        pending: [this]
	                    };
	                    image.src = src;
	                    globalImageCache.put(src, cachedImgObj);
	                    this._image = image;
	                    return;
	                }
	                else {
	                    image = cachedImgObj.image;
	                    this._image = image;
	                    // Image is not complete finish, add to pending list
	                    if (!image.width || !image.height) {
	                        cachedImgObj.pending.push(this);
	                        return;
	                    }
	                }
	            }
	
	            if (image) {
	                // 图片已经加载完成
	                // if (image.nodeName.toUpperCase() == 'IMG') {
	                //     if (!image.complete) {
	                //         return;
	                //     }
	                // }
	                // Else is canvas
	
	                var width = style.width || image.width;
	                var height = style.height || image.height;
	                var x = style.x || 0;
	                var y = style.y || 0;
	                // 图片加载失败
	                if (!image.width || !image.height) {
	                    return;
	                }
	
	                // 设置transform
	                this.setTransform(ctx);
	
	
	                if (style.sWidth && style.sHeight) {
	                    var sx = style.sx || 0;
	                    var sy = style.sy || 0;
	                    ctx.drawImage(
	                        image,
	                        sx, sy, style.sWidth, style.sHeight,
	                        x, y, width, height
	                    );
	                }
	                else if (style.sx && style.sy) {
	                    var sx = style.sx;
	                    var sy = style.sy;
	                    var sWidth = width - sx;
	                    var sHeight = height - sy;
	                    ctx.drawImage(
	                        image,
	                        sx, sy, sWidth, sHeight,
	                        x, y, width, height
	                    );
	                }
	                else {
	                    ctx.drawImage(image, x, y, width, height);
	                }
	
	                // 如果没设置宽和高的话自动根据图片宽高设置
	                if (style.width == null) {
	                    style.width = width;
	                }
	                if (style.height == null) {
	                    style.height = height;
	                }
	
	                this.restoreTransform(ctx);
	
	                // Draw rect text
	                if (style.text != null) {
	                    this.drawRectText(ctx, this.getBoundingRect());
	                }
	
	            }
	        },
	
	        getBoundingRect: function () {
	            var style = this.style;
	            if (! this._rect) {
	                this._rect = new BoundingRect(
	                    style.x || 0, style.y || 0, style.width || 0, style.height || 0
	                );
	            }
	            return this._rect;
	        }
	    };
	
	    zrUtil.inherits(ZImage, Displayable);
	
	    module.exports = ZImage;


/***/ },
/* 41 */
/***/ function(module, exports) {

	// Simple LRU cache use doubly linked list
	// @module zrender/core/LRU
	
	
	    /**
	     * Simple double linked list. Compared with array, it has O(1) remove operation.
	     * @constructor
	     */
	    var LinkedList = function() {
	
	        /**
	         * @type {module:zrender/core/LRU~Entry}
	         */
	        this.head = null;
	
	        /**
	         * @type {module:zrender/core/LRU~Entry}
	         */
	        this.tail = null;
	
	        this._len = 0;
	    };
	
	    var linkedListProto = LinkedList.prototype;
	    /**
	     * Insert a new value at the tail
	     * @param  {} val
	     * @return {module:zrender/core/LRU~Entry}
	     */
	    linkedListProto.insert = function(val) {
	        var entry = new Entry(val);
	        this.insertEntry(entry);
	        return entry;
	    };
	
	    /**
	     * Insert an entry at the tail
	     * @param  {module:zrender/core/LRU~Entry} entry
	     */
	    linkedListProto.insertEntry = function(entry) {
	        if (!this.head) {
	            this.head = this.tail = entry;
	        }
	        else {
	            this.tail.next = entry;
	            entry.prev = this.tail;
	            this.tail = entry;
	        }
	        this._len++;
	    };
	
	    /**
	     * Remove entry.
	     * @param  {module:zrender/core/LRU~Entry} entry
	     */
	    linkedListProto.remove = function(entry) {
	        var prev = entry.prev;
	        var next = entry.next;
	        if (prev) {
	            prev.next = next;
	        }
	        else {
	            // Is head
	            this.head = next;
	        }
	        if (next) {
	            next.prev = prev;
	        }
	        else {
	            // Is tail
	            this.tail = prev;
	        }
	        entry.next = entry.prev = null;
	        this._len--;
	    };
	
	    /**
	     * @return {number}
	     */
	    linkedListProto.len = function() {
	        return this._len;
	    };
	
	    /**
	     * @constructor
	     * @param {} val
	     */
	    var Entry = function(val) {
	        /**
	         * @type {}
	         */
	        this.value = val;
	
	        /**
	         * @type {module:zrender/core/LRU~Entry}
	         */
	        this.next;
	
	        /**
	         * @type {module:zrender/core/LRU~Entry}
	         */
	        this.prev;
	    };
	
	    /**
	     * LRU Cache
	     * @constructor
	     * @alias module:zrender/core/LRU
	     */
	    var LRU = function(maxSize) {
	
	        this._list = new LinkedList();
	
	        this._map = {};
	
	        this._maxSize = maxSize || 10;
	    };
	
	    var LRUProto = LRU.prototype;
	
	    /**
	     * @param  {string} key
	     * @param  {} value
	     */
	    LRUProto.put = function(key, value) {
	        var list = this._list;
	        var map = this._map;
	        if (map[key] == null) {
	            var len = list.len();
	            if (len >= this._maxSize && len > 0) {
	                // Remove the least recently used
	                var leastUsedEntry = list.head;
	                list.remove(leastUsedEntry);
	                delete map[leastUsedEntry.key];
	            }
	
	            var entry = list.insert(value);
	            entry.key = key;
	            map[key] = entry;
	        }
	    };
	
	    /**
	     * @param  {string} key
	     * @return {}
	     */
	    LRUProto.get = function(key) {
	        var entry = this._map[key];
	        var list = this._list;
	        if (entry != null) {
	            // Put the latest used entry in the tail
	            if (entry !== list.tail) {
	                list.remove(entry);
	                list.insertEntry(entry);
	            }
	
	            return entry.value;
	        }
	    };
	
	    /**
	     * Clear the cache
	     */
	    LRUProto.clear = function() {
	        this._list.clear();
	        this._map = {};
	    };
	
	    module.exports = LRU;


/***/ },
/* 42 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Text element
	 * @module zrender/graphic/Text
	 *
	 * TODO Wrapping
	 *
	 * Text not support gradient
	 */
	
	
	
	    var Displayable = __webpack_require__(7);
	    var zrUtil = __webpack_require__(4);
	    var textContain = __webpack_require__(23);
	
	    /**
	     * @alias zrender/graphic/Text
	     * @extends module:zrender/graphic/Displayable
	     * @constructor
	     * @param {Object} opts
	     */
	    var Text = function (opts) {
	        Displayable.call(this, opts);
	    };
	
	    Text.prototype = {
	
	        constructor: Text,
	
	        type: 'text',
	
	        brush: function (ctx, prevEl) {
	            var style = this.style;
	            var x = style.x || 0;
	            var y = style.y || 0;
	            // Convert to string
	            var text = style.text;
	
	            // Convert to string
	            text != null && (text += '');
	
	            // Always bind style
	            style.bind(ctx, this, prevEl);
	
	            if (text) {
	
	                this.setTransform(ctx);
	
	                var textBaseline;
	                var textAlign = style.textAlign;
	                var font = style.textFont || style.font;
	                if (style.textVerticalAlign) {
	                    var rect = textContain.getBoundingRect(
	                        text, font, style.textAlign, 'top'
	                    );
	                    // Ignore textBaseline
	                    textBaseline = 'middle';
	                    switch (style.textVerticalAlign) {
	                        case 'middle':
	                            y -= rect.height / 2 - rect.lineHeight / 2;
	                            break;
	                        case 'bottom':
	                            y -= rect.height - rect.lineHeight / 2;
	                            break;
	                        default:
	                            y += rect.lineHeight / 2;
	                    }
	                }
	                else {
	                    textBaseline = style.textBaseline;
	                }
	
	                // TODO Invalid font
	                ctx.font = font || '12px sans-serif';
	                ctx.textAlign = textAlign || 'left';
	                // Use canvas default left textAlign. Giving invalid value will cause state not change
	                if (ctx.textAlign !== textAlign) {
	                    ctx.textAlign = 'left';
	                }
	                ctx.textBaseline = textBaseline || 'alphabetic';
	                // Use canvas default alphabetic baseline
	                if (ctx.textBaseline !== textBaseline) {
	                    ctx.textBaseline = 'alphabetic';
	                }
	
	                var lineHeight = textContain.measureText('国', ctx.font).width;
	
	                var textLines = text.split('\n');
	                for (var i = 0; i < textLines.length; i++) {
	                    style.hasFill() && ctx.fillText(textLines[i], x, y);
	                    style.hasStroke() && ctx.strokeText(textLines[i], x, y);
	                    y += lineHeight;
	                }
	
	                this.restoreTransform(ctx);
	            }
	        },
	
	        getBoundingRect: function () {
	            if (!this._rect) {
	                var style = this.style;
	                var textVerticalAlign = style.textVerticalAlign;
	                var rect = textContain.getBoundingRect(
	                    style.text + '', style.textFont || style.font, style.textAlign,
	                    textVerticalAlign ? 'top' : style.textBaseline
	                );
	                switch (textVerticalAlign) {
	                    case 'middle':
	                        rect.y -= rect.height / 2;
	                        break;
	                    case 'bottom':
	                        rect.y -= rect.height;
	                        break;
	                }
	                rect.x += style.x || 0;
	                rect.y += style.y || 0;
	                this._rect = rect;
	            }
	            return this._rect;
	        }
	    };
	
	    zrUtil.inherits(Text, Displayable);
	
	    module.exports = Text;


/***/ },
/* 43 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	/**
	 * 圆形
	 * @module zrender/shape/Circle
	 */
	
	
	
	    module.exports = __webpack_require__(6).extend({
	
	        type: 'circle',
	
	        shape: {
	            cx: 0,
	            cy: 0,
	            r: 0
	        },
	
	
	        buildPath : function (ctx, shape, inBundle) {
	            // Better stroking in ShapeBundle
	            // Always do it may have performence issue ( fill may be 2x more cost)
	            if (inBundle) {
	                ctx.moveTo(shape.cx + shape.r, shape.cy);
	            }
	            // Better stroking in ShapeBundle
	            // ctx.moveTo(shape.cx + shape.r, shape.cy);
	            ctx.arc(shape.cx, shape.cy, shape.r, 0, Math.PI * 2, true);
	        }
	    });
	


/***/ },
/* 44 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * 扇形
	 * @module zrender/graphic/shape/Sector
	 */
	
	
	
	    module.exports = __webpack_require__(6).extend({
	
	        type: 'sector',
	
	        shape: {
	
	            cx: 0,
	
	            cy: 0,
	
	            r0: 0,
	
	            r: 0,
	
	            startAngle: 0,
	
	            endAngle: Math.PI * 2,
	
	            clockwise: true
	        },
	
	        buildPath: function (ctx, shape) {
	
	            var x = shape.cx;
	            var y = shape.cy;
	            var r0 = Math.max(shape.r0 || 0, 0);
	            var r = Math.max(shape.r, 0);
	            var startAngle = shape.startAngle;
	            var endAngle = shape.endAngle;
	            var clockwise = shape.clockwise;
	
	            var unitX = Math.cos(startAngle);
	            var unitY = Math.sin(startAngle);
	
	            ctx.moveTo(unitX * r0 + x, unitY * r0 + y);
	
	            ctx.lineTo(unitX * r + x, unitY * r + y);
	
	            ctx.arc(x, y, r, startAngle, endAngle, !clockwise);
	
	            ctx.lineTo(
	                Math.cos(endAngle) * r0 + x,
	                Math.sin(endAngle) * r0 + y
	            );
	
	            if (r0 !== 0) {
	                ctx.arc(x, y, r0, endAngle, startAngle, clockwise);
	            }
	
	            ctx.closePath();
	        }
	    });
	


/***/ },
/* 45 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * 圆环
	 * @module zrender/graphic/shape/Ring
	 */
	
	
	    module.exports = __webpack_require__(6).extend({
	
	        type: 'ring',
	
	        shape: {
	            cx: 0,
	            cy: 0,
	            r: 0,
	            r0: 0
	        },
	
	        buildPath: function (ctx, shape) {
	            var x = shape.cx;
	            var y = shape.cy;
	            var PI2 = Math.PI * 2;
	            ctx.moveTo(x + shape.r, y);
	            ctx.arc(x, y, shape.r, 0, PI2, false);
	            ctx.moveTo(x + shape.r0, y);
	            ctx.arc(x, y, shape.r0, 0, PI2, true);
	        }
	    });
	


/***/ },
/* 46 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * 多边形
	 * @module zrender/shape/Polygon
	 */
	
	
	    var polyHelper = __webpack_require__(47);
	
	    module.exports = __webpack_require__(6).extend({
	        
	        type: 'polygon',
	
	        shape: {
	            points: null,
	
	            smooth: false,
	
	            smoothConstraint: null
	        },
	
	        buildPath: function (ctx, shape) {
	            polyHelper.buildPath(ctx, shape, true);
	        }
	    });


/***/ },
/* 47 */
/***/ function(module, exports, __webpack_require__) {

	
	
	    var smoothSpline = __webpack_require__(48);
	    var smoothBezier = __webpack_require__(49);
	
	    module.exports = {
	        buildPath: function (ctx, shape, closePath) {
	            var points = shape.points;
	            var smooth = shape.smooth;
	            if (points && points.length >= 2) {
	                if (smooth && smooth !== 'spline') {
	                    var controlPoints = smoothBezier(
	                        points, smooth, closePath, shape.smoothConstraint
	                    );
	
	                    ctx.moveTo(points[0][0], points[0][1]);
	                    var len = points.length;
	                    for (var i = 0; i < (closePath ? len : len - 1); i++) {
	                        var cp1 = controlPoints[i * 2];
	                        var cp2 = controlPoints[i * 2 + 1];
	                        var p = points[(i + 1) % len];
	                        ctx.bezierCurveTo(
	                            cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]
	                        );
	                    }
	                }
	                else {
	                    if (smooth === 'spline') {
	                        points = smoothSpline(points, closePath);
	                    }
	
	                    ctx.moveTo(points[0][0], points[0][1]);
	                    for (var i = 1, l = points.length; i < l; i++) {
	                        ctx.lineTo(points[i][0], points[i][1]);
	                    }
	                }
	
	                closePath && ctx.closePath();
	            }
	        }
	    };


/***/ },
/* 48 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Catmull-Rom spline 插值折线
	 * @module zrender/shape/util/smoothSpline
	 * @author pissang (https://www.github.com/pissang)
	 *         Kener (@Kener-林峰, kener.linfeng@gmail.com)
	 *         errorrik (errorrik@gmail.com)
	 */
	
	    var vec2 = __webpack_require__(14);
	
	    /**
	     * @inner
	     */
	    function interpolate(p0, p1, p2, p3, t, t2, t3) {
	        var v0 = (p2 - p0) * 0.5;
	        var v1 = (p3 - p1) * 0.5;
	        return (2 * (p1 - p2) + v0 + v1) * t3
	                + (-3 * (p1 - p2) - 2 * v0 - v1) * t2
	                + v0 * t + p1;
	    }
	
	    /**
	     * @alias module:zrender/shape/util/smoothSpline
	     * @param {Array} points 线段顶点数组
	     * @param {boolean} isLoop
	     * @return {Array}
	     */
	    module.exports = function (points, isLoop) {
	        var len = points.length;
	        var ret = [];
	
	        var distance = 0;
	        for (var i = 1; i < len; i++) {
	            distance += vec2.distance(points[i - 1], points[i]);
	        }
	
	        var segs = distance / 2;
	        segs = segs < len ? len : segs;
	        for (var i = 0; i < segs; i++) {
	            var pos = i / (segs - 1) * (isLoop ? len : len - 1);
	            var idx = Math.floor(pos);
	
	            var w = pos - idx;
	
	            var p0;
	            var p1 = points[idx % len];
	            var p2;
	            var p3;
	            if (!isLoop) {
	                p0 = points[idx === 0 ? idx : idx - 1];
	                p2 = points[idx > len - 2 ? len - 1 : idx + 1];
	                p3 = points[idx > len - 3 ? len - 1 : idx + 2];
	            }
	            else {
	                p0 = points[(idx - 1 + len) % len];
	                p2 = points[(idx + 1) % len];
	                p3 = points[(idx + 2) % len];
	            }
	
	            var w2 = w * w;
	            var w3 = w * w2;
	
	            ret.push([
	                interpolate(p0[0], p1[0], p2[0], p3[0], w, w2, w3),
	                interpolate(p0[1], p1[1], p2[1], p3[1], w, w2, w3)
	            ]);
	        }
	        return ret;
	    };
	


/***/ },
/* 49 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * 贝塞尔平滑曲线
	 * @module zrender/shape/util/smoothBezier
	 * @author pissang (https://www.github.com/pissang)
	 *         Kener (@Kener-林峰, kener.linfeng@gmail.com)
	 *         errorrik (errorrik@gmail.com)
	 */
	
	
	    var vec2 = __webpack_require__(14);
	    var v2Min = vec2.min;
	    var v2Max = vec2.max;
	    var v2Scale = vec2.scale;
	    var v2Distance = vec2.distance;
	    var v2Add = vec2.add;
	
	    /**
	     * 贝塞尔平滑曲线
	     * @alias module:zrender/shape/util/smoothBezier
	     * @param {Array} points 线段顶点数组
	     * @param {number} smooth 平滑等级, 0-1
	     * @param {boolean} isLoop
	     * @param {Array} constraint 将计算出来的控制点约束在一个包围盒内
	     *                           比如 [[0, 0], [100, 100]], 这个包围盒会与
	     *                           整个折线的包围盒做一个并集用来约束控制点。
	     * @param {Array} 计算出来的控制点数组
	     */
	    module.exports = function (points, smooth, isLoop, constraint) {
	        var cps = [];
	
	        var v = [];
	        var v1 = [];
	        var v2 = [];
	        var prevPoint;
	        var nextPoint;
	
	        var min, max;
	        if (constraint) {
	            min = [Infinity, Infinity];
	            max = [-Infinity, -Infinity];
	            for (var i = 0, len = points.length; i < len; i++) {
	                v2Min(min, min, points[i]);
	                v2Max(max, max, points[i]);
	            }
	            // 与指定的包围盒做并集
	            v2Min(min, min, constraint[0]);
	            v2Max(max, max, constraint[1]);
	        }
	
	        for (var i = 0, len = points.length; i < len; i++) {
	            var point = points[i];
	
	            if (isLoop) {
	                prevPoint = points[i ? i - 1 : len - 1];
	                nextPoint = points[(i + 1) % len];
	            }
	            else {
	                if (i === 0 || i === len - 1) {
	                    cps.push(vec2.clone(points[i]));
	                    continue;
	                }
	                else {
	                    prevPoint = points[i - 1];
	                    nextPoint = points[i + 1];
	                }
	            }
	
	            vec2.sub(v, nextPoint, prevPoint);
	
	            // use degree to scale the handle length
	            v2Scale(v, v, smooth);
	
	            var d0 = v2Distance(point, prevPoint);
	            var d1 = v2Distance(point, nextPoint);
	            var sum = d0 + d1;
	            if (sum !== 0) {
	                d0 /= sum;
	                d1 /= sum;
	            }
	
	            v2Scale(v1, v, -d0);
	            v2Scale(v2, v, d1);
	            var cp0 = v2Add([], point, v1);
	            var cp1 = v2Add([], point, v2);
	            if (constraint) {
	                v2Max(cp0, cp0, min);
	                v2Min(cp0, cp0, max);
	                v2Max(cp1, cp1, min);
	                v2Min(cp1, cp1, max);
	            }
	            cps.push(cp0);
	            cps.push(cp1);
	        }
	
	        if (isLoop) {
	            cps.push(cps.shift());
	        }
	
	        return cps;
	    };
	


/***/ },
/* 50 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @module zrender/graphic/shape/Polyline
	 */
	
	
	    var polyHelper = __webpack_require__(47);
	
	    module.exports = __webpack_require__(6).extend({
	        
	        type: 'polyline',
	
	        shape: {
	            points: null,
	
	            smooth: false,
	
	            smoothConstraint: null
	        },
	
	        style: {
	            stroke: '#000',
	
	            fill: null
	        },
	
	        buildPath: function (ctx, shape) {
	            polyHelper.buildPath(ctx, shape, false);
	        }
	    });


/***/ },
/* 51 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * 矩形
	 * @module zrender/graphic/shape/Rect
	 */
	
	
	    var roundRectHelper = __webpack_require__(52);
	
	    module.exports = __webpack_require__(6).extend({
	
	        type: 'rect',
	
	        shape: {
	            // 左上、右上、右下、左下角的半径依次为r1、r2、r3、r4
	            // r缩写为1         相当于 [1, 1, 1, 1]
	            // r缩写为[1]       相当于 [1, 1, 1, 1]
	            // r缩写为[1, 2]    相当于 [1, 2, 1, 2]
	            // r缩写为[1, 2, 3] 相当于 [1, 2, 3, 2]
	            r: 0,
	
	            x: 0,
	            y: 0,
	            width: 0,
	            height: 0
	        },
	
	        buildPath: function (ctx, shape) {
	            var x = shape.x;
	            var y = shape.y;
	            var width = shape.width;
	            var height = shape.height;
	            if (!shape.r) {
	                ctx.rect(x, y, width, height);
	            }
	            else {
	                roundRectHelper.buildPath(ctx, shape);
	            }
	            ctx.closePath();
	            return;
	        }
	    });
	


/***/ },
/* 52 */
/***/ function(module, exports) {

	
	
	    module.exports = {
	        buildPath: function (ctx, shape) {
	            var x = shape.x;
	            var y = shape.y;
	            var width = shape.width;
	            var height = shape.height;
	            var r = shape.r;
	            var r1;
	            var r2;
	            var r3;
	            var r4;
	
	            // Convert width and height to positive for better borderRadius
	            if (width < 0) {
	                x = x + width;
	                width = -width;
	            }
	            if (height < 0) {
	                y = y + height;
	                height = -height;
	            }
	
	            if (typeof r === 'number') {
	                r1 = r2 = r3 = r4 = r;
	            }
	            else if (r instanceof Array) {
	                if (r.length === 1) {
	                    r1 = r2 = r3 = r4 = r[0];
	                }
	                else if (r.length === 2) {
	                    r1 = r3 = r[0];
	                    r2 = r4 = r[1];
	                }
	                else if (r.length === 3) {
	                    r1 = r[0];
	                    r2 = r4 = r[1];
	                    r3 = r[2];
	                }
	                else {
	                    r1 = r[0];
	                    r2 = r[1];
	                    r3 = r[2];
	                    r4 = r[3];
	                }
	            }
	            else {
	                r1 = r2 = r3 = r4 = 0;
	            }
	
	            var total;
	            if (r1 + r2 > width) {
	                total = r1 + r2;
	                r1 *= width / total;
	                r2 *= width / total;
	            }
	            if (r3 + r4 > width) {
	                total = r3 + r4;
	                r3 *= width / total;
	                r4 *= width / total;
	            }
	            if (r2 + r3 > height) {
	                total = r2 + r3;
	                r2 *= height / total;
	                r3 *= height / total;
	            }
	            if (r1 + r4 > height) {
	                total = r1 + r4;
	                r1 *= height / total;
	                r4 *= height / total;
	            }
	            ctx.moveTo(x + r1, y);
	            ctx.lineTo(x + width - r2, y);
	            r2 !== 0 && ctx.quadraticCurveTo(
	                x + width, y, x + width, y + r2
	            );
	            ctx.lineTo(x + width, y + height - r3);
	            r3 !== 0 && ctx.quadraticCurveTo(
	                x + width, y + height, x + width - r3, y + height
	            );
	            ctx.lineTo(x + r4, y + height);
	            r4 !== 0 && ctx.quadraticCurveTo(
	                x, y + height, x, y + height - r4
	            );
	            ctx.lineTo(x, y + r1);
	            r1 !== 0 && ctx.quadraticCurveTo(x, y, x + r1, y);
	        }
	    };


/***/ },
/* 53 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * 直线
	 * @module zrender/graphic/shape/Line
	 */
	
	    module.exports = __webpack_require__(6).extend({
	
	        type: 'line',
	
	        shape: {
	            // Start point
	            x1: 0,
	            y1: 0,
	            // End point
	            x2: 0,
	            y2: 0,
	
	            percent: 1
	        },
	
	        style: {
	            stroke: '#000',
	            fill: null
	        },
	
	        buildPath: function (ctx, shape) {
	            var x1 = shape.x1;
	            var y1 = shape.y1;
	            var x2 = shape.x2;
	            var y2 = shape.y2;
	            var percent = shape.percent;
	
	            if (percent === 0) {
	                return;
	            }
	
	            ctx.moveTo(x1, y1);
	
	            if (percent < 1) {
	                x2 = x1 * (1 - percent) + x2 * percent;
	                y2 = y1 * (1 - percent) + y2 * percent;
	            }
	            ctx.lineTo(x2, y2);
	        },
	
	        /**
	         * Get point at percent
	         * @param  {number} percent
	         * @return {Array.<number>}
	         */
	        pointAt: function (p) {
	            var shape = this.shape;
	            return [
	                shape.x1 * (1 - p) + shape.x2 * p,
	                shape.y1 * (1 - p) + shape.y2 * p
	            ];
	        }
	    });
	


/***/ },
/* 54 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	/**
	 * 贝塞尔曲线
	 * @module zrender/shape/BezierCurve
	 */
	
	
	    var curveTool = __webpack_require__(26);
	    var vec2 = __webpack_require__(14);
	    var quadraticSubdivide = curveTool.quadraticSubdivide;
	    var cubicSubdivide = curveTool.cubicSubdivide;
	    var quadraticAt = curveTool.quadraticAt;
	    var cubicAt = curveTool.cubicAt;
	    var quadraticDerivativeAt = curveTool.quadraticDerivativeAt;
	    var cubicDerivativeAt = curveTool.cubicDerivativeAt;
	
	    var out = [];
	
	    function someVectorAt(shape, t, isTangent) {
	        var cpx2 = shape.cpx2;
	        var cpy2 = shape.cpy2;
	        if (cpx2 === null || cpy2 === null) {
	            return [
	                (isTangent ? cubicDerivativeAt : cubicAt)(shape.x1, shape.cpx1, shape.cpx2, shape.x2, t),
	                (isTangent ? cubicDerivativeAt : cubicAt)(shape.y1, shape.cpy1, shape.cpy2, shape.y2, t)
	            ];
	        }
	        else {
	            return [
	                (isTangent ? quadraticDerivativeAt : quadraticAt)(shape.x1, shape.cpx1, shape.x2, t),
	                (isTangent ? quadraticDerivativeAt : quadraticAt)(shape.y1, shape.cpy1, shape.y2, t)
	            ];
	        }
	    }
	    module.exports = __webpack_require__(6).extend({
	
	        type: 'bezier-curve',
	
	        shape: {
	            x1: 0,
	            y1: 0,
	            x2: 0,
	            y2: 0,
	            cpx1: 0,
	            cpy1: 0,
	            // cpx2: 0,
	            // cpy2: 0
	
	            // Curve show percent, for animating
	            percent: 1
	        },
	
	        style: {
	            stroke: '#000',
	            fill: null
	        },
	
	        buildPath: function (ctx, shape) {
	            var x1 = shape.x1;
	            var y1 = shape.y1;
	            var x2 = shape.x2;
	            var y2 = shape.y2;
	            var cpx1 = shape.cpx1;
	            var cpy1 = shape.cpy1;
	            var cpx2 = shape.cpx2;
	            var cpy2 = shape.cpy2;
	            var percent = shape.percent;
	            if (percent === 0) {
	                return;
	            }
	
	            ctx.moveTo(x1, y1);
	
	            if (cpx2 == null || cpy2 == null) {
	                if (percent < 1) {
	                    quadraticSubdivide(
	                        x1, cpx1, x2, percent, out
	                    );
	                    cpx1 = out[1];
	                    x2 = out[2];
	                    quadraticSubdivide(
	                        y1, cpy1, y2, percent, out
	                    );
	                    cpy1 = out[1];
	                    y2 = out[2];
	                }
	
	                ctx.quadraticCurveTo(
	                    cpx1, cpy1,
	                    x2, y2
	                );
	            }
	            else {
	                if (percent < 1) {
	                    cubicSubdivide(
	                        x1, cpx1, cpx2, x2, percent, out
	                    );
	                    cpx1 = out[1];
	                    cpx2 = out[2];
	                    x2 = out[3];
	                    cubicSubdivide(
	                        y1, cpy1, cpy2, y2, percent, out
	                    );
	                    cpy1 = out[1];
	                    cpy2 = out[2];
	                    y2 = out[3];
	                }
	                ctx.bezierCurveTo(
	                    cpx1, cpy1,
	                    cpx2, cpy2,
	                    x2, y2
	                );
	            }
	        },
	
	        /**
	         * Get point at percent
	         * @param  {number} t
	         * @return {Array.<number>}
	         */
	        pointAt: function (t) {
	            return someVectorAt(this.shape, t, false);
	        },
	
	        /**
	         * Get tangent at percent
	         * @param  {number} t
	         * @return {Array.<number>}
	         */
	        tangentAt: function (t) {
	            var p = someVectorAt(this.shape, t, true);
	            return vec2.normalize(p, p);
	        }
	    });
	


/***/ },
/* 55 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * 圆弧
	 * @module zrender/graphic/shape/Arc
	 */
	 
	
	    module.exports = __webpack_require__(6).extend({
	
	        type: 'arc',
	
	        shape: {
	
	            cx: 0,
	
	            cy: 0,
	
	            r: 0,
	
	            startAngle: 0,
	
	            endAngle: Math.PI * 2,
	
	            clockwise: true
	        },
	
	        style: {
	
	            stroke: '#000',
	
	            fill: null
	        },
	
	        buildPath: function (ctx, shape) {
	
	            var x = shape.cx;
	            var y = shape.cy;
	            var r = Math.max(shape.r, 0);
	            var startAngle = shape.startAngle;
	            var endAngle = shape.endAngle;
	            var clockwise = shape.clockwise;
	
	            var unitX = Math.cos(startAngle);
	            var unitY = Math.sin(startAngle);
	
	            ctx.moveTo(unitX * r + x, unitY * r + y);
	            ctx.arc(x, y, r, startAngle, endAngle, !clockwise);
	        }
	    });


/***/ },
/* 56 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	
	    var zrUtil = __webpack_require__(4);
	
	    var Gradient = __webpack_require__(37);
	
	    /**
	     * x, y, x2, y2 are all percent from 0 to 1
	     * @param {number} [x=0]
	     * @param {number} [y=0]
	     * @param {number} [x2=1]
	     * @param {number} [y2=0]
	     * @param {Array.<Object>} colorStops
	     * @param {boolean} [globalCoord=false]
	     */
	    var LinearGradient = function (x, y, x2, y2, colorStops, globalCoord) {
	        this.x = x == null ? 0 : x;
	
	        this.y = y == null ? 0 : y;
	
	        this.x2 = x2 == null ? 1 : x2;
	
	        this.y2 = y2 == null ? 0 : y2;
	
	        // Can be cloned
	        this.type = 'linear';
	
	        // If use global coord
	        this.global = globalCoord || false;
	
	        Gradient.call(this, colorStops);
	    };
	
	    LinearGradient.prototype = {
	
	        constructor: LinearGradient
	    };
	
	    zrUtil.inherits(LinearGradient, Gradient);
	
	    module.exports = LinearGradient;


/***/ },
/* 57 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	
	    var zrUtil = __webpack_require__(4);
	
	    var Gradient = __webpack_require__(37);
	
	    /**
	     * x, y, r are all percent from 0 to 1
	     * @param {number} [x=0.5]
	     * @param {number} [y=0.5]
	     * @param {number} [r=0.5]
	     * @param {Array.<Object>} [colorStops]
	     * @param {boolean} [globalCoord=false]
	     */
	    var RadialGradient = function (x, y, r, colorStops, globalCoord) {
	        this.x = x == null ? 0.5 : x;
	
	        this.y = y == null ? 0.5 : y;
	
	        this.r = r == null ? 0.5 : r;
	
	        // Can be cloned
	        this.type = 'radial';
	
	        // If use global coord
	        this.global = globalCoord || false;
	
	        Gradient.call(this, colorStops);
	    };
	
	    RadialGradient.prototype = {
	
	        constructor: RadialGradient
	    };
	
	    zrUtil.inherits(RadialGradient, Gradient);
	
	    module.exports = RadialGradient;


/***/ },
/* 58 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	
	    var zrUtil = __webpack_require__(4);
	
	    var apiList = [
	        'getDom', 'getZr', 'getWidth', 'getHeight', 'dispatchAction',
	        'on', 'off', 'trigger', 'getDataURL', 'getConnectedDataURL', 'getModel', 'getOption'
	    ];
	
	    function ExtensionAPI(instance) {
	        zrUtil.each(apiList, function (name) {
	            this[name] = zrUtil.bind(instance[name], instance);
	        }, this);
	    }
	
	    module.exports = ExtensionAPI;
	


/***/ },
/* 59 */
/***/ function(module, exports) {

	
	
	    /**
	      * Creates an instance of Point
	      *
	      *
	      * @constructor
	      * @this {Point}
	      * @param {Number} x The x coordinate of point.
	      * @param {Number} y The y coordinate of point.
	      * Note: Even if it is named Point this class should be named Dot as Dot is closer
	      * then Point from math perspective.
	      **/
	    function Point(x, y){
	        /**The x coordinate of point*/
	        this.x = x;
	        
	        /**The y coordinate of point*/
	        this.y = y;
	        
	
	    }
	
	    /**Creates a {Point} out of JSON parsed object
	     *@param {JSONObject} o - the JSON parsed object
	     *@return {Point} a newly constructed Point
	     **/
	    Point.load = function(o){
	        var newPoint = new Point(Number(o.x), Number(o.y));
	        return newPoint;
	    };
	
	
	    /**Creates an array of points from an array of {JSONObject}s
	     *@param {Array} v - the array of JSONObjects
	     *@return an {Array} of {Point}s
	     **/
	    Point.loadArray = function(v){
	        var newPoints = [];
	        for(var i=0; i< v.length; i++){
	            newPoints.push(Point.load(v[i]));
	        }
	        return newPoints;
	    };
	
	
	    /**Clones an array of points
	     *@param {Array} v - the array of {Point}s
	     *@return an {Array} of {Point}s
	     **/
	    Point.cloneArray = function(v){
	        var newPoints = [];
	        for(var i=0; i< v.length; i++){
	            newPoints.push(v[i].clone());
	        }
	        return newPoints;
	    };
	
	    Point.prototype = {
	        constructor : Point,
	        
	        transform:function(matrix){
	            var oldX = this.x;
	            var oldY = this.y;
	            this.x = matrix[0][0] * oldX + matrix[0][1] * oldY + matrix[0][2];
	            this.y = matrix[1][0] * oldX + matrix[1][1] * oldY + matrix[1][2];
	        },
	        
	        /**Tests if this point is similar to other point
	         *@param {Point} anotherPoint - the other point
	         **/
	        equals:function(anotherPoint){
	            if(! (anotherPoint instanceof Point) ){
	                return false;
	            }
	            return (this.x == anotherPoint.x)
	            && (this.y == anotherPoint.y)
	        },
	
	        /**Clone current Point
	         **/
	        clone: function(){
	            var newPoint = new Point(this.x, this.y);
	            return newPoint;
	        },
	
	        /**Tests to see if a point (x, y) is within a range of current Point
	         *@param {Numeric} x - the x coordinate of tested point
	         *@param {Numeric} y - the x coordinate of tested point
	         *@param {Numeric} radius - the radius of the vicinity
	         **/
	        near:function(x, y, radius){
	            var distance = Math.sqrt(Math.pow(this.x - x, 2) + Math.pow(this.y - y, 2));
	
	            return (distance <= radius);
	        },
	
	        contains: function(x,y){
	            return this.x == x && this.y == y;
	        },
	
	        toString:function(){
	            return '[' + this.x + ',' + this.y + ']';
	        },
	
	        getPoints:function(){
	            return [this];
	        }
	    };
	    module.exports = Point;
	    

/***/ },
/* 60 */
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * ZRender, a high performance 2d drawing library.
	 *
	 * Copyright (c) 2013, Baidu Inc.
	 * All rights reserved.
	 *
	 * LICENSE
	 * https://github.com/ecomfe/zrender/blob/master/LICENSE.txt
	 */
	// Global defines
	
	    var guid = __webpack_require__(10);
	    var env = __webpack_require__(61);
	
	    var Handler = __webpack_require__(62);
	    var Storage = __webpack_require__(63);
	    var Animation = __webpack_require__(65);
	    var HandlerProxy = __webpack_require__(68);
	
	    var useVML = !env.canvasSupported;
	
	    var painterCtors = {
	        canvas: __webpack_require__(70)
	    };
	
	    var instances = {};    // ZRender实例map索引
	
	    var zrender = {};
	    /**
	     * @type {string}
	     */
	    zrender.version = '3.1.3';
	
	    /**
	     * Initializing a zrender instance
	     * @param {HTMLElement} dom
	     * @param {Object} opts
	     * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg'
	     * @param {number} [opts.devicePixelRatio]
	     * @return {module:zrender/ZRender}
	     */
	    zrender.init = function(dom, opts) {
	        var zr = new ZRender(guid(), dom, opts);
	        instances[zr.id] = zr;
	        return zr;
	    };
	
	    /**
	     * Dispose zrender instance
	     * @param {module:zrender/ZRender} zr
	     */
	    zrender.dispose = function (zr) {
	        if (zr) {
	            zr.dispose();
	        }
	        else {
	            for (var key in instances) {
	                instances[key].dispose();
	            }
	            instances = {};
	        }
	
	        return zrender;
	    };
	
	    /**
	     * Get zrender instance by id
	     * @param {string} id zrender instance id
	     * @return {module:zrender/ZRender}
	     */
	    zrender.getInstance = function (id) {
	        return instances[id];
	    };
	
	    zrender.registerPainter = function (name, Ctor) {
	        painterCtors[name] = Ctor;
	    };
	
	    function delInstance(id) {
	        delete instances[id];
	    }
	
	    /**
	     * @module zrender/ZRender
	     */
	    /**
	     * @constructor
	     * @alias module:zrender/ZRender
	     * @param {string} id
	     * @param {HTMLDomElement} dom
	     * @param {Object} opts
	     * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg'
	     * @param {number} [opts.devicePixelRatio]
	     */
	    var ZRender = function(id, dom, opts) {
	
	        opts = opts || {};
	
	        /**
	         * @type {HTMLDomElement}
	         */
	        this.dom = dom;
	
	        /**
	         * @type {string}
	         */
	        this.id = id;
	
	        var self = this;
	        var storage = new Storage();
	
	        var rendererType = opts.renderer;
	        if (useVML) {
	            if (!painterCtors.vml) {
	                throw new Error('You need to require \'zrender/vml/vml\' to support IE8');
	            }
	            rendererType = 'vml';
	        }
	        else if (!rendererType || !painterCtors[rendererType]) {
	            rendererType = 'canvas';
	        }
	        var painter = new painterCtors[rendererType](dom, storage, opts);
	
	        this.storage = storage;
	        this.painter = painter;
	
	        var handerProxy = !env.node ? new HandlerProxy(painter.getViewportRoot()) : null;
	        this.handler = new Handler(storage, painter, handerProxy);
	
	        /**
	         * @type {module:zrender/animation/Animation}
	         */
	        this.animation = new Animation({
	            stage: {
	                update: function () {
	                    if (self._needsRefresh) {
	                        self.refreshImmediately();
	                    }
	                    if (self._needsRefreshHover) {
	                        self.refreshHoverImmediately();
	                    }
	                }
	            }
	        });
	        this.animation.start();
	
	        /**
	         * @type {boolean}
	         * @private
	         */
	        this._needsRefresh;
	
	        // 修改 storage.delFromMap, 每次删除元素之前删除动画
	        // FIXME 有点ugly
	        var oldDelFromMap = storage.delFromMap;
	        var oldAddToMap = storage.addToMap;
	
	        storage.delFromMap = function (elId) {
	            var el = storage.get(elId);
	
	            oldDelFromMap.call(storage, elId);
	
	            el && el.removeSelfFromZr(self);
	        };
	
	        storage.addToMap = function (el) {
	            oldAddToMap.call(storage, el);
	
	            el.addSelfToZr(self);
	        };
	    };
	
	    ZRender.prototype = {
	
	        constructor: ZRender,
	        /**
	         * 获取实例唯一标识
	         * @return {string}
	         */
	        getId: function () {
	            return this.id;
	        },
	
	        /**
	         * 添加元素
	         * @param  {module:zrender/Element} el
	         */
	        add: function (el) {
	            this.storage.addRoot(el);
	            this._needsRefresh = true;
	        },
	
	        /**
	         * 删除元素
	         * @param  {module:zrender/Element} el
	         */
	        remove: function (el) {
	            this.storage.delRoot(el);
	            this._needsRefresh = true;
	        },
	
	        /**
	         * Change configuration of layer
	         * @param {string} zLevel
	         * @param {Object} config
	         * @param {string} [config.clearColor=0] Clear color
	         * @param {string} [config.motionBlur=false] If enable motion blur
	         * @param {number} [config.lastFrameAlpha=0.7] Motion blur factor. Larger value cause longer trailer
	        */
	        configLayer: function (zLevel, config) {
	            this.painter.configLayer(zLevel, config);
	            this._needsRefresh = true;
	        },
	
	        /**
	         * Repaint the canvas immediately
	         */
	        refreshImmediately: function () {
	            // Clear needsRefresh ahead to avoid something wrong happens in refresh
	            // Or it will cause zrender refreshes again and again.
	            this._needsRefresh = false;
	            this.painter.refresh();
	            /**
	             * Avoid trigger zr.refresh in Element#beforeUpdate hook
	             */
	            this._needsRefresh = false;
	        },
	
	        /**
	         * Mark and repaint the canvas in the next frame of browser
	         */
	        refresh: function() {
	            this._needsRefresh = true;
	        },
	
	        /**
	         * Add element to hover layer
	         * @param  {module:zrender/Element} el
	         * @param {Object} style
	         */
	        addHover: function (el, style) {
	            if (this.painter.addHover) {
	                this.painter.addHover(el, style);
	                this.refreshHover();
	            }
	        },
	
	        /**
	         * Add element from hover layer
	         * @param  {module:zrender/Element} el
	         */
	        removeHover: function (el) {
	            if (this.painter.removeHover) {
	                this.painter.removeHover(el);
	                this.refreshHover();
	            }
	        },
	
	        /**
	         * Clear all hover elements in hover layer
	         * @param  {module:zrender/Element} el
	         */
	        clearHover: function () {
	            if (this.painter.clearHover) {
	                this.painter.clearHover();
	                this.refreshHover();
	            }
	        },
	
	        /**
	         * Refresh hover in next frame
	         */
	        refreshHover: function () {
	            this._needsRefreshHover = true;
	        },
	
	        /**
	         * Refresh hover immediately
	         */
	        refreshHoverImmediately: function () {
	            this._needsRefreshHover = false;
	            this.painter.refreshHover && this.painter.refreshHover();
	        },
	
	        /**
	         * Resize the canvas.
	         * Should be invoked when container size is changed
	         */
	        resize: function() {
	            this.painter.resize();
	            this.handler.resize();
	        },
	
	        /**
	         * Stop and clear all animation immediately
	         */
	        clearAnimation: function () {
	            this.animation.clear();
	        },
	
	        /**
	         * Get container width
	         */
	        getWidth: function() {
	            return this.painter.getWidth();
	        },
	
	        /**
	         * Get container height
	         */
	        getHeight: function() {
	            return this.painter.getHeight();
	        },
	
	        /**
	         * Export the canvas as Base64 URL
	         * @param {string} type
	         * @param {string} [backgroundColor='#fff']
	         * @return {string} Base64 URL
	         */
	        // toDataURL: function(type, backgroundColor) {
	        //     return this.painter.getRenderedCanvas({
	        //         backgroundColor: backgroundColor
	        //     }).toDataURL(type);
	        // },
	
	        /**
	         * Converting a path to image.
	         * It has much better performance of drawing image rather than drawing a vector path.
	         * @param {module:zrender/graphic/Path} e
	         * @param {number} width
	         * @param {number} height
	         */
	        pathToImage: function(e, width, height) {
	            var id = guid();
	            return this.painter.pathToImage(id, e, width, height);
	        },
	
	        /**
	         * Set default cursor
	         * @param {string} [cursorStyle='default'] 例如 crosshair
	         */
	        setCursorStyle: function (cursorStyle) {
	            this.handler.setCursorStyle(cursorStyle);
	        },
	
	        /**
	         * Bind event
	         *
	         * @param {string} eventName Event name
	         * @param {Function} eventHandler Handler function
	         * @param {Object} [context] Context object
	         */
	        on: function(eventName, eventHandler, context) {
	            this.handler.on(eventName, eventHandler, context);
	        },
	
	        /**
	         * Unbind event
	         * @param {string} eventName Event name
	         * @param {Function} [eventHandler] Handler function
	         */
	        off: function(eventName, eventHandler) {
	            this.handler.off(eventName, eventHandler);
	        },
	
	        /**
	         * Trigger event manually
	         *
	         * @param {string} eventName Event name
	         * @param {event=} event Event object
	         */
	        trigger: function (eventName, event) {
	            this.handler.trigger(eventName, event);
	        },
	
	
	        /**
	         * Clear all objects and the canvas.
	         */
	        clear: function () {
	            this.storage.delRoot();
	            this.painter.clear();
	        },
	
	        /**
	         * Dispose self.
	         */
	        dispose: function () {
	            this.animation.stop();
	
	            this.clear();
	            this.storage.dispose();
	            this.painter.dispose();
	            this.handler.dispose();
	
	            this.animation =
	            this.storage =
	            this.painter =
	            this.handler = null;
	
	            delInstance(this.id);
	        }
	    };
	
	    module.exports = zrender;
	


/***/ },
/* 61 */
/***/ function(module, exports) {

	/**
	 * echarts设备环境识别
	 *
	 * @desc echarts基于Canvas，纯Javascript图表库，提供直观，生动，可交互，可个性化定制的数据统计图表。
	 * @author firede[firede@firede.us]
	 * @desc thanks zepto.
	 */
	
	    var env = {};
	    if (typeof navigator === 'undefined') {
	        // In node
	        env = {
	            browser: {},
	            os: {},
	            node: true,
	            // Assume canvas is supported
	            canvasSupported: true
	        };
	    }
	    else {
	        env = detect(navigator.userAgent);
	    }
	
	    module.exports = env;
	
	    // Zepto.js
	    // (c) 2010-2013 Thomas Fuchs
	    // Zepto.js may be freely distributed under the MIT license.
	
	    function detect(ua) {
	        var os = {};
	        var browser = {};
	        // var webkit = ua.match(/Web[kK]it[\/]{0,1}([\d.]+)/);
	        // var android = ua.match(/(Android);?[\s\/]+([\d.]+)?/);
	        // var ipad = ua.match(/(iPad).*OS\s([\d_]+)/);
	        // var ipod = ua.match(/(iPod)(.*OS\s([\d_]+))?/);
	        // var iphone = !ipad && ua.match(/(iPhone\sOS)\s([\d_]+)/);
	        // var webos = ua.match(/(webOS|hpwOS)[\s\/]([\d.]+)/);
	        // var touchpad = webos && ua.match(/TouchPad/);
	        // var kindle = ua.match(/Kindle\/([\d.]+)/);
	        // var silk = ua.match(/Silk\/([\d._]+)/);
	        // var blackberry = ua.match(/(BlackBerry).*Version\/([\d.]+)/);
	        // var bb10 = ua.match(/(BB10).*Version\/([\d.]+)/);
	        // var rimtabletos = ua.match(/(RIM\sTablet\sOS)\s([\d.]+)/);
	        // var playbook = ua.match(/PlayBook/);
	        // var chrome = ua.match(/Chrome\/([\d.]+)/) || ua.match(/CriOS\/([\d.]+)/);
	        var firefox = ua.match(/Firefox\/([\d.]+)/);
	        // var safari = webkit && ua.match(/Mobile\//) && !chrome;
	        // var webview = ua.match(/(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/) && !chrome;
	        var ie = ua.match(/MSIE\s([\d.]+)/)
	            // IE 11 Trident/7.0; rv:11.0
	            || ua.match(/Trident\/.+?rv:(([\d.]+))/);
	        var edge = ua.match(/Edge\/([\d.]+)/); // IE 12 and 12+
	
	        // Todo: clean this up with a better OS/browser seperation:
	        // - discern (more) between multiple browsers on android
	        // - decide if kindle fire in silk mode is android or not
	        // - Firefox on Android doesn't specify the Android version
	        // - possibly devide in os, device and browser hashes
	
	        // if (browser.webkit = !!webkit) browser.version = webkit[1];
	
	        // if (android) os.android = true, os.version = android[2];
	        // if (iphone && !ipod) os.ios = os.iphone = true, os.version = iphone[2].replace(/_/g, '.');
	        // if (ipad) os.ios = os.ipad = true, os.version = ipad[2].replace(/_/g, '.');
	        // if (ipod) os.ios = os.ipod = true, os.version = ipod[3] ? ipod[3].replace(/_/g, '.') : null;
	        // if (webos) os.webos = true, os.version = webos[2];
	        // if (touchpad) os.touchpad = true;
	        // if (blackberry) os.blackberry = true, os.version = blackberry[2];
	        // if (bb10) os.bb10 = true, os.version = bb10[2];
	        // if (rimtabletos) os.rimtabletos = true, os.version = rimtabletos[2];
	        // if (playbook) browser.playbook = true;
	        // if (kindle) os.kindle = true, os.version = kindle[1];
	        // if (silk) browser.silk = true, browser.version = silk[1];
	        // if (!silk && os.android && ua.match(/Kindle Fire/)) browser.silk = true;
	        // if (chrome) browser.chrome = true, browser.version = chrome[1];
	        if (firefox) browser.firefox = true, browser.version = firefox[1];
	        // if (safari && (ua.match(/Safari/) || !!os.ios)) browser.safari = true;
	        // if (webview) browser.webview = true;
	        if (ie) {
	            browser.ie = true; browser.version = ie[1];
	        }
	        if (ie) {
	            browser.ie = true;
	            browser.version = ie[1];
	        }
	        if (edge) {
	            browser.edge = true;
	            browser.version = edge[1];
	        }
	
	        // os.tablet = !!(ipad || playbook || (android && !ua.match(/Mobile/)) ||
	        //     (firefox && ua.match(/Tablet/)) || (ie && !ua.match(/Phone/) && ua.match(/Touch/)));
	        // os.phone  = !!(!os.tablet && !os.ipod && (android || iphone || webos ||
	        //     (chrome && ua.match(/Android/)) || (chrome && ua.match(/CriOS\/([\d.]+)/)) ||
	        //     (firefox && ua.match(/Mobile/)) || (ie && ua.match(/Touch/))));
	
	        return {
	            browser: browser,
	            os: os,
	            node: false,
	            // 原生canvas支持，改极端点了
	            // canvasSupported : !(browser.ie && parseFloat(browser.version) < 9)
	            canvasSupported : document.createElement('canvas').getContext ? true : false,
	            // @see <http://stackoverflow.com/questions/4817029/whats-the-best-way-to-detect-a-touch-screen-device-using-javascript>
	            // works on most browsers
	            // IE10/11 does not support touch event, and MS Edge supports them but not by
	            // default, so we dont check navigator.maxTouchPoints for them here.
	            touchEventsSupported: 'ontouchstart' in window && !browser.ie && !browser.edge,
	            // <http://caniuse.com/#search=pointer%20event>.
	            pointerEventsSupported: 'onpointerdown' in window
	                // Firefox supports pointer but not by default,
	                // only MS browsers are reliable on pointer events currently.
	                && (browser.edge || (browser.ie && browser.version >= 10))
	        };
	    }


/***/ },
/* 62 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	/**
	 * Handler
	 * @module zrender/Handler
	 * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)
	 *         errorrik (errorrik@gmail.com)
	 *         pissang (shenyi.914@gmail.com)
	 */
	
	
	    var util = __webpack_require__(4);
	    var Draggable = __webpack_require__(38);
	
	    var Eventful = __webpack_require__(11);
	
	    function makeEventPacket(eveType, target, event) {
	        return {
	            type: eveType,
	            event: event,
	            target: target,
	            cancelBubble: false,
	            offsetX: event.zrX,
	            offsetY: event.zrY,
	            gestureEvent: event.gestureEvent,
	            pinchX: event.pinchX,
	            pinchY: event.pinchY,
	            pinchScale: event.pinchScale,
	            wheelDelta: event.zrDelta
	        };
	    }
	
	    function EmptyProxy () {}
	    EmptyProxy.prototype.dispose = function () {};
	
	    var handlerNames = [
	        'click', 'dblclick', 'mousewheel', 'mouseout',
	        'mouseup', 'mousedown', 'mousemove'
	    ];
	    /**
	     * @alias module:zrender/Handler
	     * @constructor
	     * @extends module:zrender/mixin/Eventful
	     * @param {HTMLElement} root Main HTML element for painting.
	     * @param {module:zrender/Storage} storage Storage instance.
	     * @param {module:zrender/Painter} painter Painter instance.
	     */
	    var Handler = function(storage, painter, proxy) {
	        Eventful.call(this);
	
	        this.storage = storage;
	
	        this.painter = painter;
	
	        proxy = proxy || new EmptyProxy();
	        /**
	         * Proxy of event. can be Dom, WebGLSurface, etc.
	         */
	        this.proxy = proxy;
	
	        // Attach handler
	        proxy.handler = this;
	
	        /**
	         * @private
	         * @type {boolean}
	         */
	        this._hovered;
	
	        /**
	         * @private
	         * @type {Date}
	         */
	        this._lastTouchMoment;
	
	        /**
	         * @private
	         * @type {number}
	         */
	        this._lastX;
	
	        /**
	         * @private
	         * @type {number}
	         */
	        this._lastY;
	
	
	        Draggable.call(this);
	
	        util.each(handlerNames, function (name) {
	            proxy.on && proxy.on(name, this[name], this);
	        }, this);
	    };
	
	    Handler.prototype = {
	
	        constructor: Handler,
	
	        mousemove: function (event) {
	            var x = event.zrX;
	            var y = event.zrY;
	
	            var hovered = this.findHover(x, y, null);
	            var lastHovered = this._hovered;
	            var proxy = this.proxy;
	
	            this._hovered = hovered;
	
	            proxy.setCursor && proxy.setCursor(hovered ? hovered.cursor : 'default');
	
	            // Mouse out on previous hovered element
	            if (lastHovered && hovered !== lastHovered && lastHovered.__zr) {
	                this.dispatchToElement(lastHovered, 'mouseout', event);
	            }
	
	            // Mouse moving on one element
	            this.dispatchToElement(hovered, 'mousemove', event);
	
	            // Mouse over on a new element
	            if (hovered && hovered !== lastHovered) {
	                this.dispatchToElement(hovered, 'mouseover', event);
	            }
	        },
	
	        mouseout: function (event) {
	            this.dispatchToElement(this._hovered, 'mouseout', event);
	
	            this.trigger('globalout', {
	                event: event
	            });
	        },
	
	        /**
	         * Resize
	         */
	        resize: function (event) {
	            this._hovered = null;
	        },
	
	        /**
	         * Dispatch event
	         * @param {string} eventName
	         * @param {event=} eventArgs
	         */
	        dispatch: function (eventName, eventArgs) {
	            var handler = this[eventName];
	            handler && handler.call(this, eventArgs);
	        },
	
	        /**
	         * Dispose
	         */
	        dispose: function () {
	
	            this.proxy.dispose();
	
	            this.storage =
	            this.proxy =
	            this.painter = null;
	        },
	
	        /**
	         * 设置默认的cursor style
	         * @param {string} [cursorStyle='default'] 例如 crosshair
	         */
	        setCursorStyle: function (cursorStyle) {
	            var proxy = this.proxy;
	            proxy.setCursor && proxy.setCursor(cursorStyle);
	        },
	
	        /**
	         * 事件分发代理
	         *
	         * @private
	         * @param {Object} targetEl 目标图形元素
	         * @param {string} eventName 事件名称
	         * @param {Object} event 事件对象
	         */
	        dispatchToElement: function (targetEl, eventName, event) {
	            var eventHandler = 'on' + eventName;
	            var eventPacket = makeEventPacket(eventName, targetEl, event);
	
	            var el = targetEl;
	
	            while (el) {
	                el[eventHandler]
	                    && (eventPacket.cancelBubble = el[eventHandler].call(el, eventPacket));
	
	                el.trigger(eventName, eventPacket);
	
	                el = el.parent;
	
	                if (eventPacket.cancelBubble) {
	                    break;
	                }
	            }
	
	            if (!eventPacket.cancelBubble) {
	                // 冒泡到顶级 zrender 对象
	                this.trigger(eventName, eventPacket);
	                // 分发事件到用户自定义层
	                // 用户有可能在全局 click 事件中 dispose，所以需要判断下 painter 是否存在
	                this.painter && this.painter.eachOtherLayer(function (layer) {
	                    if (typeof(layer[eventHandler]) == 'function') {
	                        layer[eventHandler].call(layer, eventPacket);
	                    }
	                    if (layer.trigger) {
	                        layer.trigger(eventName, eventPacket);
	                    }
	                });
	            }
	        },
	
	        /**
	         * @private
	         * @param {number} x
	         * @param {number} y
	         * @param {module:zrender/graphic/Displayable} exclude
	         * @method
	         */
	        findHover: function(x, y, exclude) {
	            var list = this.storage.getDisplayList();
	            for (var i = list.length - 1; i >= 0 ; i--) {
	                if (!list[i].silent
	                 && list[i] !== exclude
	                 // getDisplayList may include ignored item in VML mode
	                 && !list[i].ignore
	                 && isHover(list[i], x, y)) {
	                    return list[i];
	                }
	            }
	        }
	    };
	
	    // Common handlers
	    util.each(['click', 'mousedown', 'mouseup', 'mousewheel', 'dblclick'], function (name) {
	        Handler.prototype[name] = function (event) {
	            // Find hover again to avoid click event is dispatched manually. Or click is triggered without mouseover
	            var hovered = this.findHover(event.zrX, event.zrY, null);
	
	            if (name === 'mousedown') {
	                this._downel = hovered;
	                // In case click triggered before mouseup
	                this._upel = hovered;
	            }
	            else if (name === 'mosueup') {
	                this._upel = hovered;
	            }
	            else if (name === 'click') {
	                if (this._downel !== this._upel) {
	                    return;
	                }
	            }
	
	            this.dispatchToElement(hovered, name, event);
	        };
	    });
	
	    function isHover(displayable, x, y) {
	        if (displayable[displayable.rectHover ? 'rectContain' : 'contain'](x, y)) {
	            var el = displayable;
	            while (el) {
	                // If ancestor is silent or clipped by ancestor
	                if (el.silent || (el.clipPath && !el.clipPath.contain(x, y)))  {
	                    return false;
	                }
	                el = el.parent;
	            }
	            return true;
	        }
	
	        return false;
	    }
	
	    util.mixin(Handler, Eventful);
	    util.mixin(Handler, Draggable);
	
	    module.exports = Handler;


/***/ },
/* 63 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	/**
	 * Storage内容仓库模块
	 * @module zrender/Storage
	 * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)
	 * @author errorrik (errorrik@gmail.com)
	 * @author pissang (https://github.com/pissang/)
	 */
	
	
	    var util = __webpack_require__(4);
	    var env = __webpack_require__(61);
	
	    var Group = __webpack_require__(39);
	
	    // Use timsort because in most case elements are partially sorted
	    // https://jsfiddle.net/pissang/jr4x7mdm/8/
	    var timsort = __webpack_require__(64);
	
	    function shapeCompareFunc(a, b) {
	        if (a.zlevel === b.zlevel) {
	            if (a.z === b.z) {
	                // if (a.z2 === b.z2) {
	                //     // FIXME Slow has renderidx compare
	                //     // http://stackoverflow.com/questions/20883421/sorting-in-javascript-should-every-compare-function-have-a-return-0-statement
	                //     // https://github.com/v8/v8/blob/47cce544a31ed5577ffe2963f67acb4144ee0232/src/js/array.js#L1012
	                //     return a.__renderidx - b.__renderidx;
	                // }
	                return a.z2 - b.z2;
	            }
	            return a.z - b.z;
	        }
	        return a.zlevel - b.zlevel;
	    }
	    /**
	     * 内容仓库 (M)
	     * @alias module:zrender/Storage
	     * @constructor
	     */
	    var Storage = function () {
	        // 所有常规形状，id索引的map
	        this._elements = {};
	
	        this._roots = [];
	
	        this._displayList = [];
	
	        this._displayListLen = 0;
	    };
	
	    Storage.prototype = {
	
	        constructor: Storage,
	
	        /**
	         * @param  {Function} cb
	         *
	         */
	        traverse: function (cb, context) {
	            for (var i = 0; i < this._roots.length; i++) {
	                this._roots[i].traverse(cb, context);
	            }
	        },
	
	        /**
	         * 返回所有图形的绘制队列
	         * @param {boolean} [update=false] 是否在返回前更新该数组
	         * @param {boolean} [includeIgnore=false] 是否包含 ignore 的数组, 在 update 为 true 的时候有效
	         *
	         * 详见{@link module:zrender/graphic/Displayable.prototype.updateDisplayList}
	         * @return {Array.<module:zrender/graphic/Displayable>}
	         */
	        getDisplayList: function (update, includeIgnore) {
	            includeIgnore = includeIgnore || false;
	            if (update) {
	                this.updateDisplayList(includeIgnore);
	            }
	            return this._displayList;
	        },
	
	        /**
	         * 更新图形的绘制队列。
	         * 每次绘制前都会调用，该方法会先深度优先遍历整个树，更新所有Group和Shape的变换并且把所有可见的Shape保存到数组中，
	         * 最后根据绘制的优先级（zlevel > z > 插入顺序）排序得到绘制队列
	         * @param {boolean} [includeIgnore=false] 是否包含 ignore 的数组
	         */
	        updateDisplayList: function (includeIgnore) {
	            this._displayListLen = 0;
	            var roots = this._roots;
	            var displayList = this._displayList;
	            for (var i = 0, len = roots.length; i < len; i++) {
	                this._updateAndAddDisplayable(roots[i], null, includeIgnore);
	            }
	            displayList.length = this._displayListLen;
	
	            // for (var i = 0, len = displayList.length; i < len; i++) {
	            //     displayList[i].__renderidx = i;
	            // }
	
	            // displayList.sort(shapeCompareFunc);
	            env.canvasSupported && timsort(displayList, shapeCompareFunc);
	        },
	
	        _updateAndAddDisplayable: function (el, clipPaths, includeIgnore) {
	
	            if (el.ignore && !includeIgnore) {
	                return;
	            }
	
	            el.beforeUpdate();
	
	            if (el.__dirty) {
	
	                el.update();
	
	            }
	
	            el.afterUpdate();
	
	            var clipPath = el.clipPath;
	            if (clipPath) {
	                // clipPath 的变换是基于 group 的变换
	                clipPath.parent = el;
	                clipPath.updateTransform();
	
	                // FIXME 效率影响
	                if (clipPaths) {
	                    clipPaths = clipPaths.slice();
	                    clipPaths.push(clipPath);
	                }
	                else {
	                    clipPaths = [clipPath];
	                }
	            }
	
	            if (el.isGroup) {
	                var children = el._children;
	
	                for (var i = 0; i < children.length; i++) {
	                    var child = children[i];
	
	                    // Force to mark as dirty if group is dirty
	                    // FIXME __dirtyPath ?
	                    if (el.__dirty) {
	                        child.__dirty = true;
	                    }
	
	                    this._updateAndAddDisplayable(child, clipPaths, includeIgnore);
	                }
	
	                // Mark group clean here
	                el.__dirty = false;
	
	            }
	            else {
	                el.__clipPaths = clipPaths;
	
	                this._displayList[this._displayListLen++] = el;
	            }
	        },
	
	        /**
	         * 添加图形(Shape)或者组(Group)到根节点
	         * @param {module:zrender/Element} el
	         */
	        addRoot: function (el) {
	            // Element has been added
	            if (this._elements[el.id]) {
	                return;
	            }
	
	            if (el instanceof Group) {
	                el.addChildrenToStorage(this);
	            }
	
	            this.addToMap(el);
	            this._roots.push(el);
	        },
	
	        /**
	         * 删除指定的图形(Shape)或者组(Group)
	         * @param {string|Array.<string>} [elId] 如果为空清空整个Storage
	         */
	        delRoot: function (elId) {
	            if (elId == null) {
	                // 不指定elId清空
	                for (var i = 0; i < this._roots.length; i++) {
	                    var root = this._roots[i];
	                    if (root instanceof Group) {
	                        root.delChildrenFromStorage(this);
	                    }
	                }
	
	                this._elements = {};
	                this._roots = [];
	                this._displayList = [];
	                this._displayListLen = 0;
	
	                return;
	            }
	
	            if (elId instanceof Array) {
	                for (var i = 0, l = elId.length; i < l; i++) {
	                    this.delRoot(elId[i]);
	                }
	                return;
	            }
	
	            var el;
	            if (typeof(elId) == 'string') {
	                el = this._elements[elId];
	            }
	            else {
	                el = elId;
	            }
	
	            var idx = util.indexOf(this._roots, el);
	            if (idx >= 0) {
	                this.delFromMap(el.id);
	                this._roots.splice(idx, 1);
	                if (el instanceof Group) {
	                    el.delChildrenFromStorage(this);
	                }
	            }
	        },
	
	        addToMap: function (el) {
	            if (el instanceof Group) {
	                el.__storage = this;
	            }
	            el.dirty(false);
	
	            this._elements[el.id] = el;
	
	            return this;
	        },
	
	        get: function (elId) {
	            return this._elements[elId];
	        },
	
	        delFromMap: function (elId) {
	            var elements = this._elements;
	            var el = elements[elId];
	            if (el) {
	                delete elements[elId];
	                if (el instanceof Group) {
	                    el.__storage = null;
	                }
	            }
	
	            return this;
	        },
	
	        /**
	         * 清空并且释放Storage
	         */
	        dispose: function () {
	            this._elements =
	            this._renderList =
	            this._roots = null;
	        },
	
	        displayableSortFunc: shapeCompareFunc
	    };
	
	    module.exports = Storage;
	


/***/ },
/* 64 */
/***/ function(module, exports) {

	// https://github.com/mziccard/node-timsort
	
	    var DEFAULT_MIN_MERGE = 32;
	
	    var DEFAULT_MIN_GALLOPING = 7;
	
	    var DEFAULT_TMP_STORAGE_LENGTH = 256;
	
	    function minRunLength(n) {
	        var r = 0;
	
	        while (n >= DEFAULT_MIN_MERGE) {
	            r |= n & 1;
	            n >>= 1;
	        }
	
	        return n + r;
	    }
	
	    function makeAscendingRun(array, lo, hi, compare) {
	        var runHi = lo + 1;
	
	        if (runHi === hi) {
	            return 1;
	        }
	
	        if (compare(array[runHi++], array[lo]) < 0) {
	            while (runHi < hi && compare(array[runHi], array[runHi - 1]) < 0) {
	                runHi++;
	            }
	
	            reverseRun(array, lo, runHi);
	        }
	        else {
	            while (runHi < hi && compare(array[runHi], array[runHi - 1]) >= 0) {
	                runHi++;
	            }
	        }
	
	        return runHi - lo;
	    }
	
	    function reverseRun(array, lo, hi) {
	        hi--;
	
	        while (lo < hi) {
	            var t = array[lo];
	            array[lo++] = array[hi];
	            array[hi--] = t;
	        }
	    }
	
	    function binaryInsertionSort(array, lo, hi, start, compare) {
	        if (start === lo) {
	            start++;
	        }
	
	        for (; start < hi; start++) {
	            var pivot = array[start];
	
	            var left = lo;
	            var right = start;
	            var mid;
	
	            while (left < right) {
	                mid = left + right >>> 1;
	
	                if (compare(pivot, array[mid]) < 0) {
	                    right = mid;
	                }
	                else {
	                    left = mid + 1;
	                }
	            }
	
	            var n = start - left;
	
	            switch (n) {
	                case 3:
	                    array[left + 3] = array[left + 2];
	
	                case 2:
	                    array[left + 2] = array[left + 1];
	
	                case 1:
	                    array[left + 1] = array[left];
	                    break;
	                default:
	                    while (n > 0) {
	                        array[left + n] = array[left + n - 1];
	                        n--;
	                    }
	            }
	
	            array[left] = pivot;
	        }
	    }
	
	    function gallopLeft(value, array, start, length, hint, compare) {
	        var lastOffset = 0;
	        var maxOffset = 0;
	        var offset = 1;
	
	        if (compare(value, array[start + hint]) > 0) {
	            maxOffset = length - hint;
	
	            while (offset < maxOffset && compare(value, array[start + hint + offset]) > 0) {
	                lastOffset = offset;
	                offset = (offset << 1) + 1;
	
	                if (offset <= 0) {
	                    offset = maxOffset;
	                }
	            }
	
	            if (offset > maxOffset) {
	                offset = maxOffset;
	            }
	
	            lastOffset += hint;
	            offset += hint;
	        }
	        else {
	            maxOffset = hint + 1;
	            while (offset < maxOffset && compare(value, array[start + hint - offset]) <= 0) {
	                lastOffset = offset;
	                offset = (offset << 1) + 1;
	
	                if (offset <= 0) {
	                    offset = maxOffset;
	                }
	            }
	            if (offset > maxOffset) {
	                offset = maxOffset;
	            }
	
	            var tmp = lastOffset;
	            lastOffset = hint - offset;
	            offset = hint - tmp;
	        }
	
	        lastOffset++;
	        while (lastOffset < offset) {
	            var m = lastOffset + (offset - lastOffset >>> 1);
	
	            if (compare(value, array[start + m]) > 0) {
	                lastOffset = m + 1;
	            }
	            else {
	                offset = m;
	            }
	        }
	        return offset;
	    }
	
	    function gallopRight(value, array, start, length, hint, compare) {
	        var lastOffset = 0;
	        var maxOffset = 0;
	        var offset = 1;
	
	        if (compare(value, array[start + hint]) < 0) {
	            maxOffset = hint + 1;
	
	            while (offset < maxOffset && compare(value, array[start + hint - offset]) < 0) {
	                lastOffset = offset;
	                offset = (offset << 1) + 1;
	
	                if (offset <= 0) {
	                    offset = maxOffset;
	                }
	            }
	
	            if (offset > maxOffset) {
	                offset = maxOffset;
	            }
	
	            var tmp = lastOffset;
	            lastOffset = hint - offset;
	            offset = hint - tmp;
	        }
	        else {
	            maxOffset = length - hint;
	
	            while (offset < maxOffset && compare(value, array[start + hint + offset]) >= 0) {
	                lastOffset = offset;
	                offset = (offset << 1) + 1;
	
	                if (offset <= 0) {
	                    offset = maxOffset;
	                }
	            }
	
	            if (offset > maxOffset) {
	                offset = maxOffset;
	            }
	
	            lastOffset += hint;
	            offset += hint;
	        }
	
	        lastOffset++;
	
	        while (lastOffset < offset) {
	            var m = lastOffset + (offset - lastOffset >>> 1);
	
	            if (compare(value, array[start + m]) < 0) {
	                offset = m;
	            }
	            else {
	                lastOffset = m + 1;
	            }
	        }
	
	        return offset;
	    }
	
	    function TimSort(array, compare) {
	        var minGallop = DEFAULT_MIN_GALLOPING;
	        var length = 0;
	        var tmpStorageLength = DEFAULT_TMP_STORAGE_LENGTH;
	        var stackLength = 0;
	        var runStart;
	        var runLength;
	        var stackSize = 0;
	
	        length = array.length;
	
	        if (length < 2 * DEFAULT_TMP_STORAGE_LENGTH) {
	            tmpStorageLength = length >>> 1;
	        }
	
	        var tmp = [];
	
	        stackLength = length < 120 ? 5 : length < 1542 ? 10 : length < 119151 ? 19 : 40;
	
	        runStart = [];
	        runLength = [];
	
	        function pushRun(_runStart, _runLength) {
	            runStart[stackSize] = _runStart;
	            runLength[stackSize] = _runLength;
	            stackSize += 1;
	        }
	
	        function mergeRuns() {
	            while (stackSize > 1) {
	                var n = stackSize - 2;
	
	                if (n >= 1 && runLength[n - 1] <= runLength[n] + runLength[n + 1] || n >= 2 && runLength[n - 2] <= runLength[n] + runLength[n - 1]) {
	                    if (runLength[n - 1] < runLength[n + 1]) {
	                        n--;
	                    }
	                }
	                else if (runLength[n] > runLength[n + 1]) {
	                    break;
	                }
	                mergeAt(n);
	            }
	        }
	
	        function forceMergeRuns() {
	            while (stackSize > 1) {
	                var n = stackSize - 2;
	
	                if (n > 0 && runLength[n - 1] < runLength[n + 1]) {
	                    n--;
	                }
	
	                mergeAt(n);
	            }
	        }
	
	        function mergeAt(i) {
	            var start1 = runStart[i];
	            var length1 = runLength[i];
	            var start2 = runStart[i + 1];
	            var length2 = runLength[i + 1];
	
	            runLength[i] = length1 + length2;
	
	            if (i === stackSize - 3) {
	                runStart[i + 1] = runStart[i + 2];
	                runLength[i + 1] = runLength[i + 2];
	            }
	
	            stackSize--;
	
	            var k = gallopRight(array[start2], array, start1, length1, 0, compare);
	            start1 += k;
	            length1 -= k;
	
	            if (length1 === 0) {
	                return;
	            }
	
	            length2 = gallopLeft(array[start1 + length1 - 1], array, start2, length2, length2 - 1, compare);
	
	            if (length2 === 0) {
	                return;
	            }
	
	            if (length1 <= length2) {
	                mergeLow(start1, length1, start2, length2);
	            }
	            else {
	                mergeHigh(start1, length1, start2, length2);
	            }
	        }
	
	        function mergeLow(start1, length1, start2, length2) {
	            var i = 0;
	
	            for (i = 0; i < length1; i++) {
	                tmp[i] = array[start1 + i];
	            }
	
	            var cursor1 = 0;
	            var cursor2 = start2;
	            var dest = start1;
	
	            array[dest++] = array[cursor2++];
	
	            if (--length2 === 0) {
	                for (i = 0; i < length1; i++) {
	                    array[dest + i] = tmp[cursor1 + i];
	                }
	                return;
	            }
	
	            if (length1 === 1) {
	                for (i = 0; i < length2; i++) {
	                    array[dest + i] = array[cursor2 + i];
	                }
	                array[dest + length2] = tmp[cursor1];
	                return;
	            }
	
	            var _minGallop = minGallop;
	            var count1, count2, exit;
	
	            while (1) {
	                count1 = 0;
	                count2 = 0;
	                exit = false;
	
	                do {
	                    if (compare(array[cursor2], tmp[cursor1]) < 0) {
	                        array[dest++] = array[cursor2++];
	                        count2++;
	                        count1 = 0;
	
	                        if (--length2 === 0) {
	                            exit = true;
	                            break;
	                        }
	                    }
	                    else {
	                        array[dest++] = tmp[cursor1++];
	                        count1++;
	                        count2 = 0;
	                        if (--length1 === 1) {
	                            exit = true;
	                            break;
	                        }
	                    }
	                } while ((count1 | count2) < _minGallop);
	
	                if (exit) {
	                    break;
	                }
	
	                do {
	                    count1 = gallopRight(array[cursor2], tmp, cursor1, length1, 0, compare);
	
	                    if (count1 !== 0) {
	                        for (i = 0; i < count1; i++) {
	                            array[dest + i] = tmp[cursor1 + i];
	                        }
	
	                        dest += count1;
	                        cursor1 += count1;
	                        length1 -= count1;
	                        if (length1 <= 1) {
	                            exit = true;
	                            break;
	                        }
	                    }
	
	                    array[dest++] = array[cursor2++];
	
	                    if (--length2 === 0) {
	                        exit = true;
	                        break;
	                    }
	
	                    count2 = gallopLeft(tmp[cursor1], array, cursor2, length2, 0, compare);
	
	                    if (count2 !== 0) {
	                        for (i = 0; i < count2; i++) {
	                            array[dest + i] = array[cursor2 + i];
	                        }
	
	                        dest += count2;
	                        cursor2 += count2;
	                        length2 -= count2;
	
	                        if (length2 === 0) {
	                            exit = true;
	                            break;
	                        }
	                    }
	                    array[dest++] = tmp[cursor1++];
	
	                    if (--length1 === 1) {
	                        exit = true;
	                        break;
	                    }
	
	                    _minGallop--;
	                } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);
	
	                if (exit) {
	                    break;
	                }
	
	                if (_minGallop < 0) {
	                    _minGallop = 0;
	                }
	
	                _minGallop += 2;
	            }
	
	            minGallop = _minGallop;
	
	            minGallop < 1 && (minGallop = 1);
	
	            if (length1 === 1) {
	                for (i = 0; i < length2; i++) {
	                    array[dest + i] = array[cursor2 + i];
	                }
	                array[dest + length2] = tmp[cursor1];
	            }
	            else if (length1 === 0) {
	                throw new Error();
	                // throw new Error('mergeLow preconditions were not respected');
	            }
	            else {
	                for (i = 0; i < length1; i++) {
	                    array[dest + i] = tmp[cursor1 + i];
	                }
	            }
	        }
	
	        function mergeHigh (start1, length1, start2, length2) {
	            var i = 0;
	
	            for (i = 0; i < length2; i++) {
	                tmp[i] = array[start2 + i];
	            }
	
	            var cursor1 = start1 + length1 - 1;
	            var cursor2 = length2 - 1;
	            var dest = start2 + length2 - 1;
	            var customCursor = 0;
	            var customDest = 0;
	
	            array[dest--] = array[cursor1--];
	
	            if (--length1 === 0) {
	                customCursor = dest - (length2 - 1);
	
	                for (i = 0; i < length2; i++) {
	                    array[customCursor + i] = tmp[i];
	                }
	
	                return;
	            }
	
	            if (length2 === 1) {
	                dest -= length1;
	                cursor1 -= length1;
	                customDest = dest + 1;
	                customCursor = cursor1 + 1;
	
	                for (i = length1 - 1; i >= 0; i--) {
	                    array[customDest + i] = array[customCursor + i];
	                }
	
	                array[dest] = tmp[cursor2];
	                return;
	            }
	
	            var _minGallop = minGallop;
	
	            while (true) {
	                var count1 = 0;
	                var count2 = 0;
	                var exit = false;
	
	                do {
	                    if (compare(tmp[cursor2], array[cursor1]) < 0) {
	                        array[dest--] = array[cursor1--];
	                        count1++;
	                        count2 = 0;
	                        if (--length1 === 0) {
	                            exit = true;
	                            break;
	                        }
	                    }
	                    else {
	                        array[dest--] = tmp[cursor2--];
	                        count2++;
	                        count1 = 0;
	                        if (--length2 === 1) {
	                            exit = true;
	                            break;
	                        }
	                    }
	                } while ((count1 | count2) < _minGallop);
	
	                if (exit) {
	                    break;
	                }
	
	                do {
	                    count1 = length1 - gallopRight(tmp[cursor2], array, start1, length1, length1 - 1, compare);
	
	                    if (count1 !== 0) {
	                        dest -= count1;
	                        cursor1 -= count1;
	                        length1 -= count1;
	                        customDest = dest + 1;
	                        customCursor = cursor1 + 1;
	
	                        for (i = count1 - 1; i >= 0; i--) {
	                            array[customDest + i] = array[customCursor + i];
	                        }
	
	                        if (length1 === 0) {
	                            exit = true;
	                            break;
	                        }
	                    }
	
	                    array[dest--] = tmp[cursor2--];
	
	                    if (--length2 === 1) {
	                        exit = true;
	                        break;
	                    }
	
	                    count2 = length2 - gallopLeft(array[cursor1], tmp, 0, length2, length2 - 1, compare);
	
	                    if (count2 !== 0) {
	                        dest -= count2;
	                        cursor2 -= count2;
	                        length2 -= count2;
	                        customDest = dest + 1;
	                        customCursor = cursor2 + 1;
	
	                        for (i = 0; i < count2; i++) {
	                            array[customDest + i] = tmp[customCursor + i];
	                        }
	
	                        if (length2 <= 1) {
	                            exit = true;
	                            break;
	                        }
	                    }
	
	                    array[dest--] = array[cursor1--];
	
	                    if (--length1 === 0) {
	                        exit = true;
	                        break;
	                    }
	
	                    _minGallop--;
	                } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);
	
	                if (exit) {
	                    break;
	                }
	
	                if (_minGallop < 0) {
	                    _minGallop = 0;
	                }
	
	                _minGallop += 2;
	            }
	
	            minGallop = _minGallop;
	
	            if (minGallop < 1) {
	                minGallop = 1;
	            }
	
	            if (length2 === 1) {
	                dest -= length1;
	                cursor1 -= length1;
	                customDest = dest + 1;
	                customCursor = cursor1 + 1;
	
	                for (i = length1 - 1; i >= 0; i--) {
	                    array[customDest + i] = array[customCursor + i];
	                }
	
	                array[dest] = tmp[cursor2];
	            }
	            else if (length2 === 0) {
	                throw new Error();
	                // throw new Error('mergeHigh preconditions were not respected');
	            }
	            else {
	                customCursor = dest - (length2 - 1);
	                for (i = 0; i < length2; i++) {
	                    array[customCursor + i] = tmp[i];
	                }
	            }
	        }
	
	        this.mergeRuns = mergeRuns;
	        this.forceMergeRuns = forceMergeRuns;
	        this.pushRun = pushRun;
	    }
	
	    function sort(array, compare, lo, hi) {
	        if (!lo) {
	            lo = 0;
	        }
	        if (!hi) {
	            hi = array.length;
	        }
	
	        var remaining = hi - lo;
	
	        if (remaining < 2) {
	            return;
	        }
	
	        var runLength = 0;
	
	        if (remaining < DEFAULT_MIN_MERGE) {
	            runLength = makeAscendingRun(array, lo, hi, compare);
	            binaryInsertionSort(array, lo, hi, lo + runLength, compare);
	            return;
	        }
	
	        var ts = new TimSort(array, compare);
	
	        var minRun = minRunLength(remaining);
	
	        do {
	            runLength = makeAscendingRun(array, lo, hi, compare);
	            if (runLength < minRun) {
	                var force = remaining;
	                if (force > minRun) {
	                    force = minRun;
	                }
	
	                binaryInsertionSort(array, lo, lo + force, lo + runLength, compare);
	                runLength = force;
	            }
	
	            ts.pushRun(lo, runLength);
	            ts.mergeRuns();
	
	            remaining -= runLength;
	            lo += runLength;
	        } while (remaining !== 0);
	
	        ts.forceMergeRuns();
	    }
	
	    module.exports = sort;


/***/ },
/* 65 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	/**
	 * 动画主类, 调度和管理所有动画控制器
	 *
	 * @module zrender/animation/Animation
	 * @author pissang(https://github.com/pissang)
	 */
	// TODO Additive animation
	// http://iosoteric.com/additive-animations-animatewithduration-in-ios-8/
	// https://developer.apple.com/videos/wwdc2014/#236
	
	
	    var util = __webpack_require__(4);
	    var Dispatcher = __webpack_require__(66).Dispatcher;
	
	    var requestAnimationFrame = __webpack_require__(67);
	
	    var Animator = __webpack_require__(16);
	    /**
	     * @typedef {Object} IZRenderStage
	     * @property {Function} update
	     */
	
	    /**
	     * @alias module:zrender/animation/Animation
	     * @constructor
	     * @param {Object} [options]
	     * @param {Function} [options.onframe]
	     * @param {IZRenderStage} [options.stage]
	     * @example
	     *     var animation = new Animation();
	     *     var obj = {
	     *         x: 100,
	     *         y: 100
	     *     };
	     *     animation.animate(node.position)
	     *         .when(1000, {
	     *             x: 500,
	     *             y: 500
	     *         })
	     *         .when(2000, {
	     *             x: 100,
	     *             y: 100
	     *         })
	     *         .start('spline');
	     */
	    var Animation = function (options) {
	
	        options = options || {};
	
	        this.stage = options.stage || {};
	
	        this.onframe = options.onframe || function() {};
	
	        // private properties
	        this._clips = [];
	
	        this._running = false;
	
	        this._time;
	
	        this._pausedTime;
	
	        this._pauseStart;
	
	        this._paused = false;
	
	        Dispatcher.call(this);
	    };
	
	    Animation.prototype = {
	
	        constructor: Animation,
	        /**
	         * 添加 clip
	         * @param {module:zrender/animation/Clip} clip
	         */
	        addClip: function (clip) {
	            this._clips.push(clip);
	        },
	        /**
	         * 添加 animator
	         * @param {module:zrender/animation/Animator} animator
	         */
	        addAnimator: function (animator) {
	            animator.animation = this;
	            var clips = animator.getClips();
	            for (var i = 0; i < clips.length; i++) {
	                this.addClip(clips[i]);
	            }
	        },
	        /**
	         * 删除动画片段
	         * @param {module:zrender/animation/Clip} clip
	         */
	        removeClip: function(clip) {
	            var idx = util.indexOf(this._clips, clip);
	            if (idx >= 0) {
	                this._clips.splice(idx, 1);
	            }
	        },
	
	        /**
	         * 删除动画片段
	         * @param {module:zrender/animation/Animator} animator
	         */
	        removeAnimator: function (animator) {
	            var clips = animator.getClips();
	            for (var i = 0; i < clips.length; i++) {
	                this.removeClip(clips[i]);
	            }
	            animator.animation = null;
	        },
	
	        _update: function() {
	
	            var time = new Date().getTime() - this._pausedTime;
	            var delta = time - this._time;
	            var clips = this._clips;
	            var len = clips.length;
	
	            var deferredEvents = [];
	            var deferredClips = [];
	            for (var i = 0; i < len; i++) {
	                var clip = clips[i];
	                var e = clip.step(time);
	                // Throw out the events need to be called after
	                // stage.update, like destroy
	                if (e) {
	                    deferredEvents.push(e);
	                    deferredClips.push(clip);
	                }
	            }
	
	            // Remove the finished clip
	            for (var i = 0; i < len;) {
	                if (clips[i]._needsRemove) {
	                    clips[i] = clips[len - 1];
	                    clips.pop();
	                    len--;
	                }
	                else {
	                    i++;
	                }
	            }
	
	            len = deferredEvents.length;
	            for (var i = 0; i < len; i++) {
	                deferredClips[i].fire(deferredEvents[i]);
	            }
	
	            this._time = time;
	
	            this.onframe(delta);
	
	            this.trigger('frame', delta);
	
	            if (this.stage.update) {
	                this.stage.update();
	            }
	        },
	
	        _startLoop: function () {
	            var self = this;
	
	            this._running = true;
	
	            function step() {
	                if (self._running) {
	
	                    requestAnimationFrame(step);
	
	                    !self._paused && self._update();
	                }
	            }
	
	            requestAnimationFrame(step);
	        },
	
	        /**
	         * 开始运行动画
	         */
	        start: function () {
	
	            this._time = new Date().getTime();
	            this._pausedTime = 0;
	
	            this._startLoop();
	        },
	        /**
	         * 停止运行动画
	         */
	        stop: function () {
	            this._running = false;
	        },
	
	        /**
	         * Pause
	         */
	        pause: function () {
	            if (!this._paused) {
	                this._pauseStart = new Date().getTime();
	                this._paused = true;
	            }
	        },
	
	        /**
	         * Resume
	         */
	        resume: function () {
	            if (this._paused) {
	                this._pausedTime += (new Date().getTime()) - this._pauseStart;
	                this._paused = false;
	            }
	        },
	
	        /**
	         * 清除所有动画片段
	         */
	        clear: function () {
	            this._clips = [];
	        },
	        /**
	         * 对一个目标创建一个animator对象，可以指定目标中的属性使用动画
	         * @param  {Object} target
	         * @param  {Object} options
	         * @param  {boolean} [options.loop=false] 是否循环播放动画
	         * @param  {Function} [options.getter=null]
	         *         如果指定getter函数，会通过getter函数取属性值
	         * @param  {Function} [options.setter=null]
	         *         如果指定setter函数，会通过setter函数设置属性值
	         * @return {module:zrender/animation/Animation~Animator}
	         */
	        // TODO Gap
	        animate: function (target, options) {
	            options = options || {};
	            var animator = new Animator(
	                target,
	                options.loop,
	                options.getter,
	                options.setter
	            );
	
	            return animator;
	        }
	    };
	
	    util.mixin(Animation, Dispatcher);
	
	    module.exports = Animation;
	


/***/ },
/* 66 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	/**
	 * 事件辅助类
	 * @module zrender/core/event
	 * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)
	 */
	
	
	    var Eventful = __webpack_require__(11);
	
	    var isDomLevel2 = (typeof window !== 'undefined') && !!window.addEventListener;
	
	    function getBoundingClientRect(el) {
	        // BlackBerry 5, iOS 3 (original iPhone) don't have getBoundingRect
	        return el.getBoundingClientRect ? el.getBoundingClientRect() : {left: 0, top: 0};
	    }
	
	    function clientToLocal(el, e, out) {
	        // clientX/clientY is according to view port.
	        var box = getBoundingClientRect(el);
	        out = out || {};
	        out.zrX = e.clientX - box.left;
	        out.zrY = e.clientY - box.top;
	        return out;
	    }
	
	    /**
	     * 如果存在第三方嵌入的一些dom触发的事件，或touch事件，需要转换一下事件坐标
	     */
	    function normalizeEvent(el, e) {
	
	        e = e || window.event;
	
	        if (e.zrX != null) {
	            return e;
	        }
	
	        var eventType = e.type;
	        var isTouch = eventType && eventType.indexOf('touch') >= 0;
	
	        if (!isTouch) {
	            clientToLocal(el, e, e);
	            e.zrDelta = (e.wheelDelta) ? e.wheelDelta / 120 : -(e.detail || 0) / 3;
	        }
	        else {
	            var touch = eventType != 'touchend'
	                ? e.targetTouches[0]
	                : e.changedTouches[0];
	            touch && clientToLocal(el, touch, e);
	        }
	
	        return e;
	    }
	
	    function addEventListener(el, name, handler) {
	        if (isDomLevel2) {
	            el.addEventListener(name, handler);
	        }
	        else {
	            el.attachEvent('on' + name, handler);
	        }
	    }
	
	    function removeEventListener(el, name, handler) {
	        if (isDomLevel2) {
	            el.removeEventListener(name, handler);
	        }
	        else {
	            el.detachEvent('on' + name, handler);
	        }
	    }
	
	    /**
	     * 停止冒泡和阻止默认行为
	     * @memberOf module:zrender/core/event
	     * @method
	     * @param {Event} e : event对象
	     */
	    var stop = isDomLevel2
	        ? function (e) {
	            e.preventDefault();
	            e.stopPropagation();
	            e.cancelBubble = true;
	        }
	        : function (e) {
	            e.returnValue = false;
	            e.cancelBubble = true;
	        };
	
	    module.exports = {
	        clientToLocal: clientToLocal,
	        normalizeEvent: normalizeEvent,
	        addEventListener: addEventListener,
	        removeEventListener: removeEventListener,
	
	        stop: stop,
	        // 做向上兼容
	        Dispatcher: Eventful
	    };
	


/***/ },
/* 67 */
/***/ function(module, exports) {

	
	
	    module.exports = (typeof window !== 'undefined' &&
	                                    (window.requestAnimationFrame
	                                    || window.msRequestAnimationFrame
	                                    || window.mozRequestAnimationFrame
	                                    || window.webkitRequestAnimationFrame))
	                                || function (func) {
	                                    setTimeout(func, 16);
	                                };
	


/***/ },
/* 68 */
/***/ function(module, exports, __webpack_require__) {

	
	
	    var eventTool = __webpack_require__(66);
	    var zrUtil = __webpack_require__(4);
	    var Eventful = __webpack_require__(11);
	    var env = __webpack_require__(61);
	    var GestureMgr = __webpack_require__(69);
	
	    var addEventListener = eventTool.addEventListener;
	    var removeEventListener = eventTool.removeEventListener;
	    var normalizeEvent = eventTool.normalizeEvent;
	
	    var TOUCH_CLICK_DELAY = 300;
	
	    var mouseHandlerNames = [
	        'click', 'dblclick', 'mousewheel', 'mouseout',
	        'mouseup', 'mousedown', 'mousemove'
	    ];
	
	    var touchHandlerNames = [
	        'touchstart', 'touchend', 'touchmove'
	    ];
	
	    function eventNameFix(name) {
	        return (name === 'mousewheel' && env.browser.firefox) ? 'DOMMouseScroll' : name;
	    }
	
	    function processGesture(proxy, event, stage) {
	        var gestureMgr = proxy._gestureMgr;
	
	        stage === 'start' && gestureMgr.clear();
	
	        var gestureInfo = gestureMgr.recognize(
	            event,
	            proxy.handler.findHover(event.zrX, event.zrY, null),
	            proxy.dom
	        );
	
	        stage === 'end' && gestureMgr.clear();
	
	        if (gestureInfo) {
	            // eventTool.stop(event);
	            var type = gestureInfo.type;
	            event.gestureEvent = type;
	
	            proxy.handler.dispatchToElement(gestureInfo.target, type, gestureInfo.event);
	        }
	    }
	
	    /**
	     * Prevent mouse event from being dispatched after Touch Events action
	     * @see <https://github.com/deltakosh/handjs/blob/master/src/hand.base.js>
	     * 1. Mobile browsers dispatch mouse events 300ms after touchend.
	     * 2. Chrome for Android dispatch mousedown for long-touch about 650ms
	     * Result: Blocking Mouse Events for 700ms.
	     */
	    function setTouchTimer(instance) {
	        instance._touching = true;
	        clearTimeout(instance._touchTimer);
	        instance._touchTimer = setTimeout(function () {
	            instance._touching = false;
	        }, 700);
	    }
	
	    function useTouchEvent() {
	        return env.touchEventsSupported;
	    }
	
	    var domHandlers = {
	        /**
	         * Mouse move handler
	         * @inner
	         * @param {Event} event
	         */
	        mousemove: function (event) {
	            event = normalizeEvent(this.dom, event);
	
	            this.trigger('mousemove', event);
	        },
	
	        /**
	         * Mouse out handler
	         * @inner
	         * @param {Event} event
	         */
	        mouseout: function (event) {
	            event = normalizeEvent(this.dom, event);
	
	            var element = event.toElement || event.relatedTarget;
	            if (element != this.dom) {
	                while (element && element.nodeType != 9) {
	                    // 忽略包含在root中的dom引起的mouseOut
	                    if (element === this.dom) {
	                        return;
	                    }
	
	                    element = element.parentNode;
	                }
	            }
	
	            this.trigger('mouseout', event);
	        },
	
	        /**
	         * Touch开始响应函数
	         * @inner
	         * @param {Event} event
	         */
	        touchstart: function (event) {
	            // Default mouse behaviour should not be disabled here.
	            // For example, page may needs to be slided.
	
	            event = normalizeEvent(this.dom, event);
	
	            this._lastTouchMoment = new Date();
	
	            processGesture(this, event, 'start');
	
	            // 平板补充一次findHover
	            // this._mobileFindFixed(event);
	            // Trigger mousemove and mousedown
	            domHandlers.mousemove.call(this, event);
	
	            domHandlers.mousedown.call(this, event);
	
	            setTouchTimer(this);
	        },
	
	        /**
	         * Touch移动响应函数
	         * @inner
	         * @param {Event} event
	         */
	        touchmove: function (event) {
	
	            event = normalizeEvent(this.dom, event);
	
	            processGesture(this, event, 'change');
	
	            // Mouse move should always be triggered no matter whether
	            // there is gestrue event, because mouse move and pinch may
	            // be used at the same time.
	            domHandlers.mousemove.call(this, event);
	
	            setTouchTimer(this);
	        },
	
	        /**
	         * Touch结束响应函数
	         * @inner
	         * @param {Event} event
	         */
	        touchend: function (event) {
	
	            event = normalizeEvent(this.dom, event);
	
	            processGesture(this, event, 'end');
	
	            domHandlers.mouseup.call(this, event);
	
	            // click event should always be triggered no matter whether
	            // there is gestrue event. System click can not be prevented.
	            if (+new Date() - this._lastTouchMoment < TOUCH_CLICK_DELAY) {
	                domHandlers.click.call(this, event);
	            }
	
	            setTouchTimer(this);
	        }
	    };
	
	    // Common handlers
	    zrUtil.each(['click', 'mousedown', 'mouseup', 'mousewheel', 'dblclick'], function (name) {
	        domHandlers[name] = function (event) {
	            event = normalizeEvent(this.dom, event);
	            this.trigger(name, event);
	        };
	    });
	
	    /**
	     * 为控制类实例初始化dom 事件处理函数
	     *
	     * @inner
	     * @param {module:zrender/Handler} instance 控制类实例
	     */
	    function initDomHandler(instance) {
	        for (var i = 0; i < touchHandlerNames.length; i++) {
	            var name = touchHandlerNames[i];
	            instance._handlers[name] = zrUtil.bind(domHandlers[name], instance);
	        }
	
	        for (var i = 0; i < mouseHandlerNames.length; i++) {
	            var name = mouseHandlerNames[i];
	            instance._handlers[name] = makeMouseHandler(domHandlers[name], instance);
	        }
	
	        function makeMouseHandler(fn, instance) {
	            return function () {
	                if (instance._touching) {
	                    return;
	                }
	                return fn.apply(instance, arguments);
	            };
	        }
	    }
	
	
	    function HandlerDomProxy(dom) {
	        Eventful.call(this);
	
	        this.dom = dom;
	
	        /**
	         * @private
	         * @type {boolean}
	         */
	        this._touching = false;
	
	        /**
	         * @private
	         * @type {number}
	         */
	        this._touchTimer;
	
	        /**
	         * @private
	         * @type {module:zrender/core/GestureMgr}
	         */
	        this._gestureMgr = new GestureMgr();
	
	        this._handlers = {};
	
	        initDomHandler(this);
	
	        if (useTouchEvent()) {
	            mountHandlers(touchHandlerNames, this);
	
	            // Handler of 'mouseout' event is needed in touch mode, which will be mounted below.
	            // addEventListener(root, 'mouseout', this._mouseoutHandler);
	        }
	
	        // Considering some devices that both enable touch and mouse event (like MS Surface
	        // and lenovo X240, @see #2350), we make mouse event be always listened, otherwise
	        // mouse event can not be handle in those devices.
	        mountHandlers(mouseHandlerNames, this);
	
	        function mountHandlers(handlerNames, instance) {
	            zrUtil.each(handlerNames, function (name) {
	                addEventListener(dom, eventNameFix(name), instance._handlers[name]);
	            }, instance);
	        }
	    }
	
	    var handlerDomProxyProto = HandlerDomProxy.prototype;
	    handlerDomProxyProto.dispose = function () {
	        var handlerNames = mouseHandlerNames.concat(touchHandlerNames);
	
	        for (var i = 0; i < handlerNames.length; i++) {
	            var name = handlerNames[i];
	            removeEventListener(this.dom, eventNameFix(name), this._handlers[name]);
	        }
	    };
	
	    handlerDomProxyProto.setCursor = function (cursorStyle) {
	        this.dom.style.cursor = cursorStyle || 'default';
	    };
	
	    zrUtil.mixin(HandlerDomProxy, Eventful);
	
	    module.exports = HandlerDomProxy;


/***/ },
/* 69 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	/**
	 * Only implements needed gestures for mobile.
	 */
	
	
	    var eventUtil = __webpack_require__(66);
	
	    var GestureMgr = function () {
	
	        /**
	         * @private
	         * @type {Array.<Object>}
	         */
	        this._track = [];
	    };
	
	    GestureMgr.prototype = {
	
	        constructor: GestureMgr,
	
	        recognize: function (event, target, root) {
	            this._doTrack(event, target, root);
	            return this._recognize(event);
	        },
	
	        clear: function () {
	            this._track.length = 0;
	            return this;
	        },
	
	        _doTrack: function (event, target, root) {
	            var touches = event.touches;
	
	            if (!touches) {
	                return;
	            }
	
	            var trackItem = {
	                points: [],
	                touches: [],
	                target: target,
	                event: event
	            };
	
	            for (var i = 0, len = touches.length; i < len; i++) {
	                var touch = touches[i];
	                var pos = eventUtil.clientToLocal(root, touch);
	                trackItem.points.push([pos.zrX, pos.zrY]);
	                trackItem.touches.push(touch);
	            }
	
	            this._track.push(trackItem);
	        },
	
	        _recognize: function (event) {
	            for (var eventName in recognizers) {
	                if (recognizers.hasOwnProperty(eventName)) {
	                    var gestureInfo = recognizers[eventName](this._track, event);
	                    if (gestureInfo) {
	                        return gestureInfo;
	                    }
	                }
	            }
	        }
	    };
	
	    function dist(pointPair) {
	        var dx = pointPair[1][0] - pointPair[0][0];
	        var dy = pointPair[1][1] - pointPair[0][1];
	
	        return Math.sqrt(dx * dx + dy * dy);
	    }
	
	    function center(pointPair) {
	        return [
	            (pointPair[0][0] + pointPair[1][0]) / 2,
	            (pointPair[0][1] + pointPair[1][1]) / 2
	        ];
	    }
	
	    var recognizers = {
	
	        pinch: function (track, event) {
	            var trackLen = track.length;
	
	            if (!trackLen) {
	                return;
	            }
	
	            var pinchEnd = (track[trackLen - 1] || {}).points;
	            var pinchPre = (track[trackLen - 2] || {}).points || pinchEnd;
	
	            if (pinchPre
	                && pinchPre.length > 1
	                && pinchEnd
	                && pinchEnd.length > 1
	            ) {
	                var pinchScale = dist(pinchEnd) / dist(pinchPre);
	                !isFinite(pinchScale) && (pinchScale = 1);
	
	                event.pinchScale = pinchScale;
	
	                var pinchCenter = center(pinchEnd);
	                event.pinchX = pinchCenter[0];
	                event.pinchY = pinchCenter[1];
	
	                return {
	                    type: 'pinch',
	                    target: track[0].target,
	                    event: event
	                };
	            }
	        }
	
	        // Only pinch currently.
	    };
	
	    module.exports = GestureMgr;
	


/***/ },
/* 70 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	/**
	 * Default canvas painter
	 * @module zrender/Painter
	 * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)
	 *         errorrik (errorrik@gmail.com)
	 *         pissang (https://www.github.com/pissang)
	 */
	 
	
	    var config = __webpack_require__(21);
	    var util = __webpack_require__(4);
	    var log = __webpack_require__(20);
	    var BoundingRect = __webpack_require__(24);
	    var timsort = __webpack_require__(64);
	
	    var Layer = __webpack_require__(71);
	
	    var requestAnimationFrame = __webpack_require__(67);
	
	    // PENDIGN
	    // Layer exceeds MAX_PROGRESSIVE_LAYER_NUMBER may have some problem when flush directly second time.
	    //
	    // Maximum progressive layer. When exceeding this number. All elements will be drawed in the last layer.
	    var MAX_PROGRESSIVE_LAYER_NUMBER = 5;
	
	    function parseInt10(val) {
	        return parseInt(val, 10);
	    }
	
	    function isLayerValid(layer) {
	        if (!layer) {
	            return false;
	        }
	
	        if (layer.isBuildin) {
	            return true;
	        }
	
	        if (typeof(layer.resize) !== 'function'
	            || typeof(layer.refresh) !== 'function'
	        ) {
	            return false;
	        }
	
	        return true;
	    }
	
	    function preProcessLayer(layer) {
	        layer.__unusedCount++;
	    }
	
	    function postProcessLayer(layer) {
	        if (layer.__unusedCount == 1) {
	            layer.clear();
	        }
	    }
	
	    var tmpRect = new BoundingRect(0, 0, 0, 0);
	    var viewRect = new BoundingRect(0, 0, 0, 0);
	    function isDisplayableCulled(el, width, height) {
	        tmpRect.copy(el.getBoundingRect());
	        if (el.transform) {
	            tmpRect.applyTransform(el.transform);
	        }
	        viewRect.width = width;
	        viewRect.height = height;
	        return !tmpRect.intersect(viewRect);
	    }
	
	    function isClipPathChanged(clipPaths, prevClipPaths) {
	        if (clipPaths == prevClipPaths) { // Can both be null or undefined
	            return false;
	        }
	
	        if (!clipPaths || !prevClipPaths || (clipPaths.length !== prevClipPaths.length)) {
	            return true;
	        }
	        for (var i = 0; i < clipPaths.length; i++) {
	            if (clipPaths[i] !== prevClipPaths[i]) {
	                return true;
	            }
	        }
	    }
	
	    function doClip(clipPaths, ctx) {
	        for (var i = 0; i < clipPaths.length; i++) {
	            var clipPath = clipPaths[i];
	            var path = clipPath.path;
	
	            clipPath.setTransform(ctx);
	            path.beginPath(ctx);
	            clipPath.buildPath(path, clipPath.shape);
	            ctx.clip();
	            // Transform back
	            clipPath.restoreTransform(ctx);
	        }
	    }
	
	    function createRoot(width, height) {
	        var domRoot = document.createElement('div');
	        var domRootStyle = domRoot.style;
	
	        // domRoot.onselectstart = returnFalse; // 避免页面选中的尴尬
	        domRootStyle.position = 'relative';
	        domRootStyle.overflow = 'hidden';
	        domRootStyle.width = width + 'px';
	        domRootStyle.height = height + 'px';
	        return domRoot;
	    }
	
	    /**
	     * @alias module:zrender/Painter
	     * @constructor
	     * @param {HTMLElement} root 绘图容器
	     * @param {module:zrender/Storage} storage
	     * @param {Ojbect} opts
	     */
	    var Painter = function (root, storage, opts) {
	        // In node environment using node-canvas
	        var singleCanvas = !root.nodeName // In node ?
	            || root.nodeName.toUpperCase() === 'CANVAS';
	
	        opts = opts || {};
	
	        /**
	         * @type {number}
	         */
	        this.dpr = opts.devicePixelRatio || config.devicePixelRatio;
	        /**
	         * @type {boolean}
	         * @private
	         */
	        this._singleCanvas = singleCanvas;
	        /**
	         * 绘图容器
	         * @type {HTMLElement}
	         */
	        this.root = root;
	
	        var rootStyle = root.style;
	
	        if (rootStyle) {
	            rootStyle['-webkit-tap-highlight-color'] = 'transparent';
	            rootStyle['-webkit-user-select'] =
	            rootStyle['user-select'] =
	            rootStyle['-webkit-touch-callout'] = 'none';
	
	            root.innerHTML = '';
	        }
	
	        /**
	         * @type {module:zrender/Storage}
	         */
	        this.storage = storage;
	
	        /**
	         * @type {Array.<number>}
	         * @private
	         */
	        var zlevelList = this._zlevelList = [];
	
	        /**
	         * @type {Object.<string, module:zrender/Layer>}
	         * @private
	         */
	        var layers = this._layers = {};
	
	        /**
	         * @type {Object.<string, Object>}
	         * @type {private}
	         */
	        this._layerConfig = {};
	
	        if (!singleCanvas) {
	            this._width = this._getWidth();
	            this._height = this._getHeight();
	
	            var domRoot = this._domRoot = createRoot(
	                this._width, this._height
	            );
	            root.appendChild(domRoot);
	        }
	        else {
	            // Use canvas width and height directly
	            var width = root.width;
	            var height = root.height;
	            this._width = width;
	            this._height = height;
	
	            // Create layer if only one given canvas
	            // Device pixel ratio is fixed to 1 because given canvas has its specified width and height
	            var mainLayer = new Layer(root, this, 1);
	            mainLayer.initContext();
	            // FIXME Use canvas width and height
	            // mainLayer.resize(width, height);
	            layers[0] = mainLayer;
	            zlevelList.push(0);
	        }
	
	        this.pathToImage = this._createPathToImage();
	
	        // Layers for progressive rendering
	        this._progressiveLayers = [];
	
	        /**
	         * @type {module:zrender/Layer}
	         * @private
	         */
	        this._hoverlayer;
	
	        this._hoverElements = [];
	    };
	
	    Painter.prototype = {
	
	        constructor: Painter,
	
	        /**
	         * If painter use a single canvas
	         * @return {boolean}
	         */
	        isSingleCanvas: function () {
	            return this._singleCanvas;
	        },
	        /**
	         * @return {HTMLDivElement}
	         */
	        getViewportRoot: function () {
	            return this._singleCanvas ? this._layers[0].dom : this._domRoot;
	        },
	
	        /**
	         * 刷新
	         * @param {boolean} [paintAll=false] 强制绘制所有displayable
	         */
	        refresh: function (paintAll) {
	
	            var list = this.storage.getDisplayList(true);
	
	            var zlevelList = this._zlevelList;
	
	            this._paintList(list, paintAll);
	
	            // Paint custum layers
	            for (var i = 0; i < zlevelList.length; i++) {
	                var z = zlevelList[i];
	                var layer = this._layers[z];
	                if (!layer.isBuildin && layer.refresh) {
	                    layer.refresh();
	                }
	            }
	
	            this.refreshHover();
	
	            if (this._progressiveLayers.length) {
	                this._startProgessive();
	            }
	
	            return this;
	        },
	
	        addHover: function (el, hoverStyle) {
	            if (el.__hoverMir) {
	                return;
	            }
	            var elMirror = new el.constructor({
	                style: el.style,
	                shape: el.shape
	            });
	            elMirror.__from = el;
	            el.__hoverMir = elMirror;
	            elMirror.setStyle(hoverStyle);
	            this._hoverElements.push(elMirror);
	        },
	
	        removeHover: function (el) {
	            var elMirror = el.__hoverMir;
	            var hoverElements = this._hoverElements;
	            var idx = util.indexOf(hoverElements, elMirror);
	            if (idx >= 0) {
	                hoverElements.splice(idx, 1);
	            }
	            el.__hoverMir = null;
	        },
	
	        clearHover: function (el) {
	            var hoverElements = this._hoverElements;
	            for (var i = 0; i < hoverElements.length; i++) {
	                var from = hoverElements[i].__from;
	                if (from) {
	                    from.__hoverMir = null;
	                }
	            }
	            hoverElements.length = 0;
	        },
	
	        refreshHover: function () {
	            var hoverElements = this._hoverElements;
	            var len = hoverElements.length;
	            var hoverLayer = this._hoverlayer;
	            hoverLayer && hoverLayer.clear();
	
	            if (!len) {
	                return;
	            }
	            timsort(hoverElements, this.storage.displayableSortFunc);
	
	            // Use a extream large zlevel
	            // FIXME?
	            if (!hoverLayer) {
	                hoverLayer = this._hoverlayer = this.getLayer(1e5);
	            }
	
	            var scope = {};
	            hoverLayer.ctx.save();
	            for (var i = 0; i < len;) {
	                var el = hoverElements[i];
	                var originalEl = el.__from;
	                // Original el is removed
	                // PENDING
	                if (!(originalEl && originalEl.__zr)) {
	                    hoverElements.splice(i, 1);
	                    originalEl.__hoverMir = null;
	                    len--;
	                    continue;
	                }
	                i++;
	
	                // Use transform
	                // FIXME style and shape ?
	                if (!originalEl.invisible) {
	                    el.transform = originalEl.transform;
	                    el.invTransform = originalEl.invTransform;
	                    el.__clipPaths = originalEl.__clipPaths;
	                    // el.
	                    this._doPaintEl(el, hoverLayer, true, scope);
	                }
	            }
	            hoverLayer.ctx.restore();
	        },
	
	        _startProgessive: function () {
	            var self = this;
	
	            if (!self._furtherProgressive) {
	                return;
	            }
	
	            // Use a token to stop progress steps triggered by
	            // previous zr.refresh calling.
	            var token = self._progressiveToken = +new Date();
	
	            self._progress++;
	            requestAnimationFrame(step);
	
	            function step() {
	                // In case refreshed or disposed
	                if (token === self._progressiveToken && self.storage) {
	
	                    self._doPaintList(self.storage.getDisplayList());
	
	                    if (self._furtherProgressive) {
	                        self._progress++;
	                        requestAnimationFrame(step);
	                    }
	                    else {
	                        self._progressiveToken = -1;
	                    }
	                }
	            }
	        },
	
	        _clearProgressive: function () {
	            this._progressiveToken = -1;
	            this._progress = 0;
	            util.each(this._progressiveLayers, function (layer) {
	                layer.__dirty && layer.clear();
	            });
	        },
	
	        _paintList: function (list, paintAll) {
	
	            if (paintAll == null) {
	                paintAll = false;
	            }
	
	            this._updateLayerStatus(list);
	
	            this._clearProgressive();
	
	            this.eachBuildinLayer(preProcessLayer);
	
	            this._doPaintList(list, paintAll);
	
	            this.eachBuildinLayer(postProcessLayer);
	        },
	
	        _doPaintList: function (list, paintAll) {
	            var currentLayer;
	            var currentZLevel;
	            var ctx;
	
	            // var invTransform = [];
	            var scope;
	
	            var progressiveLayerIdx = 0;
	            var currentProgressiveLayer;
	
	            var width = this._width;
	            var height = this._height;
	            var layerProgress;
	            var frame = this._progress;
	            function flushProgressiveLayer(layer) {
	                var dpr = ctx.dpr || 1;
	                ctx.save();
	                ctx.globalAlpha = 1;
	                ctx.shadowBlur = 0;
	                // Avoid layer don't clear in next progressive frame
	                currentLayer.__dirty = true;
	                ctx.setTransform(1, 0, 0, 1, 0, 0);
	                ctx.drawImage(layer.dom, 0, 0, width * dpr, height * dpr);
	                ctx.restore();
	            }
	
	            for (var i = 0, l = list.length; i < l; i++) {
	                var el = list[i];
	                var elZLevel = this._singleCanvas ? 0 : el.zlevel;
	
	                var elFrame = el.__frame;
	
	                // Flush at current context
	                // PENDING
	                if (elFrame < 0 && currentProgressiveLayer) {
	                    flushProgressiveLayer(currentProgressiveLayer);
	                    currentProgressiveLayer = null;
	                }
	
	                // Change draw layer
	                if (currentZLevel !== elZLevel) {
	                    if (ctx) {
	                        ctx.restore();
	                    }
	
	                    // Reset scope
	                    scope = {};
	
	                    // Only 0 zlevel if only has one canvas
	                    currentZLevel = elZLevel;
	                    currentLayer = this.getLayer(currentZLevel);
	
	                    if (!currentLayer.isBuildin) {
	                        log(
	                            'ZLevel ' + currentZLevel
	                            + ' has been used by unkown layer ' + currentLayer.id
	                        );
	                    }
	
	                    ctx = currentLayer.ctx;
	                    ctx.save();
	
	                    // Reset the count
	                    currentLayer.__unusedCount = 0;
	
	                    if (currentLayer.__dirty || paintAll) {
	                        currentLayer.clear();
	                    }
	                }
	
	                if (!(currentLayer.__dirty || paintAll)) {
	                    continue;
	                }
	
	                if (elFrame >= 0) {
	                    // Progressive layer changed
	                    if (!currentProgressiveLayer) {
	                        currentProgressiveLayer = this._progressiveLayers[
	                            Math.min(progressiveLayerIdx++, MAX_PROGRESSIVE_LAYER_NUMBER - 1)
	                        ];
	
	                        currentProgressiveLayer.ctx.save();
	                        currentProgressiveLayer.renderScope = {};
	
	                        if (currentProgressiveLayer
	                            && (currentProgressiveLayer.__progress > currentProgressiveLayer.__maxProgress)
	                        ) {
	                            // flushProgressiveLayer(currentProgressiveLayer);
	                            // Quick jump all progressive elements
	                            // All progressive element are not dirty, jump over and flush directly
	                            i = currentProgressiveLayer.__nextIdxNotProg - 1;
	                            // currentProgressiveLayer = null;
	                            continue;
	                        }
	
	                        layerProgress = currentProgressiveLayer.__progress;
	
	                        if (!currentProgressiveLayer.__dirty) {
	                            // Keep rendering
	                            frame = layerProgress;
	                        }
	
	                        currentProgressiveLayer.__progress = frame + 1;
	                    }
	
	                    if (elFrame === frame) {
	                        this._doPaintEl(el, currentProgressiveLayer, true, currentProgressiveLayer.renderScope);
	                    }
	                }
	                else {
	                    this._doPaintEl(el, currentLayer, paintAll, scope);
	                }
	
	                el.__dirty = false;
	            }
	
	            if (currentProgressiveLayer) {
	                flushProgressiveLayer(currentProgressiveLayer);
	            }
	
	            // Restore the lastLayer ctx
	            ctx && ctx.restore();
	            // If still has clipping state
	            // if (scope.prevElClipPaths) {
	            //     ctx.restore();
	            // }
	
	            this._furtherProgressive = false;
	            util.each(this._progressiveLayers, function (layer) {
	                if (layer.__maxProgress >= layer.__progress) {
	                    this._furtherProgressive = true;
	                }
	            }, this);
	        },
	
	        _doPaintEl: function (el, currentLayer, forcePaint, scope) {
	            var ctx = currentLayer.ctx;
	            var m = el.transform;
	            if (
	                (currentLayer.__dirty || forcePaint)
	                // Ignore invisible element
	                && !el.invisible
	                // Ignore transparent element
	                && el.style.opacity !== 0
	                // Ignore scale 0 element, in some environment like node-canvas
	                // Draw a scale 0 element can cause all following draw wrong
	                // And setTransform with scale 0 will cause set back transform failed.
	                && !(m && !m[0] && !m[3])
	                // Ignore culled element
	                && !(el.culling && isDisplayableCulled(el, this._width, this._height))
	            ) {
	
	                var clipPaths = el.__clipPaths;
	
	                // Optimize when clipping on group with several elements
	                if (scope.prevClipLayer !== currentLayer
	                    || isClipPathChanged(clipPaths, scope.prevElClipPaths)
	                ) {
	                    // If has previous clipping state, restore from it
	                    if (scope.prevElClipPaths) {
	                        scope.prevClipLayer.ctx.restore();
	                        scope.prevClipLayer = scope.prevElClipPaths = null;
	
	                        // Reset prevEl since context has been restored
	                        scope.prevEl = null;
	                    }
	                    // New clipping state
	                    if (clipPaths) {
	                        ctx.save();
	                        doClip(clipPaths, ctx);
	                        scope.prevClipLayer = currentLayer;
	                        scope.prevElClipPaths = clipPaths;
	                    }
	                }
	                el.beforeBrush && el.beforeBrush(ctx);
	
	                el.brush(ctx, scope.prevEl || null);
	                scope.prevEl = el;
	
	                el.afterBrush && el.afterBrush(ctx);
	            }
	        },
	
	        /**
	         * 获取 zlevel 所在层，如果不存在则会创建一个新的层
	         * @param {number} zlevel
	         * @return {module:zrender/Layer}
	         */
	        getLayer: function (zlevel) {
	            if (this._singleCanvas) {
	                return this._layers[0];
	            }
	
	            var layer = this._layers[zlevel];
	            if (!layer) {
	                // Create a new layer
	                layer = new Layer('zr_' + zlevel, this, this.dpr);
	                layer.isBuildin = true;
	
	                if (this._layerConfig[zlevel]) {
	                    util.merge(layer, this._layerConfig[zlevel], true);
	                }
	
	                this.insertLayer(zlevel, layer);
	
	                // Context is created after dom inserted to document
	                // Or excanvas will get 0px clientWidth and clientHeight
	                layer.initContext();
	            }
	
	            return layer;
	        },
	
	        insertLayer: function (zlevel, layer) {
	
	            var layersMap = this._layers;
	            var zlevelList = this._zlevelList;
	            var len = zlevelList.length;
	            var prevLayer = null;
	            var i = -1;
	            var domRoot = this._domRoot;
	
	            if (layersMap[zlevel]) {
	                log('ZLevel ' + zlevel + ' has been used already');
	                return;
	            }
	            // Check if is a valid layer
	            if (!isLayerValid(layer)) {
	                log('Layer of zlevel ' + zlevel + ' is not valid');
	                return;
	            }
	
	            if (len > 0 && zlevel > zlevelList[0]) {
	                for (i = 0; i < len - 1; i++) {
	                    if (
	                        zlevelList[i] < zlevel
	                        && zlevelList[i + 1] > zlevel
	                    ) {
	                        break;
	                    }
	                }
	                prevLayer = layersMap[zlevelList[i]];
	            }
	            zlevelList.splice(i + 1, 0, zlevel);
	
	            if (prevLayer) {
	                var prevDom = prevLayer.dom;
	                if (prevDom.nextSibling) {
	                    domRoot.insertBefore(
	                        layer.dom,
	                        prevDom.nextSibling
	                    );
	                }
	                else {
	                    domRoot.appendChild(layer.dom);
	                }
	            }
	            else {
	                if (domRoot.firstChild) {
	                    domRoot.insertBefore(layer.dom, domRoot.firstChild);
	                }
	                else {
	                    domRoot.appendChild(layer.dom);
	                }
	            }
	
	            layersMap[zlevel] = layer;
	        },
	
	        // Iterate each layer
	        eachLayer: function (cb, context) {
	            var zlevelList = this._zlevelList;
	            var z;
	            var i;
	            for (i = 0; i < zlevelList.length; i++) {
	                z = zlevelList[i];
	                cb.call(context, this._layers[z], z);
	            }
	        },
	
	        // Iterate each buildin layer
	        eachBuildinLayer: function (cb, context) {
	            var zlevelList = this._zlevelList;
	            var layer;
	            var z;
	            var i;
	            for (i = 0; i < zlevelList.length; i++) {
	                z = zlevelList[i];
	                layer = this._layers[z];
	                if (layer.isBuildin) {
	                    cb.call(context, layer, z);
	                }
	            }
	        },
	
	        // Iterate each other layer except buildin layer
	        eachOtherLayer: function (cb, context) {
	            var zlevelList = this._zlevelList;
	            var layer;
	            var z;
	            var i;
	            for (i = 0; i < zlevelList.length; i++) {
	                z = zlevelList[i];
	                layer = this._layers[z];
	                if (! layer.isBuildin) {
	                    cb.call(context, layer, z);
	                }
	            }
	        },
	
	        /**
	         * 获取所有已创建的层
	         * @param {Array.<module:zrender/Layer>} [prevLayer]
	         */
	        getLayers: function () {
	            return this._layers;
	        },
	
	        _updateLayerStatus: function (list) {
	
	            var layers = this._layers;
	            var progressiveLayers = this._progressiveLayers;
	
	            var elCountsLastFrame = {};
	            var progressiveElCountsLastFrame = {};
	
	            this.eachBuildinLayer(function (layer, z) {
	                elCountsLastFrame[z] = layer.elCount;
	                layer.elCount = 0;
	                layer.__dirty = false;
	            });
	
	            util.each(progressiveLayers, function (layer, idx) {
	                progressiveElCountsLastFrame[idx] = layer.elCount;
	                layer.elCount = 0;
	                layer.__dirty = false;
	            });
	
	            var progressiveLayerCount = 0;
	            var currentProgressiveLayer;
	            var lastProgressiveKey;
	            var frameCount = 0;
	            for (var i = 0, l = list.length; i < l; i++) {
	                var el = list[i];
	                var zlevel = this._singleCanvas ? 0 : el.zlevel;
	                var layer = layers[zlevel];
	                var elProgress = el.progressive;
	                if (layer) {
	                    layer.elCount++;
	                    layer.__dirty = layer.__dirty || el.__dirty;
	                }
	
	                /////// Update progressive
	                if (elProgress >= 0) {
	                    // Fix wrong progressive sequence problem.
	                    if (lastProgressiveKey !== elProgress) {
	                        lastProgressiveKey = elProgress;
	                        frameCount++;
	                    }
	                    var elFrame = el.__frame = frameCount - 1;
	                    if (!currentProgressiveLayer) {
	                        var idx = Math.min(progressiveLayerCount, MAX_PROGRESSIVE_LAYER_NUMBER - 1);
	                        currentProgressiveLayer = progressiveLayers[idx];
	                        if (!currentProgressiveLayer) {
	                            currentProgressiveLayer = progressiveLayers[idx] = new Layer(
	                                'progressive', this, this.dpr
	                            );
	                            currentProgressiveLayer.initContext();
	                        }
	                        currentProgressiveLayer.__maxProgress = 0;
	                    }
	                    currentProgressiveLayer.__dirty = currentProgressiveLayer.__dirty || el.__dirty;
	                    currentProgressiveLayer.elCount++;
	
	                    currentProgressiveLayer.__maxProgress = Math.max(
	                        currentProgressiveLayer.__maxProgress, elFrame
	                    );
	
	                    if (currentProgressiveLayer.__maxProgress >= currentProgressiveLayer.__progress) {
	                        // Should keep rendering this  layer because progressive rendering is not finished yet
	                        layer.__dirty = true;
	                    }
	                }
	                else {
	                    el.__frame = -1;
	
	                    if (currentProgressiveLayer) {
	                        currentProgressiveLayer.__nextIdxNotProg = i;
	                        progressiveLayerCount++;
	                        currentProgressiveLayer = null;
	                    }
	                }
	            }
	
	            if (currentProgressiveLayer) {
	                progressiveLayerCount++;
	                currentProgressiveLayer.__nextIdxNotProg = i;
	            }
	
	            // 层中的元素数量有发生变化
	            this.eachBuildinLayer(function (layer, z) {
	                if (elCountsLastFrame[z] !== layer.elCount) {
	                    layer.__dirty = true;
	                }
	            });
	
	            progressiveLayers.length = Math.min(progressiveLayerCount, MAX_PROGRESSIVE_LAYER_NUMBER);
	            util.each(progressiveLayers, function (layer, idx) {
	                if (progressiveElCountsLastFrame[idx] !== layer.elCount) {
	                    el.__dirty = true;
	                }
	                if (layer.__dirty) {
	                    layer.__progress = 0;
	                }
	            });
	        },
	
	        /**
	         * 清除hover层外所有内容
	         */
	        clear: function () {
	            this.eachBuildinLayer(this._clearLayer);
	            return this;
	        },
	
	        _clearLayer: function (layer) {
	            layer.clear();
	        },
	
	        /**
	         * 修改指定zlevel的绘制参数
	         *
	         * @param {string} zlevel
	         * @param {Object} config 配置对象
	         * @param {string} [config.clearColor=0] 每次清空画布的颜色
	         * @param {string} [config.motionBlur=false] 是否开启动态模糊
	         * @param {number} [config.lastFrameAlpha=0.7]
	         *                 在开启动态模糊的时候使用，与上一帧混合的alpha值，值越大尾迹越明显
	         */
	        configLayer: function (zlevel, config) {
	            if (config) {
	                var layerConfig = this._layerConfig;
	                if (!layerConfig[zlevel]) {
	                    layerConfig[zlevel] = config;
	                }
	                else {
	                    util.merge(layerConfig[zlevel], config, true);
	                }
	
	                var layer = this._layers[zlevel];
	
	                if (layer) {
	                    util.merge(layer, layerConfig[zlevel], true);
	                }
	            }
	        },
	
	        /**
	         * 删除指定层
	         * @param {number} zlevel 层所在的zlevel
	         */
	        delLayer: function (zlevel) {
	            var layers = this._layers;
	            var zlevelList = this._zlevelList;
	            var layer = layers[zlevel];
	            if (!layer) {
	                return;
	            }
	            layer.dom.parentNode.removeChild(layer.dom);
	            delete layers[zlevel];
	
	            zlevelList.splice(util.indexOf(zlevelList, zlevel), 1);
	        },
	
	        /**
	         * 区域大小变化后重绘
	         */
	        resize: function (width, height) {
	            var domRoot = this._domRoot;
	            // FIXME Why ?
	            domRoot.style.display = 'none';
	
	            width = width || this._getWidth();
	            height = height || this._getHeight();
	
	            domRoot.style.display = '';
	
	            // 优化没有实际改变的resize
	            if (this._width != width || height != this._height) {
	                domRoot.style.width = width + 'px';
	                domRoot.style.height = height + 'px';
	
	                for (var id in this._layers) {
	                    this._layers[id].resize(width, height);
	                }
	
	                this.refresh(true);
	            }
	
	            this._width = width;
	            this._height = height;
	
	            return this;
	        },
	
	        /**
	         * 清除单独的一个层
	         * @param {number} zlevel
	         */
	        clearLayer: function (zlevel) {
	            var layer = this._layers[zlevel];
	            if (layer) {
	                layer.clear();
	            }
	        },
	
	        /**
	         * 释放
	         */
	        dispose: function () {
	            this.root.innerHTML = '';
	
	            this.root =
	            this.storage =
	
	            this._domRoot =
	            this._layers = null;
	        },
	
	        /**
	         * Get canvas which has all thing rendered
	         * @param {Object} opts
	         * @param {string} [opts.backgroundColor]
	         */
	        getRenderedCanvas: function (opts) {
	            opts = opts || {};
	            if (this._singleCanvas) {
	                return this._layers[0].dom;
	            }
	
	            var imageLayer = new Layer('image', this, opts.pixelRatio || this.dpr);
	            imageLayer.initContext();
	
	            imageLayer.clearColor = opts.backgroundColor;
	            imageLayer.clear();
	
	            var displayList = this.storage.getDisplayList(true);
	
	            var scope = {};
	            for (var i = 0; i < displayList.length; i++) {
	                var el = displayList[i];
	                this._doPaintEl(el, imageLayer, true, scope);
	            }
	
	            return imageLayer.dom;
	        },
	        /**
	         * 获取绘图区域宽度
	         */
	        getWidth: function () {
	            return this._width;
	        },
	
	        /**
	         * 获取绘图区域高度
	         */
	        getHeight: function () {
	            return this._height;
	        },
	
	        _getWidth: function () {
	            var root = this.root;
	            var stl = document.defaultView.getComputedStyle(root);
	
	            // FIXME Better way to get the width and height when element has not been append to the document
	            return ((root.clientWidth || parseInt10(stl.width) || parseInt10(root.style.width))
	                    - (parseInt10(stl.paddingLeft) || 0)
	                    - (parseInt10(stl.paddingRight) || 0)) | 0;
	        },
	
	        _getHeight: function () {
	            var root = this.root;
	            var stl = document.defaultView.getComputedStyle(root);
	
	            return ((root.clientHeight || parseInt10(stl.height) || parseInt10(root.style.height))
	                    - (parseInt10(stl.paddingTop) || 0)
	                    - (parseInt10(stl.paddingBottom) || 0)) | 0;
	        },
	
	        _pathToImage: function (id, path, width, height, dpr) {
	            var canvas = document.createElement('canvas');
	            var ctx = canvas.getContext('2d');
	
	            canvas.width = width * dpr;
	            canvas.height = height * dpr;
	
	            ctx.clearRect(0, 0, width * dpr, height * dpr);
	
	            var pathTransform = {
	                position: path.position,
	                rotation: path.rotation,
	                scale: path.scale
	            };
	            path.position = [0, 0, 0];
	            path.rotation = 0;
	            path.scale = [1, 1];
	            if (path) {
	                path.brush(ctx);
	            }
	
	            var ImageShape = __webpack_require__(40);
	            var imgShape = new ImageShape({
	                id: id,
	                style: {
	                    x: 0,
	                    y: 0,
	                    image: canvas
	                }
	            });
	
	            if (pathTransform.position != null) {
	                imgShape.position = path.position = pathTransform.position;
	            }
	
	            if (pathTransform.rotation != null) {
	                imgShape.rotation = path.rotation = pathTransform.rotation;
	            }
	
	            if (pathTransform.scale != null) {
	                imgShape.scale = path.scale = pathTransform.scale;
	            }
	
	            return imgShape;
	        },
	
	        _createPathToImage: function () {
	            var me = this;
	
	            return function (id, e, width, height) {
	                return me._pathToImage(
	                    id, e, width, height, me.dpr
	                );
	            };
	        }
	    };
	
	    module.exports = Painter;
	


/***/ },
/* 71 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @module zrender/Layer
	 * @author pissang(https://www.github.com/pissang)
	 */
	
	
	    var util = __webpack_require__(4);
	    var config = __webpack_require__(21);
	    var Style = __webpack_require__(8);
	    var Pattern = __webpack_require__(35);
	
	    function returnFalse() {
	        return false;
	    }
	
	    /**
	     * 创建dom
	     *
	     * @inner
	     * @param {string} id dom id 待用
	     * @param {string} type dom type，such as canvas, div etc.
	     * @param {Painter} painter painter instance
	     * @param {number} number
	     */
	    function createDom(id, type, painter, dpr) {
	        var newDom = document.createElement(type);
	        var width = painter.getWidth();
	        var height = painter.getHeight();
	
	        var newDomStyle = newDom.style;
	        // 没append呢，请原谅我这样写，清晰~
	        newDomStyle.position = 'absolute';
	        newDomStyle.left = 0;
	        newDomStyle.top = 0;
	        newDomStyle.width = width + 'px';
	        newDomStyle.height = height + 'px';
	        newDom.width = width * dpr;
	        newDom.height = height * dpr;
	
	        // id不作为索引用，避免可能造成的重名，定义为私有属性
	        newDom.setAttribute('data-zr-dom-id', id);
	        return newDom;
	    }
	
	    /**
	     * @alias module:zrender/Layer
	     * @constructor
	     * @extends module:zrender/mixin/Transformable
	     * @param {string} id
	     * @param {module:zrender/Painter} painter
	     * @param {number} [dpr]
	     */
	    var Layer = function(id, painter, dpr) {
	        var dom;
	        dpr = dpr || config.devicePixelRatio;
	        if (typeof id === 'string') {
	            dom = createDom(id, 'canvas', painter, dpr);
	        }
	        // Not using isDom because in node it will return false
	        else if (util.isObject(id)) {
	            dom = id;
	            id = dom.id;
	        }
	        this.id = id;
	        this.dom = dom;
	
	        var domStyle = dom.style;
	        if (domStyle) { // Not in node
	            dom.onselectstart = returnFalse; // 避免页面选中的尴尬
	            domStyle['-webkit-user-select'] = 'none';
	            domStyle['user-select'] = 'none';
	            domStyle['-webkit-touch-callout'] = 'none';
	            domStyle['-webkit-tap-highlight-color'] = 'rgba(0,0,0,0)';
	        }
	
	        this.domBack = null;
	        this.ctxBack = null;
	
	        this.painter = painter;
	
	        this.config = null;
	
	        // Configs
	        /**
	         * 每次清空画布的颜色
	         * @type {string}
	         * @default 0
	         */
	        this.clearColor = 0;
	        /**
	         * 是否开启动态模糊
	         * @type {boolean}
	         * @default false
	         */
	        this.motionBlur = false;
	        /**
	         * 在开启动态模糊的时候使用，与上一帧混合的alpha值，值越大尾迹越明显
	         * @type {number}
	         * @default 0.7
	         */
	        this.lastFrameAlpha = 0.7;
	
	        /**
	         * Layer dpr
	         * @type {number}
	         */
	        this.dpr = dpr;
	    };
	
	    Layer.prototype = {
	
	        constructor: Layer,
	
	        elCount: 0,
	
	        __dirty: true,
	
	        initContext: function () {
	            this.ctx = this.dom.getContext('2d');
	
	            this.ctx.dpr = this.dpr;
	        },
	
	        createBackBuffer: function () {
	            var dpr = this.dpr;
	
	            this.domBack = createDom('back-' + this.id, 'canvas', this.painter, dpr);
	            this.ctxBack = this.domBack.getContext('2d');
	
	            if (dpr != 1) {
	                this.ctxBack.scale(dpr, dpr);
	            }
	        },
	
	        /**
	         * @param  {number} width
	         * @param  {number} height
	         */
	        resize: function (width, height) {
	            var dpr = this.dpr;
	
	            var dom = this.dom;
	            var domStyle = dom.style;
	            var domBack = this.domBack;
	
	            domStyle.width = width + 'px';
	            domStyle.height = height + 'px';
	
	            dom.width = width * dpr;
	            dom.height = height * dpr;
	
	            if (domBack) {
	                domBack.width = width * dpr;
	                domBack.height = height * dpr;
	
	                if (dpr != 1) {
	                    this.ctxBack.scale(dpr, dpr);
	                }
	            }
	        },
	
	        /**
	         * 清空该层画布
	         * @param {boolean} clearAll Clear all with out motion blur
	         */
	        clear: function (clearAll) {
	            var dom = this.dom;
	            var ctx = this.ctx;
	            var width = dom.width;
	            var height = dom.height;
	
	            var clearColor = this.clearColor;
	            var haveMotionBLur = this.motionBlur && !clearAll;
	            var lastFrameAlpha = this.lastFrameAlpha;
	
	            var dpr = this.dpr;
	
	            if (haveMotionBLur) {
	                if (!this.domBack) {
	                    this.createBackBuffer();
	                }
	
	                this.ctxBack.globalCompositeOperation = 'copy';
	                this.ctxBack.drawImage(
	                    dom, 0, 0,
	                    width / dpr,
	                    height / dpr
	                );
	            }
	
	            ctx.clearRect(0, 0, width, height);
	            if (clearColor) {
	                var clearColorGradientOrPattern;
	                // Gradient
	                if (clearColor.colorStops) {
	                    // Cache canvas gradient
	                    clearColorGradientOrPattern = clearColor.__canvasGradient || Style.getGradient(ctx, clearColor, {
	                        x: 0,
	                        y: 0,
	                        width: width,
	                        height: height
	                    });
	
	                    clearColor.__canvasGradient = clearColorGradientOrPattern;
	                }
	                // Pattern
	                else if (clearColor.image) {
	                    clearColorGradientOrPattern = Pattern.prototype.getCanvasPattern.call(clearColor, ctx);
	                }
	                ctx.save();
	                ctx.fillStyle = clearColorGradientOrPattern || clearColor;
	                ctx.fillRect(0, 0, width, height);
	                ctx.restore();
	            }
	
	            if (haveMotionBLur) {
	                var domBack = this.domBack;
	                ctx.save();
	                ctx.globalAlpha = lastFrameAlpha;
	                ctx.drawImage(domBack, 0, 0, width, height);
	                ctx.restore();
	            }
	        }
	    };
	
	    module.exports = Layer;


/***/ },
/* 72 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 */
	
	    var zrUtil = __webpack_require__(4);
	    var util = __webpack_require__(73);
	    var BPMNNode = __webpack_require__(75);
	    var BPMNModel = __webpack_require__(78);
	    var StartEventNode = __webpack_require__(80);
	    var EndEventNode = __webpack_require__(82);
	    var UserTaskNode = __webpack_require__(83);
	    var ManualTaskNode = __webpack_require__(85);
	    var ScriptTaskNode = __webpack_require__(86);
	    var MailTaskNode = __webpack_require__(87);
	    var CatchTimerEventNode = __webpack_require__(88);
	    var CatchSignalEventNode = __webpack_require__(89);
	    var ThrowSignalEventNode = __webpack_require__(90);
	    var InclusiveGatewayNode = __webpack_require__(91);
	    var ExclusiveGatewayNode = __webpack_require__(93);
	    var ParallelGatewayNode = __webpack_require__(94);
	    var SubPrcessNode = __webpack_require__(95);
	    var Bpmn = __webpack_require__(101);
	    /**
	     * 根据结点数组 导出JSON格式的数据
	     *
	     * @param {Array} nodes 结点数组
	     * @param {String} bpmnModel bpmn的model
	     * @param {Array} connectors 所有连线
	     * @return {JSON} JSON格式的数据
	     */
	    function toJson(bpmnModel, nodes, connectors) {
	        var jsonArr = [];
	        for(var i = 0; i < nodes.length;i++){
	            var node = nodes[i];
	            //去掉子流程里面的节点
	            if (node.parent && Bpmn.isSubProcess(node.parent)) {
	                continue;
	            }
	            if( node && node.toJSON) {
	                jsonArr.push(node.toJSON());
	            }
	        }
	        //增加线
	        for(var j = 0; j < connectors.length;j++){
	            var connector = connectors[j];
	            //去掉子流程里面的线段
	            if (connector.parent && Bpmn.isSubProcess(connector.parent)) {
	                continue;
	            }
	            if( connector && connector.toJSON) {
	                jsonArr.push(connector.toJSON());
	            }
	        }
	        bpmnModel.set("childShapes", jsonArr);
	
	
	        return bpmnModel.option;
	    }
	
	    /**
	     * 根据 JSON 生成节点
	     * @param  {[type]} fishTopoBpmn [description]
	     * @param  {[type]} json         [description]
	     * @return {[type]}              [description]
	     */
	    function fromJson(fishTopoBpmn, json) {
	        // 1.清空画布
	        fishTopoBpmn.clear(true);
	
	        // 2.先创建节点  遍历形状 获取模型
	        var bpmnModel = new BPMNModel(json);
	
	        fishTopoBpmn.model = bpmnModel;
	
	        var bpmnWidth = bpmnModel.get("properties.width");
	        var bpmnHeight = bpmnModel.get("properties.height");
	        if (bpmnWidth > 0 && bpmnHeight > 0) {
	            fishTopoBpmn.resize(bpmnWidth,bpmnHeight);
	        }
	
	        var childShapes = bpmnModel.get("childShapes");
	        var connectors = [];
	        for (var i = 0; i < childShapes.length; i++) {
	            var shape = childShapes[i];
	            var type = shape.stencil.type;
	
	
	            if (type === Bpmn.SEQUENCE_FLOW) {
	                connectors.push(shape);
	            } else {
	                var model = new BPMNModel(shape);
	                var createdNode = fishTopoBpmn.addNodeByModel(model,false,true);
	
	                 if (type === Bpmn.SUB_PROCESS) {
	                    var subNode = model.get("childShapes");
	                    for (var j = 0; j < subNode.length; j++) {
	
	                        var subModel = new BPMNModel(subNode[j]);
	                        if(Bpmn.isFlowModel(subModel)) {
	                            fishTopoBpmn.addConnectorByModel(subModel, createdNode);
	                        } else {
	                            var superUpperLeft = model.get("bounds.upperLeft");
	                            var subUpperLeft = subModel.get("bounds.upperLeft");
	                            subModel.set("bounds.upperLeft", { x: subUpperLeft.x + superUpperLeft.x, y: subUpperLeft.y + superUpperLeft.y });
	                            fishTopoBpmn.addNodeByModel(subModel,true,true);
	                        }
	
	                    }
	                 }
	            }
	        }
	
	        // 3. 再创建线
	        for(var k = 0, len = connectors.length; k < len; k++) {
	            var modelLine = new BPMNModel(connectors[k]); // shape
	            fishTopoBpmn.addConnectorByModel(modelLine);
	        }
	
	        // 4.创建事件插槽
	        for (var m = 0; m < childShapes.length; m++) {
	            if (childShapes[m].properties.slotEvent) {
	                for(var n = 0;n < childShapes[m].properties.slotEvent.length; n++){
	                    findNodeById(fishTopoBpmn,childShapes[m].resourceId).slotEvent.push(findNodeById(fishTopoBpmn,childShapes[m].properties.slotEvent[n]))
	                }
	            }
	
	        }
	
	    }
	
	    /**
	     * 根据id在fishTopoBpmn中查找
	     * @param  {[type]} fishTopoBpmn  [description]
	     * @param  {[type]} nodeId [description]
	     * @return {[type]}        [description]
	     */
	    function findNodeById(fishTopoBpmn, nodeId) {
	        var node;
	        for (var i = fishTopoBpmn.allNodes.length - 1; i >= 0; i--) {
	            if (fishTopoBpmn.allNodes[i].model.get("resourceId") == nodeId) {
	                node = fishTopoBpmn.allNodes[i];
	            }
	        }
	        return node;
	    }
	
	
	
	    function registerBPMNNode () {
	        BPMNNode.registerClass(StartEventNode, "StartNoneEvent");
	        BPMNNode.registerClass(EndEventNode, "EndNoneEvent");
	        BPMNNode.registerClass(UserTaskNode, "UserTask");
	        BPMNNode.registerClass(ManualTaskNode, "ManualTask");
	        BPMNNode.registerClass(ScriptTaskNode, "ScriptTask");
	        BPMNNode.registerClass(MailTaskNode, "MailTask");
	        BPMNNode.registerClass(CatchTimerEventNode, "CatchTimerEvent");
	        BPMNNode.registerClass(CatchSignalEventNode, "CatchSignalEvent");
	        BPMNNode.registerClass(ThrowSignalEventNode, "ThrowSignalEvent");
	        BPMNNode.registerClass(InclusiveGatewayNode, "InclusiveGateway");
	        BPMNNode.registerClass(ExclusiveGatewayNode, "ExclusiveGateway");
	        BPMNNode.registerClass(ParallelGatewayNode, "ParallelGateway");
	        BPMNNode.registerClass(SubPrcessNode, "SubProcess");
	    }
	
	
	    function isHover(node, x, y) {
	        var cx , cy;
	        if(node.parent){
	            if(node.parent.model.get("stencil.type") == "SubProcess"){
	                cx = x - node.parent.getRect().boundingRect.x;
	                cy = y - node.parent.getRect().boundingRect.y;
	                return node.rectContain(cx, cy)
	            }
	        }else{
	            return node.rectContain(x, y);
	        }
	
	     }
	
	    function findHover(list, x, y, excludes) {
	        for (var i = list.length - 1; i >= 0 ; i--) {
	            if (isExclude(excludes,list[i]) //list[i] !== exclude
	             // getDisplayList may include ignored item in VML mode
	             && !list[i].ignore
	             && isHover(list[i], x, y)) {
	                return list[i];
	            }
	        }
	    }
	
	
	    function isExclude(excludes, node) {
	        return zrUtil.indexOf(excludes,node) == -1;
	     }
	
	
	
	
	    var BpmnUtil = {
	        toJson: toJson,
	        fromJson: fromJson,
	        registerBPMNNode: registerBPMNNode,
	        findHover: findHover
	    };
	    module.exports = BpmnUtil;
	


/***/ },
/* 73 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * 工具方法类
	 * @author wang.xiaohu
	 */
	
	    var Point = __webpack_require__(59);
	    var Line = __webpack_require__(74);
	    var graphic = __webpack_require__(3);
	    var BoundingRect = __webpack_require__(24);
	    var zrUtil = __webpack_require__(4);
	    /**
	     * 构造类继承关系
	     *
	     * @param {Function} clazz 源类
	     * @param {Function} baseClazz 基类
	     */
	    function inherits(clazz, baseClazz) {
	        var clazzPrototype = clazz.prototype;
	
	        function F() {}
	        F.prototype = baseClazz.prototype;
	        clazz.prototype = new F();
	
	        for (var prop in clazzPrototype) {
	            clazz.prototype[prop] = clazzPrototype[prop];
	        }
	        clazz.prototype.constructor = clazz;
	        clazz.superClass = baseClazz;
	    }
	
	    function getUUID() {
	        var chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split(''),
	            uuid = new Array(36),
	            rnd = 0,
	            r;
	        for (var i = 0; i < 36; i++) {
	            if (i == 8 || i == 13 || i == 18 || i == 23) {
	                uuid[i] = '-';
	            } else if (i == 14) {
	                uuid[i] = '4';
	            } else {
	                if (rnd <= 0x02) rnd = 0x2000000 + (Math.random() * 0x1000000) | 0;
	                r = rnd & 0xf;
	                rnd = rnd >> 4;
	                uuid[i] = chars[(i == 19) ? (r & 0x3) | 0x8 : r];
	            }
	        }
	        return "sid-" + uuid.join('');
	    }
	
	
	    /**
	     * 计算两点之间的距离
	     *@param {Point} p1 - first {Point}
	     *@param {Point} p2 - second {Point}
	     *@return {Number} - the distance between those 2 points. It is always positive.
	     **/
	    function distance(p1, p2) {
	        return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
	    }
	
	    /**
	     * 返回一条折线 最长的两个点
	     * @param  {[type]} points [description]
	     * @return {[type]}        [description]
	     */
	    function getMaxLineLength(points) {
	        var m = distance(points[0], points[1]);
	        var result = [points[0], points[1]];
	        for (var i = 1; i < points.length - 1; i++) {
	
	            if (m < distance(points[i], points[i + 1])) {
	                m = distance(points[i], points[i + 1])
	                result = [points[i], points[i + 1]];
	            }
	        }
	
	        return result;
	    }
	
	    /**Returns the length of a Polyline that would be created with a set of points
	     *@param {Array} v - an {Array} of {Points}
	     *@return {Number} - a positive number equal with total length*/
	    function getPolylineLength(v) {
	        var l = 0;
	        for (var i = 0; i < v.length - 1; i++) {
	            l += distance(v[i], v[i + 1]);
	        }
	
	        return l;
	    }
	
	
	    /**Returns the max of a vector
	     *@param {Array} v - vector of {Number}s
	     *@return {Number} - the maximum number from the vector or NaN if vector is empty
	     **/
	    function max(v) {
	        if (v.lenght == 0) {
	            return NaN;
	        } else {
	            var m = v[0];
	            for (var i = 0; i < v.length; i++) {
	                if (m < v[i]) {
	                    m = v[i];
	                }
	            }
	
	            return m;
	        }
	    }
	
	
	    /**Returns the min of a vector
	     *@param {Array} v - vector of {Number}s
	     *@return {Number} - the minimum number from the vector or NaN if vector is empty
	     *@author alex@scriptoid.com
	     **/
	    function min(v) {
	        if (v.lenght == 0) {
	            return NaN;
	        } else {
	            var m = v[0];
	            for (var i = 0; i < v.length; i++) {
	                if (m > v[i]) {
	                    m = v[i];
	                }
	            }
	
	            return m;
	        }
	    }
	
	    /**
	     * 判断 点数组 是否正交直线路径
	     *Tests if a vector of points is an orthogonal path (moving in multiples of 90 degrees)
	     *@param {Array} v - an {Array} of {Point}s
	     *@return {Boolean} - true if path is valid, false otherwise
	     **/
	    function orthogonalPath(v) {
	        if (v.length <= 1) {
	            return true;
	        }
	
	        for (var i = 0; i < v.length - 1; i++) {
	            if (v[i].x != v[i + 1].x && v[i].y != v[i + 1].y) {
	                return false;
	            }
	        }
	
	        return true;
	    }
	
	
	    /**
	     *Test to see if 2 {Line}s intersects. They are considered finite segments
	     *and not the infinite lines from geometry
	     *@param {Line} l1 - fist line/segment
	     *@param {Line} l2 - last line/segment
	     *@return {Boolean} true - if the lines intersect or false if not
	     **/
	    function lineIntersectsLine(l1, l2) {
	        // check for two vertical lines
	        if (l1.startPoint.x == l1.endPoint.x && l2.startPoint.x == l2.endPoint.x) {
	            return l1.startPoint.x == l2.startPoint.x ? // if 'infinite 'lines do coincide,
	                // then check segment bounds for overlapping
	                l1.contains(l2.startPoint.x, l2.startPoint.y) ||
	                l1.contains(l2.endPoint.x, l2.endPoint.y) :
	                // lines are paralel
	                false;
	        }
	        // if one line is vertical, and another line is not vertical
	        else if (l1.startPoint.x == l1.endPoint.x || l2.startPoint.x == l2.endPoint.x) {
	            // let assume l2 is vertical, otherwise exchange them
	            if (l1.startPoint.x == l1.endPoint.x) {
	                var l = l1;
	                l1 = l2;
	                l2 = l;
	            }
	            // finding intersection of 'infinite' lines
	            // equation of the first line is y = ax + b, second: x = c
	            var a = (l1.endPoint.y - l1.startPoint.y) / (l1.endPoint.x - l1.startPoint.x);
	            var b = l1.startPoint.y - a * l1.startPoint.x;
	            var x0 = l2.startPoint.x;
	            var y0 = a * x0 + b;
	            return l1.contains(x0, y0) && l2.contains(x0, y0);
	        }
	
	        // check normal case - both lines are not vertical
	        else {
	            //line equation is : y = a*x + b, b = y - a * x
	            var a1 = (l1.endPoint.y - l1.startPoint.y) / (l1.endPoint.x - l1.startPoint.x);
	            var b1 = l1.startPoint.y - a1 * l1.startPoint.x;
	
	            var a2 = (l2.endPoint.y - l2.startPoint.y) / (l2.endPoint.x - l2.startPoint.x);
	            var b2 = l2.startPoint.y - a2 * l2.startPoint.x;
	
	            if (a1 == a2) { //paralel lines
	                return b1 == b2 ?
	                    // for coincide lines, check for segment bounds overlapping
	                    l1.contains(l2.startPoint.x, l2.startPoint.y) || l1.contains(l2.endPoint.x, l2.endPoint.y) :
	                    // not coincide paralel lines have no chance to intersect
	                    false;
	            } else { //usual case - non paralel, the 'infinite' lines intersects...we only need to know if inside the segment
	
	                /*
	                 * if one of the lines are vertical, then x0 is equal to their x,
	                 * otherwise:
	                 * y1 = a1 * x + b1
	                 * y2 = a2 * x + b2
	                 * => x0 = (b2 - b1) / (a1 - a2)
	                 * => y0 = a1 * x0 + b1
	                 **/
	                x0 = (b2 - b1) / (a1 - a2);
	                y0 = a1 * x0 + b1;
	                return l1.contains(x0, y0) && l2.contains(x0, y0);
	            }
	        }
	    }
	
	    /**
	     *
	     *Tests if a a polyline defined by a set of points intersects a rectangle
	     *@param {Array} points - and {Array} of {Point}s
	     *@param {Array} bounds - the bounds of the rectangle defined by (x1, y1, x2, y2)
	     *@param {Boolean} closedPolyline - incase polyline is closed figure then true, else false
	     *
	     *@return true - if line intersects the rectangle, false - if not
	     **/
	    function polylineIntersectsRectangle(points, bounds, closedPolyline) {
	
	
	        //get the 4 lines/segments represented by the bounds
	        var lines = [];
	        lines.push(new Line(new Point(bounds[0], bounds[1]), new Point(bounds[2], bounds[1])));
	        lines.push(new Line(new Point(bounds[2], bounds[1]), new Point(bounds[2], bounds[3])));
	        lines.push(new Line(new Point(bounds[2], bounds[3]), new Point(bounds[0], bounds[3])));
	        lines.push(new Line(new Point(bounds[0], bounds[3]), new Point(bounds[0], bounds[1])));
	
	        for (var k = 0; k < points.length - 1; k++) {
	            //create a line out of each 2 consecutive points
	            var tempLine = new Line(points[k], points[k + 1]);
	
	            //see if that line intersect any of the line on bounds border
	            for (var i = 0; i < lines.length; i++) {
	                if (lineIntersectsLine(tempLine, lines[i])) {
	                    return true;
	                }
	            }
	        }
	
	        //check the closed figure - that is last point connected to the first
	        if (closedPolyline) {
	            //create a line out of each 2 consecutive points
	            var tempLine1 = new Line(points[points.length - 1], points[0]);
	
	            //see if that line intersect any of the line on bounds border
	            for (var j = 0; j < lines.length; j++) {
	                if (lineIntersectsLine(tempLine1, lines[j])) {
	                    return true;
	                }
	            }
	        }
	
	        return false;
	    }
	
	    /**
	     * 计算路径的分数
	     * Score a ortogonal path made out of Points
	     *Iterates over a set of points (minimum 3)
	     *For each 3 points (i, i+1, i+2) :
	     *  - if the 3rd one is after the 2nd on the same line we add +1
	     *  - if the 3rd is up or down related to the 2nd we do not do anything +0
	     *  - if the 3rd goes back we imediatelly return -1
	     *@param {Array} v - an array of {Point}s
	     *@return {Number} - -1 if the path is wrong (goes back) or something >= 0 if is fine
	     *  The bigger the number the smooth the path is
	     **/
	    function scorePath(v) {
	        if (v.length <= 2) {
	            return -1;
	        }
	
	        var score = 0;
	        for (var i = 1; i < v.length - 1; i++) {
	            if (v[i - 1].x == v[i].x && v[i].x == v[i + 1].x) { //on the same vertical
	                if (signum(v[i + 1].y - v[i].y) == signum(v[i].y - v[i - 1].y)) { //same direction
	                    score++;
	                } else { //going back - no good
	                    return -1;
	                }
	            } else if (v[i - 1].y == v[i].y && v[i].y == v[i + 1].y) { //on the same horizontal
	                if (signum(v[i + 1].x - v[i].x) == signum(v[i].x - v[i - 1].x)) { //same direction
	                    score++;
	                } else { //going back - no good
	                    return -1;
	                }
	            } else { //not on same vertical nor horizontal
	                score--;
	            }
	        }
	
	        return score;
	    }
	
	    /**
	     * 返回数字符号（+ -)
	     * Returns the sign of a number
	     *@param {Number} x - the number
	     *@returns {Number}
	     *@see <a href="http://en.wikipedia.org/wiki/Sign_function">http://en.wikipedia.org/wiki/Sign_function</a>
	     **/
	    function signum(x) {
	        if (x > 0)
	            return 1;
	        else if (x < 0)
	            return -1;
	        else
	            return 0;
	    }
	
	    /**
	     * 判断 点数组 是不是有效路径（没有回路）
	     *Tests if a vector of points is a valid path (not going back)
	     *There are a few problems here. If you have p1, p2, p3 and p4 and p2 = p3 you need to ignore that
	     *@param {Array} v - an {Array} of {Point}s
	     *@return {Boolean} - true if path is valid, false otherwise
	     **/
	    function forwardPath(v) {
	        if (v.length <= 2) {
	            return true;
	        }
	
	        for (var i = 0; i < v.length - 2; i++) {
	            if (v[i].x == v[i + 1].x && v[i + 1].x == v[i + 2].x) { //on the same vertical
	                if (signum(v[i + 1].y - v[i].y) != 0) { //test only we have a progressing path
	                    if (signum(v[i + 1].y - v[i].y) == -1 * signum(v[i + 2].y - v[i + 1].y)) { //going back (ignore zero)
	                        return false;
	                    }
	                }
	            } else if (v[i].y == v[i + 1].y && v[i + 1].y == v[i + 2].y) { //on the same horizontal
	                if (signum(v[i + 1].x - v[i].x) != 0) { //test only we have a progressing path
	                    if (signum(v[i + 1].x - v[i].x) == -1 * signum(v[i + 2].x - v[i + 1].x)) { //going back (ignore zero)
	                        return false;
	                    }
	                }
	            }
	        }
	
	        return true;
	    }
	
	    /**
	     * 将[x:0,y:0]转化为[0, 0]  给zrender使用
	     * @param  {[type]} points [description]
	     * @param  {[type]} isRevert [description]
	     * @return {[type]}        [description]
	     */
	    function traslatePoints(points, isRevert) {
	        var newPoints = [];
	        if (isRevert) {
	            for (var i = 0; i < points.length; i++) {
	                var point = points[i];
	                newPoints.push(new Point(point[0], point[1]));
	            }
	            return newPoints;
	        } else {
	            for (var j = 0; j < points.length; j++) {
	                var point1 = points[j];
	                newPoints.push([point1.x, point1.y]);
	            }
	            return newPoints;
	        }
	
	
	    }
	
	    function rotationMatrix(angle) {
	        var mReturn = [
	            [Math.cos(angle), -Math.sin(angle), 0],
	            [Math.sin(angle), Math.cos(angle), 0],
	            [0, 0, 1]
	        ];
	        return mReturn;
	    }
	
	    function translationMatrix(dx, dy) {
	        return [
	            [1, 0, dx],
	            [0, 1, dy],
	            [0, 0, 1]
	        ];
	    }
	
	    function scaleMatrix(sx, sy) {
	        if (sy == null) {
	            sy = sx;
	        }
	        return [
	            [sx, 0, 0],
	            [0, sy, 0],
	            [0, 0, 1]
	        ];
	    }
	
	    /** It will return the end point of a line on a given angle (clockwise).
	     * @param {Point} startPoint - the start of the line
	     * @param {Number} length - the length of the line
	     * @param {Number} angle - the angle of the line in radians
	     * @return {Point} - the endPoint of the line
	     */
	    function getEndPoint(startPoint, length, angle) {
	        var endPoint = startPoint.clone();
	        endPoint.transform(translationMatrix(-startPoint.x, -startPoint.y));
	        endPoint.y -= length;
	        endPoint.transform(rotationMatrix(angle));
	        endPoint.transform(translationMatrix(startPoint.x, startPoint.y));
	        return endPoint;
	    }
	
	    /**
	     * 获取获取两个图形的外面四个连接点
	     * @param  {[type]} node [description]
	     * @return {[type]}      [description]
	     */
	    function getConnectorPoints(node) {
	        return {
	            left: new Point(node.x, node.y + node.height / 2), //矩形 左中的位置
	            top: new Point(node.x + node.width / 2, node.y), //矩形 上中的位置
	            right: new Point(node.x + node.width, node.y + node.height / 2), //矩形 右中的位置
	            bottom: new Point(node.x + node.width / 2, node.y + node.height), //矩形 下中的位置
	            center: new Point(node.x + node.width / 2, node.y + node.height / 2) //中间位置
	
	        };
	    }
	
	    /**
	     * 获取获取两个图形的外面四个连接点
	     * @param  {[type]} node [description]
	     * @return {[type]}      [description]
	     */
	    function getSoltPoints(node) {
	        return [
	            //top
	            [Math.round(node.getRect().width / 3 /10)*10, 0 ],
	            [Math.round(2*node.getRect().width / 3 /10)*10, 0 ],
	            //right
	            [node.getRect().width, Math.round(node.getRect().height / 3 /10)*10 ],
	            [node.getRect().width, Math.round(2*node.getRect().height / 3 /10)*10 ],
	            //bottom
	            [Math.round(node.getRect().width / 3 /10)*10, node.getRect().height ],
	            [Math.round(2*node.getRect().width / 3 /10)*10, node.getRect().height ],
	            //left
	            [0, Math.round(node.getRect().height / 3 /10)*10 ],
	            [0, Math.round(2*node.getRect().height / 3 /10)*10 ]
	
	        ]
	    }
	
	    /**
	     * 计算 p1 p2两点所连接的直线的角度
	     * @param  {[type]} p1 [description]
	     * @param  {[type]} p2 [description]
	     * @return {[type]}    [description]
	     */
	    function tangentRotation(p1, p2) {
	        return -Math.PI / 2 - Math.atan2(
	            p2.y - p1.y, p2.x - p1.x
	        );
	    }
	
	    /**
	     * 判断3点是否在一条直线上
	     * Tests if 3 points are coliniar with matrix determinants.
	     * If the determinat of matrix
	     * /         \
	     * | x1 y1 1 |
	     * | x2 y2 1 |
	     * | x3 y3 1 |
	     * \         /
	     * is zero it means that the points are colinear
	     *@param {Point} p1 - first point
	     *@param {Point} p2 - second point
	     *@param {Point} p3 - third point
	     * @param {Number} precission
	     *@return {Boolean} - true if coliniar and false if not
	     *@author Alex
	     *@see http://en.wikipedia.org/wiki/Determinant
	     *@see https://people.richland.edu/james/lecture/m116/matrices/applications.html
	     **/
	    function collinearity(p1, p2, p3, precission) {
	        var determinant = (p1.x * p2.y + p1.y * p3.x + p2.x * p3.y) - (p2.y * p3.x + p1.y * p2.x + p1.x * p3.y);
	
	        if (precission) {
	            return Math.abs(determinant) <= precission;
	        } else {
	            return determinant === 0;
	        }
	    }
	
	
	    /**
	     * 四舍五入 保存decimals的小数
	     **/
	    function enhancedRound(number, decimals) {
	        return Math.round(number * Math.pow(10, decimals)) / Math.pow(10, decimals);
	    }
	
	    /**
	     * 获取两点之间的长度
	     **/
	    function getLength(startPoint, endPoint) {
	        return Math.sqrt(Math.pow(startPoint.x - endPoint.x, 2) + Math.pow(startPoint.y - endPoint.y, 2));
	    }
	
	    /**
	     * 获取角度
	     * @param  {[type]} centerPoint  [description]
	     * @param  {[type]} outsidePoint [description]
	     * @param  {[type]} round        [description]
	     * @return {[type]}              [description]
	     */
	    function getAngle(centerPoint, outsidePoint, round) {
	        centerPoint.x = enhancedRound(centerPoint.x, 5);
	        centerPoint.y = enhancedRound(centerPoint.y, 5);
	        outsidePoint.x = enhancedRound(outsidePoint.x, 5);
	        outsidePoint.y = enhancedRound(outsidePoint.y, 5);
	        var angle = Math.atan((outsidePoint.x - centerPoint.x) / (outsidePoint.y - centerPoint.y));
	        angle = -angle;
	
	        //endAngle+=90;
	        if (outsidePoint.x >= centerPoint.x && outsidePoint.y >= centerPoint.y) {
	            angle += Math.PI;
	        } else if (outsidePoint.x <= centerPoint.x && outsidePoint.y >= centerPoint.y) {
	            angle += Math.PI;
	        } else if (outsidePoint.x <= centerPoint.x && outsidePoint.y <= centerPoint.y) {
	            angle += Math.PI * 2;
	        }
	        while (angle >= Math.PI * 2) {
	            angle -= Math.PI * 2;
	        }
	        if (isNaN(angle)) { //Nan
	            angle = 0; //we are at center point;
	        }
	        if (round) {
	            angle = Math.round(angle / round) * round
	        }
	        return angle;
	    }
	
	    function getRect(node) {
	        var boundingRect = node.getBoundingRect();
	        //创建最小包围盒虚线
	        var points = [];
	        points[0] = [-boundingRect.width / 2, -boundingRect.height / 2];
	        points[1] = [boundingRect.width / 2, -boundingRect.height / 2];
	        points[2] = [boundingRect.width / 2, boundingRect.height / 2];
	        points[3] = [-boundingRect.width / 2, boundingRect.height / 2];
	        points[4] = [-boundingRect.width / 2, -boundingRect.height / 2];
	
	        var boundRect, cx, cy;
	        if (node instanceof graphic.Circle) {
	            //注: 因事件为圆形  所以 x y 为圆心的位置  包围矩形要减去宽度一半
	            boundRect = new BoundingRect(Number(node.position[0]) - Number(boundingRect.width / 2),
	                Number(node.position[1]) - Number(boundingRect.height / 2),
	                Number(boundingRect.width), Number(boundingRect.height));
	            cx = Number(node.position[0]);
	            cy = Number(node.position[1]);
	        } else {
	            boundRect = new BoundingRect(Number(node.position[0]),
	                Number(node.position[1]),
	                Number(boundingRect.width), Number(boundingRect.height));
	            cx = Number(node.position[0]) + Number(boundingRect.width) / 2;
	            cy = Number(node.position[1]) + Number(boundingRect.height) / 2;
	        }
	        return {
	            x: Number(cx),
	            y: Number(cy),
	            width: Number(boundingRect.width),
	            height: Number(boundingRect.height),
	            points: points,
	            boundingRect: boundRect
	        };
	    }
	
	    var StackedMap = {
	        createNew: function() {
	            var stack = [];
	
	            return {
	                add: function(key, value) {
	                    var arrKey = this.get(key);
	                    arrKey.push(value)
	
	                },
	                get: function(key) {
	                    for (var i = 0; i < stack.length; i++) {
	                        if (key == stack[i].key) {
	                            return stack[i].value;
	                        }
	                    }
	                    //如果没有找到的话，则创建一个新的数组
	                    var value = [];
	                    stack.push({ key: key, value: value });
	                    return value;
	                },
	                keys: function() {
	                    var keys = [];
	                    for (var i = 0; i < stack.length; i++) {
	                        keys.push(stack[i].key);
	                    }
	                    return keys;
	                },
	                top: function() {
	                    return stack[stack.length - 1];
	                },
	                remove: function(key) {
	                    var idx = -1;
	                    for (var i = 0; i < stack.length; i++) {
	                        if (key == stack[i].key) {
	                            idx = i;
	                            break;
	                        }
	                    }
	                    return stack.splice(idx, 1)[0];
	                },
	                removeItem: function(key, item) {
	                    var arrKey = this.get(key);
	                    var index = zrUtil.indexOf(arrKey, item);
	                    arrKey.splice(index, 1);
	
	                },
	                removeTop: function() {
	                    return stack.splice(stack.length - 1, 1)[0];
	                },
	                length: function() {
	                    return stack.length;
	                },
	                clear: function() {
	                    stack.splice(0, stack.length);
	                }
	            };
	        }
	    };
	
	    function randomColor() {
	        var arrHex = ["0", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d"],
	            strHex = "#",
	            index;
	        for (var i = 0; i < 6; i++) {
	            index = Math.round(Math.random() * 15);
	            strHex += arrHex[index];
	        }
	        return strHex;
	    }
	
	    function isUndefined(obj) {
	        return obj === void 0;
	    }
	
	    function collinearReduction (v) {
	        var r = [];
	
	        if(v.length < 3){
	            return Point.cloneArray(v);
	        }
	
	        r.push( v[0].clone() );
	        for(var i=1; i < v.length-1; i++){
	            if( (v[i-1].x == v[i].x && v[i].x == v[i+1].x)  ||  (v[i-1].y == v[i].y && v[i].y == v[i+1].y) )
	            {
	                continue;
	            }
	            else{
	                r.push( v[i].clone() );
	            }
	        }
	        r.push( v[v.length-1].clone() );
	
	        return r;
	    }
	
	    // By default, Underscore uses ERB-style template delimiters, change the
	    // following template settings to use alternative delimiters.
	    var templateSettings = {
	        evaluate: /<%([\s\S]+?)%>/g,
	        interpolate: /<%=([\s\S]+?)%>/g,
	        escape: /<%-([\s\S]+?)%>/g
	    };
	
	    // When customizing `templateSettings`, if you don't want to define an
	    // interpolation, evaluation or escaping regex, we need one that is
	    // guaranteed not to match.
	    var noMatch = /(.)^/;
	
	    // Certain characters need to be escaped so that they can be put into a
	    // string literal.
	    var escapes = {
	        "'": "'",
	        '\\': '\\',
	        '\r': 'r',
	        '\n': 'n',
	        '\u2028': 'u2028',
	        '\u2029': 'u2029'
	    };
	
	    var escaper = /\\|'|\r|\n|\u2028|\u2029/g;
	
	    var escapeChar = function(match) {
	        return '\\' + escapes[match];
	    };
	
	    // JavaScript micro-templating, similar to John Resig's implementation.
	    // Underscore templating handles arbitrary delimiters, preserves whitespace,
	    // and correctly escapes quotes within interpolated code.
	    // NB: `oldSettings` only exists for backwards compatibility.
	    function template(text, settings, oldSettings) {
	        if (!settings && oldSettings) settings = oldSettings;
	        settings = settings || {};
	        settings = zrUtil.defaults(settings, templateSettings, true);
	
	        // Combine delimiters into one regular expression via alternation.
	        var matcher = RegExp([
	            (settings.escape || noMatch).source,
	            (settings.interpolate || noMatch).source,
	            (settings.evaluate || noMatch).source
	        ].join('|') + '|$', 'g');
	
	        // Compile the template source, escaping string literals appropriately.
	        var index = 0;
	        var source = "__p+='";
	        text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
	            source += text.slice(index, offset).replace(escaper, escapeChar);
	            index = offset + match.length;
	
	            if (escape) {
	                source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
	            } else if (interpolate) {
	                source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
	            } else if (evaluate) {
	                source += "';\n" + evaluate + "\n__p+='";
	            }
	
	            // Adobe VMs need the match returned to produce the correct offest.
	            return match;
	        });
	        source += "';\n";
	
	        // If a variable is not specified, place data values in local scope.
	        if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';
	
	        source = "var __t,__p='',__j=Array.prototype.join," +
	            "print=function(){__p+=__j.call(arguments,'');};\n" +
	            source + 'return __p;\n';
	
	        try {
	            var render = new Function(settings.variable || 'obj', source);
	        } catch (e) {
	            e.source = source;
	            throw e;
	        }
	
	        var template = function(data) {
	            return render.call(this, data);
	        };
	
	        // Provide the compiled source as a convenience for precompilation.
	        var argument = settings.variable || 'obj';
	        template.source = 'function(' + argument + '){\n' + source + '}';
	
	        return template;
	    }
	
	    function isEmpty(obj) {
	        if (obj == null) return true;
	        if (zrUtil.isArrayLike(obj) && (zrUtil.isArray(obj) || zrUtil.isString(obj))) return obj.length === 0;
	    }
	
	    module.exports = {
	        inherits: inherits,
	        getUUID: getUUID,
	        distance: distance,
	        getPolylineLength: getPolylineLength,
	        max: max,
	        min: min,
	        isEmpty: isEmpty,
	        orthogonalPath: orthogonalPath,
	        polylineIntersectsRectangle: polylineIntersectsRectangle,
	        scorePath: scorePath,
	        forwardPath: forwardPath,
	        traslatePoints: traslatePoints,
	        getEndPoint: getEndPoint,
	        getConnectorPoints: getConnectorPoints,
	        tangentRotation: tangentRotation,
	        collinearity: collinearity,
	        translationMatrix: translationMatrix,
	        scaleMatrix: scaleMatrix,
	        round: enhancedRound,
	        getLength: getLength,
	        getAngle: getAngle,
	        getRect: getRect,
	        StackedMap: StackedMap,
	        getMaxLineLength: getMaxLineLength,
	        randomColor: randomColor,
	        template: template,
	        isUndefined: isUndefined,
	        getSoltPoints:getSoltPoints,
	        collinearReduction: collinearReduction
	    };
	


/***/ },
/* 74 */
/***/ function(module, exports) {

	
	
	    /**
	      * Creates an instance of a Line. A Line is actually a segment and not a pure
	      * geometrical Line
	      *
	      * @constructor
	      * @this {Line}
	      * @param {Point} startPoint - starting point of the line
	      * @param {Point} endPoint - the ending point of the line
	      **/
	    function Line(startPoint, endPoint){
	        /**Starting {@link Point} of the line*/
	        this.startPoint = startPoint;
	
	        /**Ending {@link Point} of the line*/
	        this.endPoint = endPoint;
	
	        /**Serialization type*/
	        this.oType = 'Line'; //object type used for JSON deserialization
	    }
	
	    /**Creates a {Line} out of JSON parsed object
	     *@param {JSONObject} o - the JSON parsed object
	     *@return {Line} a newly constructed Line
	     **/
	    Line.load = function(o){
	        var newLine = new Line(
	            Point.load(o.startPoint),
	            Point.load(o.endPoint)
	        );
	
	        return newLine;
	    };
	
	    Line.prototype = {
	        contructor: Line,
	
	
	
	        clone:function(){
	            var ret = new Line(this.startPoint.clone(), this.endPoint.clone());
	            return ret;
	        },
	
	        equals:function(anotherLine){
	            if(!anotherLine instanceof Line){
	                return false;
	            }
	            return this.startPoint.equals(anotherLine.startPoint)
	            && this.endPoint.equals(anotherLine.endPoint)
	        },
	
	        /** Tests to see if a point belongs to this line (not as infinite line but more like a segment)
	         * Algorithm: Compute line's equation and see if (x, y) verifies it.
	         * @param {Number} x - the X coordinates
	         * @param {Number} y - the Y coordinates
	         **/
	        contains: function(x, y){
	            // if the point is inside rectangle bounds of the segment
	            if (Math.min(this.startPoint.x, this.endPoint.x) <= x
	                && x <= Math.max(this.startPoint.x, this.endPoint.x)
	                && Math.min(this.startPoint.y, this.endPoint.y) <= y
	                && y <= Math.max(this.startPoint.y, this.endPoint.y)) {
	
	                // check for vertical line
	                if (this.startPoint.x == this.endPoint.x) {
	                    return x == this.startPoint.x;
	                } else { // usual (not vertical) line can be represented as y = a * x + b
	                    var a = (this.endPoint.y - this.startPoint.y) / (this.endPoint.x - this.startPoint.x);
	                    var b = this.startPoint.y - a * this.startPoint.x;
	                    return y == a * x + b;
	                }
	            } else {
	                return false;
	            }
	        },
	
	        /*
	         *See if we are near a {Line} by a certain radius (also includes the extremities into computation)
	         *@param {Number} x - the x coordinates
	         *@param {Number} y - the y coordinates
	         *@param {Number} radius - the radius to search for
	         *@see http://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line
	         *@see "Mathematics for Computer Graphics, 2nd Ed., by John Vice, page 227"
	         **/
	        near:function(x,y,radius){
	
	            if(this.endPoint.x === this.startPoint.x){ //Vertical line, so the vicinity area is a rectangle
	                return ( (this.startPoint.y-radius<=y && this.endPoint.y+radius>=y)
	                        || (this.endPoint.y-radius<=y && this.startPoint.y+radius>=y))
	                && x > this.startPoint.x - radius && x < this.startPoint.x + radius ;
	            }
	
	            if(this.startPoint.y === this.endPoint.y){ //Horizontal line, so the vicinity area is a rectangle
	                return ( (this.startPoint.x - radius<=x && this.endPoint.x+radius>=x)
	                        || (this.endPoint.x-radius<=x && this.startPoint.x+radius>=x))
	                        && y>this.startPoint.y-radius && y<this.startPoint.y+radius ;
	            }
	
	
	            var startX = Math.min(this.endPoint.x,this.startPoint.x);
	            var startY = Math.min(this.endPoint.y,this.startPoint.y);
	            var endX = Math.max(this.endPoint.x,this.startPoint.x);
	            var endY = Math.max(this.endPoint.y,this.startPoint.y);
	
	            /*We will compute the distance from point to the line
	             * by using the algorithm from
	             * http://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line
	             * */
	
	            //First we need to find a,b,c of the line equation ax + by + c = 0
	            var a = this.endPoint.y - this.startPoint.y;
	            var b = this.startPoint.x - this.endPoint.x;
	            var c = -(this.startPoint.x * this.endPoint.y - this.endPoint.x * this.startPoint.y);
	
	            //Secondly we get the distance "Mathematics for Computer Graphics, 2nd Ed., by John Vice, page 227"
	            var d = Math.abs( (a*x + b*y + c) / Math.sqrt(Math.pow(a,2) + Math.pow(b,2)) );
	
	            //Thirdly we get coordinates of closest line's point to target point
	            //http://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line#Cartesian_coordinates
	            var closestX = (b * (b*x - a*y) - a*c) / ( Math.pow(a,2) + Math.pow(b,2) );
	            var closestY = (a * (-b*x + a*y) - b*c) / ( Math.pow(a,2) + Math.pow(b,2) );
	
	            var r = ( d <= radius && endX>=closestX && closestX>=startX && endY>=closestY && closestY>=startY ) //the projection of the point falls INSIDE of the segment
	                || this.startPoint.near(x,y,radius) || this.endPoint.near(x,y,radius); //the projection of the point falls OUTSIDE of the segment
	
	            return  r;
	
	        },
	
	        /**we need to create a new array each time, or we will affect the actual shape*/
	        getPoints:function(){
	            var points = [];
	            points.push(this.startPoint);
	            points.push(this.endPoint);
	            return points;
	        },
	
	        /**Return the {Point} corresponding the t certain t value
	         * @param {Number} t the value of parameter t, where t in [0,1], t is like a percent*/
	        getPoint: function(t){
	            var Xp = t * (this.endPoint.x - this.startPoint.x) + this.startPoint.x;
	            var Yp = t * (this.endPoint.y - this.startPoint.y) + this.startPoint.y;
	
	            return new Point(Xp, Yp);
	        },
	
	        // /**
	        //  * Returns the middle of the line
	        //  * @return {Point} the middle point
	        //  * */
	        // getMiddle : function(){
	        //     return Util.getMiddle(this.startPoint, this.endPoint);
	        // },
	
	
	        // getLength : function(){
	        //     return Util.getLength(this.startPoint, this.endPoint);
	        // },
	
	        // /**
	        //  *Get bounds for this line
	        //  *@author Alex Gheorghiu <alex@scriptoid.com>
	        //  **/
	        // getBounds:function(){
	        //     return Util.getBounds(this.getPoints());
	        // },
	
	        /**String representation*/
	        toString:function(){
	            return 'line(' + this.startPoint + ',' + this.endPoint + ')';
	        }
	    };
	    module.exports = Line;
	


/***/ },
/* 75 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * BPMN节点类  所有的BPMN形状都继承与它，用户自定义节点可以继承它并注册即可使用
	 * @class fish.topo.FishTopoBpmn.BPMNNode
	 */
	
	
		var Node = __webpack_require__(76);
		var zrUtil = __webpack_require__(4);
		var graphic = __webpack_require__(3);
		var clazzUtil = __webpack_require__(77);
		//创建Node类 所有形状都继承Node
		function BPMNNode(model, api) {
			Node.call(this);
			this.model = model;
			this.options =
			{
				outline: {
					enable: true, // 是否有外框
					radius: true, // 是否圆角
					initVisible: false
				},
				text: {
					color: '#000000', // 文本颜色
					lineHeight: 24 // 文本行高
				}
			};
			this.bpmnInfo = {type: -1, name:"BPMNDiagram", displayName:"Task" };    //节点信息
			var resourceId = model.get("resourceId");
			if(resourceId && resourceId != "") {
				this.resourceId = resourceId;
			}
	
	        //判断是否有operationNode
	        var prop = model.get("properties");
	        if (prop.operationIcons) {
	            this.operationIcons = prop.operationIcons;
	        }
			this.initEvent(api);
		}
	
	    BPMNNode.prototype.initEvent = function(api) {
	        var that = this;
	        var MOUSE_EVENT_NAMES = ['dblclick', 'click'];//'click', 'dblclick', 'mouseover', 'mouseout'
	
	
	        zrUtil.each(MOUSE_EVENT_NAMES, function (eveName) {
	            that.on(eveName, function (e) {
		            var params = {};
		            params.event = e;
		            params.type = eveName;
		            params.target = that;
		            api.trigger(eveName, params);
	            }, this);
	        });
	    };
	
	    /**
	     * 获取当前节点的包围和 相关参数
	     * @returns {{x:Number, y:Number, width:Number, height:Number, points:Array, boundingRect:Object}}
	     * @returns {Number} return.x 当前节点的中心点x值
	     * @returns {Number} return.y 当前节点的中心点y值
	     * @returns {Number} return.width 当前节点的宽度
	     * @returns {Number} return.height 当前节点的高度
	     * @returns {Array} return.points 当前节点的包围和 [左上角坐标，右上角坐标，右下角坐标，右下角坐标] 用于节点选中时包围虚线框
	     * @returns {Object} return.boundingRect 当前节点的包围矩形
	     */
	    BPMNNode.prototype.getRect = function() {
	    };
	
	    /**
	     * 返回当前节点的包围矩形
	     * @return {Object} 当前节点的包围矩形  一般不包括下面的文字
	     */
	    BPMNNode.prototype.getBoundingRect = function() {
	    };
	
	    /**
	     * 设置图元的位置
	     * @param {Number} x x坐标
	     * @param {Number} y y坐标
	     */
	    BPMNNode.prototype.setPosition  = function(x, y) {
	    };
	
	    /**
	     * @private
	     * 查看当前节点是否 包括x ,y 坐标
	     * @param  {number} x x坐标
	     * @param  {number} y y坐标
	     * @return {Boolean}   是否在范围内
	     */
	    BPMNNode.prototype.rectContain = function(x, y) {
	    	var rect = this.getRect();
	        return rect.boundingRect.contain(x,y);
	    };
	
	    /**
	     * 返回json对象
	     * @return {String} json对象
	     */
		BPMNNode.prototype.toJSON = function() {
			this.model.set("resourceId", this.resourceId);
			this.model.set("properties.type", this.bpmnInfo.type);
			this.model.set("stencil.type", this.bpmnInfo.name);  //stencil.id
	
	        if (this.slotEvent && this.slotEvent.length > 0) {
	            var arrSlotEvent = [];
	            for (var i = this.slotEvent.length - 1; i >= 0; i--) {
	                arrSlotEvent.push(this.slotEvent[i].resourceId)
	            }
	            this.model.set("properties.slotEvent", arrSlotEvent);
	        }
	        this.model.set("properties.type", this.bpmnInfo.type);
	
	        var rect = this.getRect().boundingRect;
	        this.model.set("bounds.upperLeft.x", rect.x);
	        this.model.set("bounds.upperLeft.y", rect.y);
	        this.model.set("bounds.lowerRight.x", rect.x + rect.width);
	        this.model.set("bounds.lowerRight.y", rect.y + rect.height);
			return this.model.option;
		};
	
		/**
	     * @private
	     * 根据属性设置模型数据
	     * @param {Object} option 模型数据
	     */
	    BPMNNode.prototype.setModel = function(option) {
	        var that = this;
	        var originText = this.model.get("properties.name");
	        this.model.mergeOption(option);
	        if(originText != option.properties.name) {
	            var title = this.childOfName("Title");
	            var nameByteLength = option.properties.name.length;
	            var showName;
	            if(nameByteLength > 64){
	                showName = option.properties.name.substr(0,64)+'..';
	                if(this.alarm){
	                    this.alarm.isShow = true;
	                }
	            }else{
	                showName = option.properties.name;
	                if(this.alarm){
	                    this.alarm.isShow = false;
	                }
	
	            }
	            title.attr("style",{text:showName});
	            that.refreshText(that);
	            var name = option.properties.name;
	            var text = this.alarm.childOfName("Text");
	            text.attr("style",{text:name});
	            var groupWidth = text.getBoundingRect().width+4;
	            var groupHeight = text.getBoundingRect().height+8;
	            var points = [
	                [0,0],
	                [groupWidth,0],
	                [groupWidth,groupHeight],
	                [groupWidth-3,groupHeight],
	                [groupWidth-6,groupHeight+3],
	                [groupWidth-9,groupHeight],
	                [0,groupHeight],
	                [0,0]
	            ];
	            var Polyline = this.alarm.childOfName("Polyline");
	            Polyline.attr("shape",{points:points});
	            var groupPosition = [this.position[0]+this.getBoundingRect().width-(this.alarm.getBoundingRect().width-6),this.position[1]-this.alarm.getBoundingRect().height-3];
	            this.alarm.attr("position",groupPosition);
	        }
	    };
	
	
		zrUtil.inherits(BPMNNode,Node);
	
	    /**
	     * 注册BPMN节点的类，只有注册过后，才能在BPMN编辑器中添加
	     * @method registerClass
	     * @param {Object} Clazz 继承了BPMNNode的实现类
	     * @param {String} componentType 注册类的名称
	     *
	     * **使用范例**：
	     *
	     *     @example
	     *     BPMNNode.registerClass(CustomNode, "CustomNode");
	     */
		clazzUtil.enableClassManagement(BPMNNode, {
	        registerWhenExtend: true
	    });
		module.exports = BPMNNode;
	
	
	


/***/ },
/* 76 */
/***/ function(module, exports, __webpack_require__) {

	
	    var graphic = __webpack_require__(3);
	    var util = __webpack_require__(73)
	    //创建Node类 所有形状都继承Node  包括fromJSON toJSON
	    function Node() {
	        this.resourceId = util.getUUID(); // 生成节点ID
	        graphic.Group.call(this);
	    }
	
	    /**
	     * 由父类实现
	     * @return {[type]} [description]
	     */
	    Node.prototype.render = function() {};
	
	    /**
	     * 由父类实现
	     * @param  {[type]} json [description]
	     * @return {[type]}      [description]
	     */
	    Node.prototype.getRect = function(json) {};
	
	    /**
	     * drawText
	     * @description 画一个文本
	     * @param {string} name
	     * @param {string} color
	     */
	    Node.prototype.drawText = function(name,color) {
	        var textName = this.bpmnInfo.name;
	        if(name != null){
	            textName = name;
	        }
	        var text = new graphic.Text({
	            style: {
	                text: textName,
	                color: color ? color : this.options.text.color,
	                textFont: '12px Microsoft YaHei'
	            },
	            zlevel: 20
	        });
	        //文字绘制的位置  
	        //x = 中心点.x - 起始位置.x - 文字宽度的一半
	        var x = this.getRect().x - this.position[0] - text.getBoundingRect().width / 2;
	        //y = 中心点.y - 起始位置.y + 节点高度的一半 + 偏移值（6）
	        var y = this.getRect().y - this.position[1] + this.getBoundingRect().height / 2 + text.getBoundingRect().height + 6;
	        text.attr("style", { x: x, y: y });
	        return {
	            text: text,
	            rect: text.getBoundingRect()
	        };
	    };
	    /**
	     * refreshText
	     * @description 刷新文本
	     */
	    Node.prototype.refreshText = function() {
	        var text = this.childOfName("Title");
	        var x = this.getRect().x - this.position[0] - text.getBoundingRect().width / 2;
	        var y = this.getRect().y - this.position[1] + this.getBoundingRect().height / 2 + text.getBoundingRect().height + 6;
	        text.attr("style", { x: x, y: y });
	    };
	    /**
	     * 由父类实现
	     * @return {[type]} [description]
	     */
	    Node.prototype.toJSON = function() {};
	
	    graphic.Util.inherits(Node, graphic.Group);
	    module.exports = Node;
	


/***/ },
/* 77 */
/***/ function(module, exports, __webpack_require__) {

	
	
	    var zrUtil = __webpack_require__(4);
	
	    var clazz = {};
	
	    var TYPE_DELIMITER = '.';
	    var IS_CONTAINER = '___FT__COMPONENT__CONTAINER___';
	    /**
	     * @public
	     */
	    var parseClassType = clazz.parseClassType = function (componentType) {
	        var ret = {main: '', sub: ''};
	        if (componentType) {
	            componentType = componentType.split(TYPE_DELIMITER);
	            ret.main = componentType[0] || '';
	            ret.sub = componentType[1] || '';
	        }
	        return ret;
	    };
	    /**
	     * @public  相比 直接用zrUtil.inherits 好处是  可以直接调用父类的构造函数
	     */
	    clazz.enableClassExtend = function (RootClass, preConstruct) {
	        RootClass.extend = function (proto) {
	            var ExtendedClass = function () {
	                preConstruct && preConstruct.apply(this, arguments);
	                RootClass.apply(this, arguments);
	            };
	
	            zrUtil.extend(ExtendedClass.prototype, proto);
	
	            ExtendedClass.extend = this.extend;
	            ExtendedClass.superCall = superCall;
	            ExtendedClass.superApply = superApply;
	            zrUtil.inherits(ExtendedClass, this);
	            ExtendedClass.superClass = this;
	
	            return ExtendedClass;
	        };
	    };
	
	    // superCall should have class info, which can not be fetch from 'this'.
	    // Consider this case:
	    // class A has method f,
	    // class B inherits class A, overrides method f, f call superApply('f'),
	    // class C inherits class B, do not overrides method f,
	    // then when method of class C is called, dead loop occured.
	    function superCall(context, methodName) {
	        var args = zrUtil.slice(arguments, 2);
	        return this.superClass.prototype[methodName].apply(context, args);
	    }
	
	    function superApply(context, methodName, args) {
	        return this.superClass.prototype[methodName].apply(context, args);
	    }
	
	    /**
	     * @param {Object} entity
	     * @param {Object} options
	     * @param {boolean} [options.registerWhenExtend]
	     * @public
	     */
	    clazz.enableClassManagement = function (entity, options) {
	        options = options || {};
	
	        /**
	         * Component model classes
	         * key: componentType,
	         * value:
	         *     componentClass, when componentType is 'xxx'
	         *     or Object.<subKey, componentClass>, when componentType is 'xxx.yy'
	         * @type {Object}
	         */
	        var storage = {};
	
	        entity.registerClass = function (Clazz, componentType) {
	            if (componentType) {
	                componentType = parseClassType(componentType);
	
	                if (!componentType.sub) {
	                    if (storage[componentType.main]) {
	                        //已经注册过了，直接返回
	                        return;
	                    }
	                    storage[componentType.main] = Clazz;
	                }
	                else if (componentType.sub !== IS_CONTAINER) {
	                    var container = makeContainer(componentType);
	                    container[componentType.sub] = Clazz;
	                }
	            }
	            return Clazz;
	        };
	
	        entity.getClass = function (componentTypeMain, subType, throwWhenNotFound) {
	            var Clazz = storage[componentTypeMain];
	
	            if (Clazz && Clazz[IS_CONTAINER]) {
	                Clazz = subType ? Clazz[subType] : null;
	            }
	
	            if (throwWhenNotFound && !Clazz) {
	                throw new Error(
	                    'Component ' + componentTypeMain + '.' + (subType || '') + ' not exists. Load it first.'
	                );
	            }
	
	            return Clazz;
	        };
	
	        entity.getClassesByMainType = function (componentType) {
	            componentType = parseClassType(componentType);
	
	            var result = [];
	            var obj = storage[componentType.main];
	
	            if (obj && obj[IS_CONTAINER]) {
	                zrUtil.each(obj, function (o, type) {
	                    type !== IS_CONTAINER && result.push(o);
	                });
	            }
	            else {
	                result.push(obj);
	            }
	
	            return result;
	        };
	
	        entity.hasClass = function (componentType) {
	            // Just consider componentType.main.
	            componentType = parseClassType(componentType);
	            return !!storage[componentType.main];
	        };
	
	        /**
	         * @return {Array.<string>} Like ['aa', 'bb'], but can not be ['aa.xx']
	         */
	        entity.getAllClassMainTypes = function () {
	            var types = [];
	            zrUtil.each(storage, function (obj, type) {
	                types.push(type);
	            });
	            return types;
	        };
	
	        /**
	         * If a main type is container and has sub types
	         * @param  {string}  componentType
	         * @return {boolean}
	         */
	        entity.hasSubTypes = function (componentType) {
	            componentType = parseClassType(componentType);
	            var obj = storage[componentType.main];
	            return obj && obj[IS_CONTAINER];
	        };
	
	        entity.parseClassType = parseClassType;
	
	        function makeContainer(componentType) {
	            var container = storage[componentType.main];
	            if (!container || !container[IS_CONTAINER]) {
	                container = storage[componentType.main] = {};
	                container[IS_CONTAINER] = true;
	            }
	            return container;
	        }
	
	        if (options.registerWhenExtend) {
	            var originalExtend = entity.extend;
	            if (originalExtend) {
	                entity.extend = function (proto) {
	                    var ExtendedClass = originalExtend.call(this, proto);
	                    return entity.registerClass(ExtendedClass, proto.type);
	                };
	            }
	        }
	
	        return entity;
	    };
	
	    module.exports = clazz;
	


/***/ },
/* 78 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * BPMN model
	 *
	 */
	
	
	    var Model = __webpack_require__(79);
	    var BPMNModel = Model.extend({
	
	        type: 'BPMN',
	        /**
	         * @type {Object}
	         * @protected
	         */
	        defaultOption: {
	            resourceId: "",  //资源ID
	
	            properties: {
	                type: -1,  //类型
	                name: null, //名称
	                notes: "",  //备注
	                //no: ""
	                extProperties: {}  //扩展属性
	            },
	
	            stencil: {type: "BPMNDiagram"},
	
	            childShapes: [],    //子形状
	
	            outgoing: [],  // 下一个要连接的形状
	
	            bounds: {
	                upperLeft: {x:0, y:0},  //左上角坐标
	                lowerRight: {x:0, y:0} //右下角坐标
	            }
	        }
	    });
	    module.exports = BPMNModel;
	
	


/***/ },
/* 79 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * 节点等的模型
	 * 里面存的数据用来处理序列化和反序列化
	 * @class fish.topo.model
	 */
	
	
	    var zrUtil = __webpack_require__(4);
	    var clazzUtil = __webpack_require__(77);
	
	    function Model(option, parentModel,  extraOpt) {
	        this.parentModel = parentModel;
	        this.option = option;
	
	        // Simple optimization
	        if (this.init) {
	            if (arguments.length <= 3) {
	                this.init(option, parentModel,  extraOpt);
	            }
	            else {
	                this.init.apply(this, arguments);
	            }
	        }
	    }
	
	    Model.prototype = {
	
	        constructor: Model,
	
	        /**
	         * Model 的初始化函数
	         * @private
	         * @param {Object} option
	         */
	        init: function (option) {
	            zrUtil.merge(option, this.getDefaultOption());
	        },
	
	        getDefaultOption: function () {
	            if (!this.hasOwnProperty('__defaultOption')) {
	                var optList = [];
	                var Class = this.constructor;
	                while (Class) {
	                    var opt = Class.prototype.defaultOption;
	                    opt && optList.push(opt);
	                    Class = Class.superClass;
	                }
	
	                var defaultOption = {};
	                for (var i = optList.length - 1; i >= 0; i--) {
	                    defaultOption = zrUtil.merge(defaultOption, optList[i], true);
	                }
	                this.__defaultOption = defaultOption;
	            }
	            return this.__defaultOption;
	        },
	
	        /**
	         * @private
	         */
	        mergeOption: function (option) {
	            zrUtil.merge(this.option, option, true);
	        },
	
	        /**
	         * 获取model的某个属性的值
	         * @param {string} path model中的属性
	         * @return {String}
	         *
	         * **使用范例**：
	         *
	         *      @example
	         *          node.model.get("options.text");
	         */
	        get: function (path, ignoreParent) {
	            if (!path) {
	                return this.option;
	            }
	
	            if (typeof path === 'string') {
	                path = path.split('.');
	            }
	
	            var obj = this.option;
	            var parentModel = this.parentModel;
	            for (var i = 0; i < path.length; i++) {
	                // obj could be number/string/... (like 0)
	                obj = (obj && typeof obj === 'object') ? obj[path[i]] : null;
	                if (obj == null) {
	                    break;
	                }
	            }
	            if (obj == null && parentModel && !ignoreParent) {
	                obj = parentModel.get(path);
	            }
	            return obj;
	        },
	
	        /**
	         * 设置model的某个属性的值
	         * @param {string} path model中的属性
	         * @param {String} value 所需要设置的值
	         * @return {String}
	         *
	         * **使用范例**：
	         *
	         *      @example
	         *          node.model.set("options.text","例子");
	         */
	        set: function (path, value) {
	            var obj = this.option;
	
	            if (path.indexOf(".") == -1) {
	                obj[path] = value;
	            } else {
	                var fieldArray  = path.split('.');
	                var n = fieldArray.length;
	                var currentRef = obj;
	                var fieldName;
	
	                for (var i = 0; i < n - 1; i++) {
	                    fieldName = fieldArray[i];
	                    if(currentRef[fieldName] == null) {
	                        currentRef[fieldName] = {};
	                    }
	                    currentRef = currentRef[fieldName];
	                }
	                fieldName = fieldArray[n-1];
	                currentRef[fieldName] = value;
	            }
	        },
	
	        /**
	         * @private
	         */
	        getShallow: function (key, ignoreParent) {
	            var option = this.option;
	            var val = option && option[key];
	            var parentModel = this.parentModel;
	            if (val == null && parentModel && !ignoreParent) {
	                val = parentModel.getShallow(key);
	            }
	            return val;
	        },
	
	        /**
	         * @private
	         */
	        getModel: function (path, parentModel) {
	            var obj = this.get(path, true);
	            var thisParentModel = this.parentModel;
	            var model = new Model(
	                obj, parentModel || (thisParentModel && thisParentModel.getModel(path))
	            );
	            return model;
	        },
	
	        /**
	         *清空model的option
	         * @private
	         */
	        isEmpty: function () {
	            return this.option == null;
	        },
	
	        restoreData: function () {},
	
	        /**
	         * @private
	         */
	        clone: function () {
	            var Ctor = this.constructor;
	            return new Ctor(zrUtil.clone(this.option));
	        }
	    };
	
	    // Enable Model.extend.
	    clazzUtil.enableClassExtend(Model);
	
	    module.exports = Model;
	


/***/ },
/* 80 */
/***/ function(module, exports, __webpack_require__) {

	
		var EventNode = __webpack_require__(81);
		var zrUtil = __webpack_require__(4);
	    var graphic = __webpack_require__(3);
	
	/**
	 * <g pointer-events="fill" id="sid-FF0ADFC0-D3EC-4237-AD16-A36273D1FE6D" title="Start event">
	 *    <circle id="sid-FF0ADFC0-D3EC-4237-AD16-A36273D1FE6Dbg_frame" cx="15" cy="15" r="15" stroke="" fill="#7ED321"></circle>
	 *    <path d="M11.25,8.25 L11.25,22.5 L22.5,15.375 L11.25,8.25 Z" id="sid-FF0ADFC0-D3EC-4237-AD16-A36273D1FE6Dpath1" fill="#FFFFFF"></path>
	 * </g>
	 */
	
		function StartEventNode(model, api) {
			EventNode.call(this, model, api);
	        this.startIcon = 'M11.25,8.25 L11.25,22.5 L22.5,15.375 L11.25,8.25 Z';
	        this.itemSize = 20;
			this.bpmnInfo = {type: 29, name:"StartNoneEvent" };    //节点信息
	
	        this.render(model);
	
		}
	
	    StartEventNode.prototype.render = function(model) {
	        this.removeAll();
	        this.model = model;
	        var circle = new graphic.Circle({
	                shape: {
	                    cx: 0,
	                    cy: 0,
	                    r: this.itemSize
	                },
	                style: {
	                    fill: '#7ED321'
	                },
	                z:2
	        });
	        circle.name = "Circle";
	        this.add(circle);
	        var itemSize = this.itemSize;
	        var rect = {x:-itemSize/2, y: -itemSize/2, width: itemSize, height:itemSize};
	        this.add(graphic.makePath(this.startIcon, {style: {fill: '#FFFFFF'},z:2}, rect,"center"));
	        this.position = [model.get("bounds.upperLeft.x")+itemSize , model.get("bounds.upperLeft.y")+itemSize];
	        var title = this.drawText(model.get("properties.name"));
	        title.text.name = "Title";
	        this.add(title.text);
	    };
	
	
		zrUtil.inherits(StartEventNode, EventNode);
		module.exports = StartEventNode;
	


/***/ },
/* 81 */
/***/ function(module, exports, __webpack_require__) {

	
	    var BPMNNode = __webpack_require__(75);
	    var zrUtil = __webpack_require__(4);
	    var BoundingRect = __webpack_require__(24);
	    //创建Node类 所有形状都继承Node  包括fromJSON toJSON
	    //
	    function EventNode(model,api) {
	        BPMNNode.call(this, model, api);
	        this.bpmnInfo = {type: -1, name:"EventNode" };    //节点信息
	        this.model = model;
	
	    }
	
	    EventNode.prototype.render = function() {
	
	    };
	
	
	    EventNode.prototype.getRect = function() {
	        // body...
	        var boundingRect = this.getBoundingRect();
	        //创建最小包围盒虚线
	        var points = [];
	        points[0] =[-boundingRect.width/2,-boundingRect.height/2];
	        points[1] =[boundingRect.width/2,-boundingRect.height/2];
	        points[2] =[boundingRect.width/2,boundingRect.height/2];
	        points[3] =[-boundingRect.width/2,boundingRect.height/2];
	        points[4] =[-boundingRect.width/2,-boundingRect.height/2];
	
	        //注: 因事件为圆形  所以 x y 为圆心的位置  包围矩形要减去宽度一半
	        var boundRect = new BoundingRect(this.position[0] - boundingRect.width/2 ,
	                                         this.position[1] - boundingRect.height/2,
	                                         boundingRect.width, boundingRect.height);
	        return {
	            x: this.position[0],
	            y: this.position[1],
	            width: boundingRect.width/2,
	            height: boundingRect.height/2,
	            points: points,
	            boundingRect: boundRect
	        };
	
	    };
	    EventNode.prototype.setPosition = function(pX,pY) {
	        // body...
	        this.attr('position',[pX,pY]);
	    };
	
	    EventNode.prototype.getBoundingRect = function() {
	        var circle = this.childOfName("Circle");
	        return circle.getBoundingRect();
	    };
	
	
	    zrUtil.inherits(EventNode,BPMNNode);
	    module.exports = EventNode;
	


/***/ },
/* 82 */
/***/ function(module, exports, __webpack_require__) {

	
		var EventNode = __webpack_require__(81);
		var zrUtil = __webpack_require__(4);
	    var util = __webpack_require__(73);
	    var graphic = __webpack_require__(3);
	
	/**
	<g pointer-events="fill" id="sid-39EF045E-66B5-449D-B300-5CBCE4D6698E" title="Intermediate signal catching event">
	  <circle id="sid-39EF045E-66B5-449D-B300-5CBCE4D6698Ebg_frame" cx="15" cy="15" r="15" fill="#D0011B"></circle>
	  <rect id="sid-39EF045E-66B5-449D-B300-5CBCE4D6698Ebg_rect" fill="#FFFFFF" x="9" y="9" width="12" height="12"></rect>
	</g>
	 */
	
		function EndEventNode(model, api) {
			EventNode.call(this,model, api);
	        this.bpmnType = "EndNoneEvent";
	        this.itemSize = 20;
	        this.rectSize = 12;
			this.bpmnInfo = {type: 31, name:"EndNoneEvent" };    //节点信息
	        this.render(model);
		}
	
	    EndEventNode.prototype.render = function(model) {
	        this.model = model;
	        var circle = new graphic.Circle({
	            shape: {
	                cx: 0,
	                cy: 0,
	                r: this.itemSize
	            },
	            style: {
	                fill: '#D0011B'
	            },
	            z:2
	        });
	        circle.name = "Circle";
	        this.add(circle);
	        var rect = new graphic.Rect({
	            shape: {
	                x: -this.rectSize/2,
	                y: -this.rectSize/2,
	                width: this.rectSize,
	                height: this.rectSize
	            },
	            style: {
	                fill: '#FFFFFF'
	            },
	            z:2
	        });
	        this.add(rect);
	        var itemSize = this.itemSize*2;
	        this.position = [model.get("bounds.upperLeft.x")+itemSize/2 , model.get("bounds.upperLeft.y")+itemSize/2];
	        var title = this.drawText(model.get("properties.name"));
	        title.text.name = "Title";
	        this.add(title.text);
	    };
	
		zrUtil.inherits(EndEventNode, EventNode);
		module.exports = EndEventNode;
	


/***/ },
/* 83 */
/***/ function(module, exports, __webpack_require__) {

	
		var TaskNode = __webpack_require__(84);
		var zrUtil = __webpack_require__(4);
	    var graphic = __webpack_require__(3);
	/**
	 *
	 * <g pointer-events="fill" minimumSize="85 55" id="sid-8A1CDA21-9CD0-48EC-B49D-64474EEDEF6D" title="User task">
	 *   <rect id="sid-8A1CDA21-9CD0-48EC-B49D-64474EEDEF6Dtext_frame" anchors="bottom top right left" x="1.000000059837755" y="1.0162024924" width="72" height="22.000000000000004" rx="7" ry="7" stroke="none" stroke-width="0" fill="none">
	 *   </rect>
	 *   <rect id="sid-8A1CDA21-9CD0-48EC-B49D-64474EEDEF6Dbg_frame" resize="vertical horizontal" x="5.98377549e-8" y="0.0162024924" width="85" height="55" rx="7" ry="7" stroke="#bbbbbb" stroke-width="1" fill="#f9f9f9">
	 *   </rect>
	 *   <rect xmlns:oryx="http://www.b3mn.org/oryx" xmlns="http://www.w3.org/2000/svg" id="sid-8A1CDA21-9CD0-48EC-B49D-64474EEDEF6Darea_state" anchors="bottom" x="5.98377549e-8" y="45.0162024924" width="85" height="10" rx="10" ry="10" resize="horizontal" stroke="none" stroke-width="0" fill="none" style="">
	 *   </rect>
	 *   <text xmlns:oryx="http://www.b3mn.org/oryx" xmlns="http://www.w3.org/2000/svg" font-size="12" id="sid-8A1CDA21-9CD0-48EC-B49D-64474EEDEF6Dtext_name" x="52" y="35" align="middle center" fittoelem="text_frame" stroke="#373e48" stroke-width="0pt" letter-spacing="-0.01px" transform="rotate(0 52 35)" oryx:fontSize="12" text-anchor="middle">
	 *       <tspan x="52" y="35" dy="5">Task
	 *       </tspan>
	 *   </text>
	 *   <g id="sid-8A1CDA21-9CD0-48EC-B49D-64474EEDEF6DuserTask" transform="translate(5.000000, 5.000000)" fill="#4990E2">
	 *       <path anchors="top left" d=" M4.689754749837755 0.7547497214000001  C3.124908639837755 1.5094994424 2.536902989837755 2.8359404524 3.0388532998377547 5.3878194723999995  C3.540803599837755 7.9396985024 4.256854379837756 7.9729218124 4.689754749837755 8.9207625924  C5.122655119837755 9.868603372399999 4.8340548898377556 10.6706224924 3.8239538798377546 11.1080874924  C2.813852879837755 11.5455524924 1.1967550949999999e-7 12.8579473924 5.98377549e-8 13.5870556924  C0 14.3161639924 1.226551289837755 14.2432530924 2.3088023698377547 14.2432530924  C3.391053449837755 14.2432530924 9.090909149837755 14.2432530924 9.090909149837755 14.2432530924  L9.163059219837754 0.5237704804000001  C9.163059219837754 0.5237704804000001 6.254600859837756 0 4.689754749837755 0.7547497214000001  z" id="sid-8A1CDA21-9CD0-48EC-B49D-64474EEDEF6DPath-14">
	 *       </path>
	 *       <path anchors="top left" d=" M9.595959659837757 0.7547497214000001  C11.160805759837753 1.5094994424 11.576517859837754 2.7466546824 11.074567559837757 5.298533702399999  C10.572617259837756 7.8504127324 10.028860059837754 7.9729218124 9.595959659837757 8.9207625924  C9.163059279837753 9.868603372399999 9.451659519837754 10.6706224924 10.461760559837757 11.1080874924  C11.471861559837755 11.5455524924 14.285714259837755 12.8579473924 14.285714359837757 13.5870556924  C14.285714359837757 14.3161639924 13.059163159837755 14.2432530924 11.976912059837755 14.2432530924  C10.894660959837754 14.2432530924 6.349206409837755 14.2432530924 6.349206409837755 14.2432530924  L6.152061969837755 0.4299262694  C6.152061969837755 0.4299262694 8.031113549837755 0 9.595959659837757 0.7547497214000001  z" id="sid-8A1CDA21-9CD0-48EC-B49D-64474EEDEF6DPath-14-Copy">
	 *       </path>
	 *   </g>
	 * </g>
	 */
	
	    function UserTaskNode(model,api) {
	        TaskNode.call(this,model, api);
	        this.rectSize = {width:100, height:60};
	        this.iconPath = "M765.573741 718.489888c-14.999622-112.659873-119.671567-196.438974-237.776452-196.438974-118.912273 0-220.514299 85.277222-238.20317 198.770066-11.840676 76.071559 54.585199 71.326489 54.585199 71.326489l360.734878 0C704.913173 792.148491 776.608052 801.364387 765.573741 718.489888zM690.249195 365.718379c0 89.911776-72.889077 162.810063-162.79676 162.810063-89.908706 0-162.797783-72.898287-162.797783-162.810063 0-89.916892 72.889077-162.80597 162.797783-162.80597C617.360118 202.912409 690.249195 275.801487 690.249195 365.718379z";
	        this.bpmnInfo = {type: 0, name:"UserTask" };    //节点信息
	        this.render(model);
	    }
	
	    UserTaskNode.prototype.render = function(model) {
	        var rect = new graphic.Rect({
	            shape: {
	                x: 0.5,
	                y: 0.5,
	                width: this.rectSize.width-1,
	                height: this.rectSize.height-1,
	                r: 7
	            },
	            style: {
	
	                fill: '#f9f9f9',
	                stroke: '#bbbbbb'
	            },
	            z:2
	        });
	        rect.name = "Rect";
	        this.add(rect);
	
	        var iconRect = {x:5, y: 5, width: 15, height:15};
	        var pathIcon = graphic.makePath(this.iconPath, {style: {fill: '#4990E2'},z:2}, iconRect);
	        this.add(pathIcon);
	       // this.add(graphic.makePath(this.iconPath2, {style: {fill: '#4990E2'}}, rect,"center"));
	        this.position =  [model.get("bounds.upperLeft.x"), model.get("bounds.upperLeft.y")];
	        var title = this.drawText(model.get("properties.name"));
	        title.text.name = "Title";
	        this.add(title.text);
	    };
	
	
	
		zrUtil.inherits(UserTaskNode,TaskNode);
		module.exports = UserTaskNode;
	


/***/ },
/* 84 */
/***/ function(module, exports, __webpack_require__) {

	
		var BPMNNode = __webpack_require__(75);
		var zrUtil = __webpack_require__(4);
	    var BoundingRect = __webpack_require__(24);
		//创建Node类 所有形状都继承Node
		//
		function TaskNode(model, api) {
	
			BPMNNode.call(this, model, api);
			this.bpmnInfo = {type: -1, name:"TaskNode" };    //节点信息
	        this.model = model;
	        this.slot = [];
	        this.slotEvent = [];
	        this.isCanSlot = true;  //用于控制本节点是否可以被插槽
		}
	
	    TaskNode.prototype.render = function() {
	
	    };
	
	    TaskNode.prototype.getRect = function() {
	        var boundingRect = this.getBoundingRect();
	        //创建最小包围盒虚线
	        var points = [];
	        points[0] =[-boundingRect.width/2,-boundingRect.height/2];
	        points[1] =[boundingRect.width/2,-boundingRect.height/2];
	        points[2] =[boundingRect.width/2,boundingRect.height/2];
	        points[3] =[-boundingRect.width/2,boundingRect.height/2];
	        points[4] =[-boundingRect.width/2,-boundingRect.height/2];
	
	        var boundRect = new BoundingRect(this.position[0] ,
	                                         this.position[1],
	                                         boundingRect.width, boundingRect.height);
	        return {
	            x: this.position[0]+boundingRect.width/2,
	            y: this.position[1]+boundingRect.height/2,
	            width: boundingRect.width,
	            height: boundingRect.height,
	            points: points,
	            boundingRect: boundRect
	        };
	    };
	
	    TaskNode.prototype.getBoundingRect = function() {
	        var rect = this.childOfName("Rect");
	        return rect.getBoundingRect();
	    };
	
	    TaskNode.prototype.setPosition = function(pX,pY) {
	        var boundingRect = this.getBoundingRect();
	        this.attr('position',[pX-boundingRect.width/2,pY-boundingRect.height/2]);
	
	    };
	
		zrUtil.inherits(TaskNode,BPMNNode);
		module.exports = TaskNode;
	


/***/ },
/* 85 */
/***/ function(module, exports, __webpack_require__) {

	//ManualTask节点
	
		var TaskNode = __webpack_require__(84);
		var zrUtil = __webpack_require__(4);
	    var graphic = __webpack_require__(3);
	/**
	 *
	 *  <g pointer-events="fill" minimumSize="82 42" id="sid-A9545224-4CAE-450D-893D-12CFA7E68825" title="Manual task">
	 *     <rect id="sid-A9545224-4CAE-450D-893D-12CFA7E68825text_frame" anchors="bottom top right left" x="1" y="1" width="74" height="39" rx="10" ry="10" stroke="none" stroke-width="0" fill="none"></rect>
	 *     <rect id="sid-A9545224-4CAE-450D-893D-12CFA7E68825bg_frame" resize="vertical horizontal" x="0" y="0" width="80" height="40" rx="10" ry="10" stroke="#bbbbbb" stroke-width="1" fill="#f9f9f9"></rect>
	 *     <rect xmlns:oryx="http://www.b3mn.org/oryx" xmlns="http://www.w3.org/2000/svg" id="sid-A9545224-4CAE-450D-893D-12CFA7E68825area_state" anchors="bottom" x="0" y="30" width="80" height="10" rx="10" ry="10" resize="horizontal" stroke="none" stroke-width="0" fill="none" style=""></rect>
	 *     <text xmlns:oryx="http://www.b3mn.org/oryx" xmlns="http://www.w3.org/2000/svg" font-size="12" id="sid-A9545224-4CAE-450D-893D-12CFA7E68825text_name" x="43" y="24" align="middle center" fittoelem="text_frame" stroke="#373e48" stroke-width="0pt" letter-spacing="-0.01px" transform="rotate(0 43 24)" oryx:fontSize="12" text-anchor="middle"><tspan x="43" y="24" dy="5">Task</tspan></text>
	 *     <g id="sid-A9545224-4CAE-450D-893D-12CFA7E68825manualTask" transform="translate(3,1) scale(0.8)">
	 *     <path anchors="top left" style="fill:#d1b575;stroke=none" d="m 17,9.3290326 c -0.0069,0.5512461 -0.455166,1.0455894 -0.940778,1.0376604 l -5.792746,0 c 0.0053,0.119381 0.0026,0.237107 0.0061,0.355965 l 5.154918,0 c 0.482032,-0.0096 0.925529,0.49051 0.919525,1.037574 -0.0078,0.537128 -0.446283,1.017531 -0.919521,1.007683 l -5.245273,0 c -0.01507,0.104484 -0.03389,0.204081 -0.05316,0.301591 l 2.630175,0 c 0.454137,-0.0096 0.872112,0.461754 0.866386,0.977186 C 13.619526,14.554106 13.206293,15.009498 12.75924,15 L 3.7753054,15 C 3.6045812,15 3.433552,14.94423 3.2916363,14.837136 c -0.00174,0 -0.00436,0 -0.00609,0 C 1.7212035,14.367801 0.99998255,11.458641 1,11.458641 L 1,7.4588393 c 0,0 0.6623144,-1.316333 1.8390583,-2.0872584 1.1767614,-0.7711868 6.8053358,-2.40497 7.2587847,-2.8052901 0.453484,-0.40032 1.660213,1.4859942 0.04775,2.4010487 C 8.5332315,5.882394 8.507351,5.7996113 8.4370292,5.7936859 l 6.3569748,-0.00871 c 0.497046,-0.00958 0.952273,0.5097676 0.94612,1.0738232 -0.0053,0.556126 -0.456176,1.0566566 -0.94612,1.0496854 l -4.72435,0 c 0.01307,0.1149374 0.0244,0.2281319 0.03721,0.3498661 l 5.952195,0 c 0.494517,-0.00871 0.947906,0.5066305 0.940795,1.0679848 z" id="sid-A9545224-4CAE-450D-893D-12CFA7E68825_sid-A9545224-4CAE-450D-893D-12CFA7E68825_17"></path>
	 *     </g>
	 * </g>
	 */
	    function ManualTaskNode(model,api) {
	        TaskNode.call(this,model, api);
	        this.rectSize = {width:100, height:60};
	        this.iconPath = "m 17,9.3290326 c -0.0069,0.5512461 -0.455166,1.0455894 -0.940778,1.0376604 l -5.792746,0 c 0.0053,0.119381 0.0026,0.237107 0.0061,0.355965 l 5.154918,0 c 0.482032,-0.0096 0.925529,0.49051 0.919525,1.037574 -0.0078,0.537128 -0.446283,1.017531 -0.919521,1.007683 l -5.245273,0 c -0.01507,0.104484 -0.03389,0.204081 -0.05316,0.301591 l 2.630175,0 c 0.454137,-0.0096 0.872112,0.461754 0.866386,0.977186 C 13.619526,14.554106 13.206293,15.009498 12.75924,15 L 3.7753054,15 C 3.6045812,15 3.433552,14.94423 3.2916363,14.837136 c -0.00174,0 -0.00436,0 -0.00609,0 C 1.7212035,14.367801 0.99998255,11.458641 1,11.458641 L 1,7.4588393 c 0,0 0.6623144,-1.316333 1.8390583,-2.0872584 1.1767614,-0.7711868 6.8053358,-2.40497 7.2587847,-2.8052901 0.453484,-0.40032 1.660213,1.4859942 0.04775,2.4010487 C 8.5332315,5.882394 8.507351,5.7996113 8.4370292,5.7936859 l 6.3569748,-0.00871 c 0.497046,-0.00958 0.952273,0.5097676 0.94612,1.0738232 -0.0053,0.556126 -0.456176,1.0566566 -0.94612,1.0496854 l -4.72435,0 c 0.01307,0.1149374 0.0244,0.2281319 0.03721,0.3498661 l 5.952195,0 c 0.494517,-0.00871 0.947906,0.5066305 0.940795,1.0679848 z";
	      //  this.iconPath2 = "M9.595959659837757 0.7547497214000001  C11.160805759837753 1.5094994424 11.576517859837754 2.7466546824 11.074567559837757 5.298533702399999  C10.572617259837756 7.8504127324 10.028860059837754 7.9729218124 9.595959659837757 8.9207625924  C9.163059279837753 9.868603372399999 9.451659519837754 10.6706224924 10.461760559837757 11.1080874924  C11.471861559837755 11.5455524924 14.285714259837755 12.8579473924 14.285714359837757 13.5870556924  C14.285714359837757 14.3161639924 13.059163159837755 14.2432530924 11.976912059837755 14.2432530924  C10.894660959837754 14.2432530924 6.349206409837755 14.2432530924 6.349206409837755 14.2432530924  L6.152061969837755 0.4299262694  C6.152061969837755 0.4299262694 8.031113549837755 0 9.595959659837757 0.7547497214000001  z";
	        this.bpmnInfo = {type: 4, name:"ManualTask" };    //节点信息
	        this.render(model);
	    }
	
	    ManualTaskNode.prototype.render = function(model) {
	        var rect = new graphic.Rect({
	            shape: {
	                x: 0.5,
	                y: 0.5,
	                width: this.rectSize.width-1,
	                height: this.rectSize.height-1,
	                r: 7
	            },
	            style: {
	
	                fill: '#f9f9f9',
	                stroke: '#bbbbbb'
	            },
	            z:2
	        });
	        rect.name = "Rect";
	        this.add(rect);
	
	        var iconrect = {x:5, y: 5, width: 15, height:15};
	        this.add(graphic.makePath(this.iconPath, {style: {fill: '#d1b575'},z:2}, iconrect));
	
	       // this.add(graphic.makePath(this.iconPath2, {style: {fill: '#4990E2'}}, rect,"center"));
	        this.position =  [model.get("bounds.upperLeft.x"), model.get("bounds.upperLeft.y")];
	        var title = this.drawText(model.get("properties.name"));
	        title.text.name = "Title";
	        this.add(title.text);
	    };
	
		zrUtil.inherits(ManualTaskNode,TaskNode);
		module.exports = ManualTaskNode;
	


/***/ },
/* 86 */
/***/ function(module, exports, __webpack_require__) {

	//ScriptTask节点
	
		var TaskNode = __webpack_require__(84);
		var zrUtil = __webpack_require__(4);
	    var graphic = __webpack_require__(3);
	/**
	 *
	 *  <g pointer-events="fill" minimumSize="82 42" id="sid-B83DFA9E-0066-4032-A9E8-A7FF19C1AB5D" title="Script task">
	 *     <rect id="sid-B83DFA9E-0066-4032-A9E8-A7FF19C1AB5Dtext_frame" anchors="bottom top right left" x="1" y="1" width="74" height="39" rx="10" ry="10" stroke="none" stroke-width="0" fill="none"></rect>
	 *     <rect id="sid-B83DFA9E-0066-4032-A9E8-A7FF19C1AB5Dbg_frame" resize="vertical horizontal" x="0" y="0" width="80" height="40" rx="10" ry="10" stroke="#bbbbbb" stroke-width="1" fill="#f9f9f9"></rect>
	 *     <rect xmlns:oryx="http://www.b3mn.org/oryx" xmlns="http://www.w3.org/2000/svg" id="sid-B83DFA9E-0066-4032-A9E8-A7FF19C1AB5Darea_state" anchors="bottom" x="0" y="30" width="80" height="10" rx="10" ry="10" resize="horizontal" stroke="none" stroke-width="0" fill="none" style=""></rect>
	 *     <text xmlns:oryx="http://www.b3mn.org/oryx" xmlns="http://www.w3.org/2000/svg" font-size="12" id="sid-B83DFA9E-0066-4032-A9E8-A7FF19C1AB5Dtext_name" x="43" y="24" align="middle center" fittoelem="text_frame" stroke="#373e48" stroke-width="0pt" letter-spacing="-0.01px" transform="rotate(0 43 24)" oryx:fontSize="12" text-anchor="middle"><tspan x="43" y="24" dy="5">Task</tspan></text>
	 *     <g id="sid-B83DFA9E-0066-4032-A9E8-A7FF19C1AB5DscriptTask" transform="translate(2,2) scale(0.8)">
	 *     <path anchors="top left" d="m 5,2 0,0.094 c 0.23706,0.064 0.53189,0.1645 0.8125,0.375 0.5582,0.4186 1.05109,1.228 1.15625,2.5312 l 8.03125,0 1,0 1,0 c 0,-3 -2,-3 -2,-3 l -10,0 z M 4,3 4,13 2,13 c 0,3 2,3 2,3 l 9,0 c 0,0 2,0 2,-3 L 15,6 6,6 6,5.5 C 6,4.1111 5.5595,3.529 5.1875,3.25 4.8155,2.971 4.5,3 4.5,3 L 4,3 z" style="fill:#72a7d0;stroke:none" id="sid-B83DFA9E-0066-4032-A9E8-A7FF19C1AB5D_sid-B83DFA9E-0066-4032-A9E8-A7FF19C1AB5D_17"></path>
	 *     </g>
	 * </g>
	 */
	    function ScriptTaskNode(model,api) {
	        TaskNode.call(this,model, api);
	        this.rectSize = {width:100, height:60};
	        this.iconPath = "m 5,2 0,0.094 c 0.23706,0.064 0.53189,0.1645 0.8125,0.375 0.5582,0.4186 1.05109,1.228 1.15625,2.5312 l 8.03125,0 1,0 1,0 c 0,-3 -2,-3 -2,-3 l -10,0 z M 4,3 4,13 2,13 c 0,3 2,3 2,3 l 9,0 c 0,0 2,0 2,-3 L 15,6 6,6 6,5.5 C 6,4.1111 5.5595,3.529 5.1875,3.25 4.8155,2.971 4.5,3 4.5,3 L 4,3 z";
	      //  this.iconPath2 = "M9.595959659837757 0.7547497214000001  C11.160805759837753 1.5094994424 11.576517859837754 2.7466546824 11.074567559837757 5.298533702399999  C10.572617259837756 7.8504127324 10.028860059837754 7.9729218124 9.595959659837757 8.9207625924  C9.163059279837753 9.868603372399999 9.451659519837754 10.6706224924 10.461760559837757 11.1080874924  C11.471861559837755 11.5455524924 14.285714259837755 12.8579473924 14.285714359837757 13.5870556924  C14.285714359837757 14.3161639924 13.059163159837755 14.2432530924 11.976912059837755 14.2432530924  C10.894660959837754 14.2432530924 6.349206409837755 14.2432530924 6.349206409837755 14.2432530924  L6.152061969837755 0.4299262694  C6.152061969837755 0.4299262694 8.031113549837755 0 9.595959659837757 0.7547497214000001  z";
	        this.bpmnInfo = {type: 7, name:"ScriptTask" };    //节点信息
	        this.render(model);
	    }
	
	    ScriptTaskNode.prototype.render = function(model) {
	        var rect = new graphic.Rect({
	            shape: {
	                x: 0.5,
	                y: 0.5,
	                width: this.rectSize.width-1,
	                height: this.rectSize.height-1,
	                r: 7
	            },
	            style: {
	
	                fill: '#f9f9f9',
	                stroke: '#bbbbbb'
	            },
	            z:2
	        });
	        rect.name = "Rect";
	        this.add(rect);
	
	        var iconrect = {x:5, y: 5, width: 15, height:15};
	        this.add(graphic.makePath(this.iconPath, {style: {fill: '#72a7d0'},z:2}, iconrect));
	
	       // this.add(graphic.makePath(this.iconPath2, {style: {fill: '#4990E2'}}, rect,"center"));
	        this.position =  [model.get("bounds.upperLeft.x"), model.get("bounds.upperLeft.y")];
	        var title = this.drawText(model.get("properties.name"));
	        title.text.name = "Title";
	        this.add(title.text);
	    };
	
		zrUtil.inherits(ScriptTaskNode,TaskNode);
		module.exports = ScriptTaskNode;
	


/***/ },
/* 87 */
/***/ function(module, exports, __webpack_require__) {

	//MailTask节点
	
		var TaskNode = __webpack_require__(84);
		var zrUtil = __webpack_require__(4);
	    var graphic = __webpack_require__(3);
	/**
	 *
	 *  <g pointer-events="fill" minimumSize="82 42" id="sid-B83DFA9E-0066-4032-A9E8-A7FF19C1AB5D" title="Script task">
	 *     <rect id="sid-B83DFA9E-0066-4032-A9E8-A7FF19C1AB5Dtext_frame" anchors="bottom top right left" x="1" y="1" width="74" height="39" rx="10" ry="10" stroke="none" stroke-width="0" fill="none"></rect>
	 *     <rect id="sid-B83DFA9E-0066-4032-A9E8-A7FF19C1AB5Dbg_frame" resize="vertical horizontal" x="0" y="0" width="80" height="40" rx="10" ry="10" stroke="#bbbbbb" stroke-width="1" fill="#f9f9f9"></rect>
	 *     <rect xmlns:oryx="http://www.b3mn.org/oryx" xmlns="http://www.w3.org/2000/svg" id="sid-B83DFA9E-0066-4032-A9E8-A7FF19C1AB5Darea_state" anchors="bottom" x="0" y="30" width="80" height="10" rx="10" ry="10" resize="horizontal" stroke="none" stroke-width="0" fill="none" style=""></rect>
	 *     <text xmlns:oryx="http://www.b3mn.org/oryx" xmlns="http://www.w3.org/2000/svg" font-size="12" id="sid-B83DFA9E-0066-4032-A9E8-A7FF19C1AB5Dtext_name" x="43" y="24" align="middle center" fittoelem="text_frame" stroke="#373e48" stroke-width="0pt" letter-spacing="-0.01px" transform="rotate(0 43 24)" oryx:fontSize="12" text-anchor="middle"><tspan x="43" y="24" dy="5">Task</tspan></text>
	 *     <g id="sid-B83DFA9E-0066-4032-A9E8-A7FF19C1AB5DscriptTask" transform="translate(2,2) scale(0.8)">
	 *        <path anchors="top left" d="M0.332638936,1.17391304 L8.98125126,6.65217391" id="sid-09B97C5E-BEA8-40A2-9F22-3064A2745DBELine" stroke="#FFFFFF" stroke-linecap="square"></path>
	 *        <path anchors="top left" d="M17.5500302,1.17391304 L8.90141792,6.65217391" id="sid-09B97C5E-BEA8-40A2-9F22-3064A2745DBELine-Copy-4" stroke="#FFFFFF" stroke-linecap="square"></path>
	 *	   </g>
	 * </g>
	 */
	    function MailTaskNode(model,api) {
	        TaskNode.call(this,model, api);
	        this.rectSize = {width:100, height:60};
	        this.iconPath = "M49.013,51.003c1.847,1.303,7.414,5.174,16.702,11.61S82.118,74.005,87.061,77.48c0.543,0.381,1.697,1.209,3.462,2.485c1.765,1.277,3.232,2.31,4.399,3.097c1.168,0.787,2.58,1.67,4.237,2.647c1.657,0.977,3.219,1.711,4.685,2.198c1.467,0.49,2.825,0.733,4.074,0.733H108h0.082c1.249,0,2.607-0.243,4.074-0.733c1.466-0.487,3.029-1.222,4.685-2.198c1.656-0.978,3.068-1.86,4.236-2.647s2.634-1.82,4.399-3.097s2.92-2.104,3.463-2.485c4.996-3.476,17.707-12.302,38.129-26.479c3.965-2.769,7.277-6.11,9.939-10.021C179.67,37.071,181,32.97,181,28.679c0-3.585-1.291-6.654-3.871-9.207c-2.58-2.553-5.636-3.829-9.165-3.829H48.035c-4.182,0-7.4,1.412-9.654,4.236C36.127,22.704,35,26.235,35,30.471c0,3.422,1.494,7.13,4.481,11.122S45.646,48.722,49.013,51.003z M172.852,59.72c-17.814,12.057-31.34,21.427-40.572,28.108c-3.096,2.281-5.608,4.061-7.537,5.336c-1.928,1.277-4.494,2.58-7.699,3.911c-3.204,1.331-6.191,1.996-8.961,1.996H108h-0.082c-2.77,0-5.758-0.665-8.962-1.996s-5.771-2.634-7.699-3.911c-1.928-1.275-4.44-3.055-7.536-5.336c-7.333-5.377-20.83-14.747-40.492-28.108c-3.096-2.063-5.839-4.427-8.229-7.088v64.688c0,3.586,1.276,6.654,3.829,9.207c2.553,2.554,5.622,3.83,9.207,3.83h119.929c3.584,0,6.653-1.276,9.206-3.83c2.554-2.554,3.829-5.621,3.829-9.207V52.632C178.664,55.238,175.949,57.602,172.852,59.72z";
	      //  this.iconPath2 = "M9.595959659837757 0.7547497214000001  C11.160805759837753 1.5094994424 11.576517859837754 2.7466546824 11.074567559837757 5.298533702399999  C10.572617259837756 7.8504127324 10.028860059837754 7.9729218124 9.595959659837757 8.9207625924  C9.163059279837753 9.868603372399999 9.451659519837754 10.6706224924 10.461760559837757 11.1080874924  C11.471861559837755 11.5455524924 14.285714259837755 12.8579473924 14.285714359837757 13.5870556924  C14.285714359837757 14.3161639924 13.059163159837755 14.2432530924 11.976912059837755 14.2432530924  C10.894660959837754 14.2432530924 6.349206409837755 14.2432530924 6.349206409837755 14.2432530924  L6.152061969837755 0.4299262694  C6.152061969837755 0.4299262694 8.031113549837755 0 9.595959659837757 0.7547497214000001  z";
	        this.bpmnInfo = {type: 8, name:"MailTask" };    //节点信息
	        this.render(model);
	    }
	
	    MailTaskNode.prototype.render = function(model) {
	        var rect = new graphic.Rect({
	            shape: {
	                x: 0.5,
	                y: 0.5,
	                width: this.rectSize.width-1,
	                height: this.rectSize.height-1,
	                r: 7
	            },
	            style: {
	
	                fill: '#f9f9f9',
	                stroke: '#bbbbbb'
	            },
	            z:2
	        });
	        rect.name = "Rect";
	        this.add(rect);
	
	        var iconrect = {x:5, y: 5, width: 20, height:15};
	        this.add(graphic.makePath(this.iconPath, {style: {fill: '#72a7d0'},z:2}, iconrect));
	
	       // this.add(graphic.makePath(this.iconPath2, {style: {fill: '#4990E2'}}, rect,"center"));
	        this.position =  [model.get("bounds.upperLeft.x"), model.get("bounds.upperLeft.y")];
	        var title = this.drawText(model.get("properties.name"));
	        title.text.name = "Title";
	        this.add(title.text);
	    };
	
		zrUtil.inherits(MailTaskNode,TaskNode);
		module.exports = MailTaskNode;
	


/***/ },
/* 88 */
/***/ function(module, exports, __webpack_require__) {

	//边界事件---捕获定时器事件节点
	
		var EventNode = __webpack_require__(81);
		var zrUtil = __webpack_require__(4);
	    var graphic = __webpack_require__(3);
	
	/**
	 * <g pointer-events="fill" id="sid-FF0ADFC0-D3EC-4237-AD16-A36273D1FE6D" title="Start event">
	 *    <circle id="sid-F8DFBDAD-2852-4A9A-84E9-A65943A0962Bbg_frame" cx="16" cy="16" r="15" stroke="#585858" fill="#ffffff" stroke-width="1" style="stroke-dasharray: 5.5, 3"></circle>
	 *    <circle id="sid-F8DFBDAD-2852-4A9A-84E9-A65943A0962Bframe2_non_interrupting" cx="16" cy="16" r="12" stroke="#585858" fill="none" stroke-width="1" style="stroke-dasharray: 4.5, 3"></circle>
	 *    <circle id="sid-F8DFBDAD-2852-4A9A-84E9-A65943A0962Bframe" cx="16" cy="16" r="15" stroke="#585858" fill="none" stroke-width="1"></circle>
	 *    <circle id="sid-F8DFBDAD-2852-4A9A-84E9-A65943A0962Bframe2" cx="16" cy="16" r="12" stroke="#585858" fill="none" stroke-width="1"></circle>
	 *    <path id="sid-F8DFBDAD-2852-4A9A-84E9-A65943A0962Bpath1" transform="translate(6,6)" d="M 10 0 C 4.4771525 0 0 4.4771525 0 10 C 0 15.522847 4.4771525 20 10 20 C 15.522847 20 20 15.522847 20 10 C 20 4.4771525 15.522847 1.1842379e-15 10 0 z M 9.09375 1.03125 C 9.2292164 1.0174926 9.362825 1.0389311 9.5 1.03125 L 9.5 3.5 L 10.5 3.5 L 10.5 1.03125 C 15.063526 1.2867831 18.713217 4.9364738 18.96875 9.5 L 16.5 9.5 L 16.5 10.5 L 18.96875 10.5 C 18.713217 15.063526 15.063526 18.713217 10.5 18.96875 L 10.5 16.5 L 9.5 16.5 L 9.5 18.96875 C 4.9364738 18.713217 1.2867831 15.063526 1.03125 10.5 L 3.5 10.5 L 3.5 9.5 L 1.03125 9.5 C 1.279102 5.0736488 4.7225326 1.4751713 9.09375 1.03125 z M 9.5 5 L 9.5 8.0625 C 8.6373007 8.2844627 8 9.0680195 8 10 C 8 11.104569 8.8954305 12 10 12 C 10.931981 12 11.715537 11.362699 11.9375 10.5 L 14 10.5 L 14 9.5 L 11.9375 9.5 C 11.756642 8.7970599 11.20294 8.2433585 10.5 8.0625 L 10.5 5 L 9.5 5 z " fill="#585858" stroke="none"></path>
	 * </g>
	 */
	
		function CatchTimerEventNode(model, api) {
			EventNode.call(this,model, api);
	        this.startIcon = 'M 10 0 C 4.4771525 0 0 4.4771525 0 10 C 0 15.522847 4.4771525 20 10 20 C 15.522847 20 20 15.522847 20 10 C 20 4.4771525 15.522847 1.1842379e-15 10 0 z M 9.09375 1.03125 C 9.2292164 1.0174926 9.362825 1.0389311 9.5 1.03125 L 9.5 3.5 L 10.5 3.5 L 10.5 1.03125 C 15.063526 1.2867831 18.713217 4.9364738 18.96875 9.5 L 16.5 9.5 L 16.5 10.5 L 18.96875 10.5 C 18.713217 15.063526 15.063526 18.713217 10.5 18.96875 L 10.5 16.5 L 9.5 16.5 L 9.5 18.96875 C 4.9364738 18.713217 1.2867831 15.063526 1.03125 10.5 L 3.5 10.5 L 3.5 9.5 L 1.03125 9.5 C 1.279102 5.0736488 4.7225326 1.4751713 9.09375 1.03125 z M 9.5 5 L 9.5 8.0625 C 8.6373007 8.2844627 8 9.0680195 8 10 C 8 11.104569 8.8954305 12 10 12 C 10.931981 12 11.715537 11.362699 11.9375 10.5 L 14 10.5 L 14 9.5 L 11.9375 9.5 C 11.756642 8.7970599 11.20294 8.2433585 10.5 8.0625 L 10.5 5 L 9.5 5 z';
	        this.itemSize = 10;
			this.bpmnInfo = {type: 43, name:"CatchTimerEvent" };    //节点信息
	        this.render(model);
		}
	
	    CatchTimerEventNode.prototype.render = function(model) {
	
	        var circle = new graphic.Circle({
	            shape: {
	                cx: 0,
	                cy: 0,
	                r: this.itemSize-0.5
	            },
	            style: {
	                fill: '#ffffff',
	                stroke:'#585858'
	            },
	            z:2
	        });
	        circle.name = "Circle";
	        this.add(circle);
	        var circle1 = new graphic.Circle({
	            shape: {
	                cx: 0,
	                cy: 0,
	                r: this.itemSize-3
	            },
	            style: {
	                fill: '#ffffff',
	                stroke:'#585858'
	            },
	            z:2
	        });
	        this.add(circle1);
	
	        var itemSize = this.itemSize+6;
	        var rect = {x:-itemSize/2, y: -itemSize/2, width: itemSize, height:itemSize};
	        this.add(graphic.makePath(this.startIcon, {style: {stroke:'#585858'},z:2}, rect,"center"));
	        this.position = [model.get("bounds.upperLeft.x")+this.itemSize , model.get("bounds.upperLeft.y")+this.itemSize];
	
	    };
	
		zrUtil.inherits(CatchTimerEventNode, EventNode);
		module.exports = CatchTimerEventNode;
	


/***/ },
/* 89 */
/***/ function(module, exports, __webpack_require__) {

	//边界事件---捕获信号量事件
	
		var EventNode = __webpack_require__(81);
		var zrUtil = __webpack_require__(4);
	    var graphic = __webpack_require__(3);
	
	/**
	 * <g pointer-events="fill" id="sid-FF0ADFC0-D3EC-4237-AD16-A36273D1FE6D" title="Start event">
	 *    <circle id="sid-F8DFBDAD-2852-4A9A-84E9-A65943A0962Bbg_frame" cx="16" cy="16" r="15" stroke="#585858" fill="#ffffff" stroke-width="1" style="stroke-dasharray: 5.5, 3"></circle>
	 *    <circle id="sid-F8DFBDAD-2852-4A9A-84E9-A65943A0962Bframe2_non_interrupting" cx="16" cy="16" r="12" stroke="#585858" fill="none" stroke-width="1" style="stroke-dasharray: 4.5, 3"></circle>
	 *    <path id="sid-3CC33924-73F3-4D13-A2A9-0242530680DEsignalCatching" stroke="#585858" d=" M7.7124971 20.247342  L22.333334 20.247342  L15.022915000000001 7.575951200000001  L7.7124971 20.247342  z" style="fill:none;stroke-width:1.4;stroke-miterlimit:4;stroke-dasharray:none"></path>
	 * </g>
	 */
	
		function CatchSignalEventNode(model, api) {
			EventNode.call(this,model, api);
	        this.startIcon = 'M7.7124971 20.247342  L22.333334 20.247342  L15.022915000000001 7.575951200000001  L7.7124971 20.247342  z';
	        this.itemSize = 10;
			this.bpmnInfo = {type: 72, name:"CatchSignalEvent" };    //节点信息
	        this.render(model);
		}
	
	    CatchSignalEventNode.prototype.render = function(model) {
	
	        var circle = new graphic.Circle({
	            shape: {
	                cx: 0,
	                cy: 0,
	                r: this.itemSize-0.5
	            },
	            style: {
	                fill: '#ffffff',
	                stroke:'#585858'
	            },
	            z:2
	        });
	        circle.name = "Circle";
	        this.add(circle);
	        var circle1 = new graphic.Circle({
	            shape: {
	                cx: 0,
	                cy: 0,
	                r: this.itemSize-3
	            },
	            style: {
	                fill: '#ffffff',
	                stroke:'#585858'
	            },
	            z:2
	        });
	        this.add(circle1);
	
	        var itemSize = this.itemSize+6;
	        var rect = {x:-itemSize/2, y: -itemSize/2-3, width: itemSize, height:itemSize};
	        this.add(graphic.makePath(this.startIcon, {style: {stroke:'#585858',fill:'#ffffff'},z:2}, rect,"center"));
	        this.position = [model.get("bounds.upperLeft.x")+this.itemSize , model.get("bounds.upperLeft.y")+this.itemSize];
	
	    };
	
		zrUtil.inherits(CatchSignalEventNode, EventNode);
		module.exports = CatchSignalEventNode;
	


/***/ },
/* 90 */
/***/ function(module, exports, __webpack_require__) {

	//边界事件---ThrowSignalEvent节点
	
		var EventNode = __webpack_require__(81);
		var zrUtil = __webpack_require__(4);
	    var graphic = __webpack_require__(3);
	
	/**
	 * <g pointer-events="fill" id="sid-FF0ADFC0-D3EC-4237-AD16-A36273D1FE6D" title="Start event">
	 *    <circle id="sid-F8DFBDAD-2852-4A9A-84E9-A65943A0962Bbg_frame" cx="16" cy="16" r="15" stroke="#585858" fill="#ffffff" stroke-width="1" style="stroke-dasharray: 5.5, 3"></circle>
	 *    <circle id="sid-F8DFBDAD-2852-4A9A-84E9-A65943A0962Bframe2_non_interrupting" cx="16" cy="16" r="12" stroke="#585858" fill="none" stroke-width="1" style="stroke-dasharray: 4.5, 3"></circle>
	 *    <path id="sid-3CC33924-73F3-4D13-A2A9-0242530680DEsignalCatching" stroke="#585858" d=" M7.7124971 20.247342  L22.333334 20.247342  L15.022915000000001 7.575951200000001  L7.7124971 20.247342  z" style="fill:none;stroke-width:1.4;stroke-miterlimit:4;stroke-dasharray:none"></path>
	 * </g>
	 */
	
		function ThrowSignalEventNode(model, api) {
			EventNode.call(this,model, api);
	        this.startIcon = 'M7.7124971 20.247342  L22.333334 20.247342  L15.022915000000001 7.575951200000001  L7.7124971 20.247342  z';
	        this.itemSize = 10;
			this.bpmnInfo = {type: 75, name:"ThrowSignalEvent" };    //节点信息
	        this.render(model);
		}
	
	    ThrowSignalEventNode.prototype.render = function(model) {
	
	        var circle = new graphic.Circle({
	            shape: {
	                cx: 0,
	                cy: 0,
	                r: this.itemSize-0.5
	            },
	            style: {
	                fill: '#ffffff',
	                stroke:'#585858'
	            },
	            z:2
	        });
	        circle.name = "Circle";
	        this.add(circle);
	        var circle1 = new graphic.Circle({
	            shape: {
	                cx: 0,
	                cy: 0,
	                r: this.itemSize-3
	            },
	            style: {
	                fill: '#ffffff',
	                stroke:'#585858'
	            },
	            z:2
	        });
	        this.add(circle1);
	
	        var itemSize = this.itemSize+6;
	        var rect = {x:-itemSize/2, y: -itemSize/2-3, width: itemSize, height:itemSize};
	        this.add(graphic.makePath(this.startIcon, {style: {stroke:'#585858',fill:'#000000'},z:2}, rect,"center"));
	        this.position = [model.get("bounds.upperLeft.x")+this.itemSize , model.get("bounds.upperLeft.y")+this.itemSize];
	
	    };
	
		zrUtil.inherits(ThrowSignalEventNode, EventNode);
		module.exports = ThrowSignalEventNode;
	


/***/ },
/* 91 */
/***/ function(module, exports, __webpack_require__) {

	//InclusiveGateWay节点
	
		var GatewayNode = __webpack_require__(92);
		var zrUtil = __webpack_require__(4);
	    var graphic = __webpack_require__(3);
	
	/**
	 * <g pointer-events="fill" id="sid-FF0ADFC0-D3EC-4237-AD16-A36273D1FE6D" title="Start event">
	 *    <path d=" M0 19.506393964  L19.506393964 0  L39.012787964 19.506393964  L19.506393964 39.012787964  L0 19.506393964  L0 19.506393964  z" id="sid-6D0E93DA-0E0B-47F0-AF85-3F3230367651Rectangle-1" fill="#F6A623"></path>
	 *    <path d=" M19.851221564 27.782256064000002  C24.231410964 27.782256064000002 27.782256064000002 24.231410964 27.782256064000002 19.851221564  C27.782256064000002 15.471032163999999 24.231410964 11.920187063999999 19.851221564 11.920187063999999  C15.471032163999999 11.920187063999999 11.920187063999999 15.471032163999999 11.920187063999999 19.851221564  C11.920187063999999 24.231410964 15.471032163999999 27.782256064000002 19.851221564 27.782256064000002  z" id="sid-6D0E93DA-0E0B-47F0-AF85-3F3230367651Oval-4" fill="#FFFFFF"></path>
	 * </g>
	 */
	
		function InclusiveGatewayNode(model, api) {
			GatewayNode.call(this, model, api);
	        this.startIcon = 'M0 19.506393964  L19.506393964 0  L39.012787964 19.506393964  L19.506393964 39.012787964  L0 19.506393964  L0 19.506393964  z';
	        this.nextIcon = 'M19.851221564 27.782256064000002  C24.231410964 27.782256064000002 27.782256064000002 24.231410964 27.782256064000002 19.851221564  C27.782256064000002 15.471032163999999 24.231410964 11.920187063999999 19.851221564 11.920187063999999  C15.471032163999999 11.920187063999999 11.920187063999999 15.471032163999999 11.920187063999999 19.851221564  C11.920187063999999 24.231410964 15.471032163999999 27.782256064000002 19.851221564 27.782256064000002  z';
	        this.itemSize = 20;
			this.bpmnInfo = {type: 20, name:"InclusiveGateway" };    //节点信息
	        this.render(model);
		}
	
	    InclusiveGatewayNode.prototype.render = function(model) {
	        var itemSize = this.itemSize*2;
	        var rect = {x:-itemSize/2, y: -itemSize/2, width: itemSize, height:itemSize};
	        var path = graphic.makePath(this.startIcon, {style: {fill: '#F6A623'},z:2}, rect,"center");
	        path.name = 'Path';
	        this.add(path);
	        var itemSize1 = this.itemSize;
	        var rect1 = {x:-itemSize1/2, y: -itemSize1/2, width: itemSize1, height:itemSize1};
	        this.add(graphic.makePath(this.nextIcon, {style: {fill: '#FFFFFF'},z:2}, rect1,"center"));
	        this.position = [model.get("bounds.upperLeft.x")+itemSize1 , model.get("bounds.upperLeft.y")+itemSize1];
	        var title = this.drawText(model.get("properties.name"));
	        title.text.name = "Title";
	        this.add(title.text);
	    };
	
		zrUtil.inherits(InclusiveGatewayNode, GatewayNode);
		module.exports = InclusiveGatewayNode;
	


/***/ },
/* 92 */
/***/ function(module, exports, __webpack_require__) {

	//所有GateWay节点的基类
	
	    var BPMNNode = __webpack_require__(75);
	    var zrUtil = __webpack_require__(4);
	    var BoundingRect = __webpack_require__(24);
	    //创建Node类 所有形状都继承Node  包括fromJSON toJSON
	    //
	    function GatewayNode(model, api) {
	        BPMNNode.call(this, model, api);
	        this.bpmnInfo = {type: -1, name:"GatewayNode" };    //节点信息
	        this.model = model;
	    }
	
	    GatewayNode.prototype.render = function() {
	
	    };
	
	    GatewayNode.prototype.getRect = function() {
	        var boundingRect = this.getBoundingRect();
	        //创建最小包围盒虚线
	        var points = [];
	        points[0] =[-boundingRect.width/2,-boundingRect.height/2];
	        points[1] =[boundingRect.width/2,-boundingRect.height/2];
	        points[2] =[boundingRect.width/2,boundingRect.height/2];
	        points[3] =[-boundingRect.width/2,boundingRect.height/2];
	        points[4] =[-boundingRect.width/2,-boundingRect.height/2];
	        var boundRect = new BoundingRect(this.position[0] - boundingRect.width/2 ,
	                                         this.position[1] - boundingRect.height/2,
	                                         boundingRect.width, boundingRect.height);
	        return {
	            x: this.position[0],
	            y: this.position[1],
	            width: boundingRect.width/2,
	            height: boundingRect.height/2,
	            points: points,
	            boundingRect: boundRect
	        };
	
	    };
	    GatewayNode.prototype.setPosition = function(pX,pY) {
	        // body...
	        this.attr('position',[pX,pY]);
	    };
	    GatewayNode.prototype.getBoundingRect = function() {
	        var path = this.childOfName("Path");
	        return path.getBoundingRect();
	    };
	
	    zrUtil.inherits(GatewayNode,BPMNNode);
	    module.exports = GatewayNode;
	


/***/ },
/* 93 */
/***/ function(module, exports, __webpack_require__) {

	//ExclusiveGateWay节点
	
		var GatewayNode = __webpack_require__(92);
		var zrUtil = __webpack_require__(4);
	    var graphic = __webpack_require__(3);
	
	/**
	 * <g pointer-events="fill" id="sid-FF0ADFC0-D3EC-4237-AD16-A36273D1FE6D" title="Start event">
	 *    <path d=" M0 19.506393964  L19.506393964 0  L39.012787964 19.506393964  L19.506393964 39.012787964  L0 19.506393964  L0 19.506393964  z" id="sid-6D0E93DA-0E0B-47F0-AF85-3F3230367651Rectangle-1" fill="#F6A623"></path>
	 *    <path d=" M8.275862069 11.965517269000001  L1.499999999 11.965517269000001  L0 11.965517269000001  L0 8.965517239  L1.499999999 8.965517239  L8.275862069 8.965517239  L8.275862069 1.499999999  L8.275862069 0  L11.275862069 0  L11.275862069 1.499999999  L11.275862069 8.965517239  L18.741379269 8.965517239  L20.241379269 8.965517239  L20.241379269 11.965517269000001  L18.741379269 11.965517269000001  L11.275862069 11.965517269000001  L11.275862069 18.741379269  L11.275862069 20.241379269  L8.275862069 20.241379269  L8.275862069 18.741379269  L8.275862069 11.965517269000001  z" id="sid-1B88D2DF-A08F-4837-91F2-91F67ACAB29ALine-Copy"></path>
	 * </g>
	 */
	
		function ExclusiveGatewayNode(model, api) {
			GatewayNode.call(this, model, api);
	        this.startIcon = 'M0 19.506393964  L19.506393964 0  L39.012787964 19.506393964  L19.506393964 39.012787964  L0 19.506393964  L0 19.506393964  z';
	        this.nextIcon = 'M19.904129064000003 17.676993964000005  L24.997457864000005 12.583664864000003  L26.058118064000006 11.523004664000002  L28.179438464 13.644324964000003  L27.118778264 14.704985164000002  L22.025449364000004 19.798314364  L27.118778264 24.891643464000005  L28.179438464 25.952303664000006  L26.058118064000006 28.073623964000003  L24.997457864000005 27.012963764000006  L19.904129064000003 21.919634764  L14.810800164000003 27.012963764000006  L13.750140064000002 28.073623964000003  L11.628819664000003 25.952303664000006  L12.689479764000003 24.891643464000005  L17.782808764000002 19.798314364  L12.689479764000003 14.704985164000002  L11.628819664000003 13.644324964000003  L13.750140064000002 11.523004664000002  L14.810800164000003 12.583664864000003  L19.904129064000003 17.676993964000005  z';
	        this.itemSize = 20;
			this.bpmnInfo = {type: 17, name:"ExclusiveGateway" };    //节点信息
	        this.render(model);
		}
	
	    ExclusiveGatewayNode.prototype.render = function(model) {
	        var itemSize = this.itemSize*2;
	        var rect = {x:-itemSize/2, y: -itemSize/2, width: itemSize, height:itemSize};
	        var path = graphic.makePath(this.startIcon, {style: {fill: '#F6A623'},z:2}, rect,"center");
	        path.name = 'Path';
	        this.add(path);
	        var itemSize1 = this.itemSize;
	        var rect1 = {x:-itemSize1/2, y: -itemSize1/2, width: itemSize1, height:itemSize1};
	        this.add(graphic.makePath(this.nextIcon, {style: {fill: '#FFFFFF'},z:2}, rect1,"center"));
	        this.position = [model.get("bounds.upperLeft.x")+itemSize1 , model.get("bounds.upperLeft.y")+itemSize1];
	        var title = this.drawText(model.get("properties.name"));
	        title.text.name = "Title";
	        this.add(title.text);
	    };
	
		zrUtil.inherits(ExclusiveGatewayNode, GatewayNode);
		module.exports = ExclusiveGatewayNode;
	


/***/ },
/* 94 */
/***/ function(module, exports, __webpack_require__) {

	//ParallelGateWay节点
	
		var GatewayNode = __webpack_require__(92);
		var zrUtil = __webpack_require__(4);
	    var graphic = __webpack_require__(3);
	
	/**
	 * <g pointer-events="fill" id="sid-FF0ADFC0-D3EC-4237-AD16-A36273D1FE6D" title="Start event">
	 *    <path d=" M0 19.506393964  L19.506393964 0  L39.012787964 19.506393964  L19.506393964 39.012787964  L0 19.506393964  L0 19.506393964  z" id="sid-6D0E93DA-0E0B-47F0-AF85-3F3230367651Rectangle-1" fill="#F6A623"></path>
	 *    <path d=" M19.904129064000003 17.676993964000005  L24.997457864000005 12.583664864000003  L26.058118064000006 11.523004664000002  L28.179438464 13.644324964000003  L27.118778264 14.704985164000002  L22.025449364000004 19.798314364  L27.118778264 24.891643464000005  L28.179438464 25.952303664000006  L26.058118064000006 28.073623964000003  L24.997457864000005 27.012963764000006  L19.904129064000003 21.919634764  L14.810800164000003 27.012963764000006  L13.750140064000002 28.073623964000003  L11.628819664000003 25.952303664000006  L12.689479764000003 24.891643464000005  L17.782808764000002 19.798314364  L12.689479764000003 14.704985164000002  L11.628819664000003 13.644324964000003  L13.750140064000002 11.523004664000002  L14.810800164000003 12.583664864000003  L19.904129064000003 17.676993964000005  z" id="sid-8FCD6C01-B973-4C9C-A90B-3D2ADFC75217Line" fill="#FFFFFF"></path>
	 * </g>
	 */
	
		function ParallelGatewayNode(model, api) {
			GatewayNode.call(this, model, api);
	        this.startIcon = 'M0 19.506393964  L19.506393964 0  L39.012787964 19.506393964  L19.506393964 39.012787964  L0 19.506393964  L0 19.506393964  z';
	        this.nextIcon = 'M8.275862069 11.965517269000001  L1.499999999 11.965517269000001  L0 11.965517269000001  L0 8.965517239  L1.499999999 8.965517239  L8.275862069 8.965517239  L8.275862069 1.499999999  L8.275862069 0  L11.275862069 0  L11.275862069 1.499999999  L11.275862069 8.965517239  L18.741379269 8.965517239  L20.241379269 8.965517239  L20.241379269 11.965517269000001  L18.741379269 11.965517269000001  L11.275862069 11.965517269000001  L11.275862069 18.741379269  L11.275862069 20.241379269  L8.275862069 20.241379269  L8.275862069 18.741379269  L8.275862069 11.965517269000001  z';
	        this.itemSize = 20;
			this.bpmnInfo = {type: 20, name:"ParallelGateway" };    //节点信息
	        this.render(model);
		}
	
	    ParallelGatewayNode.prototype.render = function(model) {
	        var itemSize = this.itemSize*2;
	        var rect = {x:-itemSize/2, y: -itemSize/2, width: itemSize, height:itemSize};
	        var path = graphic.makePath(this.startIcon, {style: {fill: '#F6A623'},z:2}, rect,"center");
	        path.name = 'Path';
	        this.add(path);
	        var itemSize1 = this.itemSize;
	        var rect1 = {x:-itemSize1/2, y: -itemSize1/2, width: itemSize1, height:itemSize1};
	        this.add(graphic.makePath(this.nextIcon, {style: {fill: '#FFFFFF'},z:2}, rect1,"center"));
	        this.position = [model.get("bounds.upperLeft.x")+itemSize1 , model.get("bounds.upperLeft.y")+itemSize1];
	        var title = this.drawText(model.get("properties.name"));
	        title.text.name = "Title";
	        this.add(title.text);
	    };
	
		zrUtil.inherits(ParallelGatewayNode, GatewayNode);
		module.exports = ParallelGatewayNode;
	


/***/ },
/* 95 */
/***/ function(module, exports, __webpack_require__) {

	//子流程
	
		var BPMNNode = __webpack_require__(75);
		var zrUtil = __webpack_require__(4);
	    var BoundingRect = __webpack_require__(24);
	    var graphic = __webpack_require__(3);
	    var Connector = __webpack_require__(96);
		//创建Node类 所有形状都继承Node
		//
		function SubProcessNode(model, api) {
	
			BPMNNode.call(this, model, api);
			this.bpmnInfo = {type: -1, name:"SubProcess" };    //节点信息
	        this.model = model;
	        this.slot = [];
	        this.slotEvent = [];
	        this.isCanSlot = true;
	        var width,height;
	        width = model.get("bounds.lowerRight.x")-model.get("bounds.upperLeft.x");
	        height = model.get("bounds.lowerRight.y")-model.get("bounds.upperLeft.y");
	        if(!width || width <= 0){
	            width = 160;
	        }
	        if(!height || height <= 0){
	            height = 100;
	        }
	
	        this.rectSize = {width:width, height:height};
	        this.render(model);
		}
	
	
	    SubProcessNode.prototype.initEvent = function(api) {
	        var that = this;
	        var MOUSE_EVENT_NAMES = ['dblclick', 'click'];//'click', 'dblclick', 'mouseover', 'mouseout'
	
	
	        zrUtil.each(MOUSE_EVENT_NAMES, function (eveName) {
	            that.on(eveName, function (e) {
	                var params = {};
	                params.event = e;
	                var current = e.target;
	                if (current.parent &&  current.parent instanceof Connector) {
	                    return;
	                }
	                params.type = eveName;
	                params.target = that;
	                api.trigger(eveName, params);
	            }, this);
	        });
	    };
	
	
	    SubProcessNode.prototype.render = function(model) {
	    	var rect = new graphic.Rect({
	            shape: {
	                x: 0.5,
	                y: 0.5,
	                width: this.rectSize.width-1,
	                height: this.rectSize.height-1,
	                r: 7
	            },
	            style: {
	
	                fill: '#f9f9f9',
	                stroke: '#bbbbbb'
	            },
	            z:2
	        });
	        rect.name = "Rect";
	        this.add(rect);
	        this.position =  [model.get("bounds.upperLeft.x"), model.get("bounds.upperLeft.y")];
	        var title = this.drawText(model.get("properties.name"));
	        title.text.name = "Title";
	        this.add(title.text);
	    };
	
	
	    SubProcessNode.prototype.getRect = function() {
	        // body...
	        var boundingRect = this.getBoundingRect();
	        //创建最小包围盒虚线
	        var points = [];
	        points[0] =[-boundingRect.width/2,-boundingRect.height/2];
	        points[1] =[boundingRect.width/2,-boundingRect.height/2];
	        points[2] =[boundingRect.width/2,boundingRect.height/2];
	        points[3] =[-boundingRect.width/2,boundingRect.height/2];
	        points[4] =[-boundingRect.width/2,-boundingRect.height/2];
	
	        var boundRect = new BoundingRect(this.position[0] ,
	                                         this.position[1],
	                                         boundingRect.width, boundingRect.height);
	        return {
	            x: this.position[0]+boundingRect.width/2,
	            y: this.position[1]+boundingRect.height/2,
	            width: boundingRect.width,
	            height: boundingRect.height,
	            points: points,
	            boundingRect: boundRect
	        };
	    };
	
	    SubProcessNode.prototype.setPosition = function(pX,pY) {
	        // body...
	        var boundingRect = this.getBoundingRect();
	        this.attr('position',[pX-boundingRect.width/2,pY-boundingRect.height/2]);
	
	    };
	
	
	    SubProcessNode.prototype.refresh = function(opt) {
	        var rect = this.childOfName("Rect");
	        rect.setShape(opt.shape);
	        this.attr('position',opt.position);
	        this.refreshText();
	    };
	
	
	
	    SubProcessNode.prototype.getBoundingRect = function() {
	        var rect = this.childOfName("Rect");
	        return rect.getBoundingRect();
	    };
	
	    /**
	     * 根据属性设置模型数据
	     * @param {[type]} option [description]
	     */
	    SubProcessNode.prototype.setModel = function(option) {
	        var that = this;
	        var originText = this.model.get("properties.name");
	        this.model.mergeOption(option);
	        if(originText != option.properties.name) {
	            var title = this.childOfName("Title");
	            var nameByteLength = option.properties.name.length;
	            var showName;
	            if(nameByteLength > 64){
	                showName = option.properties.name.substr(0,64)+'..';
	                this.alarm.isShow = true;
	            }else{
	                showName = option.properties.name;
	                this.alarm.isShow = false;
	            }
	            title.attr("style",{text:showName});
	            that.refreshText(that);
	            var name = option.properties.name;
	            var text = this.alarm.childOfName("Text");
	            text.attr("style",{text:name});
	            var groupWidth = text.getBoundingRect().width+4;
	            var groupHeight = text.getBoundingRect().height+8;
	            var points = [
	                [0,0],
	                [groupWidth,0],
	                [groupWidth,groupHeight],
	                [groupWidth-3,groupHeight],
	                [groupWidth-6,groupHeight+3],
	                [groupWidth-9,groupHeight],
	                [0,groupHeight],
	                [0,0]
	            ];
	            var Polyline = this.alarm.childOfName("Polyline");
	            Polyline.attr("shape",{points:points});
	            var groupPosition = [this.position[0]+this.getBoundingRect().width-(this.alarm.getBoundingRect().width-6),this.position[1]-this.alarm.getBoundingRect().height-3];
	            this.alarm.attr("position",groupPosition);
	        }
	    };
	
	
	    SubProcessNode.prototype.toJSON = function() {
	        this.model.set("resourceId", this.resourceId);
	        this.model.set("properties.type", this.bpmnInfo.type);
	        this.model.set("stencil.type", this.bpmnInfo.name);  //stencil.id
	        if (this.slotEvent && this.slotEvent.length > 0) {
	            var arrSlotEvent = [];
	            for (var i = this.slotEvent.length - 1; i >= 0; i--) {
	                arrSlotEvent.push(this.slotEvent[i].resourceId)
	            }
	            this.model.set("properties.slotEvent", arrSlotEvent);
	        }
	            // var rect = this.getRect();
	            // this.model.set("bounds.upperLeft.x", rect.x);
	            // this.model.set("bounds.upperLeft.y", rect.y);
	            // this.model.set("bounds.lowerRight.x", rect.x + rect.boundingRect.width);
	            // this.model.set("bounds.lowerRight.y", rect.y + rect.boundingRect.height);
	
	        var rect = this.getRect().boundingRect;
	        this.model.set("bounds.upperLeft.x", rect.x);
	        this.model.set("bounds.upperLeft.y", rect.y);
	        this.model.set("bounds.lowerRight.x", rect.x + rect.width);
	        this.model.set("bounds.lowerRight.y", rect.y + rect.height);
	
	
	
	        // 加入子流程的 节点
	        var arrChildSahpes = [];
	        this.eachChild(function(child){
	            if (child instanceof BPMNNode) {
	                arrChildSahpes.push(child.toJSON());
	            }
	
	            if (child instanceof Connector) {
	                arrChildSahpes.push(child.toJSON());
	            }
	        });
	
	
	
	        this.model.set("childShapes", arrChildSahpes);
	        return this.model.option;
	    };
	
		zrUtil.inherits(SubProcessNode,BPMNNode);
		module.exports = SubProcessNode;
	


/***/ },
/* 96 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * 连接线
	 * @author wang.xiaohu
	 */
	
	    var Util = __webpack_require__(73);
	    var zrUtil = __webpack_require__(4);
	    var graphic = __webpack_require__(3);
	    var Node = __webpack_require__(76);
	    var symbolUtil = __webpack_require__(97);
	    var Handle = __webpack_require__(98);
	    var EffectLine = __webpack_require__(99);
	    var ConnectionPoint = __webpack_require__(100);
	    var Point = __webpack_require__(59);
	    /**
	     * 构造函数
	     * @param {[type]} options [description]
	     */
	    function Connector(options) {
	        Node.call(this);
	        this.resourceId = Util.getUUID();  // 生成节点ID
	        var defaultOptions = {
	            symbol: {type:"arrow" , size: 10, color:"#000000"},  //箭头  可选值为： 'circle', 'rect', 'roundRect', 'triangle', 'diamond', 'pin', 'arrow'
	            style: {lineWidth:1, stroke:"#000000", lineType:Connector.TYPE_STRAIGHT},    //样式
	            hoverStyle: {lineWidth:2, stroke:"lime"}, //移上去的样式
	            arrowHoverStyle: {fill:"lime"},
	            shape: {points:null, smooth:false, smoothConstraint:null},//形状
	            position: [0,0],
	            isEdit: true,  //是否可编辑
	            text: {
	                text: "",
	                color: '#000000', // 文本颜色
	                textFont: '12px Microsoft YaHei'
	            },
	            z: 0
	        }
	        var opt = options || {};
	        this.options = zrUtil.merge(defaultOptions, opt, true);
	        this.model = options.model;
	        this.handles = [];
	        this.connectionPoints = [];
	        this.conPointsGroup = null;
	        this.startNode = null;
	        this.endNode = null;
	        this.line = null;
	        this.groupCurve = new graphic.Group();
	        this.icons = [];  // 用于存储线段上面的操作图标
	        this.render();
	    }
	
	    Connector.TYPE_STRAIGHT = 'straight';
	
	    Connector.TYPE_JAGGED = 'jagged';
	
	    Connector.TYPE_CURVE = 'curve';
	
	    Connector.RADIUS = 3;
	
	    Connector.START_NODE = "startNode";
	
	    Connector.END_NODE = "endNode";
	
	    Connector.LEFT = "left";
	
	    Connector.RIGHT = "right";
	
	    Connector.TOP = "top";
	
	    Connector.BOTTOM = "bottom";
	
	    Connector.BOTTOM = "bottom";
	
	    Connector.SEPERATOR = "-";
	    /**
	     * 重新画线，如果传空则根据turningPoints 重新画线
	     * @param  {[type]} points [description]
	     * @return {[type]}        [description]
	     */
	    Connector.prototype.refresh = function(points) {
	        if(points) {
	            this.turningPoints = points;
	        }
	        //将[x:0,y:0]转化为[0, 0]  给zrender使用
	        var points = Util.traslatePoints(this.turningPoints);
	
	        if((this.options.style.lineType == Connector.TYPE_CURVE) && (points.length > 2)) {
	            this.modifyCurve(this.turningPoints);
	        } else {
	            this.line.attr('shape', {points: points});
	        }
	
	        var lineText = this.childOfName('lineText');
	        //开始没有创建文本，后来传进来text了，需要先创建文本
	        if (!lineText  && this.options.text.text) {
	            var text = this.drawText("lineText", this.options.text.text,0, 0);
	            this.add(text.text);
	            lineText = this.childOfName('lineText');
	        }
	        if (lineText) {
	            lineText.setStyle("text", this.options.text.text);
	
	            var textPoint = this.getTextPostion(this.options.text);
	
	            // if (this.options.style.lineType == Connector.TYPE_STRAIGHT ) {
	            //     lineText.attr('rotation', this.getTextRotation(textPoint));
	            // }
	
	            lineText.attr("position", textPoint);
	        }
	        var symbolTo = this.childOfName('toSymbol');
	        if(symbolTo) {
	            if(this.options.effect&&this.options.effect.show){
	                new EffectLine(symbolTo,this.options,this.groupCurve,this.polyLine);
	            }else{
	                symbolTo.attr('position', points[points.length -1]);
	                symbolTo.attr('rotation', Util.tangentRotation(this.turningPoints[this.turningPoints.length-2], this.turningPoints[this.turningPoints.length-1]));
	            }
	        }
	   };
	    /**
	     * 渲染
	     * @return {[type]} [description]
	     */
	    Connector.prototype.render = function() {
	        var that = this;
	        //1.创建箭头
	        var symbolTo = this.createSymbol('toSymbol', this.options); //arrow,triangle
	        if (symbolTo) {
	            this.add(symbolTo);
	        }
	
	        //2.创建线
	        this.curveLine = new graphic.BezierCurve({
	            position: this.options.position,
	            style: this.options.style,
	            z: this.options.z
	        });
	        this.groupCurve.add(this.curveLine);
	        this.add(this.groupCurve);
	
	        this.polyLine = new graphic.Polyline({
	            position: this.options.position,
	            shape: this.options.shape,
	            style: this.options.style,
	            z: this.options.z
	        });
	        this.add(this.polyLine);
	
	        if((this.options.style.lineType == Connector.TYPE_CURVE)) {
	            this.line = this.groupCurve;
	            this.createHoverStyle(this.curveLine);
	            this.polyLine.hide();
	        }
	        else {
	            this.line = this.polyLine;
	            this.createHoverStyle(this.polyLine);
	            this.curveLine.hide();
	        }
	
	        //3.侦听线事件
	        var MOUSE_EVENT_NAMES = ['dblclick', 'click'];//'click', 'dblclick', 'mouseover', 'mouseout'
	        zrUtil.each(MOUSE_EVENT_NAMES, function (eveName) {
	            this.line.on(eveName, zrUtil.bind(function (e) {
	                e.cancelBubble = true;
	                var params = {};
	                params.event = e;
	                params.type = "Connector:" + eveName;
	                params.target = that;
	                this.trigger(params.type, params);
	                if(this.options.isEdit == false){return;}
	
	                if(this.options.isEdit && this.connectionPoints.length < 1 && this.turningPoints.length >=2) {
	                    this.createAllconnectionPoint()
	                }
	                if(this.handles.length < 1 ) {
	                    this.shapeSetHandle();
	                }
	            }, this));
	        }, this);
	
	        //3.创建调整线的连接点
	        if(this.options.isEdit) {
	            this.conPointsGroup = new graphic.Group();
	            this.add(this.conPointsGroup);
	        }
	
	        //4.创建线上文本
	        if (this.options.text.text && this.options.text.text != "") {
	            var text = this.drawText("lineText", this.options.text.text,0, 0);
	            this.add(text.text);
	        }
	
	
	    };
	
	    //设置style
	    Connector.prototype.setStyle = function(options) {
	        if(options.color){
	            if(this.options.style.lineType == Connector.TYPE_CURVE){
	                this.groupCurve.eachChild(function(curve) {
	                    curve.attr("style",{stroke:options.color});
	                    graphic.setNormalStyle(curve, {stroke:options.color});
	                });
	            }else{
	                this.polyLine.attr("style",{stroke:options.color});
	                graphic.setNormalStyle(this.polyLine, {stroke:options.color});
	            }
	            var symbolTo = this.childOfName('toSymbol');
	            if (symbolTo) {
	                symbolTo.attr("style",{fill:options.color});
	                graphic.setNormalStyle(symbolTo, {fill:options.color});
	            }
	            this.options.style.stroke = options.color;
	            this.model.set("options.style.stroke", options.color);
	            this.model.set("options.symbol.color", options.color);
	        }
	
	        if(options.text){
	             var lineText = this.childOfName('lineText');
	            //开始没有创建文本，后来传进来text了，需要先创建文本
	            if (!lineText  && options.text.text) {
	                var text = this.drawText("lineText", options.text.text,0, 0);
	                this.add(text.text);
	                lineText = this.childOfName('lineText');
	            }
	
	            if(options.text.text || options.text.text == ""){
	                lineText.setStyle("text", options.text.text);
	                this.options.text.text = options.text.text;
	            }
	            var textPoint = this.getTextPostion(options.text);
	            lineText.attr("position", textPoint);
	            if(options.text.textPos){
	                this.options.text.textPos = options.text.textPos;
	            }else{
	                this.options.text.textPos = 'center';
	            }
	            if(options.text.color){
	                lineText.attr("style",{
	                    fill: options.text.color
	                });
	                this.options.text.color = options.text.color;
	            }
	            this.model.set("options.text", options.text);
	        }
	
	    };
	
	    /**
	     * 获取线段的位置
	     * @param  {Object} text {text:'', color:'', textPos:''}
	     * @return {Object}      {x,y}
	     */
	    Connector.prototype.getTextPostion = function(text) {
	        var textPostion = [];
	        var textWidth = graphic.textContain.getWidth(text.text, text.textFont);
	        if(text&&text.textPos){
	            if(text.textPos == 'start'){
	                var xOffset = text.xOffset || 0;
	                textPostion = [this.turningPoints[0].x + xOffset,this.turningPoints[0].y];
	            }else if(text.textPos == 'end'){
	                if (this.options.style.lineType == Connector.TYPE_STRAIGHT ) {
	                    var points  = Util.getMaxLineLength(this.turningPoints);
	
	                    var angle = Util.getAngle(points[0],points[1]);
	                    var length =  Util.distance(points[0],points[1]) - textWidth;
	                    var newPoint = Util.getEndPoint(points[0], length, angle);
	                    textPostion = [newPoint.x,newPoint.y];
	                }else{
	                    textPostion = [this.turningPoints[this.turningPoints.length-1].x,this.turningPoints[this.turningPoints.length-1].y];
	                }
	            }else{
	                textPostion = this.middle(text);
	            }
	        }else{
	            var position = this.middle(text);
	            textPostion = [position[0]-textWidth/2,position[1]];
	        }
	
	        return textPostion;
	    };
	
	    /**
	     * 获取线段的旋转角度
	     * @param  {Object} textPostion {x,y}
	     * @return {Number}             角度值
	     */
	    Connector.prototype.getTextRotation = function(textPostion) {
	        //计算出极坐标的角度
	        var points  = Util.getMaxLineLength(this.turningPoints);
	        var angle = - Math.atan2(points[1].y - textPostion[1], points[1].x - textPostion[0]);  //,Math.PI/2
	        return angle;
	    };
	
	    Connector.prototype.createHoverStyle = function(el) {
	        if (this.options.hoverStyle) {
	            graphic.setElementHoverStl(el, this.options.hoverStyle);
	
	            var symbolTo = this.childOfName('toSymbol');
	            if(symbolTo){graphic.setElementHoverStl(symbolTo, this.options.arrowHoverStyle);}
	
	            el.on('mouseover', zrUtil.bind(function() {
	                graphic.doEnterHover(el);
	                if(symbolTo){graphic.doEnterHover(symbolTo);}
	
	                this.groupCurve.eachChild(function(line) {
	                    graphic.doEnterHover(line);
	                });
	            },this))
	              .on('mouseout', zrUtil.bind(function() {
	                graphic.doLeaveHover(el);
	                if(symbolTo){graphic.doLeaveHover(symbolTo);}
	                this.groupCurve.eachChild(function(line) {
	                    graphic.doLeaveHover(line);
	                });
	            },this));
	        }
	    };
	    /**
	     * 创建Node的连接点
	     * @private
	     *
	     * @return {[type]} [description]
	     */
	    Connector.prototype.createAllconnectionPoint = function() {
	        var sRect = this.startNode.getRect? this.startNode.getRect().boundingRect : Util.getRect(this.startNode).boundingRect;
	
	        var eRect = this.endNode.getRect? this.endNode.getRect().boundingRect : Util.getRect(this.endNode).boundingRect;
	
	        var sConnectorPoint = Util.getConnectorPoints(sRect);
	        var eConnectorPoint = Util.getConnectorPoints(eRect);
	
	        this.connectionPointCreate(this.startNode, sConnectorPoint.left, Connector.START_NODE + Connector.SEPERATOR + Connector.LEFT);
	        this.connectionPointCreate(this.startNode, sConnectorPoint.right, Connector.START_NODE + Connector.SEPERATOR + Connector.RIGHT);
	        this.connectionPointCreate(this.startNode, sConnectorPoint.top, Connector.START_NODE + Connector.SEPERATOR + Connector.TOP);
	        this.connectionPointCreate(this.startNode, sConnectorPoint.bottom, Connector.START_NODE + Connector.SEPERATOR + Connector.BOTTOM);
	
	        this.connectionPointCreate(this.endNode, eConnectorPoint.left, Connector.END_NODE + Connector.SEPERATOR + Connector.LEFT);
	        this.connectionPointCreate(this.endNode, eConnectorPoint.right, Connector.END_NODE + Connector.SEPERATOR + Connector.RIGHT);
	        this.connectionPointCreate(this.endNode, eConnectorPoint.top, Connector.END_NODE + Connector.SEPERATOR + Connector.TOP);
	        this.connectionPointCreate(this.endNode, eConnectorPoint.bottom, Connector.END_NODE + Connector.SEPERATOR + Connector.BOTTOM);
	
	
	        this.connectionPointCreate(this, this.turningPoints[0].clone(), ConnectionPoint.TYPE_CONNECTOR);
	
	        this.connectionPointCreate(this, this.turningPoints[this.turningPoints.length-1].clone(), ConnectionPoint.TYPE_CONNECTOR);
	    };
	
	    /**
	     * 创建连接点
	     * @private
	     * @param  {[type]} shape [description]
	     * @param  {[type]} point [description]
	     * @param  {[type]} type  [description]
	     * @return {[type]}       [description]
	     */
	    Connector.prototype.connectionPointCreate = function(shape, point, type) {
	        var conPoint = new ConnectionPoint(this, point, type, this.options);
	        this.conPointsGroup.add(conPoint.shape);
	    };
	
	    /**
	     * 清空控制点
	     * @return {[type]} [description]
	     */
	    Connector.prototype.clearHandles = function() {
	        for (var i = 0; i < this.handles.length; i++) {
	            this.remove(this.handles[i].handleShape);
	        }
	        this.handles = [];
	        if (this.conPointsGroup) {
	            this.conPointsGroup.removeAll();
	        }
	    };
	
	    /**
	     * 创建拆线 线断的控制点
	     * @return {[type]} [description]
	     */
	    Connector.prototype.shapeSetHandle = function() {
	        for(var i=1; i<this.turningPoints.length-2; i++){
	            var h;
	            var x, y;
	            //是否在一条线上
	            var isCollineaityFirst = Util.collinearity(this.turningPoints[i-1], this.turningPoints[i], this.turningPoints[i+1]);
	            var isCollineaitySecond = Util.collinearity(this.turningPoints[i], this.turningPoints[i+1], this.turningPoints[i+2]);
	            if( (!isCollineaityFirst && (!isCollineaitySecond || this.turningPoints[i+1].equals(this.turningPoints[i+2])))
	                || ( (!isCollineaityFirst || this.turningPoints[i-1].equals(this.turningPoints[i])) && !isCollineaitySecond )) {
	
	                if(this.turningPoints[i].x === this.turningPoints[i+1].x){ //same vertical
	                    x = this.turningPoints[i].x;
	                    y = (this.turningPoints[i].y + this.turningPoints[i+1].y) / 2;
	
	                    h = new Handle('h',x,y,this);
	
	
	                }
	                else if(this.turningPoints[i].y === this.turningPoints[i+1].y){ // same horizontal
	                    x = (this.turningPoints[i].x +  this.turningPoints[i+1].x) / 2;
	                    y = this.turningPoints[i].y;
	                    h =  new  Handle('v',x,y,this);
	                }
	                if (h) {
	                    this.add(h.handleShape);
	                    this.handles.push(h);
	                }
	
	            }
	        }
	    };
	
	
	    /**
	     * 创建箭头
	     * @param  {[type]} name       [description]
	     * @param  {[type]} options [description]
	     * @return {[type]}            [description]
	     */
	    Connector.prototype.createSymbol = function(name, options) {
	        var symbolType = options.symbol.type;
	        var symbolSize =this.options.symbol.size;
	        if (symbolType === 'none') {
	            return;
	        }
	
	        if (!zrUtil.isArray(symbolSize)) {
	            symbolSize = [symbolSize, symbolSize];
	        }
	        var symbolPath = symbolUtil.createSymbol(
	            symbolType, -symbolSize[0] / 2, -symbolSize[1] / 2,
	            symbolSize[0], symbolSize[1], this.options.symbol.color, this.options.z
	        );
	        symbolPath.name = name;
	
	        return symbolPath;
	    };
	
	    /**
	     * 绘制线段上的文本
	     * @param  {[type]} content [description]
	     * @param  {[type]} name [description]
	     * @param  {[type]} x       [description]
	     * @param  {[type]} y       [description]
	     * @param  {[type]} color   [description]
	     * @return {[type]}         [description]
	     */
	    Connector.prototype.drawText = function (name,content, x, y, color) {
	        var text = new graphic.Text({
	            style: {
	                text: content,
	                x: x,
	                y: y,
	                fill: color ? color : this.options.text.color,
	                textFont: this.options.text.textFont
	            },
	            zlevel: 20
	        });
	        text.name = name;
	        return {
	            text: text,
	            rect: text.getBoundingRect()
	        };
	    };
	
	    /**
	     * 获取线段的中间值
	     * @return {[type]} text
	     */
	    Connector.prototype.middle = function(text){
	
	        if(this.options.style.lineType == Connector.TYPE_STRAIGHT){
	            var points  = Util.getMaxLineLength(this.turningPoints);
	            //如果是求线段上的文字的中间值
	            // if(text) {
	            //     //取出字的长度，计算角度，
	            //     var textWidth = graphic.textContain.getWidth(text.text, text.textFont);
	            //     var angle = Util.getAngle(points[0],points[1]);
	            //     var length =  Util.distance(points[0],points[1])/2 - textWidth/2;
	            //     var newPoint = Util.getEndPoint(points[0], length, angle);
	            //     return [newPoint.x, newPoint.y];
	            // } else {
	            //     var middleX = (points[0].x + points[1].x)/2;
	            //     var middleY = (points[0].y + points[1].y) /2;
	            //     return [middleX, middleY];
	            // }
	            var middleX = (points[0].x + points[1].x)/2;
	            var middleY = (points[0].y + points[1].y) /2;
	            return [middleX, middleY];
	        }
	        else if(this.options.style.lineType == Connector.TYPE_JAGGED){
	
	            //find total distance
	            var distance = this.getLength();
	
	            //find between what turning points the half distance is
	            var index = -1;
	            var ellapsedDistance = 0;
	            for(var i=0; i<this.turningPoints.length-1; i++){
	                index = i;
	                var segment = Util.getLength(this.turningPoints[i], this.turningPoints[i+1]);
	                if(ellapsedDistance + segment < distance /2){
	                    ellapsedDistance += segment;
	                }
	                else{
	                    break;
	                }
	            }
	
	            //we have the middle distance somewhere between i(ndex) and i(ndex)+1
	            if(index != -1){
	                var missingDistance = distance / 2 - ellapsedDistance;
	                if( Util.round(this.turningPoints[index].x, 3) == Util.round(this.turningPoints[index + 1].x, 3) ){ //vertical segment (same x)
	                    return [this.turningPoints[index].x, Math.min(this.turningPoints[index].y, this.turningPoints[index + 1].y) + missingDistance];
	                } else if( Util.round(this.turningPoints[index].y, 3) == Util.round(this.turningPoints[index + 1].y, 3) ) { //horizontal segment (same y)
	                    return [Math.min(this.turningPoints[index].x, this.turningPoints[index + 1].x) + missingDistance, this.turningPoints[index].y];
	                } else{
	                    console.error("Connector:middle() - this should never happen " + this.turningPoints[index] + " " + this.turningPoints[index + 1]
	                        + " nr of points " + this.turningPoints.length
	                        );
	                }
	
	            }
	        }
	        else if(this.options.style.lineType == Connector.TYPE_CURVE){
	            var t = 0.5;
	            var l = this.getLength();
	
	            var walked = 0;
	            for(var j =0; j< this.turningPoints.length-1; j++){
	                if( walked + Util.distance(this.turningPoints[j], this.turningPoints[j+1]) > l * t ){
	                    break;
	                }
	
	                walked += Util.distance(this.turningPoints[j], this.turningPoints[j+1]);
	            }
	
	            var rest = l * t - walked;
	            var currentSegmentLength = Util.distance(this.turningPoints[j], this.turningPoints[j+1]);
	
	            //find the position/ration of the middle of Polyline on current segment
	            var segmentPercent = rest / currentSegmentLength;
	
	            var Xp = segmentPercent * (this.turningPoints[j+1].x - this.turningPoints[j].x) + this.turningPoints[j].x;
	            var Yp = segmentPercent * (this.turningPoints[j+1].y - this.turningPoints[j].y) + this.turningPoints[j].y;
	
	            return [Xp, Yp];
	
	        }
	
	        return null;
	    };
	
	    /**
	     * find total distance
	     * @return {Number} [description]
	     */
	    Connector.prototype.getLength = function() {
	            //find total distance
	        var distance = 0;
	        for(var i=0; i<this.turningPoints.length-1; i++){
	            distance += Util.getLength(this.turningPoints[i], this.turningPoints[i+1]);
	        }
	        return distance;
	    };
	
	    /**
	     * 转JSON对象
	     * @return {[type]} [description]
	     */
	    Connector.prototype.toJSON = function() {
	
	        this.model.set("resourceId", this.resourceId);
	        this.model.set("properties.type", 14);
	
	        this.model.set("bounds.upperLeft.x", this.position[0]);
	        this.model.set("bounds.upperLeft.y", this.position[1]);
	        this.model.set("bounds.lowerRight.x", this.position[0] + this.getBoundingRect().width);
	        this.model.set("bounds.lowerRight.y", this.position[1] + this.getBoundingRect().height);
	        this.model.set("style.sPos", this.sPos);
	        this.model.set("style.ePos", this.ePos);
	        this.model.set("dockers",this.turningPoints);
	        return this.model.option;
	    };
	
	     /**
	     * refreshModel
	     * @return {[type]} [description]
	     */
	    Connector.prototype.refreshModel = function() {
	        this.model.set("options.dockers",this.turningPoints);
	        var icons = [];
	        for(var i = 0;i < this.icons.length;i++){
	            var iconNode = this.icons[i];
	            var option = [iconNode.key,{
	                icon:iconNode.style.image,
	                width: iconNode.style.width,
	                height: iconNode.style.height
	            }];
	            icons.push(option);
	        }
	        this.model.set("icons",icons);
	    };
	
	    /**
	     * 调整曲线的形状
	     * @param  {array} points 点数组
	     * @return {void}
	     */
	    Connector.prototype.modifyCurve = function(points) {
	        var sol = this.getCurvePoint(points);
	
	        // 1. 如果曲线的数量 比数量的中数量要少 则删除多余的线段
	        var willDelCurves = [];
	        for (var j = sol.length, cntCurve = this.groupCurve.childCount(); j < cntCurve ; j++) {
	            willDelCurves.push(this.groupCurve.childAt(j));
	        }
	        zrUtil.each(willDelCurves, function(curve) {
	            this.groupCurve.remove(curve);
	        }, this);
	        // 2. 遍历曲线   如果存在则直接设置形状，否则创建
	        for (var i = 0; i < sol.length; i++) {
	            var line = this.groupCurve.childAt(i);
	            if (line) {
	                line.attr('shape', sol[i]);
	            } else {
	                var cure = new graphic.BezierCurve({
	                    position: this.options.position,
	                    style: this.options.style,
	                    shape: sol[i],
	                    z: this.options.z
	                });
	                this.groupCurve.add(cure);
	                this.createHoverStyle(cure);
	            }
	        }
	    };
	
	
	    /**
	     * 根据传入的点数组计算曲线的点
	     * @param  {array} P 点数组
	     * @return {object}        曲线的点数组
	     */
	    Connector.prototype.getCurvePoint = function(P) {
	        var n = P.length;
	        var sol = [];
	        if (n === 3) {
	            sol.push({x1: P[0].x,
	                   y1: P[0].y,
	                   cpx1: P[1].x,
	                   cpy1: P[1].y,
	                   x2: P[2].x,
	                   y2: P[2].y
	                });
	            return sol;
	        }
	        else if (n === 4) {
	            sol.push({x1: P[0].x,
	                   y1: P[0].y,
	                   cpx1: P[1].x,
	                   cpy1: P[1].y,
	                   cpx2: P[2].x,
	                   cpy2: P[2].y,
	                   x2: P[3].x,
	                   y2: P[3].y
	                });
	            return sol;
	        }
	
	        /**Computes factorial
	         * @param {Number} k the number
	         * */
	        function fact(k){
	            if(k===0 || k===1){
	                return 1;
	            }
	            else{
	                return k * fact(k-1);
	            }
	        }
	
	        /**Computes Bernstain*/
	        function B(i,n,u){
	            return fact(n) / (fact(i) * fact(n-i))* Math.pow(u, i) * Math.pow(1-u, n-i);
	        }
	
	        /**Computes the sum between two point
	         *@param p1 - {Point}
	         *@param p2 - {Point}
	         *@return {Point} the sum of initial points
	         **/
	        function sum(p1, p2){
	            return new Point(p1.x + p2.x, p1.y + p2.y);
	        }
	
	        /**Computes the difference between first {Point} and second {Point}
	         *@param p1 - {Point}
	         *@param p2 - {Point}
	         *@return {Point} the sum of initial points
	         **/
	        function minus(p1, p2){
	            return new Point(p1.x - p2.x, p1.y - p2.y);
	        }
	
	        /**Computes the division of a {Point} by a number
	         *@param p - {Point}
	         *@param nr - {Number}
	         *@return {Point}
	         **/
	        function divide(p, nr){
	            if(nr == 0){
	                throw "Division by zero not allowed (yet :) " + this.callee ;
	            }
	            return new Point(p.x/nr, p.y/nr);
	        }
	
	        /**Computes the multiplication of a {Point} by a number
	         *@param p - {Point}
	         *@param nr - {Number}
	         *@return {Point}
	         **/
	        function multiply(p, nr){
	            return new Point (p.x * nr, p.y * nr);
	        }
	
	
	
	
	        /*
	         *I do not get why first 4 must be 0 and last 3 of same value.....
	         *but otherwise we will get division by zero
	         */
	        var k = [0,0,0];
	
	        var j;
	        for(j=0;j<=n-3;j++){
	            k.push(j);
	        }
	
	        k.push(n-3, n-3);
	
	
	
	        for(i=1; i<=n-3; i++){
	            //q1 - compute start point
	            var q1 = divide( sum( multiply(P[i], k[i+4] - k[i+2]), multiply(P[i+1], k[i+2] - k[i+1]) ), k[i+4] - k[i+1]);
	
	            //q0 - compute 1st controll point
	            var q_01 = (k[i+3] - k[i+2]) / (k[i+3] - k[i+1]);
	            var q_02 = divide( sum( multiply(P[i-1],k[i+3] - k[i+2]), multiply(P[i], k[i+2] - k[i])), k[i+3] - k[i]);
	            var q_03 = multiply(q1, ( k[i+2] - k[i+1])/ (k[i+3] - k[i+1]) );
	            var q0 = sum(multiply(q_02, q_01), q_03);
	
	            //q2 - compute 2nd controll point
	            var q2 = divide( sum( multiply(P[i], k[i+4] - k[i+3]), multiply(P[i+1], k[i+3] - k[i+1]) ), k[i+4] - k[i+1] );
	
	            //q3 - compute end point
	            var q_31 = (k[i+3] - k[i+2]) / (k[i+4] - k[i+2]);
	            var q_32 = divide( sum( multiply(P[i+1], k[i+5] - k[i+3]), multiply(P[i+2], k[i+3] - k[i+2]) ) , k[i+5] - k[i+2]);
	            var q_33 = multiply(q2, (k[i+4] - k[i+3])/(k[i+4] - k[i+2]) );
	            var q3 = sum(multiply(q_32, q_31), q_33);
	
	            //store solution
	            //
	            sol.push({x1: q0.x,
	                   y1: q0.y,
	                   cpx1: q1.x,
	                   cpy1: q1.y,
	                   cpx2: q2.x,
	                   cpy2: q2.y,
	                   x2: q3.x,
	                   y2: q3.y
	                });
	        }
	
	        return sol;
	    };
	
	
	    Util.inherits(Connector,Node);
	
	    module.exports = Connector;
	
	


/***/ },
/* 97 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// Symbol factory
	
	
	    var graphic = __webpack_require__(3);
	    var BoundingRect = __webpack_require__(24);
	    /**
	     * Triangle shape
	     * @inner
	     */
	    var Triangle = graphic.extendShape({
	        type: 'triangle',
	        shape: {
	            cx: 0,
	            cy: 0,
	            width: 0,
	            height: 0
	        },
	        buildPath: function (path, shape) {
	            var cx = shape.cx;
	            var cy = shape.cy;
	            var width = shape.width / 2;
	            var height = shape.height / 2;
	            path.moveTo(cx, cy - height);
	            path.lineTo(cx + width, cy + height);
	            path.lineTo(cx - width, cy + height);
	            path.closePath();
	        }
	    });
	    /**
	     * Diamond shape
	     * @inner
	     */
	    var Diamond = graphic.extendShape({
	        type: 'diamond',
	        shape: {
	            cx: 0,
	            cy: 0,
	            width: 0,
	            height: 0
	        },
	        buildPath: function (path, shape) {
	            var cx = shape.cx;
	            var cy = shape.cy;
	            var width = shape.width / 2;
	            var height = shape.height / 2;
	            path.moveTo(cx, cy - height);
	            path.lineTo(cx + width, cy);
	            path.lineTo(cx, cy + height);
	            path.lineTo(cx - width, cy);
	            path.closePath();
	        }
	    });
	
	    /**
	     * Pin shape
	     * @inner
	     */
	    var Pin = graphic.extendShape({
	        type: 'pin',
	        shape: {
	            // x, y on the cusp
	            x: 0,
	            y: 0,
	            width: 0,
	            height: 0
	        },
	
	        buildPath: function (path, shape) {
	            var x = shape.x;
	            var y = shape.y;
	            var w = shape.width / 5 * 3;
	            // Height must be larger than width
	            var h = Math.max(w, shape.height);
	            var r = w / 2;
	
	            // Dist on y with tangent point and circle center
	            var dy = r * r / (h - r);
	            var cy = y - h + r + dy;
	            var angle = Math.asin(dy / r);
	            // Dist on x with tangent point and circle center
	            var dx = Math.cos(angle) * r;
	
	            var tanX = Math.sin(angle);
	            var tanY = Math.cos(angle);
	
	            path.arc(
	                x, cy, r,
	                Math.PI - angle,
	                Math.PI * 2 + angle
	            );
	
	            var cpLen = r * 0.6;
	            var cpLen2 = r * 0.7;
	            path.bezierCurveTo(
	                x + dx - tanX * cpLen, cy + dy + tanY * cpLen,
	                x, y - cpLen2,
	                x, y
	            );
	            path.bezierCurveTo(
	                x, y - cpLen2,
	                x - dx + tanX * cpLen, cy + dy + tanY * cpLen,
	                x - dx, cy + dy
	            );
	            path.closePath();
	        }
	    });
	
	    /**
	     * Arrow shape
	     * @inner
	     */
	    var Arrow = graphic.extendShape({
	
	        type: 'arrow',
	
	        shape: {
	            x: 0,
	            y: 0,
	            width: 0,
	            height: 0
	        },
	
	        buildPath: function (ctx, shape) {
	            var height = shape.height;
	            var width = shape.width;
	            var x = shape.x;
	            var y = shape.y;
	            var dx = width / 3 * 2;
	            ctx.moveTo(x, y);
	            ctx.lineTo(x + dx, y + height);
	            ctx.lineTo(x, y + height / 4 * 3);
	            ctx.lineTo(x - dx, y + height);
	            ctx.lineTo(x, y);
	            ctx.closePath();
	        }
	    });
	
	    /**
	     * Map of path contructors
	     * @type {Object.<string, module:zrender/graphic/Path>}
	     */
	    var symbolCtors = {
	        line: graphic.Line,
	
	        rect: graphic.Rect,
	
	        roundRect: graphic.Rect,
	
	        square: graphic.Rect,
	
	        circle: graphic.Circle,
	
	        diamond: Diamond,
	
	        pin: Pin,
	
	        arrow: Arrow,
	
	        triangle: Triangle
	    };
	
	    var symbolShapeMakers = {
	
	        line: function (x, y, w, h, shape) {
	            // FIXME
	            shape.x1 = x;
	            shape.y1 = y + h / 2;
	            shape.x2 = x + w;
	            shape.y2 = y + h / 2;
	        },
	
	        rect: function (x, y, w, h, shape) {
	            shape.x = x;
	            shape.y = y;
	            shape.width = w;
	            shape.height = h;
	        },
	
	        roundRect: function (x, y, w, h, shape) {
	            shape.x = x;
	            shape.y = y;
	            shape.width = w;
	            shape.height = h;
	            shape.r = Math.min(w, h) / 4;
	        },
	
	        square: function (x, y, w, h, shape) {
	            var size = Math.min(w, h);
	            shape.x = x;
	            shape.y = y;
	            shape.width = size;
	            shape.height = size;
	        },
	
	        circle: function (x, y, w, h, shape) {
	            // Put circle in the center of square
	            shape.cx = x + w / 2;
	            shape.cy = y + h / 2;
	            shape.r = Math.min(w, h) / 2;
	        },
	
	        diamond: function (x, y, w, h, shape) {
	            shape.cx = x + w / 2;
	            shape.cy = y + h / 2;
	            shape.width = w;
	            shape.height = h;
	        },
	
	        pin: function (x, y, w, h, shape) {
	            shape.x = x + w / 2;
	            shape.y = y + h / 2;
	            shape.width = w;
	            shape.height = h;
	        },
	
	        arrow: function (x, y, w, h, shape) {
	            shape.x = x + w / 2;
	            shape.y = y + h / 2;
	            shape.width = w;
	            shape.height = h;
	        },
	
	        triangle: function (x, y, w, h, shape) {
	            shape.cx = x + w / 2;
	            shape.cy = y + h / 2;
	            shape.width = w;
	            shape.height = h;
	        }
	    };
	
	    var symbolBuildProxies = {};
	    for (var name in symbolCtors) {
	        symbolBuildProxies[name] = new symbolCtors[name]();
	    }
	
	    var Symbol = graphic.extendShape({
	
	        type: 'symbol',
	
	        shape: {
	            symbolType: '',
	            x: 0,
	            y: 0,
	            width: 0,
	            height: 0
	        },
	
	        beforeBrush: function () {
	            var style = this.style;
	            var shape = this.shape;
	            // FIXME
	            if (shape.symbolType === 'pin' && style.textPosition === 'inside') {
	                style.textPosition = ['50%', '40%'];
	                style.textAlign = 'center';
	                style.textVerticalAlign = 'middle';
	            }
	        },
	
	        buildPath: function (ctx, shape) {
	            var symbolType = shape.symbolType;
	            var proxySymbol = symbolBuildProxies[symbolType];
	            if (shape.symbolType !== 'none') {
	                if (!proxySymbol) {
	                    // Default rect
	                    symbolType = 'rect';
	                    proxySymbol = symbolBuildProxies[symbolType];
	                }
	                symbolShapeMakers[symbolType](
	                    shape.x, shape.y, shape.width, shape.height, proxySymbol.shape
	                );
	                proxySymbol.buildPath(ctx, proxySymbol.shape);
	            }
	        }
	    });
	
	    // Provide setColor helper method to avoid determine if set the fill or stroke outside
	    var symbolPathSetColor = function (color) {
	        if (this.type !== 'image') {
	            var symbolStyle = this.style;
	            var symbolShape = this.shape;
	            if (symbolShape && symbolShape.symbolType === 'line') {
	                symbolStyle.stroke = color;
	            }
	            else if (this.__isEmptyBrush) {
	                symbolStyle.stroke = color;
	                symbolStyle.fill = '#fff';
	            }
	            else {
	                // FIXME 判断图形默认是填充还是描边，使用 onlyStroke ?
	                symbolStyle.fill && (symbolStyle.fill = color);
	                symbolStyle.stroke && (symbolStyle.stroke = color);
	            }
	            this.dirty();
	        }
	    };
	
	    var symbolUtil = {
	        /**
	         * Create a symbol element with given symbol configuration: shape, x, y, width, height, color
	         * @param {string} symbolType
	         * @param {number} x
	         * @param {number} y
	         * @param {number} w
	         * @param {number} h
	         * @param {number} z
	         * @param {string} color
	         */
	        createSymbol: function (symbolType, x, y, w, h, color, z) {
	            var isEmpty = symbolType.indexOf('empty') === 0;
	            if (isEmpty) {
	                symbolType = symbolType.substr(5, 1).toLowerCase() + symbolType.substr(6);
	            }
	            var symbolPath;
	
	            if (symbolType.indexOf('image://') === 0) {
	                symbolPath = new graphic.Image({
	                    style: {
	                        image: symbolType.slice(8),
	                        x: x,
	                        y: y,
	                        width: w,
	                        height: h
	                    },
	                    z: z
	                });
	            }
	            else if (symbolType.indexOf('path://') === 0) {
	                symbolPath = graphic.makePath(symbolType.slice(7), {z: z}, new BoundingRect(x, y, w, h));
	            }
	            else {
	                symbolPath = new Symbol({
	                    shape: {
	                        symbolType: symbolType,
	                        x: x,
	                        y: y,
	                        width: w,
	                        height: h
	                    },
	                    z: z
	                });
	            }
	
	            symbolPath.__isEmptyBrush = isEmpty;
	
	            symbolPath.setColor = symbolPathSetColor;
	
	            symbolPath.setColor(color);
	
	            return symbolPath;
	        }
	    };
	
	    module.exports = symbolUtil;
	


/***/ },
/* 98 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * 画句柄
	 * @author wang.xiaohu
	 */
	
	    var graphic = __webpack_require__(3);
	    var Util = __webpack_require__(73);
	    function Handle(type, x, y, connector){
	        this.type = type;
	
	        this.x = x;
	
	        this.y = y;
	
	        this.visible = true;
	
	        this.connector = connector;
	
	        this.handleShape = new graphic.Circle({
	            shape: {
	                cx: x,
	                cy: y,
	                r: Handle.RADIUS
	            },
	
	            style: {
	                fill: "rgb(0,255,0)",
	                stroke:"rgb(0,0,0)"
	            },
	            z : connector.options.z + 2,  //节点Z为1 线段为0;
	            draggable:true
	        });
	
	        var that = this;
	        this.handleShape.on("drag", function(e) {
	            that.actionConnector(e.offsetX,e.offsetY);
	        });
	       // return this.circle;
	    }
	
	    Handle.RADIUS = 4;
	
	    Handle.prototype = {
	
	        constructor : Handle,
	
	        equals : function(anotherHandle){
	            if(!anotherHandle instanceof Handle){
	                return false;
	            }
	
	            return this.type == anotherHandle.type
	            && this.x == anotherHandle.x
	            && this.y == anotherHandle.y
	            && this.visible == anotherHandle.visible;
	        },
	
	        /**
	         * 移动句柄
	         * @param  {[type]} newX [description]
	         * @param  {[type]} newY [description]
	         * @return {[type]}      [description]
	         */
	        actionConnector: function(newX, newY){
	            switch(this.type){
	                case 'v':
	                    var index;
	                    // 找出两个转折点（可移动句柄在这两个转折点中间）
	                    for(var i = 1; i < this.connector.turningPoints.length-1; i++){
	                        if(this.connector.turningPoints[i-1].y == this.connector.turningPoints[i].y
	                            && this.connector.turningPoints[i].y == this.y
	                            && Math.min(this.connector.turningPoints[i].x, this.connector.turningPoints[i-1].x) <= this.x
	                            && Math.max(this.connector.turningPoints[i].x, this.connector.turningPoints[i-1].x) >= this.x)
	                        {
	                            index = i;
	                        }
	                    }
	                    var deltaY = newY - this.y;
	                    var translationMatrix = Util.translationMatrix(0, deltaY);
	
	                    this.connector.turningPoints[index-1].transform(translationMatrix);
	                    this.connector.turningPoints[index].transform(translationMatrix);
	                    this.connector.refresh();
	                    this.y = newY;  //将句柄新的位置赋值给y
	
	                    break;
	
	                case 'h':
	                    var index;
	                    // 找出两个转折点（可移动句柄在这两个转折点中间）
	                    for(var i = 1; i < this.connector.turningPoints.length-1; i++){
	                        if(this.connector.turningPoints[i-1].x == this.connector.turningPoints[i].x
	                            && this.connector.turningPoints[i].x == this.x
	                            && Math.min(this.connector.turningPoints[i].y, this.connector.turningPoints[i-1].y) <= this.y
	                            && Math.max(this.connector.turningPoints[i].y, this.connector.turningPoints[i-1].y) >= this.y)
	                            {
	                            index = i;
	                        }
	                    }
	                    var deltaX = newX-this.x;
	                    var translationMatrix = Util.translationMatrix(deltaX, 0);
	                    this.connector.turningPoints[index-1].transform(translationMatrix);
	                    this.connector.turningPoints[index].transform(translationMatrix);
	                    this.connector.refresh();
	                    this.x = newX; //将句柄新的位置赋值给x
	
	                    break;
	            }
	           //. this.shape.updateMiddleText();
	        }
	    };
	    module.exports = Handle;
	
	
	


/***/ },
/* 99 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * 连线动态效果
	 * @author miao.cunzhi
	 */
	
	    var zrUtil = __webpack_require__(4);
	    var vec2 = __webpack_require__(14);
	    var curveUtil = __webpack_require__(26);
	    var symbolUtil = __webpack_require__(97);
	
	    function EffectLine(symbol, options, groupCurve, polyLine) {
	        this._lastFrame = 0;
	        this._lastFramePercent = 0;
	        this.symbol = symbol;
	        this.groupCurve = groupCurve;
	        this.initSymbol(options, polyLine);
	    }
	    var EffectLineProto = EffectLine.prototype;
	
	    EffectLineProto.initSymbol = function(options, polyLine) {
	        var that = this;
	        this.symbol.z2 = 100;
	        this.symbol.culling = true;
	        var period = options.effect.period * 1000;
	        this.symbol.__t = 0;
	        this.symbol.stopAnimation();
	        if ((options.style.lineType == "curve")) {
	            if (this.groupCurve) {
	                var i = 0;
	                period = period / this.groupCurve._children.length;
	                this.groupCurveAnimate(this.groupCurve._children[0], i, period);
	            }
	
	        } else {
	            this.symbol.animate('', true)
	                .when(period, {
	                    __t: 1
	                })
	                .delay(0)
	                .during(function() {
	                    that.updateSymbolPositionPolyline();
	                })
	                .start();
	            this.setAnimationPointsPolyline(polyLine.shape.points);
	        }
	
	    };
	
	    EffectLineProto.groupCurveAnimate = function(curveLine, i, period) {
	        var that = this;
	        if (curveLine == undefined) {
	            curveLine = this.groupCurve._children[0];
	            i = 0;
	        }
	        var points;
	        var pos = curveLine.shape;
	        points = [
	            [pos.x1, pos.y1],
	            [pos.x2, pos.y2],
	            [pos.cpx1, pos.cpy1],
	            [pos.cpx2, pos.cpy2]
	        ];
	        this.setAnimationPointsBezierCurve(points);
	        this.symbol.animate('')
	            .when(period, {
	                __t: 1
	            })
	            .delay(0)
	            .during(function() {
	                that.updateSymbolPositionBezierCurve();
	            })
	            .done(function() {
	                that.symbol.__t = 0;
	                that.groupCurveAnimate(that.groupCurve._children[i + 1], i + 1, period);
	            })
	            .start();
	
	    };
	
	
	    EffectLineProto.setAnimationPointsBezierCurve = function(points) {
	        this.symbol.__p1 = points[0];
	        this.symbol.__p2 = points[1];
	        this.symbol.__cp1 = points[2] || [
	            (points[0][0] + points[1][0]) / 2,
	            (points[0][1] + points[1][1]) / 2
	        ];
	        this.symbol.__cp2 = points[3];
	    };
	
	    EffectLineProto.updateSymbolPositionBezierCurve = function() {
	        var p1 = this.symbol.__p1;
	        var p2 = this.symbol.__p2;
	        var cp1 = this.symbol.__cp1;
	        var cp2 = this.symbol.__cp2;
	        var t = this.symbol.__t;
	        var pos = this.symbol.position;
	        var tx, ty;
	        if (cp2[0] != undefined) {
	            var cubicAt = curveUtil.cubicAt;
	            var cubicDerivativeAt = curveUtil.cubicDerivativeAt;
	            pos[0] = cubicAt(p1[0], cp1[0], cp2[0], p2[0], t);
	            pos[1] = cubicAt(p1[1], cp1[1], cp2[1], p2[1], t);
	            // Tangent
	            tx = cubicDerivativeAt(p1[0], cp1[0], cp2[0], p2[0], t);
	            ty = cubicDerivativeAt(p1[1], cp1[1], cp2[1], p2[1], t);
	        } else {
	            var quadraticAt = curveUtil.quadraticAt;
	            var quadraticDerivativeAt = curveUtil.quadraticDerivativeAt;
	            pos[0] = quadraticAt(p1[0], cp1[0], p2[0], t);
	            pos[1] = quadraticAt(p1[1], cp1[1], p2[1], t);
	            // Tangent
	            tx = quadraticDerivativeAt(p1[0], cp1[0], p2[0], t);
	            ty = quadraticDerivativeAt(p1[1], cp1[1], p2[1], t);
	        }
	        this.symbol.rotation = -Math.atan2(ty, tx) - Math.PI / 2;
	
	        this.symbol.ignore = false;
	    };
	
	    EffectLineProto.setAnimationPointsPolyline = function(points) {
	        this._points = points;
	        var accLenArr = [0];
	        var len = 0;
	        for (var i = 1; i < points.length; i++) {
	            var p1 = points[i - 1];
	            var p2 = points[i];
	            len += vec2.dist(p1, p2);
	            accLenArr.push(len);
	        }
	        if (len === 0) {
	            return;
	        }
	
	        for (var j = 0; j < accLenArr.length; j++) {
	            accLenArr[j] /= len;
	        }
	        this._offsets = accLenArr;
	        this._length = len;
	        this.symbol._lastFrame = 0;
	        this.symbol.__lastFramePercent = 0;
	    };
	
	    EffectLineProto.updateSymbolPositionPolyline = function() {
	        var t = this.symbol.__t;
	        var points = this._points;
	        var offsets = this._offsets;
	        var len = points.length;
	
	        if (!offsets) {
	            // Has length 0
	            return;
	        }
	
	        var lastFrame = this._lastFrame;
	        var frame;
	
	        if (t < this._lastFramePercent) {
	            // Start from the next frame
	            // PENDING start from lastFrame ?
	            var start = Math.min(lastFrame + 1, len - 1);
	            for (frame = start; frame >= 0; frame--) {
	                if (offsets[frame] <= t) {
	                    break;
	                }
	            }
	            // PENDING really need to do this ?
	            frame = Math.min(frame, len - 2);
	        } else {
	            for (var frame = lastFrame; frame < len; frame++) {
	                if (offsets[frame] > t) {
	                    break;
	                }
	            }
	            frame = Math.min(frame - 1, len - 2);
	        }
	        vec2.lerp(
	            this.symbol.position, points[frame], points[frame + 1],
	            (t - offsets[frame]) / (offsets[frame + 1] - offsets[frame])
	        );
	
	        this._lastFrame = frame;
	        this._lastFramePercent = t;
	        var angle = -Math.atan2(points[frame + 1][1] - points[frame][1], points[frame + 1][0] - points[frame][0]);
	        this.symbol.rotation = angle - Math.PI / 2;
	        this.symbol.ignore = false;
	    };
	    module.exports = EffectLine;
	


/***/ },
/* 100 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * 控制点
	 * @author wang.xiaohu
	 */
	
	    var graphic = __webpack_require__(3);
	    var Util = __webpack_require__(73);
	    function ConnectionPoint(connector, point, type, options){
	        this.connector = connector;
	
	        this.point = point.clone();
	
	        this.type = type;
	
	        this.color = ConnectionPoint.NORMAL_COLOR;
	
	        this.oType = 'ConnectionPoint';
	
	        this.shape = new graphic.Circle({
	            shape: {
	                cx: this.point.x,
	                cy: this.point.y,
	                r: ConnectionPoint.RADIUS
	            },
	
	            style: {
	                fill: this.color,
	                stroke:'#000000'
	            },
	            z : options.z + 2  //节点Z为1 线段为0;
	        });
	        this.shape.type =  this.type;
	
	        this.shape.connector = connector;
	        //return this.circle;
	    }
	
	    ConnectionPoint.NORMAL_COLOR = "#FFFF33"; //yellow.
	
	    ConnectionPoint.OVER_COLOR = "#FF9900"; //orange
	
	    ConnectionPoint.CONNECTED_COLOR = "#ff0000"; //red
	
	    ConnectionPoint.RADIUS = 4;
	
	    ConnectionPoint.TYPE_FIGURE = 'figure';
	
	    ConnectionPoint.TYPE_CONNECTOR = 'connector';
	
	    ConnectionPoint.prototype = {
	
	        constructor : ConnectionPoint,
	
	        equals : function(anotherConnectionPoint){
	            return this.point.equals(anotherConnectionPoint.point)
	            && this.connector == anotherConnectionPoint.connector
	            && this.type == anotherConnectionPoint.type
	            && this.color == anotherConnectionPoint.color
	            && this.radius == anotherConnectionPoint.radius;
	        }
	
	
	    };
	    module.exports = ConnectionPoint;
	
	
	


/***/ },
/* 101 */
/***/ function(module, exports) {

	/**
	 * BPMN静态方法类
	 * @class fish.topo.FishTopoBpmn.Bpmn
	 */
	
		var Bpmn = {
			BPMN_TYPE:"stencil.type",
			BPMN_SCRIPT_TASK: "ScriptTask",
			BPMN_EVENT_SUB_PROCESS: "SubProcessTask",
			BPMN_TASK:"Task",
			TEMPLATE: "BPMNDiagram",
			RESOURCE_ID: "resourceId",
			SEQUENCE_FLOW: "SequenceFlow",
			SUB_PROCESS: "SubProcess",
			USER_DATA: "properties.userData",
	
			START_EVENT: "StartNoneEvent",
			END_EVENT: "EndNoneEvent",
			USER_TASK: "UserTask",
			MANUAL_TASK: "ManualTask",
			SCRIPT_TASK: "ScriptTask",
			MAIL_TASK: "MailTask",
			CATCH_TIMER_EVENT: "CatchTimerEvent",
			CATCH_SIGNAL_EVENT: "CatchSignalEvent",
			THROW_SIGNAL_EVENT: "ThrowSignalEvent",
			INCLUSIVE_GATEWAY: "InclusiveGateway",
			EXCLUSIVE_GATEWAY: "ExclusiveGateway",
			PARALLEL_GATEWAY: "ParallelGateway",
	
			/**
			 * 判断节点是否 BPMN模板 类型
			 * @param  {Object}  node 需要判断类型的节点
			 * @return {Boolean}      是 否
			 */
			isTemplate: function(node) {
				var bpmntype = node.model.get(Bpmn.BPMN_TYPE);
				return bpmntype === Bpmn.TEMPLATE;
			},
	
			/**
			 * 判断节点是否 Activity 类型
			 * @param  {Object}  node 需要判断类型的节点
			 * @return {Boolean}      是 否
			 */
			isActivity: function(node) {
				var bpmntype = node.model.get(Bpmn.BPMN_TYPE);
				return (bpmntype.indexOf("Task") != -1);
			},
	
			/**
			 * 判断节点是否 子流程 类型
			 * @param  {Object}  node 需要判断类型的节点
			 * @return {Boolean}      是 否
			 */
			isSubProcess: function(node) {
				var bpmntype = node.model.get(Bpmn.BPMN_TYPE);
				return  bpmntype == Bpmn.SUB_PROCESS
			},
	
			/**
			 * 判断节点是否 网关 类型
			 * @param  {Object}  node 需要判断类型的节点
			 * @return {Boolean}      是 否
			 */
			isGateway: function(node) {
				var bpmntype = node.model.get(Bpmn.BPMN_TYPE);
				return bpmntype.indexOf("Gateway") != -1;
			},
	
			/**
			 * 判断节点是否 线段 类型
			 * @param  {Object}  node 需要判断类型的节点
			 * @return {Boolean}      是 否
			 */
			isFlow: function(node) {
				var bpmntype = node.model.get(Bpmn.BPMN_TYPE);
				return bpmntype === Bpmn.SEQUENCE_FLOW;
			},
	
			/**
			 * @private
			 * 判断模型是否 线段 类型
			 * @param  {Object}  model 需要判断类型的模型
			 * @return {Boolean}      是 否
			 */
			isFlowModel: function(model) {
				var bpmntype = model.get(Bpmn.BPMN_TYPE);
				return bpmntype === Bpmn.SEQUENCE_FLOW;
			},
	
			/**
			 * 判断节点是否 事件 类型
			 * @param  {Object}  node 需要判断类型的节点
			 * @return {Boolean}      是 否
			 */
			isEvent: function(node) {
				var bpmntype = node.model.get(Bpmn.BPMN_TYPE);
				return bpmntype.indexOf("Event") != -1;
			},
	
			/**
			 * 判断节点是否 插糟事件 类型
			 * @param  {Object}  node 需要判断类型的节点
			 * @return {Boolean}      是 否
			 */
			isSlotEvent: function(node) {
				var bpmntype = node.model.get(Bpmn.BPMN_TYPE);
				return bpmntype == Bpmn.CATCH_TIMER_EVENT || bpmntype == Bpmn.CATCH_SIGNAL_EVENT || bpmntype == Bpmn.THROW_SIGNAL_EVENT;
			},
	
			/**
			 * 获取当前节点的类型
			 * @param  {Object}  node 需要判断类型的节点
			 * @return {String}      节点的类型
			 */
			getType: function(node) {
				var bpmntype = node.model.get(Bpmn.BPMN_TYPE);
				return bpmntype;
			},
	
			/**
			 * 返回当前节点的样式选项
			 * @param  {Object}  node 需要判断类型的节点
			 * @return {Object}      样式对象
			 */
			getStyle: function(node) {
				return node.model.option.style;
			},
	
			/**
			 * 返回当前节点的属性选项
			 * @param  {Object}  node 需要判断类型的节点
			 * @return  {Object}      属性对象
			 */
			getProp: function(node) {
				return node.model.option.properties;
			},
	
			/**
			 * 获取用户自定义的数据
			 * @param  {Object}  node 需要判断类型的节点
			 * @return {Object}   用户自定义的数据
			 */
			getUserData: function(node) {
				var model = node.model;
				return model.get(Bpmn.USER_DATA);
			},
	
			/**
			 * 设置用户的自定义数据
			 * @param  {Object}  node 需要判断类型的节点
			 * @param {Object} userData 用户的自定义数据
			 */
			setUserData: function(node, userData) {
				var model = node.model;
				model.set(Bpmn.USER_DATA, userData);
			}
		};
	
		module.exports = Bpmn;
	


/***/ },
/* 102 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * 选中节点后，出现的操作框及按钮
	 */
	
	    var zrUtil = __webpack_require__(4);
	    var graphic = __webpack_require__(3);
	    var util = __webpack_require__(73);
	    var Bpmn = __webpack_require__(101);
	    var OperationNode = __webpack_require__(103);
	
	    function BpmnOperationNode(node, zr, forbidEdit) {
	        OperationNode.call(this, node, zr, forbidEdit);
	    }
	
	    BpmnOperationNode.prototype.renderOther = function() {
	        if (Bpmn.isSubProcess(this.node)) {
	            //左上角放大箭头
	            var leftTopArrow = { x: 0, y: 0, width: 10, height: 10 };
	            var leftTopArrowPath = 'M0 100 L0 0 L100 0 L100 20 L20 20 L20 100 z';
	            this.leftTop = graphic.makePath(leftTopArrowPath, { style: { fill: '#000000' } }, leftTopArrow);
	            this.leftTop.attr("cursor", "nw-resize");
	            this.leftTop.isSelfComputePos = true;  // 自己计算位置
	            //右下角放大箭头
	            var rightBottomArrow = { x: 0, y: 0, width: 10, height: 10 };
	            var rightBottomArrowPath = 'M0 100 L100 100 L100 0 L80 0 L80 80 L0 80 z';
	            this.rightBottom = graphic.makePath(rightBottomArrowPath, { style: { fill: '#000000' } }, rightBottomArrow);
	            this.rightBottom.attr("cursor", "se-resize");
	            this.rightBottom.isSelfComputePos = true;  // 自己计算位置
	
	            this.add(this.rightBottom);
	            this.add(this.leftTop);
	        }
	    };
	
	    BpmnOperationNode.prototype.refreshPositionOther = function(node,nodeRect) {
	        if (Bpmn.isSubProcess(this.node)) {
	            var that = this;
	            var startX, startY;
	            var pixel = 20;
	            //矩形最小长和宽
	            var widthMin = 100;
	            var heightMin = 60;
	            var leftTopPosition, nowleftTopPosition = [],
	                startSlotPoints, startPosition;
	            this.leftTop.on('mousedown', function(e) {
	                startSlotPoints = util.getSoltPoints(node);
	                startPosition = zrUtil.clone(node.position);
	                leftTopPosition = nodeRect.points[0];
	                startX = e.event.clientX;
	                startY = e.event.clientY;
	                leftScaleDrag(e);
	            });
	
	            function leftScaleDrag(e) {
	                var leftArrow = function(e) { leftArrowDrag(e); };
	
	                function leftArrowDrag(e) {
	                    //2个圆间距太小时,不在拖动
	                    if (that.rightBottom.position[0] - that.leftTop.position[0] < (widthMin + 10)) {
	                        if (that.rightBottom.position[1] - that.leftTop.position[1] < (heightMin + 10)) {
	                            that.leftTop.position[0] = that.rightBottom.position[0] - (widthMin + 10);
	                            that.leftTop.position[1] = that.rightBottom.position[1] - (heightMin + 10);
	                        } else {
	                            that.leftTop.position[0] = that.rightBottom.position[0] - (widthMin + 10);
	                            scaleRect(that.leftTop, e);
	                        }
	                    } else {
	                        if (that.rightBottom.position[1] - that.leftTop.position[1] < (heightMin)) {
	                            that.leftTop.position[1] = that.rightBottom.position[1] - (heightMin + 10);
	                            scaleRect(that.leftTop, e);
	                        } else {
	                            scaleRect(that.leftTop, e);
	                        }
	                    }
	
	                    function scaleRect(dom, e) {
	                        var domPosition = [];
	                        for (var n = 0; n <= Math.abs(parseInt((e.event.clientX - startX) / pixel)); n++) {
	                            if (e.event.clientX - startX <= 0) {
	                                nowleftTopPosition[0] = leftTopPosition[0] - pixel * (n);
	                                domPosition[0] = nowleftTopPosition[0] - 10;
	                            } else {
	                                if (!nowleftTopPosition[0]) {
	                                    nowleftTopPosition[0] = leftTopPosition[0];
	                                }
	                                if (nodeRect.points[2][0] - nowleftTopPosition[0] > widthMin) {
	                                    nowleftTopPosition[0] = leftTopPosition[0] + pixel * (n);
	                                    domPosition[0] = nowleftTopPosition[0] - 10;
	                                } else {
	                                    domPosition[0] = that.rightBottom.position[0] - widthMin;
	                                }
	                            }
	                        }
	                        for (var m = 0; m <= Math.abs(parseInt((e.event.clientY - startY) / pixel)); m++) {
	                            if (e.event.clientY - startY <= 0) {
	                                nowleftTopPosition[1] = leftTopPosition[1] - pixel * (m);
	                                domPosition[1] = nowleftTopPosition[1] - 10;
	                            } else {
	                                if (!nowleftTopPosition[1]) {
	                                    nowleftTopPosition[1] = leftTopPosition[1];
	                                }
	                                if (nodeRect.points[2][1] - nowleftTopPosition[1] > heightMin) {
	                                    nowleftTopPosition[1] = leftTopPosition[1] + pixel * (m);
	                                    domPosition[1] = nowleftTopPosition[1] - 10;
	                                } else {
	                                    domPosition[1] = that.rightBottom.position[1] - heightMin;
	
	                                }
	                            }
	                        }
	                        dom.attr("position", domPosition);
	                        var points = [];
	                        points[0] = [nowleftTopPosition[0], nowleftTopPosition[1]];
	                        points[1] = [nodeRect.points[1][0], nowleftTopPosition[1]];
	                        points[2] = nodeRect.points[2];
	                        points[3] = [nowleftTopPosition[0], nodeRect.points[3][1] ];
	                        points[4] = [nowleftTopPosition[0], nowleftTopPosition[1]];
	                        var params = {};
	                        params.type = "OperationNode:scaleDragLeft";
	                        params.points = points;
	                        that.trigger(params.type, params);
	                    }
	                }
	                that.zr.on('mousemove', leftArrow);
	                var leftEnd = function(e) { leftDragEnd(e) };
	
	                function leftDragEnd(e) {
	                    that.zr.off('mousemove', leftArrow);
	                    that.zr.off("mouseup", leftEnd);
	                    var params = {};
	                    params.event = e;
	                    params.arrowName = "left";
	                    params.type = "OperationNode:scaleDragEnd";
	                    params.startSlotPoints = startSlotPoints;
	                    params.startPosition = startPosition;
	                    that.trigger(params.type, params);
	                }
	                that.zr.on("mouseup", leftEnd);
	            }
	
	            var rightBottomPosition, nowrightBottomPosition = [];
	            this.rightBottom.on('mousedown', function(e) {
	                startSlotPoints = util.getSoltPoints(node);
	                startPosition = zrUtil.clone(node.position);
	                rightBottomPosition = nodeRect.points[2];
	                startX = e.event.clientX;
	                startY = e.event.clientY;
	                rightScaleDrag(e);
	            });
	
	            function rightScaleDrag(e) {
	                var rightArrow = function(e) { rightArrowDrag(e); };
	
	                function rightArrowDrag(e) {
	                    //2个圆间距太小时,不在拖动
	                    if (that.rightBottom.position[0] - that.leftTop.position[0] < (widthMin + 10)) {
	                        if (that.rightBottom.position[1] - that.leftTop.position[1] < (heightMin + 10)) {
	                            that.rightBottom.position[0] = that.leftTop.position[0] + (widthMin + 10);
	                            that.rightBottom.position[1] = that.leftTop.position[1] + (heightMin + 10);
	                        } else {
	                            that.rightBottom.position[0] = that.leftTop.position[0] + widthMin;
	                            scaleRect(that.rightBottom, e);
	                        }
	                    } else {
	                        if (that.rightBottom.position[1] - that.leftTop.position[1] < (heightMin)) {
	                            that.rightBottom.position[1] = that.leftTop.position[1] + heightMin;
	                            scaleRect(that.rightBottom, e);
	                        } else {
	                            scaleRect(that.rightBottom, e);
	                        }
	                    }
	
	                    function scaleRect(dom, e) {
	                        var domPosition = [];
	                        for (var n = 0; n <= Math.abs(parseInt((e.event.clientX - startX) / pixel)); n++) {
	                            if (e.event.clientX - startX > 0) {
	                                nowrightBottomPosition[0] = rightBottomPosition[0] + pixel * (n);
	                                domPosition[0] = nowrightBottomPosition[0];
	                            } else {
	                                if (!nowrightBottomPosition[0]) {
	                                    nowrightBottomPosition[0] = rightBottomPosition[0];
	                                }
	                                if (nowrightBottomPosition[0] - nodeRect.points[0][0] > widthMin) {
	                                    nowrightBottomPosition[0] = rightBottomPosition[0] - pixel * (n);
	                                    domPosition[0] = nowrightBottomPosition[0];
	                                } else {
	                                    domPosition[0] = that.leftTop.position[0] + widthMin;
	                                }
	                            }
	                        }
	                        for (var m = 0; m <= Math.abs(parseInt((e.event.clientY - startY) / pixel)); m++) {
	                            if (e.event.clientY - startY > 0) {
	                                nowrightBottomPosition[1] = rightBottomPosition[1] + pixel * (m);
	                                domPosition[1] = nowrightBottomPosition[1];
	                            } else {
	                                if (!nowrightBottomPosition[1]) {
	                                    nowrightBottomPosition[1] = rightBottomPosition[1];
	                                }
	                                if (nowrightBottomPosition[1] - nodeRect.points[0][1] > heightMin) {
	                                    nowrightBottomPosition[1] = rightBottomPosition[1] - pixel * (m);
	                                    domPosition[1] = nowrightBottomPosition[1];
	
	                                } else {
	                                    domPosition[1] = that.leftTop.position[1] + heightMin;
	                                }
	                            }
	                        }
	                        dom.attr("position", domPosition);
	
	                        var points = [];
	                        points[0] = nodeRect.points[0];
	                        points[1] = [nowrightBottomPosition[0], nodeRect.points[1][1]];
	                        points[2] = [nowrightBottomPosition[0], nowrightBottomPosition[1]];
	                        points[3] = [nodeRect.points[3][0], nowrightBottomPosition[1]];
	                        points[4] = nodeRect.points[0];
	                        var params = {};
	                        params.type = "OperationNode:scaleDragRight";
	                        params.points = points;
	                        that.trigger(params.type, params);
	                    }
	                }
	                that.zr.on('mousemove', rightArrow);
	                var rightEnd = function(e) { rightDragEnd(e) };
	
	                function rightDragEnd(e) {
	                    that.zr.off('mousemove', rightArrow);
	                    that.zr.off("mouseup", rightEnd);
	                    var params = {};
	                    params.event = e;
	                    params.arrowName = "right";
	                    params.type = "OperationNode:scaleDragEnd";
	                    params.startSlotPoints = startSlotPoints;
	                    params.startPosition = startPosition;
	                    that.trigger(params.type, params);
	                }
	                that.zr.on("mouseup", rightEnd);
	            }
	            this.leftTop.attr("position", [nodeRect.points[0][0] - 10, nodeRect.points[0][1] - 10]);
	            this.rightBottom.attr("position", [nodeRect.points[2][0], nodeRect.points[2][1]]);
	        }
	
	        // 计算整个的位置
	        if (node.parent) {
	            if (Bpmn.isSubProcess(node.parent)) { //if(node.parent.model.get("stencil.type") == "SubProcess"){
	                this.attr("position", [nodeRect.x + node.parent.position[0], nodeRect.y + node.parent.position[1]])
	            }
	        } else {
	            this.attr("position", [nodeRect.x, nodeRect.y])
	        }
	
	    };
	
	    BpmnOperationNode.ARROW_DRAGEND = "OperationNode:dragendArrow";
	    BpmnOperationNode.ARROW_DRAG = "OperationNode:dragArrow";
	    BpmnOperationNode.ARROW_DRAGSTART = "OperationNode:dragstartArrow";
	    BpmnOperationNode.DELETE_CLICK = "OperationNode:deleteClick";
	
	    zrUtil.inherits(BpmnOperationNode, OperationNode);
	
	
	    module.exports = BpmnOperationNode;
	


/***/ },
/* 103 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * 选中节点后，出现的操作框及按钮
	 * @author wang.xiaohu
	 */
	
	    var Node = __webpack_require__(76);
	    var zrUtil = __webpack_require__(4);
	    var graphic = __webpack_require__(3);
	    var Connector = __webpack_require__(96);
	    var env = __webpack_require__(61);
	
	    function OperationNode(node, zr, forbidEdit) {
	        Node.call(this);
	        this.node = node;
	        this.zr = zr;
	        this.forbidEdit = forbidEdit; //
	        this.render();
	    }
	
	    //事件
	    OperationNode.ARROW_DRAGEND = "OperationNode:dragendArrow";
	    OperationNode.ARROW_DRAG = "OperationNode:dragArrow";
	    OperationNode.ARROW_DRAGSTART = "OperationNode:dragstartArrow";
	    OperationNode.DELETE_CLICK = "OperationNode:deleteClick";
	
	    if(!env.canvasSupported) {
	        //内置操作图标的图像
	        OperationNode.opicons = {
	            STRAIGHT: 'M13.961,2.309c-0.051-0.122-0.148-0.22-0.27-0.27L13.5,2h-5C8.224,2,8,2.224,8,2.5S8.224,3,8.5,3h3.793L2.146,13.146c-0.195,0.195-0.195,0.512,0,0.707s0.512,0.195,0.707,0L13,3.707V7.5C13,7.776,13.225,8,13.5,8S14,7.776,14,7.5v-5L13.961,2.309z',
	            JAGGED: 'M96.046,13.604H84.213c-1.104,0-2,0.896-2,2v42.188H38.314v-10.77c0-0.715-0.381-1.375-1-1.732c-0.619-0.357-1.382-0.355-2,0L2.954,63.977c-0.619,0.357-1,1.018-1,1.732s0.381,1.375,1,1.732l32.36,18.687c0.309,0.179,0.655,0.268,1,0.268s0.69-0.089,1-0.268c0.619-0.357,1-1.018,1-1.732V73.625h57.732c1.104,0,2-0.896,2-2V15.604C98.046,14.5,97.151,13.604,96.046,13.604z',
	            CURVE: 'M510.536,268.098c13.541,0,27.078-5.207,37.347-15.6c20.379-20.625,20.18-53.866-0.445-74.245L414.167,46.57c-9.905-9.786-23.325-15.244-37.215-15.154c-13.923,0.083-27.244,5.695-37.03,15.599l-129.912,131.48c-20.379,20.625-20.18,53.866,0.445,74.245c20.625,20.379,53.866,20.18,74.245-0.445l40.618-41.108c0.021,0.464,0.029,0.927,0.062,1.394c4.178,59.008,4.668,119.832,16.633,177.931c23.937,116.232,103.705,191.961,191.489,264.024c47.292,38.823,79.66,94.122,98.601,151.673c9.765,29.669,14.714,77.115,17.215,107.157c2.261,27.161,25.08,47.978,52.333,47.709l1.061-0.01c30.228-0.298,53.81-26.211,51.306-56.336c-2.921-35.15-8.858-89.828-20.925-127.49c-16.283-50.821-40.016-99.463-74.766-140.245c-33.993-39.892-75.456-72.403-113.338-108.373c-47.091-44.713-84.977-95.161-98.006-159.719c-10.541-52.231-12.789-105.215-16.461-158.562l43.118,42.604C483.87,263.053,497.205,268.098,510.536,268.098z',
	            DEL: 'M73.641,45.957l-0.021,0.252c0,0.032,0.021,0.06,0.021,0.088c0,0.065-0.022,0.126-0.026,0.191l-2.685,54.878H70.91c-0.231,4.304-5.166,10.81-31.748,10.81c-26.58,0-31.509-6.506-31.746-10.81H7.41L4.731,46.488c-0.009-0.06-0.028-0.126-0.028-0.191c0-0.032,0.01-0.06,0.01-0.088l-0.01-0.252h0.028c0.099-0.466,0.364-0.919,0.784-1.353c3.439,3.477,17.191,4.051,33.646,4.051s30.221-0.574,33.642-4.051c0.426,0.434,0.711,0.887,0.784,1.353H73.641z M78.335,25.102v6.407c0,1.316-1.34,2.567-3.715,3.696c-6.266,2.936-19.777,4.975-35.459,4.975c-15.666,0-29.189-2.039-35.442-4.975C1.33,34.075,0,32.825,0,31.509v-6.407c0-3.374,8.681-6.286,21.359-7.724V3.929c0-2.16,1.768-3.929,3.93-3.929h26.314c2.164,0,3.938,1.773,3.938,3.938v13.296C68.98,18.606,78.333,21.611,78.335,25.102z M48.416,11.395c0-2.348-0.321-4.27-0.715-4.27c-0.393,0-2.641,0-4.979,0h-8.545c-2.352,0-4.592,0-4.989,0c-0.388,0-0.714,1.922-0.714,4.27v5.367l1.083-0.065c3.067-0.173,6.286-0.27,9.595-0.271c3.202,0,6.292,0.098,9.264,0.252V11.395z'
	        };
	    }else{
	        OperationNode.opicons = {
	            STRAIGHT: 'data:image/png;base64,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',
	            JAGGED: 'data:image/png;base64,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',
	            CURVE: 'data:image/png;base64,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',
	            DEL: 'M73.641,45.957l-0.021,0.252c0,0.032,0.021,0.06,0.021,0.088c0,0.065-0.022,0.126-0.026,0.191l-2.685,54.878H70.91c-0.231,4.304-5.166,10.81-31.748,10.81c-26.58,0-31.509-6.506-31.746-10.81H7.41L4.731,46.488c-0.009-0.06-0.028-0.126-0.028-0.191c0-0.032,0.01-0.06,0.01-0.088l-0.01-0.252h0.028c0.099-0.466,0.364-0.919,0.784-1.353c3.439,3.477,17.191,4.051,33.646,4.051s30.221-0.574,33.642-4.051c0.426,0.434,0.711,0.887,0.784,1.353H73.641z M78.335,25.102v6.407c0,1.316-1.34,2.567-3.715,3.696c-6.266,2.936-19.777,4.975-35.459,4.975c-15.666,0-29.189-2.039-35.442-4.975C1.33,34.075,0,32.825,0,31.509v-6.407c0-3.374,8.681-6.286,21.359-7.724V3.929c0-2.16,1.768-3.929,3.93-3.929h26.314c2.164,0,3.938,1.773,3.938,3.938v13.296C68.98,18.606,78.333,21.611,78.335,25.102z M48.416,11.395c0-2.348-0.321-4.27-0.715-4.27c-0.393,0-2.641,0-4.979,0h-8.545c-2.352,0-4.592,0-4.989,0c-0.388,0-0.714,1.922-0.714,4.27v5.367l1.083-0.065c3.067-0.173,6.286-0.27,9.595-0.271c3.202,0,6.292,0.098,9.264,0.252V11.395z'
	        };
	    }
	
	
	
	
	    OperationNode.prototype.render = function() {
	        this.renderBase();
	        if (!this.forbidEdit) {
	            this.renderOther();
	        }
	
	    };
	
	    OperationNode.prototype.renderBase = function() {
	        this.createOperation();
	    };
	
	    OperationNode.prototype.createOperation = function() {
	        var me = this;
	        this.virtualRect = new graphic.Polyline({ style: { lineDash: [2] } });
	        this.virtualRect.isSelfComputePos = true;  // 自己计算位置
	        this.add(this.virtualRect);
	
	
	
	        if (this.node.operationIcons) {
	            zrUtil.each(this.node.operationIcons, function(item) {
	                //检查是否是内置图标
	                var opIconInstance = null;
	                if (OperationNode.opicons[item.name + ""]) {
	
	                    if (this.forbidEdit) {
	                        return;
	                    }
	                    if (item.name == "DEL") {
	                        //垃圾桶
	                        var rect1 = { x: 0, y: 0, width: 10, height: 15 };
	                        opIconInstance = graphic.makePath(OperationNode.opicons[item.name + ""], { style: { fill: '#000000' } }, rect1);
	                        if(item.callback){
	                            opIconInstance.on("click", function(e) {
	                                e.data = item;
	                                e.node = me.node;  // 将所附的节点也传递出去
	                                if (item.callback) {
	                                    item.callback(e);
	                                }
	                            });
	                        }else{
	                            opIconInstance.on("click", function(e) {
	                                var params = {};
	                                params.event = e;
	                                params.target = this;
	                                params.type = OperationNode.DELETE_CLICK;
	                                me.trigger(params.type, params);
	                            });
	                        }
	
	
	                    } else {
	                        if(!env.canvasSupported){
	                            var rect = { x: 0, y: 0, width: 15, height: 15 };
	                            opIconInstance = graphic.makePath(OperationNode.opicons[item.name + ""], { style: { fill: '#000000' },draggable:true,z:19,lineType: Connector["TYPE_" + item.name] }, rect);
	                        }else{
	                            var imageUrl = document.createElement('img');
	                            imageUrl.src = OperationNode.opicons[item.name + ""];
	                            opIconInstance = new graphic.Image({
	                                style: {
	                                    image:imageUrl,
	                                    cursor: 'default',
	                                    width:15,
	                                    height:15
	                                },
	                                draggable: true,
	                                z: 19, //zIndex 置于最高
	                                lineType: Connector["TYPE_" + item.name] //区分不同的线段
	                            });
	                        }
	
	                        var MOUSE_EVENT_NAMES = ['dragstart', 'drag', 'dragend'];
	                        zrUtil.each(MOUSE_EVENT_NAMES, function(eveName) {
	                            opIconInstance.on(eveName, function(e) {
	                                var params = {};
	                                params.event = e;
	                                params.type = "OperationNode:" + eveName + "Arrow";
	                                me.trigger(params.type, params);
	                            });
	                        });
	                    }
	
	                } else {
	                    //用户自定义的图标放在这里，用户传进来的图标只能响应click事件，其它事件暂不支持
	                    opIconInstance = new graphic.Image({
	                        style: {
	                            image: item.iconPath,
	                            width: item.width || 15,
	                            height: item.height || 15
	                        },
	                        z: 19 //zIndex 置于最高
	                    });
	                    opIconInstance.on("click", function(e) {
	                        e.data = item;
	                        e.node = me.node;  // 将所附的节点也传递出去
	                        if (item.callback) {
	                            item.callback(e);
	                        }
	
	                        //todo 用户自定图标click事件是否要派发到外面
	                    });
	                }
	                opIconInstance.name = item.name;
	                me.add(opIconInstance);
	            });
	        }
	    };
	
	    OperationNode.prototype.refreshPostion = function(node,nodeRect) {
	        var me = this;
	        var i = 0;
	        var rbPoint = nodeRect.points[2]; //取右下角坐标
	        //1.定位虚框
	        this.virtualRect.setShape({ points: nodeRect.points });
	        //2.定位每个小图标
	        this.eachChild(function(nodeItem) {
	            if (!nodeItem.isSelfComputePos) {
	                // 8px是第一个操作按钮图标的距离 靠太近不好看    20px是每个图标的间隔  10px是图标向偏的距离
	                nodeItem.attr("position", [rbPoint[0] + 8 + (i++ * 20), rbPoint[1] - 10]);
	            }
	        });
	
	        this.refreshPositionOther(node,nodeRect);
	    };
	
	    OperationNode.prototype.renderOther = function() {
	        //留给扩展使用
	    };
	    OperationNode.prototype.refreshPositionOther = function(node,nodeRect) {
	        //留给扩展使用
	        //3.定位整个operationNode
	        if (node.parent && node.parent.isBg && node.parent.isBg == true) {
	            this.attr("position", [nodeRect.x, nodeRect.y])
	        } else {
	            this.attr("position", [nodeRect.x + node.parent.position[0]+node.shape.x, nodeRect.y + node.parent.position[1]+node.shape.y])
	        }
	    };
	    zrUtil.inherits(OperationNode, Node);
	    module.exports = OperationNode;
	


/***/ },
/* 104 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * bpmn连线管理类
	 * @author wang.xiaohu
	 */
	
		var zrUtil = __webpack_require__(4);
		var ConnectionManager = __webpack_require__(105);
		var BPMNModel = __webpack_require__(78);
		var Connector = __webpack_require__(96);
	    var Point = __webpack_require__(59);
		var connectionManagerExtend = {
	        /**
	         * 创建连线
	         * @param  {[type]} startNode [开始节点]
	         * @param  {[type]} endNode   [结束节点]
	         * @param  {[type]} type      [类型]
	         * @param {[type]} [api] [description]
	         * @return {[type]}           [返回连线]
	         */
	        connectorCreate:function(startNode,endNode,type, api){
	            var model = new BPMNModel({});
	            model.set("style.lineType", type);
	            model.set("stencil.type", this.stencilType);
	
	            return this.connectorCreateByOptions(startNode,endNode,{model:model, isEdit: true, style: {lineType:type}}, api);
	        },
	
	
	        /**
	         * 根据opetions.model 反序列化线
	         * @param  {[type]} startNode [description]
	         * @param  {[type]} endNode   [description]
	         * @param  {[type]} options   [description]
	         * @param  {[type]} api       [description]
	         * @return {[type]}           [description]
	         */
	        connectorCreateByOptions:function(startNode,endNode,options, api){
	            var that = this;
	            var model = options.model;
	            var connector = new Connector(options);
	            connector.startNode = startNode;
	            connector.endNode = endNode;
	
	            this.connectors.push(connector);
	
	            //判断一下sPos,ePos
	            connector.sPos = model.get("style.sPos");
	            connector.ePos = model.get("style.ePos");
	
	            //判断一下 model里有没有dockers，如果有则调用构造point数组  或者调用refreshConnector计算如何画线
	            var dockers = model.get("dockers");
	            if (dockers && dockers.length >= 2) {
	                var points = Point.loadArray(dockers);
	                connector.refresh(points);
	            } else {
	                this.refreshConnector(connector,true);
	            }
	
	            connector.conPointsGroup.on("click", function(e) {
	                var arrSplit = e.target.type.split(Connector.SEPERATOR);
	                var connector = e.target.connector;
	                if (arrSplit[0] === Connector.START_NODE) {
	                    connector.sPos = arrSplit[1];
	                } else if (arrSplit[0] === Connector.END_NODE){
	                    connector.ePos = arrSplit[1];
	                }
	                that.refreshConnector(connector,true);
	
	                var params = {};
	                params.event = e;
	                params.type = "conPointsGroup:click";
	                params.lineNode = that.selConnector;
	                api.trigger(params.type, params);
	            });
	
	
	            var MOUSE_EVENT_NAMES = ['dblclick', 'click'];
	            zrUtil.each(MOUSE_EVENT_NAMES, function (eveName) {
	                connector.on("Connector:" + eveName, function(e) {
	                    var selected = e.target;
	
	                    if ( that.selConnector !== selected) {
	                        that.selConnector &&  that.refreshConnector(that.selConnector);
	                        that.selConnector = selected;
	                    }
	
	                    var params = {};
	                    params.event = e;
	                    params.type = eveName;
	                    params.target = that.selConnector;
	                    api.trigger(params.type, params);
	                });
	            });
	
	            //1.设置起始节点的outgoing数组 为线段的ID
	            var startNodeOutgoing = startNode.model.get("outgoing");
	            startNodeOutgoing.push(connector.resourceId);
	            //2.设置线段的outgoing数组 为结束节点的ID
	            var connectorOutgoing = connector.model.get("outgoing");
	            connectorOutgoing.push(endNode.resourceId);
	
	            return connector;
	        },
	
	        /**
	         * 设置线段的模型数据  (类型 文字)
	         * @param {[type]} connector [description]
	         * @param {[type]} option    [description]
	         */
	        setModel: function(connector, option) {
	            var originLineType =  connector.model.get("style.lineType");
	            var originName = connector.options.text.text;
	            connector.options.text.text =  option.properties.name;
	            connector.model.mergeOption(option);
	            //文字不一致时
	            if (originName != option.properties.name) {
	                this.refreshConnector(connector, true);
	            }
	        },
	        /**
	         * 刷新连接线
	         * @param  {[type]} node [description]
	         * @return {[type]}      [description]
	         */
	        refreshLineByNode: function(node) {
	            for(var i = 0, len = this.connectors.length; i < len; i++){
	                if(this.connectors[i].startNode == node || this.connectors[i].endNode == node){
	                    this.refreshConnector(this.connectors[i], true);
	                }
	            }
	        }
		};
	
		var BpmnConnectionManager = zrUtil.extend(ConnectionManager, connectionManagerExtend);
		module.exports = BpmnConnectionManager;
	


/***/ },
/* 105 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * 连线管理类
	 * @author wang.xiaohu
	 */
	
	    var Node = __webpack_require__(76);
	    var Util = __webpack_require__(73);
	    var graphic = __webpack_require__(3);
	    var Point = __webpack_require__(59);
	    var Connector = __webpack_require__(96);
	    var Log = __webpack_require__(106);
	    var zrUtil = __webpack_require__(4);
	    var ConnectionManager = {
	
	        CLOUD_RADIUS: 12,
	        CLOUD_LINEWIDTH: 3,
	        CLOUD_STROKE_STYLE: "rgba(255, 153, 0, 0.8)", //orange
	        stencilType : "SequenceFlow",
	        connectors: [],
	        selConnector: null,
	        tempConnector: null,
	
	
	
	        /**
	         * 设置线的不可编辑
	         * @param  {[type]} forbidEdit [description]
	         * @return {[type]}            [description]
	         */
	        connectorForbidEdit:function(forbidEdit){
	            var that = this;
	            for(var i = 0;i < this.connectors.length;i++){
	                this.connectors[i].options.isEdit = !forbidEdit;
	            }
	        },
	
	
	        /**
	         * 清空连接线
	         * @return {[type]} [description]
	         */
	        clearSelectCon: function() {
	            if (ConnectionManager.selConnector != null) {
	                this.refreshConnector(this.selConnector);
	            }
	        },
	        /**
	         * 删除连接线
	         * @return {[type]} [description]
	         */
	        deleteSelectCon:function(node,_zr){
	            var deleteLine= [];
	            for(var i = 0; i < this.connectors.length; i++){
	                if(this.connectors[i].startNode == node || this.connectors[i].endNode == node){
	                    //1.将线 所联的startNode的outgoing数据删除
	                    var startNodeOutgoing = this.connectors[i].startNode.model.get("outgoing");
	                    index = zrUtil.indexOf(startNodeOutgoing, this.connectors[i].resourceId);
	                    if(index != -1) {
	                        startNodeOutgoing.splice(index,1);
	                    }
	                    //2.从_zr上删除
	                    _zr.remove(this.connectors[i]);
	                    this.connectors.splice(i, 1);
	                    i--;
	                    this.selConnector = null;
	
	                }
	            }
	        },
	        /**
	         * 删除选定的线
	         * @return {[type]} [description]
	         */
	        deleteLine:function(_zr){
	            //1.将线 所联的startNode的outgoing数据删除
	            var startNodeOutgoing = this.selConnector.startNode.model.get("outgoing");
	            index = zrUtil.indexOf(startNodeOutgoing, this.selConnector.resourceId);
	            if(index != -1) {
	                startNodeOutgoing.splice(index,1);
	            }
	
	            if (this.connectorMap) {
	                var key = this.getTwoNodeId(this.selConnector.startNode, this.selConnector.endNode);
	                this.connectorMap.removeItem(key, this.selConnector);
	            }
	
	            //2.从_zr上删除
	            _zr.remove(this.selConnector);
	
	
	            //3.从线数据中删除
	            var index = zrUtil.indexOf(this.connectors, this.selConnector);
	            if(index != -1) {
	                this.connectors.splice(index,1);
	            }
	            this.selConnector = null;
	        },
	        /**
	         * 重新画线
	         * @param  {[type]} connector          [description]
	         * @param  {[type]} force
	         * @return {[type]}                    [description]
	         */
	        refreshConnector: function (connector, force) {
	            // 只有需要强制刷新  或者 连线为空（<2)时 才进行重新计算重绘
	            if( force || (!connector.turningPoints) || (connector.turningPoints.length < 2))
	            {
	                if (connector.model && connector.model.get("style.lineType")) { connector.options.style.lineType = connector.model.get("style.lineType");}
	                var arrStartEndPoint = this.getStartEndPoint(connector);
	                var escapeDistance = null;
	                if(connector.options.position&&connector.options.position.escapeDistance){
	                    escapeDistance = connector.options.position.escapeDistance;
	                }
	                var solutions = this.connector2Points(connector.options.style.lineType, arrStartEndPoint[0], arrStartEndPoint[1],
	                    arrStartEndPoint[2], arrStartEndPoint[3],escapeDistance);  // TYPE_STRAIGHT TYPE_JAGGED
	
	
	                connector.refresh(solutions[0][2]);
	            }
	
	            connector.clearHandles();  //清空handle
	        },
	
	
	        getStartEndPoint: function(connector) {
	            var startNode = connector.startNode;
	            var endNode = connector.endNode;
	
	            var sRect = startNode.getRect? startNode.getRect().boundingRect : Util.getRect(startNode).boundingRect;
	            var sBounds = [Number(sRect.x), Number(sRect.y), Number(sRect.x) + Number(sRect.width), Number(sRect.y) + Number(sRect.height)];
	
	            var eRect = startNode.getRect? endNode.getRect().boundingRect : Util.getRect(endNode).boundingRect;
	            var eBounds = [Number(eRect.x), Number(eRect.y), Number(eRect.x) + Number(eRect.width), Number(eRect.y) + Number(eRect.height)];
	
	
	            var sConnectorPoint = Util.getConnectorPoints(sRect);
	            var eConnectorPoint = Util.getConnectorPoints(eRect);
	
	            //判断如果没有指定位置的话, 判断开始节点在结束结果左边则采用 right-left 否则采用left-right
	            if (!connector.sPos || !connector.ePos) {
	                if (sRect.x < eRect.x) {
	                    connector.sPos = "right";
	                    connector.ePos = "left";
	                } else {
	                    connector.sPos = "left";
	                    connector.ePos = "right";
	                }
	            }
	            var startPoint =  this.calcPointExpression(connector.sPos, sConnectorPoint);
	            var endPoint =  this.calcPointExpression(connector.ePos, eConnectorPoint);
	            return [startPoint, endPoint,sBounds, eBounds];
	        },
	
	        calcPointExpression: function(pos, point) {
	            var variable = {top:point.top.x,
	                left: point.left.y,
	                right:point.right.y,
	                bottom:point.bottom.x,
	                center:point.center.x
	            };
	
	            var expression =  "<% print(" + pos + ") %>";
	            var val = parseInt(Util.template(expression)(variable));
	            if (pos.indexOf("top")!= -1) {
	                return new Point(val, point.top.y);
	            } else if (pos.indexOf("left")!= -1) {
	                return new Point(point.left.x, val);
	            } else if (pos.indexOf("right")!= -1) {
	                return new Point(point.right.x, val);
	            } else if (pos.indexOf("bottom")!= -1) {
	                return new Point(val, point.bottom.y);
	            } else if (pos.indexOf("center")!= -1) {
	                return new Point(val, point.bottom.y);
	            }else {
	                throw new Error("pos参数错误");
	            }
	        },
	
	        /**
	         * 创建或修改临时线
	         * @param  {[type]} startNode             [description]
	         * @param  {[type]} rEndPoint             [description]
	         * @param  {[type]} lineType [description]
	         * @return {[type]}                       [description]
	         */
	        manageTempConnector: function(startNode, rEndPoint, lineType) {
	
	            var sRect = startNode.getRect? startNode.getRect().boundingRect : Util.getRect(startNode).boundingRect;
	
	            var sBounds = [sRect.x, sRect.y, sRect.x + sRect.width, sRect.y + sRect.height];
	            var sConnectorPoint = Util.getConnectorPoints(sRect);
	
	            if (!ConnectionManager.tempConnector) {
	                ConnectionManager.tempConnector = new Connector({isEdit: false, style: {lineType:lineType}});
	            }
	
	            var connector =  ConnectionManager.tempConnector;
	            //判断如果没有指定位置的话, 判断开始节点在结束结果左边则采用 right-left 否则采用left-right
	            if (sRect.x < rEndPoint.x) {
	                connector.sPos = "right";
	                connector.ePos = "left";
	            } else {
	                connector.sPos = "left";
	                connector.ePos = "right";
	            }
	
	            connector.options.style.lineType = lineType;
	            var solutions = this.connector2Points(lineType, sConnectorPoint[connector.sPos], rEndPoint,
	                sBounds, null);  // TYPE_STRAIGHT TYPE_JAGGED
	
	            connector.refresh(solutions[0][2]);
	            return connector;
	        },
	
	        /**
	         * 删除临时线
	         * @param  {[type]} zr             [description]
	         */
	        removeTempConnector: function(zr) {
	            if (ConnectionManager.tempConnector) {
	                zr.remove(ConnectionManager.tempConnector);
	                ConnectionManager.tempConnector = null;
	            }
	        },
	
	
	        /**
	         * 算出 两个节点 指定两个点如何联线
	         * @param  {[type]} type       [description]
	         * @param  {[type]} startPoint [description]
	         * @param  {[type]} endPoint   [description]
	         * @param  {[type]} sBounds    [description]
	         * @param  {[type]} eBounds    [description]
	         * @return {[type]}            [description]
	         */
	        connector2Points: function(type,  startPoint, endPoint, sBounds, eBounds ,escapeDistance){
	            var  figureEscapeDistance = [30, 30];
	            if (escapeDistance) {
	                if (!zrUtil.isArray(escapeDistance)) {
	                    figureEscapeDistance = [escapeDistance, escapeDistance];
	                } else {
	                    figureEscapeDistance = escapeDistance;
	                }
	            }
	
	            Log.group("connectionManager: connector2Points");
	
	
	            Log.info("ConnectionManager: connector2Points (" + type + ", " + startPoint + ", " + endPoint + ", " + sBounds + ", " + eBounds + ')');
	            var solutions = [];
	
	
	
	            switch(type){
	                case Connector.TYPE_STRAIGHT:  //直线
	                    var points = [startPoint.clone(), endPoint.clone()];
	                    solutions.push( ['straight', 'straight', points] );
	                    break;
	
	                case Connector.TYPE_CURVE:  //曲线
	
	                case Connector.TYPE_JAGGED:    //折线
	                    var startExitPoint = null;
	                    var endExitPoint = null;
	
	                    //find start exit point  寻找开始出口
	                    if(sBounds != null){
	                        var potentialExits = [];
	
	                        potentialExits.push(new Point(startPoint.x, sBounds[1] - figureEscapeDistance[0])); //north 北
	                        potentialExits.push(new Point(sBounds[2] + figureEscapeDistance[0], startPoint.y)); //east  东
	                        potentialExits.push(new Point(startPoint.x, sBounds[3] + figureEscapeDistance[0])); //south  南
	                        potentialExits.push(new Point(sBounds[0] - figureEscapeDistance[0], startPoint.y)); //west  西
	
	                        //pick closest exit point  寻找与 startPoint 最靠近的出口点
	                        startExitPoint = potentialExits[0];
	                        for(var i=1; i < potentialExits.length; i++){
	                            if(Util.distance(startPoint, potentialExits[i]) < Util.distance(startPoint, startExitPoint)){
	                                startExitPoint = potentialExits[i];
	                            }
	                        }
	                    }
	
	
	                    //find end exit point  寻找结束出口
	                    if(eBounds != null){
	                        var potentialExits = [];
	
	                        potentialExits.push(new Point(endPoint.x, eBounds[1] - figureEscapeDistance[1])); //north
	                        potentialExits.push(new Point(eBounds[2] + figureEscapeDistance[1], endPoint.y)); //east
	                        potentialExits.push(new Point(endPoint.x, eBounds[3] + figureEscapeDistance[1])); //south
	                        potentialExits.push(new Point(eBounds[0] - figureEscapeDistance[1], endPoint.y)); //west
	
	                        //pick closest exit point  寻找与 endPoint 最靠近的出口点
	                        endExitPoint = potentialExits[0];
	                        for(var i=1; i < potentialExits.length; i++){
	                            if(Util.distance(endPoint, potentialExits[i]) < Util.distance(endPoint, endExitPoint)){
	                                endExitPoint = potentialExits[i];
	                            }
	                        }
	                    }
	
	                    //Basic solution 最基本的解决方案   为其他解决方案做准备
	                    var s = [startPoint];
	                    var gapIndex = 0; //the index of the gap (where do we need to insert new points) DO NOT CHANGE IT
	                    if(startExitPoint){
	                        s.push(startExitPoint);
	                        gapIndex = 1;
	                    }
	                    if(endExitPoint){
	                        s.push(endExitPoint);
	                    }
	                    s.push(endPoint);
	
	
	
	                    //SO - no additional points     S0 解决方案 不添加任何点  基本不会被采用
	                    var s0 = Point.cloneArray(s);
	                    solutions.push(['s0', 's0', s0]);
	
	
	
	                    //S1   S1 解决方案  只有一个折点
	                    var s1 = Point.cloneArray(s);
	
	                    //first variant   第一个变体 s1 s1_1方案  折线点在 startExitPoint的X 与 endExitPoint的 Y位置
	                    var s1_1 = Point.cloneArray(s1);
	                    s1_1.splice(gapIndex + 1, 0, new Point(s1_1[gapIndex].x , s1_1[gapIndex+1].y) );
	                    solutions.push(['s1', 's1_1', s1_1]);
	
	                    //second variant  第二变体 s1 s1-2方案  折线点在 endExitPoint的X 与  startExitPoint的Y位置
	                    var s1_2 = Point.cloneArray(s1);
	                    s1_2.splice(gapIndex + 1, 0, new Point(s1_2[gapIndex+1].x , s1_2[gapIndex].y) );
	                    solutions.push(['s1', 's1_2', s1_2]);
	
	
	                    //S2  S2 解决方案  添加两个折点
	
	                    //Variant I   s2_1方案
	                    var s2_1 = Point.cloneArray(s);
	                    var s2_1_1 = new Point( (s2_1[gapIndex].x + s2_1[gapIndex+1].x) / 2,  s2_1[gapIndex].y);
	                    var s2_1_2 = new Point( (s2_1[gapIndex].x + s2_1[gapIndex+1].x) / 2,  s2_1[gapIndex+1].y);
	                    s2_1.splice(gapIndex + 1, 0, s2_1_1, s2_1_2);
	                    solutions.push(['s2', 's2_1', s2_1]);
	
	
	                    //Variant II  s2_1方案  1折线点 x: startExitPoint的X 位置 y: startExitPoint的y+endExitPoint的y/2
	                    //1折线点 x:endExitPoint的x  y:startExitPoint的y+endExitPoint的y/2
	                    var s2_2 = Point.cloneArray(s);
	                    var s2_2_1 = new Point( s2_2[gapIndex].x, (s2_2[gapIndex].y + s2_2[gapIndex+1].y)/2 );
	                    var s2_2_2 = new Point( s2_2[gapIndex+1].x, (s2_2[gapIndex].y + s2_2[gapIndex+1].y)/2);
	                    s2_2.splice(gapIndex + 1, 0, s2_2_1, s2_2_2);
	                    solutions.push(['s2', 's2_2', s2_2]);
	
	
	                    //Variant III
	                    var s2_3 = Point.cloneArray(s);
	                    //find the amount (stored in delta) of pixels we need to move right so no intersection with a figure will be present
	                    //!See:  /documents/specs/connected_figures_deltas.jpg file
	
	                    var eastExits = [s2_3[gapIndex].x + 20, s2_3[gapIndex+1].x + 20]; //add points X coordinates to be able to generate Variant III even in the absence of figures :p
	
	                    if(sBounds){
	                        eastExits.push(sBounds[2] + 20);
	                    }
	
	                    if(eBounds){
	                        eastExits.push(eBounds[2] + 20);
	                    }
	
	                    var eastExit = Util.max(eastExits);
	                    var s2_3_1 = new Point( eastExit, s2_3[gapIndex].y );
	                    var s2_3_2 = new Point( eastExit, s2_3[gapIndex+1].y );
	                    s2_3.splice(gapIndex + 1, 0, s2_3_1, s2_3_2);
	                    solutions.push(['s2', 's2_3', s2_3]);
	
	
	                    //Variant IV  s2_4方案
	                    var s2_4 = Point.cloneArray(s);
	                    //find the amount (stored in delta) of pixels we need to move up so no intersection with a figure will be present
	                    //!See:  /documents/specs/connected_figures_deltas.jpg file
	
	                    var northExits = [s2_4[gapIndex].y - 20, s2_4[gapIndex+1].y - 20]; //add points y coordinates to be able to generate Variant III even in the absence of figures :p
	
	                    if(sBounds){
	                        northExits.push(sBounds[1] - 20);
	                    }
	
	                    if(eBounds){
	                        northExits.push(eBounds[1] - 20);
	                    }
	
	                    var northExit = Util.min(northExits);
	                    var s2_4_1 = new Point( s2_4[gapIndex].x, northExit);
	                    var s2_4_2 = new Point( s2_4[gapIndex+1].x, northExit);
	                    s2_4.splice(gapIndex + 1, 0, s2_4_1, s2_4_2);
	                    solutions.push(['s2', 's2_4', s2_4]);
	
	
	                    //Variant V
	                    var s2_5 = Point.cloneArray(s);
	                    //find the amount (stored in delta) of pixels we need to move left so no intersection with a figure will be present
	                    //!See:  /documents/specs/connected_figures_deltas.jpg file
	
	                    var westExits = [s2_5[gapIndex].x - 20, s2_5[gapIndex+1].x - 20]; //add points x coordinates to be able to generate Variant III even in the absence of figures :p
	
	                    if(sBounds){
	                        westExits.push(sBounds[0] - 20);
	                    }
	
	                    if(eBounds){
	                        westExits.push(eBounds[0] - 20);
	                    }
	
	                    var westExit = Util.min(westExits);
	                    var s2_5_1 = new Point( westExit, s2_5[gapIndex].y);
	                    var s2_5_2 = new Point( westExit, s2_5[gapIndex+1].y);
	                    s2_5.splice(gapIndex + 1, 0, s2_5_1, s2_5_2);
	                    solutions.push(['s2', 's2_5', s2_5]);
	
	
	                    //Variant VI
	                    var s2_6 = Point.cloneArray(s);
	                    //find the amount (stored in delta) of pixels we need to move down so no intersection with a figure will be present
	                    //!See:  /documents/specs/connected_figures_deltas.jpg file
	
	                    var southExits = [s2_6[gapIndex].y + 20, s2_6[gapIndex+1].y + 20]; //add points y coordinates to be able to generate Variant III even in the absence of figures :p
	
	                    if(sBounds){
	                        southExits.push(sBounds[3] + 20);
	                    }
	
	                    if(eBounds){
	                        southExits.push(eBounds[3] + 20);
	                    }
	
	                    var southExit = Util.max(southExits);
	                    var s2_6_1 = new Point( s2_6[gapIndex].x, southExit);
	                    var s2_6_2 = new Point( s2_6[gapIndex+1].x, southExit);
	                    s2_6.splice(gapIndex + 1, 0, s2_6_1, s2_6_2);
	                    solutions.push(['s2', 's2_6', s2_6]);
	
	
	
	                    //FILTER solutions
	
	                    /*Algorithm
	                     * 0. solutions are ordered from minimmun nr of points to maximum >:)
	                     * 1. remove all solutions that are not orthogonal (mainly s0 solution)
	                     * 2. remove all solutions that go backward (we will not need them ever)
	                     * 3. remove all solutions with intersections
	                     * 4. pick first class of solutions with same nr of points (ex: 2)
	                     * 5. pick the first solution with 90 degree angles (less turnarounds)
	                     * (not interesteted) sort by length :p
	                     */
	
	                    //1. filter non ortogonal solutions 删除不是正交直线的方案
	                    if(true){
	                        Log.info("Filter orthogonal solutions. Initial number of solutions = " + solutions.length);
	                        var orthogonalSolution = [];
	                        for(var l=0; l<solutions.length; l++){
	                            var solution = solutions[l][2];
	                            if(Util.orthogonalPath(solution)){
	                                orthogonalSolution.push(solutions[l]);
	                            }
	                        }
	                        solutions = orthogonalSolution;
	                        Log.info("\n\tOrthogonalSolutions = " + solutions.length);
	                    }
	
	                    //2. filter backward solutions  过滤 倒退的方案
	                    if(true){
	                        //do not allow start and end points to coincide - ignore them
	                        if(startPoint.equals(endPoint)){
	                            Log.info("Start and end point coincide...skip backward solution. I think we will just fall on s0 :)");
	                        }
	                        else{
	                            Log.info("Filter backward solutions. Initial number of solutions = " + solutions.length);
	                            var forwardSolutions = [];
	                            var temp = '';
	                            for(var l=0; l<solutions.length; l++){
	                                var solution = solutions[l][2];
	                                if(Util.forwardPath(solution)){
	                                    forwardSolutions.push(solutions[l]);
	                                }
	                                else{
	                                    temp = temp +  "\n\t" + solution;
	                                }
	                            }
	                            solutions = forwardSolutions;
	                            Log.info("\n\t ForwardSolutions = " + solutions.length);
	                            if(solutions.length == 0){
	                                Log.info("Discarded solutions: " + temp);
	                            }
	                        }
	                    }
	
	
	                    //3. Filter non intersecting solutions  去除没有交集()的方案
	                    if(true){
	                        Log.info("Filter non intersecting solutions. Initial number of solutions = " + solutions.length);
	                        var nonIntersectionSolutions = []
	                        for(var l=0; l<solutions.length; l++){
	                            var solution = solutions[l][2];
	                            //Log.info("Solution id= " + solutions[l][1] + ' nr points = ' + solution.length + ", points = " + solution);
	                            var intersect = false;
	
	                            var innerLines = solution.slice(); //just a shallow copy
	
	                            /*If any bounds just trim the solution. So we avoid the strange case when a connection
	                             *startes from a point on a figure and ends inside of the same figure, but not on a connection point*/
	                            if(eBounds || sBounds){
	                                //i0nnerLines = innerLines.slice(0, innerLines.length - 1);
	                                innerLines = innerLines.slice(1, innerLines.length - 1);
	                                //Log.info("\t eBounds present,innerLines nr. points = " + innerLines.length + ", points = " + innerLines);
	                            }
	
	
	
	                            //now test for intersection
	                            if(sBounds){
	                                intersect = intersect || Util.polylineIntersectsRectangle(innerLines, sBounds);
	                            }
	                            if(eBounds){
	                                intersect = intersect || Util.polylineIntersectsRectangle(innerLines, eBounds);
	                            }
	
	                            if(!intersect){
	                                nonIntersectionSolutions.push(solutions[l]);
	                            }
	                        }
	
	                        //If all solutions intersect than this is destiny  :) and just ignore the intersection filter
	                        if(nonIntersectionSolutions.length != 0){
	                            //reasign to solutions
	                            solutions = nonIntersectionSolutions;
	                        }
	
	                        Log.info("\n\t nonIntersectionSolutions = " + solutions.length);
	                    }
	
	
	                    //4. get first class of solutions with same nr of points 选择与第一个方案点数一样多的方案（因为第一个方案点数最少）
	                    if(true){
	                        Log.info("Get first class of solutions with same nr of points");
	                        if(solutions.length == 0){
	                            Log.info("This is not possible");
	                        }
	
	                        var firstSolution = solutions[0][2]; //pick first solution
	                        var nrOfPoints = firstSolution.length;
	                        var sameNrPointsSolution = [];
	
	                        for(var l=0; l<solutions.length; l++){
	                            var solution = solutions[l][2];
	                            if(solution.length == nrOfPoints){
	                                sameNrPointsSolution.push(solutions[l]);
	                            }
	                        }
	
	                        solutions = sameNrPointsSolution;
	                    }
	
	
	
	
	                    /*5.  计算路径分数 ，取最分数高的
	                     Pick the first solution with 90 degree angles (less turnarounds)
	                     *in case we have more than one solution in our class
	                     */
	                    if(true){
	                        Log.info("pick the first solution with 90 degree angles (less turnarounds)");
	                        var solIndex = 0;
	                        for(var l=0; l<solutions.length; l++){
	                            var solution = solutions[l][2];
	                            if(Util.scorePath( solutions[solIndex][2] ) < Util.scorePath( solutions[l][2] ) ){
	                                solIndex = l;
	                            }
	                        }
	                        solutions = [solutions[solIndex]];
	                    }
	
	
	                    break;
	            }
	
	            //SMOOTHING curve
	            if(type === Connector.TYPE_CURVE){
	                this.smoothCurve(solutions);
	            }
	            //END SMOOTHING curve
	
	            Log.groupEnd();
	
	            return solutions;
	        },
	
	        smoothCurve: function(solutions){
	            var option = 3;
	
	            switch(option){
	                case 0:
	                    //do nothing
	                    break;
	
	                case 1: //add intermediate points
	                    //Add the middle point for start and end segment so that we "force" the
	                    //curve to both come "perpendicular" on bounds and also make the curve
	                    //"flee" more from bounds (on exit)
	                    for(var s=0; s<solutions.length; s++){
	                        var solTurningPoints = solutions[s][2];
	
	                        //first segment
	                        var a1 = solTurningPoints[0];
	                        var a2 = solTurningPoints[1];
	                        var startMiddlePoint = Util.getMiddle(a1, a2);
	                        solTurningPoints.splice(1,0, startMiddlePoint);
	
	                        //last segment
	                        var a3 = solTurningPoints[solTurningPoints.length - 2];
	                        var a4 = solTurningPoints[solTurningPoints.length - 1];
	                        var endMiddlePoint = Util.getMiddle(a3, a4);
	                        solTurningPoints.splice(solTurningPoints.length - 1, 0, endMiddlePoint);
	                    }
	                    break;
	
	                case 2: //remove points
	                    for(var s=0; s<solutions.length; s++){
	                        var solType= solutions[s][0];
	                        if(solType == 's1' || solType == 's2'){
	                            var solTurningPoints = solutions[s][2];
	                            solTurningPoints.splice(1,1);
	                            solTurningPoints.splice(solTurningPoints.length - 2, 1);
	                        }
	                    }
	                    break;
	
	                case 3:
	                    /*remove colinear point for s1 as it seems that more colinear points do not look good
	                     * on organic solutions >:D*/
	                    for(var s=0; s<solutions.length; s++){
	                        var solType= solutions[s][0];
	                        if(solType == 's1'){
	                            var solTurningPoints = solutions[s][2];
	                            var reducedSolution = Util.collinearReduction(solTurningPoints);
	                            solutions[s][2] = reducedSolution;
	                        }
	                    }
	                    break;
	            }//end switch
	
	        }
	    };
	    module.exports = ConnectionManager;
	


/***/ },
/* 106 */
/***/ function(module, exports) {

	/**
	 * 日志类
	 * @author wang.xiaohu
	 */
	
	
	    var Log  = {
	        LOG_LEVEL_NONE  : 0,
	
	        LOG_LEVEL_DEBUG : 1,
	
	        LOG_LEVEL_INFO : 2,
	
	        LOG_LEVEL_ERROR : 3,
	
	        level : this.LOG_LEVEL_ERROR,
	        
	        /**
	        * The less important of all messages
	        * @param {String} message - the message to be logged
	        **/
	        debug: function (message){
	            if(typeof console !== 'undefined'){
	                if(this.level <= this.LOG_LEVEL_DEBUG){
	                    
	                    //in FF is debug
	                    if(typeof console.debug == 'function'){
	                        console.debug(message);
	                    }
	                    else{//TODO: in IE is log
	    //                    console.info(message);
	                    }
	                }
	            }
	        },
	
	
	        /**
	        * The commonly used log message
	        * @param {String} message - the message to be logged
	        **/
	        info : function (message){
	            if(typeof console !== 'undefined'){
	                if(this.level <= this.LOG_LEVEL_INFO){
	                    console.info(message);
	                }
	            }
	        },
	
	        /**
	        * The worse kind of message. Usually a crash
	        * @param {String} message - the message to be logged
	        **/
	        error : function (message){
	            if(typeof console !== 'undefined'){
	                if(this.level <= this.LOG_LEVEL_ERROR){
	                    console.error(message);
	                }
	            }
	        },
	
	        /**
	         *Start grouping the log messages
	         *@param {String} title - the title of the group
	         *@see <a href="http://getfirebug.com/logging">http://getfirebug.com/logging</a>
	         **/
	        group : function(title){
	            if(this.level <= this.LOG_LEVEL_INFO){ //ignore group if level not debug or info
	                if(typeof console !== 'undefined'){           
	                    /**If we do not test for group() function you will get an error in Opera
	                     *as Opera has it's own console...which does not have a group() function*/
	                    if(typeof console.group === 'function'){
	                        console.group(title);
	                    }
	                }
	            }
	        },
	
	        /**Ends current message grouping*/
	        groupEnd : function(){
	            if(this.level <= this.LOG_LEVEL_INFO){ //ignore group if level not debug or info
	                if(typeof console !== 'undefined'){
	                    /**If we do not test for groupEnd() function you will get an error in Opera
	                     *as Opera has it's own console...which does not have a group() function*/
	                    if(typeof console.groupEnd === 'function'){
	                        console.groupEnd();
	                    }
	                }
	            }
	        }
	
	    };
	
	    //Log.level = Log.LOG_LEVEL_DEBUG; 
	    Log.level = Log.LOG_LEVEL_ERROR; 
	    //Log.level = Log.LOG_LEVEL_ERROR;
	    //Log.level = Log.LOG_LEVEL_NONE;
	    module.exports = Log;
	    


/***/ },
/* 107 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * 连线操作类
	 * @author miao.cunzhi
	 */
	
		var Node = __webpack_require__(76);
		var Util = __webpack_require__(73);
		var graphic = __webpack_require__(3);
	    var Point = __webpack_require__(59);
	    var zrUtil = __webpack_require__(4);
	    var ConnectionManager = __webpack_require__(105);
	    var LineOperationManager = {
	        LineOperations:[],
	        isEdit:true,
	        creatOperation:function(key,obj,api){
	            var lineOperation = new graphic.Image({
	                style: {
	                    image:obj.icon,
	                    width: obj.width||15,
	                    height: obj.height||15
	                }
	            });
	            lineOperation.key = key;
	            lineOperation.operation = true;
	            lineOperation.hide();
	            obj.lineNode.icons.push(lineOperation);
	            LineOperationManager.LineOperations.push(lineOperation);
	
	            //小图标 点击事件  如果有回调则调用回调，否则派发事件
	            lineOperation.on("click",function(e){
	                if(obj.callback){
	                    obj.callback(obj.lineNode);
	                } else {
	                    var params = {};
	                    params.event = e;
	                    params.type = "click";
	                    params.elementType = "LineOperationIcon";
	                    api.trigger(params.type, params);
	                }
	
	            });
	            return lineOperation;
	        },
	
	        /**
	         * 计算小图标的位置，并显示
	         * @param  {[type]} connector [description]
	         * @return {[type]}           [description]
	         */
	        bindOperation:function(connector){
	            if(LineOperationManager.isEdit == false){return;}
	            var pointPosition = connector.middle();
	            var length = [];
	            for(var j = 0; j < connector.icons.length; j++){
	                length.push(connector.icons[j].style.width);
	            }
	            var totalLength = 0;
	            for(var m = 0; m < connector.icons.length; m++){
	                    totalLength += length[m]+10;
	            }
	            for(var i = 0; i < connector.icons.length; i++){
	                var connectorPosition = 0;
	                for(var k = 0; k < i; k++){
	                    connectorPosition += length[k]+10;
	                }
	                connector.icons[i].attr("position",[pointPosition[0]+connectorPosition-totalLength/2,pointPosition[1]+5]);
	                connector.icons[i].show();
	            }
	        },
	
	        hideAllLineOperation: function() {
	            for (var li = 0; li < LineOperationManager.LineOperations.length; li++) {
	                var icon =  LineOperationManager.LineOperations[li];
	                icon.hide();
	            }
	        },
	
	        addIcon: function(key, obj, zr, api) {
	            //判断是小图标否存在 ，存在则直接返回
	            if(obj.lineNode.icons){
	                for (var i = 0; i < obj.lineNode.icons.length; i++) {
	                    if (obj.lineNode.icons[i].key == key) {
	                        LineOperationManager.bindOperation(obj.lineNode);
	                        return;
	                    }
	                }
	            }
	
	            var lineOperation = LineOperationManager.creatOperation(key, obj, api);
	            zr.add(lineOperation);
	            LineOperationManager.bindOperation(obj.lineNode);
	            return lineOperation;
	        },
	
	        deleteIconObj: function(parentZr,lineNode) {
	            return {
	                icon:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAwAAAAOBAMAAADpk+DfAAAABGdBTUEAALGPC/xhBQAAAAFzUkdCAK7OHOkAAAAtUExURQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMGgKD4AAAAPdFJOUwDH/g+agESj4Y6zUiRnh7lnwbkAAABLSURBVAjXY2BgYDZgAIEnnkCa7a5cYGwCwwklIOhhMBEEgmIGnlAgOMDAprhQUGgDA5vWdJciXJRGR0dTAgPzQ0FBSaBpzMbGBgwAIoUW3sQ2EdkAAAAASUVORK5CYII=",
	                width: 12,
	                height: 14,
	                lineNode:lineNode,
	                callback:function(e) {
	                    for(var i = 0; i<lineNode.icons.length;i++){
	                        parentZr.remove(lineNode.icons[i])
	                    }
	                    ConnectionManager.deleteLine(parentZr);
	                    LineOperationManager.hideAllLineOperation();
	                    e.cancelBubble = true;
	                }
	            }
	        }
	
	    };
	
		module.exports = LineOperationManager;
	


/***/ },
/* 108 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * 辅助线操作类
	 * @author miao.cunzhi
	 */
	
		var Node = __webpack_require__(76);
		var Util = __webpack_require__(73);
		var graphic = __webpack_require__(3);
	    var Point = __webpack_require__(59);
	    var zrUtil = __webpack_require__(4);
	
	    var Guidelines = {
	        virtualXLine:null,
	        virtualYLine:null,
	        createGuidelines:function(zr){
	            //创建x轴虚线
	            this.virtualXLine = new graphic.Line({
	                style: {
	                    lineDash: [5]
	                },
	                z: 3
	            });
	            //创建Y轴虚线
	            this.virtualYLine = new graphic.Line({
	                style: {
	                    lineDash: [5]
	                },
	                z: 3
	            });
	            zr.add(this.virtualXLine);
	            zr.add(this.virtualYLine);
	        },
	        judgeAlignment:function(nowRectPosition,domArray,maxWidth,maxHeight){
	            var that = this;
	            //循环判断水平对齐
	            for (var j = 0, len = domArray.length; j < len; j++) {
	                if (nowRectPosition[1] == domArray[j].position[1]) {
	                    that.virtualXLine.attr('position', [0, nowRectPosition[1]]);
	                    that.virtualXLine.attr("shape", {
	                        x2: maxWidth
	                    });
	
	                    break;
	                } else {
	                    that.virtualXLine.attr("shape", {
	                        x2: 0
	                    });
	                }
	            }
	            //循环判断垂直对齐
	            for (var m = 0, len1 = domArray.length; m < len1; m++) {
	                if (nowRectPosition[0] == domArray[m].position[0]) {
	                    that.virtualYLine.attr('position', [nowRectPosition[0], 0]);
	                    that.virtualYLine.attr("shape", {
	                        y2: maxHeight
	                    });
	                    break;
	                } else {
	                    that.virtualYLine.attr("shape", {
	                        y2: 0
	                    });
	                }
	            }
	        }
	    };
	
		module.exports = Guidelines;
	


/***/ },
/* 109 */
/***/ function(module, exports, __webpack_require__) {

	
	    __webpack_require__(110);
	    __webpack_require__(60).registerPainter('vml', __webpack_require__(112));


/***/ },
/* 110 */
/***/ function(module, exports, __webpack_require__) {

	// http://www.w3.org/TR/NOTE-VML
	// TODO Use proxy like svg instead of overwrite brush methods
	
	
	if (!__webpack_require__(61).canvasSupported) {
	    var vec2 = __webpack_require__(14);
	    var BoundingRect = __webpack_require__(24);
	    var CMD = __webpack_require__(25).CMD;
	    var colorTool = __webpack_require__(19);
	    var textContain = __webpack_require__(23);
	    var RectText = __webpack_require__(22);
	    var Displayable = __webpack_require__(7);
	    var ZImage = __webpack_require__(40);
	    var Text = __webpack_require__(42);
	    var Path = __webpack_require__(6);
	
	    var Gradient = __webpack_require__(37);
	
	    var vmlCore = __webpack_require__(111);
	
	    var round = Math.round;
	    var sqrt = Math.sqrt;
	    var abs = Math.abs;
	    var cos = Math.cos;
	    var sin = Math.sin;
	    var mathMax = Math.max;
	
	    var applyTransform = vec2.applyTransform;
	
	    var comma = ',';
	    var imageTransformPrefix = 'progid:DXImageTransform.Microsoft';
	
	    var Z = 21600;
	    var Z2 = Z / 2;
	
	    var ZLEVEL_BASE = 100000;
	    var Z_BASE = 1000;
	
	    var initRootElStyle = function (el) {
	        el.style.cssText = 'position:absolute;left:0;top:0;width:1px;height:1px;';
	        el.coordsize = Z + ','  + Z;
	        el.coordorigin = '0,0';
	    };
	
	    var encodeHtmlAttribute = function (s) {
	        return String(s).replace(/&/g, '&amp;').replace(/"/g, '&quot;');
	    };
	
	    var rgb2Str = function (r, g, b) {
	        return 'rgb(' + [r, g, b].join(',') + ')';
	    };
	
	    var append = function (parent, child) {
	        if (child && parent && child.parentNode !== parent) {
	            parent.appendChild(child);
	        }
	    };
	
	    var remove = function (parent, child) {
	        if (child && parent && child.parentNode === parent) {
	            parent.removeChild(child);
	        }
	    };
	
	    var getZIndex = function (zlevel, z, z2) {
	        // z 的取值范围为 [0, 1000]
	        return (parseFloat(zlevel) || 0) * ZLEVEL_BASE + (parseFloat(z) || 0) * Z_BASE + z2;
	    };
	
	    var parsePercent = function (value, maxValue) {
	        if (typeof value === 'string') {
	            if (value.lastIndexOf('%') >= 0) {
	                return parseFloat(value) / 100 * maxValue;
	            }
	            return parseFloat(value);
	        }
	        return value;
	    };
	
	    /***************************************************
	     * PATH
	     **************************************************/
	
	    var setColorAndOpacity = function (el, color, opacity) {
	        var colorArr = colorTool.parse(color);
	        opacity = +opacity;
	        if (isNaN(opacity)) {
	            opacity = 1;
	        }
	        if (colorArr) {
	            el.color = rgb2Str(colorArr[0], colorArr[1], colorArr[2]);
	            el.opacity = opacity * colorArr[3];
	        }
	    };
	
	    var getColorAndAlpha = function (color) {
	        var colorArr = colorTool.parse(color);
	        return [
	            rgb2Str(colorArr[0], colorArr[1], colorArr[2]),
	            colorArr[3]
	        ];
	    };
	
	    var updateFillNode = function (el, style, zrEl) {
	        // TODO pattern
	        var fill = style.fill;
	        if (fill != null) {
	            // Modified from excanvas
	            if (fill instanceof Gradient) {
	                var gradientType;
	                var angle = 0;
	                var focus = [0, 0];
	                // additional offset
	                var shift = 0;
	                // scale factor for offset
	                var expansion = 1;
	                var rect = zrEl.getBoundingRect();
	                var rectWidth = rect.width;
	                var rectHeight = rect.height;
	                if (fill.type === 'linear') {
	                    gradientType = 'gradient';
	                    var transform = zrEl.transform;
	                    var p0 = [fill.x * rectWidth, fill.y * rectHeight];
	                    var p1 = [fill.x2 * rectWidth, fill.y2 * rectHeight];
	                    if (transform) {
	                        applyTransform(p0, p0, transform);
	                        applyTransform(p1, p1, transform);
	                    }
	                    var dx = p1[0] - p0[0];
	                    var dy = p1[1] - p0[1];
	                    angle = Math.atan2(dx, dy) * 180 / Math.PI;
	                    // The angle should be a non-negative number.
	                    if (angle < 0) {
	                        angle += 360;
	                    }
	
	                    // Very small angles produce an unexpected result because they are
	                    // converted to a scientific notation string.
	                    if (angle < 1e-6) {
	                        angle = 0;
	                    }
	                }
	                else {
	                    gradientType = 'gradientradial';
	                    var p0 = [fill.x * rectWidth, fill.y * rectHeight];
	                    var transform = zrEl.transform;
	                    var scale = zrEl.scale;
	                    var width = rectWidth;
	                    var height = rectHeight;
	                    focus = [
	                        // Percent in bounding rect
	                        (p0[0] - rect.x) / width,
	                        (p0[1] - rect.y) / height
	                    ];
	                    if (transform) {
	                        applyTransform(p0, p0, transform);
	                    }
	
	                    width /= scale[0] * Z;
	                    height /= scale[1] * Z;
	                    var dimension = mathMax(width, height);
	                    shift = 2 * 0 / dimension;
	                    expansion = 2 * fill.r / dimension - shift;
	                }
	
	                // We need to sort the color stops in ascending order by offset,
	                // otherwise IE won't interpret it correctly.
	                var stops = fill.colorStops.slice();
	                stops.sort(function(cs1, cs2) {
	                    return cs1.offset - cs2.offset;
	                });
	
	                var length = stops.length;
	                // Color and alpha list of first and last stop
	                var colorAndAlphaList = [];
	                var colors = [];
	                for (var i = 0; i < length; i++) {
	                    var stop = stops[i];
	                    var colorAndAlpha = getColorAndAlpha(stop.color);
	                    colors.push(stop.offset * expansion + shift + ' ' + colorAndAlpha[0]);
	                    if (i === 0 || i === length - 1) {
	                        colorAndAlphaList.push(colorAndAlpha);
	                    }
	                }
	
	                if (length >= 2) {
	                    var color1 = colorAndAlphaList[0][0];
	                    var color2 = colorAndAlphaList[1][0];
	                    var opacity1 = colorAndAlphaList[0][1] * style.opacity;
	                    var opacity2 = colorAndAlphaList[1][1] * style.opacity;
	
	                    el.type = gradientType;
	                    el.method = 'none';
	                    el.focus = '100%';
	                    el.angle = angle;
	                    el.color = color1;
	                    el.color2 = color2;
	                    el.colors = colors.join(',');
	                    // When colors attribute is used, the meanings of opacity and o:opacity2
	                    // are reversed.
	                    el.opacity = opacity2;
	                    // FIXME g_o_:opacity ?
	                    el.opacity2 = opacity1;
	                }
	                if (gradientType === 'radial') {
	                    el.focusposition = focus.join(',');
	                }
	            }
	            else {
	                // FIXME Change from Gradient fill to color fill
	                setColorAndOpacity(el, fill, style.opacity);
	            }
	        }
	    };
	
	    var updateStrokeNode = function (el, style) {
	        // if (style.lineJoin != null) {
	        //     el.joinstyle = style.lineJoin;
	        // }
	        // if (style.miterLimit != null) {
	        //     el.miterlimit = style.miterLimit * Z;
	        // }
	        // if (style.lineCap != null) {
	        //     el.endcap = style.lineCap;
	        // }
	        if (style.lineDash != null) {
	            el.dashstyle = style.lineDash.join(' ');
	        }
	        if (style.stroke != null && !(style.stroke instanceof Gradient)) {
	            setColorAndOpacity(el, style.stroke, style.opacity);
	        }
	    };
	
	    var updateFillAndStroke = function (vmlEl, type, style, zrEl) {
	        var isFill = type == 'fill';
	        var el = vmlEl.getElementsByTagName(type)[0];
	        // Stroke must have lineWidth
	        if (style[type] != null && style[type] !== 'none' && (isFill || (!isFill && style.lineWidth))) {
	            vmlEl[isFill ? 'filled' : 'stroked'] = 'true';
	            // FIXME Remove before updating, or set `colors` will throw error
	            if (style[type] instanceof Gradient) {
	                remove(vmlEl, el);
	            }
	            if (!el) {
	                el = vmlCore.createNode(type);
	            }
	
	            isFill ? updateFillNode(el, style, zrEl) : updateStrokeNode(el, style);
	            append(vmlEl, el);
	        }
	        else {
	            vmlEl[isFill ? 'filled' : 'stroked'] = 'false';
	            remove(vmlEl, el);
	        }
	    };
	
	    var points = [[], [], []];
	    var pathDataToString = function (data, m) {
	        var M = CMD.M;
	        var C = CMD.C;
	        var L = CMD.L;
	        var A = CMD.A;
	        var Q = CMD.Q;
	
	        var str = [];
	        var nPoint;
	        var cmdStr;
	        var cmd;
	        var i;
	        var xi;
	        var yi;
	        for (i = 0; i < data.length;) {
	            cmd = data[i++];
	            cmdStr = '';
	            nPoint = 0;
	            switch (cmd) {
	                case M:
	                    cmdStr = ' m ';
	                    nPoint = 1;
	                    xi = data[i++];
	                    yi = data[i++];
	                    points[0][0] = xi;
	                    points[0][1] = yi;
	                    break;
	                case L:
	                    cmdStr = ' l ';
	                    nPoint = 1;
	                    xi = data[i++];
	                    yi = data[i++];
	                    points[0][0] = xi;
	                    points[0][1] = yi;
	                    break;
	                case Q:
	                case C:
	                    cmdStr = ' c ';
	                    nPoint = 3;
	                    var x1 = data[i++];
	                    var y1 = data[i++];
	                    var x2 = data[i++];
	                    var y2 = data[i++];
	                    var x3;
	                    var y3;
	                    if (cmd === Q) {
	                        // Convert quadratic to cubic using degree elevation
	                        x3 = x2;
	                        y3 = y2;
	                        x2 = (x2 + 2 * x1) / 3;
	                        y2 = (y2 + 2 * y1) / 3;
	                        x1 = (xi + 2 * x1) / 3;
	                        y1 = (yi + 2 * y1) / 3;
	                    }
	                    else {
	                        x3 = data[i++];
	                        y3 = data[i++];
	                    }
	                    points[0][0] = x1;
	                    points[0][1] = y1;
	                    points[1][0] = x2;
	                    points[1][1] = y2;
	                    points[2][0] = x3;
	                    points[2][1] = y3;
	
	                    xi = x3;
	                    yi = y3;
	                    break;
	                case A:
	                    var x = 0;
	                    var y = 0;
	                    var sx = 1;
	                    var sy = 1;
	                    var angle = 0;
	                    if (m) {
	                        // Extract SRT from matrix
	                        x = m[4];
	                        y = m[5];
	                        sx = sqrt(m[0] * m[0] + m[1] * m[1]);
	                        sy = sqrt(m[2] * m[2] + m[3] * m[3]);
	                        angle = Math.atan2(-m[1] / sy, m[0] / sx);
	                    }
	
	                    var cx = data[i++];
	                    var cy = data[i++];
	                    var rx = data[i++];
	                    var ry = data[i++];
	                    var startAngle = data[i++] + angle;
	                    var endAngle = data[i++] + startAngle + angle;
	                    // FIXME
	                    // var psi = data[i++];
	                    i++;
	                    var clockwise = data[i++];
	
	                    var x0 = cx + cos(startAngle) * rx;
	                    var y0 = cy + sin(startAngle) * ry;
	
	                    var x1 = cx + cos(endAngle) * rx;
	                    var y1 = cy + sin(endAngle) * ry;
	
	                    var type = clockwise ? ' wa ' : ' at ';
	                    if (Math.abs(x0 - x1) < 1e-10) {
	                        // IE won't render arches drawn counter clockwise if x0 == x1.
	                        if (Math.abs(endAngle - startAngle) > 1e-2) {
	                            // Offset x0 by 1/80 of a pixel. Use something
	                            // that can be represented in binary
	                            if (clockwise) {
	                                x0 += 270 / Z;
	                            }
	                        }
	                        else {
	                            // Avoid case draw full circle
	                            if (Math.abs(y0 - cy) < 1e-10) {
	                                if ((clockwise && x0 < cx) || (!clockwise && x0 > cx)) {
	                                    y1 -= 270 / Z;
	                                }
	                                else {
	                                    y1 += 270 / Z;
	                                }
	                            }
	                            else if ((clockwise && y0 < cy) || (!clockwise && y0 > cy)) {
	                                x1 += 270 / Z;
	                            }
	                            else {
	                                x1 -= 270 / Z;
	                            }
	                        }
	                    }
	                    str.push(
	                        type,
	                        round(((cx - rx) * sx + x) * Z - Z2), comma,
	                        round(((cy - ry) * sy + y) * Z - Z2), comma,
	                        round(((cx + rx) * sx + x) * Z - Z2), comma,
	                        round(((cy + ry) * sy + y) * Z - Z2), comma,
	                        round((x0 * sx + x) * Z - Z2), comma,
	                        round((y0 * sy + y) * Z - Z2), comma,
	                        round((x1 * sx + x) * Z - Z2), comma,
	                        round((y1 * sy + y) * Z - Z2)
	                    );
	
	                    xi = x1;
	                    yi = y1;
	                    break;
	                case CMD.R:
	                    var p0 = points[0];
	                    var p1 = points[1];
	                    // x0, y0
	                    p0[0] = data[i++];
	                    p0[1] = data[i++];
	                    // x1, y1
	                    p1[0] = p0[0] + data[i++];
	                    p1[1] = p0[1] + data[i++];
	
	                    if (m) {
	                        applyTransform(p0, p0, m);
	                        applyTransform(p1, p1, m);
	                    }
	
	                    p0[0] = round(p0[0] * Z - Z2);
	                    p1[0] = round(p1[0] * Z - Z2);
	                    p0[1] = round(p0[1] * Z - Z2);
	                    p1[1] = round(p1[1] * Z - Z2);
	                    str.push(
	                        // x0, y0
	                        ' m ', p0[0], comma, p0[1],
	                        // x1, y0
	                        ' l ', p1[0], comma, p0[1],
	                        // x1, y1
	                        ' l ', p1[0], comma, p1[1],
	                        // x0, y1
	                        ' l ', p0[0], comma, p1[1]
	                    );
	                    break;
	                case CMD.Z:
	                    // FIXME Update xi, yi
	                    str.push(' x ');
	            }
	
	            if (nPoint > 0) {
	                str.push(cmdStr);
	                for (var k = 0; k < nPoint; k++) {
	                    var p = points[k];
	
	                    m && applyTransform(p, p, m);
	                    // 不 round 会非常慢
	                    str.push(
	                        round(p[0] * Z - Z2), comma, round(p[1] * Z - Z2),
	                        k < nPoint - 1 ? comma : ''
	                    );
	                }
	            }
	        }
	
	        return str.join('');
	    };
	
	    // Rewrite the original path method
	    Path.prototype.brushVML = function (vmlRoot) {
	        var style = this.style;
	
	        var vmlEl = this._vmlEl;
	        if (!vmlEl) {
	            vmlEl = vmlCore.createNode('shape');
	            initRootElStyle(vmlEl);
	
	            this._vmlEl = vmlEl;
	        }
	
	        updateFillAndStroke(vmlEl, 'fill', style, this);
	        updateFillAndStroke(vmlEl, 'stroke', style, this);
	
	        var m = this.transform;
	        var needTransform = m != null;
	        var strokeEl = vmlEl.getElementsByTagName('stroke')[0];
	        if (strokeEl) {
	            var lineWidth = style.lineWidth;
	            // Get the line scale.
	            // Determinant of this.m_ means how much the area is enlarged by the
	            // transformation. So its square root can be used as a scale factor
	            // for width.
	            if (needTransform && !style.strokeNoScale) {
	                var det = m[0] * m[3] - m[1] * m[2];
	                lineWidth *= sqrt(abs(det));
	            }
	            strokeEl.weight = lineWidth + 'px';
	        }
	
	        var path = this.path;
	        if (this.__dirtyPath) {
	            path.beginPath();
	            this.buildPath(path, this.shape);
	            path.toStatic();
	            this.__dirtyPath = false;
	        }
	
	        vmlEl.path = pathDataToString(path.data, this.transform);
	
	        vmlEl.style.zIndex = getZIndex(this.zlevel, this.z, this.z2);
	
	        // Append to root
	        append(vmlRoot, vmlEl);
	
	        // Text
	        if (style.text) {
	            this.drawRectText(vmlRoot, this.getBoundingRect());
	        }
	        else {
	            this.removeRectText(vmlRoot);
	        }
	    };
	
	    Path.prototype.onRemove = function (vmlRoot) {
	        remove(vmlRoot, this._vmlEl);
	        this.removeRectText(vmlRoot);
	    };
	
	    Path.prototype.onAdd = function (vmlRoot) {
	        append(vmlRoot, this._vmlEl);
	        this.appendRectText(vmlRoot);
	    };
	
	    /***************************************************
	     * IMAGE
	     **************************************************/
	    var isImage = function (img) {
	        // FIXME img instanceof Image 如果 img 是一个字符串的时候，IE8 下会报错
	        return (typeof img === 'object') && img.tagName && img.tagName.toUpperCase() === 'IMG';
	        // return img instanceof Image;
	    };
	
	    // Rewrite the original path method
	    ZImage.prototype.brushVML = function (vmlRoot) {
	        var style = this.style;
	        var image = style.image;
	
	        // Image original width, height
	        var ow;
	        var oh;
	
	        if (isImage(image)) {
	            var src = image.src;
	            if (src === this._imageSrc) {
	                ow = this._imageWidth;
	                oh = this._imageHeight;
	            }
	            else {
	                var imageRuntimeStyle = image.runtimeStyle;
	                var oldRuntimeWidth = imageRuntimeStyle.width;
	                var oldRuntimeHeight = imageRuntimeStyle.height;
	                imageRuntimeStyle.width = 'auto';
	                imageRuntimeStyle.height = 'auto';
	
	                // get the original size
	                ow = image.width;
	                oh = image.height;
	
	                // and remove overides
	                imageRuntimeStyle.width = oldRuntimeWidth;
	                imageRuntimeStyle.height = oldRuntimeHeight;
	
	                // Caching image original width, height and src
	                this._imageSrc = src;
	                this._imageWidth = ow;
	                this._imageHeight = oh;
	            }
	            image = src;
	        }
	        else {
	            if (image === this._imageSrc) {
	                ow = this._imageWidth;
	                oh = this._imageHeight;
	            }
	        }
	        if (!image) {
	            return;
	        }
	
	        var x = style.x || 0;
	        var y = style.y || 0;
	
	        var dw = style.width;
	        var dh = style.height;
	
	        var sw = style.sWidth;
	        var sh = style.sHeight;
	        var sx = style.sx || 0;
	        var sy = style.sy || 0;
	
	        var hasCrop = sw && sh;
	
	        var vmlEl = this._vmlEl;
	        if (!vmlEl) {
	            // FIXME 使用 group 在 left, top 都不是 0 的时候就无法显示了。
	            // vmlEl = vmlCore.createNode('group');
	            vmlEl = vmlCore.doc.createElement('div');
	            initRootElStyle(vmlEl);
	
	            this._vmlEl = vmlEl;
	        }
	
	        var vmlElStyle = vmlEl.style;
	        var hasRotation = false;
	        var m;
	        var scaleX = 1;
	        var scaleY = 1;
	        if (this.transform) {
	            m = this.transform;
	            scaleX = sqrt(m[0] * m[0] + m[1] * m[1]);
	            scaleY = sqrt(m[2] * m[2] + m[3] * m[3]);
	
	            hasRotation = m[1] || m[2];
	        }
	        if (hasRotation) {
	            // If filters are necessary (rotation exists), create them
	            // filters are bog-slow, so only create them if abbsolutely necessary
	            // The following check doesn't account for skews (which don't exist
	            // in the canvas spec (yet) anyway.
	            // From excanvas
	            var p0 = [x, y];
	            var p1 = [x + dw, y];
	            var p2 = [x, y + dh];
	            var p3 = [x + dw, y + dh];
	            applyTransform(p0, p0, m);
	            applyTransform(p1, p1, m);
	            applyTransform(p2, p2, m);
	            applyTransform(p3, p3, m);
	
	            var maxX = mathMax(p0[0], p1[0], p2[0], p3[0]);
	            var maxY = mathMax(p0[1], p1[1], p2[1], p3[1]);
	
	            var transformFilter = [];
	            transformFilter.push('M11=', m[0] / scaleX, comma,
	                        'M12=', m[2] / scaleY, comma,
	                        'M21=', m[1] / scaleX, comma,
	                        'M22=', m[3] / scaleY, comma,
	                        'Dx=', round(x * scaleX + m[4]), comma,
	                        'Dy=', round(y * scaleY + m[5]));
	
	            vmlElStyle.padding = '0 ' + round(maxX) + 'px ' + round(maxY) + 'px 0';
	            // FIXME DXImageTransform 在 IE11 的兼容模式下不起作用
	            vmlElStyle.filter = imageTransformPrefix + '.Matrix('
	                + transformFilter.join('') + ', SizingMethod=clip)';
	
	        }
	        else {
	            if (m) {
	                x = x * scaleX + m[4];
	                y = y * scaleY + m[5];
	            }
	            vmlElStyle.filter = '';
	            vmlElStyle.left = round(x) + 'px';
	            vmlElStyle.top = round(y) + 'px';
	        }
	
	        var imageEl = this._imageEl;
	        var cropEl = this._cropEl;
	
	        if (!imageEl) {
	            imageEl = vmlCore.doc.createElement('div');
	            this._imageEl = imageEl;
	        }
	        var imageELStyle = imageEl.style;
	        if (hasCrop) {
	            // Needs know image original width and height
	            if (! (ow && oh)) {
	                var tmpImage = new Image();
	                var self = this;
	                tmpImage.onload = function () {
	                    tmpImage.onload = null;
	                    ow = tmpImage.width;
	                    oh = tmpImage.height;
	                    // Adjust image width and height to fit the ratio destinationSize / sourceSize
	                    imageELStyle.width = round(scaleX * ow * dw / sw) + 'px';
	                    imageELStyle.height = round(scaleY * oh * dh / sh) + 'px';
	
	                    // Caching image original width, height and src
	                    self._imageWidth = ow;
	                    self._imageHeight = oh;
	                    self._imageSrc = image;
	                };
	                tmpImage.src = image;
	            }
	            else {
	                imageELStyle.width = round(scaleX * ow * dw / sw) + 'px';
	                imageELStyle.height = round(scaleY * oh * dh / sh) + 'px';
	            }
	
	            if (! cropEl) {
	                cropEl = vmlCore.doc.createElement('div');
	                cropEl.style.overflow = 'hidden';
	                this._cropEl = cropEl;
	            }
	            var cropElStyle = cropEl.style;
	            cropElStyle.width = round((dw + sx * dw / sw) * scaleX);
	            cropElStyle.height = round((dh + sy * dh / sh) * scaleY);
	            cropElStyle.filter = imageTransformPrefix + '.Matrix(Dx='
	                    + (-sx * dw / sw * scaleX) + ',Dy=' + (-sy * dh / sh * scaleY) + ')';
	
	            if (! cropEl.parentNode) {
	                vmlEl.appendChild(cropEl);
	            }
	            if (imageEl.parentNode != cropEl) {
	                cropEl.appendChild(imageEl);
	            }
	        }
	        else {
	            imageELStyle.width = round(scaleX * dw) + 'px';
	            imageELStyle.height = round(scaleY * dh) + 'px';
	
	            vmlEl.appendChild(imageEl);
	
	            if (cropEl && cropEl.parentNode) {
	                vmlEl.removeChild(cropEl);
	                this._cropEl = null;
	            }
	        }
	
	        var filterStr = '';
	        var alpha = style.opacity;
	        if (alpha < 1) {
	            filterStr += '.Alpha(opacity=' + round(alpha * 100) + ') ';
	        }
	        filterStr += imageTransformPrefix + '.AlphaImageLoader(src=' + image + ', SizingMethod=scale)';
	
	        imageELStyle.filter = filterStr;
	
	        vmlEl.style.zIndex = getZIndex(this.zlevel, this.z, this.z2);
	
	        // Append to root
	        append(vmlRoot, vmlEl);
	
	        // Text
	        if (style.text) {
	            this.drawRectText(vmlRoot, this.getBoundingRect());
	        }
	    };
	
	    ZImage.prototype.onRemove = function (vmlRoot) {
	        remove(vmlRoot, this._vmlEl);
	
	        this._vmlEl = null;
	        this._cropEl = null;
	        this._imageEl = null;
	
	        this.removeRectText(vmlRoot);
	    };
	
	    ZImage.prototype.onAdd = function (vmlRoot) {
	        append(vmlRoot, this._vmlEl);
	        this.appendRectText(vmlRoot);
	    };
	
	
	    /***************************************************
	     * TEXT
	     **************************************************/
	
	    var DEFAULT_STYLE_NORMAL = 'normal';
	
	    var fontStyleCache = {};
	    var fontStyleCacheCount = 0;
	    var MAX_FONT_CACHE_SIZE = 100;
	    var fontEl = document.createElement('div');
	
	    var getFontStyle = function (fontString) {
	        var fontStyle = fontStyleCache[fontString];
	        if (!fontStyle) {
	            // Clear cache
	            if (fontStyleCacheCount > MAX_FONT_CACHE_SIZE) {
	                fontStyleCacheCount = 0;
	                fontStyleCache = {};
	            }
	
	            var style = fontEl.style;
	            var fontFamily;
	            try {
	                style.font = fontString;
	                fontFamily = style.fontFamily.split(',')[0];
	            }
	            catch (e) {
	            }
	
	            fontStyle = {
	                style: style.fontStyle || DEFAULT_STYLE_NORMAL,
	                variant: style.fontVariant || DEFAULT_STYLE_NORMAL,
	                weight: style.fontWeight || DEFAULT_STYLE_NORMAL,
	                size: parseFloat(style.fontSize || 12) | 0,
	                family: fontFamily || 'Microsoft YaHei'
	            };
	
	            fontStyleCache[fontString] = fontStyle;
	            fontStyleCacheCount++;
	        }
	        return fontStyle;
	    };
	
	    var textMeasureEl;
	    // Overwrite measure text method
	    textContain.measureText = function (text, textFont) {
	        var doc = vmlCore.doc;
	        if (!textMeasureEl) {
	            textMeasureEl = doc.createElement('div');
	            textMeasureEl.style.cssText = 'position:absolute;top:-20000px;left:0;'
	                + 'padding:0;margin:0;border:none;white-space:pre;';
	            vmlCore.doc.body.appendChild(textMeasureEl);
	        }
	
	        try {
	            textMeasureEl.style.font = textFont;
	        } catch (ex) {
	            // Ignore failures to set to invalid font.
	        }
	        textMeasureEl.innerHTML = '';
	        // Don't use innerHTML or innerText because they allow markup/whitespace.
	        textMeasureEl.appendChild(doc.createTextNode(text));
	        return {
	            width: textMeasureEl.offsetWidth
	        };
	    };
	
	    var tmpRect = new BoundingRect();
	
	    var drawRectText = function (vmlRoot, rect, textRect, fromTextEl) {
	
	        var style = this.style;
	        var text = style.text;
	        if (!text) {
	            return;
	        }
	
	        var x;
	        var y;
	        var align = style.textAlign;
	        var fontStyle = getFontStyle(style.textFont);
	        // FIXME encodeHtmlAttribute ?
	        var font = fontStyle.style + ' ' + fontStyle.variant + ' ' + fontStyle.weight + ' '
	            + fontStyle.size + 'px "' + fontStyle.family + '"';
	
	        var baseline = style.textBaseline;
	        var verticalAlign = style.textVerticalAlign;
	
	        textRect = textRect || textContain.getBoundingRect(text, font, align, baseline);
	
	        // Transform rect to view space
	        var m = this.transform;
	        // Ignore transform for text in other element
	        if (m && !fromTextEl) {
	            tmpRect.copy(rect);
	            tmpRect.applyTransform(m);
	            rect = tmpRect;
	        }
	
	        if (!fromTextEl) {
	            var textPosition = style.textPosition;
	            var distance = style.textDistance;
	            // Text position represented by coord
	            if (textPosition instanceof Array) {
	                x = rect.x + parsePercent(textPosition[0], rect.width);
	                y = rect.y + parsePercent(textPosition[1], rect.height);
	
	                align = align || 'left';
	                baseline = baseline || 'top';
	            }
	            else {
	                var res = textContain.adjustTextPositionOnRect(
	                    textPosition, rect, textRect, distance
	                );
	                x = res.x;
	                y = res.y;
	
	                // Default align and baseline when has textPosition
	                align = align || res.textAlign;
	                baseline = baseline || res.textBaseline;
	            }
	        }
	        else {
	            x = rect.x;
	            y = rect.y;
	        }
	        if (verticalAlign) {
	            switch (verticalAlign) {
	                case 'middle':
	                    y -= textRect.height / 2;
	                    break;
	                case 'bottom':
	                    y -= textRect.height;
	                    break;
	                // 'top'
	            }
	            // Ignore baseline
	            baseline = 'top';
	        }
	
	        var fontSize = fontStyle.size;
	        // 1.75 is an arbitrary number, as there is no info about the text baseline
	        switch (baseline) {
	            case 'hanging':
	            case 'top':
	                y += fontSize / 1.75;
	                break;
	            case 'middle':
	                break;
	            default:
	            // case null:
	            // case 'alphabetic':
	            // case 'ideographic':
	            // case 'bottom':
	                y -= fontSize / 2.25;
	                break;
	        }
	        switch (align) {
	            case 'left':
	                break;
	            case 'center':
	                x -= textRect.width / 2;
	                break;
	            case 'right':
	                x -= textRect.width;
	                break;
	            // case 'end':
	                // align = elementStyle.direction == 'ltr' ? 'right' : 'left';
	                // break;
	            // case 'start':
	                // align = elementStyle.direction == 'rtl' ? 'right' : 'left';
	                // break;
	            // default:
	            //     align = 'left';
	        }
	
	        var createNode = vmlCore.createNode;
	
	        var textVmlEl = this._textVmlEl;
	        var pathEl;
	        var textPathEl;
	        var skewEl;
	        if (!textVmlEl) {
	            textVmlEl = createNode('line');
	            pathEl = createNode('path');
	            textPathEl = createNode('textpath');
	            skewEl = createNode('skew');
	
	            // FIXME Why here is not cammel case
	            // Align 'center' seems wrong
	            textPathEl.style['v-text-align'] = 'left';
	
	            initRootElStyle(textVmlEl);
	
	            pathEl.textpathok = true;
	            textPathEl.on = true;
	
	            textVmlEl.from = '0 0';
	            textVmlEl.to = '1000 0.05';
	
	            append(textVmlEl, skewEl);
	            append(textVmlEl, pathEl);
	            append(textVmlEl, textPathEl);
	
	            this._textVmlEl = textVmlEl;
	        }
	        else {
	            // 这里是在前面 appendChild 保证顺序的前提下
	            skewEl = textVmlEl.firstChild;
	            pathEl = skewEl.nextSibling;
	            textPathEl = pathEl.nextSibling;
	        }
	
	        var coords = [x, y];
	        var textVmlElStyle = textVmlEl.style;
	        // Ignore transform for text in other element
	        if (m && fromTextEl) {
	            applyTransform(coords, coords, m);
	
	            skewEl.on = true;
	
	            skewEl.matrix = m[0].toFixed(3) + comma + m[2].toFixed(3) + comma +
	            m[1].toFixed(3) + comma + m[3].toFixed(3) + ',0,0';
	
	            // Text position
	            skewEl.offset = (round(coords[0]) || 0) + ',' + (round(coords[1]) || 0);
	            // Left top point as origin
	            skewEl.origin = '0 0';
	
	            textVmlElStyle.left = '0px';
	            textVmlElStyle.top = '0px';
	        }
	        else {
	            skewEl.on = false;
	            textVmlElStyle.left = round(x) + 'px';
	            textVmlElStyle.top = round(y) + 'px';
	        }
	
	        textPathEl.string = encodeHtmlAttribute(text);
	        // TODO
	        try {
	            textPathEl.style.font = font;
	        }
	        // Error font format
	        catch (e) {}
	
	        updateFillAndStroke(textVmlEl, 'fill', {
	            fill: fromTextEl ? style.fill : style.textFill,
	            opacity: style.opacity
	        }, this);
	        updateFillAndStroke(textVmlEl, 'stroke', {
	            stroke: fromTextEl ? style.stroke : style.textStroke,
	            opacity: style.opacity,
	            lineDash: style.lineDash
	        }, this);
	
	        textVmlEl.style.zIndex = getZIndex(this.zlevel, this.z, this.z2);
	
	        // Attached to root
	        append(vmlRoot, textVmlEl);
	    };
	
	    var removeRectText = function (vmlRoot) {
	        remove(vmlRoot, this._textVmlEl);
	        this._textVmlEl = null;
	    };
	
	    var appendRectText = function (vmlRoot) {
	        append(vmlRoot, this._textVmlEl);
	    };
	
	    var list = [RectText, Displayable, ZImage, Path, Text];
	
	    // In case Displayable has been mixed in RectText
	    for (var i = 0; i < list.length; i++) {
	        var proto = list[i].prototype;
	        proto.drawRectText = drawRectText;
	        proto.removeRectText = removeRectText;
	        proto.appendRectText = appendRectText;
	    }
	
	    Text.prototype.brushVML = function (vmlRoot) {
	        var style = this.style;
	        if (style.text) {
	            this.drawRectText(vmlRoot, {
	                x: style.x || 0, y: style.y || 0,
	                width: 0, height: 0
	            }, this.getBoundingRect(), true);
	        }
	        else {
	            this.removeRectText(vmlRoot);
	        }
	    };
	
	    Text.prototype.onRemove = function (vmlRoot) {
	        this.removeRectText(vmlRoot);
	    };
	
	    Text.prototype.onAdd = function (vmlRoot) {
	        this.appendRectText(vmlRoot);
	    };
	}


/***/ },
/* 111 */
/***/ function(module, exports, __webpack_require__) {

	
	
	if (!__webpack_require__(61).canvasSupported) {
	    var urn = 'urn:schemas-microsoft-com:vml';
	
	    var createNode;
	    var win = window;
	    var doc = win.document;
	
	    var vmlInited = false;
	
	    try {
	        !doc.namespaces.zrvml && doc.namespaces.add('zrvml', urn);
	        createNode = function (tagName) {
	            return doc.createElement('<zrvml:' + tagName + ' class="zrvml">');
	        };
	    }
	    catch (e) {
	        createNode = function (tagName) {
	            return doc.createElement('<' + tagName + ' xmlns="' + urn + '" class="zrvml">');
	        };
	    }
	
	    // From raphael
	    var initVML = function () {
	        if (vmlInited) {
	            return;
	        }
	        vmlInited = true;
	
	        var styleSheets = doc.styleSheets;
	        if (styleSheets.length < 31) {
	            doc.createStyleSheet().addRule('.zrvml', 'behavior:url(#default#VML)');
	        }
	        else {
	            // http://msdn.microsoft.com/en-us/library/ms531194%28VS.85%29.aspx
	            styleSheets[0].addRule('.zrvml', 'behavior:url(#default#VML)');
	        }
	    };
	
	    // Not useing return to avoid error when converting to CommonJS module
	    module.exports = {
	        doc: doc,
	        initVML: initVML,
	        createNode: createNode
	    };
	}


/***/ },
/* 112 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * VML Painter.
	 *
	 * @module zrender/vml/Painter
	 */
	
	
	
	    var zrLog = __webpack_require__(20);
	    var vmlCore = __webpack_require__(111);
	
	    function parseInt10(val) {
	        return parseInt(val, 10);
	    }
	
	    /**
	     * @alias module:zrender/vml/Painter
	     */
	    function VMLPainter(root, storage) {
	
	        vmlCore.initVML();
	
	        this.root = root;
	
	        this.storage = storage;
	
	        var vmlViewport = document.createElement('div');
	
	        var vmlRoot = document.createElement('div');
	
	        vmlViewport.style.cssText = 'display:inline-block;overflow:hidden;position:relative;width:300px;height:150px;';
	
	        vmlRoot.style.cssText = 'position:absolute;left:0;top:0;';
	
	        root.appendChild(vmlViewport);
	
	        this._vmlRoot = vmlRoot;
	        this._vmlViewport = vmlViewport;
	
	        this.resize();
	
	        // Modify storage
	        var oldDelFromMap = storage.delFromMap;
	        var oldAddToMap = storage.addToMap;
	        storage.delFromMap = function (elId) {
	            var el = storage.get(elId);
	
	            oldDelFromMap.call(storage, elId);
	
	            if (el) {
	                el.onRemove && el.onRemove(vmlRoot);
	            }
	        };
	
	        storage.addToMap = function (el) {
	            // Displayable already has a vml node
	            el.onAdd && el.onAdd(vmlRoot);
	
	            oldAddToMap.call(storage, el);
	        };
	
	        this._firstPaint = true;
	    }
	
	    VMLPainter.prototype = {
	
	        constructor: VMLPainter,
	
	        /**
	         * @return {HTMLDivElement}
	         */
	        getViewportRoot: function () {
	            return this._vmlViewport;
	        },
	
	        /**
	         * 刷新
	         */
	        refresh: function () {
	
	            var list = this.storage.getDisplayList(true, true);
	
	            this._paintList(list);
	        },
	
	        _paintList: function (list) {
	            var vmlRoot = this._vmlRoot;
	            for (var i = 0; i < list.length; i++) {
	                var el = list[i];
	                if (el.invisible || el.ignore) {
	                    if (!el.__alreadyNotVisible) {
	                        el.onRemove(vmlRoot);
	                    }
	                    // Set as already invisible
	                    el.__alreadyNotVisible = true;
	                }
	                else {
	                    if (el.__alreadyNotVisible) {
	                        el.onAdd(vmlRoot);
	                    }
	                    el.__alreadyNotVisible = false;
	                    if (el.__dirty) {
	                        el.beforeBrush && el.beforeBrush();
	                        (el.brushVML || el.brush).call(el, vmlRoot);
	                        el.afterBrush && el.afterBrush();
	                    }
	                }
	                el.__dirty = false;
	            }
	
	            if (this._firstPaint) {
	                // Detached from document at first time
	                // to avoid page refreshing too many times
	
	                // FIXME 如果每次都先 removeChild 可能会导致一些填充和描边的效果改变
	                this._vmlViewport.appendChild(vmlRoot);
	                this._firstPaint = false;
	            }
	        },
	
	        resize: function () {
	            var width = this._getWidth();
	            var height = this._getHeight();
	
	            if (this._width != width && this._height != height) {
	                this._width = width;
	                this._height = height;
	
	                var vmlViewportStyle = this._vmlViewport.style;
	                vmlViewportStyle.width = width + 'px';
	                vmlViewportStyle.height = height + 'px';
	            }
	        },
	
	        dispose: function () {
	            this.root.innerHTML = '';
	
	            this._vmlRoot =
	            this._vmlViewport =
	            this.storage = null;
	        },
	
	        getWidth: function () {
	            return this._width;
	        },
	
	        getHeight: function () {
	            return this._height;
	        },
	
	        clear: function () {
	            this.root.removeChild(this.vmlViewport);
	        },
	
	        _getWidth: function () {
	            var root = this.root;
	            var stl = root.currentStyle;
	
	            return ((root.clientWidth || parseInt10(stl.width))
	                    - parseInt10(stl.paddingLeft)
	                    - parseInt10(stl.paddingRight)) | 0;
	        },
	
	        _getHeight: function () {
	            var root = this.root;
	            var stl = root.currentStyle;
	
	            return ((root.clientHeight || parseInt10(stl.height))
	                    - parseInt10(stl.paddingTop)
	                    - parseInt10(stl.paddingBottom)) | 0;
	        }
	    };
	
	    // Not supported methods
	    function createMethodNotSupport(method) {
	        return function () {
	            zrLog('In IE8.0 VML mode painter not support method "' + method + '"');
	        };
	    }
	
	    var notSupportedMethods = [
	        'getLayer', 'insertLayer', 'eachLayer', 'eachBuildinLayer', 'eachOtherLayer', 'getLayers',
	        'modLayer', 'delLayer', 'clearLayer', 'toDataURL', 'pathToImage'
	    ];
	
	    for (var i = 0; i < notSupportedMethods.length; i++) {
	        var name = notSupportedMethods[i];
	        VMLPainter.prototype[name] = createMethodNotSupport(name);
	    }
	
	    module.exports = VMLPainter;


/***/ }
/******/ ])
});
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwid2VicGFjazovLy93ZWJwYWNrL2Jvb3RzdHJhcCA4MDU0YmYzMDM0NjA2MTgxZWViNiIsIndlYnBhY2s6Ly8vLi9pbmRleC5icG1uLmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tYnBtbi9saWIvRmlzaFRvcG9CcG1uLmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tY29yZS9saWIvZ3JhcGhpYy5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2NvcmUvdXRpbC5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL3Rvb2wvcGF0aC5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvUGF0aC5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvRGlzcGxheWFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9ncmFwaGljL1N0eWxlLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvRWxlbWVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2NvcmUvZ3VpZC5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL21peGluL0V2ZW50ZnVsLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvbWl4aW4vVHJhbnNmb3JtYWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2NvcmUvbWF0cml4LmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvY29yZS92ZWN0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9taXhpbi9BbmltYXRhYmxlLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvYW5pbWF0aW9uL0FuaW1hdG9yLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvYW5pbWF0aW9uL0NsaXAuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9hbmltYXRpb24vZWFzaW5nLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvdG9vbC9jb2xvci5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2NvcmUvbG9nLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvY29uZmlnLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvZ3JhcGhpYy9taXhpbi9SZWN0VGV4dC5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2NvbnRhaW4vdGV4dC5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2NvcmUvQm91bmRpbmdSZWN0LmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvY29yZS9QYXRoUHJveHkuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9jb3JlL2N1cnZlLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvY29yZS9iYm94LmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvY29udGFpbi9wYXRoLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvY29udGFpbi9saW5lLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvY29udGFpbi9jdWJpYy5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2NvbnRhaW4vcXVhZHJhdGljLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvY29udGFpbi9hcmMuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9jb250YWluL3V0aWwuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9jb250YWluL3dpbmRpbmdMaW5lLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvZ3JhcGhpYy9QYXR0ZXJuLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvdG9vbC90cmFuc2Zvcm1QYXRoLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvZ3JhcGhpYy9HcmFkaWVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL21peGluL0RyYWdnYWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2NvbnRhaW5lci9Hcm91cC5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvSW1hZ2UuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9jb3JlL0xSVS5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvVGV4dC5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvQ2lyY2xlLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9TZWN0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL1JpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL1BvbHlnb24uanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9ncmFwaGljL2hlbHBlci9wb2x5LmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvZ3JhcGhpYy9oZWxwZXIvc21vb3RoU3BsaW5lLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvZ3JhcGhpYy9oZWxwZXIvc21vb3RoQmV6aWVyLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9Qb2x5bGluZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvUmVjdC5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvaGVscGVyL3JvdW5kUmVjdC5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvTGluZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvQmV6aWVyQ3VydmUuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL0FyYy5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvTGluZWFyR3JhZGllbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9ncmFwaGljL1JhZGlhbEdyYWRpZW50LmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tYnBtbi9saWIvRXh0ZW5zaW9uQXBpLmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tY29yZS9saWIvUG9pbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi96cmVuZGVyLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvY29yZS9lbnYuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9IYW5kbGVyLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvU3RvcmFnZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2NvcmUvdGltc29ydC5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2FuaW1hdGlvbi9BbmltYXRpb24uanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9jb3JlL2V2ZW50LmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvYW5pbWF0aW9uL3JlcXVlc3RBbmltYXRpb25GcmFtZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2RvbS9IYW5kbGVyUHJveHkuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9jb3JlL0dlc3R1cmVNZ3IuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9QYWludGVyLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvTGF5ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1icG1uL2xpYi9CcG1uVXRpbC5qcyIsIndlYnBhY2s6Ly8vLi9saWIvZmlzaC10b3BvLWNvcmUvbGliL3V0aWwuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1jb3JlL2xpYi9MaW5lU3RydWN0LmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tYnBtbi9saWIvbm9kZS9CUE1OTm9kZS5qcyIsIndlYnBhY2s6Ly8vLi9saWIvZmlzaC10b3BvLWNvcmUvbGliL05vZGUuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1jb3JlL2xpYi9jbGF6ei5qcyIsIndlYnBhY2s6Ly8vLi9saWIvZmlzaC10b3BvLWJwbW4vbGliL21vZGVsL0JQTU5Nb2RlbC5qcyIsIndlYnBhY2s6Ly8vLi9saWIvZmlzaC10b3BvLWNvcmUvbGliL01vZGVsLmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tYnBtbi9saWIvbm9kZS9ldmVudC9TdGFydEV2ZW50Tm9kZS5qcyIsIndlYnBhY2s6Ly8vLi9saWIvZmlzaC10b3BvLWJwbW4vbGliL25vZGUvZXZlbnQvRXZlbnROb2RlLmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tYnBtbi9saWIvbm9kZS9ldmVudC9FbmRFdmVudE5vZGUuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1icG1uL2xpYi9ub2RlL3Rhc2svVXNlclRhc2tOb2RlLmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tYnBtbi9saWIvbm9kZS90YXNrL1Rhc2tOb2RlLmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tYnBtbi9saWIvbm9kZS90YXNrL01hbnVhbFRhc2tOb2RlLmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tYnBtbi9saWIvbm9kZS90YXNrL1NjcmlwdFRhc2tOb2RlLmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tYnBtbi9saWIvbm9kZS90YXNrL01haWxUYXNrTm9kZS5qcyIsIndlYnBhY2s6Ly8vLi9saWIvZmlzaC10b3BvLWJwbW4vbGliL25vZGUvZXZlbnQvYm91bmRhcnlldmVudC9DYXRjaFRpbWVyRXZlbnROb2RlLmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tYnBtbi9saWIvbm9kZS9ldmVudC9ib3VuZGFyeWV2ZW50L0NhdGNoU2lnbmFsRXZlbnROb2RlLmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tYnBtbi9saWIvbm9kZS9ldmVudC9ib3VuZGFyeWV2ZW50L1Rocm93U2lnbmFsRXZlbnROb2RlLmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tYnBtbi9saWIvbm9kZS9nYXRld2F5L0luY2x1c2l2ZUdhdGV3YXlOb2RlLmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tYnBtbi9saWIvbm9kZS9nYXRld2F5L0dhdGV3YXlOb2RlLmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tYnBtbi9saWIvbm9kZS9nYXRld2F5L0V4Y2x1c2l2ZUdhdGV3YXlOb2RlLmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tYnBtbi9saWIvbm9kZS9nYXRld2F5L1BhcmFsbGVsR2F0ZXdheU5vZGUuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1icG1uL2xpYi9ub2RlL1N1YlByb2Nlc3NOb2RlLmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tY29yZS9saWIvc2hhcGVzL0Nvbm5lY3Rvci5qcyIsIndlYnBhY2s6Ly8vLi9saWIvZmlzaC10b3BvLWNvcmUvbGliL3NoYXBlcy9TeW1ib2wuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1jb3JlL2xpYi9zaGFwZXMvSGFuZGxlLmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tY29yZS9saWIvc2hhcGVzL0VmZmVjdExpbmUuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1jb3JlL2xpYi9zaGFwZXMvQ29ubmVjdGlvblBvaW50LmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tYnBtbi9saWIvQnBtbi5qcyIsIndlYnBhY2s6Ly8vLi9saWIvZmlzaC10b3BvLWJwbW4vbGliL25vZGUvQnBtbk9wZXJhdGlvbk5vZGUuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1jb3JlL2xpYi9tYW5hZ2VyL09wZXJhdGlvbk5vZGUuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1icG1uL2xpYi9tYW5hZ2VyL0JwbW5Db25uZWN0aW9uTWFuYWdlci5qcyIsIndlYnBhY2s6Ly8vLi9saWIvZmlzaC10b3BvLWNvcmUvbGliL21hbmFnZXIvQ29ubmVjdGlvbk1hbmFnZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1jb3JlL2xpYi9Mb2cuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1jb3JlL2xpYi9tYW5hZ2VyL0xpbmVPcGVyYXRpb25NYW5hZ2VyLmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tY29yZS9saWIvbWFuYWdlci9HdWlkZWxpbmVzLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvdm1sL3ZtbC5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL3ZtbC9ncmFwaGljLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvdm1sL2NvcmUuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi92bWwvUGFpbnRlci5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsTztBQ1ZBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVCQUFlO0FBQ2Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FDdENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNMQTtBQUNBO0FBQ0E7QUFDQTs7QUFF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RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWUsNEJBQTRCO0FBQzNDLGdCQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixpQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGlCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsU0FBUztBQUN4QixpQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTJCLFNBQVM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNqWkE7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQSx5REFBd0Q7O0FBRXhEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQSxxQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBLG9CQUFtQixRQUFRO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQSxvQkFBbUIsY0FBYztBQUNqQyxvQkFBbUIsRUFBRTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsU0FBUztBQUN4QixnQkFBZSxTQUFTO0FBQ3hCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7Ozs7OztBQ3BXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBa0I7QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBa0I7QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBa0I7QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1CQUFrQjtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUJBQWtCO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQkFBa0I7QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1CQUFrQjtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFrQjtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUJBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUJBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUJBQWtCO0FBQ2xCO0FBQ0E7O0FBRUEsdUNBQXNDOztBQUV0QyxzQ0FBcUM7O0FBRXJDO0FBQ0E7QUFDQSxvQkFBbUIseUJBQXlCO0FBQzVDO0FBQ0E7QUFDQSx5Q0FBd0M7O0FBRXhDO0FBQ0E7QUFDQSxxQkFBb0I7QUFDcEI7QUFDQTtBQUNBLHdDQUF1Qzs7QUFFdkM7QUFDQTtBQUNBO0FBQ0EscUJBQW9CLE9BQU87QUFDM0IscUJBQW9CLE9BQU87QUFDM0IscUJBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQSxxQkFBb0IsU0FBUztBQUM3QixzQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxxQkFBb0IsT0FBTztBQUMzQixxQkFBb0IsT0FBTztBQUMzQixxQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxxQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFZO0FBQ1o7QUFDQTtBQUNBLG9CQUFtQixRQUFRO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0Esb0JBQW1CLGNBQWM7QUFDakMsb0JBQW1CLEVBQUU7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBLHFCQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUMzUUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOzs7QUFHQTs7QUFFQTs7QUFFQTtBQUNBLG1CQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0EsbUJBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQSxtQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBLG1CQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0EsbUJBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQSxtQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBLG1CQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0EsbUJBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQSxtQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUJBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQSxtQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBLG1CQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1CQUFrQjtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBLG1CQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0EsbUJBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1CQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBa0I7QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW1CLHlCQUF5QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVB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QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBLG9CQUFtQixPQUFPO0FBQzFCLG9CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwwREFBeUQsT0FBTztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLG9CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQ0FBK0IsU0FBUztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQSxvQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQ0FBK0IsU0FBUztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWM7QUFDZDtBQUNBOztBQUVBOzs7Ozs7OztBQ3ZTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWUsVUFBVTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsaUJBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsaUJBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7O0FDdlBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxvQkFBbUIsNEJBQTRCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0Esb0JBQW1CLDRCQUE0QjtBQUMvQyxvQkFBbUIsNEJBQTRCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0Esb0JBQW1CLDRCQUE0QjtBQUMvQyxvQkFBbUIsNEJBQTRCO0FBQy9DLG9CQUFtQiw0QkFBNEI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxvQkFBbUIsNEJBQTRCO0FBQy9DLG9CQUFtQiw0QkFBNEI7QUFDL0Msb0JBQW1CLDRCQUE0QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLG9CQUFtQiw0QkFBNEI7QUFDL0Msb0JBQW1CLDRCQUE0QjtBQUMvQyxvQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0Esb0JBQW1CLDRCQUE0QjtBQUMvQyxvQkFBbUIsNEJBQTRCO0FBQy9DLG9CQUFtQiw0QkFBNEI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0Esb0JBQW1CLDRCQUE0QjtBQUMvQyxvQkFBbUIsNEJBQTRCO0FBQy9DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7Ozs7QUMzSkE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWlCLDRCQUE0QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW1CLE9BQU87QUFDMUIsb0JBQW1CLE9BQU87QUFDMUIscUJBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBLG9CQUFtQixRQUFRO0FBQzNCLG9CQUFtQixRQUFRO0FBQzNCLHFCQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0Esb0JBQW1CLFFBQVE7QUFDM0IscUJBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBLG9CQUFtQixRQUFRO0FBQzNCLG9CQUFtQixPQUFPO0FBQzFCLG9CQUFtQixPQUFPO0FBQzFCLHFCQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQSxvQkFBbUIsUUFBUTtBQUMzQixvQkFBbUIsUUFBUTtBQUMzQixvQkFBbUIsUUFBUTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0Esb0JBQW1CLFFBQVE7QUFDM0Isb0JBQW1CLFFBQVE7QUFDM0Isb0JBQW1CLFFBQVE7QUFDM0Isb0JBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBLG9CQUFtQixRQUFRO0FBQzNCLG9CQUFtQixRQUFRO0FBQzNCLG9CQUFtQixRQUFRO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQSxvQkFBbUIsUUFBUTtBQUMzQixxQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0Esb0JBQW1CLFFBQVE7QUFDM0IscUJBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBLG9CQUFtQixRQUFRO0FBQzNCLG9CQUFtQixRQUFRO0FBQzNCLG9CQUFtQixRQUFRO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQSxvQkFBbUIsUUFBUTtBQUMzQixvQkFBbUIsUUFBUTtBQUMzQixvQkFBbUIsUUFBUTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0Esb0JBQW1CLFFBQVE7QUFDM0Isb0JBQW1CLFFBQVE7QUFDM0IscUJBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBLG9CQUFtQixRQUFRO0FBQzNCLG9CQUFtQixRQUFRO0FBQzNCLG9CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQSxvQkFBbUIsUUFBUTtBQUMzQixvQkFBbUIsUUFBUTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQSxvQkFBbUIsUUFBUTtBQUMzQixvQkFBbUIsUUFBUTtBQUMzQixxQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0Esb0JBQW1CLFFBQVE7QUFDM0Isb0JBQW1CLFFBQVE7QUFDM0IscUJBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0Esb0JBQW1CLFFBQVE7QUFDM0Isb0JBQW1CLFFBQVE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBLG9CQUFtQixRQUFRO0FBQzNCLG9CQUFtQixRQUFRO0FBQzNCLG9CQUFtQixRQUFRO0FBQzNCLG9CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQSxvQkFBbUIsUUFBUTtBQUMzQixvQkFBbUIsUUFBUTtBQUMzQixvQkFBbUIsUUFBUTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ0E7QUFDQSx3QkFBdUIsY0FBYztBQUNyQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3QkFBdUIsa0JBQWtCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFtQyxZQUFZO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBdUMsa0JBQWtCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQ1Q7QUFDQSxtQkFBa0IsT0FBTztBQUN6QixvQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0EsbUJBQWtCLE9BQU87QUFDekIsb0JBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBLG1CQUFrQixPQUFPO0FBQ3pCLG9CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQSxtQkFBa0IsT0FBTztBQUN6QixvQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0EsbUJBQWtCLE9BQU87QUFDekIsb0JBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBLG1CQUFrQixPQUFPO0FBQ3pCLG9CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQSxtQkFBa0IsT0FBTztBQUN6QixvQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0EsbUJBQWtCLE9BQU87QUFDekIsb0JBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBLG1CQUFrQixPQUFPO0FBQ3pCLG9CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQSxtQkFBa0IsT0FBTztBQUN6QixvQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0EsbUJBQWtCLE9BQU87QUFDekIsb0JBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBLG1CQUFrQixPQUFPO0FBQ3pCLG9CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQSxtQkFBa0IsT0FBTztBQUN6QixvQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0EsbUJBQWtCLE9BQU87QUFDekIsb0JBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBLG1CQUFrQixPQUFPO0FBQ3pCLG9CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQSxtQkFBa0IsT0FBTztBQUN6QixvQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0EsbUJBQWtCLE9BQU87QUFDekIsb0JBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBLG1CQUFrQixPQUFPO0FBQ3pCLG9CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQSxtQkFBa0IsT0FBTztBQUN6QixvQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0EsbUJBQWtCLE9BQU87QUFDekIsb0JBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBLG1CQUFrQixPQUFPO0FBQ3pCLG9CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0EsbUJBQWtCLE9BQU87QUFDekIsb0JBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQSxtQkFBa0IsT0FBTztBQUN6QixvQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBLG1CQUFrQixPQUFPO0FBQ3pCLG9CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBLG1CQUFrQixPQUFPO0FBQ3pCLG9CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBLG1CQUFrQixPQUFPO0FBQ3pCLG9CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBLG1CQUFrQixPQUFPO0FBQ3pCLG9CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQSxtQkFBa0IsT0FBTztBQUN6QixvQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBLG1CQUFrQixPQUFPO0FBQ3pCLG9CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7Ozs7QUN0VkE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF1QixPQUFPO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFrQixhQUFhO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBLHFCQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRCQUEyQixpQkFBaUI7QUFDNUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxvQkFBbUIsdUJBQXVCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUEyQixTQUFTO0FBQ3BDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7Ozs7OztBQ2h3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFnQixPQUFPO0FBQ3ZCLGlCQUFnQixPQUFPO0FBQ3ZCLGlCQUFnQixPQUFPO0FBQ3ZCLGlCQUFnQixPQUFPO0FBQ3ZCLGlCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBZ0IsT0FBTztBQUN2QixpQkFBZ0IsT0FBTztBQUN2QixpQkFBZ0IsT0FBTztBQUN2QixpQkFBZ0IsT0FBTztBQUN2QixpQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFnQixPQUFPO0FBQ3ZCLGlCQUFnQixPQUFPO0FBQ3ZCLGlCQUFnQixPQUFPO0FBQ3ZCLGlCQUFnQixPQUFPO0FBQ3ZCLGlCQUFnQixlQUFlO0FBQy9CLGlCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWdCLE9BQU87QUFDdkIsaUJBQWdCLE9BQU87QUFDdkIsaUJBQWdCLE9BQU87QUFDdkIsaUJBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWdCLE9BQU87QUFDdkIsaUJBQWdCLE9BQU87QUFDdkIsaUJBQWdCLE9BQU87QUFDdkIsaUJBQWdCLE9BQU87QUFDdkIsaUJBQWdCLGVBQWU7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxlQUFlO0FBQzlCLGlCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseUJBQXdCLFFBQVE7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXVCLFFBQVE7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7Ozs7Ozs7QUMzaEJBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFlLGNBQWM7QUFDN0IsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW1CLG1CQUFtQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxlQUFlO0FBQzlCLGdCQUFlLGVBQWU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxlQUFlO0FBQzlCLGdCQUFlLGVBQWU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLGVBQWU7QUFDOUIsZ0JBQWUsZUFBZTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLGVBQWU7QUFDOUIsZ0JBQWUsZUFBZTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRCQUEyQixrQkFBa0I7QUFDN0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7O0FDcE9BOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBMkIsWUFBWTtBQUN2Qzs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsOEJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBK0IsWUFBWTtBQUMzQztBQUNBOztBQUVBO0FBQ0Esa0NBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBdUIsT0FBTztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBdUIsaUJBQWlCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDOVlBO0FBQ0E7QUFDQTtBQUNBLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FDdkNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FDdENBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FDcENBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUJBQW9CLE9BQU87QUFDM0IscUJBQW9CLE9BQU87QUFDM0IscUJBQW9CLE9BQU87QUFDM0IscUJBQW9CLE9BQU87QUFDM0IscUJBQW9CLE9BQU87QUFDM0IscUJBQW9CLFFBQVE7QUFDNUIscUJBQW9CLE9BQU87QUFDM0IscUJBQW9CLE9BQU87QUFDM0IscUJBQW9CLE9BQU87QUFDM0IscUJBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQ3pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOzs7Ozs7Ozs7QUNsQkE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7OztBQ2RBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMEIsaUJBQWlCO0FBQzNDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXVCLFlBQVk7QUFDbkM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7Ozs7QUM1RkE7QUFDQSxnQkFB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QUEyQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0EsNEJBQTJCLDJCQUEyQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBLHFCQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRCQUEyQixxQkFBcUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7Ozs7Ozs7QUNuVEE7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF1QyxpQ0FBaUM7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOzs7Ozs7O0FDMUpBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBLG1CQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCLGlCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFnQiw4QkFBOEI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBZ0IsOEJBQThCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0EsbUJBQWtCO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGlCQUFnQixPQUFPO0FBQ3ZCLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDeEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxnQ0FBK0Isc0JBQXNCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7Ozs7Ozs7QUM1SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7O0FBR1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOzs7Ozs7OztBQzdCTDtBQUNBO0FBQ0E7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Q0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7Ozs7Ozs7Ozs7QUN0Q0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDeEZBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7Ozs7Ozs7QUN6REw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQSxxQkFBb0IsT0FBTztBQUMzQixxQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0EscUJBQW9CLE9BQU87QUFDM0IscUJBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOzs7Ozs7OztBQ3JJTDtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxVQUFTOztBQUVUOztBQUVBOztBQUVBO0FBQ0EsVUFBUzs7QUFFVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOzs7Ozs7O0FDL0NMOzs7QUFHQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87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Q0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWMsWUFBWTtBQUMxQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7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a0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNEJBQTJCLFNBQVM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTJCLFNBQVM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTJCLFNBQVM7QUFDcEM7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EscUJBQW9CLE9BQU87QUFDM0IscUJBQW9CLE9BQU87QUFDM0IscUJBQW9CLFFBQVE7QUFDNUIscUJBQW9CLFNBQVM7QUFDN0I7QUFDQSxxQkFBb0IsU0FBUztBQUM3QjtBQUNBLHFCQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7Ozs7Ozs7O0FDelBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLHlFQUF3RTtBQUN4RTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWUsTUFBTTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUNoR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW1CLE1BQU07QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxvQkFBbUIsTUFBTTtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxvQkFBbUIsTUFBTTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0Esb0JBQW1CLE1BQU07QUFDekI7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0Esb0JBQW1CLE1BQU07QUFDekI7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWUsdUJBQXVCO0FBQ3RDO0FBQ0E7QUFDQSx3QkFBdUIsOEJBQThCO0FBQ3JEO0FBQ0E7QUFDQTs7QUFFQSx3QkFBdUIsOEJBQThCO0FBQ3JEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLG1CQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHdCQUF1Qix5QkFBeUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOzs7Ozs7O0FDNVFBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQWtCO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtEQUFpRCxTQUFTO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHNEQUFxRDtBQUNyRCxzREFBcUQ7O0FBRXJEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7OztBQ3RIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBDQUF5QztBQUN6QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxnREFBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFlLFlBQVk7QUFDM0IsZ0JBQWUsdUJBQXVCO0FBQ3RDLGdCQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLG1CQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxtQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFrQjtBQUNsQjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG1CQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0EsbUJBQWtCO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFrQjtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBa0I7QUFDbEIsbUJBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBa0I7QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLHFCQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQSxxQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0Esb0JBQW1CLFFBQVE7QUFDM0I7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLDRCQUEyQix1QkFBdUI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQSw0QkFBMkIsMEJBQTBCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0QkFBMkIsU0FBUztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2IsVUFBUzs7QUFFVDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNkNBQTRDLE9BQU87QUFDbkQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0Esb0JBQW1CLE9BQU87QUFDMUIscUJBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFTOztBQUVUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0QkFBMkIsYUFBYTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXVCLHVCQUF1QjtBQUM5QztBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF1Qix1QkFBdUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBdUIsdUJBQXVCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBLG9CQUFtQiw2QkFBNkI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE0QyxPQUFPO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxvQkFBbUIsT0FBTztBQUMxQixvQkFBbUIsT0FBTztBQUMxQixvQkFBbUIsT0FBTztBQUMxQixvQkFBbUIsT0FBTztBQUMxQixvQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0Esb0JBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBLG9CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQSxvQkFBbUIsT0FBTztBQUMxQixvQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsNEJBQTJCLHdCQUF3QjtBQUNuRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQSxlQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNB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QUFDQSwrQ0FBOEMsT0FBTyxNQUFNLFVBQVUsV0FBVztBQUNoRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4Q0FBNkMsd0JBQXdCO0FBQ3JFOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUErQixZQUFZO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdDQUErQixZQUFZO0FBQzNDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBNkQsYUFBYSxPQUFPO0FBQ2pGLDhCQUE2QixTQUFTLFlBQVksZ0JBQWdCO0FBQ2xFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0Esb0JBQW1CLGlCQUFpQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FDemhDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUM5Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLDJEQUEwRCxnQkFBZ0Isa0JBQWtCLFlBQVksYUFBYTs7QUFFckgsb0RBQW1ELE9BQU8sTUFBTTs7QUFFaEU7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxxQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBLDRCQUEyQixpQkFBaUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBbUIsZ0NBQWdDO0FBQ25EO0FBQ0E7QUFDQTs7QUFFQSIsImZpbGUiOiJmaXNoVG9wb0JwbW4uanMiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShbXSwgZmFjdG9yeSk7XG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJmaXNoVG9wb0JwbW5cIl0gPSBmYWN0b3J5KCk7XG5cdGVsc2Vcblx0XHRyb290W1wiZmlzaFRvcG9CcG1uXCJdID0gZmFjdG9yeSgpO1xufSkodGhpcywgZnVuY3Rpb24oKSB7XG5yZXR1cm4gXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uXG4gKiovIiwiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pXG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG5cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGV4cG9ydHM6IHt9LFxuIFx0XHRcdGlkOiBtb2R1bGVJZCxcbiBcdFx0XHRsb2FkZWQ6IGZhbHNlXG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmxvYWRlZCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiB3ZWJwYWNrL2Jvb3RzdHJhcCA4MDU0YmYzMDM0NjA2MTgxZWViNlxuICoqLyIsIi8qKlxyXG4gKiBFeHBvcnQgZmlzaFRvcG8gYXMgQ29tbW9uSlMgbW9kdWxlXHJcbiAqL1xyXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL2Zpc2gtdG9wby1icG1uL2xpYi9GaXNoVG9wb0JwbW4uanMnKTtcclxuLy/lhbzlrrlJRTgg5byV5YWlVk1MIOWmguaenOS4jemcgOimgeWFvOWuuUlFOOivt+WIoOmZpFxyXG5yZXF1aXJlKCd6cmVuZGVyL2xpYi92bWwvdm1sJyk7XHJcblxyXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vaW5kZXguYnBtbi5qc1xuICoqIG1vZHVsZSBpZCA9IDFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxyXG4gKiBCUE1O5a+56LGhXHJcbiAqIEBjbGFzcyBmaXNoLnRvcG8uRmlzaFRvcG9CcG1uXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEBldmVudCBjbGlja1xyXG4gKiDoioLngrnmiJbogIXnur/mrrXnmoRjbGlja+S6i+S7tlxyXG4gKiBAcGFyYW0ge09iamVjdH0gZXZlbnQg5LqL5Lu2IGV2ZW50LnRhcmdldOS4uuebruagh+WvueixoSBldmVudC50YXJnZXQubW9kZWzkuLrnm67moIflr7nosaHnmoTkuJrliqHmlbDmja5cclxuICpcclxuICogKirkvb/nlKjojIPkvosqKu+8mlxyXG4gKlxyXG4gKiAgICAgIEBleGFtcGxlXHJcbiAqICAgICAgdGhpcy5maXNoVG9wb0JwbW4ub24oXCJjbGlja1wiLGZ1bmN0aW9uKGUpIHtcclxuICogICAgICAgICAgdmFyIHRhcmdldCA9IGUudGFyZ2V0O1xyXG4gKiAgICAgICAgICBpZihGaXNoVG9wb0JwbW4uQnBtbi5pc0Zsb3codGFyZ2V0KSkgeyAvL+WIpOaWreexu+Wei1xyXG4gKiAgICAgICAgICAgICAgdmFyIGxpbmVOb2RlID0gZS50YXJnZXQ7XHJcbiAqICAgICAgICAgICAgICB0aGF0LmZpc2hUb3BvQnBtbi5iaW5kTGluZURlbGV0ZShsaW5lTm9kZSk7IC8v57uZ57q/5q615aKe5Yqg5Yig6Zmk5Zu+5qCHXHJcbiAqICAgICAgICAgICAgICAvL3RvZG9cclxuICogICAgICAgICAgfVxyXG4gKiAgICAgIH1cclxuICovXHJcblxyXG4vKipcclxuICogQGV2ZW50IGRibGNsaWNrXHJcbiAqIOiKgueCueaIluiAhee6v+auteeahOWPjOWHu+S6i+S7tlxyXG4gKiBAcGFyYW0ge09iamVjdH0gZXZlbnQg5LqL5Lu2IGV2ZW50LnRhcmdldOS4uuebruagh+WvueixoSBldmVudC50YXJnZXQubW9kZWzkuLrnm67moIflr7nosaHnmoTkuJrliqHmlbDmja5cclxuICpcclxuICogKirkvb/nlKjojIPkvosqKu+8mlxyXG4gKlxyXG4gKiAgICAgIEBleGFtcGxlXHJcbiAqICAgICAgICAgIC8v5Y+M5Ye75by55Ye66IqC54K55a+55bqU55qEanNvblxyXG4gKiAgICAgICAgICB0aGlzLmZpc2hUb3BvQnBtbi5vbihcImRibGNsaWNrXCIsZnVuY3Rpb24oZSkge1xyXG4gKiAgICAgICAgICAgICAgdmFyIHRhcmdldCA9IGUudGFyZ2V0O1xyXG4gKlxyXG4gKiAgICAgICAgICAgICAgaWYoRmlzaFRvcG9CcG1uLkJwbW4uaXNGbG93KHRhcmdldCkpIHtcclxuICogICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcImRibGNsaWNrIGxpbmVcIik7XHJcbiAqICAgICAgICAgICAgICB9XHJcbiAqICAgICAgICAgICAgICBlbHNle1xyXG4gKiAgICAgICAgICAgICAgICAgIHZhciBqc29uID0gbm9kZU1vZGVsLm9wdGlvbjtcclxuICogICAgICAgICAgICAgICAgICBmaXNoLnBvcHVwVmlldyh7XHJcbiAqICAgICAgICAgICAgICAgICAgICAgIHVybDogXCJ2aWV3cy9kaWFsb2cvRXhwb3J0SnNvbkRsZy5qc1wiLFxyXG4gKiAgICAgICAgICAgICAgICAgICAgICB2aWV3T3B0aW9uOnticG1uSnNvbjpKU09OLnN0cmluZ2lmeShqc29uLG51bGwsNCl9LFxyXG4gKiAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjazogZnVuY3Rpb24ocG9wdXAsdmlldykge1xyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJPS1wiKTtcclxuICogICAgICAgICAgICAgICAgICAgICAgfSxcclxuICogICAgICAgICAgICAgICAgICAgICAgY2xvc2U6IGZ1bmN0aW9uKG1zZykge1xyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJyZXR1cm4gdmFsdWU6IFwiICsgbXNnKTtcclxuICogICAgICAgICAgICAgICAgICAgICAgfVxyXG4gKiAgICAgICAgICAgICAgICAgIH0pO1xyXG4gKiAgICAgICAgICAgICAgfVxyXG4gKiAgICAgICAgICB9KTtcclxuICovXHJcblxyXG4vKipcclxuICogQGV2ZW50IGNyZWF0ZVxyXG4gKiDoioLngrnkuI7nur/mrrXliJvlu7rlrozmr5XnmoTkuovku7ZcclxuICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IOS6i+S7tiBldmVudC50YXJnZXTkuLrnm67moIflr7nosaEgZXZlbnQudGFyZ2V0Lm1vZGVs5Li655uu5qCH5a+56LGh55qE5Lia5Yqh5pWw5o2uXHJcbiAqXHJcbiAqICoq5L2/55So6IyD5L6LKirvvJpcclxuICpcclxuICogICAgICBAZXhhbXBsZVxyXG4gKiAgICAgICAgICB0aGlzLmZpc2hUb3BvQnBtbi5vbihcImNyZWF0ZVwiLCBmdW5jdGlvbihlKSB7XHJcbiAqICAgICAgICAgICAgICBpZihGaXNoVG9wb0JwbW4uQnBtbi5pc0Zsb3coZS50YXJnZXQpKSB7XHJcbiAqICAgICAgICAgICAgICAgICAgdmFyIGxpbmUgPSBlLnRhcmdldDtcclxuICogICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIui/nue6v+WIm+W7uuWujOavle+8jOS7jlwiICsgbGluZS5zdGFydE5vZGUubW9kZWwuZ2V0KFwicHJvcGVydGllcy5uYW1lXCIpICsgXCIg6IezIFwiICsgbGluZS5lbmROb2RlLm1vZGVsLmdldChcInByb3BlcnRpZXMubmFtZVwiKSk7XHJcbiAqICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gKiAgICAgICAgICAgICAgICAgIHZhciBub2RlID0gZS50YXJnZXQ7XHJcbiAqICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCLoioLngrnvvJpcIiArIG5vZGUubW9kZWwuZ2V0KFwicHJvcGVydGllcy5uYW1lXCIpICsgXCIg5Yib5bu65a6M5q+VXCIpO1xyXG4gKiAgICAgICAgICAgICAgfVxyXG4gKiAgICAgICAgICB9KTtcclxuICovXHJcblxyXG4vKipcclxuICogQGV2ZW50IGRlbGV0ZVxyXG4gKiDoioLngrnkuI7nur/mrrXliJvlu7rlrozmr5XnmoTkuovku7ZcclxuICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IOS6i+S7tiBldmVudC50YXJnZXTkuLrnm67moIflr7nosaEgZXZlbnQudGFyZ2V0Lm1vZGVs5Li655uu5qCH5a+56LGh55qE5Lia5Yqh5pWw5o2uXHJcbiAqXHJcbiAqICoq5L2/55So6IyD5L6LKirvvJpcclxuICpcclxuICogICAgICBAZXhhbXBsZVxyXG4gKiAgICAgICAgICAvL+iKgueCueWIoOmZpOWujOavleS6i+S7tlxyXG4gKiAgICAgICAgICB0aGlzLmZpc2hUb3BvQnBtbi5vbihcImRlbGV0ZVwiLCBmdW5jdGlvbihldmVudCkge1xyXG4gKiAgICAgICAgICAgICAgY29uc29sZS5sb2coXCLliKDpmaTnmoTmmK/vvJpcIiArIGV2ZW50LnRhcmdldCk7XHJcbiAqICAgICAgICAgIH0pO1xyXG4gKi9cclxuXHJcblxyXG4gICAgdmFyIGdyYXBoaWMgPSByZXF1aXJlKFwiLi4vLi4vZmlzaC10b3BvLWNvcmUvbGliL2dyYXBoaWMuanNcIik7XHJcbiAgICB2YXIgRXh0ZW5zaW9uQVBJID0gcmVxdWlyZSgnLi9FeHRlbnNpb25BcGknKTtcclxuICAgIHZhciBQb2ludCA9IHJlcXVpcmUoXCIuLi8uLi9maXNoLXRvcG8tY29yZS9saWIvUG9pbnQuanNcIik7XHJcbiAgICB2YXIgRXZlbnRmdWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9taXhpbi9FdmVudGZ1bCcpO1xyXG4gICAgdmFyIHpyZW5kZXIgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi96cmVuZGVyJyk7XHJcbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XHJcbiAgICB2YXIgQm91bmRpbmdSZWN0ID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS9Cb3VuZGluZ1JlY3QuanMnKTtcclxuICAgIHZhciBCcG1uVXRpbCA9IHJlcXVpcmUoXCIuL0JwbW5VdGlsLmpzXCIpO1xyXG4gICAgdmFyIHV0aWwgPSByZXF1aXJlKFwiLi4vLi4vZmlzaC10b3BvLWNvcmUvbGliL3V0aWwuanNcIik7XHJcbiAgICB2YXIgQlBNTk1vZGVsID0gcmVxdWlyZShcIi4vbW9kZWwvQlBNTk1vZGVsLmpzXCIpO1xyXG4gICAgdmFyIEJQTU5Ob2RlID0gcmVxdWlyZShcIi4vbm9kZS9CUE1OTm9kZS5qc1wiKTtcclxuICAgIHZhciBPcGVyYXRpb25Ob2RlID0gcmVxdWlyZShcIi4vbm9kZS9CcG1uT3BlcmF0aW9uTm9kZS5qc1wiKTtcclxuICAgIHZhciBCcG1uQ29ubmVjdGlvbk1hbmFnZXIgPSByZXF1aXJlKFwiLi9tYW5hZ2VyL0JwbW5Db25uZWN0aW9uTWFuYWdlci5qc1wiKTtcclxuICAgIHZhciBDb25uZWN0b3IgPSByZXF1aXJlKFwiLi4vLi4vZmlzaC10b3BvLWNvcmUvbGliL3NoYXBlcy9Db25uZWN0b3IuanNcIik7XHJcbiAgICB2YXIgTGluZU9wZXJhdGlvbk1hbmFnZXIgPSByZXF1aXJlKFwiLi4vLi4vZmlzaC10b3BvLWNvcmUvbGliL21hbmFnZXIvTGluZU9wZXJhdGlvbk1hbmFnZXIuanNcIik7XHJcbiAgICB2YXIgR3VpZGVsaW5lcyA9IHJlcXVpcmUoXCIuLi8uLi9maXNoLXRvcG8tY29yZS9saWIvbWFuYWdlci9HdWlkZWxpbmVzLmpzXCIpO1xyXG4gICAgdmFyIEJwbW4gPSByZXF1aXJlKFwiLi9CcG1uLmpzXCIpO1xyXG5cclxuICAgIGZ1bmN0aW9uIEZpc2hUb3BvQnBtbihkb20sIG9wdHMpIHtcclxuICAgICAgICB0aGlzLmlkO1xyXG4gICAgICAgIHRoaXMuZ3JvdXA7XHJcbiAgICAgICAgdGhpcy5fZG9tID0gZG9tO1xyXG4gICAgICAgIHRoaXMuX3pyID0genJlbmRlci5pbml0KGRvbSwge1xyXG4gICAgICAgICAgICByZW5kZXJlcjogb3B0cy5yZW5kZXJlciB8fCAnY2FudmFzJyxcclxuICAgICAgICAgICAgZGV2aWNlUGl4ZWxSYXRpbzogb3B0cy5kZXZpY2VQaXhlbFJhdGlvXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5hbGxOb2RlcyA9IFtdOyAvL+WtmOaUvuaJgOacieiKgueCuVxyXG4gICAgICAgIHRoaXMuc3ViUHJvY2Vzc05vZGUgPSBbXTsgIC8v5a2Y5pS+5a2Q6IqC54K5XHJcbiAgICAgICAgdGhpcy5kb21BcnJheSA9IFtdOyAvL+WtmOaUvuiKgueCueeahOS9jee9ruS/oeaBr++8jOaLluWKqOeahOaXtuWAmeeUqOWIsFxyXG4gICAgICAgIHRoaXMub3ZlcmxhcEFycmF5ID0gW107IC8vIOWtmOaUvuiKgueCueeahOS9jee9ruS/oeaBr++8jOWIpOaWremHjeWPoOeUqOWIsO+8jOmZpOWOu+S6huWtkOa1geeoi+mHjOmdoueahOiKgueCuVxyXG4gICAgICAgIHRoaXMuc2VsZWN0ZWROb2RlID0gbnVsbDsgIC8v6YCJ5Lit55qE6IqC54K5XHJcbiAgICAgICAgdGhpcy5pc05vZGUgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLnJlY3Q7ICAvLyDlr7npvZDnur/lkoznp7vliqjmoYboioLngrlcclxuICAgICAgICB0aGlzLm9wZXJhdGlvbk5vZGU7XHJcbiAgICAgICAgdGhpcy5zdGVwID0gMDsvL+WJjei/m+WQjumAgOiuoeatpeaVsFxyXG4gICAgICAgIHRoaXMuc3RlcEpzb24gPSBbXTsvL+WtmOaUvuavj+atpeeahGpzb25cclxuICAgICAgICB0aGlzLm9wdHMgPSBvcHRzO1xyXG4gICAgICAgIHRoaXMuX2FwaSA9IG5ldyBFeHRlbnNpb25BUEkodGhpcyk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQGNmZyB7Qm9vbGVhbn0gZm9yYmlkRWRpdCDmmK/lkKbnpoHnlKjnvJbovpHlip/og71cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmZvcmJpZEVkaXQgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgdGhpcy5tb2RlbCA9IG5ldyBCUE1OTW9kZWwoe30pO1xyXG4gICAgICAgIHRoaXMubW9kZWwuc2V0KEJwbW4uUkVTT1VSQ0VfSUQsIHV0aWwuZ2V0VVVJRCgpKTtcclxuICAgICAgICB0aGlzLm1vZGVsLnNldChCcG1uLkJQTU5fVFlQRSwgQnBtbi5URU1QTEFURSk7XHJcbiAgICAgICAgRXZlbnRmdWwuY2FsbCh0aGlzKTtcclxuICAgICAgICBCcG1uVXRpbC5yZWdpc3RlckJQTU5Ob2RlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGZpc2hUb3BvUHJvdG8gPSBGaXNoVG9wb0JwbW4ucHJvdG90eXBlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICog6I635Y+WIGZpc2hUb3BvIOWunuS+i+WuueWZqOeahCBkb20g6IqC54K5XHJcbiAgICAgKiBAcmV0dXJuIHtIVE1MRWxlbWVudH1cclxuICAgICAqL1xyXG4gICAgZmlzaFRvcG9Qcm90by5nZXREb20gPSBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZG9tO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIGZpc2hUb3BvUHJvdG8uZ2V0WnIgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fenI7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiDojrflj5YgZmlzaFRvcG8g5a6e5L6L5a655Zmo55qE5a695bqm44CCXHJcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIGZpc2hUb3BvUHJvdG8uZ2V0V2lkdGggPSBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fenIuZ2V0V2lkdGgoKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDojrflj5YgZmlzaFRvcG8g5a6e5L6L5a655Zmo55qE6auY5bqm44CCXHJcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIGZpc2hUb3BvUHJvdG8uZ2V0SGVpZ2h0ID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3pyLmdldEhlaWdodCgpO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDlvZPliY3lrp7kvovmmK/lkKblt7Lnu4/ooqvph4rmlL7jgIJcclxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIGZpc2hUb3BvUHJvdG8uaXNEaXNwb3NlZCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9kaXNwb3NlZDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEaXNwb3NlIGluc3RhbmNlXHJcbiAgICAgKi9cclxuICAgIGZpc2hUb3BvUHJvdG8uZGlzcG9zZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHRoaXMuX2Rpc3Bvc2VkID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgdGhpcy5fenIuZGlzcG9zZSgpO1xyXG5cclxuICAgICAgICBpbnN0YW5jZXNbdGhpcy5pZF0gPSBudWxsO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDosIPmlbTlsLrlr7ggIOWcqOeql+WPo+Wkp+Wwj+WPkeeUn+aUueWPmOaXtumcgOimgeaJi+W3peiwg+eUqFxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIOWuveW6plxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCDpq5jluqZcclxuICAgICAqL1xyXG4gICAgZmlzaFRvcG9Qcm90by5yZXNpemUgPSBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0KSB7XHJcbiAgICAgICAgJCh0aGlzLmdldERvbSgpKS5jc3MoXCJ3aWR0aFwiLCB3aWR0aCk7XHJcbiAgICAgICAgJCh0aGlzLmdldERvbSgpKS5jc3MoXCJoZWlnaHRcIiwgaGVpZ2h0KTtcclxuICAgICAgICB0aGlzLl96ci5yZXNpemUoKTtcclxuICAgICAgICB0aGlzLl96ci5yZW1vdmUodGhpcy5ncm91cCk7XHJcbiAgICAgICAgdGhpcy5ncm91cCA9IG5ldyBncmFwaGljLkdyb3VwKCk7XHJcbiAgICAgICAgdGhpcy5ncmlkTGluZSgwLjIpO1xyXG4gICAgICAgIHRoaXMuX3pyLmFkZCh0aGlzLmdyb3VwKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqIEBwcml2YXRlIOWIneWni+WMliAqL1xyXG4gICAgZmlzaFRvcG9Qcm90by5pbml0ID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMuZ3JvdXAgPSBuZXcgZ3JhcGhpYy5Hcm91cCgpO1xyXG4gICAgICAgIGlmICh0aGlzLm9wdHMuc2hvd0dyaWRMaW5lID09IHRydWUgfHwgb3B0cy5zaG93R3JpZExpbmUgPT0gXCJ0cnVlXCIpIHtcclxuICAgICAgICAgICAgdGhpcy5ncmlkTGluZSgwLjIpO1xyXG4gICAgICAgICAgICB0aGlzLl96ci5hZGQodGhpcy5ncm91cCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL21vdXNldXAg5Lya5Zyo5ZCE5Liqbm9kZeaIlue6v+eahOeCueWHu+S6i+S7tuS5i+WJjeaJp+ihjCAg5Zyo6YCJ5Lit6IqC54K55oiW57q/5YmNIOWFiOa4heepuumAieS4reaViOaenFxyXG4gICAgICAgIHRoaXMuX3pyLm9uKFwibW91c2V1cFwiLCBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGF0Lm9wZXJhdGlvbk5vZGUpIHtcclxuICAgICAgICAgICAgICAgIHRoYXQuX3pyLnJlbW92ZSh0aGF0Lm9wZXJhdGlvbk5vZGUpO1xyXG4gICAgICAgICAgICAgICAgdGhhdC5vcGVyYXRpb25Ob2RlID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgc2hhcGUgPSBlLnRhcmdldDtcclxuICAgICAgICAgICAgaWYgKHNoYXBlICYmIHNoYXBlLmNvbm5lY3RvciBpbnN0YW5jZW9mIENvbm5lY3Rvcikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIEJwbW5Db25uZWN0aW9uTWFuYWdlci5jbGVhclNlbGVjdENvbigpO1xyXG4gICAgICAgICAgICBpZiAoc2hhcGUgJiYgc2hhcGUub3BlcmF0aW9uICYmIHNoYXBlLm9wZXJhdGlvbiA9PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgTGluZU9wZXJhdGlvbk1hbmFnZXIuaGlkZUFsbExpbmVPcGVyYXRpb24oKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICAvL+a0vuWPkeS4jeaYr+iKgueCueaIlue6vyDnmoTnlLvluIPngrnlh7vkuovku7ZcclxuICAgICAgICB0aGlzLl96ci5vbihcImNsaWNrXCIsIGZ1bmN0aW9uKGUpIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBzaGFwZSA9IGUudGFyZ2V0O1xyXG4gICAgICAgICAgICAvL+eCueWHu+eahOe6v1xyXG4gICAgICAgICAgICBpZiAoc2hhcGUgJiYgc2hhcGUucGFyZW50ICYmIHNoYXBlLnBhcmVudC5yZXNvdXJjZUlkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcGFyYW1zID0ge307XHJcbiAgICAgICAgICAgICAgICBwYXJhbXMuZXZlbnQgPSBlO1xyXG4gICAgICAgICAgICAgICAgcGFyYW1zLnR5cGUgPSBcImNsaWNrXCI7XHJcbiAgICAgICAgICAgICAgICBwYXJhbXMudGFyZ2V0ID0gdGhhdDtcclxuICAgICAgICAgICAgICAgIHRoYXQuX2FwaS50cmlnZ2VyKHBhcmFtcy50eXBlLCBwYXJhbXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5vbignY29uUG9pbnRzR3JvdXA6Y2xpY2snLCBmdW5jdGlvbihhcmd1bWVudCkge1xyXG4gICAgICAgICAgICBMaW5lT3BlcmF0aW9uTWFuYWdlci5iaW5kT3BlcmF0aW9uKGFyZ3VtZW50LmxpbmVOb2RlKTtcclxuICAgICAgICB9KVxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIOagueaNruS8oOi/h+adpeeahOWAvCAg6K6+572u6IqC54K55qih5Z6LXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc2hhcGUgIOiKgueCueaIlue6v1xyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbiDmqKHlnovmlbDmja5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCDlrr3luqYo5LuF55So5LqO6LCD5pW055S75biD5aSn5bCPKVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCDpq5jluqYo5LuF55So5LqO6LCD5pW055S75biD5aSn5bCPKVxyXG4gICAgICovXHJcbiAgICBmaXNoVG9wb1Byb3RvLnNldFNoYXBlTW9kZWwgPSBmdW5jdGlvbihzaGFwZSwgb3B0aW9uLCB3aWR0aCwgaGVpZ2h0KSB7XHJcbiAgICAgICAgaWYgKEJwbW4uaXNUZW1wbGF0ZShzaGFwZSkpIHtcclxuICAgICAgICAgICAgdGhpcy5tb2RlbC5tZXJnZU9wdGlvbihvcHRpb24pO1xyXG4gICAgICAgICAgICBpZiAod2lkdGggPiAwICYmIGhlaWdodCA+IDApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVzaXplKHdpZHRoLCBoZWlnaHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIGlmIChCcG1uLmlzRmxvdyhzaGFwZSkpIHtcclxuICAgICAgICAgICAgQnBtbkNvbm5lY3Rpb25NYW5hZ2VyLnNldE1vZGVsKHNoYXBlLCBvcHRpb24pO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHNoYXBlLnNldE1vZGVsKG9wdGlvbik7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIOa4heepuuW9k+WJjeWunuS+i++8jOS8muenu+mZpOWunuS+i+S4reaJgOacieeahOiKgueCueS4jue6v1xyXG4gICAgICogQG1ldGhvZCBjbGVhclxyXG4gICAgICovXHJcbiAgICBmaXNoVG9wb1Byb3RvLmNsZWFyID0gZnVuY3Rpb24oaXNOb0NvdW50KSB7XHJcbiAgICAgICAgdGhpcy5hbGxOb2RlcyA9IFtdO1xyXG5cclxuICAgICAgICB0aGlzLnN1YlByb2Nlc3NOb2RlID0gW107XHJcblxyXG4gICAgICAgIHRoaXMuZG9tQXJyYXkgPSBbXTtcclxuXHJcbiAgICAgICAgdGhpcy5vdmVybGFwQXJyYXkgPSBbXTtcclxuXHJcbiAgICAgICAgdGhpcy5zZWxlY3RlZE5vZGUgPSBudWxsO1xyXG4gICAgICAgIHRoaXMucmVjdCA9IG51bGw7XHJcbiAgICAgICAgQnBtbkNvbm5lY3Rpb25NYW5hZ2VyLmNvbm5lY3RvcnMgPSBbXTtcclxuICAgICAgICB0aGlzLl96ci5jbGVhcigpO1xyXG4gICAgICAgIHRoaXMuX3pyLmFkZCh0aGlzLmdyb3VwKTsgLy8g55S7572R5qC857q/ICDku6PnoIHmlL7ov5nmr5TovoPmgbblv4Mg5ZCO6Z2i5pS5XHJcbiAgICAgICAgaWYgKGlzTm9Db3VudCAhPSB0cnVlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3RlcENvdW50ZXIoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICog6K6+572u5piv5ZCm5pi+56S6572R57uc57q/XHJcbiAgICAgKiBAcGFyYW0gIHtCb29sZWFufSBpc0ZvcmJpZGRlbiDmmK/lkKbmmL7npLrnvZHnu5znur9cclxuICAgICAqL1xyXG4gICAgZmlzaFRvcG9Qcm90by5mb3JiaWRHcmlkTGluZSA9IGZ1bmN0aW9uKGlzRm9yYmlkZGVuKSB7XHJcbiAgICAgICAgaWYgKGlzRm9yYmlkZGVuID09IHRydWUpIHtcclxuICAgICAgICAgICAgdGhpcy5fenIucmVtb3ZlKHRoaXMuZ3JvdXApO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3pyLnJlbW92ZSh0aGlzLmdyb3VwKTtcclxuICAgICAgICAgICAgdGhpcy5ncm91cCA9IG5ldyBncmFwaGljLkdyb3VwKCk7XHJcbiAgICAgICAgICAgIHRoaXMuZ3JpZExpbmUoMC4yKTtcclxuICAgICAgICAgICAgdGhpcy5fenIuYWRkKHRoaXMuZ3JvdXApO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDlr7zlh7pqc29uXHJcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IGpzb27lrZfnrKbkuLJcclxuICAgICAqL1xyXG4gICAgZmlzaFRvcG9Qcm90by50b0pzb24gPSBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gQnBtblV0aWwudG9Kc29uKHRoaXMubW9kZWwsIHRoaXMuYWxsTm9kZXMsIEJwbW5Db25uZWN0aW9uTWFuYWdlci5jb25uZWN0b3JzKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDlr7zlhaVqc29uXHJcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9IGpzb24ganNvbuagvOW8j+eahOWtl+espuS4slxyXG4gICAgICovXHJcbiAgICBmaXNoVG9wb1Byb3RvLmZyb21Kc29uID0gZnVuY3Rpb24oanNvbikge1xyXG4gICAgICAgIEJwbW5VdGlsLmZyb21Kc29uKHRoaXMsIGpzb24pO1xyXG4gICAgfTtcclxuXHJcbiAgICAvL+iDjOaZr+e9keagvOe6v1xyXG4gICAgZmlzaFRvcG9Qcm90by5ncmlkTGluZSA9IGZ1bmN0aW9uKG9wYWNpdHkpIHtcclxuICAgICAgICB2YXIgcGl4ZWwgPSB0aGlzLm9wdHMuZ3JpZExpbmVTcGFjaW5nO1xyXG4gICAgICAgIHZhciB3aWR0aExlbiA9IHBhcnNlSW50KHRoaXMuZ2V0V2lkdGgoKSAvIHBpeGVsKTtcclxuICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8PSB3aWR0aExlbjsgeCsrKSB7XHJcbiAgICAgICAgICAgIHZhciBsaW5lWCA9IG5ldyBncmFwaGljLkxpbmUoe1xyXG4gICAgICAgICAgICAgICAgc2hhcGU6IHtcclxuICAgICAgICAgICAgICAgICAgICB4MTogeCAqIHBpeGVsLFxyXG4gICAgICAgICAgICAgICAgICAgIHkxOiAwLFxyXG4gICAgICAgICAgICAgICAgICAgIHgyOiB4ICogcGl4ZWwsXHJcbiAgICAgICAgICAgICAgICAgICAgeTI6IHRoaXMuZ2V0SGVpZ2h0KClcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBzdHlsZToge1xyXG4gICAgICAgICAgICAgICAgICAgIGxpbmVEYXNoOiBbMV0sXHJcbiAgICAgICAgICAgICAgICAgICAgb3BhY2l0eTogb3BhY2l0eVxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHo6IDAsXHJcbiAgICAgICAgICAgICAgICBkcmFnZ2FibGU6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgY3Vyc29yOiAnZGVmYXVsdCdcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHRoaXMuZ3JvdXAuYWRkKGxpbmVYKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBoZWlnaHRMZW4gPSBwYXJzZUludCh0aGlzLmdldEhlaWdodCgpIC8gcGl4ZWwsIHBpeGVsKTtcclxuICAgICAgICBmb3IgKHZhciB5ID0gMDsgeSA8PSBoZWlnaHRMZW47IHkrKykge1xyXG4gICAgICAgICAgICB2YXIgbGluZVkgPSBuZXcgZ3JhcGhpYy5MaW5lKHtcclxuICAgICAgICAgICAgICAgIHNoYXBlOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgeDE6IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgeTE6IHkgKiBwaXhlbCxcclxuICAgICAgICAgICAgICAgICAgICB4MjogdGhpcy5nZXRXaWR0aCgpLFxyXG4gICAgICAgICAgICAgICAgICAgIHkyOiB5ICogcGl4ZWxcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBzdHlsZToge1xyXG4gICAgICAgICAgICAgICAgICAgIGxpbmVEYXNoOiBbMV0sXHJcbiAgICAgICAgICAgICAgICAgICAgb3BhY2l0eTogb3BhY2l0eVxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHo6IDAsXHJcbiAgICAgICAgICAgICAgICBkcmFnZ2FibGU6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgY3Vyc29yOiAnZGVmYXVsdCdcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHRoaXMuZ3JvdXAuYWRkKGxpbmVZKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIOmAmui/h+eVjOmdouaLluWKqCDlop7liqDoioLngrlcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpdGVtVHlwZSDliJvlu7roioLngrnnmoTnsbvlnovvvIjlt7LmnInpooTlrprkuYnnsbvlnovljIXmi6xTdGFydE5vbmVFdmVudOOAgUVuZE5vbmVFdmVudOOAgVVzZXJUYXNr44CBTWFudWFsVGFza+OAgVNjcmlwdFRhc2vjgIFNYWlsVGFza+OAgUNhdGNoVGltZXJFdmVudOOAgUNhdGNoU2lnbmFsRXZlbnTjgIFUaHJvd1NpZ25hbEV2ZW5044CBSW5jbHVzaXZlR2F0ZXdheeOAgUV4Y2x1c2l2ZUdhdGV3YXnjgIFQYXJhbGxlbEdhdGV3YXnjgIFTdWJQcm9jZXNz77yJXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCAgICAgICAg6IqC54K55Yib5bu655qEeOWdkOagh1xyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgICAgICAgIOiKgueCueWIm+W7uueahHnlnZDmoIdcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIOmAiemhuVxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLm5hbWVdIOiKgueCueS4i+mdouaYvuekuuWQjeensFxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gW29wdGlvbnMub3BlcmF0aW9uSWNvbnNdIOiuvue9rumAieS4reiKgueCueaXtiDmmL7npLrnmoTmk43kvZzlsI/lm77moIfvvIwg6buY6K6k5o+Q5L6b5LqGIOWIoOmZpOOAgeebtOe6v+OAgeaKmOe6v+OAgeabsue6vzTnp43lm77moIfvvIzkuZ/lj6/ku6Xoh6rlrprlm77moIcgZWcuXHJcbiAgICAgKiA8cHJlPlxyXG4gICAgICogICAgICAgICAgb3BlcmF0aW9uSWNvbnM6IFt7IG5hbWU6ICdERUwnIH0sXHJcbiAgICAgKiAgICAgICAgICAgICAgeyBuYW1lOiAnU1RSQUlHSFQnIH0sXHJcbiAgICAgKiAgICAgICAgICAgICAgeyBuYW1lOiAnSkFHR0VEJyB9LFxyXG4gICAgICogICAgICAgICAgICAgIHsgbmFtZTogJ0NVUlZFJyB9LFxyXG4gICAgICogICAgICAgICAgICAgIHtcclxuICAgICAqICAgICAgICAgICAgICAgICAgbmFtZTogXCJjdXN0b20xXCIsXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgIGljb25QYXRoOiBcImltZy9ob3N0LnBuZ1wiLFxyXG4gICAgICogICAgICAgICAgICAgICAgICBjYWxsYmFjazogZnVuY3Rpb24oZSkgeyBhbGVydChlLmRhdGEubmFtZSArIFwiIGNsaWNrZWRcIikgfSAgLy9lLm5vZGXmmK/lvZPliY3nmoToioLngrlcclxuICAgICAqICAgICAgICAgICAgICB9XHJcbiAgICAgKiAgICAgICAgICBdXHJcbiAgICAgKiA8L3ByZT5cclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB1c2VyRGF0YSDnlKjmiLfkvKDpgJLnmoTkuJrliqHmlbDmja5cclxuICAgICAqXHJcbiAgICAgKiAqKuS9v+eUqOiMg+S+iyoq77yaXHJcbiAgICAgKlxyXG4gICAgICogICAgICBAZXhhbXBsZVxyXG4gICAgICogICAgICBmaXNoVG9wby5hZGROb2RlKGl0ZW1UeXBlLCB4LCB5LCB7XHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBpdGVtVHlwZSwgICAvL+iKgueCueeahOWQjeensFxyXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uSWNvbnM6W3tuYW1lOidERUwnfSx7IG5hbWU6ICdTVFJBSUdIVCcgfSx7bmFtZTonSkFHR0VEJ30seyBuYW1lOiAnQ1VSVkUnIH1dLFxyXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgLy8g5aKe5Yqg6IqC54K55pON5L2c5Zu+5qCHIOS4iumdouWIhuWIq+aYr1wi5Yig6Zmk44CB55u057q/44CB5oqY57q/44CB5puy57q/XCLvvIxcclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgIC8vIOS5n+WPr+S7peWinuWKoOiHquWumuWbvuaghyDlpoJ7bmFtZTogXCJjdXN0b20xXCIsIGljb25QYXRoOiBcImltZy9ob3N0LnBuZ1wiLCBjYWxsYmFjazogZnVuY3Rpb24oZSkgeyBhbGVydChlLmRhdGEubmFtZSArIFwiIGNsaWNrZWRcIikgfX0gLy9lLm5vZGXmmK/lvZPliY3nmoToioLngrlcclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgIHVzZXJEYXRhOntidXNpbmVzc0RhdGE6J+aIkeaYr+S4muWKoeaVsOaNrizpgJrov4dCcG1uLmdldFVzZXJEYXRh5Y+v6I635Y+WJ31cclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgIC8vIOWinuWKoOiKgueCueeahOiHquWumuS5ieS4muWKoe+8jOWPr+S7pemAmui/h0JwbW4uZ2V0VXNlckRhdGEobm9kZSnojrflj5ZcclxuICAgICAqICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgKi9cclxuICAgIGZpc2hUb3BvUHJvdG8uYWRkTm9kZSA9IGZ1bmN0aW9uKGl0ZW1UeXBlLCB4LCB5LCBvcHRpb25zKSB7XHJcblxyXG4gICAgICAgIC8v5Yik5pat5piv5ZCm5Zyo6IyD5Zu05YaFXHJcbiAgICAgICAgaWYgKHggPj0gMCAmJiB5ID49IDApIHtcclxuICAgICAgICAgICAgdmFyIG1vZGVsID0gbmV3IEJQTU5Nb2RlbCh7fSk7XHJcbiAgICAgICAgICAgIG1vZGVsLnNldChCcG1uLkJQTU5fVFlQRSwgaXRlbVR5cGUpO1xyXG4gICAgICAgICAgICBtb2RlbC5zZXQoXCJib3VuZHMudXBwZXJMZWZ0XCIsIHt4OiB4LCB5OiB5fSk7XHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zKSB7XHJcbiAgICAgICAgICAgICAgICBtb2RlbC5zZXQoXCJwcm9wZXJ0aWVzXCIsIG9wdGlvbnMpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hZGROb2RlQnlNb2RlbChtb2RlbCwgdHJ1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIOagueaNruaooeWei+WinuWKoOiKgueCuVxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtb2RlbCBbZGVzY3JpcHRpb25dXHJcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IOWIm+W7uuWujOaIkOeahOiKgueCuVxyXG4gICAgICovXHJcbiAgICBmaXNoVG9wb1Byb3RvLmFkZE5vZGVCeU1vZGVsID0gZnVuY3Rpb24obW9kZWwsIGlzRnJvbURyYWcsIGlzTm9Db3VudCkge1xyXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgICAgICB2YXIgU2hhcGUgPSBCUE1OTm9kZS5nZXRDbGFzcyhtb2RlbC5nZXQoQnBtbi5CUE1OX1RZUEUpKTtcclxuICAgICAgICB2YXIgbWVzQXJyYXk7XHJcbiAgICAgICAgaWYgKFNoYXBlKSB7XHJcbiAgICAgICAgICAgIHZhciBub2RlID0gbmV3IFNoYXBlKG1vZGVsLCB0aGlzLl9hcGkpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5zdWJQcm9jZXNzTm9kZS5sZW5ndGggPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fenIuYWRkKG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgbWVzQXJyYXkgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWQ6IG5vZGUuaWQsXHJcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IFtub2RlLmdldFJlY3QoKS54LCBub2RlLmdldFJlY3QoKS55XSxcclxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogbm9kZS5nZXRSZWN0KCkud2lkdGgsXHJcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBub2RlLmdldFJlY3QoKS5oZWlnaHRcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBpZiAoIUJwbW4uaXNTbG90RXZlbnQobm9kZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm92ZXJsYXBBcnJheS5wdXNoKG1lc0FycmF5KTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl96ci5hZGQobm9kZSk7XHJcbiAgICAgICAgICAgICAgICBtZXNBcnJheSA9IHtcclxuICAgICAgICAgICAgICAgICAgICBpZDogbm9kZS5pZCxcclxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogW25vZGUuZ2V0UmVjdCgpLngsIG5vZGUuZ2V0UmVjdCgpLnldLFxyXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiBub2RlLmdldFJlY3QoKS53aWR0aCxcclxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IG5vZGUuZ2V0UmVjdCgpLmhlaWdodFxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIGlmICghQnBtbi5pc1Nsb3RFdmVudChub2RlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMub3ZlcmxhcEFycmF5LnB1c2gobWVzQXJyYXkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGlzRnJvbURyYWcpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLzEu5Yik5pat5omA5pyJ55qE5a2Q6IqC54K5XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnN1YlByb2Nlc3NOb2RlLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vMi7lpoLmnpzoioLngrnmi5bmlL7lnKgg5a2Q6IqC54K55LitXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnN1YlByb2Nlc3NOb2RlW2ldLnJlY3RDb250YWluKG5vZGUuZ2V0UmVjdCgpLngsIG5vZGUuZ2V0UmVjdCgpLnkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLzIuMemHjeaWsOiuoeeul+iKgueCueWcqCDlrZDoioLngrnkuK3nmoTkvY3nva4gIOW5tuWKoOWFpeWIsOWtkOiKgueCuVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGdyb3VwTm9kZVBvc2l0aW9uWCA9IHRoaXMuc3ViUHJvY2Vzc05vZGVbaV0uZ2V0UmVjdCgpLndpZHRoIC8gMiArIChub2RlLmdldFJlY3QoKS54IC0gdGhpcy5zdWJQcm9jZXNzTm9kZVtpXS5nZXRSZWN0KCkueCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZ3JvdXBOb2RlUG9zaXRpb25ZID0gdGhpcy5zdWJQcm9jZXNzTm9kZVtpXS5nZXRSZWN0KCkuaGVpZ2h0IC8gMiArIChub2RlLmdldFJlY3QoKS55IC0gdGhpcy5zdWJQcm9jZXNzTm9kZVtpXS5nZXRSZWN0KCkueSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLnNldFBvc2l0aW9uKGdyb3VwTm9kZVBvc2l0aW9uWCwgZ3JvdXBOb2RlUG9zaXRpb25ZKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3ViUHJvY2Vzc05vZGVbaV0uYWRkKG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8yLjLku456cuS4reWIoOmZpFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fenIucmVtb3ZlKG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8yLjPku44g6IqC54K55L2N572uIOS/oeaBr+aVsOe7hOS4reWIoOmZpOatpOiKgueCuVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGF0Lm92ZXJsYXBBcnJheS5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub2RlLmlkID09IHRoYXQub3ZlcmxhcEFycmF5W2pdLmlkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQub3ZlcmxhcEFycmF5LnNwbGljZShqLCAxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8yLuWmguaenOaYr+WtkOiKgueCuSDliJnliqDlhaXliLDlrZDoioLngrnmlbDnu4TkuK1cclxuICAgICAgICAgICAgaWYgKEJwbW4uaXNTdWJQcm9jZXNzKG5vZGUpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN1YlByb2Nlc3NOb2RlLnB1c2gobm9kZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5hbGxOb2Rlcy5wdXNoKG5vZGUpO1xyXG4gICAgICAgICAgICAvL+aUvuWFpeiKgueCueS9jee9ruS/oeaBryDnlKjkuo7mi5bmi71cclxuICAgICAgICAgICAgdGhpcy5kb21BcnJheS5wdXNoKG1lc0FycmF5KTtcclxuXHJcbiAgICAgICAgICAgIC8v5L6m5ZCs6IqC54K555qE5LqL5Lu2IOW5tuaKiuS6i+S7tue7meWPlua2iOaOiSDpmLLmraIg5aaC5p6c54i25piv5a2Q6IqC54K55L6m5ZCs5YiwXHJcbiAgICAgICAgICAgIG5vZGUub24oJ21vdXNlZG93bicsIGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGF0LmZvcmJpZEVkaXQgPT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoYXQubmV3RHJhZyh0aGlzLCBlLmV2ZW50LmNsaWVudFgsIGUuZXZlbnQuY2xpZW50WSk7XHJcbiAgICAgICAgICAgICAgICAvL+WmguaenOmAieaLqeeahOaYr+S6i+S7tuiKgueCue+8jOWImeS4uuWFtuS7lnRhc2vnu5Hlrprmj5Lmp71cclxuICAgICAgICAgICAgICAgIGlmIChCcG1uLmlzU2xvdEV2ZW50KHRoaXMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5iaW5kRXZlbnROb2RlKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlLmNhbmNlbEJ1YmJsZSA9IHRydWU7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBub2RlLm9uKCdjbGljaycsIGZ1bmN0aW9uKGUpIHtcclxuXHJcbiAgICAgICAgICAgICAgICB0aGF0Lm5vZGVDbGlja0hhbmRsZXIodGhpcyk7XHJcbiAgICAgICAgICAgICAgICBlLmNhbmNlbEJ1YmJsZSA9IHRydWU7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgLy/mt7vliqB0aXBcclxuICAgICAgICAgICAgaWYgKEJwbW4uaXNBY3Rpdml0eShub2RlKSkge1xyXG4gICAgICAgICAgICAgICAgdGhhdC5jcmVhdFRpcChub2RlKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgbm9kZS5vbihcIm1vdXNlb3ZlclwiLCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmFsYXJtICYmIHRoaXMuYWxhcm0uaXNTaG93ID09IHRydWUpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hbGFybS5zaG93KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hbGFybS5lYWNoQ2hpbGQoZnVuY3Rpb24oY2hpbGQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGQuc2hvdygpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIC8v5qC55o2u5a2X5YaF5a655pu05pS5dGlw5aSW5qGG55qE5aSn5bCPXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRleHQgPSB0aGlzLmFsYXJtLmNoaWxkT2ZOYW1lKFwiVGV4dFwiKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZ3JvdXBXaWR0aCA9IHRleHQuZ2V0Qm91bmRpbmdSZWN0KCkud2lkdGggKyA0O1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBncm91cEhlaWdodCA9IHRleHQuZ2V0Qm91bmRpbmdSZWN0KCkuaGVpZ2h0ICsgODtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcG9pbnRzID0gW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBbMCwgMF0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFtncm91cFdpZHRoLCAwXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgW2dyb3VwV2lkdGgsIGdyb3VwSGVpZ2h0XSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgW2dyb3VwV2lkdGggLyAyIC0gMywgZ3JvdXBIZWlnaHRdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBbZ3JvdXBXaWR0aCAvIDIsIGdyb3VwSGVpZ2h0ICsgM10sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFtncm91cFdpZHRoIC8gMiArIDMsIGdyb3VwSGVpZ2h0XSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgWzAsIGdyb3VwSGVpZ2h0XSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgWzAsIDBdXHJcbiAgICAgICAgICAgICAgICAgICAgXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgUG9seWxpbmUgPSB0aGlzLmFsYXJtLmNoaWxkT2ZOYW1lKFwiUG9seWxpbmVcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgUG9seWxpbmUuYXR0cihcInNoYXBlXCIsIHtwb2ludHM6IHBvaW50c30pO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBncm91cFBvc2l0aW9uID0gW25vZGUucG9zaXRpb25bMF0gKyBub2RlLmdldEJvdW5kaW5nUmVjdCgpLndpZHRoIC0gdGhpcy5hbGFybS5nZXRCb3VuZGluZ1JlY3QoKS53aWR0aCAvIDIsIG5vZGUucG9zaXRpb25bMV0gLSB0aGlzLmFsYXJtLmdldEJvdW5kaW5nUmVjdCgpLmhlaWdodCAtIDNdO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWxhcm0uYXR0cihcInBvc2l0aW9uXCIsIGdyb3VwUG9zaXRpb24pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgbm9kZS5vbihcIm1vdXNlb3V0XCIsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYWxhcm0pIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFsYXJtLmhpZGUoKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFsYXJtLmVhY2hDaGlsZChmdW5jdGlvbihjaGlsZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZC5oaWRlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB0aGlzLl90cmlnZ2VyQ3JlYXRlRXZlbnQobm9kZSk7XHJcbiAgICAgICAgICAgIGlmIChpc05vQ291bnQgIT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zdGVwQ291bnRlcigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBub2RlO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDmoLnmja5uYW1l6I635Y+W6IqC54K5XHJcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IG5hbWUg5Zyo5Yib5bu66IqC54K55LitICBuYW1l5bGe5oCn6K6+572u55qE5YC8XHJcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9ICAgICAgbmFtZeWvueW6lOeahOiKgueCuVxyXG4gICAgICovXHJcbiAgICBmaXNoVG9wb1Byb3RvLmNoaWxkT2ZOYW1lID0gZnVuY3Rpb24obmFtZSkge1xyXG4gICAgICAgIHZhciBhcnJSZXN1bHQgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYWxsTm9kZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuYWxsTm9kZXNbaV0ubW9kZWwuZ2V0KFwicHJvcGVydGllcy5uYW1lXCIpID09IG5hbWUpIHtcclxuICAgICAgICAgICAgICAgIGFyclJlc3VsdC5wdXNoKHRoaXMuYWxsTm9kZXNbaV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChhcnJSZXN1bHQubGVuZ3RoID4gMSkge1xyXG4gICAgICAgICAgICByZXR1cm4gYXJyUmVzdWx0O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBhcnJSZXN1bHRbMF07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIOafpeaJvuWcuuaZr+S4reeahOWvueixoSAgIOS+i+WmgjogeOWdkOagh+Wkp+S6jjEwMOeahOiKgueCuSBmaW5kRWxlbWVudHMoZnVuY3Rpb24oZSl7IHJldHVybiBlLnBvc2l0aW9uWzBdID4gMTAwOyB9KTtcclxuICAgICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBjYiAgICAgIOWbnuiwg+WHveaVsFxyXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSAgIGNvbnRleHQg5Zue6LCD5Ye95pWw5omn6KGM55qE5LiK5LiL5paHXHJcbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gICAgICAgICAgIOi/lOWbnuafpeaJvuWIsOeahOWvueixoVxyXG4gICAgICovXHJcbiAgICBmaXNoVG9wb1Byb3RvLmZpbmRFbGVtZW50cyA9IGZ1bmN0aW9uKGNiLCBjb250ZXh0KSB7XHJcbiAgICAgICAgdmFyIGNoaWxkcmVuTm9kZSA9IHRoaXMuYWxsTm9kZXM7XHJcbiAgICAgICAgdmFyIGNoaWxkcmVuTGluZSA9IEJwbW5Db25uZWN0aW9uTWFuYWdlci5jb25uZWN0b3JzO1xyXG4gICAgICAgIHZhciBhcnIgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuTm9kZS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgY2hpbGQgPSBjaGlsZHJlbk5vZGVbaV07XHJcbiAgICAgICAgICAgIGlmIChjYi5jYWxsKGNvbnRleHQsIGNoaWxkLCBpKSkge1xyXG4gICAgICAgICAgICAgICAgYXJyLnB1c2goY2hpbGQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgY2hpbGRyZW5MaW5lLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgIHZhciBjaGlsZExpbmUgPSBjaGlsZHJlbkxpbmVbal07XHJcbiAgICAgICAgICAgIGlmIChjYi5jYWxsKGNvbnRleHQsIGNoaWxkTGluZSwgaikpIHtcclxuICAgICAgICAgICAgICAgIGFyci5wdXNoKGNoaWxkTGluZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGFycjtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICog5qC55o2u5qih5Z6L5aKe5Yqg57q/XHJcbiAgICAgKi9cclxuICAgIGZpc2hUb3BvUHJvdG8uYWRkQ29ubmVjdG9yQnlNb2RlbCA9IGZ1bmN0aW9uKG1vZGVsLCBwYXJlbnRacikge1xyXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgICAgICAvL+aJvuWHuiBzdGFydE5vZGUg5LiOIGVuZE5vZGVcclxuICAgICAgICB2YXIgc3RhcnROb2RlID0gbnVsbCxcclxuICAgICAgICAgICAgZW5kTm9kZSA9IG51bGw7XHJcbiAgICAgICAgenJVdGlsLmVhY2godGhpcy5hbGxOb2RlcywgZnVuY3Rpb24obm9kZSkge1xyXG4gICAgICAgICAgICAvL3N0YXJ0Tm9kZTog5LuOYWxsTm9kZeS4reaJvuWHum91dGdvaW5n5Li6IOe6v+eahGlk55qE6LW35aeL6IqC54K5XHJcbiAgICAgICAgICAgIHZhciBub2RlT3V0Z29pbmcgPSBub2RlLm1vZGVsLmdldChcIm91dGdvaW5nXCIpO1xyXG4gICAgICAgICAgICBpZiAobm9kZU91dGdvaW5nLmluZGV4T2YobW9kZWwuZ2V0KFwicmVzb3VyY2VJZFwiKSkgIT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICBzdGFydE5vZGUgPSBub2RlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vZW5kTm9kZSA6IOS7jmFsbE5vZGXkuK3mib7lh7ogaWQg5Li657q/55qEb3V0Z29pbmfnmoTnu5PmnZ/oioLngrlcclxuICAgICAgICAgICAgdmFyIGNvbm5lY3Rvck91dGdvaW5nID0gbW9kZWwuZ2V0KFwib3V0Z29pbmdcIik7XHJcbiAgICAgICAgICAgIGlmIChjb25uZWN0b3JPdXRnb2luZy5pbmRleE9mKG5vZGUucmVzb3VyY2VJZCkgIT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICBlbmROb2RlID0gbm9kZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmIChzdGFydE5vZGUgJiYgZW5kTm9kZSkge1xyXG4gICAgICAgICAgICB2YXIgY29ubmVjdG9yID0gQnBtbkNvbm5lY3Rpb25NYW5hZ2VyLmNvbm5lY3RvckNyZWF0ZUJ5T3B0aW9ucyhzdGFydE5vZGUsIGVuZE5vZGUsIHttb2RlbDogbW9kZWx9LCB0aGlzLl9hcGkpO1xyXG4gICAgICAgICAgICBpZiAocGFyZW50WnIpIHtcclxuICAgICAgICAgICAgICAgIHBhcmVudFpyLmFkZChjb25uZWN0b3IpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMuX3pyLmFkZChjb25uZWN0b3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbm5lY3Rvci5vbihcIm1vdXNlZG93blwiLCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIEJwbW5Db25uZWN0aW9uTWFuYWdlci5jb25uZWN0b3JGb3JiaWRFZGl0KHRoYXQuZm9yYmlkRWRpdCk7XHJcbiAgICAgICAgICAgICAgICBMaW5lT3BlcmF0aW9uTWFuYWdlci5pc0VkaXQgPSAhdGhhdC5mb3JiaWRFZGl0O1xyXG4gICAgICAgICAgICAgICAgdGhhdC5pc05vZGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDliJvlu7rov57nur/nmoTlsI/lm77moIfmk43kvZxcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkg5bCP5Zu+5qCH55qE5ZCN56ewXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqIOWwj+Wbvuagh+eahOebuOWFs+WPguaVsFxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMg5bCP5Zu+5qCH6YCJ6aG5XHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuaWNvbl0g5bCP5Zu+5qCH6Lev5b6EXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMubGluZU5vZGVdIOe6v+auteWunuS+i1xyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuY2FsbGJhY2tdIOeCueWHu+WQjueahOWbnuiwg1xyXG4gICAgICpcclxuICAgICAqICoq5L2/55So6IyD5L6LKirvvJpcclxuICAgICAqXHJcbiAgICAgKiAgICAgIEBleGFtcGxlXHJcbiAgICAgKiAgICAgIGZpc2hUb3BvQnBtbi5hZGRJY29uKFwiaWNvbjFcIix7ICAvL+e6v+S4iuWbvuagh+eahOWQjeensFxyXG4gICAgICogICAgICAgICAgICAgICAgICAgIGljb246XCJicG1uMi4wL2ljb25zL2FjdGl2aXR5L2xpc3QvbWFpbC5zZW5kLnBuZ1wiLCAvL+e6v+S4iuWbvuagh+eahOi3r+W+hFxyXG4gICAgICogICAgICAgICAgICAgICAgICAgICBsaW5lTm9kZTpsaW5lTm9kZSwgIC8v57q/XHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrOmZ1bmN0aW9uKGxpbmVOb2RlKXsgIC8v5Zue6LCDXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgYWxlcnQoSlNPTi5zdHJpbmdpZnkobGluZU5vZGUpKVxyXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAqICAgICAgICAgICAgICAgICAgfSk7KlxyXG4gICAgICovXHJcbiAgICBmaXNoVG9wb1Byb3RvLmFkZEljb24gPSBmdW5jdGlvbihrZXksIG9iaikge1xyXG4gICAgICAgIExpbmVPcGVyYXRpb25NYW5hZ2VyLmFkZEljb24oa2V5LCBvYmosIHRoaXMuX3pyLCB0aGlzLl9hcGkpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIOWIm+W7uui/nue6v+eahOm7mOiupOWIoOmZpOaTjeS9nFxyXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBsaW5lTm9kZSDnur9cclxuICAgICAqXHJcbiAgICAgKiAgKirkvb/nlKjojIPkvosqKu+8mlxyXG4gICAgICpcclxuICAgICAqICAgICAgQGV4YW1wbGVcclxuICAgICAqICAgICAgZmlzaFRvcG9CcG1uLmJpbmRMaW5lRGVsZXRlKGxpbmVOb2RlKTtcclxuICAgICAqL1xyXG4gICAgZmlzaFRvcG9Qcm90by5iaW5kTGluZURlbGV0ZSA9IGZ1bmN0aW9uKGxpbmVOb2RlKSB7XHJcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgICAgIHZhciBwYXJlbnRacjtcclxuICAgICAgICBpZiAobGluZU5vZGUucGFyZW50KSB7XHJcbiAgICAgICAgICAgIHBhcmVudFpyID0gbGluZU5vZGUucGFyZW50O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHBhcmVudFpyID0gdGhhdC5fenI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8v5Yib5bu65Yig6ZmkXHJcbiAgICAgICAgdmFyIGxpbmVPcGVyYXRpb24gPSBMaW5lT3BlcmF0aW9uTWFuYWdlci5hZGRJY29uKFwiZGVsZXRlXCIsIExpbmVPcGVyYXRpb25NYW5hZ2VyLmRlbGV0ZUljb25PYmoocGFyZW50WnIsIGxpbmVOb2RlKSwgcGFyZW50WnIsIHRoaXMuX2FwaSk7XHJcbiAgICAgICAgaWYgKGxpbmVPcGVyYXRpb24pIHtcclxuICAgICAgICAgICAgbGluZU9wZXJhdGlvbi5vbihcImNsaWNrXCIsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgdGhhdC5fdHJpZ2dlckRlbGV0ZUV2ZW50KGxpbmVOb2RlKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIOi/lOWbniDov57lkJHor6XoioLngrnnmoToioLngrnmlbDnu4TvvJpub2RlQXJyYXlbMF0gIOS7peWPiuivpeiKgueCuei/nuWQkeeahOiKgueCueaVsOe7hCBub2RlQXJyYXlbMF1cclxuICAgICAqL1xyXG4gICAgZmlzaFRvcG9Qcm90by5jaGVja0xpbmVOb2RlID0gZnVuY3Rpb24obm9kZSkge1xyXG4gICAgICAgIHZhciBzdGFydEFycmF5ID0gW10sXHJcbiAgICAgICAgICAgIGVuZEFycmF5ID0gW107XHJcbiAgICAgICAgdmFyIGxpbmVBcnJheSA9IEJwbW5Db25uZWN0aW9uTWFuYWdlci5jb25uZWN0b3JzO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBsaW5lQXJyYXkubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKGxpbmVBcnJheVtpXS5zdGFydE5vZGUgPT0gbm9kZSkge1xyXG4gICAgICAgICAgICAgICAgZW5kQXJyYXkucHVzaChsaW5lQXJyYXlbaV0uZW5kTm9kZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yICh2YXIgaiA9IDAsIGxlbkVuZCA9IGxpbmVBcnJheS5sZW5ndGg7IGogPCBsZW5FbmQ7IGorKykge1xyXG4gICAgICAgICAgICBpZiAobGluZUFycmF5W2pdLmVuZE5vZGUgPT0gbm9kZSkge1xyXG4gICAgICAgICAgICAgICAgc3RhcnRBcnJheS5wdXNoKGxpbmVBcnJheVtqXS5zdGFydE5vZGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBbc3RhcnRBcnJheSwgZW5kQXJyYXldO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIOWIneWni+WMliDmk43kvZznmoTomZrnur/moYZcclxuICAgICAqL1xyXG4gICAgZmlzaFRvcG9Qcm90by5pbml0T3BlcmF0aW9uTm9kZSA9IGZ1bmN0aW9uKG5vZGUpIHtcclxuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5vcGVyYXRpb25Ob2RlID0gbmV3IE9wZXJhdGlvbk5vZGUobm9kZSwgdGhhdC5fenIsIHRoaXMuZm9yYmlkRWRpdCk7XHJcbiAgICAgICAgLy8g5L6m5ZCsIOeureWktCDmi5bmi73lvIDlp4vkuovku7ZcclxuICAgICAgICB0aGlzLm9wZXJhdGlvbk5vZGUub24oT3BlcmF0aW9uTm9kZS5BUlJPV19EUkFHU1RBUlQsIGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgICAgdmFyIHggPSBlLmV2ZW50Lm9mZnNldFg7XHJcbiAgICAgICAgICAgIHZhciB5ID0gZS5ldmVudC5vZmZzZXRZO1xyXG4gICAgICAgICAgICAvL+aLluaLveW8gOWni+WFiOaKiiDnrq3lpLTlm77moIcg57uZ6ZqQ6JePXHJcbiAgICAgICAgICAgIHZhciBhcnJvdyA9IGUuZXZlbnQudGFyZ2V0O1xyXG4gICAgICAgICAgICBhcnJvdy5oaWRlKCk7XHJcbiAgICAgICAgICAgIHZhciByRW5kUG9pbnQgPSBuZXcgUG9pbnQoeCwgeSk7XHJcbiAgICAgICAgICAgIGlmICh0aGF0LnNlbGVjdGVkTm9kZS5wYXJlbnQgJiYgQnBtbi5pc1N1YlByb2Nlc3ModGhhdC5zZWxlY3RlZE5vZGUucGFyZW50KSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHN1YlByb2Nlc3NOb2RlID0gdGhhdC5zZWxlY3RlZE5vZGUucGFyZW50O1xyXG4gICAgICAgICAgICAgICAgckVuZFBvaW50ID0gbmV3IFBvaW50KHggLSBzdWJQcm9jZXNzTm9kZS5wb3NpdGlvblswXSwgeSAtIHN1YlByb2Nlc3NOb2RlLnBvc2l0aW9uWzFdKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIGNvbm5lY3RvciA9IEJwbW5Db25uZWN0aW9uTWFuYWdlci5tYW5hZ2VUZW1wQ29ubmVjdG9yKHRoYXQuc2VsZWN0ZWROb2RlLCByRW5kUG9pbnQsIGFycm93LmxpbmVUeXBlKTtcclxuICAgICAgICAgICAgaWYgKHRoYXQuc2VsZWN0ZWROb2RlLnBhcmVudCAmJiBCcG1uLmlzU3ViUHJvY2Vzcyh0aGF0LnNlbGVjdGVkTm9kZS5wYXJlbnQpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGF0LnNlbGVjdGVkTm9kZS5wYXJlbnQuYWRkKGNvbm5lY3Rvcik7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGF0Ll96ci5hZGQoY29ubmVjdG9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICAvLyDkvqblkKwg566t5aS0IOaLluaLveS6i+S7tlxyXG4gICAgICAgIHRoaXMub3BlcmF0aW9uTm9kZS5vbihPcGVyYXRpb25Ob2RlLkFSUk9XX0RSQUcsIGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgICAgdmFyIHggPSBlLmV2ZW50Lm9mZnNldFg7XHJcbiAgICAgICAgICAgIHZhciB5ID0gZS5ldmVudC5vZmZzZXRZO1xyXG4gICAgICAgICAgICB2YXIgckVuZFBvaW50ID0gbmV3IFBvaW50KHgsIHkpO1xyXG4gICAgICAgICAgICB2YXIgYXJyb3cgPSBlLmV2ZW50LnRhcmdldDtcclxuICAgICAgICAgICAgaWYgKHRoYXQuc2VsZWN0ZWROb2RlLnBhcmVudCAmJiBCcG1uLmlzU3ViUHJvY2Vzcyh0aGF0LnNlbGVjdGVkTm9kZS5wYXJlbnQpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc3ViUHJvY2Vzc05vZGUgPSB0aGF0LnNlbGVjdGVkTm9kZS5wYXJlbnQ7XHJcbiAgICAgICAgICAgICAgICByRW5kUG9pbnQgPSBuZXcgUG9pbnQoeCAtIHN1YlByb2Nlc3NOb2RlLnBvc2l0aW9uWzBdLCB5IC0gc3ViUHJvY2Vzc05vZGUucG9zaXRpb25bMV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIEJwbW5Db25uZWN0aW9uTWFuYWdlci5tYW5hZ2VUZW1wQ29ubmVjdG9yKHRoYXQuc2VsZWN0ZWROb2RlLCByRW5kUG9pbnQsIGFycm93LmxpbmVUeXBlKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgLy/kvqblkKwg566t5aS0IOaLluaLvee7k+adn+S6i+S7tiDnlLvnur9cclxuICAgICAgICB0aGlzLm9wZXJhdGlvbk5vZGUub24oT3BlcmF0aW9uTm9kZS5BUlJPV19EUkFHRU5ELCBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICAgIHZhciB4ID0gZS5ldmVudC5vZmZzZXRYO1xyXG4gICAgICAgICAgICB2YXIgeSA9IGUuZXZlbnQub2Zmc2V0WTtcclxuICAgICAgICAgICAgdmFyIHRhcmdldE5vZGUgPSBudWxsO1xyXG4gICAgICAgICAgICAvL+aLluaLvee7k+adn+WFiOaKiiDnrq3lpLTlm77moIcg57uZ5pi+56S6XHJcbiAgICAgICAgICAgIHZhciBhcnJvdyA9IGUuZXZlbnQudGFyZ2V0O1xyXG4gICAgICAgICAgICBhcnJvdy5zaG93KCk7XHJcblxyXG4gICAgICAgICAgICAvLzEu5aaC5p6c5piv5a2Q6IqC54K5IOWGhSDoioLngrnmi5bmi70g5YiZIOWinuWKoOaOkumZpOWtkOiKgueCueeahOWPguaVsFxyXG4gICAgICAgICAgICBpZiAobm9kZS5wYXJlbnQpIHtcclxuICAgICAgICAgICAgICAgIGlmIChCcG1uLmlzU3ViUHJvY2Vzcyhub2RlLnBhcmVudCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAvL+WIoOmZpOS4tOaXtue6v1xyXG4gICAgICAgICAgICAgICAgICAgIEJwbW5Db25uZWN0aW9uTWFuYWdlci5yZW1vdmVUZW1wQ29ubmVjdG9yKG5vZGUucGFyZW50KTtcclxuICAgICAgICAgICAgICAgICAgICB0YXJnZXROb2RlID0gQnBtblV0aWwuZmluZEhvdmVyKHRoYXQuYWxsTm9kZXMsIHgsIHksIHRoYXQuc3ViUHJvY2Vzc05vZGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGFyZ2V0Tm9kZSA9IEJwbW5VdGlsLmZpbmRIb3Zlcih0aGF0LmFsbE5vZGVzLCB4LCB5KTtcclxuICAgICAgICAgICAgICAgIC8v5Yig6Zmk5Li05pe257q/XHJcbiAgICAgICAgICAgICAgICBCcG1uQ29ubmVjdGlvbk1hbmFnZXIucmVtb3ZlVGVtcENvbm5lY3Rvcih0aGF0Ll96cik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8yLuWmguaenOaJvuWIsOebruagh+e7k+eCuSDliJnnlLvnur9cclxuICAgICAgICAgICAgaWYgKHRhcmdldE5vZGUgJiYgKHRoYXQuc2VsZWN0ZWROb2RlICE9IHRhcmdldE5vZGUpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGF0Ll9jcmVhdGVDb25uZWN0b3JCeU5vZGVzKHRoYXQuc2VsZWN0ZWROb2RlLCB0YXJnZXROb2RlLCBhcnJvdy5saW5lVHlwZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHNoYXBlUmVjdCA9IHRoYXQuc2VsZWN0ZWROb2RlLmdldFJlY3QoKTtcclxuICAgICAgICAgICAgdGhhdC5vcGVyYXRpb25Ob2RlLnJlbmRlcihub2RlLCB0aGF0Ll96ciwgc2hhcGVSZWN0KTtcclxuICAgICAgICAgICAgdGhhdC5zdGVwQ291bnRlcigpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8v5Yig6Zmk5oyJ6ZKu54K55Ye75LqL5Lu2XHJcbiAgICAgICAgdGhpcy5vcGVyYXRpb25Ob2RlLm9uKFwiT3BlcmF0aW9uTm9kZTpkZWxldGVDbGlja1wiLCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdGhhdC5fdHJpZ2dlckRlbGV0ZUV2ZW50KHRoYXQuc2VsZWN0ZWROb2RlKTtcclxuICAgICAgICAgICAgdGhhdC5yZW1vdmVOb2RlKHRoYXQuc2VsZWN0ZWROb2RlKTtcclxuICAgICAgICAgICAgdGhhdC5zdGVwQ291bnRlcigpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8v5pS+5aSn57yp5bCP5ouW5Yqo6L+H56iLXHJcbiAgICAgICAgdGhpcy5vcGVyYXRpb25Ob2RlLm9uKFwiT3BlcmF0aW9uTm9kZTpzY2FsZURyYWdMZWZ0XCIsIGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgICAgdGhpcy52aXJ0dWFsUmVjdC5zZXRTaGFwZSh7cG9pbnRzOiBlLnBvaW50c30pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMub3BlcmF0aW9uTm9kZS5vbihcIk9wZXJhdGlvbk5vZGU6c2NhbGVEcmFnUmlnaHRcIiwgZnVuY3Rpb24oZSkge1xyXG4gICAgICAgICAgICB0aGlzLnZpcnR1YWxSZWN0LnNldFNoYXBlKHtwb2ludHM6IGUucG9pbnRzfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLy/mlL7lpKfnvKnlsI/mi5bliqjnu5PmnZ9cclxuICAgICAgICB0aGlzLm9wZXJhdGlvbk5vZGUub24oXCJPcGVyYXRpb25Ob2RlOnNjYWxlRHJhZ0VuZFwiLCBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICAgIC8vMS7ov5vooYzoioLngrnlpKflsI/nmoTorr7nva7vvIzlubbnu7TmiqTkvY3nva7kv6Hmga/mlbDnu4RcclxuICAgICAgICAgICAgaWYgKHRoaXMudmlydHVhbFJlY3Quc2hhcGUucG9pbnRzIHx8IHRoaXMudmlydHVhbFJlY3Quc2hhcGUucG9pbnRzICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHZhciB3aWR0aCA9IHRoaXMudmlydHVhbFJlY3Quc2hhcGUucG9pbnRzWzFdWzBdIC0gdGhpcy52aXJ0dWFsUmVjdC5zaGFwZS5wb2ludHNbMF1bMF0gLSAxO1xyXG4gICAgICAgICAgICAgICAgdmFyIGhlaWdodCA9IHRoaXMudmlydHVhbFJlY3Quc2hhcGUucG9pbnRzWzJdWzFdIC0gdGhpcy52aXJ0dWFsUmVjdC5zaGFwZS5wb2ludHNbMV1bMV0gLSAxO1xyXG4gICAgICAgICAgICAgICAgdmFyIHBvc2l0aW9uO1xyXG4gICAgICAgICAgICAgICAgaWYgKGUuYXJyb3dOYW1lID09IFwibGVmdFwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24gPSBbdGhhdC5zZWxlY3RlZE5vZGUucG9zaXRpb25bMF0gLSAod2lkdGggKyAxIC0gdGhhdC5zZWxlY3RlZE5vZGUuZ2V0UmVjdCgpLndpZHRoKSwgdGhhdC5zZWxlY3RlZE5vZGUucG9zaXRpb25bMV0gLSAoaGVpZ2h0ICsgMSAtIHRoYXQuc2VsZWN0ZWROb2RlLmdldFJlY3QoKS5oZWlnaHQpXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChlLmFycm93TmFtZSA9PSBcInJpZ2h0XCIpIHtcclxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IFt0aGF0LnNlbGVjdGVkTm9kZS5wb3NpdGlvblswXSwgdGhhdC5zZWxlY3RlZE5vZGUucG9zaXRpb25bMV1dO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhhdC5zZWxlY3RlZE5vZGUucmVmcmVzaCh7c2hhcGU6IHt3aWR0aDogd2lkdGgsIGhlaWdodDogaGVpZ2h0fX0pO1xyXG4gICAgICAgICAgICAgICAgdmFyIGlzQ2hhbmdlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGlmIChoZWlnaHQgKyAxIDwgdGhhdC5zZWxlY3RlZE5vZGUuZ2V0Qm91bmRpbmdSZWN0KCkuaGVpZ2h0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5zZWxlY3RlZE5vZGUucmVmcmVzaCh7c2hhcGU6IHtoZWlnaHQ6IHRoYXQuc2VsZWN0ZWROb2RlLmdldEJvdW5kaW5nUmVjdCgpLmhlaWdodH19KTtcclxuICAgICAgICAgICAgICAgICAgICBpc0NoYW5nZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHdpZHRoICsgMSA8IHRoYXQuc2VsZWN0ZWROb2RlLmdldEJvdW5kaW5nUmVjdCgpLndpZHRoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5zZWxlY3RlZE5vZGUucmVmcmVzaCh7c2hhcGU6IHt3aWR0aDogdGhhdC5zZWxlY3RlZE5vZGUuZ2V0Qm91bmRpbmdSZWN0KCkud2lkdGh9fSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaXNDaGFuZ2UgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChpc0NoYW5nZSA9PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5zZWxlY3RlZE5vZGUucmVmcmVzaCh7cG9zaXRpb246IHBvc2l0aW9ufSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBtID0gMDsgbSA8IHRoYXQuZG9tQXJyYXkubGVuZ3RoOyBtKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhhdC5zZWxlY3RlZE5vZGUuaWQgPT0gdGhhdC5kb21BcnJheVttXS5pZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGF0LmRvbUFycmF5W21dLnBvc2l0aW9uID0gW3Bvc2l0aW9uWzBdICsgKHdpZHRoICsgMSkgLyAyLCBwb3NpdGlvblsxXSArIChoZWlnaHQgKyAxKSAvIDJdO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoYXQubm9kZUNsaWNrSGFuZGxlcih0aGF0LnNlbGVjdGVkTm9kZSk7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBuID0gMDsgbiA8IHRoYXQub3ZlcmxhcEFycmF5Lmxlbmd0aDsgbisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoYXQuc2VsZWN0ZWROb2RlLmlkID09IHRoYXQub3ZlcmxhcEFycmF5W25dLmlkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQub3ZlcmxhcEFycmF5W25dID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IHRoYXQuc2VsZWN0ZWROb2RlLmlkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IFt0aGF0LnNlbGVjdGVkTm9kZS5nZXRSZWN0KCkueCwgdGhhdC5zZWxlY3RlZE5vZGUuZ2V0UmVjdCgpLnldLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHRoYXQuc2VsZWN0ZWROb2RlLmdldFJlY3QoKS53aWR0aCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogdGhhdC5zZWxlY3RlZE5vZGUuZ2V0UmVjdCgpLmhlaWdodFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLzIu5Yi35paw57q/XHJcbiAgICAgICAgICAgIEJwbW5Db25uZWN0aW9uTWFuYWdlci5yZWZyZXNoTGluZUJ5Tm9kZSh0aGF0LnNlbGVjdGVkTm9kZSk7XHJcbiAgICAgICAgICAgIHZhciBlbmRTbG90UG9pbnRzID0gdXRpbC5nZXRTb2x0UG9pbnRzKHRoYXQuc2VsZWN0ZWROb2RlKTtcclxuICAgICAgICAgICAgaWYgKHRoYXQuc2VsZWN0ZWROb2RlLnNsb3RFdmVudCAmJiB0aGF0LnNlbGVjdGVkTm9kZS5zbG90RXZlbnQubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGF0LnNlbGVjdGVkTm9kZS5zbG90RXZlbnQubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc2xvdE5vZGUgPSB0aGF0LnNlbGVjdGVkTm9kZS5zbG90RXZlbnRbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBlLnN0YXJ0U2xvdFBvaW50cy5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhhdC5zZWxlY3RlZE5vZGUuc2xvdEV2ZW50W2ldLnBvc2l0aW9uWzBdIC0gZS5zdGFydFBvc2l0aW9uWzBdID09IGUuc3RhcnRTbG90UG9pbnRzW2pdWzBdICYmIHRoYXQuc2VsZWN0ZWROb2RlLnNsb3RFdmVudFtpXS5wb3NpdGlvblsxXSAtIGUuc3RhcnRQb3NpdGlvblsxXSA9PSBlLnN0YXJ0U2xvdFBvaW50c1tqXVsxXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5zZWxlY3RlZE5vZGUuc2xvdEV2ZW50W2ldLmF0dHIoXCJwb3NpdGlvblwiLCBbZW5kU2xvdFBvaW50c1tqXVswXSArIHRoYXQuc2VsZWN0ZWROb2RlLnBvc2l0aW9uWzBdLCBlbmRTbG90UG9pbnRzW2pdWzFdICsgdGhhdC5zZWxlY3RlZE5vZGUucG9zaXRpb25bMV1dKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEJwbW5Db25uZWN0aW9uTWFuYWdlci5yZWZyZXNoTGluZUJ5Tm9kZSh0aGF0LnNlbGVjdGVkTm9kZS5zbG90RXZlbnRbaV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoYXQuc3RlcENvdW50ZXIoKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLl96ci5hZGQodGhpcy5vcGVyYXRpb25Ob2RlKTtcclxuXHJcblxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIOenu+mZpOWcuuaZr+S4reeahOafkOS4quiKgueCuVxyXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBzZWxlY3RlZE5vZGUg5b6F5Yig6Zmk55qE6IqC54K5XHJcbiAgICAgKi9cclxuICAgIGZpc2hUb3BvUHJvdG8ucmVtb3ZlTm9kZSA9IGZ1bmN0aW9uKHNlbGVjdGVkTm9kZSkge1xyXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgICAgICAvLzEu5aaC5p6c5piv5a2Q6IqC54K5IOWGhSDoioLngrkgIOWImSDosIPnlKjlrZDoioLngrnnmoTliKDpmaRcclxuICAgICAgICB2YXIgcGFyZW50WnI7XHJcbiAgICAgICAgaWYgKHNlbGVjdGVkTm9kZS5wYXJlbnQpIHtcclxuICAgICAgICAgICAgcGFyZW50WnIgPSBzZWxlY3RlZE5vZGUucGFyZW50O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHBhcmVudFpyID0gdGhhdC5fenI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHBhcmVudFpyLnJlbW92ZShzZWxlY3RlZE5vZGUpO1xyXG4gICAgICAgIC8vMi7ku45hbGxOb2Rlc+aVsOe7hOS4reWIoOmZpFxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhhdC5hbGxOb2Rlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoc2VsZWN0ZWROb2RlLmlkID09IHRoYXQuYWxsTm9kZXNbaV0uaWQpIHtcclxuICAgICAgICAgICAgICAgIHRoYXQuYWxsTm9kZXMuc3BsaWNlKGksIDEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGhhdC5kb21BcnJheS5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICBpZiAoc2VsZWN0ZWROb2RlLmlkID09IHRoYXQuZG9tQXJyYXlbal0uaWQpIHtcclxuICAgICAgICAgICAgICAgIHRoYXQuZG9tQXJyYXkuc3BsaWNlKGosIDEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgdGhhdC5vdmVybGFwQXJyYXkubGVuZ3RoOyBrKyspIHtcclxuICAgICAgICAgICAgaWYgKHNlbGVjdGVkTm9kZS5pZCA9PSB0aGF0Lm92ZXJsYXBBcnJheVtrXS5pZCkge1xyXG4gICAgICAgICAgICAgICAgdGhhdC5vdmVybGFwQXJyYXkuc3BsaWNlKGssIDEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vMy7lsIbmraToioLngrnkuqTogZTnmoTnur/kuZ/liKDpmaRcclxuICAgICAgICBCcG1uQ29ubmVjdGlvbk1hbmFnZXIuZGVsZXRlU2VsZWN0Q29uKHNlbGVjdGVkTm9kZSwgcGFyZW50WnIpO1xyXG4gICAgICAgIC8v5aaC5p6c5Yig6Zmk6IqC54K55pivdGFza+iKgueCue+8jOmcgOimgeWwhuS+nemZhOWug+eahOS6i+S7tuiKgueCueWIoOmZpFxyXG4gICAgICAgIGlmIChCcG1uLmlzQWN0aXZpdHkoc2VsZWN0ZWROb2RlKSB8fCBCcG1uLmlzU3ViUHJvY2VzcyhzZWxlY3RlZE5vZGUpKSB7XHJcbiAgICAgICAgICAgIGlmIChzZWxlY3RlZE5vZGUuc2xvdEV2ZW50ICYmIHNlbGVjdGVkTm9kZS5zbG90RXZlbnQubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgbSA9IDA7IG0gPCBzZWxlY3RlZE5vZGUuc2xvdEV2ZW50Lmxlbmd0aDsgbSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGVjdGVkTm9kZS5zbG90RXZlbnRbbV0ucGFyZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChCcG1uLmlzU3ViUHJvY2VzcyhzZWxlY3RlZE5vZGUuc2xvdEV2ZW50W21dLnBhcmVudCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkTm9kZS5zbG90RXZlbnRbbV0ucGFyZW50LnJlbW92ZShzZWxlY3RlZE5vZGUuc2xvdEV2ZW50W21dKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuX3pyLnJlbW92ZShzZWxlY3RlZE5vZGUuc2xvdEV2ZW50W21dKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgbiA9IDA7IG4gPCB0aGF0LmFsbE5vZGVzLmxlbmd0aDsgbisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZWxlY3RlZE5vZGUuc2xvdEV2ZW50W21dLmlkID09IHRoYXQuYWxsTm9kZXNbbl0uaWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuYWxsTm9kZXMuc3BsaWNlKG4sIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGEgPSAwOyBhIDwgdGhhdC5kb21BcnJheS5sZW5ndGg7IGErKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZWN0ZWROb2RlLnNsb3RFdmVudFttXS5pZCA9PSB0aGF0LmRvbUFycmF5W2FdLmlkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGF0LmRvbUFycmF5LnNwbGljZShhLCAxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLzQu5aaC5p6c5Yig6Zmk55qE5piv5LqL5Lu26IqC54K577yM6ZyA6KaB5bCG57uR5a6a5a6D55qEdGFza+iKgueCueeahOagh+ivhuWIoOmZpFxyXG4gICAgICAgIGlmIChCcG1uLmlzU2xvdEV2ZW50KHNlbGVjdGVkTm9kZSkpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgYiA9IDA7IGIgPCB0aGF0LmFsbE5vZGVzLmxlbmd0aDsgYisrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhhdC5hbGxOb2Rlc1tiXS5pc0NhblNsb3QpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhhdC5hbGxOb2Rlc1tiXS5zbG90RXZlbnQgJiYgdGhhdC5hbGxOb2Rlc1tiXS5zbG90RXZlbnQubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBjID0gMDsgYyA8IHRoYXQuYWxsTm9kZXNbYl0uc2xvdEV2ZW50Lmxlbmd0aDsgYysrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZWN0ZWROb2RlLmlkID09IHRoYXQuYWxsTm9kZXNbYl0uc2xvdEV2ZW50W2NdLmlkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5hbGxOb2Rlc1tiXS5zbG90RXZlbnQuc3BsaWNlKGMsIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuc3RlcENvdW50ZXIoKTtcclxuICAgIH07XHJcblxyXG4gICAgZmlzaFRvcG9Qcm90by5fY3JlYXRlQ29ubmVjdG9yQnlOb2RlcyA9IGZ1bmN0aW9uKHN0YXJ0Tm9kZSwgZW5kTm9kZSwgbGluZVR5cGUpIHtcclxuICAgICAgICB2YXIgY29ubmVjdG9yID0gQnBtbkNvbm5lY3Rpb25NYW5hZ2VyLmNvbm5lY3RvckNyZWF0ZShzdGFydE5vZGUsIGVuZE5vZGUsIGxpbmVUeXBlLCB0aGlzLl9hcGkpO1xyXG4gICAgICAgIGlmIChzdGFydE5vZGUucGFyZW50ICYmIGVuZE5vZGUucGFyZW50KSB7XHJcbiAgICAgICAgICAgIGVuZE5vZGUucGFyZW50LmFkZChjb25uZWN0b3IpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3pyLmFkZChjb25uZWN0b3IpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25uZWN0b3Iub24oXCJtb3VzZWRvd25cIiwgenJVdGlsLmJpbmQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIEJwbW5Db25uZWN0aW9uTWFuYWdlci5jb25uZWN0b3JGb3JiaWRFZGl0KHRoaXMuZm9yYmlkRWRpdCk7XHJcbiAgICAgICAgICAgIExpbmVPcGVyYXRpb25NYW5hZ2VyLmlzRWRpdCA9ICF0aGlzLmZvcmJpZEVkaXQ7XHJcbiAgICAgICAgICAgIHRoaXMuaXNOb2RlID0gZmFsc2U7XHJcbiAgICAgICAgfSwgdGhpcykpO1xyXG5cclxuICAgICAgICB0aGlzLl90cmlnZ2VyQ3JlYXRlRXZlbnQoY29ubmVjdG9yKTtcclxuICAgICAgICByZXR1cm4gY29ubmVjdG9yO1xyXG4gICAgfTtcclxuXHJcbiAgICBmaXNoVG9wb1Byb3RvLl90cmlnZ2VyRGVsZXRlRXZlbnQgPSBmdW5jdGlvbih0YXJnZXQpIHtcclxuICAgICAgICB2YXIgZXZlbnRQYXJhbXMgPSB7fTtcclxuICAgICAgICBldmVudFBhcmFtcy50eXBlID0gXCJkZWxldGVcIjtcclxuICAgICAgICBldmVudFBhcmFtcy50YXJnZXQgPSB0YXJnZXQ7XHJcbiAgICAgICAgdGhpcy5fYXBpLnRyaWdnZXIoZXZlbnRQYXJhbXMudHlwZSwgZXZlbnRQYXJhbXMpO1xyXG4gICAgfTtcclxuICAgIGZpc2hUb3BvUHJvdG8uX3RyaWdnZXJDcmVhdGVFdmVudCA9IGZ1bmN0aW9uKHRhcmdldCkge1xyXG4gICAgICAgIHZhciBldmVudFBhcmFtcyA9IHt9O1xyXG4gICAgICAgIGV2ZW50UGFyYW1zLnR5cGUgPSBcImNyZWF0ZVwiO1xyXG4gICAgICAgIGV2ZW50UGFyYW1zLnRhcmdldCA9IHRhcmdldDtcclxuICAgICAgICB0aGlzLl9hcGkudHJpZ2dlcihldmVudFBhcmFtcy50eXBlLCBldmVudFBhcmFtcyk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIOm8oOagh+eCueS4iyDlsIbmk43kvZzmoYYg56e75Yiw5a+55bqU55qE6IqC54K55LiKXHJcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IG5vZGUgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICogQHJldHVybiB7T2JqZWN0fSAgICAgIFtkZXNjcmlwdGlvbl1cclxuICAgICAqL1xyXG4gICAgZmlzaFRvcG9Qcm90by5ub2RlQ2xpY2tIYW5kbGVyID0gZnVuY3Rpb24obm9kZSkge1xyXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgICAgICB0aGlzLnNlbGVjdGVkTm9kZSA9IG5vZGU7XHJcbiAgICAgICAgdmFyIHNoYXBlUmVjdCA9IG5vZGUuZ2V0UmVjdCgpO1xyXG4gICAgICAgIGlmICghdGhpcy5vcGVyYXRpb25Ob2RlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaW5pdE9wZXJhdGlvbk5vZGUobm9kZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghdGhpcy5mb3JiaWRFZGl0KSB7XHJcbiAgICAgICAgICAgIHRoYXQucmVjdC5hdHRyKFwic3R5bGVcIiwge1xyXG4gICAgICAgICAgICAgICAgc3Ryb2tlOiBcInJnYmEoMCwgMCwgMCwgMSlcIlxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMub3BlcmF0aW9uTm9kZS5yZWZyZXNoUG9zdGlvbihub2RlLCBzaGFwZVJlY3QpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIOWIneWni+WMluiZmuahhuWvuem9kOe6v1xyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSAge09iamVjdH0gc2hhcGVMaXN0IFtkZXNjcmlwdGlvbl1cclxuICAgICAqL1xyXG4gICAgZmlzaFRvcG9Qcm90by5pbml0VmlydHVhbExpbmUgPSBmdW5jdGlvbihzaGFwZUxpc3QpIHtcclxuICAgICAgICBHdWlkZWxpbmVzLmNyZWF0ZUd1aWRlbGluZXModGhpcy5fenIpO1xyXG4gICAgICAgIHRoaXMucmVjdCA9IG5ldyBncmFwaGljLlBvbHlsaW5lKHtcclxuICAgICAgICAgICAgcG9zaXRpb246IFtzaGFwZUxpc3QueCwgc2hhcGVMaXN0LnldLFxyXG4gICAgICAgICAgICBzaGFwZToge1xyXG4gICAgICAgICAgICAgICAgcG9pbnRzOiBzaGFwZUxpc3QucG9pbnRzXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgICBsaW5lRGFzaDogWzJdXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHo6IDNcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLl96ci5hZGQodGhpcy5yZWN0KTtcclxuICAgIH07XHJcbiAgICAvL+e7keWumuS6i+S7tuiKgueCuVxyXG4gICAgZmlzaFRvcG9Qcm90by5iaW5kRXZlbnROb2RlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgICAgIC8vbW91c2Vkb3du55qE5pe25YCZ5Li65q+P5LiqdGFza+WIm+W7uuaPkuanvVxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhhdC5hbGxOb2Rlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAodGhhdC5hbGxOb2Rlc1tpXS5pc0NhblNsb3QpIHtcclxuICAgICAgICAgICAgICAgIHRoYXQuY3JlYXRTbG90KHRoYXQuYWxsTm9kZXNbaV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vbW91c2V1cOeahOaXtuWAmeWIoOmZpOaPkuanvVxyXG4gICAgICAgIHRoYXQuX3pyLm9uKFwibW91c2V1cFwiLCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGF0LmFsbE5vZGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhhdC5hbGxOb2Rlc1tpXS5pc0NhblNsb3QpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhhdC5hbGxOb2Rlc1tpXS5zbG90ICYmIHRoYXQuYWxsTm9kZXNbaV0uc2xvdC5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIG0gPSAwOyBtIDwgdGhhdC5hbGxOb2Rlc1tpXS5zbG90Lmxlbmd0aDsgbSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGF0LmFsbE5vZGVzW2ldLnJlbW92ZSh0aGF0LmFsbE5vZGVzW2ldLnNsb3RbbV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSlcclxuXHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgZmlzaFRvcG9Qcm90by5jcmVhdFNsb3QgPSBmdW5jdGlvbihub2RlKSB7XHJcbiAgICAgICAgLy/nu5l0YXNr5Yib5bu6OOS4quaPkuanvVxyXG4gICAgICAgIG5vZGUuc2xvdCA9IFtdO1xyXG4gICAgICAgIHZhciBwb3NpdGlvbiA9IHV0aWwuZ2V0U29sdFBvaW50cyhub2RlKTtcclxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IDg7IGorKykge1xyXG4gICAgICAgICAgICB2YXIgQ2lyY2xlID0gbmV3IGdyYXBoaWMuQ2lyY2xlKHtcclxuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBwb3NpdGlvbltqXSxcclxuICAgICAgICAgICAgICAgIHNoYXBlOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgY3g6IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgY3k6IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgcjogMTBcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBzdHlsZToge1xyXG4gICAgICAgICAgICAgICAgICAgIGxpbmVXaWR0aDogMSxcclxuICAgICAgICAgICAgICAgICAgICBzdHJva2U6ICdyZ2JhKDAsMCwwLDAuNiknLFxyXG4gICAgICAgICAgICAgICAgICAgIGZpbGw6ICd0cmFuc3BhcmVudCdcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIG5vZGUuc2xvdC5wdXNoKENpcmNsZSk7XHJcbiAgICAgICAgICAgIG5vZGUuYWRkKENpcmNsZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBtb3VzZWRvd27lkI4g5byA5aeL5ouW5YqoXHJcbiAgICAgKi9cclxuICAgIGZpc2hUb3BvUHJvdG8ubmV3RHJhZyA9IGZ1bmN0aW9uKGRvbSwgc1gsIHNZKSB7XHJcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgICAgIHRoYXQuc2VsZWN0ZWROb2RlID0gZG9tO1xyXG4gICAgICAgIHRoYXQuaXNOb2RlID0gdHJ1ZTtcclxuICAgICAgICB2YXIgcGl4ZWwgPSB0aGlzLm9wdHMuZ3JpZExpbmVTcGFjaW5nO1xyXG4gICAgICAgIHZhciBzaGFwZUxpc3QgPSBkb20uZ2V0UmVjdCgpO1xyXG4gICAgICAgIHZhciBkb21BcnJheSA9IHRoYXQuZG9tQXJyYXk7XHJcbiAgICAgICAgLy96cmVuZGVy5LiN5pSv5oyB6ZSu55uY5LqL5Lu277yM5Y+q6IO95L6m5ZCsYm9keeWFg+e0oOS4iueahOS6hlxyXG4gICAgICAgICQoJ2JvZHknKS5vbmUoJ2tleWRvd24nLCBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICAgIHZhciBldiA9IGUgfHwgd2luZG93LmV2ZW50O1xyXG4gICAgICAgICAgICAvL+WIpOaWrSBkZWxldGXmjInplK5cclxuICAgICAgICAgICAgaWYgKGV2LmtleWNvZGUgPT0gNDYgfHwgZXYuY2hhckNvZGUgPT0gNDYgfHwgZXYud2hpY2ggPT0gNDYpIHtcclxuICAgICAgICAgICAgICAgIC8vMS7lpoLmnpzmmK/oioLngrks56e76Zmk5LqL5Lu2LOi/m+ihjOWIoOmZpCAg5aaC5p6c5piv5a2Q6IqC54K5IOmAmui/h3BhcmVudOWIoOmZpFxyXG4gICAgICAgICAgICAgICAgaWYgKHRoYXQuaXNOb2RlID09IHRydWUpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGF0LnNlbGVjdGVkTm9kZS5vZmYoKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhhdC5zZWxlY3RlZE5vZGUucGFyZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChCcG1uLmlzU3ViUHJvY2Vzcyh0aGF0LnNlbGVjdGVkTm9kZS5wYXJlbnQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGF0LnNlbGVjdGVkTm9kZS5wYXJlbnQucmVtb3ZlKHRoYXQuc2VsZWN0ZWROb2RlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuX3pyLnJlbW92ZSh0aGF0LnNlbGVjdGVkTm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIC8vMi7liKDpmaTnu7TmiqTnmoToioLngrnmlbDnu4RcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoYXQuYWxsTm9kZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoYXQuc2VsZWN0ZWROb2RlLmlkID09IHRoYXQuYWxsTm9kZXNbaV0uaWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuYWxsTm9kZXMuc3BsaWNlKGksIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZG9tQXJyYXkubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoYXQuc2VsZWN0ZWROb2RlLmlkID09IGRvbUFycmF5W2pdLmlkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb21BcnJheS5zcGxpY2UoaiwgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCB0aGF0Lm92ZXJsYXBBcnJheS5sZW5ndGg7IGsrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhhdC5zZWxlY3RlZE5vZGUuaWQgPT0gdGhhdC5vdmVybGFwQXJyYXlba10uaWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQub3ZlcmxhcEFycmF5LnNwbGljZShrLCAxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAvLzMu56e75Y675pON5L2c5qGGXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoYXQub3BlcmF0aW9uTm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGF0Ll96ci5yZW1vdmUodGhhdC5vcGVyYXRpb25Ob2RlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5vcGVyYXRpb25Ob2RlID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgLy8zLuWIoOmZpOWvueW6lOeahOe6v1xyXG4gICAgICAgICAgICAgICAgICAgIEJwbW5Db25uZWN0aW9uTWFuYWdlci5kZWxldGVTZWxlY3RDb24odGhhdC5zZWxlY3RlZE5vZGUsIHRoYXQuX3pyKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7IC8v5ZCm5YiZ55u05o6l5Yig6Zmk57q/XHJcbiAgICAgICAgICAgICAgICAgICAgQnBtbkNvbm5lY3Rpb25NYW5hZ2VyLmRlbGV0ZUxpbmUodGhhdC5fenIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5zdGVwQ291bnRlcigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIC8v5Yid5aeL5YyWIOWvuem9kOe6v1xyXG4gICAgICAgIHZhciBzdGFydFgsIHN0YXJ0WSwgcmVjdFBvc2l0aW9uWCwgcmVjdFBvc2l0aW9uWTtcclxuICAgICAgICBzdGFydFggPSBzWDtcclxuICAgICAgICBzdGFydFkgPSBzWTtcclxuICAgICAgICBpZiAoZG9tLnBhcmVudCkge1xyXG4gICAgICAgICAgICBpZiAoQnBtbi5pc1N1YlByb2Nlc3MoZG9tLnBhcmVudCkpIHtcclxuICAgICAgICAgICAgICAgIHJlY3RQb3NpdGlvblggPSBzaGFwZUxpc3QueCArIGRvbS5wYXJlbnQucG9zaXRpb25bMF07XHJcbiAgICAgICAgICAgICAgICByZWN0UG9zaXRpb25ZID0gc2hhcGVMaXN0LnkgKyBkb20ucGFyZW50LnBvc2l0aW9uWzFdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmVjdFBvc2l0aW9uWCA9IHNoYXBlTGlzdC54O1xyXG4gICAgICAgICAgICByZWN0UG9zaXRpb25ZID0gc2hhcGVMaXN0Lnk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghdGhhdC5yZWN0KSB7XHJcbiAgICAgICAgICAgIHRoYXQuaW5pdFZpcnR1YWxMaW5lKHNoYXBlTGlzdCk7XHJcbiAgICAgICAgICAgIHRoYXQucmVjdC5hdHRyKFwicG9zaXRpb25cIiwgW3JlY3RQb3NpdGlvblgsIHJlY3RQb3NpdGlvblldKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGF0LnJlY3QuYXR0cihcInBvc2l0aW9uXCIsIFtyZWN0UG9zaXRpb25YLCByZWN0UG9zaXRpb25ZXSk7XHJcbiAgICAgICAgICAgIHRoYXQucmVjdC5zZXRTaGFwZSh7cG9pbnRzOiBzaGFwZUxpc3QucG9pbnRzfSk7XHJcbiAgICAgICAgICAgIHRoYXQucmVjdC5zaG93KCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgbm93UmVjdFBvc2l0aW9uID0gW3JlY3RQb3NpdGlvblgsIHJlY3RQb3NpdGlvblldO1xyXG4gICAgICAgIHZhciBpc0xhcCA9IDA7XHJcbiAgICAgICAgdmFyIGlzTW92ZSA9IDA7XHJcbiAgICAgICAgdmFyIG1vdmVGdW5jdGlvbiA9IGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgICAgbW92ZURyYWcoZSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB2YXIgdXBGdW5jdGlvbiA9IGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgICAgZW5kRHJhZyhlKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuX3pyLm9uKCdtb3VzZW1vdmUnLCBtb3ZlRnVuY3Rpb24pO1xyXG5cclxuICAgICAgICAvL+W8gOWni+enu+WKqFxyXG4gICAgICAgIGZ1bmN0aW9uIG1vdmVEcmFnKGUpIHtcclxuICAgICAgICAgICAgLy/ku6UxMOS4quWDj+e0oOS4uuWNleS9jei/m+ihjOenu+WKqFxyXG4gICAgICAgICAgICB2YXIgbWF4UmVjdFBvc2l0aW9uID0gW3RoYXQuZ2V0V2lkdGgoKSAtICh0aGF0LnJlY3Quc2hhcGUucG9pbnRzWzFdWzBdIC0gdGhhdC5yZWN0LnNoYXBlLnBvaW50c1swXVswXSkgLyAyLCB0aGF0LmdldEhlaWdodCgpIC0gKHRoYXQucmVjdC5zaGFwZS5wb2ludHNbMl1bMV0gLSB0aGF0LnJlY3Quc2hhcGUucG9pbnRzWzFdWzFdKSAvIDJdO1xyXG4gICAgICAgICAgICB2YXIgbWluUmVjdFBvc2l0aW9uID0gWyh0aGF0LnJlY3Quc2hhcGUucG9pbnRzWzFdWzBdIC0gdGhhdC5yZWN0LnNoYXBlLnBvaW50c1swXVswXSkgLyAyLCAodGhhdC5yZWN0LnNoYXBlLnBvaW50c1syXVsxXSAtIHRoYXQucmVjdC5zaGFwZS5wb2ludHNbMV1bMV0pIC8gMl07XHJcbiAgICAgICAgICAgIGZvciAodmFyIG4gPSAwOyBuIDwgTWF0aC5hYnMocGFyc2VJbnQoKGUuZXZlbnQuY2xpZW50WCAtIHN0YXJ0WCkgLyBwaXhlbCkpOyBuKyspIHtcclxuICAgICAgICAgICAgICAgIGlzTW92ZSA9IDE7XHJcbiAgICAgICAgICAgICAgICBpZiAoZS5ldmVudC5jbGllbnRYIC0gc3RhcnRYIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5vd1JlY3RQb3NpdGlvblswXSA9IHJlY3RQb3NpdGlvblggLSBwaXhlbCAqIChuKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbm93UmVjdFBvc2l0aW9uWzBdID0gcmVjdFBvc2l0aW9uWCArIHBpeGVsICogKG4pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKG5vd1JlY3RQb3NpdGlvblswXSA8IG1pblJlY3RQb3NpdGlvblswXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5vd1JlY3RQb3NpdGlvblswXSA9IG1pblJlY3RQb3NpdGlvblswXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChub3dSZWN0UG9zaXRpb25bMF0gPiBtYXhSZWN0UG9zaXRpb25bMF0pIHtcclxuICAgICAgICAgICAgICAgICAgICBub3dSZWN0UG9zaXRpb25bMF0gPSBtYXhSZWN0UG9zaXRpb25bMF07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZm9yICh2YXIgbSA9IDA7IG0gPCBNYXRoLmFicyhwYXJzZUludCgoZS5ldmVudC5jbGllbnRZIC0gc3RhcnRZKSAvIHBpeGVsKSk7IG0rKykge1xyXG4gICAgICAgICAgICAgICAgaXNNb3ZlID0gMTtcclxuICAgICAgICAgICAgICAgIGlmIChlLmV2ZW50LmNsaWVudFkgLSBzdGFydFkgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbm93UmVjdFBvc2l0aW9uWzFdID0gcmVjdFBvc2l0aW9uWSAtIHBpeGVsICogKG0pO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBub3dSZWN0UG9zaXRpb25bMV0gPSByZWN0UG9zaXRpb25ZICsgcGl4ZWwgKiAobSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAobm93UmVjdFBvc2l0aW9uWzFdIDwgbWluUmVjdFBvc2l0aW9uWzFdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbm93UmVjdFBvc2l0aW9uWzFdID0gbWluUmVjdFBvc2l0aW9uWzFdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKG5vd1JlY3RQb3NpdGlvblsxXSA+IG1heFJlY3RQb3NpdGlvblsxXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5vd1JlY3RQb3NpdGlvblsxXSA9IG1heFJlY3RQb3NpdGlvblsxXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGF0LnJlY3QuYXR0cigncG9zaXRpb24nLCBub3dSZWN0UG9zaXRpb24pO1xyXG5cclxuICAgICAgICAgICAgR3VpZGVsaW5lcy5qdWRnZUFsaWdubWVudChub3dSZWN0UG9zaXRpb24sIGRvbUFycmF5LCB0aGF0LmdldFdpZHRoKCksIHRoYXQuZ2V0SGVpZ2h0KCkpO1xyXG4gICAgICAgICAgICAvLyDlpoLmnpzlpITkuo7lrZDoioLngrnlhoXpg6ggIOWImeS4jeWFgeiuuOaLluWIsOWklumdoiDomZrmoYbmoIfnuqJcclxuICAgICAgICAgICAgaWYgKGRvbS5wYXJlbnQpIHtcclxuICAgICAgICAgICAgICAgIHZhciBjZW50ZXJYID0gTWF0aC5hYnMobm93UmVjdFBvc2l0aW9uWzBdIC0gZG9tLnBhcmVudC5nZXRSZWN0KCkueCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgd2lkdGhYID0gTWF0aC5hYnMoZG9tLmdldFJlY3QoKS53aWR0aCAvIDIgLSBkb20ucGFyZW50LmdldFJlY3QoKS53aWR0aCAvIDIpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGNlbnRlclkgPSBNYXRoLmFicyhub3dSZWN0UG9zaXRpb25bMV0gLSBkb20ucGFyZW50LmdldFJlY3QoKS55KTtcclxuICAgICAgICAgICAgICAgIHZhciBoZWlnaHRZID0gTWF0aC5hYnMoZG9tLmdldFJlY3QoKS5oZWlnaHQgLyAyIC0gZG9tLnBhcmVudC5nZXRSZWN0KCkuaGVpZ2h0IC8gMik7XHJcbiAgICAgICAgICAgICAgICBpZiAoY2VudGVyWCA+ICh3aWR0aFggLSBwaXhlbCkgfHwgY2VudGVyWSA+IChoZWlnaHRZIC0gcGl4ZWwpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0RmFsc2UoKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0U3VjY2VzcygpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBmdW5jdGlvbiByZXN1bHRTdWNjZXNzKCkge1xyXG4gICAgICAgICAgICAgICAgaXNMYXAgPSAwO1xyXG4gICAgICAgICAgICAgICAgdGhhdC5yZWN0LmF0dHIoXCJzdHlsZVwiLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3Ryb2tlOiBcInJnYmEoMCwgMCwgMCwgMSlcIlxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIHJlc3VsdEZhbHNlKCkge1xyXG4gICAgICAgICAgICAgICAgaXNMYXAgPSAxO1xyXG4gICAgICAgICAgICAgICAgdGhhdC5yZWN0LmF0dHIoXCJzdHlsZVwiLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3Ryb2tlOiBcInJnYmEoMjU1LCAwLCAwLCAxKVwiXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy/liKTmlq3mmK/lkKbmnInph43lj6AgIOaOkumZpOWOu+S6huWtkOa1geeoi+mHjOmdoueahOiKgueCuVxyXG4gICAgICAgICAgICBpZiAoIWRvbS5wYXJlbnQpIHtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGwgPSAwLCBsZW4gPSB0aGF0Lm92ZXJsYXBBcnJheS5sZW5ndGg7IGwgPCBsZW47IGwrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciByZWN0RG9tID0gdGhhdC5vdmVybGFwQXJyYXlbbF07XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0U3VjY2VzcygpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8v5LiO5ouW5ou96IqC54K55LiN55u4562JXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlY3REb20uaWQgIT0gdGhhdC5yZWN0LmlkICYmIHJlY3REb20uaWQgIT0gZG9tLmlkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzaGFwZUxpc3Qud2lkdGggPiByZWN0RG9tLndpZHRoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLy8v56e75Yqo55qE5L2N572uIOWHj+WOu+W9k+WJjeiKgueCueeahOS9jee9riDlsI/kuo7mi5bmi73oioLngrnpq5jluqblj4rlrr3luqbkuIDljYrvvIwg5YiZ5pyJ6YeN5Y+gIOagh+e6olxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNoYXBlTGlzdC5oZWlnaHQgPiByZWN0RG9tLmhlaWdodCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyhub3dSZWN0UG9zaXRpb25bMF0gLSAocmVjdERvbS5wb3NpdGlvblswXSkpIDwgc2hhcGVMaXN0LndpZHRoIC8gMiAmJiBNYXRoLmFicyhub3dSZWN0UG9zaXRpb25bMV0gLSAocmVjdERvbS5wb3NpdGlvblsxXSkpIDwgc2hhcGVMaXN0LmhlaWdodCAvIDIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0RmFsc2UoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0U3VjY2VzcygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKE1hdGguYWJzKG5vd1JlY3RQb3NpdGlvblswXSAtIChyZWN0RG9tLnBvc2l0aW9uWzBdKSkgPCBzaGFwZUxpc3Qud2lkdGggLyAyICYmIE1hdGguYWJzKG5vd1JlY3RQb3NpdGlvblsxXSAtIChyZWN0RG9tLnBvc2l0aW9uWzFdKSkgPCByZWN0RG9tLmhlaWdodCAvIDIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0RmFsc2UoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0U3VjY2VzcygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2hhcGVMaXN0LmhlaWdodCA+IHJlY3REb20uaGVpZ2h0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKE1hdGguYWJzKG5vd1JlY3RQb3NpdGlvblswXSAtIChyZWN0RG9tLnBvc2l0aW9uWzBdKSkgPCByZWN0RG9tLndpZHRoIC8gMiAmJiBNYXRoLmFicyhub3dSZWN0UG9zaXRpb25bMV0gLSAocmVjdERvbS5wb3NpdGlvblsxXSkpIDwgc2hhcGVMaXN0LmhlaWdodCAvIDIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0RmFsc2UoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0U3VjY2VzcygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKE1hdGguYWJzKG5vd1JlY3RQb3NpdGlvblswXSAtIChyZWN0RG9tLnBvc2l0aW9uWzBdKSkgPCAocmVjdERvbS53aWR0aCAvIDIpICYmIE1hdGguYWJzKG5vd1JlY3RQb3NpdGlvblsxXSAtIChyZWN0RG9tLnBvc2l0aW9uWzFdKSkgPCAocmVjdERvbS5oZWlnaHQgLyAyKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRGYWxzZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRTdWNjZXNzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy/liKTmlq3kuovku7boioLngrnmmK/lkKblj6/ku6Xkvp3pmYTvvIzlj6/ku6Xkvp3pmYTmmL7npLrnu7/moYZcclxuICAgICAgICAgICAgaWYgKEJwbW4uaXNTbG90RXZlbnQoZG9tKSkge1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGF0LmFsbE5vZGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoYXQuYWxsTm9kZXNbaV0uaXNDYW5TbG90KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGF0LmFsbE5vZGVzW2ldLnNsb3QgJiYgdGhhdC5hbGxOb2Rlc1tpXS5zbG90Lmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGEgPSAwOyBhIDwgdGhhdC5hbGxOb2Rlc1tpXS5zbG90Lmxlbmd0aDsgYSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNsb3RQb3NpdGlvbiA9IFt0aGF0LmFsbE5vZGVzW2ldLnNsb3RbYV0ucG9zaXRpb25bMF0gKyB0aGF0LmFsbE5vZGVzW2ldLnBvc2l0aW9uWzBdLCB0aGF0LmFsbE5vZGVzW2ldLnNsb3RbYV0ucG9zaXRpb25bMV0gKyB0aGF0LmFsbE5vZGVzW2ldLnBvc2l0aW9uWzFdXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobm93UmVjdFBvc2l0aW9uWzBdID09IHNsb3RQb3NpdGlvblswXSAmJiBub3dSZWN0UG9zaXRpb25bMV0gPT0gc2xvdFBvc2l0aW9uWzFdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQucmVjdC5hdHRyKFwic3R5bGVcIiwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3Ryb2tlOiBcInJnYmEoMCwgMjU1LCAwLCAxKVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBlbmREcmFnKCkge1xyXG4gICAgICAgICAgICB0aGF0Ll96ci5vZmYoJ21vdXNlbW92ZScsIG1vdmVGdW5jdGlvbik7XHJcbiAgICAgICAgICAgIHRoYXQuX3pyLm9mZignbW91c2V1cCcsIHVwRnVuY3Rpb24pO1xyXG4gICAgICAgICAgICB0aGF0Ll96ci5vZmYoJ2dsb2JhbG91dCcsIHVwRnVuY3Rpb24pO1xyXG4gICAgICAgICAgICBpZiAoZG9tLnBhcmVudCkge1xyXG4gICAgICAgICAgICAgICAgZG9tLnBhcmVudC5vZmYoXCJnbG9iYWxvdXRcIiwgdXBGdW5jdGlvbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhhdC5yZWN0LmhpZGUoKTtcclxuICAgICAgICAgICAgR3VpZGVsaW5lcy52aXJ0dWFsWExpbmUuYXR0cihcInNoYXBlXCIsIHtcclxuICAgICAgICAgICAgICAgIHgyOiAwXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBHdWlkZWxpbmVzLnZpcnR1YWxZTGluZS5hdHRyKFwic2hhcGVcIiwge1xyXG4gICAgICAgICAgICAgICAgeTI6IDBcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGlmIChpc0xhcCA9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZG9tLnBhcmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChCcG1uLmlzU3ViUHJvY2Vzcyhkb20ucGFyZW50KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZ3JvdXBOb2RlUG9zaXRpb25YID0gZG9tLnBhcmVudC5nZXRSZWN0KCkud2lkdGggLyAyICsgKG5vd1JlY3RQb3NpdGlvblswXSAtIGRvbS5wYXJlbnQuZ2V0UmVjdCgpLngpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZ3JvdXBOb2RlUG9zaXRpb25ZID0gZG9tLnBhcmVudC5nZXRSZWN0KCkuaGVpZ2h0IC8gMiArIChub3dSZWN0UG9zaXRpb25bMV0gLSBkb20ucGFyZW50LmdldFJlY3QoKS55KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRvbS5zbG90RXZlbnQgJiYgZG9tLnNsb3RFdmVudC5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBtID0gMDsgbSA8IGRvbS5zbG90RXZlbnQubGVuZ3RoOyBtKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2xvdEV2ZW50UG9zaXRpb24gPSBbZG9tLnNsb3RFdmVudFttXS5wb3NpdGlvblswXSArIGdyb3VwTm9kZVBvc2l0aW9uWCAtIHpyVXRpbC5jbG9uZShkb20ucG9zaXRpb25bMF0pIC0gZG9tLmdldEJvdW5kaW5nUmVjdCgpLndpZHRoIC8gMiwgZG9tLnNsb3RFdmVudFttXS5wb3NpdGlvblsxXSArIGdyb3VwTm9kZVBvc2l0aW9uWSAtIHpyVXRpbC5jbG9uZShkb20ucG9zaXRpb25bMV0pIC0gZG9tLmdldEJvdW5kaW5nUmVjdCgpLmhlaWdodCAvIDJdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbS5zbG90RXZlbnRbbV0uYXR0cihcInBvc2l0aW9uXCIsIHNsb3RFdmVudFBvc2l0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBCcG1uQ29ubmVjdGlvbk1hbmFnZXIucmVmcmVzaExpbmVCeU5vZGUoZG9tLnNsb3RFdmVudFttXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZG9tLnNldFBvc2l0aW9uKGdyb3VwTm9kZVBvc2l0aW9uWCwgZ3JvdXBOb2RlUG9zaXRpb25ZKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChkb20uc2xvdEV2ZW50ICYmIGRvbS5zbG90RXZlbnQubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBuID0gMDsgbiA8IGRvbS5zbG90RXZlbnQubGVuZ3RoOyBuKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzbG90RXZlbnRQb3NpdGlvbiA9IFtkb20uc2xvdEV2ZW50W25dLnBvc2l0aW9uWzBdICsgbm93UmVjdFBvc2l0aW9uWzBdIC0genJVdGlsLmNsb25lKGRvbS5wb3NpdGlvblswXSkgLSBkb20uZ2V0Qm91bmRpbmdSZWN0KCkud2lkdGggLyAyLCBkb20uc2xvdEV2ZW50W25dLnBvc2l0aW9uWzFdICsgbm93UmVjdFBvc2l0aW9uWzFdIC0genJVdGlsLmNsb25lKGRvbS5wb3NpdGlvblsxXSkgLSBkb20uZ2V0Qm91bmRpbmdSZWN0KCkuaGVpZ2h0IC8gMl07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb20uc2xvdEV2ZW50W25dLmF0dHIoXCJwb3NpdGlvblwiLCBzbG90RXZlbnRQb3NpdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBCcG1uQ29ubmVjdGlvbk1hbmFnZXIucmVmcmVzaExpbmVCeU5vZGUoZG9tLnNsb3RFdmVudFtuXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZG9tLnNldFBvc2l0aW9uKG5vd1JlY3RQb3NpdGlvblswXSwgbm93UmVjdFBvc2l0aW9uWzFdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIGlmIChkb20uYWxhcm0pIHtcclxuICAgICAgICAgICAgICAgIC8vICAgICB2YXIgbmV3QWxhcm1Qb3NpdGlvbiA9IFtub3dSZWN0UG9zaXRpb25bMF0gLSBkb20uZ2V0Qm91bmRpbmdSZWN0KCkud2lkdGggLyAyIC0gKGRvbS5hbGFybS5nZXRCb3VuZGluZ1JlY3QoKS53aWR0aCAtIDYpLCBub3dSZWN0UG9zaXRpb25bMV0gLSBkb20uZ2V0Qm91bmRpbmdSZWN0KCkuaGVpZ2h0IC8gMiAtIGRvbS5hbGFybS5nZXRCb3VuZGluZ1JlY3QoKS5oZWlnaHQgLSAzXTtcclxuICAgICAgICAgICAgICAgIC8vICAgICBkb20uYWxhcm0uYXR0cihcInBvc2l0aW9uXCIsIG5ld0FsYXJtUG9zaXRpb24pO1xyXG4gICAgICAgICAgICAgICAgLy8gfTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGIgPSAwOyBiIDwgdGhhdC5kb21BcnJheS5sZW5ndGg7IGIrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChkb20uaWQgPT0gdGhhdC5kb21BcnJheVtiXS5pZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGF0LmRvbUFycmF5W2JdLnBvc2l0aW9uID0gW25vd1JlY3RQb3NpdGlvblswXSwgbm93UmVjdFBvc2l0aW9uWzFdXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRoYXQub3ZlcmxhcEFycmF5Lmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRvbS5pZCA9PSB0aGF0Lm92ZXJsYXBBcnJheVtqXS5pZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGF0Lm92ZXJsYXBBcnJheVtqXSA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBkb20uaWQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogW25vd1JlY3RQb3NpdGlvblswXSwgbm93UmVjdFBvc2l0aW9uWzFdXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiBkb20uZ2V0UmVjdCgpLndpZHRoLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBkb20uZ2V0UmVjdCgpLmhlaWdodFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKGlzTW92ZSA9PSAxKSB7XHJcbiAgICAgICAgICAgICAgICB0aGF0Lm5vZGVDbGlja0hhbmRsZXIoZG9tKTtcclxuICAgICAgICAgICAgICAgIEJwbW5Db25uZWN0aW9uTWFuYWdlci5yZWZyZXNoTGluZUJ5Tm9kZShkb20pO1xyXG4gICAgICAgICAgICAgICAgdGhhdC5zdGVwQ291bnRlcigpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvL+WwhuS6i+S7tuiKgueCueS4jnRhc2voioLngrnnu5HlrprmiJbop6Pnu5FcclxuICAgICAgICAgICAgaWYgKEJwbW4uaXNTbG90RXZlbnQoZG9tKSkge1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGF0LmFsbE5vZGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoYXQuYWxsTm9kZXNbaV0uaXNDYW5TbG90KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGF0LmFsbE5vZGVzW2ldLnNsb3QgJiYgdGhhdC5hbGxOb2Rlc1tpXS5zbG90Lmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGMgPSAwOyBjIDwgdGhhdC5hbGxOb2Rlc1tpXS5zbG90Lmxlbmd0aDsgYysrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNsb3RQb3NpdGlvbiA9IFt0aGF0LmFsbE5vZGVzW2ldLnNsb3RbY10ucG9zaXRpb25bMF0gKyB0aGF0LmFsbE5vZGVzW2ldLnBvc2l0aW9uWzBdLCB0aGF0LmFsbE5vZGVzW2ldLnNsb3RbY10ucG9zaXRpb25bMV0gKyB0aGF0LmFsbE5vZGVzW2ldLnBvc2l0aW9uWzFdXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmV3UmVjdFBvc2l0aW9uID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRvbS5wYXJlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKEJwbW4uaXNTdWJQcm9jZXNzKGRvbS5wYXJlbnQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdSZWN0UG9zaXRpb25bMF0gPSBkb20ucGFyZW50LmdldFJlY3QoKS53aWR0aCAvIDIgKyAobm93UmVjdFBvc2l0aW9uWzBdIC0gZG9tLnBhcmVudC5nZXRSZWN0KCkueCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdSZWN0UG9zaXRpb25bMV0gPSBkb20ucGFyZW50LmdldFJlY3QoKS5oZWlnaHQgLyAyICsgKG5vd1JlY3RQb3NpdGlvblsxXSAtIGRvbS5wYXJlbnQuZ2V0UmVjdCgpLnkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3UmVjdFBvc2l0aW9uID0gbm93UmVjdFBvc2l0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV3UmVjdFBvc2l0aW9uWzBdID09IHNsb3RQb3NpdGlvblswXSAmJiBuZXdSZWN0UG9zaXRpb25bMV0gPT0gc2xvdFBvc2l0aW9uWzFdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuYWxsTm9kZXNbaV0uc2xvdEV2ZW50LnB1c2goZG9tKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCB0aGF0LmFsbE5vZGVzW2ldLnNsb3RFdmVudC5sZW5ndGg7IGsrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRvbS5pZCA9PSB0aGF0LmFsbE5vZGVzW2ldLnNsb3RFdmVudFtrXS5pZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuYWxsTm9kZXNbaV0uc2xvdEV2ZW50LnNwbGljZShrLCAxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuX3pyLm9uKFwibW91c2V1cFwiLCB1cEZ1bmN0aW9uKTtcclxuICAgICAgICB0aGlzLl96ci5vbihcImdsb2JhbG91dFwiLCB1cEZ1bmN0aW9uKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBmaXNoVG9wb1Byb3RvLmNyZWF0VGlwID0gZnVuY3Rpb24obm9kZSkge1xyXG4gICAgICAgIC8v5Yib5bu6dGFza+WGheWuueeahOaPkOekulxyXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgICAgICB2YXIgZ3JvdXAgPSBuZXcgZ3JhcGhpYy5Hcm91cCgpO1xyXG4gICAgICAgIGdyb3VwLmlzU2hvdyA9IGZhbHNlO1xyXG4gICAgICAgIHZhciBuYW1lID0gbm9kZS5tb2RlbC5nZXQoXCJwcm9wZXJ0aWVzLm5hbWVcIikgfHwgXCJcIjtcclxuICAgICAgICB2YXIgc2hvd05hbWU7XHJcbiAgICAgICAgaWYgKG5hbWUubGVuZ3RoID4gNjQpIHtcclxuICAgICAgICAgICAgc2hvd05hbWUgPSBuYW1lLnN1YnN0cigwLCA2NCkgKyAnLi4nO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHNob3dOYW1lID0gbmFtZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHRleHQgPSBuZXcgZ3JhcGhpYy5UZXh0KHtcclxuICAgICAgICAgICAgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgIHRleHQ6IHNob3dOYW1lLFxyXG4gICAgICAgICAgICAgICAgdGV4dEZvbnQ6ICcxNnB4IE1pY3Jvc29mdCBZYUhlaScsXHJcbiAgICAgICAgICAgICAgICBmaWxsOiBcIiMwMDAwMDBcIixcclxuICAgICAgICAgICAgICAgIHRleHRCYXNlbGluZTogXCJ0b3BcIiAvL+WeguebtOWvuem9kFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBwb3NpdGlvbjogWzIsIDBdLFxyXG4gICAgICAgICAgICB6OiAyXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGV4dC5uYW1lID0gXCJUZXh0XCI7XHJcbiAgICAgICAgZ3JvdXAuYWRkKHRleHQpO1xyXG4gICAgICAgIHZhciBQb2x5bGluZSA9IG5ldyBncmFwaGljLlBvbHlsaW5lKHtcclxuICAgICAgICAgICAgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgIGZpbGw6ICcjZjlmOWY5JyxcclxuICAgICAgICAgICAgICAgIHN0cm9rZTogJyNiYmJiYmInXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHo6IDFcclxuICAgICAgICB9KTtcclxuICAgICAgICBQb2x5bGluZS5uYW1lID0gXCJQb2x5bGluZVwiO1xyXG4gICAgICAgIGdyb3VwLmFkZChQb2x5bGluZSk7XHJcbiAgICAgICAgLy8gdmFyIGdyb3VwUG9zaXRpb24gPSBbbm9kZS5wb3NpdGlvblswXSAtIG5vZGUuZ2V0Qm91bmRpbmdSZWN0KCkud2lkdGgvMiAtIChncm91cC5nZXRCb3VuZGluZ1JlY3QoKS53aWR0aCAtIDYpLCBub2RlLnBvc2l0aW9uWzFdLSBub2RlLmdldEJvdW5kaW5nUmVjdCgpLmhlaWdodCAvIDIgLSBncm91cC5nZXRCb3VuZGluZ1JlY3QoKS5oZWlnaHQgLSAzXTtcclxuICAgICAgICAvLyBncm91cC5hdHRyKFwicG9zaXRpb25cIiwgZ3JvdXBQb3NpdGlvbik7XHJcbiAgICAgICAgdGhhdC5fenIuYWRkKGdyb3VwKTtcclxuICAgICAgICBub2RlLmFsYXJtID0gZ3JvdXA7XHJcbiAgICAgICAgZ3JvdXAuaGlkZSgpO1xyXG4gICAgICAgIGdyb3VwLmVhY2hDaGlsZChmdW5jdGlvbihjaGlsZCkge1xyXG4gICAgICAgICAgICBjaGlsZC5oaWRlKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIGZpc2hUb3BvUHJvdG8uc3RlcENvdW50ZXIgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB0aGlzLnN0ZXBKc29uLnNwbGljZSh0aGlzLnN0ZXAsIHRoaXMuc3RlcEpzb24ubGVuZ3RoIC0gKHRoaXMuc3RlcCkpO1xyXG4gICAgICAgIHRoaXMuc3RlcCArPSAxO1xyXG4gICAgICAgIHZhciBqc29uID0gdGhpcy50b0pzb24oKTtcclxuICAgICAgICB0aGlzLnN0ZXBKc29uLnB1c2goSlNPTi5zdHJpbmdpZnkoanNvbikpO1xyXG4gICAgfTtcclxuICAgIC8vIGZpc2hUb3BvUHJvdG8uc3RlcEZvcndhcmQgPSBmdW5jdGlvbigpIHtcclxuICAgIC8vICAgICBpZiAodGhpcy5zdGVwIDwgdGhpcy5zdGVwSnNvbi5sZW5ndGgpIHtcclxuICAgIC8vICAgICAgICAgdGhpcy5jbGVhcih0cnVlKTtcclxuICAgIC8vICAgICAgICAgdGhpcy5zdGVwICs9IDE7XHJcbiAgICAvLyAgICAgICAgIHZhciBqc29uID0gSlNPTi5wYXJzZSh0aGlzLnN0ZXBKc29uW3RoaXMuc3RlcCAtIDFdKTtcclxuICAgIC8vICAgICAgICAgdGhpcy5mcm9tSnNvbihqc29uKTtcclxuICAgIC8vICAgICB9XHJcbiAgICAvLyB9O1xyXG4gICAgLy8gZmlzaFRvcG9Qcm90by5zdGVwQmFjayA9IGZ1bmN0aW9uKCkge1xyXG4gICAgLy8gICAgIGlmICh0aGlzLnN0ZXAgPiAwKSB7XHJcbiAgICAvLyAgICAgICAgIHRoaXMuY2xlYXIodHJ1ZSk7XHJcbiAgICAvLyAgICAgICAgIHRoaXMuc3RlcCAtPSAxO1xyXG4gICAgLy8gICAgICAgICBpZiAodGhpcy5zdGVwIC0gMSA+PSAwKSB7XHJcbiAgICAvLyAgICAgICAgICAgICB2YXIganNvbiA9IEpTT04ucGFyc2UodGhpcy5zdGVwSnNvblt0aGlzLnN0ZXAgLSAxXSk7XHJcbiAgICAvLyAgICAgICAgICAgICB0aGlzLmZyb21Kc29uKGpzb24pO1xyXG4gICAgLy8gICAgICAgICB9XHJcbiAgICAvLyAgICAgfVxyXG4gICAgLy8gfTtcclxuXHJcblxyXG4gICAgenJVdGlsLm1peGluKEZpc2hUb3BvQnBtbiwgRXZlbnRmdWwpO1xyXG5cclxuICAgIC8vIC0tLS0tLS0tLeWvueWkluaatOmcsmZpc2hUb3BvQnBtbi0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgdmFyIGlkQmFzZSA9IG5ldyBEYXRlKCkgLSAwO1xyXG4gICAgdmFyIGluc3RhbmNlcyA9IHt9O1xyXG4gICAgdmFyIERPTV9BVFRSSUJVVEVfS0VZID0gJ19maXNoVG9wb0JwbW5faW5zdGFuY2VfJztcclxuXHJcbiAgICAvKipcclxuICAgICAqIGZpc2hUb3BvQnBtbuWFqOWxgOWvueixoe+8jOWmguaenOaYr2FtZOaWueW8j+WKoOi9ve+8jOWImeebtOaOpei/lOWbnlxyXG4gICAgICogQGNsYXNzIGZpc2hUb3BvQnBtblxyXG4gICAgICogQHNpbmdsZXRvblxyXG4gICAgICovXHJcbiAgICB2YXIgZmlzaFRvcG9CcG1uID0ge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIOeJiOacrOWPt1xyXG4gICAgICAgICAqIEB0eXBlIHtTdHJpbmd9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdmVyc2lvbjogJzEuMy4wJyxcclxuICAgICAgICBkZXBlbmRlbmNpZXM6IHtcclxuICAgICAgICAgICAgenJlbmRlcjogJzMuMC40J1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDliJ3lp4vljJZkb23lhYPntKDkuLogYnBtbuWvueixoVxyXG4gICAgICogQG1lbWJlciBmaXNoVG9wb0JwbW5cclxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGRvbSAg5LiA5LiqZGl25YWD57SgXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAg5Lyg6YCS55qE6YCJ6aG55Y+C5pWwXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMucmVuZGVyZXI9J2NhbnZhcyddICdjYW52YXMnIG9yICdzdmcnIG9yICd2bWwnXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdHMuZGV2aWNlUGl4ZWxSYXRpbz0xXSByZXRpbmEg5bGP5bmV5LyY5YyWXHJcbiAgICAgKiBAcmV0dXJuIHtmaXNoLnRvcG8uRmlzaFRvcG9CcG1ufVxyXG4gICAgICovXHJcbiAgICBmaXNoVG9wb0JwbW4uaW5pdCA9IGZ1bmN0aW9uKGRvbSwgb3B0cykge1xyXG4gICAgICAgIGlmICghZG9tKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW5pdGlhbGl6ZSBmYWlsZWQ6IGludmFsaWQgZG9tLicpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgb3B0cyA9IG9wdHMgfHwge307XHJcbiAgICAgICAgLy8gRGVmYXVsdCB2YWx1ZVxyXG4gICAgICAgIHpyVXRpbC5kZWZhdWx0cyhvcHRzLCB7XHJcbiAgICAgICAgICAgIHR5cGU6IFwiYnBtblwiLFxyXG4gICAgICAgICAgICBzaG93R3JpZExpbmU6IHRydWUsXHJcbiAgICAgICAgICAgIGRldmljZVBpeGVsUmF0aW86IDEsXHJcbiAgICAgICAgICAgIGdyaWRMaW5lU3BhY2luZzogMTBcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgdmFyIGZpc2hUb3BvQnBtbiA9IG5ldyBGaXNoVG9wb0JwbW4oZG9tLCBvcHRzKTtcclxuICAgICAgICBmaXNoVG9wb0JwbW4uaW5pdCgpO1xyXG5cclxuICAgICAgICBmaXNoVG9wb0JwbW4uaWQgPSAnZnRfJyArIGlkQmFzZSsrO1xyXG4gICAgICAgIGluc3RhbmNlc1tmaXNoVG9wb0JwbW4uaWRdID0gZmlzaFRvcG9CcG1uO1xyXG5cclxuICAgICAgICBkb20uc2V0QXR0cmlidXRlICYmIGRvbS5zZXRBdHRyaWJ1dGUoRE9NX0FUVFJJQlVURV9LRVksIGZpc2hUb3BvQnBtbi5pZCk7XHJcblxyXG4gICAgICAgIHJldHVybiBmaXNoVG9wb0JwbW47XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIOiOt+WPliBkb20g5a655Zmo5LiK55qE5a6e5L6L44CCXHJcbiAgICAgKiBAbWVtYmVyIGZpc2hUb3BvQnBtblxyXG4gICAgICogQHBhcmFtICB7SFRNTEVsZW1lbnR9IGRvbSDkuIDkuKpkaXblhYPntKBcclxuICAgICAqIEByZXR1cm4ge2Zpc2gudG9wby5GaXNoVG9wb0JwbW59XHJcbiAgICAgKi9cclxuICAgIGZpc2hUb3BvQnBtbi5nZXRJbnN0YW5jZUJ5RG9tID0gZnVuY3Rpb24oZG9tKSB7XHJcbiAgICAgICAgdmFyIGtleSA9IGRvbS5nZXRBdHRyaWJ1dGUoRE9NX0FUVFJJQlVURV9LRVkpO1xyXG4gICAgICAgIHJldHVybiBpbnN0YW5jZXNba2V5XTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDplIDmr4Hlrp7kvovvvIzlrp7kvovplIDmr4HlkI7ml6Dms5Xlho3ooqvkvb/nlKjjgIJcclxuICAgICAqIEBtZW1iZXIgZmlzaFRvcG9CcG1uXHJcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R8c3RyaW5nfSBjaGFydCBmaXNoVG9wb0JwbW7lrp7kvosg5oiWIGZpc2hUb3BvQnBtbueahGlkXHJcbiAgICAgKi9cclxuICAgIGZpc2hUb3BvQnBtbi5kaXNwb3NlID0gZnVuY3Rpb24oY2hhcnQpIHtcclxuICAgICAgICB2YXIgdG9wbztcclxuICAgICAgICBpZiAoenJVdGlsLmlzRG9tKGNoYXJ0KSkge1xyXG4gICAgICAgICAgICB0b3BvID0gZmlzaFRvcG9CcG1uLmdldEluc3RhbmNlQnlEb20oY2hhcnQpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGNoYXJ0ID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICB0b3BvID0gaW5zdGFuY2VzW2NoYXJ0XTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCh0b3BvIGluc3RhbmNlb2YgZmlzaFRvcG9CcG1uKSAmJiAhdG9wby5pc0Rpc3Bvc2VkKCkpIHtcclxuICAgICAgICAgICAgdG9wby5kaXNwb3NlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8v5pq06Zyy5Ye65Y6755qE57G7IOaWueS+v+eUqOaIt+aJqeWxleWbvuWFg1xyXG4gICAgZmlzaFRvcG9CcG1uLkJwbW4gPSBCcG1uO1xyXG4gICAgZmlzaFRvcG9CcG1uLkJQTU5Ob2RlID0gQlBNTk5vZGU7XHJcbiAgICBmaXNoVG9wb0JwbW4uZ3JhcGhpYyA9IGdyYXBoaWM7XHJcbiAgICBmaXNoVG9wb0JwbW4uQm91bmRpbmdSZWN0ID0gQm91bmRpbmdSZWN0O1xyXG5cclxuICAgIGZpc2hUb3BvQnBtbi51dGlsID0ge307XHJcbiAgICB6clV0aWwuZWFjaChbXHJcbiAgICAgICAgICAgICdtYXAnLCAnZWFjaCcsICdmaWx0ZXInLCAnaW5kZXhPZicsICdpbmhlcml0cycsXHJcbiAgICAgICAgICAgICdyZWR1Y2UnLCAnZmlsdGVyJywgJ2JpbmQnLCAnY3VycnknLCAnaXNBcnJheScsXHJcbiAgICAgICAgICAgICdpc1N0cmluZycsICdpc09iamVjdCcsICdpc0Z1bmN0aW9uJywgJ2V4dGVuZCdcclxuICAgICAgICBdLFxyXG4gICAgICAgIGZ1bmN0aW9uKG5hbWUpIHtcclxuICAgICAgICAgICAgZmlzaFRvcG9CcG1uLnV0aWxbbmFtZV0gPSB6clV0aWxbbmFtZV07XHJcbiAgICAgICAgfVxyXG4gICAgKTtcclxuICAgIG1vZHVsZS5leHBvcnRzID0gZmlzaFRvcG9CcG1uO1xyXG5cclxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2xpYi9maXNoLXRvcG8tYnBtbi9saWIvRmlzaFRvcG9CcG1uLmpzXG4gKiogbW9kdWxlIGlkID0gMlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXHJcblxyXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xyXG5cclxuICAgIHZhciBwYXRoVG9vbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL3Rvb2wvcGF0aCcpO1xyXG4gICAgdmFyIHJvdW5kID0gTWF0aC5yb3VuZDtcclxuICAgIHZhciBQYXRoID0gcmVxdWlyZSgnenJlbmRlci9saWIvZ3JhcGhpYy9QYXRoJyk7XHJcbiAgICB2YXIgY29sb3JUb29sID0gcmVxdWlyZSgnenJlbmRlci9saWIvdG9vbC9jb2xvcicpO1xyXG4gICAgdmFyIG1hdHJpeCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvbWF0cml4Jyk7XHJcbiAgICB2YXIgdmVjdG9yID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS92ZWN0b3InKTtcclxuICAgIHZhciBHcmFkaWVudCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2dyYXBoaWMvR3JhZGllbnQnKTtcclxuICAgIHZhciBEcmFnZ2FibGUgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9taXhpbi9EcmFnZ2FibGUnKTtcclxuXHJcbiAgICB2YXIgZ3JhcGhpYyA9IHt9O1xyXG4gICAgZ3JhcGhpYy5VdGlsID0genJVdGlsO1xyXG4gICAgZ3JhcGhpYy5Hcm91cCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvbnRhaW5lci9Hcm91cCcpO1xyXG5cclxuICAgIGdyYXBoaWMuSW1hZ2UgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9ncmFwaGljL0ltYWdlJyk7XHJcblxyXG4gICAgZ3JhcGhpYy5UZXh0ID0gcmVxdWlyZSgnenJlbmRlci9saWIvZ3JhcGhpYy9UZXh0Jyk7XHJcblxyXG4gICAgZ3JhcGhpYy50ZXh0Q29udGFpbiA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvbnRhaW4vdGV4dCcpO1xyXG5cclxuICAgIGdyYXBoaWMuQ2lyY2xlID0gcmVxdWlyZSgnenJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9DaXJjbGUnKTtcclxuXHJcbiAgICBncmFwaGljLlNlY3RvciA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvU2VjdG9yJyk7XHJcblxyXG4gICAgZ3JhcGhpYy5SaW5nID0gcmVxdWlyZSgnenJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9SaW5nJyk7XHJcblxyXG4gICAgZ3JhcGhpYy5Qb2x5Z29uID0gcmVxdWlyZSgnenJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9Qb2x5Z29uJyk7XHJcblxyXG4gICAgZ3JhcGhpYy5Qb2x5bGluZSA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvUG9seWxpbmUnKTtcclxuXHJcbiAgICBncmFwaGljLlJlY3QgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL1JlY3QnKTtcclxuXHJcbiAgICBncmFwaGljLkxpbmUgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL0xpbmUnKTtcclxuXHJcbiAgICBncmFwaGljLkJlemllckN1cnZlID0gcmVxdWlyZSgnenJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9CZXppZXJDdXJ2ZScpO1xyXG5cclxuICAgIGdyYXBoaWMuQXJjID0gcmVxdWlyZSgnenJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9BcmMnKTtcclxuXHJcbiAgICBncmFwaGljLkxpbmVhckdyYWRpZW50ID0gcmVxdWlyZSgnenJlbmRlci9saWIvZ3JhcGhpYy9MaW5lYXJHcmFkaWVudCcpO1xyXG5cclxuICAgIGdyYXBoaWMuUmFkaWFsR3JhZGllbnQgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9ncmFwaGljL1JhZGlhbEdyYWRpZW50Jyk7XHJcblxyXG4gICAgZ3JhcGhpYy5Cb3VuZGluZ1JlY3QgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL0JvdW5kaW5nUmVjdCcpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRXh0ZW5kIHNoYXBlIHdpdGggcGFyYW1ldGVyc1xyXG4gICAgICovXHJcbiAgICBncmFwaGljLmV4dGVuZFNoYXBlID0gZnVuY3Rpb24gKG9wdHMpIHtcclxuICAgICAgICByZXR1cm4gUGF0aC5leHRlbmQob3B0cyk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRXh0ZW5kIHBhdGhcclxuICAgICAqL1xyXG4gICAgZ3JhcGhpYy5leHRlbmRQYXRoID0gZnVuY3Rpb24gKHBhdGhEYXRhLCBvcHRzKSB7XHJcbiAgICAgICAgcmV0dXJuIHBhdGhUb29sLmV4dGVuZEZyb21TdHJpbmcocGF0aERhdGEsIG9wdHMpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZSBhIHBhdGggZWxlbWVudCBmcm9tIHBhdGggZGF0YSBzdHJpbmdcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoRGF0YVxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHNcclxuICAgICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvY29yZS9Cb3VuZGluZ1JlY3R9IHJlY3RcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbbGF5b3V0PWNvdmVyXSAnY2VudGVyJyBvciAnY292ZXInXHJcbiAgICAgKi9cclxuICAgIGdyYXBoaWMubWFrZVBhdGggPSBmdW5jdGlvbiAocGF0aERhdGEsIG9wdHMsIHJlY3QsIGxheW91dCkge1xyXG4gICAgICAgIHZhciBwYXRoID0gcGF0aFRvb2wuY3JlYXRlRnJvbVN0cmluZyhwYXRoRGF0YSwgb3B0cyk7XHJcbiAgICAgICAgRHJhZ2dhYmxlLmNhbGwocGF0aCk7XHJcbiAgICAgICAgdmFyIGJvdW5kaW5nUmVjdCA9IHBhdGguZ2V0Qm91bmRpbmdSZWN0KCk7XHJcbiAgICAgICAgaWYgKHJlY3QpIHtcclxuICAgICAgICAgICAgdmFyIGFzcGVjdCA9IGJvdW5kaW5nUmVjdC53aWR0aCAvIGJvdW5kaW5nUmVjdC5oZWlnaHQ7XHJcblxyXG4gICAgICAgICAgICBpZiAobGF5b3V0ID09PSAnY2VudGVyJykge1xyXG4gICAgICAgICAgICAgICAgLy8gU2V0IHJlY3QgdG8gY2VudGVyLCBrZWVwIHdpZHRoIC8gaGVpZ2h0IHJhdGlvLlxyXG4gICAgICAgICAgICAgICAgdmFyIHdpZHRoID0gcmVjdC5oZWlnaHQgKiBhc3BlY3Q7XHJcbiAgICAgICAgICAgICAgICB2YXIgaGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgaWYgKHdpZHRoIDw9IHJlY3Qud2lkdGgpIHtcclxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQgPSByZWN0LmhlaWdodDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoID0gcmVjdC53aWR0aDtcclxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQgPSB3aWR0aCAvIGFzcGVjdDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBjeCA9IHJlY3QueCArIHJlY3Qud2lkdGggLyAyO1xyXG4gICAgICAgICAgICAgICAgdmFyIGN5ID0gcmVjdC55ICsgcmVjdC5oZWlnaHQgLyAyO1xyXG5cclxuICAgICAgICAgICAgICAgIHJlY3QueCA9IGN4IC0gd2lkdGggLyAyO1xyXG4gICAgICAgICAgICAgICAgcmVjdC55ID0gY3kgLSBoZWlnaHQgLyAyO1xyXG4gICAgICAgICAgICAgICAgcmVjdC53aWR0aCA9IHdpZHRoO1xyXG4gICAgICAgICAgICAgICAgcmVjdC5oZWlnaHQgPSBoZWlnaHQ7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHRoaXMucmVzaXplUGF0aChwYXRoLCByZWN0KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHpyVXRpbC5pbmhlcml0cyhwYXRoLCBEcmFnZ2FibGUpO1xyXG4gICAgICAgIHJldHVybiBwYXRoO1xyXG4gICAgfTtcclxuXHJcbiAgICBncmFwaGljLm1lcmdlUGF0aCA9IHBhdGhUb29sLm1lcmdlUGF0aDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlc2l6ZSBhIHBhdGggdG8gZml0IHRoZSByZWN0XHJcbiAgICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL2dyYXBoaWMvUGF0aH0gcGF0aFxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHJlY3RcclxuICAgICAqL1xyXG4gICAgZ3JhcGhpYy5yZXNpemVQYXRoID0gZnVuY3Rpb24gKHBhdGgsIHJlY3QpIHtcclxuICAgICAgICBpZiAoIXBhdGguYXBwbHlUcmFuc2Zvcm0pIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHBhdGhSZWN0ID0gcGF0aC5nZXRCb3VuZGluZ1JlY3QoKTtcclxuXHJcbiAgICAgICAgdmFyIG0gPSBwYXRoUmVjdC5jYWxjdWxhdGVUcmFuc2Zvcm0ocmVjdCk7XHJcblxyXG4gICAgICAgIHBhdGguYXBwbHlUcmFuc2Zvcm0obSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU3ViIHBpeGVsIG9wdGltaXplIGxpbmUgZm9yIGNhbnZhc1xyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbVxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtwYXJhbS5zaGFwZV1cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcGFyYW0uc2hhcGUueDFdXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3BhcmFtLnNoYXBlLnkxXVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtwYXJhbS5zaGFwZS54Ml1cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcGFyYW0uc2hhcGUueTJdXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3BhcmFtLnN0eWxlXVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtwYXJhbS5zdHlsZS5saW5lV2lkdGhdXHJcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IE1vZGlmaWVkIHBhcmFtXHJcbiAgICAgKi9cclxuICAgIGdyYXBoaWMuc3ViUGl4ZWxPcHRpbWl6ZUxpbmUgPSBmdW5jdGlvbiAocGFyYW0pIHtcclxuICAgICAgICB2YXIgc3ViUGl4ZWxPcHRpbWl6ZSA9IGdyYXBoaWMuc3ViUGl4ZWxPcHRpbWl6ZTtcclxuICAgICAgICB2YXIgc2hhcGUgPSBwYXJhbS5zaGFwZTtcclxuICAgICAgICB2YXIgbGluZVdpZHRoID0gcGFyYW0uc3R5bGUubGluZVdpZHRoO1xyXG5cclxuICAgICAgICBpZiAocm91bmQoc2hhcGUueDEgKiAyKSA9PT0gcm91bmQoc2hhcGUueDIgKiAyKSkge1xyXG4gICAgICAgICAgICBzaGFwZS54MSA9IHNoYXBlLngyID0gc3ViUGl4ZWxPcHRpbWl6ZShzaGFwZS54MSwgbGluZVdpZHRoLCB0cnVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHJvdW5kKHNoYXBlLnkxICogMikgPT09IHJvdW5kKHNoYXBlLnkyICogMikpIHtcclxuICAgICAgICAgICAgc2hhcGUueTEgPSBzaGFwZS55MiA9IHN1YlBpeGVsT3B0aW1pemUoc2hhcGUueTEsIGxpbmVXaWR0aCwgdHJ1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBwYXJhbTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTdWIgcGl4ZWwgb3B0aW1pemUgcmVjdCBmb3IgY2FudmFzXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3BhcmFtLnNoYXBlXVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtwYXJhbS5zaGFwZS54XVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtwYXJhbS5zaGFwZS55XVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtwYXJhbS5zaGFwZS53aWR0aF1cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcGFyYW0uc2hhcGUuaGVpZ2h0XVxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtwYXJhbS5zdHlsZV1cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcGFyYW0uc3R5bGUubGluZVdpZHRoXVxyXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBNb2RpZmllZCBwYXJhbVxyXG4gICAgICovXHJcbiAgICBncmFwaGljLnN1YlBpeGVsT3B0aW1pemVSZWN0ID0gZnVuY3Rpb24gKHBhcmFtKSB7XHJcbiAgICAgICAgdmFyIHN1YlBpeGVsT3B0aW1pemUgPSBncmFwaGljLnN1YlBpeGVsT3B0aW1pemU7XHJcbiAgICAgICAgdmFyIHNoYXBlID0gcGFyYW0uc2hhcGU7XHJcbiAgICAgICAgdmFyIGxpbmVXaWR0aCA9IHBhcmFtLnN0eWxlLmxpbmVXaWR0aDtcclxuICAgICAgICB2YXIgb3JpZ2luWCA9IHNoYXBlLng7XHJcbiAgICAgICAgdmFyIG9yaWdpblkgPSBzaGFwZS55O1xyXG4gICAgICAgIHZhciBvcmlnaW5XaWR0aCA9IHNoYXBlLndpZHRoO1xyXG4gICAgICAgIHZhciBvcmlnaW5IZWlnaHQgPSBzaGFwZS5oZWlnaHQ7XHJcbiAgICAgICAgc2hhcGUueCA9IHN1YlBpeGVsT3B0aW1pemUoc2hhcGUueCwgbGluZVdpZHRoLCB0cnVlKTtcclxuICAgICAgICBzaGFwZS55ID0gc3ViUGl4ZWxPcHRpbWl6ZShzaGFwZS55LCBsaW5lV2lkdGgsIHRydWUpO1xyXG4gICAgICAgIHNoYXBlLndpZHRoID0gTWF0aC5tYXgoXHJcbiAgICAgICAgICAgIHN1YlBpeGVsT3B0aW1pemUob3JpZ2luWCArIG9yaWdpbldpZHRoLCBsaW5lV2lkdGgsIGZhbHNlKSAtIHNoYXBlLngsXHJcbiAgICAgICAgICAgIG9yaWdpbldpZHRoID09PSAwID8gMCA6IDFcclxuICAgICAgICApO1xyXG4gICAgICAgIHNoYXBlLmhlaWdodCA9IE1hdGgubWF4KFxyXG4gICAgICAgICAgICBzdWJQaXhlbE9wdGltaXplKG9yaWdpblkgKyBvcmlnaW5IZWlnaHQsIGxpbmVXaWR0aCwgZmFsc2UpIC0gc2hhcGUueSxcclxuICAgICAgICAgICAgb3JpZ2luSGVpZ2h0ID09PSAwID8gMCA6IDFcclxuICAgICAgICApO1xyXG4gICAgICAgIHJldHVybiBwYXJhbTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTdWIgcGl4ZWwgb3B0aW1pemUgZm9yIGNhbnZhc1xyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwb3NpdGlvbiBDb29yZGluYXRlLCBzdWNoIGFzIHgsIHlcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsaW5lV2lkdGggU2hvdWxkIGJlIG5vbm5lZ2F0aXZlIGludGVnZXIuXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBwb3NpdGl2ZU9yTmVnYXRpdmUgRGVmYXVsdCBmYWxzZSAobmVnYXRpdmUpLlxyXG4gICAgICogQHJldHVybiB7bnVtYmVyfSBPcHRpbWl6ZWQgcG9zaXRpb24uXHJcbiAgICAgKi9cclxuICAgIGdyYXBoaWMuc3ViUGl4ZWxPcHRpbWl6ZSA9IGZ1bmN0aW9uIChwb3NpdGlvbiwgbGluZVdpZHRoLCBwb3NpdGl2ZU9yTmVnYXRpdmUpIHtcclxuICAgICAgICAvLyBBc3N1cmUgdGhhdCAocG9zaXRpb24gKyBsaW5lV2lkdGggLyAyKSBpcyBuZWFyIGludGVnZXIgZWRnZSxcclxuICAgICAgICAvLyBvdGhlcndpc2UgbGluZSB3aWxsIGJlIGZ1enp5IGluIGNhbnZhcy5cclxuICAgICAgICB2YXIgZG91YmxlZFBvc2l0aW9uID0gcm91bmQocG9zaXRpb24gKiAyKTtcclxuICAgICAgICByZXR1cm4gKGRvdWJsZWRQb3NpdGlvbiArIHJvdW5kKGxpbmVXaWR0aCkpICUgMiA9PT0gMFxyXG4gICAgICAgICAgICA/IGRvdWJsZWRQb3NpdGlvbiAvIDJcclxuICAgICAgICAgICAgOiAoZG91YmxlZFBvc2l0aW9uICsgKHBvc2l0aXZlT3JOZWdhdGl2ZSA/IDEgOiAtMSkpIC8gMjtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBkb1NpbmdsZUVudGVySG92ZXIoZWwpIHtcclxuICAgICAgICBpZiAoZWwuX19pc0hvdmVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGVsLl9faG92ZXJTdGxEaXJ0eSkge1xyXG4gICAgICAgICAgICB2YXIgc3Ryb2tlID0gZWwuc3R5bGUuc3Ryb2tlO1xyXG4gICAgICAgICAgICB2YXIgZmlsbCA9IGVsLnN0eWxlLmZpbGw7XHJcblxyXG4gICAgICAgICAgICAvLyBDcmVhdGUgaG92ZXJTdHlsZSBvbiBtb3VzZW92ZXJcclxuICAgICAgICAgICAgdmFyIGhvdmVyU3R5bGUgPSBlbC5fX2hvdmVyU3RsO1xyXG4gICAgICAgICAgICB2YXIgbGlmdCA9IGNvbG9yVG9vbC5saWZ0O1xyXG4gICAgICAgICAgICBob3ZlclN0eWxlLmZpbGwgPSBob3ZlclN0eWxlLmZpbGxcclxuICAgICAgICAgICAgICAgIHx8IChmaWxsICYmIChmaWxsIGluc3RhbmNlb2YgR3JhZGllbnQgPyBmaWxsIDogbGlmdChmaWxsLCAtMC4xKSkpO1xyXG4gICAgICAgICAgICBob3ZlclN0eWxlLnN0cm9rZSA9IGhvdmVyU3R5bGUuc3Ryb2tlXHJcbiAgICAgICAgICAgICAgICB8fCAoc3Ryb2tlICYmIChzdHJva2UgaW5zdGFuY2VvZiBHcmFkaWVudCA/IHN0cm9rZSA6IGxpZnQoc3Ryb2tlLCAtMC4xKSkpO1xyXG5cclxuICAgICAgICAgICAgdmFyIG5vcm1hbFN0eWxlID0ge307XHJcbiAgICAgICAgICAgIGZvciAodmFyIG5hbWUgaW4gaG92ZXJTdHlsZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGhvdmVyU3R5bGUuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBub3JtYWxTdHlsZVtuYW1lXSA9IGVsLnN0eWxlW25hbWVdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBlbC5fX25vcm1hbFN0bCA9IG5vcm1hbFN0eWxlO1xyXG5cclxuICAgICAgICAgICAgZWwuX19ob3ZlclN0bERpcnR5ID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsLnNldFN0eWxlKGVsLl9faG92ZXJTdGwpO1xyXG4gICAgICAgIGVsLnoyICs9IDE7XHJcblxyXG4gICAgICAgIGVsLl9faXNIb3ZlciA9IHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAaW5uZXJcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZG9TaW5nbGVMZWF2ZUhvdmVyKGVsKSB7XHJcbiAgICAgICAgaWYgKCFlbC5fX2lzSG92ZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIG5vcm1hbFN0bCA9IGVsLl9fbm9ybWFsU3RsO1xyXG4gICAgICAgIG5vcm1hbFN0bCAmJiBlbC5zZXRTdHlsZShub3JtYWxTdGwpO1xyXG4gICAgICAgIGVsLnoyIC09IDE7XHJcblxyXG4gICAgICAgIGVsLl9faXNIb3ZlciA9IGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGlubmVyXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGRvRW50ZXJIb3ZlcihlbCkge1xyXG4gICAgICAgIGVsLnR5cGUgPT09ICdncm91cCdcclxuICAgICAgICAgICAgPyBlbC50cmF2ZXJzZShmdW5jdGlvbiAoY2hpbGQpIHtcclxuICAgICAgICAgICAgICAgIGlmIChjaGlsZC50eXBlICE9PSAnZ3JvdXAnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZG9TaW5nbGVFbnRlckhvdmVyKGNoaWxkKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgOiBkb1NpbmdsZUVudGVySG92ZXIoZWwpO1xyXG4gICAgfVxyXG4gICAgZ3JhcGhpYy5kb0VudGVySG92ZXIgPSBkb0VudGVySG92ZXI7XHJcbiAgICBmdW5jdGlvbiBkb0xlYXZlSG92ZXIoZWwpIHtcclxuICAgICAgICBlbC50eXBlID09PSAnZ3JvdXAnXHJcbiAgICAgICAgICAgID8gZWwudHJhdmVyc2UoZnVuY3Rpb24gKGNoaWxkKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQudHlwZSAhPT0gJ2dyb3VwJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGRvU2luZ2xlTGVhdmVIb3ZlcihjaGlsZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIDogZG9TaW5nbGVMZWF2ZUhvdmVyKGVsKTtcclxuICAgIH1cclxuICAgIGdyYXBoaWMuZG9MZWF2ZUhvdmVyID0gZG9MZWF2ZUhvdmVyO1xyXG4gICAgLyoqXHJcbiAgICAgKiBAaW5uZXJcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gc2V0RWxlbWVudEhvdmVyU3RsKGVsLCBob3ZlclN0bCkge1xyXG4gICAgICAgIC8vIElmIGVsZW1lbnQgaGFzIHNlcGNpZmllZCBob3ZlclN0eWxlLCB0aGVuIHVzZSBpdCBpbnN0ZWFkIG9mIGdpdmVuIGhvdmVyU3R5bGVcclxuICAgICAgICAvLyBPZnRlbiB1c2VkIHdoZW4gaXRlbSBncm91cCBoYXMgYSBsYWJlbCBlbGVtZW50IGFuZCBpdCdzIGhvdmVyU3R5bGUgaXMgZGlmZmVyZW50XHJcbiAgICAgICAgZWwuX19ob3ZlclN0bCA9IGVsLmhvdmVyU3R5bGUgfHwgaG92ZXJTdGwgfHwge307XHJcbiAgICAgICAgZWwuX19ob3ZlclN0bERpcnR5ID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIGdyYXBoaWMuc2V0RWxlbWVudEhvdmVyU3RsID0gc2V0RWxlbWVudEhvdmVyU3RsO1xyXG4gICAgLyoqXHJcbiAgICAgKiBAaW5uZXJcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gb25FbGVtZW50TW91c2VPdmVyKCkge1xyXG4gICAgICAgIC8vIE9ubHkgaWYgZWxlbWVudCBpcyBub3QgaW4gZW1waGFzaXMgc3RhdHVzXHJcbiAgICAgICAgIXRoaXMuX19pc0VtcGhhc2lzICYmIGRvRW50ZXJIb3Zlcih0aGlzKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBpbm5lclxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBvbkVsZW1lbnRNb3VzZU91dCgpIHtcclxuICAgICAgICAvLyBPbmx5IGlmIGVsZW1lbnQgaXMgbm90IGluIGVtcGhhc2lzIHN0YXR1c1xyXG4gICAgICAgICF0aGlzLl9faXNFbXBoYXNpcyAmJiBkb0xlYXZlSG92ZXIodGhpcyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAaW5uZXJcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZW50ZXJFbXBoYXNpcygpIHtcclxuICAgICAgICB0aGlzLl9faXNFbXBoYXNpcyA9IHRydWU7XHJcbiAgICAgICAgZG9FbnRlckhvdmVyKHRoaXMpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGlubmVyXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGxlYXZlRW1waGFzaXMoKSB7XHJcbiAgICAgICAgdGhpcy5fX2lzRW1waGFzaXMgPSBmYWxzZTtcclxuICAgICAgICBkb0xlYXZlSG92ZXIodGhpcyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgaG92ZXIgc3R5bGUgb2YgZWxlbWVudFxyXG4gICAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9FbGVtZW50fSBlbFxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtob3ZlclN0eWxlXVxyXG4gICAgICovXHJcbiAgICBncmFwaGljLnNldEhvdmVyU3R5bGUgPSBmdW5jdGlvbiAoZWwsIGhvdmVyU3R5bGUpIHtcclxuICAgICAgICBlbC50eXBlID09PSAnZ3JvdXAnXHJcbiAgICAgICAgICAgID8gZWwudHJhdmVyc2UoZnVuY3Rpb24gKGNoaWxkKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQudHlwZSAhPT0gJ2dyb3VwJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHNldEVsZW1lbnRIb3ZlclN0bChjaGlsZCwgaG92ZXJTdHlsZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIDogc2V0RWxlbWVudEhvdmVyU3RsKGVsLCBob3ZlclN0eWxlKTtcclxuICAgICAgICAvLyBSZW1vdmUgcHJldmlvdXMgYm91bmQgaGFuZGxlcnNcclxuICAgICAgICBlbC5vbignbW91c2VvdmVyJywgb25FbGVtZW50TW91c2VPdmVyKVxyXG4gICAgICAgICAgLm9uKCdtb3VzZW91dCcsIG9uRWxlbWVudE1vdXNlT3V0KTtcclxuXHJcbiAgICAgICAgLy8gRW1waGFzaXMsIG5vcm1hbCBjYW4gYmUgdHJpZ2dlcmVkIG1hbnVhbGx5XHJcbiAgICAgICAgZWwub24oJ2VtcGhhc2lzJywgZW50ZXJFbXBoYXNpcylcclxuICAgICAgICAgIC5vbignbm9ybWFsJywgbGVhdmVFbXBoYXNpcyk7XHJcbiAgICB9O1xyXG5cclxuICAgIGdyYXBoaWMuc2V0Tm9ybWFsU3R5bGUgPSBmdW5jdGlvbihlbCwgb3B0aW9ucykge1xyXG4gICAgICAgIGlmIChlbC5fX25vcm1hbFN0bCkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBuYW1lIGluIG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgICAgIGlmIChlbC5fX25vcm1hbFN0bC5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGVsLl9fbm9ybWFsU3RsW25hbWVdID0gb3B0aW9uc1tuYW1lXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdGV4dCBvcHRpb24gaW4gdGhlIHN0eWxlXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdGV4dFN0eWxlXHJcbiAgICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL21vZGVsL01vZGVsfSBsYWJlbE1vZGVsXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29sb3JcclxuICAgICAqL1xyXG4gICAgZ3JhcGhpYy5zZXRUZXh0ID0gZnVuY3Rpb24gKHRleHRTdHlsZSwgbGFiZWxNb2RlbCwgY29sb3IpIHtcclxuICAgICAgICB2YXIgbGFiZWxQb3NpdGlvbiA9IGxhYmVsTW9kZWwuZ2V0U2hhbGxvdygncG9zaXRpb24nKSB8fCAnaW5zaWRlJztcclxuICAgICAgICB2YXIgbGFiZWxDb2xvciA9IGxhYmVsUG9zaXRpb24uaW5kZXhPZignaW5zaWRlJykgPj0gMCA/ICd3aGl0ZScgOiBjb2xvcjtcclxuICAgICAgICB2YXIgdGV4dFN0eWxlTW9kZWwgPSBsYWJlbE1vZGVsLmdldE1vZGVsKCd0ZXh0U3R5bGUnKTtcclxuICAgICAgICB6clV0aWwuZXh0ZW5kKHRleHRTdHlsZSwge1xyXG4gICAgICAgICAgICB0ZXh0RGlzdGFuY2U6IGxhYmVsTW9kZWwuZ2V0U2hhbGxvdygnZGlzdGFuY2UnKSB8fCA1LFxyXG4gICAgICAgICAgICB0ZXh0Rm9udDogdGV4dFN0eWxlTW9kZWwuZ2V0Rm9udCgpLFxyXG4gICAgICAgICAgICB0ZXh0UG9zaXRpb246IGxhYmVsUG9zaXRpb24sXHJcbiAgICAgICAgICAgIHRleHRGaWxsOiB0ZXh0U3R5bGVNb2RlbC5nZXRUZXh0Q29sb3IoKSB8fCBsYWJlbENvbG9yXHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIGZ1bmN0aW9uIGFuaW1hdGVPclNldFByb3BzKGlzVXBkYXRlLCBlbCwgcHJvcHMsIGFuaW1hdGFibGVNb2RlbCwgY2IpIHtcclxuICAgICAgICB2YXIgcG9zdGZpeCA9IGlzVXBkYXRlID8gJ1VwZGF0ZScgOiAnJztcclxuICAgICAgICB2YXIgZHVyYXRpb24gPSBhbmltYXRhYmxlTW9kZWxcclxuICAgICAgICAgICAgJiYgYW5pbWF0YWJsZU1vZGVsLmdldFNoYWxsb3coJ2FuaW1hdGlvbkR1cmF0aW9uJyArIHBvc3RmaXgpO1xyXG4gICAgICAgIHZhciBhbmltYXRpb25FYXNpbmcgPSBhbmltYXRhYmxlTW9kZWxcclxuICAgICAgICAgICAgJiYgYW5pbWF0YWJsZU1vZGVsLmdldFNoYWxsb3coJ2FuaW1hdGlvbkVhc2luZycgKyBwb3N0Zml4KTtcclxuXHJcbiAgICAgICAgYW5pbWF0YWJsZU1vZGVsICYmIGFuaW1hdGFibGVNb2RlbC5nZXRTaGFsbG93KCdhbmltYXRpb24nKVxyXG4gICAgICAgICAgICA/IGVsLmFuaW1hdGVUbyhwcm9wcywgZHVyYXRpb24sIGFuaW1hdGlvbkVhc2luZywgY2IpXHJcbiAgICAgICAgICAgIDogKGVsLmF0dHIocHJvcHMpLCBjYiAmJiBjYigpKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlIGdyYXBoaWMgZWxlbWVudCBwcm9wZXJ0aWVzIHdpdGggb3Igd2l0aG91dCBhbmltYXRpb24gYWNjb3JkaW5nIHRvIHRoZSBjb25maWd1cmF0aW9uIGluIHNlcmllc1xyXG4gICAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9FbGVtZW50fSBlbFxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHByb3BzXHJcbiAgICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL21vZGVsL01vZGVsfSBbYW5pbWF0YWJsZU1vZGVsXVxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcclxuICAgICAqL1xyXG4gICAgZ3JhcGhpYy51cGRhdGVQcm9wcyA9IHpyVXRpbC5jdXJyeShhbmltYXRlT3JTZXRQcm9wcywgdHJ1ZSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJbml0IGdyYXBoaWMgZWxlbWVudCBwcm9wZXJ0aWVzIHdpdGggb3Igd2l0aG91dCBhbmltYXRpb24gYWNjb3JkaW5nIHRvIHRoZSBjb25maWd1cmF0aW9uIGluIHNlcmllc1xyXG4gICAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9FbGVtZW50fSBlbFxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHByb3BzXHJcbiAgICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL21vZGVsL01vZGVsfSBbYW5pbWF0YWJsZU1vZGVsXVxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcclxuICAgICAqL1xyXG4gICAgZ3JhcGhpYy5pbml0UHJvcHMgPSB6clV0aWwuY3VycnkoYW5pbWF0ZU9yU2V0UHJvcHMsIGZhbHNlKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldCB0cmFuc2Zvcm0gbWF0cml4IG9mIHRhcmdldCAocGFyYW0gdGFyZ2V0KSxcclxuICAgICAqIGluIGNvb3JkaW5hdGUgb2YgaXRzIGFuY2VzdG9yIChwYXJhbSBhbmNlc3RvcilcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL21peGluL1RyYW5zZm9ybWFibGV9IHRhcmdldFxyXG4gICAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9taXhpbi9UcmFuc2Zvcm1hYmxlfSBhbmNlc3RvclxyXG4gICAgICovXHJcbiAgICBncmFwaGljLmdldFRyYW5zZm9ybSA9IGZ1bmN0aW9uICh0YXJnZXQsIGFuY2VzdG9yKSB7XHJcbiAgICAgICAgdmFyIG1hdCA9IG1hdHJpeC5pZGVudGl0eShbXSk7XHJcblxyXG4gICAgICAgIHdoaWxlICh0YXJnZXQgJiYgdGFyZ2V0ICE9PSBhbmNlc3Rvcikge1xyXG4gICAgICAgICAgICBtYXRyaXgubXVsKG1hdCwgdGFyZ2V0LmdldExvY2FsVHJhbnNmb3JtKCksIG1hdCk7XHJcbiAgICAgICAgICAgIHRhcmdldCA9IHRhcmdldC5wYXJlbnQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gbWF0O1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFwcGx5IHRyYW5zZm9ybSB0byBhbiB2ZXJ0ZXguXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSB2ZXJ0ZXggW3gsIHldXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSB0cmFuc2Zvcm0gVHJhbnNmb3JtIG1hdHJpeDogbGlrZSBbMSwgMCwgMCwgMSwgMCwgMF1cclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IGludmVydCBXaGV0aGVyIHVzZSBpbnZlcnQgbWF0cml4LlxyXG4gICAgICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59IFt4LCB5XVxyXG4gICAgICovXHJcbiAgICBncmFwaGljLmFwcGx5VHJhbnNmb3JtID0gZnVuY3Rpb24gKHZlcnRleCwgdHJhbnNmb3JtLCBpbnZlcnQpIHtcclxuICAgICAgICBpZiAoaW52ZXJ0KSB7XHJcbiAgICAgICAgICAgIHRyYW5zZm9ybSA9IG1hdHJpeC5pbnZlcnQoW10sIHRyYW5zZm9ybSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB2ZWN0b3IuYXBwbHlUcmFuc2Zvcm0oW10sIHZlcnRleCwgdHJhbnNmb3JtKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZGlyZWN0aW9uICdsZWZ0JyAncmlnaHQnICd0b3AnICdib3R0b20nXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSB0cmFuc2Zvcm0gVHJhbnNmb3JtIG1hdHJpeDogbGlrZSBbMSwgMCwgMCwgMSwgMCwgMF1cclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IGludmVydCBXaGV0aGVyIHVzZSBpbnZlcnQgbWF0cml4LlxyXG4gICAgICogQHJldHVybiB7c3RyaW5nfSBUcmFuc2Zvcm1lZCBkaXJlY3Rpb24uICdsZWZ0JyAncmlnaHQnICd0b3AnICdib3R0b20nXHJcbiAgICAgKi9cclxuICAgIGdyYXBoaWMudHJhbnNmb3JtRGlyZWN0aW9uID0gZnVuY3Rpb24gKGRpcmVjdGlvbiwgdHJhbnNmb3JtLCBpbnZlcnQpIHtcclxuXHJcbiAgICAgICAgLy8gUGljayBhIGJhc2UsIGVuc3VyZSB0aGF0IHRyYW5zZm9ybSByZXN1bHQgd2lsbCBub3QgYmUgKDAsIDApLlxyXG4gICAgICAgIHZhciBoQmFzZSA9ICh0cmFuc2Zvcm1bNF0gPT09IDAgfHwgdHJhbnNmb3JtWzVdID09PSAwIHx8IHRyYW5zZm9ybVswXSA9PT0gMClcclxuICAgICAgICAgICAgPyAxIDogTWF0aC5hYnMoMiAqIHRyYW5zZm9ybVs0XSAvIHRyYW5zZm9ybVswXSk7XHJcbiAgICAgICAgdmFyIHZCYXNlID0gKHRyYW5zZm9ybVs0XSA9PT0gMCB8fCB0cmFuc2Zvcm1bNV0gPT09IDAgfHwgdHJhbnNmb3JtWzJdID09PSAwKVxyXG4gICAgICAgICAgICA/IDEgOiBNYXRoLmFicygyICogdHJhbnNmb3JtWzRdIC8gdHJhbnNmb3JtWzJdKTtcclxuXHJcbiAgICAgICAgdmFyIHZlcnRleCA9IFtcclxuICAgICAgICAgICAgZGlyZWN0aW9uID09PSAnbGVmdCcgPyAtaEJhc2UgOiBkaXJlY3Rpb24gPT09ICdyaWdodCcgPyBoQmFzZSA6IDAsXHJcbiAgICAgICAgICAgIGRpcmVjdGlvbiA9PT0gJ3RvcCcgPyAtdkJhc2UgOiBkaXJlY3Rpb24gPT09ICdib3R0b20nID8gdkJhc2UgOiAwXHJcbiAgICAgICAgXTtcclxuXHJcbiAgICAgICAgdmVydGV4ID0gZ3JhcGhpYy5hcHBseVRyYW5zZm9ybSh2ZXJ0ZXgsIHRyYW5zZm9ybSwgaW52ZXJ0KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIE1hdGguYWJzKHZlcnRleFswXSkgPiBNYXRoLmFicyh2ZXJ0ZXhbMV0pXHJcbiAgICAgICAgICAgID8gKHZlcnRleFswXSA+IDAgPyAncmlnaHQnIDogJ2xlZnQnKVxyXG4gICAgICAgICAgICA6ICh2ZXJ0ZXhbMV0gPiAwID8gJ2JvdHRvbScgOiAndG9wJyk7XHJcbiAgICB9O1xyXG5cclxuICAgIG1vZHVsZS5leHBvcnRzID0gZ3JhcGhpYztcclxuXHJcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9saWIvZmlzaC10b3BvLWNvcmUvbGliL2dyYXBoaWMuanNcbiAqKiBtb2R1bGUgaWQgPSAzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIEBtb2R1bGUgenJlbmRlci9jb3JlL3V0aWxcbiAqL1xuXG5cbiAgICAvLyDnlKjkuo7lpITnkIZtZXJnZeaXtuaXoOazlemBjeWOhkRhdGXnrYnlr7nosaHnmoTpl67pophcbiAgICB2YXIgQlVJTFRJTl9PQkpFQ1QgPSB7XG4gICAgICAgICdbb2JqZWN0IEZ1bmN0aW9uXSc6IDEsXG4gICAgICAgICdbb2JqZWN0IFJlZ0V4cF0nOiAxLFxuICAgICAgICAnW29iamVjdCBEYXRlXSc6IDEsXG4gICAgICAgICdbb2JqZWN0IEVycm9yXSc6IDEsXG4gICAgICAgICdbb2JqZWN0IENhbnZhc0dyYWRpZW50XSc6IDEsXG4gICAgICAgICdbb2JqZWN0IENhbnZhc1BhdHRlcm5dJzogMSxcbiAgICAgICAgLy8gSW4gbm9kZS1jYW52YXMgSW1hZ2UgY2FuIGJlIENhbnZhcy5JbWFnZVxuICAgICAgICAnW29iamVjdCBJbWFnZV0nOiAxXG4gICAgfTtcblxuICAgIHZhciBvYmpUb1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbiAgICB2YXIgYXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZTtcbiAgICB2YXIgbmF0aXZlRm9yRWFjaCA9IGFycmF5UHJvdG8uZm9yRWFjaDtcbiAgICB2YXIgbmF0aXZlRmlsdGVyID0gYXJyYXlQcm90by5maWx0ZXI7XG4gICAgdmFyIG5hdGl2ZVNsaWNlID0gYXJyYXlQcm90by5zbGljZTtcbiAgICB2YXIgbmF0aXZlTWFwID0gYXJyYXlQcm90by5tYXA7XG4gICAgdmFyIG5hdGl2ZVJlZHVjZSA9IGFycmF5UHJvdG8ucmVkdWNlO1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHsqfSBzb3VyY2VcbiAgICAgKiBAcmV0dXJuIHsqfSDmi7fotJ3lkI7nmoTmlrDlr7nosaFcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjbG9uZShzb3VyY2UpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzb3VyY2UgPT0gJ29iamVjdCcgJiYgc291cmNlICE9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gc291cmNlO1xuICAgICAgICAgICAgaWYgKHNvdXJjZSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHNvdXJjZS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRbaV0gPSBjbG9uZShzb3VyY2VbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKFxuICAgICAgICAgICAgICAgICFpc0J1aWxkSW5PYmplY3Qoc291cmNlKVxuICAgICAgICAgICAgICAgIC8vIOaYr+WQpuS4uiBkb20g5a+56LGhXG4gICAgICAgICAgICAgICAgJiYgIWlzRG9tKHNvdXJjZSlcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHt9O1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNvdXJjZS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRba2V5XSA9IGNsb25lKHNvdXJjZVtrZXldKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzb3VyY2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICAgICAqIEBwYXJhbSB7Kn0gdGFyZ2V0XG4gICAgICogQHBhcmFtIHsqfSBzb3VyY2VcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvdmVyd3JpdGU9ZmFsc2VdXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWVyZ2UodGFyZ2V0LCBzb3VyY2UsIG92ZXJ3cml0ZSkge1xuICAgICAgICAvLyBXZSBzaG91bGQgZXNjYXBzZSB0aGF0IHNvdXJjZSBpcyBzdHJpbmdcbiAgICAgICAgLy8gYW5kIGVudGVyIGZvciAuLi4gaW4gLi4uXG4gICAgICAgIGlmICghaXNPYmplY3Qoc291cmNlKSB8fCAhaXNPYmplY3QodGFyZ2V0KSkge1xuICAgICAgICAgICAgcmV0dXJuIG92ZXJ3cml0ZSA/IGNsb25lKHNvdXJjZSkgOiB0YXJnZXQ7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgICAgICBpZiAoc291cmNlLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0UHJvcCA9IHRhcmdldFtrZXldO1xuICAgICAgICAgICAgICAgIHZhciBzb3VyY2VQcm9wID0gc291cmNlW2tleV07XG5cbiAgICAgICAgICAgICAgICBpZiAoaXNPYmplY3Qoc291cmNlUHJvcClcbiAgICAgICAgICAgICAgICAgICAgJiYgaXNPYmplY3QodGFyZ2V0UHJvcClcbiAgICAgICAgICAgICAgICAgICAgJiYgIWlzQXJyYXkoc291cmNlUHJvcClcbiAgICAgICAgICAgICAgICAgICAgJiYgIWlzQXJyYXkodGFyZ2V0UHJvcClcbiAgICAgICAgICAgICAgICAgICAgJiYgIWlzRG9tKHNvdXJjZVByb3ApXG4gICAgICAgICAgICAgICAgICAgICYmICFpc0RvbSh0YXJnZXRQcm9wKVxuICAgICAgICAgICAgICAgICAgICAmJiAhaXNCdWlsZEluT2JqZWN0KHNvdXJjZVByb3ApXG4gICAgICAgICAgICAgICAgICAgICYmICFpc0J1aWxkSW5PYmplY3QodGFyZ2V0UHJvcClcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8g5aaC5p6c6ZyA6KaB6YCS5b2S6KaG55uW77yM5bCx6YCS5b2S6LCD55SobWVyZ2VcbiAgICAgICAgICAgICAgICAgICAgbWVyZ2UodGFyZ2V0UHJvcCwgc291cmNlUHJvcCwgb3ZlcndyaXRlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAob3ZlcndyaXRlIHx8ICEoa2V5IGluIHRhcmdldCkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8g5ZCm5YiZ5Y+q5aSE55CGb3ZlcndyaXRl5Li6dHJ1Ze+8jOaIluiAheWcqOebruagh+WvueixoeS4reayoeacieatpOWxnuaAp+eahOaDheWGtVxuICAgICAgICAgICAgICAgICAgICAvLyBOT1RF77yM5ZyoIHRhcmdldFtrZXldIOS4jeWtmOWcqOeahOaXtuWAmeS5n+aYr+ebtOaOpeimhuebllxuICAgICAgICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IGNsb25lKHNvdXJjZVtrZXldLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHRhcmdldEFuZFNvdXJjZXMgVGhlIGZpcnN0IGl0ZW0gaXMgdGFyZ2V0LCBhbmQgdGhlIHJlc3RzIGFyZSBzb3VyY2UuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3ZlcndyaXRlPWZhbHNlXVxuICAgICAqIEByZXR1cm4geyp9IHRhcmdldFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1lcmdlQWxsKHRhcmdldEFuZFNvdXJjZXMsIG92ZXJ3cml0ZSkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gdGFyZ2V0QW5kU291cmNlc1swXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDEsIGxlbiA9IHRhcmdldEFuZFNvdXJjZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IG1lcmdlKHJlc3VsdCwgdGFyZ2V0QW5kU291cmNlc1tpXSwgb3ZlcndyaXRlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Kn0gdGFyZ2V0XG4gICAgICogQHBhcmFtIHsqfSBzb3VyY2VcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gICAgICovXG4gICAgZnVuY3Rpb24gZXh0ZW5kKHRhcmdldCwgc291cmNlKSB7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgICAgIGlmIChzb3VyY2UuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyp9IHRhcmdldFxuICAgICAqIEBwYXJhbSB7Kn0gc291cmNlXG4gICAgICogQHBhcmFtIHtib29sZW59IFtvdmVybGF5PWZhbHNlXVxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL3V0aWxcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkZWZhdWx0cyh0YXJnZXQsIHNvdXJjZSwgb3ZlcmxheSkge1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgICAgICBpZiAoc291cmNlLmhhc093blByb3BlcnR5KGtleSlcbiAgICAgICAgICAgICAgICAmJiAob3ZlcmxheSA/IHNvdXJjZVtrZXldICE9IG51bGwgOiB0YXJnZXRba2V5XSA9PSBudWxsKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUNhbnZhcygpIHtcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgIH1cbiAgICAvLyBGSVhNRVxuICAgIHZhciBfY3R4O1xuICAgIGZ1bmN0aW9uIGdldENvbnRleHQoKSB7XG4gICAgICAgIGlmICghX2N0eCkge1xuICAgICAgICAgICAgLy8gVXNlIHV0aWwuY3JlYXRlQ2FudmFzIGluc3RlYWQgb2YgY3JlYXRlQ2FudmFzXG4gICAgICAgICAgICAvLyBiZWNhdXNlIGNyZWF0ZUNhbnZhcyBtYXkgYmUgb3ZlcndyaXR0ZW4gaW4gZGlmZmVyZW50IGVudmlyb25tZW50XG4gICAgICAgICAgICBfY3R4ID0gdXRpbC5jcmVhdGVDYW52YXMoKS5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfY3R4O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOafpeivouaVsOe7hOS4reWFg+e0oOeahGluZGV4XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluZGV4T2YoYXJyYXksIHZhbHVlKSB7XG4gICAgICAgIGlmIChhcnJheSkge1xuICAgICAgICAgICAgaWYgKGFycmF5LmluZGV4T2YpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJyYXkuaW5kZXhPZih2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gYXJyYXkubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoYXJyYXlbaV0gPT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog5p6E6YCg57G757un5om/5YWz57O7XG4gICAgICpcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2xhenog5rqQ57G7XG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gYmFzZUNsYXp6IOWfuuexu1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluaGVyaXRzKGNsYXp6LCBiYXNlQ2xhenopIHtcbiAgICAgICAgdmFyIGNsYXp6UHJvdG90eXBlID0gY2xhenoucHJvdG90eXBlO1xuICAgICAgICBmdW5jdGlvbiBGKCkge31cbiAgICAgICAgRi5wcm90b3R5cGUgPSBiYXNlQ2xhenoucHJvdG90eXBlO1xuICAgICAgICBjbGF6ei5wcm90b3R5cGUgPSBuZXcgRigpO1xuXG4gICAgICAgIGZvciAodmFyIHByb3AgaW4gY2xhenpQcm90b3R5cGUpIHtcbiAgICAgICAgICAgIGNsYXp6LnByb3RvdHlwZVtwcm9wXSA9IGNsYXp6UHJvdG90eXBlW3Byb3BdO1xuICAgICAgICB9XG4gICAgICAgIGNsYXp6LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGNsYXp6O1xuICAgICAgICBjbGF6ei5zdXBlckNsYXNzID0gYmFzZUNsYXp6O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL3V0aWxcbiAgICAgKiBAcGFyYW0ge09iamVjdHxGdW5jdGlvbn0gdGFyZ2V0XG4gICAgICogQHBhcmFtIHtPYmplY3R8RnVuY3Rpb259IHNvcmNlXG4gICAgICogQHBhcmFtIHtib29sZWFufSBvdmVybGF5XG4gICAgICovXG4gICAgZnVuY3Rpb24gbWl4aW4odGFyZ2V0LCBzb3VyY2UsIG92ZXJsYXkpIHtcbiAgICAgICAgdGFyZ2V0ID0gJ3Byb3RvdHlwZScgaW4gdGFyZ2V0ID8gdGFyZ2V0LnByb3RvdHlwZSA6IHRhcmdldDtcbiAgICAgICAgc291cmNlID0gJ3Byb3RvdHlwZScgaW4gc291cmNlID8gc291cmNlLnByb3RvdHlwZSA6IHNvdXJjZTtcblxuICAgICAgICBkZWZhdWx0cyh0YXJnZXQsIHNvdXJjZSwgb3ZlcmxheSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtBcnJheXxUeXBlZEFycmF5fSBkYXRhXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNBcnJheUxpa2UoZGF0YSkge1xuICAgICAgICBpZiAoISBkYXRhKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhID09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHR5cGVvZiBkYXRhLmxlbmd0aCA9PSAnbnVtYmVyJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDmlbDnu4TmiJblr7nosaHpgY3ljoZcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gICAgICogQHBhcmFtIHtPYmplY3R8QXJyYXl9IG9ialxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiXG4gICAgICogQHBhcmFtIHsqfSBbY29udGV4dF1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlYWNoKG9iaiwgY2IsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKCEob2JqICYmIGNiKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvYmouZm9yRWFjaCAmJiBvYmouZm9yRWFjaCA9PT0gbmF0aXZlRm9yRWFjaCkge1xuICAgICAgICAgICAgb2JqLmZvckVhY2goY2IsIGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9iai5sZW5ndGggPT09ICtvYmoubGVuZ3RoKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gb2JqLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY2IuY2FsbChjb250ZXh0LCBvYmpbaV0sIGksIG9iaik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNiLmNhbGwoY29udGV4dCwgb2JqW2tleV0sIGtleSwgb2JqKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDmlbDnu4TmmKDlsIRcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gICAgICogQHBhcmFtIHtBcnJheX0gb2JqXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcbiAgICAgKiBAcGFyYW0geyp9IFtjb250ZXh0XVxuICAgICAqIEByZXR1cm4ge0FycmF5fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1hcChvYmosIGNiLCBjb250ZXh0KSB7XG4gICAgICAgIGlmICghKG9iaiAmJiBjYikpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2JqLm1hcCAmJiBvYmoubWFwID09PSBuYXRpdmVNYXApIHtcbiAgICAgICAgICAgIHJldHVybiBvYmoubWFwKGNiLCBjb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBvYmoubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChjYi5jYWxsKGNvbnRleHQsIG9ialtpXSwgaSwgb2JqKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IG9ialxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFttZW1vXVxuICAgICAqIEBwYXJhbSB7Kn0gW2NvbnRleHRdXG4gICAgICogQHJldHVybiB7QXJyYXl9XG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVkdWNlKG9iaiwgY2IsIG1lbW8sIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKCEob2JqICYmIGNiKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvYmoucmVkdWNlICYmIG9iai5yZWR1Y2UgPT09IG5hdGl2ZVJlZHVjZSkge1xuICAgICAgICAgICAgcmV0dXJuIG9iai5yZWR1Y2UoY2IsIG1lbW8sIGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IG9iai5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIG1lbW8gPSBjYi5jYWxsKGNvbnRleHQsIG1lbW8sIG9ialtpXSwgaSwgb2JqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtZW1vO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog5pWw57uE6L+H5rukXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IG9ialxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiXG4gICAgICogQHBhcmFtIHsqfSBbY29udGV4dF1cbiAgICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaWx0ZXIob2JqLCBjYiwgY29udGV4dCkge1xuICAgICAgICBpZiAoIShvYmogJiYgY2IpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9iai5maWx0ZXIgJiYgb2JqLmZpbHRlciA9PT0gbmF0aXZlRmlsdGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqLmZpbHRlcihjYiwgY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gb2JqLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNiLmNhbGwoY29udGV4dCwgb2JqW2ldLCBpLCBvYmopKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG9ialtpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOaVsOe7hOmhueafpeaJvlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL3V0aWxcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBvYmpcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYlxuICAgICAqIEBwYXJhbSB7Kn0gW2NvbnRleHRdXG4gICAgICogQHJldHVybiB7QXJyYXl9XG4gICAgICovXG4gICAgZnVuY3Rpb24gZmluZChvYmosIGNiLCBjb250ZXh0KSB7XG4gICAgICAgIGlmICghKG9iaiAmJiBjYikpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gb2JqLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoY2IuY2FsbChjb250ZXh0LCBvYmpbaV0sIGksIG9iaikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmNcbiAgICAgKiBAcGFyYW0geyp9IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiaW5kKGZ1bmMsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBuYXRpdmVTbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzLmNvbmNhdChuYXRpdmVTbGljZS5jYWxsKGFyZ3VtZW50cykpKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuY1xuICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGN1cnJ5KGZ1bmMpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBuYXRpdmVTbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuYy5hcHBseSh0aGlzLCBhcmdzLmNvbmNhdChuYXRpdmVTbGljZS5jYWxsKGFyZ3VtZW50cykpKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNBcnJheSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gb2JqVG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09ICdbb2JqZWN0IEFycmF5XSc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNTdHJpbmcodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIG9ialRvU3RyaW5nLmNhbGwodmFsdWUpID09PSAnW29iamVjdCBTdHJpbmddJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgICAgICAgLy8gQXZvaWQgYSBWOCBKSVQgYnVnIGluIENocm9tZSAxOS0yMC5cbiAgICAgICAgLy8gU2VlIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0yMjkxIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICAgIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICAgICAgICByZXR1cm4gdHlwZSA9PT0gJ2Z1bmN0aW9uJyB8fCAoISF2YWx1ZSAmJiB0eXBlID09ICdvYmplY3QnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNCdWlsZEluT2JqZWN0KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAhIUJVSUxUSU5fT0JKRUNUW29ialRvU3RyaW5nLmNhbGwodmFsdWUpXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNEb20odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlICYmIHZhbHVlLm5vZGVUeXBlID09PSAxXG4gICAgICAgICAgICAgICAmJiB0eXBlb2YodmFsdWUubm9kZU5hbWUpID09ICdzdHJpbmcnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIElmIHZhbHVlMSBpcyBub3QgbnVsbCwgdGhlbiByZXR1cm4gdmFsdWUxLCBvdGhlcndpc2UganVkZ2V0IHJlc3Qgb2YgdmFsdWVzLlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL3V0aWxcbiAgICAgKiBAcmV0dXJuIHsqfSBGaW5hbCB2YWx1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJldHJpZXZlKHZhbHVlcykge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoYXJndW1lbnRzW2ldICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFyclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydEluZGV4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGVuZEluZGV4XG4gICAgICogQHJldHVybiB7QXJyYXl9XG4gICAgICovXG4gICAgZnVuY3Rpb24gc2xpY2UoKSB7XG4gICAgICAgIHJldHVybiBGdW5jdGlvbi5jYWxsLmFwcGx5KG5hdGl2ZVNsaWNlLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL3V0aWxcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGNvbmRpdGlvblxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlXG4gICAgICovXG4gICAgZnVuY3Rpb24gYXNzZXJ0KGNvbmRpdGlvbiwgbWVzc2FnZSkge1xuICAgICAgICBpZiAoIWNvbmRpdGlvbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHV0aWwgPSB7XG4gICAgICAgIGluaGVyaXRzOiBpbmhlcml0cyxcbiAgICAgICAgbWl4aW46IG1peGluLFxuICAgICAgICBjbG9uZTogY2xvbmUsXG4gICAgICAgIG1lcmdlOiBtZXJnZSxcbiAgICAgICAgbWVyZ2VBbGw6IG1lcmdlQWxsLFxuICAgICAgICBleHRlbmQ6IGV4dGVuZCxcbiAgICAgICAgZGVmYXVsdHM6IGRlZmF1bHRzLFxuICAgICAgICBnZXRDb250ZXh0OiBnZXRDb250ZXh0LFxuICAgICAgICBjcmVhdGVDYW52YXM6IGNyZWF0ZUNhbnZhcyxcbiAgICAgICAgaW5kZXhPZjogaW5kZXhPZixcbiAgICAgICAgc2xpY2U6IHNsaWNlLFxuICAgICAgICBmaW5kOiBmaW5kLFxuICAgICAgICBpc0FycmF5TGlrZTogaXNBcnJheUxpa2UsXG4gICAgICAgIGVhY2g6IGVhY2gsXG4gICAgICAgIG1hcDogbWFwLFxuICAgICAgICByZWR1Y2U6IHJlZHVjZSxcbiAgICAgICAgZmlsdGVyOiBmaWx0ZXIsXG4gICAgICAgIGJpbmQ6IGJpbmQsXG4gICAgICAgIGN1cnJ5OiBjdXJyeSxcbiAgICAgICAgaXNBcnJheTogaXNBcnJheSxcbiAgICAgICAgaXNTdHJpbmc6IGlzU3RyaW5nLFxuICAgICAgICBpc09iamVjdDogaXNPYmplY3QsXG4gICAgICAgIGlzRnVuY3Rpb246IGlzRnVuY3Rpb24sXG4gICAgICAgIGlzQnVpbGRJbk9iamVjdDogaXNCdWlsZEluT2JqZWN0LFxuICAgICAgICBpc0RvbTogaXNEb20sXG4gICAgICAgIHJldHJpZXZlOiByZXRyaWV2ZSxcbiAgICAgICAgYXNzZXJ0OiBhc3NlcnQsXG4gICAgICAgIG5vb3A6IGZ1bmN0aW9uICgpIHt9XG4gICAgfTtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHV0aWw7XG5cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3pyZW5kZXIvbGliL2NvcmUvdXRpbC5qc1xuICoqIG1vZHVsZSBpZCA9IDRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlxuXG4gICAgdmFyIFBhdGggPSByZXF1aXJlKCcuLi9ncmFwaGljL1BhdGgnKTtcbiAgICB2YXIgUGF0aFByb3h5ID0gcmVxdWlyZSgnLi4vY29yZS9QYXRoUHJveHknKTtcbiAgICB2YXIgdHJhbnNmb3JtUGF0aCA9IHJlcXVpcmUoJy4vdHJhbnNmb3JtUGF0aCcpO1xuICAgIHZhciBtYXRyaXggPSByZXF1aXJlKCcuLi9jb3JlL21hdHJpeCcpO1xuXG4gICAgLy8gY29tbWFuZCBjaGFyc1xuICAgIHZhciBjYyA9IFtcbiAgICAgICAgJ20nLCAnTScsICdsJywgJ0wnLCAndicsICdWJywgJ2gnLCAnSCcsICd6JywgJ1onLFxuICAgICAgICAnYycsICdDJywgJ3EnLCAnUScsICd0JywgJ1QnLCAncycsICdTJywgJ2EnLCAnQSdcbiAgICBdO1xuXG4gICAgdmFyIG1hdGhTcXJ0ID0gTWF0aC5zcXJ0O1xuICAgIHZhciBtYXRoU2luID0gTWF0aC5zaW47XG4gICAgdmFyIG1hdGhDb3MgPSBNYXRoLmNvcztcbiAgICB2YXIgUEkgPSBNYXRoLlBJO1xuXG4gICAgdmFyIHZNYWcgPSBmdW5jdGlvbih2KSB7XG4gICAgICAgIHJldHVybiBNYXRoLnNxcnQodlswXSAqIHZbMF0gKyB2WzFdICogdlsxXSk7XG4gICAgfTtcbiAgICB2YXIgdlJhdGlvID0gZnVuY3Rpb24odSwgdikge1xuICAgICAgICByZXR1cm4gKHVbMF0gKiB2WzBdICsgdVsxXSAqIHZbMV0pIC8gKHZNYWcodSkgKiB2TWFnKHYpKTtcbiAgICB9O1xuICAgIHZhciB2QW5nbGUgPSBmdW5jdGlvbih1LCB2KSB7XG4gICAgICAgIHJldHVybiAodVswXSAqIHZbMV0gPCB1WzFdICogdlswXSA/IC0xIDogMSlcbiAgICAgICAgICAgICAgICAqIE1hdGguYWNvcyh2UmF0aW8odSwgdikpO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBwcm9jZXNzQXJjKHgxLCB5MSwgeDIsIHkyLCBmYSwgZnMsIHJ4LCByeSwgcHNpRGVnLCBjbWQsIHBhdGgpIHtcbiAgICAgICAgdmFyIHBzaSA9IHBzaURlZyAqIChQSSAvIDE4MC4wKTtcbiAgICAgICAgdmFyIHhwID0gbWF0aENvcyhwc2kpICogKHgxIC0geDIpIC8gMi4wXG4gICAgICAgICAgICAgICAgICsgbWF0aFNpbihwc2kpICogKHkxIC0geTIpIC8gMi4wO1xuICAgICAgICB2YXIgeXAgPSAtMSAqIG1hdGhTaW4ocHNpKSAqICh4MSAtIHgyKSAvIDIuMFxuICAgICAgICAgICAgICAgICArIG1hdGhDb3MocHNpKSAqICh5MSAtIHkyKSAvIDIuMDtcblxuICAgICAgICB2YXIgbGFtYmRhID0gKHhwICogeHApIC8gKHJ4ICogcngpICsgKHlwICogeXApIC8gKHJ5ICogcnkpO1xuXG4gICAgICAgIGlmIChsYW1iZGEgPiAxKSB7XG4gICAgICAgICAgICByeCAqPSBtYXRoU3FydChsYW1iZGEpO1xuICAgICAgICAgICAgcnkgKj0gbWF0aFNxcnQobGFtYmRhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBmID0gKGZhID09PSBmcyA/IC0xIDogMSlcbiAgICAgICAgICAgICogbWF0aFNxcnQoKCgocnggKiByeCkgKiAocnkgKiByeSkpXG4gICAgICAgICAgICAgICAgICAgIC0gKChyeCAqIHJ4KSAqICh5cCAqIHlwKSlcbiAgICAgICAgICAgICAgICAgICAgLSAoKHJ5ICogcnkpICogKHhwICogeHApKSkgLyAoKHJ4ICogcngpICogKHlwICogeXApXG4gICAgICAgICAgICAgICAgICAgICsgKHJ5ICogcnkpICogKHhwICogeHApKVxuICAgICAgICAgICAgICAgICkgfHwgMDtcblxuICAgICAgICB2YXIgY3hwID0gZiAqIHJ4ICogeXAgLyByeTtcbiAgICAgICAgdmFyIGN5cCA9IGYgKiAtcnkgKiB4cCAvIHJ4O1xuXG4gICAgICAgIHZhciBjeCA9ICh4MSArIHgyKSAvIDIuMFxuICAgICAgICAgICAgICAgICArIG1hdGhDb3MocHNpKSAqIGN4cFxuICAgICAgICAgICAgICAgICAtIG1hdGhTaW4ocHNpKSAqIGN5cDtcbiAgICAgICAgdmFyIGN5ID0gKHkxICsgeTIpIC8gMi4wXG4gICAgICAgICAgICAgICAgKyBtYXRoU2luKHBzaSkgKiBjeHBcbiAgICAgICAgICAgICAgICArIG1hdGhDb3MocHNpKSAqIGN5cDtcblxuICAgICAgICB2YXIgdGhldGEgPSB2QW5nbGUoWyAxLCAwIF0sIFsgKHhwIC0gY3hwKSAvIHJ4LCAoeXAgLSBjeXApIC8gcnkgXSk7XG4gICAgICAgIHZhciB1ID0gWyAoeHAgLSBjeHApIC8gcngsICh5cCAtIGN5cCkgLyByeSBdO1xuICAgICAgICB2YXIgdiA9IFsgKC0xICogeHAgLSBjeHApIC8gcngsICgtMSAqIHlwIC0gY3lwKSAvIHJ5IF07XG4gICAgICAgIHZhciBkVGhldGEgPSB2QW5nbGUodSwgdik7XG5cbiAgICAgICAgaWYgKHZSYXRpbyh1LCB2KSA8PSAtMSkge1xuICAgICAgICAgICAgZFRoZXRhID0gUEk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZSYXRpbyh1LCB2KSA+PSAxKSB7XG4gICAgICAgICAgICBkVGhldGEgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmcyA9PT0gMCAmJiBkVGhldGEgPiAwKSB7XG4gICAgICAgICAgICBkVGhldGEgPSBkVGhldGEgLSAyICogUEk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZzID09PSAxICYmIGRUaGV0YSA8IDApIHtcbiAgICAgICAgICAgIGRUaGV0YSA9IGRUaGV0YSArIDIgKiBQSTtcbiAgICAgICAgfVxuXG4gICAgICAgIHBhdGguYWRkRGF0YShjbWQsIGN4LCBjeSwgcngsIHJ5LCB0aGV0YSwgZFRoZXRhLCBwc2ksIGZzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVQYXRoUHJveHlGcm9tU3RyaW5nKGRhdGEpIHtcbiAgICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjb21tYW5kIHN0cmluZ1xuICAgICAgICB2YXIgY3MgPSBkYXRhLnJlcGxhY2UoLy0vZywgJyAtJylcbiAgICAgICAgICAgIC5yZXBsYWNlKC8gIC9nLCAnICcpXG4gICAgICAgICAgICAucmVwbGFjZSgvIC9nLCAnLCcpXG4gICAgICAgICAgICAucmVwbGFjZSgvLCwvZywgJywnKTtcblxuICAgICAgICB2YXIgbjtcbiAgICAgICAgLy8gY3JlYXRlIHBpcGVzIHNvIHRoYXQgd2UgY2FuIHNwbGl0IHRoZSBkYXRhXG4gICAgICAgIGZvciAobiA9IDA7IG4gPCBjYy5sZW5ndGg7IG4rKykge1xuICAgICAgICAgICAgY3MgPSBjcy5yZXBsYWNlKG5ldyBSZWdFeHAoY2Nbbl0sICdnJyksICd8JyArIGNjW25dKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNyZWF0ZSBhcnJheVxuICAgICAgICB2YXIgYXJyID0gY3Muc3BsaXQoJ3wnKTtcbiAgICAgICAgLy8gaW5pdCBjb250ZXh0IHBvaW50XG4gICAgICAgIHZhciBjcHggPSAwO1xuICAgICAgICB2YXIgY3B5ID0gMDtcblxuICAgICAgICB2YXIgcGF0aCA9IG5ldyBQYXRoUHJveHkoKTtcbiAgICAgICAgdmFyIENNRCA9IFBhdGhQcm94eS5DTUQ7XG5cbiAgICAgICAgdmFyIHByZXZDbWQ7XG4gICAgICAgIGZvciAobiA9IDE7IG4gPCBhcnIubGVuZ3RoOyBuKyspIHtcbiAgICAgICAgICAgIHZhciBzdHIgPSBhcnJbbl07XG4gICAgICAgICAgICB2YXIgYyA9IHN0ci5jaGFyQXQoMCk7XG4gICAgICAgICAgICB2YXIgb2ZmID0gMDtcbiAgICAgICAgICAgIHZhciBwID0gc3RyLnNsaWNlKDEpLnJlcGxhY2UoL2UsLS9nLCAnZS0nKS5zcGxpdCgnLCcpO1xuICAgICAgICAgICAgdmFyIGNtZDtcblxuICAgICAgICAgICAgaWYgKHAubGVuZ3RoID4gMCAmJiBwWzBdID09PSAnJykge1xuICAgICAgICAgICAgICAgIHAuc2hpZnQoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcFtpXSA9IHBhcnNlRmxvYXQocFtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAob2ZmIDwgcC5sZW5ndGggJiYgIWlzTmFOKHBbb2ZmXSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNOYU4ocFswXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBjdGxQdHg7XG4gICAgICAgICAgICAgICAgdmFyIGN0bFB0eTtcblxuICAgICAgICAgICAgICAgIHZhciByeDtcbiAgICAgICAgICAgICAgICB2YXIgcnk7XG4gICAgICAgICAgICAgICAgdmFyIHBzaTtcbiAgICAgICAgICAgICAgICB2YXIgZmE7XG4gICAgICAgICAgICAgICAgdmFyIGZzO1xuXG4gICAgICAgICAgICAgICAgdmFyIHgxID0gY3B4O1xuICAgICAgICAgICAgICAgIHZhciB5MSA9IGNweTtcblxuICAgICAgICAgICAgICAgIC8vIGNvbnZlcnQgbCwgSCwgaCwgViwgYW5kIHYgdG8gTFxuICAgICAgICAgICAgICAgIHN3aXRjaCAoYykge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdsJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweCArPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweSArPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNtZCA9IENNRC5MO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aC5hZGREYXRhKGNtZCwgY3B4LCBjcHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ0wnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY3B4ID0gcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHkgPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNtZCA9IENNRC5MO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aC5hZGREYXRhKGNtZCwgY3B4LCBjcHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ20nOlxuICAgICAgICAgICAgICAgICAgICAgICAgY3B4ICs9IHBbb2ZmKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3B5ICs9IHBbb2ZmKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY21kID0gQ01ELk07XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoLmFkZERhdGEoY21kLCBjcHgsIGNweSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjID0gJ2wnO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ00nOlxuICAgICAgICAgICAgICAgICAgICAgICAgY3B4ID0gcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHkgPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNtZCA9IENNRC5NO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aC5hZGREYXRhKGNtZCwgY3B4LCBjcHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYyA9ICdMJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdoJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweCArPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNtZCA9IENNRC5MO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aC5hZGREYXRhKGNtZCwgY3B4LCBjcHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ0gnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY3B4ID0gcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgICAgICBjbWQgPSBDTUQuTDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGguYWRkRGF0YShjbWQsIGNweCwgY3B5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICd2JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweSArPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNtZCA9IENNRC5MO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aC5hZGREYXRhKGNtZCwgY3B4LCBjcHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ1YnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY3B5ID0gcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgICAgICBjbWQgPSBDTUQuTDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGguYWRkRGF0YShjbWQsIGNweCwgY3B5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdDJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNtZCA9IENNRC5DO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aC5hZGREYXRhKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNtZCwgcFtvZmYrK10sIHBbb2ZmKytdLCBwW29mZisrXSwgcFtvZmYrK10sIHBbb2ZmKytdLCBwW29mZisrXVxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweCA9IHBbb2ZmIC0gMl07XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHkgPSBwW29mZiAtIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2MnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY21kID0gQ01ELkM7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoLmFkZERhdGEoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY21kLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBbb2ZmKytdICsgY3B4LCBwW29mZisrXSArIGNweSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwW29mZisrXSArIGNweCwgcFtvZmYrK10gKyBjcHksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcFtvZmYrK10gKyBjcHgsIHBbb2ZmKytdICsgY3B5XG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3B4ICs9IHBbb2ZmIC0gMl07XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHkgKz0gcFtvZmYgLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdTJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0bFB0eCA9IGNweDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0bFB0eSA9IGNweTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsZW4gPSBwYXRoLmxlbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhdGhEYXRhID0gcGF0aC5kYXRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByZXZDbWQgPT09IENNRC5DKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3RsUHR4ICs9IGNweCAtIHBhdGhEYXRhW2xlbiAtIDRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0bFB0eSArPSBjcHkgLSBwYXRoRGF0YVtsZW4gLSAzXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNtZCA9IENNRC5DO1xuICAgICAgICAgICAgICAgICAgICAgICAgeDEgPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHkxID0gcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHggPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweSA9IHBbb2ZmKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aC5hZGREYXRhKGNtZCwgY3RsUHR4LCBjdGxQdHksIHgxLCB5MSwgY3B4LCBjcHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3MnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY3RsUHR4ID0gY3B4O1xuICAgICAgICAgICAgICAgICAgICAgICAgY3RsUHR5ID0gY3B5O1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxlbiA9IHBhdGgubGVuKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGF0aERhdGEgPSBwYXRoLmRhdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJldkNtZCA9PT0gQ01ELkMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdGxQdHggKz0gY3B4IC0gcGF0aERhdGFbbGVuIC0gNF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3RsUHR5ICs9IGNweSAtIHBhdGhEYXRhW2xlbiAtIDNdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY21kID0gQ01ELkM7XG4gICAgICAgICAgICAgICAgICAgICAgICB4MSA9IGNweCArIHBbb2ZmKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgeTEgPSBjcHkgKyBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweCArPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweSArPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGguYWRkRGF0YShjbWQsIGN0bFB0eCwgY3RsUHR5LCB4MSwgeTEsIGNweCwgY3B5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdRJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHgxID0gcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgICAgICB5MSA9IHBbb2ZmKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3B4ID0gcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHkgPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNtZCA9IENNRC5RO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aC5hZGREYXRhKGNtZCwgeDEsIHkxLCBjcHgsIGNweSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAncSc6XG4gICAgICAgICAgICAgICAgICAgICAgICB4MSA9IHBbb2ZmKytdICsgY3B4O1xuICAgICAgICAgICAgICAgICAgICAgICAgeTEgPSBwW29mZisrXSArIGNweTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweCArPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweSArPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNtZCA9IENNRC5RO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aC5hZGREYXRhKGNtZCwgeDEsIHkxLCBjcHgsIGNweSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnVCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjdGxQdHggPSBjcHg7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdGxQdHkgPSBjcHk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGVuID0gcGF0aC5sZW4oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXRoRGF0YSA9IHBhdGguZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcmV2Q21kID09PSBDTUQuUSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0bFB0eCArPSBjcHggLSBwYXRoRGF0YVtsZW4gLSA0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdGxQdHkgKz0gY3B5IC0gcGF0aERhdGFbbGVuIC0gM107XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHggPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweSA9IHBbb2ZmKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY21kID0gQ01ELlE7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoLmFkZERhdGEoY21kLCBjdGxQdHgsIGN0bFB0eSwgY3B4LCBjcHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3QnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY3RsUHR4ID0gY3B4O1xuICAgICAgICAgICAgICAgICAgICAgICAgY3RsUHR5ID0gY3B5O1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxlbiA9IHBhdGgubGVuKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGF0aERhdGEgPSBwYXRoLmRhdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJldkNtZCA9PT0gQ01ELlEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdGxQdHggKz0gY3B4IC0gcGF0aERhdGFbbGVuIC0gNF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3RsUHR5ICs9IGNweSAtIHBhdGhEYXRhW2xlbiAtIDNdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY3B4ICs9IHBbb2ZmKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3B5ICs9IHBbb2ZmKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY21kID0gQ01ELlE7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoLmFkZERhdGEoY21kLCBjdGxQdHgsIGN0bFB0eSwgY3B4LCBjcHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ0EnOlxuICAgICAgICAgICAgICAgICAgICAgICAgcnggPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ5ID0gcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgICAgICBwc2kgPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhID0gcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgICAgICBmcyA9IHBbb2ZmKytdO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB4MSA9IGNweCwgeTEgPSBjcHk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHggPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweSA9IHBbb2ZmKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY21kID0gQ01ELkE7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9jZXNzQXJjKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHgxLCB5MSwgY3B4LCBjcHksIGZhLCBmcywgcngsIHJ5LCBwc2ksIGNtZCwgcGF0aFxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdhJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ4ID0gcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgICAgICByeSA9IHBbb2ZmKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHNpID0gcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgICAgICBmYSA9IHBbb2ZmKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZnMgPSBwW29mZisrXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgeDEgPSBjcHgsIHkxID0gY3B5O1xuICAgICAgICAgICAgICAgICAgICAgICAgY3B4ICs9IHBbb2ZmKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3B5ICs9IHBbb2ZmKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY21kID0gQ01ELkE7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9jZXNzQXJjKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHgxLCB5MSwgY3B4LCBjcHksIGZhLCBmcywgcngsIHJ5LCBwc2ksIGNtZCwgcGF0aFxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGMgPT09ICd6JyB8fCBjID09PSAnWicpIHtcbiAgICAgICAgICAgICAgICBjbWQgPSBDTUQuWjtcbiAgICAgICAgICAgICAgICBwYXRoLmFkZERhdGEoY21kKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcHJldkNtZCA9IGNtZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHBhdGgudG9TdGF0aWMoKTtcblxuICAgICAgICByZXR1cm4gcGF0aDtcbiAgICB9XG5cbiAgICAvLyBUT0RPIE9wdGltaXplIGRvdWJsZSBtZW1vcnkgY29zdCBwcm9ibGVtXG4gICAgZnVuY3Rpb24gY3JlYXRlUGF0aE9wdGlvbnMoc3RyLCBvcHRzKSB7XG4gICAgICAgIHZhciBwYXRoUHJveHkgPSBjcmVhdGVQYXRoUHJveHlGcm9tU3RyaW5nKHN0cik7XG4gICAgICAgIHZhciB0cmFuc2Zvcm07XG4gICAgICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xuICAgICAgICBvcHRzLmJ1aWxkUGF0aCA9IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgICAgICAgICBwYXRoLnNldERhdGEocGF0aFByb3h5LmRhdGEpO1xuICAgICAgICAgICAgdHJhbnNmb3JtICYmIHRyYW5zZm9ybVBhdGgocGF0aCwgdHJhbnNmb3JtKTtcbiAgICAgICAgICAgIC8vIFN2ZyBhbmQgdm1sIHJlbmRlcmVyIGRvbid0IGhhdmUgY29udGV4dFxuICAgICAgICAgICAgdmFyIGN0eCA9IHBhdGguZ2V0Q29udGV4dCgpO1xuICAgICAgICAgICAgaWYgKGN0eCkge1xuICAgICAgICAgICAgICAgIHBhdGgucmVidWlsZFBhdGgoY3R4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBvcHRzLmFwcGx5VHJhbnNmb3JtID0gZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgICAgIGlmICghdHJhbnNmb3JtKSB7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtID0gbWF0cml4LmNyZWF0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWF0cml4Lm11bCh0cmFuc2Zvcm0sIG0sIHRyYW5zZm9ybSk7XG4gICAgICAgICAgICB0aGlzLmRpcnR5KHRydWUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBvcHRzO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlIGEgUGF0aCBvYmplY3QgZnJvbSBwYXRoIHN0cmluZyBkYXRhXG4gICAgICAgICAqIGh0dHA6Ly93d3cudzMub3JnL1RSL1NWRy9wYXRocy5odG1sI1BhdGhEYXRhXG4gICAgICAgICAqIEBwYXJhbSAge09iamVjdH0gb3B0cyBPdGhlciBvcHRpb25zXG4gICAgICAgICAqL1xuICAgICAgICBjcmVhdGVGcm9tU3RyaW5nOiBmdW5jdGlvbiAoc3RyLCBvcHRzKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFBhdGgoY3JlYXRlUGF0aE9wdGlvbnMoc3RyLCBvcHRzKSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZSBhIFBhdGggY2xhc3MgZnJvbSBwYXRoIHN0cmluZyBkYXRhXG4gICAgICAgICAqIEBwYXJhbSAge3N0cmluZ30gc3RyXG4gICAgICAgICAqIEBwYXJhbSAge09iamVjdH0gb3B0cyBPdGhlciBvcHRpb25zXG4gICAgICAgICAqL1xuICAgICAgICBleHRlbmRGcm9tU3RyaW5nOiBmdW5jdGlvbiAoc3RyLCBvcHRzKSB7XG4gICAgICAgICAgICByZXR1cm4gUGF0aC5leHRlbmQoY3JlYXRlUGF0aE9wdGlvbnMoc3RyLCBvcHRzKSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1lcmdlIG11bHRpcGxlIHBhdGhzXG4gICAgICAgICAqL1xuICAgICAgICAvLyBUT0RPIEFwcGx5IHRyYW5zZm9ybVxuICAgICAgICAvLyBUT0RPIHN0cm9rZSBkYXNoXG4gICAgICAgIC8vIFRPRE8gT3B0aW1pemUgZG91YmxlIG1lbW9yeSBjb3N0IHByb2JsZW1cbiAgICAgICAgbWVyZ2VQYXRoOiBmdW5jdGlvbiAocGF0aEVscywgb3B0cykge1xuICAgICAgICAgICAgdmFyIHBhdGhMaXN0ID0gW107XG4gICAgICAgICAgICB2YXIgbGVuID0gcGF0aEVscy5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhdGhFbCA9IHBhdGhFbHNbaV07XG4gICAgICAgICAgICAgICAgaWYgKHBhdGhFbC5fX2RpcnR5KSB7XG4gICAgICAgICAgICAgICAgICAgIHBhdGhFbC5idWlsZFBhdGgocGF0aEVsLnBhdGgsIHBhdGhFbC5zaGFwZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBhdGhMaXN0LnB1c2gocGF0aEVsLnBhdGgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgcGF0aEJ1bmRsZSA9IG5ldyBQYXRoKG9wdHMpO1xuICAgICAgICAgICAgcGF0aEJ1bmRsZS5idWlsZFBhdGggPSBmdW5jdGlvbiAocGF0aCkge1xuICAgICAgICAgICAgICAgIHBhdGguYXBwZW5kUGF0aChwYXRoTGlzdCk7XG4gICAgICAgICAgICAgICAgLy8gU3ZnIGFuZCB2bWwgcmVuZGVyZXIgZG9uJ3QgaGF2ZSBjb250ZXh0XG4gICAgICAgICAgICAgICAgdmFyIGN0eCA9IHBhdGguZ2V0Q29udGV4dCgpO1xuICAgICAgICAgICAgICAgIGlmIChjdHgpIHtcbiAgICAgICAgICAgICAgICAgICAgcGF0aC5yZWJ1aWxkUGF0aChjdHgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHJldHVybiBwYXRoQnVuZGxlO1xuICAgICAgICB9XG4gICAgfTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3pyZW5kZXIvbGliL3Rvb2wvcGF0aC5qc1xuICoqIG1vZHVsZSBpZCA9IDVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogUGF0aCBlbGVtZW50XG4gKiBAbW9kdWxlIHpyZW5kZXIvZ3JhcGhpYy9QYXRoXG4gKi9cblxuXG5cbiAgICB2YXIgRGlzcGxheWFibGUgPSByZXF1aXJlKCcuL0Rpc3BsYXlhYmxlJyk7XG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJy4uL2NvcmUvdXRpbCcpO1xuICAgIHZhciBQYXRoUHJveHkgPSByZXF1aXJlKCcuLi9jb3JlL1BhdGhQcm94eScpO1xuICAgIHZhciBwYXRoQ29udGFpbiA9IHJlcXVpcmUoJy4uL2NvbnRhaW4vcGF0aCcpO1xuXG4gICAgdmFyIFBhdHRlcm4gPSByZXF1aXJlKCcuL1BhdHRlcm4nKTtcbiAgICB2YXIgZ2V0Q2FudmFzUGF0dGVybiA9IFBhdHRlcm4ucHJvdG90eXBlLmdldENhbnZhc1BhdHRlcm47XG5cbiAgICB2YXIgYWJzID0gTWF0aC5hYnM7XG5cbiAgICAvKipcbiAgICAgKiBAYWxpYXMgbW9kdWxlOnpyZW5kZXIvZ3JhcGhpYy9QYXRoXG4gICAgICogQGV4dGVuZHMgbW9kdWxlOnpyZW5kZXIvZ3JhcGhpYy9EaXNwbGF5YWJsZVxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gICAgICovXG4gICAgZnVuY3Rpb24gUGF0aChvcHRzKSB7XG4gICAgICAgIERpc3BsYXlhYmxlLmNhbGwodGhpcywgb3B0cyk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHttb2R1bGU6enJlbmRlci9jb3JlL1BhdGhQcm94eX1cbiAgICAgICAgICogQHJlYWRPbmx5XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnBhdGggPSBuZXcgUGF0aFByb3h5KCk7XG4gICAgfVxuXG4gICAgUGF0aC5wcm90b3R5cGUgPSB7XG5cbiAgICAgICAgY29uc3RydWN0b3I6IFBhdGgsXG5cbiAgICAgICAgdHlwZTogJ3BhdGgnLFxuXG4gICAgICAgIF9fZGlydHlQYXRoOiB0cnVlLFxuXG4gICAgICAgIHN0cm9rZUNvbnRhaW5UaHJlc2hvbGQ6IDUsXG5cbiAgICAgICAgYnJ1c2g6IGZ1bmN0aW9uIChjdHgsIHByZXZFbCkge1xuICAgICAgICAgICAgdmFyIHN0eWxlID0gdGhpcy5zdHlsZTtcbiAgICAgICAgICAgIHZhciBwYXRoID0gdGhpcy5wYXRoO1xuICAgICAgICAgICAgdmFyIGhhc1N0cm9rZSA9IHN0eWxlLmhhc1N0cm9rZSgpO1xuICAgICAgICAgICAgdmFyIGhhc0ZpbGwgPSBzdHlsZS5oYXNGaWxsKCk7XG4gICAgICAgICAgICB2YXIgZmlsbCA9IHN0eWxlLmZpbGw7XG4gICAgICAgICAgICB2YXIgc3Ryb2tlID0gc3R5bGUuc3Ryb2tlO1xuICAgICAgICAgICAgdmFyIGhhc0ZpbGxHcmFkaWVudCA9IGhhc0ZpbGwgJiYgISEoZmlsbC5jb2xvclN0b3BzKTtcbiAgICAgICAgICAgIHZhciBoYXNTdHJva2VHcmFkaWVudCA9IGhhc1N0cm9rZSAmJiAhIShzdHJva2UuY29sb3JTdG9wcyk7XG4gICAgICAgICAgICB2YXIgaGFzRmlsbFBhdHRlcm4gPSBoYXNGaWxsICYmICEhKGZpbGwuaW1hZ2UpO1xuICAgICAgICAgICAgdmFyIGhhc1N0cm9rZVBhdHRlcm4gPSBoYXNTdHJva2UgJiYgISEoc3Ryb2tlLmltYWdlKTtcblxuICAgICAgICAgICAgc3R5bGUuYmluZChjdHgsIHRoaXMsIHByZXZFbCk7XG4gICAgICAgICAgICB0aGlzLnNldFRyYW5zZm9ybShjdHgpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5fX2RpcnR5KSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlY3QgPSB0aGlzLmdldEJvdW5kaW5nUmVjdCgpO1xuICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBncmFkaWVudCBiZWNhdXNlIGJvdW5kaW5nIHJlY3QgbWF5IGNoYW5nZWRcbiAgICAgICAgICAgICAgICBpZiAoaGFzRmlsbEdyYWRpZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2ZpbGxHcmFkaWVudCA9IHN0eWxlLmdldEdyYWRpZW50KGN0eCwgZmlsbCwgcmVjdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChoYXNTdHJva2VHcmFkaWVudCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdHJva2VHcmFkaWVudCA9IHN0eWxlLmdldEdyYWRpZW50KGN0eCwgc3Ryb2tlLCByZWN0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBVc2UgdGhlIGdyYWRpZW50IG9yIHBhdHRlcm5cbiAgICAgICAgICAgIGlmIChoYXNGaWxsR3JhZGllbnQpIHtcbiAgICAgICAgICAgICAgICAvLyBQRU5ESU5HIElmIG1heSBoYXZlIGFmZmVjdCB0aGUgc3RhdGVcbiAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5fZmlsbEdyYWRpZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaGFzRmlsbFBhdHRlcm4pIHtcbiAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gZ2V0Q2FudmFzUGF0dGVybi5jYWxsKGZpbGwsIGN0eCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaGFzU3Ryb2tlR3JhZGllbnQpIHtcbiAgICAgICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSB0aGlzLl9zdHJva2VHcmFkaWVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGhhc1N0cm9rZVBhdHRlcm4pIHtcbiAgICAgICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBnZXRDYW52YXNQYXR0ZXJuLmNhbGwoc3Ryb2tlLCBjdHgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgbGluZURhc2ggPSBzdHlsZS5saW5lRGFzaDtcbiAgICAgICAgICAgIHZhciBsaW5lRGFzaE9mZnNldCA9IHN0eWxlLmxpbmVEYXNoT2Zmc2V0O1xuXG4gICAgICAgICAgICB2YXIgY3R4TGluZURhc2ggPSAhIWN0eC5zZXRMaW5lRGFzaDtcblxuICAgICAgICAgICAgLy8gVXBkYXRlIHBhdGggc3gsIHN5XG4gICAgICAgICAgICB2YXIgc2NhbGUgPSB0aGlzLmdldEdsb2JhbFNjYWxlKCk7XG4gICAgICAgICAgICBwYXRoLnNldFNjYWxlKHNjYWxlWzBdLCBzY2FsZVsxXSk7XG5cbiAgICAgICAgICAgIC8vIFByb3h5IGNvbnRleHRcbiAgICAgICAgICAgIC8vIFJlYnVpbGQgcGF0aCBpbiBmb2xsb3dpbmcgMiBjYXNlc1xuICAgICAgICAgICAgLy8gMS4gUGF0aCBpcyBkaXJ0eVxuICAgICAgICAgICAgLy8gMi4gUGF0aCBuZWVkcyBqYXZhc2NyaXB0IGltcGxlbWVudGVkIGxpbmVEYXNoIHN0cm9raW5nLlxuICAgICAgICAgICAgLy8gICAgSW4gdGhpcyBjYXNlLCBsaW5lRGFzaCBpbmZvcm1hdGlvbiB3aWxsIG5vdCBiZSBzYXZlZCBpbiBQYXRoUHJveHlcbiAgICAgICAgICAgIGlmICh0aGlzLl9fZGlydHlQYXRoIHx8IChcbiAgICAgICAgICAgICAgICBsaW5lRGFzaCAmJiAhY3R4TGluZURhc2ggJiYgaGFzU3Ryb2tlXG4gICAgICAgICAgICApKSB7XG4gICAgICAgICAgICAgICAgcGF0aCA9IHRoaXMucGF0aC5iZWdpblBhdGgoY3R4KTtcblxuICAgICAgICAgICAgICAgIC8vIFNldHRpbmcgbGluZSBkYXNoIGJlZm9yZSBidWlsZCBwYXRoXG4gICAgICAgICAgICAgICAgaWYgKGxpbmVEYXNoICYmICFjdHhMaW5lRGFzaCkge1xuICAgICAgICAgICAgICAgICAgICBwYXRoLnNldExpbmVEYXNoKGxpbmVEYXNoKTtcbiAgICAgICAgICAgICAgICAgICAgcGF0aC5zZXRMaW5lRGFzaE9mZnNldChsaW5lRGFzaE9mZnNldCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5idWlsZFBhdGgocGF0aCwgdGhpcy5zaGFwZSwgZmFsc2UpO1xuXG4gICAgICAgICAgICAgICAgLy8gQ2xlYXIgcGF0aCBkaXJ0eSBmbGFnXG4gICAgICAgICAgICAgICAgdGhpcy5fX2RpcnR5UGF0aCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gUmVwbGF5IHBhdGggYnVpbGRpbmdcbiAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXRoLnJlYnVpbGRQYXRoKGN0eCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGhhc0ZpbGwgJiYgcGF0aC5maWxsKGN0eCk7XG5cbiAgICAgICAgICAgIGlmIChsaW5lRGFzaCAmJiBjdHhMaW5lRGFzaCkge1xuICAgICAgICAgICAgICAgIGN0eC5zZXRMaW5lRGFzaChsaW5lRGFzaCk7XG4gICAgICAgICAgICAgICAgY3R4LmxpbmVEYXNoT2Zmc2V0ID0gbGluZURhc2hPZmZzZXQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGhhc1N0cm9rZSAmJiBwYXRoLnN0cm9rZShjdHgpO1xuXG4gICAgICAgICAgICBpZiAobGluZURhc2ggJiYgY3R4TGluZURhc2gpIHtcbiAgICAgICAgICAgICAgICAvLyBQRU5ESU5HXG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIGxpbmVEYXNoXG4gICAgICAgICAgICAgICAgY3R4LnNldExpbmVEYXNoKFtdKTtcbiAgICAgICAgICAgIH1cblxuXG4gICAgICAgICAgICB0aGlzLnJlc3RvcmVUcmFuc2Zvcm0oY3R4KTtcblxuICAgICAgICAgICAgLy8gRHJhdyByZWN0IHRleHRcbiAgICAgICAgICAgIGlmIChzdHlsZS50ZXh0IHx8IHN0eWxlLnRleHQgPT09IDApIHtcbiAgICAgICAgICAgICAgICAvLyB2YXIgcmVjdCA9IHRoaXMuZ2V0Qm91bmRpbmdSZWN0KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5kcmF3UmVjdFRleHQoY3R4LCB0aGlzLmdldEJvdW5kaW5nUmVjdCgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvLyBXaGVuIGJ1bmRsaW5nIHBhdGgsIHNvbWUgc2hhcGUgbWF5IGRlY2lkZSBpZiB1c2UgbW92ZVRvIHRvIGJlZ2luIGEgbmV3IHN1YnBhdGggb3IgY2xvc2VQYXRoXG4gICAgICAgIC8vIExpa2UgaW4gY2lyY2xlXG4gICAgICAgIGJ1aWxkUGF0aDogZnVuY3Rpb24gKGN0eCwgc2hhcGVDZmcsIGluQnVuZGxlKSB7fSxcblxuICAgICAgICBnZXRCb3VuZGluZ1JlY3Q6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciByZWN0ID0gdGhpcy5fcmVjdDtcbiAgICAgICAgICAgIHZhciBzdHlsZSA9IHRoaXMuc3R5bGU7XG4gICAgICAgICAgICB2YXIgbmVlZHNVcGRhdGVSZWN0ID0gIXJlY3Q7XG4gICAgICAgICAgICBpZiAobmVlZHNVcGRhdGVSZWN0KSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhdGggPSB0aGlzLnBhdGg7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX19kaXJ0eVBhdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcGF0aC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5idWlsZFBhdGgocGF0aCwgdGhpcy5zaGFwZSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZWN0ID0gcGF0aC5nZXRCb3VuZGluZ1JlY3QoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3JlY3QgPSByZWN0O1xuXG4gICAgICAgICAgICBpZiAoc3R5bGUuaGFzU3Ryb2tlKCkpIHtcbiAgICAgICAgICAgICAgICAvLyBOZWVkcyB1cGRhdGUgcmVjdCB3aXRoIHN0cm9rZSBsaW5lV2lkdGggd2hlblxuICAgICAgICAgICAgICAgIC8vIDEuIEVsZW1lbnQgY2hhbmdlcyBzY2FsZSBvciBsaW5lV2lkdGhcbiAgICAgICAgICAgICAgICAvLyAyLiBTaGFwZSBpcyBjaGFuZ2VkXG4gICAgICAgICAgICAgICAgdmFyIHJlY3RXaXRoU3Ryb2tlID0gdGhpcy5fcmVjdFdpdGhTdHJva2UgfHwgKHRoaXMuX3JlY3RXaXRoU3Ryb2tlID0gcmVjdC5jbG9uZSgpKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fX2RpcnR5IHx8IG5lZWRzVXBkYXRlUmVjdCkge1xuICAgICAgICAgICAgICAgICAgICByZWN0V2l0aFN0cm9rZS5jb3B5KHJlY3QpO1xuICAgICAgICAgICAgICAgICAgICAvLyBGSVhNRSBNdXN0IGFmdGVyIHVwZGF0ZVRyYW5zZm9ybVxuICAgICAgICAgICAgICAgICAgICB2YXIgdyA9IHN0eWxlLmxpbmVXaWR0aDtcbiAgICAgICAgICAgICAgICAgICAgLy8gUEVORElORywgTWluIGxpbmUgd2lkdGggaXMgbmVlZGVkIHdoZW4gbGluZSBpcyBob3Jpem9udGFsIG9yIHZlcnRpY2FsXG4gICAgICAgICAgICAgICAgICAgIHZhciBsaW5lU2NhbGUgPSBzdHlsZS5zdHJva2VOb1NjYWxlID8gdGhpcy5nZXRMaW5lU2NhbGUoKSA6IDE7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gT25seSBhZGQgZXh0cmEgaG92ZXIgbGluZVdpZHRoIHdoZW4gdGhlcmUgYXJlIG5vIGZpbGxcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzdHlsZS5oYXNGaWxsKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHcgPSBNYXRoLm1heCh3LCB0aGlzLnN0cm9rZUNvbnRhaW5UaHJlc2hvbGQgfHwgNCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gQ29uc2lkZXIgbGluZSB3aWR0aFxuICAgICAgICAgICAgICAgICAgICAvLyBMaW5lIHNjYWxlIGNhbid0IGJlIDA7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsaW5lU2NhbGUgPiAxZS0xMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVjdFdpdGhTdHJva2Uud2lkdGggKz0gdyAvIGxpbmVTY2FsZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY3RXaXRoU3Ryb2tlLmhlaWdodCArPSB3IC8gbGluZVNjYWxlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVjdFdpdGhTdHJva2UueCAtPSB3IC8gbGluZVNjYWxlIC8gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY3RXaXRoU3Ryb2tlLnkgLT0gdyAvIGxpbmVTY2FsZSAvIDI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBSZXR1cm4gcmVjdCB3aXRoIHN0cm9rZVxuICAgICAgICAgICAgICAgIHJldHVybiByZWN0V2l0aFN0cm9rZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHJlY3Q7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY29udGFpbjogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgICAgIHZhciBsb2NhbFBvcyA9IHRoaXMudHJhbnNmb3JtQ29vcmRUb0xvY2FsKHgsIHkpO1xuICAgICAgICAgICAgdmFyIHJlY3QgPSB0aGlzLmdldEJvdW5kaW5nUmVjdCgpO1xuICAgICAgICAgICAgdmFyIHN0eWxlID0gdGhpcy5zdHlsZTtcbiAgICAgICAgICAgIHggPSBsb2NhbFBvc1swXTtcbiAgICAgICAgICAgIHkgPSBsb2NhbFBvc1sxXTtcblxuICAgICAgICAgICAgaWYgKHJlY3QuY29udGFpbih4LCB5KSkge1xuICAgICAgICAgICAgICAgIHZhciBwYXRoRGF0YSA9IHRoaXMucGF0aC5kYXRhO1xuICAgICAgICAgICAgICAgIGlmIChzdHlsZS5oYXNTdHJva2UoKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGluZVdpZHRoID0gc3R5bGUubGluZVdpZHRoO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGluZVNjYWxlID0gc3R5bGUuc3Ryb2tlTm9TY2FsZSA/IHRoaXMuZ2V0TGluZVNjYWxlKCkgOiAxO1xuICAgICAgICAgICAgICAgICAgICAvLyBMaW5lIHNjYWxlIGNhbid0IGJlIDA7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsaW5lU2NhbGUgPiAxZS0xMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gT25seSBhZGQgZXh0cmEgaG92ZXIgbGluZVdpZHRoIHdoZW4gdGhlcmUgYXJlIG5vIGZpbGxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghc3R5bGUuaGFzRmlsbCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZVdpZHRoID0gTWF0aC5tYXgobGluZVdpZHRoLCB0aGlzLnN0cm9rZUNvbnRhaW5UaHJlc2hvbGQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhdGhDb250YWluLmNvbnRhaW5TdHJva2UoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aERhdGEsIGxpbmVXaWR0aCAvIGxpbmVTY2FsZSwgeCwgeVxuICAgICAgICAgICAgICAgICAgICAgICAgKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzdHlsZS5oYXNGaWxsKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhdGhDb250YWluLmNvbnRhaW4ocGF0aERhdGEsIHgsIHkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtICB7Ym9vbGVhbn0gZGlydHlQYXRoXG4gICAgICAgICAqL1xuICAgICAgICBkaXJ0eTogZnVuY3Rpb24gKGRpcnR5UGF0aCkge1xuICAgICAgICAgICAgaWYgKGRpcnR5UGF0aCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZGlydHlQYXRoID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE9ubHkgbWFyayBkaXJ0eSwgbm90IG1hcmsgY2xlYW5cbiAgICAgICAgICAgIGlmIChkaXJ0eVBhdGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9fZGlydHlQYXRoID0gZGlydHlQYXRoO1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlY3QgPSBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl9fZGlydHkgPSB0cnVlO1xuXG4gICAgICAgICAgICB0aGlzLl9fenIgJiYgdGhpcy5fX3pyLnJlZnJlc2goKTtcblxuICAgICAgICAgICAgLy8gVXNlZCBhcyBhIGNsaXBwaW5nIHBhdGhcbiAgICAgICAgICAgIGlmICh0aGlzLl9fY2xpcFRhcmdldCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX19jbGlwVGFyZ2V0LmRpcnR5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFsaWFzIGZvciBhbmltYXRlKCdzaGFwZScpXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gbG9vcFxuICAgICAgICAgKi9cbiAgICAgICAgYW5pbWF0ZVNoYXBlOiBmdW5jdGlvbiAobG9vcCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYW5pbWF0ZSgnc2hhcGUnLCBsb29wKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBPdmVyd3JpdGUgYXR0cktWXG4gICAgICAgIGF0dHJLVjogZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgIC8vIEZJWE1FXG4gICAgICAgICAgICBpZiAoa2V5ID09PSAnc2hhcGUnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRTaGFwZSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fX2RpcnR5UGF0aCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVjdCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBEaXNwbGF5YWJsZS5wcm90b3R5cGUuYXR0cktWLmNhbGwodGhpcywga2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fHN0cmluZ30ga2V5XG4gICAgICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICAgICAgICovXG4gICAgICAgIHNldFNoYXBlOiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIHNoYXBlID0gdGhpcy5zaGFwZTtcbiAgICAgICAgICAgIC8vIFBhdGggZnJvbSBzdHJpbmcgbWF5IG5vdCBoYXZlIHNoYXBlXG4gICAgICAgICAgICBpZiAoc2hhcGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoenJVdGlsLmlzT2JqZWN0KGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgbmFtZSBpbiBrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNoYXBlW25hbWVdID0ga2V5W25hbWVdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzaGFwZVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuZGlydHkodHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBnZXRMaW5lU2NhbGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBtID0gdGhpcy50cmFuc2Zvcm07XG4gICAgICAgICAgICAvLyBHZXQgdGhlIGxpbmUgc2NhbGUuXG4gICAgICAgICAgICAvLyBEZXRlcm1pbmFudCBvZiBgbWAgbWVhbnMgaG93IG11Y2ggdGhlIGFyZWEgaXMgZW5sYXJnZWQgYnkgdGhlXG4gICAgICAgICAgICAvLyB0cmFuc2Zvcm1hdGlvbi4gU28gaXRzIHNxdWFyZSByb290IGNhbiBiZSB1c2VkIGFzIGEgc2NhbGUgZmFjdG9yXG4gICAgICAgICAgICAvLyBmb3Igd2lkdGguXG4gICAgICAgICAgICByZXR1cm4gbSAmJiBhYnMobVswXSAtIDEpID4gMWUtMTAgJiYgYWJzKG1bM10gLSAxKSA+IDFlLTEwXG4gICAgICAgICAgICAgICAgPyBNYXRoLnNxcnQoYWJzKG1bMF0gKiBtWzNdIC0gbVsyXSAqIG1bMV0pKVxuICAgICAgICAgICAgICAgIDogMTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiDmianlsZXkuIDkuKogUGF0aCBlbGVtZW50LCDmr5TlpoLmmJ/lvaLvvIzlnIbnrYnjgIJcbiAgICAgKiBFeHRlbmQgYSBwYXRoIGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJvcHNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcHMudHlwZSBQYXRoIHR5cGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcm9wcy5pbml0IEluaXRpYWxpemVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcm9wcy5idWlsZFBhdGggT3ZlcndyaXRlIGJ1aWxkUGF0aCBtZXRob2RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3Byb3BzLnN0eWxlXSBFeHRlbmRlZCBkZWZhdWx0IHN0eWxlIGNvbmZpZ1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMuc2hhcGVdIEV4dGVuZGVkIGRlZmF1bHQgc2hhcGUgY29uZmlnXG4gICAgICovXG4gICAgUGF0aC5leHRlbmQgPSBmdW5jdGlvbiAoZGVmYXVsdHMpIHtcbiAgICAgICAgdmFyIFN1YiA9IGZ1bmN0aW9uIChvcHRzKSB7XG4gICAgICAgICAgICBQYXRoLmNhbGwodGhpcywgb3B0cyk7XG5cbiAgICAgICAgICAgIGlmIChkZWZhdWx0cy5zdHlsZSkge1xuICAgICAgICAgICAgICAgIC8vIEV4dGVuZCBkZWZhdWx0IHN0eWxlXG4gICAgICAgICAgICAgICAgdGhpcy5zdHlsZS5leHRlbmRGcm9tKGRlZmF1bHRzLnN0eWxlLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEV4dGVuZCBkZWZhdWx0IHNoYXBlXG4gICAgICAgICAgICB2YXIgZGVmYXVsdFNoYXBlID0gZGVmYXVsdHMuc2hhcGU7XG4gICAgICAgICAgICBpZiAoZGVmYXVsdFNoYXBlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zaGFwZSA9IHRoaXMuc2hhcGUgfHwge307XG4gICAgICAgICAgICAgICAgdmFyIHRoaXNTaGFwZSA9IHRoaXMuc2hhcGU7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgbmFtZSBpbiBkZWZhdWx0U2hhcGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgISB0aGlzU2hhcGUuaGFzT3duUHJvcGVydHkobmFtZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICYmIGRlZmF1bHRTaGFwZS5oYXNPd25Qcm9wZXJ0eShuYW1lKVxuICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNTaGFwZVtuYW1lXSA9IGRlZmF1bHRTaGFwZVtuYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZGVmYXVsdHMuaW5pdCAmJiBkZWZhdWx0cy5pbml0LmNhbGwodGhpcywgb3B0cyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgenJVdGlsLmluaGVyaXRzKFN1YiwgUGF0aCk7XG5cbiAgICAgICAgLy8gRklYTUUg5LiN6IO9IGV4dGVuZCBwb3NpdGlvbiwgcm90YXRpb24g562J5byV55So5a+56LGhXG4gICAgICAgIGZvciAodmFyIG5hbWUgaW4gZGVmYXVsdHMpIHtcbiAgICAgICAgICAgIC8vIEV4dGVuZGluZyBwcm90b3R5cGUgdmFsdWVzIGFuZCBtZXRob2RzXG4gICAgICAgICAgICBpZiAobmFtZSAhPT0gJ3N0eWxlJyAmJiBuYW1lICE9PSAnc2hhcGUnKSB7XG4gICAgICAgICAgICAgICAgU3ViLnByb3RvdHlwZVtuYW1lXSA9IGRlZmF1bHRzW25hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFN1YjtcbiAgICB9O1xuXG4gICAgenJVdGlsLmluaGVyaXRzKFBhdGgsIERpc3BsYXlhYmxlKTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gUGF0aDtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvUGF0aC5qc1xuICoqIG1vZHVsZSBpZCA9IDZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICog5Y+v57uY5Yi255qE5Zu+5b2i5Z+657G7XG4gKiBCYXNlIGNsYXNzIG9mIGFsbCBkaXNwbGF5YWJsZSBncmFwaGljIG9iamVjdHNcbiAqIEBtb2R1bGUgenJlbmRlci9ncmFwaGljL0Rpc3BsYXlhYmxlXG4gKi9cblxuXG5cbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnLi4vY29yZS91dGlsJyk7XG5cbiAgICB2YXIgU3R5bGUgPSByZXF1aXJlKCcuL1N0eWxlJyk7XG5cbiAgICB2YXIgRWxlbWVudCA9IHJlcXVpcmUoJy4uL0VsZW1lbnQnKTtcbiAgICB2YXIgUmVjdFRleHQgPSByZXF1aXJlKCcuL21peGluL1JlY3RUZXh0Jyk7XG4gICAgLy8gdmFyIFN0YXRlZnVsID0gcmVxdWlyZSgnLi9taXhpbi9TdGF0ZWZ1bCcpO1xuXG4gICAgLyoqXG4gICAgICogQGFsaWFzIG1vZHVsZTp6cmVuZGVyL2dyYXBoaWMvRGlzcGxheWFibGVcbiAgICAgKiBAZXh0ZW5kcyBtb2R1bGU6enJlbmRlci9FbGVtZW50XG4gICAgICogQGV4dGVuZHMgbW9kdWxlOnpyZW5kZXIvZ3JhcGhpYy9taXhpbi9SZWN0VGV4dFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIERpc3BsYXlhYmxlKG9wdHMpIHtcblxuICAgICAgICBvcHRzID0gb3B0cyB8fCB7fTtcblxuICAgICAgICBFbGVtZW50LmNhbGwodGhpcywgb3B0cyk7XG5cbiAgICAgICAgLy8gRXh0ZW5kIHByb3BlcnRpZXNcbiAgICAgICAgZm9yICh2YXIgbmFtZSBpbiBvcHRzKSB7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgb3B0cy5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJlxuICAgICAgICAgICAgICAgIG5hbWUgIT09ICdzdHlsZSdcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHRoaXNbbmFtZV0gPSBvcHRzW25hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHttb2R1bGU6enJlbmRlci9ncmFwaGljL1N0eWxlfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdHlsZSA9IG5ldyBTdHlsZShvcHRzLnN0eWxlKTtcblxuICAgICAgICB0aGlzLl9yZWN0ID0gbnVsbDtcbiAgICAgICAgLy8gU2hhcGVzIGZvciBjYXNjYWRlIGNsaXBwaW5nLlxuICAgICAgICB0aGlzLl9fY2xpcFBhdGhzID0gW107XG5cbiAgICAgICAgLy8gRklYTUUgU3RhdGVmdWwgbXVzdCBiZSBtaXhpbmVkIGFmdGVyIHN0eWxlIGlzIHNldHRlZFxuICAgICAgICAvLyBTdGF0ZWZ1bC5jYWxsKHRoaXMsIG9wdHMpO1xuICAgIH1cblxuICAgIERpc3BsYXlhYmxlLnByb3RvdHlwZSA9IHtcblxuICAgICAgICBjb25zdHJ1Y3RvcjogRGlzcGxheWFibGUsXG5cbiAgICAgICAgdHlwZTogJ2Rpc3BsYXlhYmxlJyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGlzcGxheWFibGUg5piv5ZCm5Li66ISP77yMUGFpbnRlciDkuK3kvJrmoLnmja7or6XmoIforrDliKTmlq3mmK/lkKbpnIDopoHmmK/lkKbpnIDopoHph43mlrDnu5jliLZcbiAgICAgICAgICogRGlydHkgZmxhZy4gRnJvbSB3aGljaCBwYWludGVyIHdpbGwgZGV0ZXJtaW5lIGlmIHRoaXMgZGlzcGxheWFibGUgb2JqZWN0IG5lZWRzIGJydXNoXG4gICAgICAgICAqIEBuYW1lIG1vZHVsZTp6cmVuZGVyL2dyYXBoaWMvRGlzcGxheWFibGUjX19kaXJ0eVxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIF9fZGlydHk6IHRydWUsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWbvuW9ouaYr+WQpuWPr+inge+8jOS4unRydWXml7bkuI3nu5jliLblm77lvaLvvIzkvYbmmK/ku43og73op6blj5HpvKDmoIfkuovku7ZcbiAgICAgICAgICogSWYgaWdub3JlIGRyYXdpbmcgb2YgdGhlIGRpc3BsYXlhYmxlIG9iamVjdC4gTW91c2UgZXZlbnQgd2lsbCBzdGlsbCBiZSB0cmlnZ2VyZWRcbiAgICAgICAgICogQG5hbWUgbW9kdWxlOi96cmVuZGVyL2dyYXBoaWMvRGlzcGxheWFibGUjaW52aXNpYmxlXG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgaW52aXNpYmxlOiBmYWxzZSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQG5hbWUgbW9kdWxlOi96cmVuZGVyL2dyYXBoaWMvRGlzcGxheWFibGUjelxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKiBAZGVmYXVsdCAwXG4gICAgICAgICAqL1xuICAgICAgICB6OiAwLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbmFtZSBtb2R1bGU6L3pyZW5kZXIvZ3JhcGhpYy9EaXNwbGF5YWJsZSN6XG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqIEBkZWZhdWx0IDBcbiAgICAgICAgICovXG4gICAgICAgIHoyOiAwLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiB65bGCbGV2ZWzvvIzlhrPlrprnu5jnlLvlnKjlk6rlsYJjYW52YXPkuK1cbiAgICAgICAgICogQG5hbWUgbW9kdWxlOi96cmVuZGVyL2dyYXBoaWMvRGlzcGxheWFibGUjemxldmVsXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqIEBkZWZhdWx0IDBcbiAgICAgICAgICovXG4gICAgICAgIHpsZXZlbDogMCxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5piv5ZCm5Y+v5ouW5ou9XG4gICAgICAgICAqIEBuYW1lIG1vZHVsZTovenJlbmRlci9ncmFwaGljL0Rpc3BsYXlhYmxlI2RyYWdnYWJsZVxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIGRyYWdnYWJsZTogZmFsc2UsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOaYr+WQpuato+WcqOaLluaLvVxuICAgICAgICAgKiBAbmFtZSBtb2R1bGU6L3pyZW5kZXIvZ3JhcGhpYy9EaXNwbGF5YWJsZSNkcmFnZ2FibGVcbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICBkcmFnZ2luZzogZmFsc2UsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOaYr+WQpuebuOW6lOm8oOagh+S6i+S7tlxuICAgICAgICAgKiBAbmFtZSBtb2R1bGU6L3pyZW5kZXIvZ3JhcGhpYy9EaXNwbGF5YWJsZSNzaWxlbnRcbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICBzaWxlbnQ6IGZhbHNlLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiBlbmFibGUgY3VsbGluZ1xuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIGN1bGxpbmc6IGZhbHNlLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNb3VzZSBjdXJzb3Igd2hlbiBob3ZlcmVkXG4gICAgICAgICAqIEBuYW1lIG1vZHVsZTovenJlbmRlci9ncmFwaGljL0Rpc3BsYXlhYmxlI2N1cnNvclxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgY3Vyc29yOiAncG9pbnRlcicsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIGhvdmVyIGFyZWEgaXMgYm91bmRpbmcgcmVjdFxuICAgICAgICAgKiBAbmFtZSBtb2R1bGU6L3pyZW5kZXIvZ3JhcGhpYy9EaXNwbGF5YWJsZSNyZWN0SG92ZXJcbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIHJlY3RIb3ZlcjogZmFsc2UsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlbmRlciB0aGUgZWxlbWVudCBwcm9ncmVzc2l2ZWx5IHdoZW4gdGhlIHZhbHVlID49IDAsXG4gICAgICAgICAqIHVzZWZ1bGwgZm9yIGxhcmdlIGRhdGEuXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBwcm9ncmVzc2l2ZTogLTEsXG5cbiAgICAgICAgYmVmb3JlQnJ1c2g6IGZ1bmN0aW9uIChjdHgpIHt9LFxuXG4gICAgICAgIGFmdGVyQnJ1c2g6IGZ1bmN0aW9uIChjdHgpIHt9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlm77lvaLnu5jliLbmlrnms5VcbiAgICAgICAgICogQHBhcmFtIHtDYW52YXMyRFJlbmRlcmluZ0NvbnRleHR9IGN0eFxuICAgICAgICAgKi9cbiAgICAgICAgLy8gSW50ZXJmYWNlXG4gICAgICAgIGJydXNoOiBmdW5jdGlvbiAoY3R4LCBwcmV2RWwpIHt9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDojrflj5bmnIDlsI/ljIXlm7Tnm5JcbiAgICAgICAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvY29yZS9Cb3VuZGluZ1JlY3R9XG4gICAgICAgICAqL1xuICAgICAgICAvLyBJbnRlcmZhY2VcbiAgICAgICAgZ2V0Qm91bmRpbmdSZWN0OiBmdW5jdGlvbiAoKSB7fSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5Yik5pat5Z2Q5qCHIHgsIHkg5piv5ZCm5Zyo5Zu+5b2i5LiKXG4gICAgICAgICAqIElmIGRpc3BsYXlhYmxlIGVsZW1lbnQgY29udGFpbiBjb29yZCB4LCB5XG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0geFxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHlcbiAgICAgICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIGNvbnRhaW46IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZWN0Q29udGFpbih4LCB5KTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtICB7RnVuY3Rpb259IGNiXG4gICAgICAgICAqIEBwYXJhbSAge30gICBjb250ZXh0XG4gICAgICAgICAqL1xuICAgICAgICB0cmF2ZXJzZTogZnVuY3Rpb24gKGNiLCBjb250ZXh0KSB7XG4gICAgICAgICAgICBjYi5jYWxsKGNvbnRleHQsIHRoaXMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDliKTmlq3lnZDmoIcgeCwgeSDmmK/lkKblnKjlm77lvaLnmoTljIXlm7Tnm5LkuIpcbiAgICAgICAgICogSWYgYm91bmRpbmcgcmVjdCBvZiBlbGVtZW50IGNvbnRhaW4gY29vcmQgeCwgeVxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHhcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSB5XG4gICAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICByZWN0Q29udGFpbjogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgICAgIHZhciBjb29yZCA9IHRoaXMudHJhbnNmb3JtQ29vcmRUb0xvY2FsKHgsIHkpO1xuICAgICAgICAgICAgdmFyIHJlY3QgPSB0aGlzLmdldEJvdW5kaW5nUmVjdCgpO1xuICAgICAgICAgICAgcmV0dXJuIHJlY3QuY29udGFpbihjb29yZFswXSwgY29vcmRbMV0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmoIforrDlm77lvaLlhYPntKDkuLrohI/vvIzlubbkuJTlnKjkuIvkuIDluKfph43nu5hcbiAgICAgICAgICogTWFyayBkaXNwbGF5YWJsZSBlbGVtZW50IGRpcnR5IGFuZCByZWZyZXNoIG5leHQgZnJhbWVcbiAgICAgICAgICovXG4gICAgICAgIGRpcnR5OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl9fZGlydHkgPSB0cnVlO1xuXG4gICAgICAgICAgICB0aGlzLl9yZWN0ID0gbnVsbDtcblxuICAgICAgICAgICAgdGhpcy5fX3pyICYmIHRoaXMuX196ci5yZWZyZXNoKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWbvuW9ouaYr+WQpuS8muinpuWPkeS6i+S7tlxuICAgICAgICAgKiBJZiBkaXNwbGF5YWJsZSBvYmplY3QgYmluZGVkIGFueSBldmVudFxuICAgICAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgLy8gVE9ETywg6YCa6L+HIGJpbmQg57uR5a6a55qE5LqL5Lu2XG4gICAgICAgIC8vIGlzU2lsZW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vICAgICByZXR1cm4gIShcbiAgICAgICAgLy8gICAgICAgICB0aGlzLmhvdmVyYWJsZSB8fCB0aGlzLmRyYWdnYWJsZVxuICAgICAgICAvLyAgICAgICAgIHx8IHRoaXMub25tb3VzZW1vdmUgfHwgdGhpcy5vbm1vdXNlb3ZlciB8fCB0aGlzLm9ubW91c2VvdXRcbiAgICAgICAgLy8gICAgICAgICB8fCB0aGlzLm9ubW91c2Vkb3duIHx8IHRoaXMub25tb3VzZXVwIHx8IHRoaXMub25jbGlja1xuICAgICAgICAvLyAgICAgICAgIHx8IHRoaXMub25kcmFnZW50ZXIgfHwgdGhpcy5vbmRyYWdvdmVyIHx8IHRoaXMub25kcmFnbGVhdmVcbiAgICAgICAgLy8gICAgICAgICB8fCB0aGlzLm9uZHJvcFxuICAgICAgICAvLyAgICAgKTtcbiAgICAgICAgLy8gfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFsaWFzIGZvciBhbmltYXRlKCdzdHlsZScpXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gbG9vcFxuICAgICAgICAgKi9cbiAgICAgICAgYW5pbWF0ZVN0eWxlOiBmdW5jdGlvbiAobG9vcCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYW5pbWF0ZSgnc3R5bGUnLCBsb29wKTtcbiAgICAgICAgfSxcblxuICAgICAgICBhdHRyS1Y6IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoa2V5ICE9PSAnc3R5bGUnKSB7XG4gICAgICAgICAgICAgICAgRWxlbWVudC5wcm90b3R5cGUuYXR0cktWLmNhbGwodGhpcywga2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0eWxlLnNldCh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fHN0cmluZ30ga2V5XG4gICAgICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICAgICAgICovXG4gICAgICAgIHNldFN0eWxlOiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5zdHlsZS5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB0aGlzLmRpcnR5KGZhbHNlKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVc2UgZ2l2ZW4gc3R5bGUgb2JqZWN0XG4gICAgICAgICAqIEBwYXJhbSAge09iamVjdH0gb2JqXG4gICAgICAgICAqL1xuICAgICAgICB1c2VTdHlsZTogZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgICAgdGhpcy5zdHlsZSA9IG5ldyBTdHlsZShvYmopO1xuICAgICAgICAgICAgdGhpcy5kaXJ0eShmYWxzZSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB6clV0aWwuaW5oZXJpdHMoRGlzcGxheWFibGUsIEVsZW1lbnQpO1xuXG4gICAgenJVdGlsLm1peGluKERpc3BsYXlhYmxlLCBSZWN0VGV4dCk7XG4gICAgLy8genJVdGlsLm1peGluKERpc3BsYXlhYmxlLCBTdGF0ZWZ1bCk7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IERpc3BsYXlhYmxlO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34venJlbmRlci9saWIvZ3JhcGhpYy9EaXNwbGF5YWJsZS5qc1xuICoqIG1vZHVsZSBpZCA9IDdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQG1vZHVsZSB6cmVuZGVyL2dyYXBoaWMvU3R5bGVcbiAqL1xuXG5cbiAgICB2YXIgU1RZTEVfQ09NTU9OX1BST1BTID0gW1xuICAgICAgICBbJ3NoYWRvd0JsdXInLCAwXSwgWydzaGFkb3dPZmZzZXRYJywgMF0sIFsnc2hhZG93T2Zmc2V0WScsIDBdLCBbJ3NoYWRvd0NvbG9yJywgJyMwMDAnXSxcbiAgICAgICAgWydsaW5lQ2FwJywgJ2J1dHQnXSwgWydsaW5lSm9pbicsICdtaXRlciddLCBbJ21pdGVyTGltaXQnLCAxMF1cbiAgICBdO1xuXG4gICAgLy8gdmFyIFNIQURPV19QUk9QUyA9IFNUWUxFX0NPTU1PTl9QUk9QUy5zbGljZSgwLCA0KTtcbiAgICAvLyB2YXIgTElORV9QUk9QUyA9IFNUWUxFX0NPTU1PTl9QUk9QUy5zbGljZSg0KTtcblxuICAgIHZhciBTdHlsZSA9IGZ1bmN0aW9uIChvcHRzKSB7XG4gICAgICAgIHRoaXMuZXh0ZW5kRnJvbShvcHRzKTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gY3JlYXRlTGluZWFyR3JhZGllbnQoY3R4LCBvYmosIHJlY3QpIHtcbiAgICAgICAgLy8gdmFyIHNpemUgPVxuICAgICAgICB2YXIgeCA9IG9iai54O1xuICAgICAgICB2YXIgeDIgPSBvYmoueDI7XG4gICAgICAgIHZhciB5ID0gb2JqLnk7XG4gICAgICAgIHZhciB5MiA9IG9iai55MjtcblxuICAgICAgICBpZiAoIW9iai5nbG9iYWwpIHtcbiAgICAgICAgICAgIHggPSB4ICogcmVjdC53aWR0aCArIHJlY3QueDtcbiAgICAgICAgICAgIHgyID0geDIgKiByZWN0LndpZHRoICsgcmVjdC54O1xuICAgICAgICAgICAgeSA9IHkgKiByZWN0LmhlaWdodCArIHJlY3QueTtcbiAgICAgICAgICAgIHkyID0geTIgKiByZWN0LmhlaWdodCArIHJlY3QueTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjYW52YXNHcmFkaWVudCA9IGN0eC5jcmVhdGVMaW5lYXJHcmFkaWVudCh4LCB5LCB4MiwgeTIpO1xuXG4gICAgICAgIHJldHVybiBjYW52YXNHcmFkaWVudDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVSYWRpYWxHcmFkaWVudChjdHgsIG9iaiwgcmVjdCkge1xuICAgICAgICB2YXIgd2lkdGggPSByZWN0LndpZHRoO1xuICAgICAgICB2YXIgaGVpZ2h0ID0gcmVjdC5oZWlnaHQ7XG4gICAgICAgIHZhciBtaW4gPSBNYXRoLm1pbih3aWR0aCwgaGVpZ2h0KTtcblxuICAgICAgICB2YXIgeCA9IG9iai54O1xuICAgICAgICB2YXIgeSA9IG9iai55O1xuICAgICAgICB2YXIgciA9IG9iai5yO1xuICAgICAgICBpZiAoIW9iai5nbG9iYWwpIHtcbiAgICAgICAgICAgIHggPSB4ICogd2lkdGggKyByZWN0Lng7XG4gICAgICAgICAgICB5ID0geSAqIGhlaWdodCArIHJlY3QueTtcbiAgICAgICAgICAgIHIgPSByICogbWluO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNhbnZhc0dyYWRpZW50ID0gY3R4LmNyZWF0ZVJhZGlhbEdyYWRpZW50KHgsIHksIDAsIHgsIHksIHIpO1xuXG4gICAgICAgIHJldHVybiBjYW52YXNHcmFkaWVudDtcbiAgICB9XG5cblxuICAgIFN0eWxlLnByb3RvdHlwZSA9IHtcblxuICAgICAgICBjb25zdHJ1Y3RvcjogU3R5bGUsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICBmaWxsOiAnIzAwMDAwMCcsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICBzdHJva2U6IG51bGwsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBvcGFjaXR5OiAxLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7QXJyYXkuPG51bWJlcj59XG4gICAgICAgICAqL1xuICAgICAgICBsaW5lRGFzaDogbnVsbCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIGxpbmVEYXNoT2Zmc2V0OiAwLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgc2hhZG93Qmx1cjogMCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHNoYWRvd09mZnNldFg6IDAsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBzaGFkb3dPZmZzZXRZOiAwLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgbGluZVdpZHRoOiAxLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiBzdHJva2UgaWdub3JlIHNjYWxlXG4gICAgICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgc3Ryb2tlTm9TY2FsZTogZmFsc2UsXG5cbiAgICAgICAgLy8gQm91bmRpbmcgcmVjdCB0ZXh0IGNvbmZpZ3VyYXRpb25cbiAgICAgICAgLy8gTm90IGFmZmVjdGVkIGJ5IGVsZW1lbnQgdHJhbnNmb3JtXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgdGV4dDogbnVsbCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIHRleHRGaWxsOiAnIzAwMCcsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICB0ZXh0U3Ryb2tlOiBudWxsLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiAnaW5zaWRlJywgJ2xlZnQnLCAncmlnaHQnLCAndG9wJywgJ2JvdHRvbSdcbiAgICAgICAgICogW3gsIHldXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd8QXJyYXkuPG51bWJlcj59XG4gICAgICAgICAqIEBkZWZhdWx0ICdpbnNpZGUnXG4gICAgICAgICAqL1xuICAgICAgICB0ZXh0UG9zaXRpb246ICdpbnNpZGUnLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgdGV4dEJhc2VsaW5lOiBudWxsLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgdGV4dEFsaWduOiBudWxsLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgdGV4dFZlcnRpY2FsQWxpZ246IG51bGwsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE9ubHkgdXNlZnVsIGluIFBhdGggYW5kIEltYWdlIGVsZW1lbnRcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRleHREaXN0YW5jZTogNSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogT25seSB1c2VmdWwgaW4gUGF0aCBhbmQgSW1hZ2UgZWxlbWVudFxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGV4dFNoYWRvd0JsdXI6IDAsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE9ubHkgdXNlZnVsIGluIFBhdGggYW5kIEltYWdlIGVsZW1lbnRcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRleHRTaGFkb3dPZmZzZXRYOiAwLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBPbmx5IHVzZWZ1bCBpbiBQYXRoIGFuZCBJbWFnZSBlbGVtZW50XG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0ZXh0U2hhZG93T2Zmc2V0WTogMCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgdHJhbnNmb3JtIHRleHRcbiAgICAgICAgICogT25seSB1c2VmdWwgaW4gUGF0aCBhbmQgSW1hZ2UgZWxlbWVudFxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIHRleHRUcmFuc2Zvcm06IGZhbHNlLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUZXh0IHJvdGF0ZSBhcm91bmQgcG9zaXRpb24gb2YgUGF0aCBvciBJbWFnZVxuICAgICAgICAgKiBPbmx5IHVzZWZ1bCBpbiBQYXRoIGFuZCBJbWFnZSBlbGVtZW50IGFuZCB0ZXh0VHJhbnNmb3JtIGlzIGZhbHNlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGV4dFJvdGF0aW9uOiAwLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEL2dsb2JhbENvbXBvc2l0ZU9wZXJhdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgYmxlbmQ6IG51bGwsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgICAgICovXG4gICAgICAgIGJpbmQ6IGZ1bmN0aW9uIChjdHgsIGVsLCBwcmV2RWwpIHtcbiAgICAgICAgICAgIHZhciBzdHlsZSA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgcHJldlN0eWxlID0gcHJldkVsICYmIHByZXZFbC5zdHlsZTtcbiAgICAgICAgICAgIHZhciBmaXJzdERyYXcgPSAhcHJldlN0eWxlO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IFNUWUxFX0NPTU1PTl9QUk9QUy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBwcm9wID0gU1RZTEVfQ09NTU9OX1BST1BTW2ldO1xuICAgICAgICAgICAgICAgIHZhciBzdHlsZU5hbWUgPSBwcm9wWzBdO1xuXG4gICAgICAgICAgICAgICAgaWYgKGZpcnN0RHJhdyB8fCBzdHlsZVtzdHlsZU5hbWVdICE9PSBwcmV2U3R5bGVbc3R5bGVOYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBGSVhNRSBJbnZhbGlkIHByb3BlcnR5IHZhbHVlIHdpbGwgY2F1c2Ugc3R5bGUgbGVhayBmcm9tIHByZXZpb3VzIGVsZW1lbnQuXG4gICAgICAgICAgICAgICAgICAgIGN0eFtzdHlsZU5hbWVdID0gc3R5bGVbc3R5bGVOYW1lXSB8fCBwcm9wWzFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKChmaXJzdERyYXcgfHwgc3R5bGUuZmlsbCAhPT0gcHJldlN0eWxlLmZpbGwpKSB7XG4gICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHN0eWxlLmZpbGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKGZpcnN0RHJhdyB8fCBzdHlsZS5zdHJva2UgIT09IHByZXZTdHlsZS5zdHJva2UpKSB7XG4gICAgICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gc3R5bGUuc3Ryb2tlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChmaXJzdERyYXcgfHwgc3R5bGUub3BhY2l0eSAhPT0gcHJldlN0eWxlLm9wYWNpdHkpKSB7XG4gICAgICAgICAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gc3R5bGUub3BhY2l0eSA9PSBudWxsID8gMSA6IHN0eWxlLm9wYWNpdHk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICgoZmlyc3REcmF3IHx8IHN0eWxlLmJsZW5kICE9PSBwcmV2U3R5bGUuYmxlbmQpKSB7XG4gICAgICAgICAgICAgICAgY3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IHN0eWxlLmJsZW5kIHx8ICdzb3VyY2Utb3Zlcic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5oYXNTdHJva2UoKSkge1xuICAgICAgICAgICAgICAgIHZhciBsaW5lV2lkdGggPSBzdHlsZS5saW5lV2lkdGg7XG4gICAgICAgICAgICAgICAgY3R4LmxpbmVXaWR0aCA9IGxpbmVXaWR0aCAvIChcbiAgICAgICAgICAgICAgICAgICAgKHRoaXMuc3Ryb2tlTm9TY2FsZSAmJiBlbCAmJiBlbC5nZXRMaW5lU2NhbGUpID8gZWwuZ2V0TGluZVNjYWxlKCkgOiAxXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBoYXNGaWxsOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZmlsbCA9IHRoaXMuZmlsbDtcbiAgICAgICAgICAgIHJldHVybiBmaWxsICE9IG51bGwgJiYgZmlsbCAhPT0gJ25vbmUnO1xuICAgICAgICB9LFxuXG4gICAgICAgIGhhc1N0cm9rZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHN0cm9rZSA9IHRoaXMuc3Ryb2tlO1xuICAgICAgICAgICAgcmV0dXJuIHN0cm9rZSAhPSBudWxsICYmIHN0cm9rZSAhPT0gJ25vbmUnICYmIHRoaXMubGluZVdpZHRoID4gMDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogRXh0ZW5kIGZyb20gb3RoZXIgc3R5bGVcbiAgICAgICAgICogQHBhcmFtIHt6cmVuZGVyL2dyYXBoaWMvU3R5bGV9IG90aGVyU3R5bGVcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBvdmVyd3JpdGVcbiAgICAgICAgICovXG4gICAgICAgIGV4dGVuZEZyb206IGZ1bmN0aW9uIChvdGhlclN0eWxlLCBvdmVyd3JpdGUpIHtcbiAgICAgICAgICAgIGlmIChvdGhlclN0eWxlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRhcmdldCA9IHRoaXM7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgbmFtZSBpbiBvdGhlclN0eWxlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvdGhlclN0eWxlLmhhc093blByb3BlcnR5KG5hbWUpXG4gICAgICAgICAgICAgICAgICAgICAgICAmJiAob3ZlcndyaXRlIHx8ICEgdGFyZ2V0Lmhhc093blByb3BlcnR5KG5hbWUpKVxuICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldFtuYW1lXSA9IG90aGVyU3R5bGVbbmFtZV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEJhdGNoIHNldHRpbmcgc3R5bGUgd2l0aCBhIGdpdmVuIG9iamVjdFxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdHxzdHJpbmd9IG9ialxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvYmpdXG4gICAgICAgICAqL1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChvYmosIHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9iaiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICB0aGlzW29ial0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZXh0ZW5kRnJvbShvYmosIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDbG9uZVxuICAgICAgICAgKiBAcmV0dXJuIHt6cmVuZGVyL2dyYXBoaWMvU3R5bGV9IFtkZXNjcmlwdGlvbl1cbiAgICAgICAgICovXG4gICAgICAgIGNsb25lOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbmV3U3R5bGUgPSBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpO1xuICAgICAgICAgICAgbmV3U3R5bGUuZXh0ZW5kRnJvbSh0aGlzLCB0cnVlKTtcbiAgICAgICAgICAgIHJldHVybiBuZXdTdHlsZTtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXRHcmFkaWVudDogZnVuY3Rpb24gKGN0eCwgb2JqLCByZWN0KSB7XG4gICAgICAgICAgICB2YXIgbWV0aG9kID0gb2JqLnR5cGUgPT09ICdyYWRpYWwnID8gY3JlYXRlUmFkaWFsR3JhZGllbnQgOiBjcmVhdGVMaW5lYXJHcmFkaWVudDtcbiAgICAgICAgICAgIHZhciBjYW52YXNHcmFkaWVudCA9IG1ldGhvZChjdHgsIG9iaiwgcmVjdCk7XG4gICAgICAgICAgICB2YXIgY29sb3JTdG9wcyA9IG9iai5jb2xvclN0b3BzO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb2xvclN0b3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY2FudmFzR3JhZGllbnQuYWRkQ29sb3JTdG9wKFxuICAgICAgICAgICAgICAgICAgICBjb2xvclN0b3BzW2ldLm9mZnNldCwgY29sb3JTdG9wc1tpXS5jb2xvclxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY2FudmFzR3JhZGllbnQ7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIHN0eWxlUHJvdG8gPSBTdHlsZS5wcm90b3R5cGU7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBTVFlMRV9DT01NT05fUFJPUFMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHByb3AgPSBTVFlMRV9DT01NT05fUFJPUFNbaV07XG4gICAgICAgIGlmICghKHByb3BbMF0gaW4gc3R5bGVQcm90bykpIHtcbiAgICAgICAgICAgIHN0eWxlUHJvdG9bcHJvcFswXV0gPSBwcm9wWzFdO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gUHJvdmlkZSBmb3Igb3RoZXJzXG4gICAgU3R5bGUuZ2V0R3JhZGllbnQgPSBzdHlsZVByb3RvLmdldEdyYWRpZW50O1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBTdHlsZTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvU3R5bGUuanNcbiAqKiBtb2R1bGUgaWQgPSA4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG4vKipcbiAqIEBtb2R1bGUgenJlbmRlci9FbGVtZW50XG4gKi9cblxuXG4gICAgdmFyIGd1aWQgPSByZXF1aXJlKCcuL2NvcmUvZ3VpZCcpO1xuICAgIHZhciBFdmVudGZ1bCA9IHJlcXVpcmUoJy4vbWl4aW4vRXZlbnRmdWwnKTtcbiAgICB2YXIgVHJhbnNmb3JtYWJsZSA9IHJlcXVpcmUoJy4vbWl4aW4vVHJhbnNmb3JtYWJsZScpO1xuICAgIHZhciBBbmltYXRhYmxlID0gcmVxdWlyZSgnLi9taXhpbi9BbmltYXRhYmxlJyk7XG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJy4vY29yZS91dGlsJyk7XG5cbiAgICAvKipcbiAgICAgKiBAYWxpYXMgbW9kdWxlOnpyZW5kZXIvRWxlbWVudFxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBleHRlbmRzIHttb2R1bGU6enJlbmRlci9taXhpbi9BbmltYXRhYmxlfVxuICAgICAqIEBleHRlbmRzIHttb2R1bGU6enJlbmRlci9taXhpbi9UcmFuc2Zvcm1hYmxlfVxuICAgICAqIEBleHRlbmRzIHttb2R1bGU6enJlbmRlci9taXhpbi9FdmVudGZ1bH1cbiAgICAgKi9cbiAgICB2YXIgRWxlbWVudCA9IGZ1bmN0aW9uIChvcHRzKSB7XG5cbiAgICAgICAgVHJhbnNmb3JtYWJsZS5jYWxsKHRoaXMsIG9wdHMpO1xuICAgICAgICBFdmVudGZ1bC5jYWxsKHRoaXMsIG9wdHMpO1xuICAgICAgICBBbmltYXRhYmxlLmNhbGwodGhpcywgb3B0cyk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOeUu+W4g+WFg+e0oElEXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmlkID0gb3B0cy5pZCB8fCBndWlkKCk7XG4gICAgfTtcblxuICAgIEVsZW1lbnQucHJvdG90eXBlID0ge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlhYPntKDnsbvlnotcbiAgICAgICAgICogRWxlbWVudCB0eXBlXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICB0eXBlOiAnZWxlbWVudCcsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWFg+e0oOWQjeWtl1xuICAgICAgICAgKiBFbGVtZW50IG5hbWVcbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIG5hbWU6ICcnLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBaUmVuZGVyIOWunuS+i+Wvueixoe+8jOS8muWcqCBlbGVtZW50IOa3u+WKoOWIsCB6cmVuZGVyIOWunuS+i+S4reWQjuiHquWKqOi1i+WAvFxuICAgICAgICAgKiBaUmVuZGVyIGluc3RhbmNlIHdpbGwgYmUgYXNzaWduZWQgd2hlbiBlbGVtZW50IGlzIGFzc29jaWF0ZWQgd2l0aCB6cmVuZGVyXG4gICAgICAgICAqIEBuYW1lIG1vZHVsZTovenJlbmRlci9FbGVtZW50I19fenJcbiAgICAgICAgICogQHR5cGUge21vZHVsZTp6cmVuZGVyL1pSZW5kZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBfX3pyOiBudWxsLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlm77lvaLmmK/lkKblv73nlaXvvIzkuLp0cnVl5pe25b+955Wl5Zu+5b2i55qE57uY5Yi25Lul5Y+K5LqL5Lu26Kem5Y+RXG4gICAgICAgICAqIElmIGlnbm9yZSBkcmF3aW5nIGFuZCBldmVudHMgb2YgdGhlIGVsZW1lbnQgb2JqZWN0XG4gICAgICAgICAqIEBuYW1lIG1vZHVsZTovenJlbmRlci9FbGVtZW50I2lnbm9yZVxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIGlnbm9yZTogZmFsc2UsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOeUqOS6juijgeWJqueahOi3r+W+hChzaGFwZSnvvIzmiYDmnIkgR3JvdXAg5YaF55qE6Lev5b6E5Zyo57uY5Yi25pe26YO95Lya6KKr6L+Z5Liq6Lev5b6E6KOB5YmqXG4gICAgICAgICAqIOivpei3r+W+hOS8mue7p+aJv+iiq+ijgeWHj+WvueixoeeahOWPmOaNolxuICAgICAgICAgKiBAdHlwZSB7bW9kdWxlOnpyZW5kZXIvZ3JhcGhpYy9QYXRofVxuICAgICAgICAgKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSLzJkY29udGV4dC8jY2xpcHBpbmctcmVnaW9uXG4gICAgICAgICAqIEByZWFkT25seVxuICAgICAgICAgKi9cbiAgICAgICAgY2xpcFBhdGg6IG51bGwsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERyaWZ0IGVsZW1lbnRcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSBkeCBkeCBvbiB0aGUgZ2xvYmFsIHNwYWNlXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gZHkgZHkgb24gdGhlIGdsb2JhbCBzcGFjZVxuICAgICAgICAgKi9cbiAgICAgICAgZHJpZnQ6IGZ1bmN0aW9uIChkeCwgZHkpIHtcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy5kcmFnZ2FibGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdob3Jpem9udGFsJzpcbiAgICAgICAgICAgICAgICAgICAgZHkgPSAwO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICd2ZXJ0aWNhbCc6XG4gICAgICAgICAgICAgICAgICAgIGR4ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBtID0gdGhpcy50cmFuc2Zvcm07XG4gICAgICAgICAgICBpZiAoIW0pIHtcbiAgICAgICAgICAgICAgICBtID0gdGhpcy50cmFuc2Zvcm0gPSBbMSwgMCwgMCwgMSwgMCwgMF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtWzRdICs9IGR4O1xuICAgICAgICAgICAgbVs1XSArPSBkeTtcblxuICAgICAgICAgICAgdGhpcy5kZWNvbXBvc2VUcmFuc2Zvcm0oKTtcbiAgICAgICAgICAgIHRoaXMuZGlydHkoZmFsc2UpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBIb29rIGJlZm9yZSB1cGRhdGVcbiAgICAgICAgICovXG4gICAgICAgIGJlZm9yZVVwZGF0ZTogZnVuY3Rpb24gKCkge30sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBIb29rIGFmdGVyIHVwZGF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgYWZ0ZXJVcGRhdGU6IGZ1bmN0aW9uICgpIHt9LFxuICAgICAgICAvKipcbiAgICAgICAgICogVXBkYXRlIGVhY2ggZnJhbWVcbiAgICAgICAgICovXG4gICAgICAgIHVwZGF0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVUcmFuc2Zvcm0oKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtICB7RnVuY3Rpb259IGNiXG4gICAgICAgICAqIEBwYXJhbSAge30gICBjb250ZXh0XG4gICAgICAgICAqL1xuICAgICAgICB0cmF2ZXJzZTogZnVuY3Rpb24gKGNiLCBjb250ZXh0KSB7fSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgYXR0cktWOiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKGtleSA9PT0gJ3Bvc2l0aW9uJyB8fCBrZXkgPT09ICdzY2FsZScgfHwga2V5ID09PSAnb3JpZ2luJykge1xuICAgICAgICAgICAgICAgIC8vIENvcHkgdGhlIGFycmF5XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0YXJnZXQgPSB0aGlzW2tleV07XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQgPSB0aGlzW2tleV0gPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0YXJnZXRbMF0gPSB2YWx1ZVswXTtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0WzFdID0gdmFsdWVbMV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpc1trZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEhpZGUgdGhlIGVsZW1lbnRcbiAgICAgICAgICovXG4gICAgICAgIGhpZGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuaWdub3JlID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX196ciAmJiB0aGlzLl9fenIucmVmcmVzaCgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTaG93IHRoZSBlbGVtZW50XG4gICAgICAgICAqL1xuICAgICAgICBzaG93OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLmlnbm9yZSA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5fX3pyICYmIHRoaXMuX196ci5yZWZyZXNoKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfE9iamVjdH0ga2V5XG4gICAgICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICAgICAgICovXG4gICAgICAgIGF0dHI6IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGtleSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmF0dHJLVihrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHpyVXRpbC5pc09iamVjdChrZXkpKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgbmFtZSBpbiBrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGtleS5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hdHRyS1YobmFtZSwga2V5W25hbWVdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5kaXJ0eShmYWxzZSk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL2dyYXBoaWMvUGF0aH0gY2xpcFBhdGhcbiAgICAgICAgICovXG4gICAgICAgIHNldENsaXBQYXRoOiBmdW5jdGlvbiAoY2xpcFBhdGgpIHtcbiAgICAgICAgICAgIHZhciB6ciA9IHRoaXMuX196cjtcbiAgICAgICAgICAgIGlmICh6cikge1xuICAgICAgICAgICAgICAgIGNsaXBQYXRoLmFkZFNlbGZUb1pyKHpyKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gUmVtb3ZlIHByZXZpb3VzIGNsaXAgcGF0aFxuICAgICAgICAgICAgaWYgKHRoaXMuY2xpcFBhdGggJiYgdGhpcy5jbGlwUGF0aCAhPT0gY2xpcFBhdGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZUNsaXBQYXRoKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuY2xpcFBhdGggPSBjbGlwUGF0aDtcbiAgICAgICAgICAgIGNsaXBQYXRoLl9fenIgPSB6cjtcbiAgICAgICAgICAgIGNsaXBQYXRoLl9fY2xpcFRhcmdldCA9IHRoaXM7XG5cbiAgICAgICAgICAgIHRoaXMuZGlydHkoZmFsc2UpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKi9cbiAgICAgICAgcmVtb3ZlQ2xpcFBhdGg6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBjbGlwUGF0aCA9IHRoaXMuY2xpcFBhdGg7XG4gICAgICAgICAgICBpZiAoY2xpcFBhdGgpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2xpcFBhdGguX196cikge1xuICAgICAgICAgICAgICAgICAgICBjbGlwUGF0aC5yZW1vdmVTZWxmRnJvbVpyKGNsaXBQYXRoLl9fenIpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNsaXBQYXRoLl9fenIgPSBudWxsO1xuICAgICAgICAgICAgICAgIGNsaXBQYXRoLl9fY2xpcFRhcmdldCA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhpcy5jbGlwUGF0aCA9IG51bGw7XG5cbiAgICAgICAgICAgICAgICB0aGlzLmRpcnR5KGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQWRkIHNlbGYgZnJvbSB6cmVuZGVyIGluc3RhbmNlLlxuICAgICAgICAgKiBOb3QgcmVjdXJzaXZlbHkgYmVjYXVzZSBpdCB3aWxsIGJlIGludm9rZWQgd2hlbiBlbGVtZW50IGFkZGVkIHRvIHN0b3JhZ2UuXG4gICAgICAgICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvWlJlbmRlcn0genJcbiAgICAgICAgICovXG4gICAgICAgIGFkZFNlbGZUb1pyOiBmdW5jdGlvbiAoenIpIHtcbiAgICAgICAgICAgIHRoaXMuX196ciA9IHpyO1xuICAgICAgICAgICAgLy8g5re75Yqg5Yqo55S7XG4gICAgICAgICAgICB2YXIgYW5pbWF0b3JzID0gdGhpcy5hbmltYXRvcnM7XG4gICAgICAgICAgICBpZiAoYW5pbWF0b3JzKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbmltYXRvcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgenIuYW5pbWF0aW9uLmFkZEFuaW1hdG9yKGFuaW1hdG9yc1tpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5jbGlwUGF0aCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2xpcFBhdGguYWRkU2VsZlRvWnIoenIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW1vdmUgc2VsZiBmcm9tIHpyZW5kZXIgaW5zdGFuY2UuXG4gICAgICAgICAqIE5vdCByZWN1cnNpdmVseSBiZWNhdXNlIGl0IHdpbGwgYmUgaW52b2tlZCB3aGVuIGVsZW1lbnQgYWRkZWQgdG8gc3RvcmFnZS5cbiAgICAgICAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9aUmVuZGVyfSB6clxuICAgICAgICAgKi9cbiAgICAgICAgcmVtb3ZlU2VsZkZyb21acjogZnVuY3Rpb24gKHpyKSB7XG4gICAgICAgICAgICB0aGlzLl9fenIgPSBudWxsO1xuICAgICAgICAgICAgLy8g56e76Zmk5Yqo55S7XG4gICAgICAgICAgICB2YXIgYW5pbWF0b3JzID0gdGhpcy5hbmltYXRvcnM7XG4gICAgICAgICAgICBpZiAoYW5pbWF0b3JzKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbmltYXRvcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgenIuYW5pbWF0aW9uLnJlbW92ZUFuaW1hdG9yKGFuaW1hdG9yc1tpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5jbGlwUGF0aCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2xpcFBhdGgucmVtb3ZlU2VsZkZyb21acih6cik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgenJVdGlsLm1peGluKEVsZW1lbnQsIEFuaW1hdGFibGUpO1xuICAgIHpyVXRpbC5taXhpbihFbGVtZW50LCBUcmFuc2Zvcm1hYmxlKTtcbiAgICB6clV0aWwubWl4aW4oRWxlbWVudCwgRXZlbnRmdWwpO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBFbGVtZW50O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34venJlbmRlci9saWIvRWxlbWVudC5qc1xuICoqIG1vZHVsZSBpZCA9IDlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogenJlbmRlcjog55Sf5oiQ5ZSv5LiAaWRcbiAqXG4gKiBAYXV0aG9yIGVycm9ycmlrIChlcnJvcnJpa0BnbWFpbC5jb20pXG4gKi9cblxuXG4gICAgdmFyIGlkU3RhcnQgPSAweDA5MDc7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGlkU3RhcnQrKztcbiAgICB9O1xuXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi96cmVuZGVyL2xpYi9jb3JlL2d1aWQuanNcbiAqKiBtb2R1bGUgaWQgPSAxMFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiDkuovku7bmianlsZVcbiAqIEBtb2R1bGUgenJlbmRlci9taXhpbi9FdmVudGZ1bFxuICogQGF1dGhvciBLZW5lciAoQEtlbmVyLeael+WzsCwga2VuZXIubGluZmVuZ0BnbWFpbC5jb20pXG4gKiAgICAgICAgIHBpc3NhbmcgKGh0dHBzOi8vd3d3LmdpdGh1Yi5jb20vcGlzc2FuZylcbiAqL1xuXG5cbiAgICB2YXIgYXJyeVNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xuXG4gICAgLyoqXG4gICAgICog5LqL5Lu25YiG5Y+R5ZmoXG4gICAgICogQGFsaWFzIG1vZHVsZTp6cmVuZGVyL21peGluL0V2ZW50ZnVsXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICovXG4gICAgdmFyIEV2ZW50ZnVsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl8kaGFuZGxlcnMgPSB7fTtcbiAgICB9O1xuXG4gICAgRXZlbnRmdWwucHJvdG90eXBlID0ge1xuXG4gICAgICAgIGNvbnN0cnVjdG9yOiBFdmVudGZ1bCxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5Y2V5qyh6Kem5Y+R57uR5a6a77yMdHJpZ2dlcuWQjumUgOavgVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnQg5LqL5Lu25ZCNXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXIg5ZON5bqU5Ye95pWwXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0XG4gICAgICAgICAqL1xuICAgICAgICBvbmU6IGZ1bmN0aW9uIChldmVudCwgaGFuZGxlciwgY29udGV4dCkge1xuICAgICAgICAgICAgdmFyIF9oID0gdGhpcy5fJGhhbmRsZXJzO1xuXG4gICAgICAgICAgICBpZiAoIWhhbmRsZXIgfHwgIWV2ZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghX2hbZXZlbnRdKSB7XG4gICAgICAgICAgICAgICAgX2hbZXZlbnRdID0gW107XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgX2hbZXZlbnRdLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKF9oW2V2ZW50XVtpXS5oID09PSBoYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2hbZXZlbnRdLnB1c2goe1xuICAgICAgICAgICAgICAgIGg6IGhhbmRsZXIsXG4gICAgICAgICAgICAgICAgb25lOiB0cnVlLFxuICAgICAgICAgICAgICAgIGN0eDogY29udGV4dCB8fCB0aGlzXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOe7keWumuS6i+S7tlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnQg5LqL5Lu25ZCNXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXIg5LqL5Lu25aSE55CG5Ye95pWwXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29udGV4dF1cbiAgICAgICAgICovXG4gICAgICAgIG9uOiBmdW5jdGlvbiAoZXZlbnQsIGhhbmRsZXIsIGNvbnRleHQpIHtcbiAgICAgICAgICAgIHZhciBfaCA9IHRoaXMuXyRoYW5kbGVycztcblxuICAgICAgICAgICAgaWYgKCFoYW5kbGVyIHx8ICFldmVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIV9oW2V2ZW50XSkge1xuICAgICAgICAgICAgICAgIF9oW2V2ZW50XSA9IFtdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IF9oW2V2ZW50XS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChfaFtldmVudF1baV0uaCA9PT0gaGFuZGxlcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9oW2V2ZW50XS5wdXNoKHtcbiAgICAgICAgICAgICAgICBoOiBoYW5kbGVyLFxuICAgICAgICAgICAgICAgIG9uZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgY3R4OiBjb250ZXh0IHx8IHRoaXNcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5piv5ZCm57uR5a6a5LqG5LqL5Lu2XG4gICAgICAgICAqIEBwYXJhbSAge3N0cmluZ30gIGV2ZW50XG4gICAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICBpc1NpbGVudDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgX2ggPSB0aGlzLl8kaGFuZGxlcnM7XG4gICAgICAgICAgICByZXR1cm4gX2hbZXZlbnRdICYmIF9oW2V2ZW50XS5sZW5ndGg7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOino+e7keS6i+S7tlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnQg5LqL5Lu25ZCNXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtoYW5kbGVyXSDkuovku7blpITnkIblh73mlbBcbiAgICAgICAgICovXG4gICAgICAgIG9mZjogZnVuY3Rpb24gKGV2ZW50LCBoYW5kbGVyKSB7XG4gICAgICAgICAgICB2YXIgX2ggPSB0aGlzLl8kaGFuZGxlcnM7XG5cbiAgICAgICAgICAgIGlmICghZXZlbnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl8kaGFuZGxlcnMgPSB7fTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAoX2hbZXZlbnRdKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXdMaXN0ID0gW107XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gX2hbZXZlbnRdLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9oW2V2ZW50XVtpXVsnaCddICE9IGhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdMaXN0LnB1c2goX2hbZXZlbnRdW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBfaFtldmVudF0gPSBuZXdMaXN0O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChfaFtldmVudF0gJiYgX2hbZXZlbnRdLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgX2hbZXZlbnRdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBfaFtldmVudF07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDkuovku7bliIblj5FcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUg5LqL5Lu257G75Z6LXG4gICAgICAgICAqL1xuICAgICAgICB0cmlnZ2VyOiBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuXyRoYW5kbGVyc1t0eXBlXSkge1xuICAgICAgICAgICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgICAgICAgICAgIHZhciBhcmdMZW4gPSBhcmdzLmxlbmd0aDtcblxuICAgICAgICAgICAgICAgIGlmIChhcmdMZW4gPiAzKSB7XG4gICAgICAgICAgICAgICAgICAgIGFyZ3MgPSBhcnJ5U2xpY2UuY2FsbChhcmdzLCAxKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgX2ggPSB0aGlzLl8kaGFuZGxlcnNbdHlwZV07XG4gICAgICAgICAgICAgICAgdmFyIGxlbiA9IF9oLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjspIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gT3B0aW1pemUgYWR2aXNlIGZyb20gYmFja2JvbmVcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChhcmdMZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfaFtpXVsnaCddLmNhbGwoX2hbaV1bJ2N0eCddKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfaFtpXVsnaCddLmNhbGwoX2hbaV1bJ2N0eCddLCBhcmdzWzFdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfaFtpXVsnaCddLmNhbGwoX2hbaV1bJ2N0eCddLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaGF2ZSBtb3JlIHRoYW4gMiBnaXZlbiBhcmd1bWVudHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfaFtpXVsnaCddLmFwcGx5KF9oW2ldWydjdHgnXSwgYXJncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoX2hbaV1bJ29uZSddKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfaC5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZW4tLTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOW4puaciWNvbnRleHTnmoTkuovku7bliIblj5EsIOacgOWQjuS4gOS4quWPguaVsOaYr+S6i+S7tuWbnuiwg+eahGNvbnRleHRcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUg5LqL5Lu257G75Z6LXG4gICAgICAgICAqL1xuICAgICAgICB0cmlnZ2VyV2l0aENvbnRleHQ6IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fJGhhbmRsZXJzW3R5cGVdKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgICAgICAgICAgdmFyIGFyZ0xlbiA9IGFyZ3MubGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgaWYgKGFyZ0xlbiA+IDQpIHtcbiAgICAgICAgICAgICAgICAgICAgYXJncyA9IGFycnlTbGljZS5jYWxsKGFyZ3MsIDEsIGFyZ3MubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBjdHggPSBhcmdzW2FyZ3MubGVuZ3RoIC0gMV07XG5cbiAgICAgICAgICAgICAgICB2YXIgX2ggPSB0aGlzLl8kaGFuZGxlcnNbdHlwZV07XG4gICAgICAgICAgICAgICAgdmFyIGxlbiA9IF9oLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjspIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gT3B0aW1pemUgYWR2aXNlIGZyb20gYmFja2JvbmVcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChhcmdMZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfaFtpXVsnaCddLmNhbGwoY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfaFtpXVsnaCddLmNhbGwoY3R4LCBhcmdzWzFdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfaFtpXVsnaCddLmNhbGwoY3R4LCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaGF2ZSBtb3JlIHRoYW4gMiBnaXZlbiBhcmd1bWVudHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfaFtpXVsnaCddLmFwcGx5KGN0eCwgYXJncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoX2hbaV1bJ29uZSddKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfaC5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZW4tLTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8g5a+56LGh5Y+v5Lul6YCa6L+HIG9ueHh4eCDnu5Hlrprkuovku7ZcbiAgICAvKipcbiAgICAgKiBAZXZlbnQgbW9kdWxlOnpyZW5kZXIvbWl4aW4vRXZlbnRmdWwjb25jbGlja1xuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICovXG4gICAgLyoqXG4gICAgICogQGV2ZW50IG1vZHVsZTp6cmVuZGVyL21peGluL0V2ZW50ZnVsI29ubW91c2VvdmVyXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAqIEBkZWZhdWx0IG51bGxcbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBAZXZlbnQgbW9kdWxlOnpyZW5kZXIvbWl4aW4vRXZlbnRmdWwjb25tb3VzZW91dFxuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICovXG4gICAgLyoqXG4gICAgICogQGV2ZW50IG1vZHVsZTp6cmVuZGVyL21peGluL0V2ZW50ZnVsI29ubW91c2Vtb3ZlXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAqIEBkZWZhdWx0IG51bGxcbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBAZXZlbnQgbW9kdWxlOnpyZW5kZXIvbWl4aW4vRXZlbnRmdWwjb25tb3VzZXdoZWVsXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAqIEBkZWZhdWx0IG51bGxcbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBAZXZlbnQgbW9kdWxlOnpyZW5kZXIvbWl4aW4vRXZlbnRmdWwjb25tb3VzZWRvd25cbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICogQGRlZmF1bHQgbnVsbFxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIEBldmVudCBtb2R1bGU6enJlbmRlci9taXhpbi9FdmVudGZ1bCNvbm1vdXNldXBcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICogQGRlZmF1bHQgbnVsbFxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIEBldmVudCBtb2R1bGU6enJlbmRlci9taXhpbi9FdmVudGZ1bCNvbmRyYWdzdGFydFxuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICovXG4gICAgLyoqXG4gICAgICogQGV2ZW50IG1vZHVsZTp6cmVuZGVyL21peGluL0V2ZW50ZnVsI29uZHJhZ2VuZFxuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICovXG4gICAgLyoqXG4gICAgICogQGV2ZW50IG1vZHVsZTp6cmVuZGVyL21peGluL0V2ZW50ZnVsI29uZHJhZ2VudGVyXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAqIEBkZWZhdWx0IG51bGxcbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBAZXZlbnQgbW9kdWxlOnpyZW5kZXIvbWl4aW4vRXZlbnRmdWwjb25kcmFnbGVhdmVcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICogQGRlZmF1bHQgbnVsbFxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIEBldmVudCBtb2R1bGU6enJlbmRlci9taXhpbi9FdmVudGZ1bCNvbmRyYWdvdmVyXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAqIEBkZWZhdWx0IG51bGxcbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBAZXZlbnQgbW9kdWxlOnpyZW5kZXIvbWl4aW4vRXZlbnRmdWwjb25kcm9wXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAqIEBkZWZhdWx0IG51bGxcbiAgICAgKi9cblxuICAgIG1vZHVsZS5leHBvcnRzID0gRXZlbnRmdWw7XG5cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3pyZW5kZXIvbGliL21peGluL0V2ZW50ZnVsLmpzXG4gKiogbW9kdWxlIGlkID0gMTFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0Jztcbi8qKlxuICog5o+Q5L6b5Y+Y5o2i5omp5bGVXG4gKiBAbW9kdWxlIHpyZW5kZXIvbWl4aW4vVHJhbnNmb3JtYWJsZVxuICogQGF1dGhvciBwaXNzYW5nIChodHRwczovL3d3dy5naXRodWIuY29tL3Bpc3NhbmcpXG4gKi9cblxuXG4gICAgdmFyIG1hdHJpeCA9IHJlcXVpcmUoJy4uL2NvcmUvbWF0cml4Jyk7XG4gICAgdmFyIHZlY3RvciA9IHJlcXVpcmUoJy4uL2NvcmUvdmVjdG9yJyk7XG4gICAgdmFyIG1JZGVudGl0eSA9IG1hdHJpeC5pZGVudGl0eTtcblxuICAgIHZhciBFUFNJTE9OID0gNWUtNTtcblxuICAgIGZ1bmN0aW9uIGlzTm90QXJvdW5kWmVybyh2YWwpIHtcbiAgICAgICAgcmV0dXJuIHZhbCA+IEVQU0lMT04gfHwgdmFsIDwgLUVQU0lMT047XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGFsaWFzIG1vZHVsZTp6cmVuZGVyL21peGluL1RyYW5zZm9ybWFibGVcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKi9cbiAgICB2YXIgVHJhbnNmb3JtYWJsZSA9IGZ1bmN0aW9uIChvcHRzKSB7XG4gICAgICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xuICAgICAgICAvLyBJZiB0aGVyZSBhcmUgbm8gZ2l2ZW4gcG9zaXRpb24sIHJvdGF0aW9uLCBzY2FsZVxuICAgICAgICBpZiAoIW9wdHMucG9zaXRpb24pIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICog5bmz56e7XG4gICAgICAgICAgICAgKiBAdHlwZSB7QXJyYXkuPG51bWJlcj59XG4gICAgICAgICAgICAgKiBAZGVmYXVsdCBbMCwgMF1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbiA9IFswLCAwXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0cy5yb3RhdGlvbiA9PSBudWxsKSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIOaXi+i9rFxuICAgICAgICAgICAgICogQHR5cGUge0FycmF5LjxudW1iZXI+fVxuICAgICAgICAgICAgICogQGRlZmF1bHQgMFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLnJvdGF0aW9uID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW9wdHMuc2NhbGUpIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICog57yp5pS+XG4gICAgICAgICAgICAgKiBAdHlwZSB7QXJyYXkuPG51bWJlcj59XG4gICAgICAgICAgICAgKiBAZGVmYXVsdCBbMSwgMV1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5zY2FsZSA9IFsxLCAxXTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICog5peL6L2s5ZKM57yp5pS+55qE5Y6f54K5XG4gICAgICAgICAqIEB0eXBlIHtBcnJheS48bnVtYmVyPn1cbiAgICAgICAgICogQGRlZmF1bHQgbnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vcmlnaW4gPSB0aGlzLm9yaWdpbiB8fCBudWxsO1xuICAgIH07XG5cbiAgICB2YXIgdHJhbnNmb3JtYWJsZVByb3RvID0gVHJhbnNmb3JtYWJsZS5wcm90b3R5cGU7XG4gICAgdHJhbnNmb3JtYWJsZVByb3RvLnRyYW5zZm9ybSA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiDliKTmlq3mmK/lkKbpnIDopoHmnInlnZDmoIflj5jmjaJcbiAgICAgKiDlpoLmnpzmnInlnZDmoIflj5jmjaIsIOWImeS7jnBvc2l0aW9uLCByb3RhdGlvbiwgc2NhbGXku6Xlj4rniLboioLngrnnmoR0cmFuc2Zvcm3orqHnrpflh7roh6rouqvnmoR0cmFuc2Zvcm3nn6npmLVcbiAgICAgKi9cbiAgICB0cmFuc2Zvcm1hYmxlUHJvdG8ubmVlZExvY2FsVHJhbnNmb3JtID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gaXNOb3RBcm91bmRaZXJvKHRoaXMucm90YXRpb24pXG4gICAgICAgICAgICB8fCBpc05vdEFyb3VuZFplcm8odGhpcy5wb3NpdGlvblswXSlcbiAgICAgICAgICAgIHx8IGlzTm90QXJvdW5kWmVybyh0aGlzLnBvc2l0aW9uWzFdKVxuICAgICAgICAgICAgfHwgaXNOb3RBcm91bmRaZXJvKHRoaXMuc2NhbGVbMF0gLSAxKVxuICAgICAgICAgICAgfHwgaXNOb3RBcm91bmRaZXJvKHRoaXMuc2NhbGVbMV0gLSAxKTtcbiAgICB9O1xuXG4gICAgdHJhbnNmb3JtYWJsZVByb3RvLnVwZGF0ZVRyYW5zZm9ybSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHBhcmVudCA9IHRoaXMucGFyZW50O1xuICAgICAgICB2YXIgcGFyZW50SGFzVHJhbnNmb3JtID0gcGFyZW50ICYmIHBhcmVudC50cmFuc2Zvcm07XG4gICAgICAgIHZhciBuZWVkTG9jYWxUcmFuc2Zvcm0gPSB0aGlzLm5lZWRMb2NhbFRyYW5zZm9ybSgpO1xuXG4gICAgICAgIHZhciBtID0gdGhpcy50cmFuc2Zvcm07XG4gICAgICAgIGlmICghKG5lZWRMb2NhbFRyYW5zZm9ybSB8fCBwYXJlbnRIYXNUcmFuc2Zvcm0pKSB7XG4gICAgICAgICAgICBtICYmIG1JZGVudGl0eShtKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIG0gPSBtIHx8IG1hdHJpeC5jcmVhdGUoKTtcblxuICAgICAgICBpZiAobmVlZExvY2FsVHJhbnNmb3JtKSB7XG4gICAgICAgICAgICB0aGlzLmdldExvY2FsVHJhbnNmb3JtKG0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbUlkZW50aXR5KG0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8g5bqU55So54i26IqC54K55Y+Y5o2iXG4gICAgICAgIGlmIChwYXJlbnRIYXNUcmFuc2Zvcm0pIHtcbiAgICAgICAgICAgIGlmIChuZWVkTG9jYWxUcmFuc2Zvcm0pIHtcbiAgICAgICAgICAgICAgICBtYXRyaXgubXVsKG0sIHBhcmVudC50cmFuc2Zvcm0sIG0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbWF0cml4LmNvcHkobSwgcGFyZW50LnRyYW5zZm9ybSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8g5L+d5a2Y6L+Z5Liq5Y+Y5o2i55+p6Zi1XG4gICAgICAgIHRoaXMudHJhbnNmb3JtID0gbTtcblxuICAgICAgICB0aGlzLmludlRyYW5zZm9ybSA9IHRoaXMuaW52VHJhbnNmb3JtIHx8IG1hdHJpeC5jcmVhdGUoKTtcbiAgICAgICAgbWF0cml4LmludmVydCh0aGlzLmludlRyYW5zZm9ybSwgbSk7XG4gICAgfTtcblxuICAgIHRyYW5zZm9ybWFibGVQcm90by5nZXRMb2NhbFRyYW5zZm9ybSA9IGZ1bmN0aW9uIChtKSB7XG4gICAgICAgIG0gPSBtIHx8IFtdO1xuICAgICAgICBtSWRlbnRpdHkobSk7XG5cbiAgICAgICAgdmFyIG9yaWdpbiA9IHRoaXMub3JpZ2luO1xuXG4gICAgICAgIHZhciBzY2FsZSA9IHRoaXMuc2NhbGU7XG4gICAgICAgIHZhciByb3RhdGlvbiA9IHRoaXMucm90YXRpb247XG4gICAgICAgIHZhciBwb3NpdGlvbiA9IHRoaXMucG9zaXRpb247XG4gICAgICAgIGlmIChvcmlnaW4pIHtcbiAgICAgICAgICAgIC8vIFRyYW5zbGF0ZSB0byBvcmlnaW5cbiAgICAgICAgICAgIG1bNF0gLT0gb3JpZ2luWzBdO1xuICAgICAgICAgICAgbVs1XSAtPSBvcmlnaW5bMV07XG4gICAgICAgIH1cbiAgICAgICAgbWF0cml4LnNjYWxlKG0sIG0sIHNjYWxlKTtcbiAgICAgICAgaWYgKHJvdGF0aW9uKSB7XG4gICAgICAgICAgICBtYXRyaXgucm90YXRlKG0sIG0sIHJvdGF0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3JpZ2luKSB7XG4gICAgICAgICAgICAvLyBUcmFuc2xhdGUgYmFjayBmcm9tIG9yaWdpblxuICAgICAgICAgICAgbVs0XSArPSBvcmlnaW5bMF07XG4gICAgICAgICAgICBtWzVdICs9IG9yaWdpblsxXTtcbiAgICAgICAgfVxuXG4gICAgICAgIG1bNF0gKz0gcG9zaXRpb25bMF07XG4gICAgICAgIG1bNV0gKz0gcG9zaXRpb25bMV07XG5cbiAgICAgICAgcmV0dXJuIG07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiDlsIboh6rlt7HnmoR0cmFuc2Zvcm3lupTnlKjliLBjb250ZXh05LiKXG4gICAgICogQHBhcmFtIHtDb250ZXh0MkR9IGN0eFxuICAgICAqL1xuICAgIHRyYW5zZm9ybWFibGVQcm90by5zZXRUcmFuc2Zvcm0gPSBmdW5jdGlvbiAoY3R4KSB7XG4gICAgICAgIHZhciBtID0gdGhpcy50cmFuc2Zvcm07XG4gICAgICAgIHZhciBkcHIgPSBjdHguZHByIHx8IDE7XG4gICAgICAgIGlmIChtKSB7XG4gICAgICAgICAgICBjdHguc2V0VHJhbnNmb3JtKGRwciAqIG1bMF0sIGRwciAqIG1bMV0sIGRwciAqIG1bMl0sIGRwciAqIG1bM10sIGRwciAqIG1bNF0sIGRwciAqIG1bNV0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY3R4LnNldFRyYW5zZm9ybShkcHIsIDAsIDAsIGRwciwgMCwgMCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdHJhbnNmb3JtYWJsZVByb3RvLnJlc3RvcmVUcmFuc2Zvcm0gPSBmdW5jdGlvbiAoY3R4KSB7XG4gICAgICAgIHZhciBtID0gdGhpcy50cmFuc2Zvcm07XG4gICAgICAgIHZhciBkcHIgPSBjdHguZHByIHx8IDE7XG4gICAgICAgIGN0eC5zZXRUcmFuc2Zvcm0oZHByLCAwLCAwLCBkcHIsIDAsIDApO1xuICAgIH1cblxuICAgIHZhciB0bXBUcmFuc2Zvcm0gPSBbXTtcblxuICAgIC8qKlxuICAgICAqIOWIhuino2B0cmFuc2Zvcm1g55+p6Zi15YiwYHBvc2l0aW9uYCwgYHJvdGF0aW9uYCwgYHNjYWxlYFxuICAgICAqL1xuICAgIHRyYW5zZm9ybWFibGVQcm90by5kZWNvbXBvc2VUcmFuc2Zvcm0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy50cmFuc2Zvcm0pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnQ7XG4gICAgICAgIHZhciBtID0gdGhpcy50cmFuc2Zvcm07XG4gICAgICAgIGlmIChwYXJlbnQgJiYgcGFyZW50LnRyYW5zZm9ybSkge1xuICAgICAgICAgICAgLy8gR2V0IGxvY2FsIHRyYW5zZm9ybSBhbmQgZGVjb21wb3NlIHRoZW0gdG8gcG9zaXRpb24sIHNjYWxlLCByb3RhdGlvblxuICAgICAgICAgICAgbWF0cml4Lm11bCh0bXBUcmFuc2Zvcm0sIHBhcmVudC5pbnZUcmFuc2Zvcm0sIG0pO1xuICAgICAgICAgICAgbSA9IHRtcFRyYW5zZm9ybTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3ggPSBtWzBdICogbVswXSArIG1bMV0gKiBtWzFdO1xuICAgICAgICB2YXIgc3kgPSBtWzJdICogbVsyXSArIG1bM10gKiBtWzNdO1xuICAgICAgICB2YXIgcG9zaXRpb24gPSB0aGlzLnBvc2l0aW9uO1xuICAgICAgICB2YXIgc2NhbGUgPSB0aGlzLnNjYWxlO1xuICAgICAgICBpZiAoaXNOb3RBcm91bmRaZXJvKHN4IC0gMSkpIHtcbiAgICAgICAgICAgIHN4ID0gTWF0aC5zcXJ0KHN4KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNOb3RBcm91bmRaZXJvKHN5IC0gMSkpIHtcbiAgICAgICAgICAgIHN5ID0gTWF0aC5zcXJ0KHN5KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobVswXSA8IDApIHtcbiAgICAgICAgICAgIHN4ID0gLXN4O1xuICAgICAgICB9XG4gICAgICAgIGlmIChtWzNdIDwgMCkge1xuICAgICAgICAgICAgc3kgPSAtc3k7XG4gICAgICAgIH1cbiAgICAgICAgcG9zaXRpb25bMF0gPSBtWzRdO1xuICAgICAgICBwb3NpdGlvblsxXSA9IG1bNV07XG4gICAgICAgIHNjYWxlWzBdID0gc3g7XG4gICAgICAgIHNjYWxlWzFdID0gc3k7XG4gICAgICAgIHRoaXMucm90YXRpb24gPSBNYXRoLmF0YW4yKC1tWzFdIC8gc3ksIG1bMF0gLyBzeCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCBnbG9iYWwgc2NhbGVcbiAgICAgKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn1cbiAgICAgKi9cbiAgICB0cmFuc2Zvcm1hYmxlUHJvdG8uZ2V0R2xvYmFsU2NhbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBtID0gdGhpcy50cmFuc2Zvcm07XG4gICAgICAgIGlmICghbSkge1xuICAgICAgICAgICAgcmV0dXJuIFsxLCAxXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3ggPSBNYXRoLnNxcnQobVswXSAqIG1bMF0gKyBtWzFdICogbVsxXSk7XG4gICAgICAgIHZhciBzeSA9IE1hdGguc3FydChtWzJdICogbVsyXSArIG1bM10gKiBtWzNdKTtcbiAgICAgICAgaWYgKG1bMF0gPCAwKSB7XG4gICAgICAgICAgICBzeCA9IC1zeDtcbiAgICAgICAgfVxuICAgICAgICBpZiAobVszXSA8IDApIHtcbiAgICAgICAgICAgIHN5ID0gLXN5O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbc3gsIHN5XTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIOWPmOaNouWdkOagh+S9jee9ruWIsCBzaGFwZSDnmoTlsYDpg6jlnZDmoIfnqbrpl7RcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geVxuICAgICAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fVxuICAgICAqL1xuICAgIHRyYW5zZm9ybWFibGVQcm90by50cmFuc2Zvcm1Db29yZFRvTG9jYWwgPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICB2YXIgdjIgPSBbeCwgeV07XG4gICAgICAgIHZhciBpbnZUcmFuc2Zvcm0gPSB0aGlzLmludlRyYW5zZm9ybTtcbiAgICAgICAgaWYgKGludlRyYW5zZm9ybSkge1xuICAgICAgICAgICAgdmVjdG9yLmFwcGx5VHJhbnNmb3JtKHYyLCB2MiwgaW52VHJhbnNmb3JtKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdjI7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIOWPmOaNouWxgOmDqOWdkOagh+S9jee9ruWIsOWFqOWxgOWdkOagh+epuumXtFxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gICAgICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59XG4gICAgICovXG4gICAgdHJhbnNmb3JtYWJsZVByb3RvLnRyYW5zZm9ybUNvb3JkVG9HbG9iYWwgPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICB2YXIgdjIgPSBbeCwgeV07XG4gICAgICAgIHZhciB0cmFuc2Zvcm0gPSB0aGlzLnRyYW5zZm9ybTtcbiAgICAgICAgaWYgKHRyYW5zZm9ybSkge1xuICAgICAgICAgICAgdmVjdG9yLmFwcGx5VHJhbnNmb3JtKHYyLCB2MiwgdHJhbnNmb3JtKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdjI7XG4gICAgfTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gVHJhbnNmb3JtYWJsZTtcblxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34venJlbmRlci9saWIvbWl4aW4vVHJhbnNmb3JtYWJsZS5qc1xuICoqIG1vZHVsZSBpZCA9IDEyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcbiAgICB2YXIgQXJyYXlDdG9yID0gdHlwZW9mIEZsb2F0MzJBcnJheSA9PT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgPyBBcnJheVxuICAgICAgICA6IEZsb2F0MzJBcnJheTtcbiAgICAvKipcbiAgICAgKiAzeDLnn6npmLXmk43kvZznsbtcbiAgICAgKiBAZXhwb3J0cyB6cmVuZGVyL3Rvb2wvbWF0cml4XG4gICAgICovXG4gICAgdmFyIG1hdHJpeCA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWIm+W7uuS4gOS4quWNleS9jeefqemYtVxuICAgICAgICAgKiBAcmV0dXJuIHtGbG9hdDMyQXJyYXl8QXJyYXkuPG51bWJlcj59XG4gICAgICAgICAqL1xuICAgICAgICBjcmVhdGUgOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBvdXQgPSBuZXcgQXJyYXlDdG9yKDYpO1xuICAgICAgICAgICAgbWF0cml4LmlkZW50aXR5KG91dCk7XG5cbiAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDorr7nva7nn6npmLXkuLrljZXkvY3nn6npmLVcbiAgICAgICAgICogQHBhcmFtIHtGbG9hdDMyQXJyYXl8QXJyYXkuPG51bWJlcj59IG91dFxuICAgICAgICAgKi9cbiAgICAgICAgaWRlbnRpdHkgOiBmdW5jdGlvbihvdXQpIHtcbiAgICAgICAgICAgIG91dFswXSA9IDE7XG4gICAgICAgICAgICBvdXRbMV0gPSAwO1xuICAgICAgICAgICAgb3V0WzJdID0gMDtcbiAgICAgICAgICAgIG91dFszXSA9IDE7XG4gICAgICAgICAgICBvdXRbNF0gPSAwO1xuICAgICAgICAgICAgb3V0WzVdID0gMDtcbiAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlpI3liLbnn6npmLVcbiAgICAgICAgICogQHBhcmFtIHtGbG9hdDMyQXJyYXl8QXJyYXkuPG51bWJlcj59IG91dFxuICAgICAgICAgKiBAcGFyYW0ge0Zsb2F0MzJBcnJheXxBcnJheS48bnVtYmVyPn0gbVxuICAgICAgICAgKi9cbiAgICAgICAgY29weTogZnVuY3Rpb24ob3V0LCBtKSB7XG4gICAgICAgICAgICBvdXRbMF0gPSBtWzBdO1xuICAgICAgICAgICAgb3V0WzFdID0gbVsxXTtcbiAgICAgICAgICAgIG91dFsyXSA9IG1bMl07XG4gICAgICAgICAgICBvdXRbM10gPSBtWzNdO1xuICAgICAgICAgICAgb3V0WzRdID0gbVs0XTtcbiAgICAgICAgICAgIG91dFs1XSA9IG1bNV07XG4gICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICog55+p6Zi155u45LmYXG4gICAgICAgICAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fEFycmF5LjxudW1iZXI+fSBvdXRcbiAgICAgICAgICogQHBhcmFtIHtGbG9hdDMyQXJyYXl8QXJyYXkuPG51bWJlcj59IG0xXG4gICAgICAgICAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fEFycmF5LjxudW1iZXI+fSBtMlxuICAgICAgICAgKi9cbiAgICAgICAgbXVsIDogZnVuY3Rpb24gKG91dCwgbTEsIG0yKSB7XG4gICAgICAgICAgICAvLyBDb25zaWRlciBtYXRyaXgubXVsKG0sIG0yLCBtKTtcbiAgICAgICAgICAgIC8vIHdoZXJlIG91dCBpcyB0aGUgc2FtZSBhcyBtMi5cbiAgICAgICAgICAgIC8vIFNvIHVzZSB0ZW1wIHZhcmlhYmxlIHRvIGVzY2FwZSBlcnJvci5cbiAgICAgICAgICAgIHZhciBvdXQwID0gbTFbMF0gKiBtMlswXSArIG0xWzJdICogbTJbMV07XG4gICAgICAgICAgICB2YXIgb3V0MSA9IG0xWzFdICogbTJbMF0gKyBtMVszXSAqIG0yWzFdO1xuICAgICAgICAgICAgdmFyIG91dDIgPSBtMVswXSAqIG0yWzJdICsgbTFbMl0gKiBtMlszXTtcbiAgICAgICAgICAgIHZhciBvdXQzID0gbTFbMV0gKiBtMlsyXSArIG0xWzNdICogbTJbM107XG4gICAgICAgICAgICB2YXIgb3V0NCA9IG0xWzBdICogbTJbNF0gKyBtMVsyXSAqIG0yWzVdICsgbTFbNF07XG4gICAgICAgICAgICB2YXIgb3V0NSA9IG0xWzFdICogbTJbNF0gKyBtMVszXSAqIG0yWzVdICsgbTFbNV07XG4gICAgICAgICAgICBvdXRbMF0gPSBvdXQwO1xuICAgICAgICAgICAgb3V0WzFdID0gb3V0MTtcbiAgICAgICAgICAgIG91dFsyXSA9IG91dDI7XG4gICAgICAgICAgICBvdXRbM10gPSBvdXQzO1xuICAgICAgICAgICAgb3V0WzRdID0gb3V0NDtcbiAgICAgICAgICAgIG91dFs1XSA9IG91dDU7XG4gICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICog5bmz56e75Y+Y5o2iXG4gICAgICAgICAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fEFycmF5LjxudW1iZXI+fSBvdXRcbiAgICAgICAgICogQHBhcmFtIHtGbG9hdDMyQXJyYXl8QXJyYXkuPG51bWJlcj59IGFcbiAgICAgICAgICogQHBhcmFtIHtGbG9hdDMyQXJyYXl8QXJyYXkuPG51bWJlcj59IHZcbiAgICAgICAgICovXG4gICAgICAgIHRyYW5zbGF0ZSA6IGZ1bmN0aW9uKG91dCwgYSwgdikge1xuICAgICAgICAgICAgb3V0WzBdID0gYVswXTtcbiAgICAgICAgICAgIG91dFsxXSA9IGFbMV07XG4gICAgICAgICAgICBvdXRbMl0gPSBhWzJdO1xuICAgICAgICAgICAgb3V0WzNdID0gYVszXTtcbiAgICAgICAgICAgIG91dFs0XSA9IGFbNF0gKyB2WzBdO1xuICAgICAgICAgICAgb3V0WzVdID0gYVs1XSArIHZbMV07XG4gICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICog5peL6L2s5Y+Y5o2iXG4gICAgICAgICAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fEFycmF5LjxudW1iZXI+fSBvdXRcbiAgICAgICAgICogQHBhcmFtIHtGbG9hdDMyQXJyYXl8QXJyYXkuPG51bWJlcj59IGFcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHJhZFxuICAgICAgICAgKi9cbiAgICAgICAgcm90YXRlIDogZnVuY3Rpb24ob3V0LCBhLCByYWQpIHtcbiAgICAgICAgICAgIHZhciBhYSA9IGFbMF07XG4gICAgICAgICAgICB2YXIgYWMgPSBhWzJdO1xuICAgICAgICAgICAgdmFyIGF0eCA9IGFbNF07XG4gICAgICAgICAgICB2YXIgYWIgPSBhWzFdO1xuICAgICAgICAgICAgdmFyIGFkID0gYVszXTtcbiAgICAgICAgICAgIHZhciBhdHkgPSBhWzVdO1xuICAgICAgICAgICAgdmFyIHN0ID0gTWF0aC5zaW4ocmFkKTtcbiAgICAgICAgICAgIHZhciBjdCA9IE1hdGguY29zKHJhZCk7XG5cbiAgICAgICAgICAgIG91dFswXSA9IGFhICogY3QgKyBhYiAqIHN0O1xuICAgICAgICAgICAgb3V0WzFdID0gLWFhICogc3QgKyBhYiAqIGN0O1xuICAgICAgICAgICAgb3V0WzJdID0gYWMgKiBjdCArIGFkICogc3Q7XG4gICAgICAgICAgICBvdXRbM10gPSAtYWMgKiBzdCArIGN0ICogYWQ7XG4gICAgICAgICAgICBvdXRbNF0gPSBjdCAqIGF0eCArIHN0ICogYXR5O1xuICAgICAgICAgICAgb3V0WzVdID0gY3QgKiBhdHkgLSBzdCAqIGF0eDtcbiAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDnvKnmlL7lj5jmjaJcbiAgICAgICAgICogQHBhcmFtIHtGbG9hdDMyQXJyYXl8QXJyYXkuPG51bWJlcj59IG91dFxuICAgICAgICAgKiBAcGFyYW0ge0Zsb2F0MzJBcnJheXxBcnJheS48bnVtYmVyPn0gYVxuICAgICAgICAgKiBAcGFyYW0ge0Zsb2F0MzJBcnJheXxBcnJheS48bnVtYmVyPn0gdlxuICAgICAgICAgKi9cbiAgICAgICAgc2NhbGUgOiBmdW5jdGlvbihvdXQsIGEsIHYpIHtcbiAgICAgICAgICAgIHZhciB2eCA9IHZbMF07XG4gICAgICAgICAgICB2YXIgdnkgPSB2WzFdO1xuICAgICAgICAgICAgb3V0WzBdID0gYVswXSAqIHZ4O1xuICAgICAgICAgICAgb3V0WzFdID0gYVsxXSAqIHZ5O1xuICAgICAgICAgICAgb3V0WzJdID0gYVsyXSAqIHZ4O1xuICAgICAgICAgICAgb3V0WzNdID0gYVszXSAqIHZ5O1xuICAgICAgICAgICAgb3V0WzRdID0gYVs0XSAqIHZ4O1xuICAgICAgICAgICAgb3V0WzVdID0gYVs1XSAqIHZ5O1xuICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOaxgumAhuefqemYtVxuICAgICAgICAgKiBAcGFyYW0ge0Zsb2F0MzJBcnJheXxBcnJheS48bnVtYmVyPn0gb3V0XG4gICAgICAgICAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fEFycmF5LjxudW1iZXI+fSBhXG4gICAgICAgICAqL1xuICAgICAgICBpbnZlcnQgOiBmdW5jdGlvbihvdXQsIGEpIHtcblxuICAgICAgICAgICAgdmFyIGFhID0gYVswXTtcbiAgICAgICAgICAgIHZhciBhYyA9IGFbMl07XG4gICAgICAgICAgICB2YXIgYXR4ID0gYVs0XTtcbiAgICAgICAgICAgIHZhciBhYiA9IGFbMV07XG4gICAgICAgICAgICB2YXIgYWQgPSBhWzNdO1xuICAgICAgICAgICAgdmFyIGF0eSA9IGFbNV07XG5cbiAgICAgICAgICAgIHZhciBkZXQgPSBhYSAqIGFkIC0gYWIgKiBhYztcbiAgICAgICAgICAgIGlmICghZGV0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZXQgPSAxLjAgLyBkZXQ7XG5cbiAgICAgICAgICAgIG91dFswXSA9IGFkICogZGV0O1xuICAgICAgICAgICAgb3V0WzFdID0gLWFiICogZGV0O1xuICAgICAgICAgICAgb3V0WzJdID0gLWFjICogZGV0O1xuICAgICAgICAgICAgb3V0WzNdID0gYWEgKiBkZXQ7XG4gICAgICAgICAgICBvdXRbNF0gPSAoYWMgKiBhdHkgLSBhZCAqIGF0eCkgKiBkZXQ7XG4gICAgICAgICAgICBvdXRbNV0gPSAoYWIgKiBhdHggLSBhYSAqIGF0eSkgKiBkZXQ7XG4gICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gbWF0cml4O1xuXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi96cmVuZGVyL2xpYi9jb3JlL21hdHJpeC5qc1xuICoqIG1vZHVsZSBpZCA9IDEzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcbiAgICB2YXIgQXJyYXlDdG9yID0gdHlwZW9mIEZsb2F0MzJBcnJheSA9PT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgPyBBcnJheVxuICAgICAgICA6IEZsb2F0MzJBcnJheTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlZGVmIHtGbG9hdDMyQXJyYXl8QXJyYXkuPG51bWJlcj59IFZlY3RvcjJcbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiDkuoznu7TlkJHph4/nsbtcbiAgICAgKiBAZXhwb3J0cyB6cmVuZGVyL3Rvb2wvdmVjdG9yXG4gICAgICovXG4gICAgdmFyIHZlY3RvciA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWIm+W7uuS4gOS4quWQkemHj1xuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW3g9MF1cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFt5PTBdXG4gICAgICAgICAqIEByZXR1cm4ge1ZlY3RvcjJ9XG4gICAgICAgICAqL1xuICAgICAgICBjcmVhdGU6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgICAgICB2YXIgb3V0ID0gbmV3IEFycmF5Q3RvcigyKTtcbiAgICAgICAgICAgIGlmICh4ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB4ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh5ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB5ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG91dFswXSA9IHg7XG4gICAgICAgICAgICBvdXRbMV0gPSB5O1xuICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5aSN5Yi25ZCR6YeP5pWw5o2uXG4gICAgICAgICAqIEBwYXJhbSB7VmVjdG9yMn0gb3V0XG4gICAgICAgICAqIEBwYXJhbSB7VmVjdG9yMn0gdlxuICAgICAgICAgKiBAcmV0dXJuIHtWZWN0b3IyfVxuICAgICAgICAgKi9cbiAgICAgICAgY29weTogZnVuY3Rpb24gKG91dCwgdikge1xuICAgICAgICAgICAgb3V0WzBdID0gdlswXTtcbiAgICAgICAgICAgIG91dFsxXSA9IHZbMV07XG4gICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlhYvpmobkuIDkuKrlkJHph49cbiAgICAgICAgICogQHBhcmFtIHtWZWN0b3IyfSB2XG4gICAgICAgICAqIEByZXR1cm4ge1ZlY3RvcjJ9XG4gICAgICAgICAqL1xuICAgICAgICBjbG9uZTogZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgIHZhciBvdXQgPSBuZXcgQXJyYXlDdG9yKDIpO1xuICAgICAgICAgICAgb3V0WzBdID0gdlswXTtcbiAgICAgICAgICAgIG91dFsxXSA9IHZbMV07XG4gICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDorr7nva7lkJHph4/nmoTkuKTkuKrpoblcbiAgICAgICAgICogQHBhcmFtIHtWZWN0b3IyfSBvdXRcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGFcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGJcbiAgICAgICAgICogQHJldHVybiB7VmVjdG9yMn0g57uT5p6cXG4gICAgICAgICAqL1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChvdXQsIGEsIGIpIHtcbiAgICAgICAgICAgIG91dFswXSA9IGE7XG4gICAgICAgICAgICBvdXRbMV0gPSBiO1xuICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5ZCR6YeP55u45YqgXG4gICAgICAgICAqIEBwYXJhbSB7VmVjdG9yMn0gb3V0XG4gICAgICAgICAqIEBwYXJhbSB7VmVjdG9yMn0gdjFcbiAgICAgICAgICogQHBhcmFtIHtWZWN0b3IyfSB2MlxuICAgICAgICAgKi9cbiAgICAgICAgYWRkOiBmdW5jdGlvbiAob3V0LCB2MSwgdjIpIHtcbiAgICAgICAgICAgIG91dFswXSA9IHYxWzBdICsgdjJbMF07XG4gICAgICAgICAgICBvdXRbMV0gPSB2MVsxXSArIHYyWzFdO1xuICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5ZCR6YeP57yp5pS+5ZCO55u45YqgXG4gICAgICAgICAqIEBwYXJhbSB7VmVjdG9yMn0gb3V0XG4gICAgICAgICAqIEBwYXJhbSB7VmVjdG9yMn0gdjFcbiAgICAgICAgICogQHBhcmFtIHtWZWN0b3IyfSB2MlxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gYVxuICAgICAgICAgKi9cbiAgICAgICAgc2NhbGVBbmRBZGQ6IGZ1bmN0aW9uIChvdXQsIHYxLCB2MiwgYSkge1xuICAgICAgICAgICAgb3V0WzBdID0gdjFbMF0gKyB2MlswXSAqIGE7XG4gICAgICAgICAgICBvdXRbMV0gPSB2MVsxXSArIHYyWzFdICogYTtcbiAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWQkemHj+ebuOWHj1xuICAgICAgICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IG91dFxuICAgICAgICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IHYxXG4gICAgICAgICAqIEBwYXJhbSB7VmVjdG9yMn0gdjJcbiAgICAgICAgICovXG4gICAgICAgIHN1YjogZnVuY3Rpb24gKG91dCwgdjEsIHYyKSB7XG4gICAgICAgICAgICBvdXRbMF0gPSB2MVswXSAtIHYyWzBdO1xuICAgICAgICAgICAgb3V0WzFdID0gdjFbMV0gLSB2MlsxXTtcbiAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWQkemHj+mVv+W6plxuICAgICAgICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IHZcbiAgICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgbGVuOiBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguc3FydCh0aGlzLmxlblNxdWFyZSh2KSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWQkemHj+mVv+W6puW5s+aWuVxuICAgICAgICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IHZcbiAgICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgbGVuU3F1YXJlOiBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgcmV0dXJuIHZbMF0gKiB2WzBdICsgdlsxXSAqIHZbMV07XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWQkemHj+S5mOazlVxuICAgICAgICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IG91dFxuICAgICAgICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IHYxXG4gICAgICAgICAqIEBwYXJhbSB7VmVjdG9yMn0gdjJcbiAgICAgICAgICovXG4gICAgICAgIG11bDogZnVuY3Rpb24gKG91dCwgdjEsIHYyKSB7XG4gICAgICAgICAgICBvdXRbMF0gPSB2MVswXSAqIHYyWzBdO1xuICAgICAgICAgICAgb3V0WzFdID0gdjFbMV0gKiB2MlsxXTtcbiAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWQkemHj+mZpOazlVxuICAgICAgICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IG91dFxuICAgICAgICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IHYxXG4gICAgICAgICAqIEBwYXJhbSB7VmVjdG9yMn0gdjJcbiAgICAgICAgICovXG4gICAgICAgIGRpdjogZnVuY3Rpb24gKG91dCwgdjEsIHYyKSB7XG4gICAgICAgICAgICBvdXRbMF0gPSB2MVswXSAvIHYyWzBdO1xuICAgICAgICAgICAgb3V0WzFdID0gdjFbMV0gLyB2MlsxXTtcbiAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWQkemHj+eCueS5mFxuICAgICAgICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IHYxXG4gICAgICAgICAqIEBwYXJhbSB7VmVjdG9yMn0gdjJcbiAgICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgZG90OiBmdW5jdGlvbiAodjEsIHYyKSB7XG4gICAgICAgICAgICByZXR1cm4gdjFbMF0gKiB2MlswXSArIHYxWzFdICogdjJbMV07XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWQkemHj+e8qeaUvlxuICAgICAgICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IG91dFxuICAgICAgICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IHZcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHNcbiAgICAgICAgICovXG4gICAgICAgIHNjYWxlOiBmdW5jdGlvbiAob3V0LCB2LCBzKSB7XG4gICAgICAgICAgICBvdXRbMF0gPSB2WzBdICogcztcbiAgICAgICAgICAgIG91dFsxXSA9IHZbMV0gKiBzO1xuICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5ZCR6YeP5b2S5LiA5YyWXG4gICAgICAgICAqIEBwYXJhbSB7VmVjdG9yMn0gb3V0XG4gICAgICAgICAqIEBwYXJhbSB7VmVjdG9yMn0gdlxuICAgICAgICAgKi9cbiAgICAgICAgbm9ybWFsaXplOiBmdW5jdGlvbiAob3V0LCB2KSB7XG4gICAgICAgICAgICB2YXIgZCA9IHZlY3Rvci5sZW4odik7XG4gICAgICAgICAgICBpZiAoZCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIG91dFswXSA9IDA7XG4gICAgICAgICAgICAgICAgb3V0WzFdID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG91dFswXSA9IHZbMF0gLyBkO1xuICAgICAgICAgICAgICAgIG91dFsxXSA9IHZbMV0gLyBkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog6K6h566X5ZCR6YeP6Ze06Led56a7XG4gICAgICAgICAqIEBwYXJhbSB7VmVjdG9yMn0gdjFcbiAgICAgICAgICogQHBhcmFtIHtWZWN0b3IyfSB2MlxuICAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBkaXN0YW5jZTogZnVuY3Rpb24gKHYxLCB2Mikge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguc3FydChcbiAgICAgICAgICAgICAgICAodjFbMF0gLSB2MlswXSkgKiAodjFbMF0gLSB2MlswXSlcbiAgICAgICAgICAgICAgICArICh2MVsxXSAtIHYyWzFdKSAqICh2MVsxXSAtIHYyWzFdKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5ZCR6YeP6Led56a75bmz5pa5XG4gICAgICAgICAqIEBwYXJhbSB7VmVjdG9yMn0gdjFcbiAgICAgICAgICogQHBhcmFtIHtWZWN0b3IyfSB2MlxuICAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBkaXN0YW5jZVNxdWFyZTogZnVuY3Rpb24gKHYxLCB2Mikge1xuICAgICAgICAgICAgcmV0dXJuICh2MVswXSAtIHYyWzBdKSAqICh2MVswXSAtIHYyWzBdKVxuICAgICAgICAgICAgICAgICsgKHYxWzFdIC0gdjJbMV0pICogKHYxWzFdIC0gdjJbMV0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmsYLotJ/lkJHph49cbiAgICAgICAgICogQHBhcmFtIHtWZWN0b3IyfSBvdXRcbiAgICAgICAgICogQHBhcmFtIHtWZWN0b3IyfSB2XG4gICAgICAgICAqL1xuICAgICAgICBuZWdhdGU6IGZ1bmN0aW9uIChvdXQsIHYpIHtcbiAgICAgICAgICAgIG91dFswXSA9IC12WzBdO1xuICAgICAgICAgICAgb3V0WzFdID0gLXZbMV07XG4gICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmj5LlgLzkuKTkuKrngrlcbiAgICAgICAgICogQHBhcmFtIHtWZWN0b3IyfSBvdXRcbiAgICAgICAgICogQHBhcmFtIHtWZWN0b3IyfSB2MVxuICAgICAgICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IHYyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0XG4gICAgICAgICAqL1xuICAgICAgICBsZXJwOiBmdW5jdGlvbiAob3V0LCB2MSwgdjIsIHQpIHtcbiAgICAgICAgICAgIG91dFswXSA9IHYxWzBdICsgdCAqICh2MlswXSAtIHYxWzBdKTtcbiAgICAgICAgICAgIG91dFsxXSA9IHYxWzFdICsgdCAqICh2MlsxXSAtIHYxWzFdKTtcbiAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOefqemYteW3puS5mOWQkemHj1xuICAgICAgICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IG91dFxuICAgICAgICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IHZcbiAgICAgICAgICogQHBhcmFtIHtWZWN0b3IyfSBtXG4gICAgICAgICAqL1xuICAgICAgICBhcHBseVRyYW5zZm9ybTogZnVuY3Rpb24gKG91dCwgdiwgbSkge1xuICAgICAgICAgICAgdmFyIHggPSB2WzBdO1xuICAgICAgICAgICAgdmFyIHkgPSB2WzFdO1xuICAgICAgICAgICAgb3V0WzBdID0gbVswXSAqIHggKyBtWzJdICogeSArIG1bNF07XG4gICAgICAgICAgICBvdXRbMV0gPSBtWzFdICogeCArIG1bM10gKiB5ICsgbVs1XTtcbiAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmsYLkuKTkuKrlkJHph4/mnIDlsI/lgLxcbiAgICAgICAgICogQHBhcmFtICB7VmVjdG9yMn0gb3V0XG4gICAgICAgICAqIEBwYXJhbSAge1ZlY3RvcjJ9IHYxXG4gICAgICAgICAqIEBwYXJhbSAge1ZlY3RvcjJ9IHYyXG4gICAgICAgICAqL1xuICAgICAgICBtaW46IGZ1bmN0aW9uIChvdXQsIHYxLCB2Mikge1xuICAgICAgICAgICAgb3V0WzBdID0gTWF0aC5taW4odjFbMF0sIHYyWzBdKTtcbiAgICAgICAgICAgIG91dFsxXSA9IE1hdGgubWluKHYxWzFdLCB2MlsxXSk7XG4gICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICog5rGC5Lik5Liq5ZCR6YeP5pyA5aSn5YC8XG4gICAgICAgICAqIEBwYXJhbSAge1ZlY3RvcjJ9IG91dFxuICAgICAgICAgKiBAcGFyYW0gIHtWZWN0b3IyfSB2MVxuICAgICAgICAgKiBAcGFyYW0gIHtWZWN0b3IyfSB2MlxuICAgICAgICAgKi9cbiAgICAgICAgbWF4OiBmdW5jdGlvbiAob3V0LCB2MSwgdjIpIHtcbiAgICAgICAgICAgIG91dFswXSA9IE1hdGgubWF4KHYxWzBdLCB2MlswXSk7XG4gICAgICAgICAgICBvdXRbMV0gPSBNYXRoLm1heCh2MVsxXSwgdjJbMV0pO1xuICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2ZWN0b3IubGVuZ3RoID0gdmVjdG9yLmxlbjtcbiAgICB2ZWN0b3IubGVuZ3RoU3F1YXJlID0gdmVjdG9yLmxlblNxdWFyZTtcbiAgICB2ZWN0b3IuZGlzdCA9IHZlY3Rvci5kaXN0YW5jZTtcbiAgICB2ZWN0b3IuZGlzdFNxdWFyZSA9IHZlY3Rvci5kaXN0YW5jZVNxdWFyZTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gdmVjdG9yO1xuXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi96cmVuZGVyL2xpYi9jb3JlL3ZlY3Rvci5qc1xuICoqIG1vZHVsZSBpZCA9IDE0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG4vKipcbiAqIEBtb2R1bGUgenJlbmRlci9taXhpbi9BbmltYXRhYmxlXG4gKi9cblxuXG4gICAgdmFyIEFuaW1hdG9yID0gcmVxdWlyZSgnLi4vYW5pbWF0aW9uL0FuaW1hdG9yJyk7XG4gICAgdmFyIHV0aWwgPSByZXF1aXJlKCcuLi9jb3JlL3V0aWwnKTtcbiAgICB2YXIgaXNTdHJpbmcgPSB1dGlsLmlzU3RyaW5nO1xuICAgIHZhciBpc0Z1bmN0aW9uID0gdXRpbC5pc0Z1bmN0aW9uO1xuICAgIHZhciBpc09iamVjdCA9IHV0aWwuaXNPYmplY3Q7XG4gICAgdmFyIGxvZyA9IHJlcXVpcmUoJy4uL2NvcmUvbG9nJyk7XG5cbiAgICAvKipcbiAgICAgKiBAYWxpYXMgbW9kdWU6enJlbmRlci9taXhpbi9BbmltYXRhYmxlXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICovXG4gICAgdmFyIEFuaW1hdGFibGUgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtBcnJheS48bW9kdWxlOnpyZW5kZXIvYW5pbWF0aW9uL0FuaW1hdG9yPn1cbiAgICAgICAgICogQHJlYWRPbmx5XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmFuaW1hdG9ycyA9IFtdO1xuICAgIH07XG5cbiAgICBBbmltYXRhYmxlLnByb3RvdHlwZSA9IHtcblxuICAgICAgICBjb25zdHJ1Y3RvcjogQW5pbWF0YWJsZSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5Yqo55S7XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIOmcgOimgea3u+WKoOWKqOeUu+eahOWxnuaAp+iOt+WPlui3r+W+hO+8jOWPr+S7pemAmui/h2EuYi5j5p2l6I635Y+W5rex5bGC55qE5bGe5oCnXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2xvb3BdIOWKqOeUu+aYr+WQpuW+queOr1xuICAgICAgICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9hbmltYXRpb24vQW5pbWF0b3J9XG4gICAgICAgICAqIEBleGFtcGxlOlxuICAgICAgICAgKiAgICAgZWwuYW5pbWF0ZSgnc3R5bGUnLCBmYWxzZSlcbiAgICAgICAgICogICAgICAgICAud2hlbigxMDAwLCB7eDogMTB9IClcbiAgICAgICAgICogICAgICAgICAuZG9uZShmdW5jdGlvbigpeyAvLyBBbmltYXRpb24gZG9uZSB9KVxuICAgICAgICAgKiAgICAgICAgIC5zdGFydCgpXG4gICAgICAgICAqL1xuICAgICAgICBhbmltYXRlOiBmdW5jdGlvbiAocGF0aCwgbG9vcCkge1xuICAgICAgICAgICAgdmFyIHRhcmdldDtcbiAgICAgICAgICAgIHZhciBhbmltYXRpbmdTaGFwZSA9IGZhbHNlO1xuICAgICAgICAgICAgdmFyIGVsID0gdGhpcztcbiAgICAgICAgICAgIHZhciB6ciA9IHRoaXMuX196cjtcbiAgICAgICAgICAgIGlmIChwYXRoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhdGhTcGxpdHRlZCA9IHBhdGguc3BsaXQoJy4nKTtcbiAgICAgICAgICAgICAgICB2YXIgcHJvcCA9IGVsO1xuICAgICAgICAgICAgICAgIC8vIElmIGFuaW1hdGluZyBzaGFwZVxuICAgICAgICAgICAgICAgIGFuaW1hdGluZ1NoYXBlID0gcGF0aFNwbGl0dGVkWzBdID09PSAnc2hhcGUnO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gcGF0aFNwbGl0dGVkLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXByb3ApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHByb3AgPSBwcm9wW3BhdGhTcGxpdHRlZFtpXV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwcm9wKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldCA9IHByb3A7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0ID0gZWw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghdGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgbG9nKFxuICAgICAgICAgICAgICAgICAgICAnUHJvcGVydHkgXCInXG4gICAgICAgICAgICAgICAgICAgICsgcGF0aFxuICAgICAgICAgICAgICAgICAgICArICdcIiBpcyBub3QgZXhpc3RlZCBpbiBlbGVtZW50ICdcbiAgICAgICAgICAgICAgICAgICAgKyBlbC5pZFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgYW5pbWF0b3JzID0gZWwuYW5pbWF0b3JzO1xuXG4gICAgICAgICAgICB2YXIgYW5pbWF0b3IgPSBuZXcgQW5pbWF0b3IodGFyZ2V0LCBsb29wKTtcblxuICAgICAgICAgICAgYW5pbWF0b3IuZHVyaW5nKGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICBlbC5kaXJ0eShhbmltYXRpbmdTaGFwZSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmRvbmUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIC8vIEZJWE1FIEFuaW1hdG9yIHdpbGwgbm90IGJlIHJlbW92ZWQgaWYgdXNlIGBBbmltYXRvciNzdG9wYCB0byBzdG9wIGFuaW1hdGlvblxuICAgICAgICAgICAgICAgIGFuaW1hdG9ycy5zcGxpY2UodXRpbC5pbmRleE9mKGFuaW1hdG9ycywgYW5pbWF0b3IpLCAxKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBhbmltYXRvcnMucHVzaChhbmltYXRvcik7XG5cbiAgICAgICAgICAgIC8vIElmIGFuaW1hdGUgYWZ0ZXIgYWRkZWQgdG8gdGhlIHpyZW5kZXJcbiAgICAgICAgICAgIGlmICh6cikge1xuICAgICAgICAgICAgICAgIHpyLmFuaW1hdGlvbi5hZGRBbmltYXRvcihhbmltYXRvcik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBhbmltYXRvcjtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5YGc5q2i5Yqo55S7XG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZm9yd2FyZFRvTGFzdCBJZiBtb3ZlIHRvIGxhc3QgZnJhbWUgYmVmb3JlIHN0b3BcbiAgICAgICAgICovXG4gICAgICAgIHN0b3BBbmltYXRpb246IGZ1bmN0aW9uIChmb3J3YXJkVG9MYXN0KSB7XG4gICAgICAgICAgICB2YXIgYW5pbWF0b3JzID0gdGhpcy5hbmltYXRvcnM7XG4gICAgICAgICAgICB2YXIgbGVuID0gYW5pbWF0b3JzLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBhbmltYXRvcnNbaV0uc3RvcChmb3J3YXJkVG9MYXN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFuaW1hdG9ycy5sZW5ndGggPSAwO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHRhcmdldFxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW3RpbWU9NTAwXSBUaW1lIGluIG1zXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbZWFzaW5nPSdsaW5lYXInXVxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2RlbGF5PTBdXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja11cbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogIC8vIEFuaW1hdGUgcG9zaXRpb25cbiAgICAgICAgICogIGVsLmFuaW1hdGVUbyh7XG4gICAgICAgICAqICAgICAgcG9zaXRpb246IFsxMCwgMTBdXG4gICAgICAgICAqICB9LCBmdW5jdGlvbiAoKSB7IC8vIGRvbmUgfSlcbiAgICAgICAgICpcbiAgICAgICAgICogIC8vIEFuaW1hdGUgc2hhcGUsIHN0eWxlIGFuZCBwb3NpdGlvbiBpbiAxMDBtcywgZGVsYXllZCAxMDBtcywgd2l0aCBjdWJpY091dCBlYXNpbmdcbiAgICAgICAgICogIGVsLmFuaW1hdGVUbyh7XG4gICAgICAgICAqICAgICAgc2hhcGU6IHtcbiAgICAgICAgICogICAgICAgICAgd2lkdGg6IDUwMFxuICAgICAgICAgKiAgICAgIH0sXG4gICAgICAgICAqICAgICAgc3R5bGU6IHtcbiAgICAgICAgICogICAgICAgICAgZmlsbDogJ3JlZCdcbiAgICAgICAgICogICAgICB9XG4gICAgICAgICAqICAgICAgcG9zaXRpb246IFsxMCwgMTBdXG4gICAgICAgICAqICB9LCAxMDAsIDEwMCwgJ2N1YmljT3V0JywgZnVuY3Rpb24gKCkgeyAvLyBkb25lIH0pXG4gICAgICAgICAqL1xuICAgICAgICAgLy8gVE9ETyBSZXR1cm4gYW5pbWF0aW9uIGtleVxuICAgICAgICBhbmltYXRlVG86IGZ1bmN0aW9uICh0YXJnZXQsIHRpbWUsIGRlbGF5LCBlYXNpbmcsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAvLyBhbmltYXRlVG8odGFyZ2V0LCB0aW1lLCBlYXNpbmcsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIGlmIChpc1N0cmluZyhkZWxheSkpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayA9IGVhc2luZztcbiAgICAgICAgICAgICAgICBlYXNpbmcgPSBkZWxheTtcbiAgICAgICAgICAgICAgICBkZWxheSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBhbmltYXRlVG8odGFyZ2V0LCB0aW1lLCBkZWxheSwgY2FsbGJhY2spO1xuICAgICAgICAgICAgZWxzZSBpZiAoaXNGdW5jdGlvbihlYXNpbmcpKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sgPSBlYXNpbmc7XG4gICAgICAgICAgICAgICAgZWFzaW5nID0gJ2xpbmVhcic7XG4gICAgICAgICAgICAgICAgZGVsYXkgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gYW5pbWF0ZVRvKHRhcmdldCwgdGltZSwgY2FsbGJhY2spO1xuICAgICAgICAgICAgZWxzZSBpZiAoaXNGdW5jdGlvbihkZWxheSkpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayA9IGRlbGF5O1xuICAgICAgICAgICAgICAgIGRlbGF5ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGFuaW1hdGVUbyh0YXJnZXQsIGNhbGxiYWNrKVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNGdW5jdGlvbih0aW1lKSkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gdGltZTtcbiAgICAgICAgICAgICAgICB0aW1lID0gNTAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gYW5pbWF0ZVRvKHRhcmdldClcbiAgICAgICAgICAgIGVsc2UgaWYgKCF0aW1lKSB7XG4gICAgICAgICAgICAgICAgdGltZSA9IDUwMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFN0b3AgYWxsIHByZXZpb3VzIGFuaW1hdGlvbnNcbiAgICAgICAgICAgIHRoaXMuc3RvcEFuaW1hdGlvbigpO1xuICAgICAgICAgICAgdGhpcy5fYW5pbWF0ZVRvU2hhbGxvdygnJywgdGhpcywgdGFyZ2V0LCB0aW1lLCBkZWxheSwgZWFzaW5nLCBjYWxsYmFjayk7XG5cbiAgICAgICAgICAgIC8vIEFuaW1hdG9ycyBtYXkgYmUgcmVtb3ZlZCBpbW1lZGlhdGVseSBhZnRlciBzdGFydFxuICAgICAgICAgICAgLy8gaWYgdGhlcmUgaXMgbm90aGluZyB0byBhbmltYXRlXG4gICAgICAgICAgICB2YXIgYW5pbWF0b3JzID0gdGhpcy5hbmltYXRvcnMuc2xpY2UoKTtcbiAgICAgICAgICAgIHZhciBjb3VudCA9IGFuaW1hdG9ycy5sZW5ndGg7XG4gICAgICAgICAgICBmdW5jdGlvbiBkb25lKCkge1xuICAgICAgICAgICAgICAgIGNvdW50LS07XG4gICAgICAgICAgICAgICAgaWYgKCFjb3VudCkge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjaygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gTm8gYW5pbWF0b3JzLiBUaGlzIHNob3VsZCBiZSBjaGVja2VkIGJlZm9yZSBhbmltYXRvcnNbaV0uc3RhcnQoKSxcbiAgICAgICAgICAgIC8vIGJlY2F1c2UgJ2RvbmUnIG1heSBiZSBleGVjdXRlZCBpbW1lZGlhdGVseSBpZiBubyBuZWVkIHRvIGFuaW1hdGUuXG4gICAgICAgICAgICBpZiAoIWNvdW50KSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFN0YXJ0IGFmdGVyIGFsbCBhbmltYXRvcnMgY3JlYXRlZFxuICAgICAgICAgICAgLy8gSW5jYXNlIGFueSBhbmltYXRvciBpcyBkb25lIGltbWVkaWF0ZWx5IHdoZW4gYWxsIGFuaW1hdGlvbiBwcm9wZXJ0aWVzIGFyZSBub3QgY2hhbmdlZFxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbmltYXRvcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBhbmltYXRvcnNbaV1cbiAgICAgICAgICAgICAgICAgICAgLmRvbmUoZG9uZSlcbiAgICAgICAgICAgICAgICAgICAgLnN0YXJ0KGVhc2luZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoPScnXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2U9dGhpc1xuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0XG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbdGltZT01MDBdXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZGVsYXk9MF1cbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogIC8vIEFuaW1hdGUgcG9zaXRpb25cbiAgICAgICAgICogIGVsLl9hbmltYXRlVG9TaGFsbG93KHtcbiAgICAgICAgICogICAgICBwb3NpdGlvbjogWzEwLCAxMF1cbiAgICAgICAgICogIH0pXG4gICAgICAgICAqXG4gICAgICAgICAqICAvLyBBbmltYXRlIHNoYXBlLCBzdHlsZSBhbmQgcG9zaXRpb24gaW4gMTAwbXMsIGRlbGF5ZWQgMTAwbXNcbiAgICAgICAgICogIGVsLl9hbmltYXRlVG9TaGFsbG93KHtcbiAgICAgICAgICogICAgICBzaGFwZToge1xuICAgICAgICAgKiAgICAgICAgICB3aWR0aDogNTAwXG4gICAgICAgICAqICAgICAgfSxcbiAgICAgICAgICogICAgICBzdHlsZToge1xuICAgICAgICAgKiAgICAgICAgICBmaWxsOiAncmVkJ1xuICAgICAgICAgKiAgICAgIH1cbiAgICAgICAgICogICAgICBwb3NpdGlvbjogWzEwLCAxMF1cbiAgICAgICAgICogIH0sIDEwMCwgMTAwKVxuICAgICAgICAgKi9cbiAgICAgICAgX2FuaW1hdGVUb1NoYWxsb3c6IGZ1bmN0aW9uIChwYXRoLCBzb3VyY2UsIHRhcmdldCwgdGltZSwgZGVsYXkpIHtcbiAgICAgICAgICAgIHZhciBvYmpTaGFsbG93ID0ge307XG4gICAgICAgICAgICB2YXIgcHJvcGVydHlDb3VudCA9IDA7XG4gICAgICAgICAgICBmb3IgKHZhciBuYW1lIGluIHRhcmdldCkge1xuICAgICAgICAgICAgICAgIGlmIChzb3VyY2VbbmFtZV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNPYmplY3QodGFyZ2V0W25hbWVdKSAmJiAhdXRpbC5pc0FycmF5TGlrZSh0YXJnZXRbbmFtZV0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9hbmltYXRlVG9TaGFsbG93KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdGggPyBwYXRoICsgJy4nICsgbmFtZSA6IG5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlW25hbWVdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldFtuYW1lXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGF5XG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgb2JqU2hhbGxvd1tuYW1lXSA9IHRhcmdldFtuYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnR5Q291bnQrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0YXJnZXRbbmFtZV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBBdHRyIGRpcmVjdGx5IGlmIG5vdCBoYXMgcHJvcGVydHlcbiAgICAgICAgICAgICAgICAgICAgLy8gRklYTUUsIGlmIHNvbWUgcHJvcGVydHkgbm90IG5lZWRlZCBmb3IgZWxlbWVudCA/XG4gICAgICAgICAgICAgICAgICAgIGlmICghcGF0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hdHRyKG5hbWUsIHRhcmdldFtuYW1lXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7ICAvLyBTaGFwZSBvciBzdHlsZVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByb3BzID0ge307XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wc1twYXRoXSA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcHNbcGF0aF1bbmFtZV0gPSB0YXJnZXRbbmFtZV07XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmF0dHIocHJvcHMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocHJvcGVydHlDb3VudCA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFuaW1hdGUocGF0aCwgZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgIC53aGVuKHRpbWUgPT0gbnVsbCA/IDUwMCA6IHRpbWUsIG9ialNoYWxsb3cpXG4gICAgICAgICAgICAgICAgICAgIC5kZWxheShkZWxheSB8fCAwKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBBbmltYXRhYmxlO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34venJlbmRlci9saWIvbWl4aW4vQW5pbWF0YWJsZS5qc1xuICoqIG1vZHVsZSBpZCA9IDE1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIEBtb2R1bGUgZWNoYXJ0cy9hbmltYXRpb24vQW5pbWF0b3JcbiAqL1xuXG5cbiAgICB2YXIgQ2xpcCA9IHJlcXVpcmUoJy4vQ2xpcCcpO1xuICAgIHZhciBjb2xvciA9IHJlcXVpcmUoJy4uL3Rvb2wvY29sb3InKTtcbiAgICB2YXIgdXRpbCA9IHJlcXVpcmUoJy4uL2NvcmUvdXRpbCcpO1xuICAgIHZhciBpc0FycmF5TGlrZSA9IHV0aWwuaXNBcnJheUxpa2U7XG5cbiAgICB2YXIgYXJyYXlTbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcblxuICAgIGZ1bmN0aW9uIGRlZmF1bHRHZXR0ZXIodGFyZ2V0LCBrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRhcmdldFtrZXldO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRlZmF1bHRTZXR0ZXIodGFyZ2V0LCBrZXksIHZhbHVlKSB7XG4gICAgICAgIHRhcmdldFtrZXldID0gdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBwMFxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcDFcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHBlcmNlbnRcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICovXG4gICAgZnVuY3Rpb24gaW50ZXJwb2xhdGVOdW1iZXIocDAsIHAxLCBwZXJjZW50KSB7XG4gICAgICAgIHJldHVybiAocDEgLSBwMCkgKiBwZXJjZW50ICsgcDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtICB7c3RyaW5nfSBwMFxuICAgICAqIEBwYXJhbSAge3N0cmluZ30gcDFcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHBlcmNlbnRcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAgICovXG4gICAgZnVuY3Rpb24gaW50ZXJwb2xhdGVTdHJpbmcocDAsIHAxLCBwZXJjZW50KSB7XG4gICAgICAgIHJldHVybiBwZXJjZW50ID4gMC41ID8gcDEgOiBwMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gcDBcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gcDFcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHBlcmNlbnRcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gb3V0XG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBhcnJEaW1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbnRlcnBvbGF0ZUFycmF5KHAwLCBwMSwgcGVyY2VudCwgb3V0LCBhcnJEaW0pIHtcbiAgICAgICAgdmFyIGxlbiA9IHAwLmxlbmd0aDtcbiAgICAgICAgaWYgKGFyckRpbSA9PSAxKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgb3V0W2ldID0gaW50ZXJwb2xhdGVOdW1iZXIocDBbaV0sIHAxW2ldLCBwZXJjZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBsZW4yID0gcDBbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbGVuMjsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dFtpXVtqXSA9IGludGVycG9sYXRlTnVtYmVyKFxuICAgICAgICAgICAgICAgICAgICAgICAgcDBbaV1bal0sIHAxW2ldW2pdLCBwZXJjZW50XG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gYXJyMCBpcyBzb3VyY2UgYXJyYXksIGFycjEgaXMgdGFyZ2V0IGFycmF5LlxuICAgIC8vIERvIHNvbWUgcHJlcHJvY2VzcyB0byBhdm9pZCBlcnJvciBoYXBwZW5lZCB3aGVuIGludGVycG9sYXRpbmcgZnJvbSBhcnIwIHRvIGFycjFcbiAgICBmdW5jdGlvbiBmaWxsQXJyKGFycjAsIGFycjEsIGFyckRpbSkge1xuICAgICAgICB2YXIgYXJyMExlbiA9IGFycjAubGVuZ3RoO1xuICAgICAgICB2YXIgYXJyMUxlbiA9IGFycjEubGVuZ3RoO1xuICAgICAgICBpZiAoYXJyMExlbiAhPT0gYXJyMUxlbikge1xuICAgICAgICAgICAgLy8gRklYTUUgTm90IHdvcmsgZm9yIFR5cGVkQXJyYXlcbiAgICAgICAgICAgIHZhciBpc1ByZXZpb3VzTGFyZ2VyID0gYXJyMExlbiA+IGFycjFMZW47XG4gICAgICAgICAgICBpZiAoaXNQcmV2aW91c0xhcmdlcikge1xuICAgICAgICAgICAgICAgIC8vIEN1dCB0aGUgcHJldmlvdXNcbiAgICAgICAgICAgICAgICBhcnIwLmxlbmd0aCA9IGFycjFMZW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBGaWxsIHRoZSBwcmV2aW91c1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSBhcnIwTGVuOyBpIDwgYXJyMUxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGFycjAucHVzaChcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyckRpbSA9PT0gMSA/IGFycjFbaV0gOiBhcnJheVNsaWNlLmNhbGwoYXJyMVtpXSlcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSGFuZGxpbmcgTmFOIHZhbHVlXG4gICAgICAgIHZhciBsZW4yID0gYXJyMFswXSAmJiBhcnIwWzBdLmxlbmd0aDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIwLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoYXJyRGltID09PSAxKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzTmFOKGFycjBbaV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGFycjBbaV0gPSBhcnIxW2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbGVuMjsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc05hTihhcnIwW2ldW2pdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJyMFtpXVtqXSA9IGFycjFbaV1bal07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gYXJyMFxuICAgICAqIEBwYXJhbSAge0FycmF5fSBhcnIxXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBhcnJEaW1cbiAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzQXJyYXlTYW1lKGFycjAsIGFycjEsIGFyckRpbSkge1xuICAgICAgICBpZiAoYXJyMCA9PT0gYXJyMSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxlbiA9IGFycjAubGVuZ3RoO1xuICAgICAgICBpZiAobGVuICE9PSBhcnIxLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhcnJEaW0gPT09IDEpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoYXJyMFtpXSAhPT0gYXJyMVtpXSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGxlbjIgPSBhcnIwWzBdLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGxlbjI7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXJyMFtpXVtqXSAhPT0gYXJyMVtpXVtqXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhdG11bGwgUm9tIGludGVycG9sYXRlIGFycmF5XG4gICAgICogQHBhcmFtICB7QXJyYXl9IHAwXG4gICAgICogQHBhcmFtICB7QXJyYXl9IHAxXG4gICAgICogQHBhcmFtICB7QXJyYXl9IHAyXG4gICAgICogQHBhcmFtICB7QXJyYXl9IHAzXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSB0XG4gICAgICogQHBhcmFtICB7bnVtYmVyfSB0MlxuICAgICAqIEBwYXJhbSAge251bWJlcn0gdDNcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gb3V0XG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBhcnJEaW1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjYXRtdWxsUm9tSW50ZXJwb2xhdGVBcnJheShcbiAgICAgICAgcDAsIHAxLCBwMiwgcDMsIHQsIHQyLCB0Mywgb3V0LCBhcnJEaW1cbiAgICApIHtcbiAgICAgICAgdmFyIGxlbiA9IHAwLmxlbmd0aDtcbiAgICAgICAgaWYgKGFyckRpbSA9PSAxKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgb3V0W2ldID0gY2F0bXVsbFJvbUludGVycG9sYXRlKFxuICAgICAgICAgICAgICAgICAgICBwMFtpXSwgcDFbaV0sIHAyW2ldLCBwM1tpXSwgdCwgdDIsIHQzXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBsZW4yID0gcDBbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbGVuMjsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dFtpXVtqXSA9IGNhdG11bGxSb21JbnRlcnBvbGF0ZShcbiAgICAgICAgICAgICAgICAgICAgICAgIHAwW2ldW2pdLCBwMVtpXVtqXSwgcDJbaV1bal0sIHAzW2ldW2pdLFxuICAgICAgICAgICAgICAgICAgICAgICAgdCwgdDIsIHQzXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2F0bXVsbCBSb20gaW50ZXJwb2xhdGUgbnVtYmVyXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBwMFxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcDFcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHAyXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBwM1xuICAgICAqIEBwYXJhbSAge251bWJlcn0gdFxuICAgICAqIEBwYXJhbSAge251bWJlcn0gdDJcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHQzXG4gICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNhdG11bGxSb21JbnRlcnBvbGF0ZShwMCwgcDEsIHAyLCBwMywgdCwgdDIsIHQzKSB7XG4gICAgICAgIHZhciB2MCA9IChwMiAtIHAwKSAqIDAuNTtcbiAgICAgICAgdmFyIHYxID0gKHAzIC0gcDEpICogMC41O1xuICAgICAgICByZXR1cm4gKDIgKiAocDEgLSBwMikgKyB2MCArIHYxKSAqIHQzXG4gICAgICAgICAgICAgICAgKyAoLTMgKiAocDEgLSBwMikgLSAyICogdjAgLSB2MSkgKiB0MlxuICAgICAgICAgICAgICAgICsgdjAgKiB0ICsgcDE7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xvbmVWYWx1ZSh2YWx1ZSkge1xuICAgICAgICBpZiAoaXNBcnJheUxpa2UodmFsdWUpKSB7XG4gICAgICAgICAgICB2YXIgbGVuID0gdmFsdWUubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGlzQXJyYXlMaWtlKHZhbHVlWzBdKSkge1xuICAgICAgICAgICAgICAgIHZhciByZXQgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldC5wdXNoKGFycmF5U2xpY2UuY2FsbCh2YWx1ZVtpXSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gYXJyYXlTbGljZS5jYWxsKHZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZ2JhMlN0cmluZyhyZ2JhKSB7XG4gICAgICAgIHJnYmFbMF0gPSBNYXRoLmZsb29yKHJnYmFbMF0pO1xuICAgICAgICByZ2JhWzFdID0gTWF0aC5mbG9vcihyZ2JhWzFdKTtcbiAgICAgICAgcmdiYVsyXSA9IE1hdGguZmxvb3IocmdiYVsyXSk7XG5cbiAgICAgICAgcmV0dXJuICdyZ2JhKCcgKyByZ2JhLmpvaW4oJywnKSArICcpJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVUcmFja0NsaXAgKGFuaW1hdG9yLCBlYXNpbmcsIG9uZVRyYWNrRG9uZSwga2V5ZnJhbWVzLCBwcm9wTmFtZSkge1xuICAgICAgICB2YXIgZ2V0dGVyID0gYW5pbWF0b3IuX2dldHRlcjtcbiAgICAgICAgdmFyIHNldHRlciA9IGFuaW1hdG9yLl9zZXR0ZXI7XG4gICAgICAgIHZhciB1c2VTcGxpbmUgPSBlYXNpbmcgPT09ICdzcGxpbmUnO1xuXG4gICAgICAgIHZhciB0cmFja0xlbiA9IGtleWZyYW1lcy5sZW5ndGg7XG4gICAgICAgIGlmICghdHJhY2tMZW4pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBHdWVzcyBkYXRhIHR5cGVcbiAgICAgICAgdmFyIGZpcnN0VmFsID0ga2V5ZnJhbWVzWzBdLnZhbHVlO1xuICAgICAgICB2YXIgaXNWYWx1ZUFycmF5ID0gaXNBcnJheUxpa2UoZmlyc3RWYWwpO1xuICAgICAgICB2YXIgaXNWYWx1ZUNvbG9yID0gZmFsc2U7XG4gICAgICAgIHZhciBpc1ZhbHVlU3RyaW5nID0gZmFsc2U7XG5cbiAgICAgICAgLy8gRm9yIHZlcnRpY2VzIG1vcnBoaW5nXG4gICAgICAgIHZhciBhcnJEaW0gPSAoXG4gICAgICAgICAgICAgICAgaXNWYWx1ZUFycmF5XG4gICAgICAgICAgICAgICAgJiYgaXNBcnJheUxpa2UoZmlyc3RWYWxbMF0pXG4gICAgICAgICAgICApXG4gICAgICAgICAgICA/IDIgOiAxO1xuICAgICAgICB2YXIgdHJhY2tNYXhUaW1lO1xuICAgICAgICAvLyBTb3J0IGtleWZyYW1lIGFzIGFzY2VuZGluZ1xuICAgICAgICBrZXlmcmFtZXMuc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gYS50aW1lIC0gYi50aW1lO1xuICAgICAgICB9KTtcblxuICAgICAgICB0cmFja01heFRpbWUgPSBrZXlmcmFtZXNbdHJhY2tMZW4gLSAxXS50aW1lO1xuICAgICAgICAvLyBQZXJjZW50cyBvZiBlYWNoIGtleWZyYW1lXG4gICAgICAgIHZhciBrZlBlcmNlbnRzID0gW107XG4gICAgICAgIC8vIFZhbHVlIG9mIGVhY2gga2V5ZnJhbWVcbiAgICAgICAgdmFyIGtmVmFsdWVzID0gW107XG4gICAgICAgIHZhciBwcmV2VmFsdWUgPSBrZXlmcmFtZXNbMF0udmFsdWU7XG4gICAgICAgIHZhciBpc0FsbFZhbHVlRXF1YWwgPSB0cnVlO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyYWNrTGVuOyBpKyspIHtcbiAgICAgICAgICAgIGtmUGVyY2VudHMucHVzaChrZXlmcmFtZXNbaV0udGltZSAvIHRyYWNrTWF4VGltZSk7XG4gICAgICAgICAgICAvLyBBc3N1bWUgdmFsdWUgaXMgYSBjb2xvciB3aGVuIGl0IGlzIGEgc3RyaW5nXG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBrZXlmcmFtZXNbaV0udmFsdWU7XG5cbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHZhbHVlIGlzIGVxdWFsLCBkZWVwIGNoZWNrIGlmIHZhbHVlIGlzIGFycmF5XG4gICAgICAgICAgICBpZiAoISgoaXNWYWx1ZUFycmF5ICYmIGlzQXJyYXlTYW1lKHZhbHVlLCBwcmV2VmFsdWUsIGFyckRpbSkpXG4gICAgICAgICAgICAgICAgfHwgKCFpc1ZhbHVlQXJyYXkgJiYgdmFsdWUgPT09IHByZXZWYWx1ZSkpKSB7XG4gICAgICAgICAgICAgICAgaXNBbGxWYWx1ZUVxdWFsID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcmV2VmFsdWUgPSB2YWx1ZTtcblxuICAgICAgICAgICAgLy8gVHJ5IGNvbnZlcnRpbmcgYSBzdHJpbmcgdG8gYSBjb2xvciBhcnJheVxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHZhciBjb2xvckFycmF5ID0gY29sb3IucGFyc2UodmFsdWUpO1xuICAgICAgICAgICAgICAgIGlmIChjb2xvckFycmF5KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gY29sb3JBcnJheTtcbiAgICAgICAgICAgICAgICAgICAgaXNWYWx1ZUNvbG9yID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlzVmFsdWVTdHJpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGtmVmFsdWVzLnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0FsbFZhbHVlRXF1YWwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsYXN0VmFsdWUgPSBrZlZhbHVlc1t0cmFja0xlbiAtIDFdO1xuICAgICAgICAvLyBQb2x5ZmlsbCBhcnJheSBhbmQgTmFOIHZhbHVlXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHJhY2tMZW4gLSAxOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChpc1ZhbHVlQXJyYXkpIHtcbiAgICAgICAgICAgICAgICBmaWxsQXJyKGtmVmFsdWVzW2ldLCBsYXN0VmFsdWUsIGFyckRpbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNOYU4oa2ZWYWx1ZXNbaV0pICYmICFpc05hTihsYXN0VmFsdWUpICYmICFpc1ZhbHVlU3RyaW5nICYmICFpc1ZhbHVlQ29sb3IpIHtcbiAgICAgICAgICAgICAgICAgICAga2ZWYWx1ZXNbaV0gPSBsYXN0VmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlzVmFsdWVBcnJheSAmJiBmaWxsQXJyKGdldHRlcihhbmltYXRvci5fdGFyZ2V0LCBwcm9wTmFtZSksIGxhc3RWYWx1ZSwgYXJyRGltKTtcblxuICAgICAgICAvLyBDYWNoZSB0aGUga2V5IG9mIGxhc3QgZnJhbWUgdG8gc3BlZWQgdXAgd2hlblxuICAgICAgICAvLyBhbmltYXRpb24gcGxheWJhY2sgaXMgc2VxdWVuY3lcbiAgICAgICAgdmFyIGxhc3RGcmFtZSA9IDA7XG4gICAgICAgIHZhciBsYXN0RnJhbWVQZXJjZW50ID0gMDtcbiAgICAgICAgdmFyIHN0YXJ0O1xuICAgICAgICB2YXIgdztcbiAgICAgICAgdmFyIHAwO1xuICAgICAgICB2YXIgcDE7XG4gICAgICAgIHZhciBwMjtcbiAgICAgICAgdmFyIHAzO1xuXG4gICAgICAgIGlmIChpc1ZhbHVlQ29sb3IpIHtcbiAgICAgICAgICAgIHZhciByZ2JhID0gWzAsIDAsIDAsIDBdO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG9uZnJhbWUgPSBmdW5jdGlvbiAodGFyZ2V0LCBwZXJjZW50KSB7XG4gICAgICAgICAgICAvLyBGaW5kIHRoZSByYW5nZSBrZXlmcmFtZXNcbiAgICAgICAgICAgIC8vIGtmMS0tLS0ta2YyLS0tLS0tLS0tY3VycmVudC0tLS0tLS0ta2YzXG4gICAgICAgICAgICAvLyBmaW5kIGtmMiBhbmQga2YzIGFuZCBkbyBpbnRlcnBvbGF0aW9uXG4gICAgICAgICAgICB2YXIgZnJhbWU7XG4gICAgICAgICAgICAvLyBJbiB0aGUgZWFzaW5nIGZ1bmN0aW9uIGxpa2UgZWxhc3RpY091dCwgcGVyY2VudCBtYXkgbGVzcyB0aGFuIDBcbiAgICAgICAgICAgIGlmIChwZXJjZW50IDwgMCkge1xuICAgICAgICAgICAgICAgIGZyYW1lID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHBlcmNlbnQgPCBsYXN0RnJhbWVQZXJjZW50KSB7XG4gICAgICAgICAgICAgICAgLy8gU3RhcnQgZnJvbSBuZXh0IGtleVxuICAgICAgICAgICAgICAgIC8vIFBFTkRJTkcgc3RhcnQgZnJvbSBsYXN0RnJhbWUgP1xuICAgICAgICAgICAgICAgIHN0YXJ0ID0gTWF0aC5taW4obGFzdEZyYW1lICsgMSwgdHJhY2tMZW4gLSAxKTtcbiAgICAgICAgICAgICAgICBmb3IgKGZyYW1lID0gc3RhcnQ7IGZyYW1lID49IDA7IGZyYW1lLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGtmUGVyY2VudHNbZnJhbWVdIDw9IHBlcmNlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFBFTkRJTkcgcmVhbGx5IG5lZWQgdG8gZG8gdGhpcyA/XG4gICAgICAgICAgICAgICAgZnJhbWUgPSBNYXRoLm1pbihmcmFtZSwgdHJhY2tMZW4gLSAyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAoZnJhbWUgPSBsYXN0RnJhbWU7IGZyYW1lIDwgdHJhY2tMZW47IGZyYW1lKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGtmUGVyY2VudHNbZnJhbWVdID4gcGVyY2VudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZnJhbWUgPSBNYXRoLm1pbihmcmFtZSAtIDEsIHRyYWNrTGVuIC0gMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsYXN0RnJhbWUgPSBmcmFtZTtcbiAgICAgICAgICAgIGxhc3RGcmFtZVBlcmNlbnQgPSBwZXJjZW50O1xuXG4gICAgICAgICAgICB2YXIgcmFuZ2UgPSAoa2ZQZXJjZW50c1tmcmFtZSArIDFdIC0ga2ZQZXJjZW50c1tmcmFtZV0pO1xuICAgICAgICAgICAgaWYgKHJhbmdlID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdyA9IChwZXJjZW50IC0ga2ZQZXJjZW50c1tmcmFtZV0pIC8gcmFuZ2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodXNlU3BsaW5lKSB7XG4gICAgICAgICAgICAgICAgcDEgPSBrZlZhbHVlc1tmcmFtZV07XG4gICAgICAgICAgICAgICAgcDAgPSBrZlZhbHVlc1tmcmFtZSA9PT0gMCA/IGZyYW1lIDogZnJhbWUgLSAxXTtcbiAgICAgICAgICAgICAgICBwMiA9IGtmVmFsdWVzW2ZyYW1lID4gdHJhY2tMZW4gLSAyID8gdHJhY2tMZW4gLSAxIDogZnJhbWUgKyAxXTtcbiAgICAgICAgICAgICAgICBwMyA9IGtmVmFsdWVzW2ZyYW1lID4gdHJhY2tMZW4gLSAzID8gdHJhY2tMZW4gLSAxIDogZnJhbWUgKyAyXTtcbiAgICAgICAgICAgICAgICBpZiAoaXNWYWx1ZUFycmF5KSB7XG4gICAgICAgICAgICAgICAgICAgIGNhdG11bGxSb21JbnRlcnBvbGF0ZUFycmF5KFxuICAgICAgICAgICAgICAgICAgICAgICAgcDAsIHAxLCBwMiwgcDMsIHcsIHcgKiB3LCB3ICogdyAqIHcsXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXR0ZXIodGFyZ2V0LCBwcm9wTmFtZSksXG4gICAgICAgICAgICAgICAgICAgICAgICBhcnJEaW1cbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzVmFsdWVDb2xvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBjYXRtdWxsUm9tSW50ZXJwb2xhdGVBcnJheShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwMCwgcDEsIHAyLCBwMywgdywgdyAqIHcsIHcgKiB3ICogdyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZ2JhLCAxXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSByZ2JhMlN0cmluZyhyZ2JhKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpc1ZhbHVlU3RyaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTdHJpbmcgaXMgc3RlcCgwLjUpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW50ZXJwb2xhdGVTdHJpbmcocDEsIHAyLCB3KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gY2F0bXVsbFJvbUludGVycG9sYXRlKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAwLCBwMSwgcDIsIHAzLCB3LCB3ICogdywgdyAqIHcgKiB3XG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHNldHRlcihcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BOYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNWYWx1ZUFycmF5KSB7XG4gICAgICAgICAgICAgICAgICAgIGludGVycG9sYXRlQXJyYXkoXG4gICAgICAgICAgICAgICAgICAgICAgICBrZlZhbHVlc1tmcmFtZV0sIGtmVmFsdWVzW2ZyYW1lICsgMV0sIHcsXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXR0ZXIodGFyZ2V0LCBwcm9wTmFtZSksXG4gICAgICAgICAgICAgICAgICAgICAgICBhcnJEaW1cbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzVmFsdWVDb2xvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJwb2xhdGVBcnJheShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZlZhbHVlc1tmcmFtZV0sIGtmVmFsdWVzW2ZyYW1lICsgMV0sIHcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmdiYSwgMVxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gcmdiYTJTdHJpbmcocmdiYSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNWYWx1ZVN0cmluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3RyaW5nIGlzIHN0ZXAoMC41KVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGludGVycG9sYXRlU3RyaW5nKGtmVmFsdWVzW2ZyYW1lXSwga2ZWYWx1ZXNbZnJhbWUgKyAxXSwgdyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGludGVycG9sYXRlTnVtYmVyKGtmVmFsdWVzW2ZyYW1lXSwga2ZWYWx1ZXNbZnJhbWUgKyAxXSwgdyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc2V0dGVyKFxuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcE5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgY2xpcCA9IG5ldyBDbGlwKHtcbiAgICAgICAgICAgIHRhcmdldDogYW5pbWF0b3IuX3RhcmdldCxcbiAgICAgICAgICAgIGxpZmU6IHRyYWNrTWF4VGltZSxcbiAgICAgICAgICAgIGxvb3A6IGFuaW1hdG9yLl9sb29wLFxuICAgICAgICAgICAgZGVsYXk6IGFuaW1hdG9yLl9kZWxheSxcbiAgICAgICAgICAgIG9uZnJhbWU6IG9uZnJhbWUsXG4gICAgICAgICAgICBvbmRlc3Ryb3k6IG9uZVRyYWNrRG9uZVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoZWFzaW5nICYmIGVhc2luZyAhPT0gJ3NwbGluZScpIHtcbiAgICAgICAgICAgIGNsaXAuZWFzaW5nID0gZWFzaW5nO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNsaXA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGFsaWFzIG1vZHVsZTp6cmVuZGVyL2FuaW1hdGlvbi9BbmltYXRvclxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGxvb3BcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBnZXR0ZXJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzZXR0ZXJcbiAgICAgKi9cbiAgICB2YXIgQW5pbWF0b3IgPSBmdW5jdGlvbih0YXJnZXQsIGxvb3AsIGdldHRlciwgc2V0dGVyKSB7XG4gICAgICAgIHRoaXMuX3RyYWNrcyA9IHt9O1xuICAgICAgICB0aGlzLl90YXJnZXQgPSB0YXJnZXQ7XG5cbiAgICAgICAgdGhpcy5fbG9vcCA9IGxvb3AgfHwgZmFsc2U7XG5cbiAgICAgICAgdGhpcy5fZ2V0dGVyID0gZ2V0dGVyIHx8IGRlZmF1bHRHZXR0ZXI7XG4gICAgICAgIHRoaXMuX3NldHRlciA9IHNldHRlciB8fCBkZWZhdWx0U2V0dGVyO1xuXG4gICAgICAgIHRoaXMuX2NsaXBDb3VudCA9IDA7XG5cbiAgICAgICAgdGhpcy5fZGVsYXkgPSAwO1xuXG4gICAgICAgIHRoaXMuX2RvbmVMaXN0ID0gW107XG5cbiAgICAgICAgdGhpcy5fb25mcmFtZUxpc3QgPSBbXTtcblxuICAgICAgICB0aGlzLl9jbGlwTGlzdCA9IFtdO1xuICAgIH07XG5cbiAgICBBbmltYXRvci5wcm90b3R5cGUgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiDorr7nva7liqjnlLvlhbPplK7luKdcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSB0aW1lIOWFs+mUruW4p+aXtumXtO+8jOWNleS9jeaYr21zXG4gICAgICAgICAqIEBwYXJhbSAge09iamVjdH0gcHJvcHMg5YWz6ZSu5bin55qE5bGe5oCn5YC877yMa2V5LXZhbHVl6KGo56S6XG4gICAgICAgICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2FuaW1hdGlvbi9BbmltYXRvcn1cbiAgICAgICAgICovXG4gICAgICAgIHdoZW46IGZ1bmN0aW9uKHRpbWUgLyogbXMgKi8sIHByb3BzKSB7XG4gICAgICAgICAgICB2YXIgdHJhY2tzID0gdGhpcy5fdHJhY2tzO1xuICAgICAgICAgICAgZm9yICh2YXIgcHJvcE5hbWUgaW4gcHJvcHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRyYWNrc1twcm9wTmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhY2tzW3Byb3BOYW1lXSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAvLyBJbnZhbGlkIHZhbHVlXG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuX2dldHRlcih0aGlzLl90YXJnZXQsIHByb3BOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHpyTG9nKCdJbnZhbGlkIHByb3BlcnR5ICcgKyBwcm9wTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aW1lIGlzIDBcbiAgICAgICAgICAgICAgICAgICAgLy8gIFRoZW4gcHJvcHMgaXMgZ2l2ZW4gaW5pdGlhbGl6ZSB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICAvLyBFbHNlXG4gICAgICAgICAgICAgICAgICAgIC8vICBJbml0aWFsaXplIHZhbHVlIGZyb20gY3VycmVudCBwcm9wIHZhbHVlXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aW1lICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFja3NbcHJvcE5hbWVdLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWU6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGNsb25lVmFsdWUodmFsdWUpXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0cmFja3NbcHJvcE5hbWVdLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICB0aW1lOiB0aW1lLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogcHJvcHNbcHJvcE5hbWVdXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOa3u+WKoOWKqOeUu+avj+S4gOW4p+eahOWbnuiwg+WHveaVsFxuICAgICAgICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICAgICAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvYW5pbWF0aW9uL0FuaW1hdG9yfVxuICAgICAgICAgKi9cbiAgICAgICAgZHVyaW5nOiBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHRoaXMuX29uZnJhbWVMaXN0LnB1c2goY2FsbGJhY2spO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2RvbmVDYWxsYmFjazogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gQ2xlYXIgYWxsIHRyYWNrc1xuICAgICAgICAgICAgdGhpcy5fdHJhY2tzID0ge307XG4gICAgICAgICAgICAvLyBDbGVhciBhbGwgY2xpcHNcbiAgICAgICAgICAgIHRoaXMuX2NsaXBMaXN0Lmxlbmd0aCA9IDA7XG5cbiAgICAgICAgICAgIHZhciBkb25lTGlzdCA9IHRoaXMuX2RvbmVMaXN0O1xuICAgICAgICAgICAgdmFyIGxlbiA9IGRvbmVMaXN0Lmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBkb25lTGlzdFtpXS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICog5byA5aeL5omn6KGM5Yqo55S7XG4gICAgICAgICAqIEBwYXJhbSAge3N0cmluZ3xGdW5jdGlvbn0gZWFzaW5nXG4gICAgICAgICAqICAgICAgICAg5Yqo55S757yT5Yqo5Ye95pWw77yM6K+m6KeBe0BsaW5rIG1vZHVsZTp6cmVuZGVyL2FuaW1hdGlvbi9lYXNpbmd9XG4gICAgICAgICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2FuaW1hdGlvbi9BbmltYXRvcn1cbiAgICAgICAgICovXG4gICAgICAgIHN0YXJ0OiBmdW5jdGlvbiAoZWFzaW5nKSB7XG5cbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIHZhciBjbGlwQ291bnQgPSAwO1xuXG4gICAgICAgICAgICB2YXIgb25lVHJhY2tEb25lID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgY2xpcENvdW50LS07XG4gICAgICAgICAgICAgICAgaWYgKCFjbGlwQ291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5fZG9uZUNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdmFyIGxhc3RDbGlwO1xuICAgICAgICAgICAgZm9yICh2YXIgcHJvcE5hbWUgaW4gdGhpcy5fdHJhY2tzKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNsaXAgPSBjcmVhdGVUcmFja0NsaXAoXG4gICAgICAgICAgICAgICAgICAgIHRoaXMsIGVhc2luZywgb25lVHJhY2tEb25lLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLl90cmFja3NbcHJvcE5hbWVdLCBwcm9wTmFtZVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgaWYgKGNsaXApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2xpcExpc3QucHVzaChjbGlwKTtcbiAgICAgICAgICAgICAgICAgICAgY2xpcENvdW50Kys7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgc3RhcnQgYWZ0ZXIgYWRkZWQgdG8gYW5pbWF0aW9uXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmFuaW1hdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hbmltYXRpb24uYWRkQ2xpcChjbGlwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGxhc3RDbGlwID0gY2xpcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEFkZCBkdXJpbmcgY2FsbGJhY2sgb24gdGhlIGxhc3QgY2xpcFxuICAgICAgICAgICAgaWYgKGxhc3RDbGlwKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9sZE9uRnJhbWUgPSBsYXN0Q2xpcC5vbmZyYW1lO1xuICAgICAgICAgICAgICAgIGxhc3RDbGlwLm9uZnJhbWUgPSBmdW5jdGlvbiAodGFyZ2V0LCBwZXJjZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIG9sZE9uRnJhbWUodGFyZ2V0LCBwZXJjZW50KTtcblxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbGYuX29uZnJhbWVMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9vbmZyYW1lTGlzdFtpXSh0YXJnZXQsIHBlcmNlbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFjbGlwQ291bnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9kb25lQ2FsbGJhY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICog5YGc5q2i5Yqo55S7XG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZm9yd2FyZFRvTGFzdCBJZiBtb3ZlIHRvIGxhc3QgZnJhbWUgYmVmb3JlIHN0b3BcbiAgICAgICAgICovXG4gICAgICAgIHN0b3A6IGZ1bmN0aW9uIChmb3J3YXJkVG9MYXN0KSB7XG4gICAgICAgICAgICB2YXIgY2xpcExpc3QgPSB0aGlzLl9jbGlwTGlzdDtcbiAgICAgICAgICAgIHZhciBhbmltYXRpb24gPSB0aGlzLmFuaW1hdGlvbjtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2xpcExpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgY2xpcCA9IGNsaXBMaXN0W2ldO1xuICAgICAgICAgICAgICAgIGlmIChmb3J3YXJkVG9MYXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE1vdmUgdG8gbGFzdCBmcmFtZSBiZWZvcmUgc3RvcFxuICAgICAgICAgICAgICAgICAgICBjbGlwLm9uZnJhbWUodGhpcy5fdGFyZ2V0LCAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYW5pbWF0aW9uICYmIGFuaW1hdGlvbi5yZW1vdmVDbGlwKGNsaXApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2xpcExpc3QubGVuZ3RoID0gMDtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOiuvue9ruWKqOeUu+W7tui/n+W8gOWni+eahOaXtumXtFxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHRpbWUg5Y2V5L2NbXNcbiAgICAgICAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvYW5pbWF0aW9uL0FuaW1hdG9yfVxuICAgICAgICAgKi9cbiAgICAgICAgZGVsYXk6IGZ1bmN0aW9uICh0aW1lKSB7XG4gICAgICAgICAgICB0aGlzLl9kZWxheSA9IHRpbWU7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOa3u+WKoOWKqOeUu+e7k+adn+eahOWbnuiwg1xuICAgICAgICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gY2JcbiAgICAgICAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvYW5pbWF0aW9uL0FuaW1hdG9yfVxuICAgICAgICAgKi9cbiAgICAgICAgZG9uZTogZnVuY3Rpb24oY2IpIHtcbiAgICAgICAgICAgIGlmIChjYikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2RvbmVMaXN0LnB1c2goY2IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4ge0FycmF5Ljxtb2R1bGU6enJlbmRlci9hbmltYXRpb24vQ2xpcD59XG4gICAgICAgICAqL1xuICAgICAgICBnZXRDbGlwczogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NsaXBMaXN0O1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gQW5pbWF0b3I7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi96cmVuZGVyL2xpYi9hbmltYXRpb24vQW5pbWF0b3IuanNcbiAqKiBtb2R1bGUgaWQgPSAxNlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiDliqjnlLvkuLvmjqfliLblmahcbiAqIEBjb25maWcgdGFyZ2V0IOWKqOeUu+Wvueixoe+8jOWPr+S7peaYr+aVsOe7hO+8jOWmguaenOaYr+aVsOe7hOeahOivneS8muaJuemHj+WIhuWPkW9uZnJhbWXnrYnkuovku7ZcbiAqIEBjb25maWcgbGlmZSgxMDAwKSDliqjnlLvml7bplb9cbiAqIEBjb25maWcgZGVsYXkoMCkg5Yqo55S75bu26L+f5pe26Ze0XG4gKiBAY29uZmlnIGxvb3AodHJ1ZSlcbiAqIEBjb25maWcgZ2FwKDApIOW+queOr+eahOmXtOmalOaXtumXtFxuICogQGNvbmZpZyBvbmZyYW1lXG4gKiBAY29uZmlnIGVhc2luZyhvcHRpb25hbClcbiAqIEBjb25maWcgb25kZXN0cm95KG9wdGlvbmFsKVxuICogQGNvbmZpZyBvbnJlc3RhcnQob3B0aW9uYWwpXG4gKlxuICogVE9ETyBwYXVzZVxuICovXG5cblxuICAgIHZhciBlYXNpbmdGdW5jcyA9IHJlcXVpcmUoJy4vZWFzaW5nJyk7XG5cbiAgICBmdW5jdGlvbiBDbGlwKG9wdGlvbnMpIHtcblxuICAgICAgICB0aGlzLl90YXJnZXQgPSBvcHRpb25zLnRhcmdldDtcblxuICAgICAgICAvLyDnlJ/lkb3lkajmnJ9cbiAgICAgICAgdGhpcy5fbGlmZSA9IG9wdGlvbnMubGlmZSB8fCAxMDAwO1xuICAgICAgICAvLyDlu7bml7ZcbiAgICAgICAgdGhpcy5fZGVsYXkgPSBvcHRpb25zLmRlbGF5IHx8IDA7XG4gICAgICAgIC8vIOW8gOWni+aXtumXtFxuICAgICAgICAvLyB0aGlzLl9zdGFydFRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKSArIHRoaXMuX2RlbGF5Oy8vIOWNleS9jeavq+enklxuICAgICAgICB0aGlzLl9pbml0aWFsaXplZCA9IGZhbHNlO1xuXG4gICAgICAgIC8vIOaYr+WQpuW+queOr1xuICAgICAgICB0aGlzLmxvb3AgPSBvcHRpb25zLmxvb3AgPT0gbnVsbCA/IGZhbHNlIDogb3B0aW9ucy5sb29wO1xuXG4gICAgICAgIHRoaXMuZ2FwID0gb3B0aW9ucy5nYXAgfHwgMDtcblxuICAgICAgICB0aGlzLmVhc2luZyA9IG9wdGlvbnMuZWFzaW5nIHx8ICdMaW5lYXInO1xuXG4gICAgICAgIHRoaXMub25mcmFtZSA9IG9wdGlvbnMub25mcmFtZTtcbiAgICAgICAgdGhpcy5vbmRlc3Ryb3kgPSBvcHRpb25zLm9uZGVzdHJveTtcbiAgICAgICAgdGhpcy5vbnJlc3RhcnQgPSBvcHRpb25zLm9ucmVzdGFydDtcbiAgICB9XG5cbiAgICBDbGlwLnByb3RvdHlwZSA9IHtcblxuICAgICAgICBjb25zdHJ1Y3RvcjogQ2xpcCxcblxuICAgICAgICBzdGVwOiBmdW5jdGlvbiAoZ2xvYmFsVGltZSkge1xuICAgICAgICAgICAgLy8gU2V0IHN0YXJ0VGltZSBvbiBmaXJzdCBzdGVwLCBvciBfc3RhcnRUaW1lIG1heSBoYXMgbWlsbGVzZWNvbmRzIGRpZmZlcmVudCBiZXR3ZWVuIGNsaXBzXG4gICAgICAgICAgICAvLyBQRU5ESU5HXG4gICAgICAgICAgICBpZiAoIXRoaXMuX2luaXRpYWxpemVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhcnRUaW1lID0gZ2xvYmFsVGltZSArIHRoaXMuX2RlbGF5O1xuICAgICAgICAgICAgICAgIHRoaXMuX2luaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHBlcmNlbnQgPSAoZ2xvYmFsVGltZSAtIHRoaXMuX3N0YXJ0VGltZSkgLyB0aGlzLl9saWZlO1xuXG4gICAgICAgICAgICAvLyDov5jmsqHlvIDlp4tcbiAgICAgICAgICAgIGlmIChwZXJjZW50IDwgMCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcGVyY2VudCA9IE1hdGgubWluKHBlcmNlbnQsIDEpO1xuXG4gICAgICAgICAgICB2YXIgZWFzaW5nID0gdGhpcy5lYXNpbmc7XG4gICAgICAgICAgICB2YXIgZWFzaW5nRnVuYyA9IHR5cGVvZiBlYXNpbmcgPT0gJ3N0cmluZycgPyBlYXNpbmdGdW5jc1tlYXNpbmddIDogZWFzaW5nO1xuICAgICAgICAgICAgdmFyIHNjaGVkdWxlID0gdHlwZW9mIGVhc2luZ0Z1bmMgPT09ICdmdW5jdGlvbidcbiAgICAgICAgICAgICAgICA/IGVhc2luZ0Z1bmMocGVyY2VudClcbiAgICAgICAgICAgICAgICA6IHBlcmNlbnQ7XG5cbiAgICAgICAgICAgIHRoaXMuZmlyZSgnZnJhbWUnLCBzY2hlZHVsZSk7XG5cbiAgICAgICAgICAgIC8vIOe7k+adn1xuICAgICAgICAgICAgaWYgKHBlcmNlbnQgPT0gMSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmxvb3ApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXN0YXJ0IChnbG9iYWxUaW1lKTtcbiAgICAgICAgICAgICAgICAgICAgLy8g6YeN5paw5byA5aeL5ZGo5pyfXG4gICAgICAgICAgICAgICAgICAgIC8vIOaKm+WHuuiAjOS4jeaYr+ebtOaOpeiwg+eUqOS6i+S7tuebtOWIsCBzdGFnZS51cGRhdGUg5ZCO5YaN57uf5LiA6LCD55So6L+Z5Lqb5LqL5Lu2XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAncmVzdGFydCc7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8g5Yqo55S75a6M5oiQ5bCG6L+Z5Liq5o6n5Yi25Zmo5qCH6K+G5Li65b6F5Yig6ZmkXG4gICAgICAgICAgICAgICAgLy8g5ZyoQW5pbWF0aW9uLnVwZGF0ZeS4rei/m+ihjOaJuemHj+WIoOmZpFxuICAgICAgICAgICAgICAgIHRoaXMuX25lZWRzUmVtb3ZlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2Rlc3Ryb3knO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfSxcblxuICAgICAgICByZXN0YXJ0OiBmdW5jdGlvbiAoZ2xvYmFsVGltZSkge1xuICAgICAgICAgICAgdmFyIHJlbWFpbmRlciA9IChnbG9iYWxUaW1lIC0gdGhpcy5fc3RhcnRUaW1lKSAlIHRoaXMuX2xpZmU7XG4gICAgICAgICAgICB0aGlzLl9zdGFydFRpbWUgPSBnbG9iYWxUaW1lIC0gcmVtYWluZGVyICsgdGhpcy5nYXA7XG5cbiAgICAgICAgICAgIHRoaXMuX25lZWRzUmVtb3ZlID0gZmFsc2U7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZmlyZTogZnVuY3Rpb24oZXZlbnRUeXBlLCBhcmcpIHtcbiAgICAgICAgICAgIGV2ZW50VHlwZSA9ICdvbicgKyBldmVudFR5cGU7XG4gICAgICAgICAgICBpZiAodGhpc1tldmVudFR5cGVdKSB7XG4gICAgICAgICAgICAgICAgdGhpc1tldmVudFR5cGVdKHRoaXMuX3RhcmdldCwgYXJnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IENsaXA7XG5cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3pyZW5kZXIvbGliL2FuaW1hdGlvbi9DbGlwLmpzXG4gKiogbW9kdWxlIGlkID0gMTdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICog57yT5Yqo5Luj56CB5p2l6IeqIGh0dHBzOi8vZ2l0aHViLmNvbS9zb2xlL3R3ZWVuLmpzL2Jsb2IvbWFzdGVyL3NyYy9Ud2Vlbi5qc1xuICogQHNlZSBodHRwOi8vc29sZS5naXRodWIuaW8vdHdlZW4uanMvZXhhbXBsZXMvMDNfZ3JhcGhzLmh0bWxcbiAqIEBleHBvcnRzIHpyZW5kZXIvYW5pbWF0aW9uL2Vhc2luZ1xuICovXG5cbiAgICB2YXIgZWFzaW5nID0ge1xuICAgICAgICAvKipcbiAgICAgICAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgKi9cbiAgICAgICAgbGluZWFyOiBmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgcmV0dXJuIGs7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICovXG4gICAgICAgIHF1YWRyYXRpY0luOiBmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgcmV0dXJuIGsgKiBrO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgKi9cbiAgICAgICAgcXVhZHJhdGljT3V0OiBmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgcmV0dXJuIGsgKiAoMiAtIGspO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgKi9cbiAgICAgICAgcXVhZHJhdGljSW5PdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICBpZiAoKGsgKj0gMikgPCAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDAuNSAqIGsgKiBrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIC0wLjUgKiAoLS1rICogKGsgLSAyKSAtIDEpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIOS4ieasoeaWueeahOe8k+WKqO+8iHReM++8iVxuICAgICAgICAvKipcbiAgICAgICAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgKi9cbiAgICAgICAgY3ViaWNJbjogZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgIHJldHVybiBrICogayAqIGs7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAqL1xuICAgICAgICBjdWJpY091dDogZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgIHJldHVybiAtLWsgKiBrICogayArIDE7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAqL1xuICAgICAgICBjdWJpY0luT3V0OiBmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgaWYgKChrICo9IDIpIDwgMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAwLjUgKiBrICogayAqIGs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gMC41ICogKChrIC09IDIpICogayAqIGsgKyAyKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyDlm5vmrKHmlrnnmoTnvJPliqjvvIh0XjTvvIlcbiAgICAgICAgLyoqXG4gICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICovXG4gICAgICAgIHF1YXJ0aWNJbjogZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgIHJldHVybiBrICogayAqIGsgKiBrO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgKi9cbiAgICAgICAgcXVhcnRpY091dDogZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgIHJldHVybiAxIC0gKC0tayAqIGsgKiBrICogayk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAqL1xuICAgICAgICBxdWFydGljSW5PdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICBpZiAoKGsgKj0gMikgPCAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDAuNSAqIGsgKiBrICogayAqIGs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gLTAuNSAqICgoayAtPSAyKSAqIGsgKiBrICogayAtIDIpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIOS6lOasoeaWueeahOe8k+WKqO+8iHReNe+8iVxuICAgICAgICAvKipcbiAgICAgICAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgKi9cbiAgICAgICAgcXVpbnRpY0luOiBmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgcmV0dXJuIGsgKiBrICogayAqIGsgKiBrO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgKi9cbiAgICAgICAgcXVpbnRpY091dDogZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgIHJldHVybiAtLWsgKiBrICogayAqIGsgKiBrICsgMTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICovXG4gICAgICAgIHF1aW50aWNJbk91dDogZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgIGlmICgoayAqPSAyKSA8IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMC41ICogayAqIGsgKiBrICogayAqIGs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gMC41ICogKChrIC09IDIpICogayAqIGsgKiBrICogayArIDIpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIOato+W8puabsue6v+eahOe8k+WKqO+8iHNpbih0Ke+8iVxuICAgICAgICAvKipcbiAgICAgICAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgKi9cbiAgICAgICAgc2ludXNvaWRhbEluOiBmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgcmV0dXJuIDEgLSBNYXRoLmNvcyhrICogTWF0aC5QSSAvIDIpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgKi9cbiAgICAgICAgc2ludXNvaWRhbE91dDogZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLnNpbihrICogTWF0aC5QSSAvIDIpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgKi9cbiAgICAgICAgc2ludXNvaWRhbEluT3V0OiBmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgcmV0dXJuIDAuNSAqICgxIC0gTWF0aC5jb3MoTWF0aC5QSSAqIGspKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyDmjIfmlbDmm7Lnur/nmoTnvJPliqjvvIgyXnTvvIlcbiAgICAgICAgLyoqXG4gICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICovXG4gICAgICAgIGV4cG9uZW50aWFsSW46IGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICByZXR1cm4gayA9PT0gMCA/IDAgOiBNYXRoLnBvdygxMDI0LCBrIC0gMSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAqL1xuICAgICAgICBleHBvbmVudGlhbE91dDogZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgIHJldHVybiBrID09PSAxID8gMSA6IDEgLSBNYXRoLnBvdygyLCAtMTAgKiBrKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICovXG4gICAgICAgIGV4cG9uZW50aWFsSW5PdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICBpZiAoayA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGsgPT09IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgoayAqPSAyKSA8IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMC41ICogTWF0aC5wb3coMTAyNCwgayAtIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIDAuNSAqICgtTWF0aC5wb3coMiwgLTEwICogKGsgLSAxKSkgKyAyKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyDlnIblvaLmm7Lnur/nmoTnvJPliqjvvIhzcXJ0KDEtdF4yKe+8iVxuICAgICAgICAvKipcbiAgICAgICAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgKi9cbiAgICAgICAgY2lyY3VsYXJJbjogZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgIHJldHVybiAxIC0gTWF0aC5zcXJ0KDEgLSBrICogayk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAqL1xuICAgICAgICBjaXJjdWxhck91dDogZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLnNxcnQoMSAtICgtLWsgKiBrKSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAqL1xuICAgICAgICBjaXJjdWxhckluT3V0OiBmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgaWYgKChrICo9IDIpIDwgMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAtMC41ICogKE1hdGguc3FydCgxIC0gayAqIGspIC0gMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gMC41ICogKE1hdGguc3FydCgxIC0gKGsgLT0gMikgKiBrKSArIDEpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIOWIm+W7uuexu+S8vOS6juW8ueewp+WcqOWBnOatouWJjeadpeWbnuaMr+iNoeeahOWKqOeUu1xuICAgICAgICAvKipcbiAgICAgICAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgKi9cbiAgICAgICAgZWxhc3RpY0luOiBmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgdmFyIHM7XG4gICAgICAgICAgICB2YXIgYSA9IDAuMTtcbiAgICAgICAgICAgIHZhciBwID0gMC40O1xuICAgICAgICAgICAgaWYgKGsgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChrID09PSAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWEgfHwgYSA8IDEpIHtcbiAgICAgICAgICAgICAgICBhID0gMTsgcyA9IHAgLyA0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcyA9IHAgKiBNYXRoLmFzaW4oMSAvIGEpIC8gKDIgKiBNYXRoLlBJKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAtKGEgKiBNYXRoLnBvdygyLCAxMCAqIChrIC09IDEpKSAqXG4gICAgICAgICAgICAgICAgICAgICAgICBNYXRoLnNpbigoayAtIHMpICogKDIgKiBNYXRoLlBJKSAvIHApKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICovXG4gICAgICAgIGVsYXN0aWNPdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICB2YXIgcztcbiAgICAgICAgICAgIHZhciBhID0gMC4xO1xuICAgICAgICAgICAgdmFyIHAgPSAwLjQ7XG4gICAgICAgICAgICBpZiAoayA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGsgPT09IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghYSB8fCBhIDwgMSkge1xuICAgICAgICAgICAgICAgIGEgPSAxOyBzID0gcCAvIDQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzID0gcCAqIE1hdGguYXNpbigxIC8gYSkgLyAoMiAqIE1hdGguUEkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIChhICogTWF0aC5wb3coMiwgLTEwICogaykgKlxuICAgICAgICAgICAgICAgICAgICBNYXRoLnNpbigoayAtIHMpICogKDIgKiBNYXRoLlBJKSAvIHApICsgMSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAqL1xuICAgICAgICBlbGFzdGljSW5PdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICB2YXIgcztcbiAgICAgICAgICAgIHZhciBhID0gMC4xO1xuICAgICAgICAgICAgdmFyIHAgPSAwLjQ7XG4gICAgICAgICAgICBpZiAoayA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGsgPT09IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghYSB8fCBhIDwgMSkge1xuICAgICAgICAgICAgICAgIGEgPSAxOyBzID0gcCAvIDQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzID0gcCAqIE1hdGguYXNpbigxIC8gYSkgLyAoMiAqIE1hdGguUEkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChrICo9IDIpIDwgMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAtMC41ICogKGEgKiBNYXRoLnBvdygyLCAxMCAqIChrIC09IDEpKVxuICAgICAgICAgICAgICAgICAgICAqIE1hdGguc2luKChrIC0gcykgKiAoMiAqIE1hdGguUEkpIC8gcCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGEgKiBNYXRoLnBvdygyLCAtMTAgKiAoayAtPSAxKSlcbiAgICAgICAgICAgICAgICAgICAgKiBNYXRoLnNpbigoayAtIHMpICogKDIgKiBNYXRoLlBJKSAvIHApICogMC41ICsgMTtcblxuICAgICAgICB9LFxuXG4gICAgICAgIC8vIOWcqOafkOS4gOWKqOeUu+W8gOWni+ayv+aMh+ekuueahOi3r+W+hOi/m+ihjOWKqOeUu+WkhOeQhuWJjeeojeeojeaUtuWbnuivpeWKqOeUu+eahOenu+WKqFxuICAgICAgICAvKipcbiAgICAgICAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgKi9cbiAgICAgICAgYmFja0luOiBmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgdmFyIHMgPSAxLjcwMTU4O1xuICAgICAgICAgICAgcmV0dXJuIGsgKiBrICogKChzICsgMSkgKiBrIC0gcyk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAqL1xuICAgICAgICBiYWNrT3V0OiBmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgdmFyIHMgPSAxLjcwMTU4O1xuICAgICAgICAgICAgcmV0dXJuIC0tayAqIGsgKiAoKHMgKyAxKSAqIGsgKyBzKSArIDE7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAqL1xuICAgICAgICBiYWNrSW5PdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICB2YXIgcyA9IDEuNzAxNTggKiAxLjUyNTtcbiAgICAgICAgICAgIGlmICgoayAqPSAyKSA8IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMC41ICogKGsgKiBrICogKChzICsgMSkgKiBrIC0gcykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIDAuNSAqICgoayAtPSAyKSAqIGsgKiAoKHMgKyAxKSAqIGsgKyBzKSArIDIpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIOWIm+W7uuW8uei3s+aViOaenFxuICAgICAgICAvKipcbiAgICAgICAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgKi9cbiAgICAgICAgYm91bmNlSW46IGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICByZXR1cm4gMSAtIGVhc2luZy5ib3VuY2VPdXQoMSAtIGspO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgKi9cbiAgICAgICAgYm91bmNlT3V0OiBmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgaWYgKGsgPCAoMSAvIDIuNzUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDcuNTYyNSAqIGsgKiBrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoayA8ICgyIC8gMi43NSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gNy41NjI1ICogKGsgLT0gKDEuNSAvIDIuNzUpKSAqIGsgKyAwLjc1O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoayA8ICgyLjUgLyAyLjc1KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiA3LjU2MjUgKiAoayAtPSAoMi4yNSAvIDIuNzUpKSAqIGsgKyAwLjkzNzU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gNy41NjI1ICogKGsgLT0gKDIuNjI1IC8gMi43NSkpICogayArIDAuOTg0Mzc1O1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgKi9cbiAgICAgICAgYm91bmNlSW5PdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICBpZiAoayA8IDAuNSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlYXNpbmcuYm91bmNlSW4oayAqIDIpICogMC41O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGVhc2luZy5ib3VuY2VPdXQoayAqIDIgLSAxKSAqIDAuNSArIDAuNTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGVhc2luZztcblxuXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi96cmVuZGVyL2xpYi9hbmltYXRpb24vZWFzaW5nLmpzXG4gKiogbW9kdWxlIGlkID0gMThcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQG1vZHVsZSB6cmVuZGVyL3Rvb2wvY29sb3JcbiAqL1xuXG5cbiAgICB2YXIga0NTU0NvbG9yVGFibGUgPSB7XG4gICAgICAgICd0cmFuc3BhcmVudCc6IFswLDAsMCwwXSwgJ2FsaWNlYmx1ZSc6IFsyNDAsMjQ4LDI1NSwxXSxcbiAgICAgICAgJ2FudGlxdWV3aGl0ZSc6IFsyNTAsMjM1LDIxNSwxXSwgJ2FxdWEnOiBbMCwyNTUsMjU1LDFdLFxuICAgICAgICAnYXF1YW1hcmluZSc6IFsxMjcsMjU1LDIxMiwxXSwgJ2F6dXJlJzogWzI0MCwyNTUsMjU1LDFdLFxuICAgICAgICAnYmVpZ2UnOiBbMjQ1LDI0NSwyMjAsMV0sICdiaXNxdWUnOiBbMjU1LDIyOCwxOTYsMV0sXG4gICAgICAgICdibGFjayc6IFswLDAsMCwxXSwgJ2JsYW5jaGVkYWxtb25kJzogWzI1NSwyMzUsMjA1LDFdLFxuICAgICAgICAnYmx1ZSc6IFswLDAsMjU1LDFdLCAnYmx1ZXZpb2xldCc6IFsxMzgsNDMsMjI2LDFdLFxuICAgICAgICAnYnJvd24nOiBbMTY1LDQyLDQyLDFdLCAnYnVybHl3b29kJzogWzIyMiwxODQsMTM1LDFdLFxuICAgICAgICAnY2FkZXRibHVlJzogWzk1LDE1OCwxNjAsMV0sICdjaGFydHJldXNlJzogWzEyNywyNTUsMCwxXSxcbiAgICAgICAgJ2Nob2NvbGF0ZSc6IFsyMTAsMTA1LDMwLDFdLCAnY29yYWwnOiBbMjU1LDEyNyw4MCwxXSxcbiAgICAgICAgJ2Nvcm5mbG93ZXJibHVlJzogWzEwMCwxNDksMjM3LDFdLCAnY29ybnNpbGsnOiBbMjU1LDI0OCwyMjAsMV0sXG4gICAgICAgICdjcmltc29uJzogWzIyMCwyMCw2MCwxXSwgJ2N5YW4nOiBbMCwyNTUsMjU1LDFdLFxuICAgICAgICAnZGFya2JsdWUnOiBbMCwwLDEzOSwxXSwgJ2RhcmtjeWFuJzogWzAsMTM5LDEzOSwxXSxcbiAgICAgICAgJ2Rhcmtnb2xkZW5yb2QnOiBbMTg0LDEzNCwxMSwxXSwgJ2RhcmtncmF5JzogWzE2OSwxNjksMTY5LDFdLFxuICAgICAgICAnZGFya2dyZWVuJzogWzAsMTAwLDAsMV0sICdkYXJrZ3JleSc6IFsxNjksMTY5LDE2OSwxXSxcbiAgICAgICAgJ2RhcmtraGFraSc6IFsxODksMTgzLDEwNywxXSwgJ2RhcmttYWdlbnRhJzogWzEzOSwwLDEzOSwxXSxcbiAgICAgICAgJ2RhcmtvbGl2ZWdyZWVuJzogWzg1LDEwNyw0NywxXSwgJ2RhcmtvcmFuZ2UnOiBbMjU1LDE0MCwwLDFdLFxuICAgICAgICAnZGFya29yY2hpZCc6IFsxNTMsNTAsMjA0LDFdLCAnZGFya3JlZCc6IFsxMzksMCwwLDFdLFxuICAgICAgICAnZGFya3NhbG1vbic6IFsyMzMsMTUwLDEyMiwxXSwgJ2RhcmtzZWFncmVlbic6IFsxNDMsMTg4LDE0MywxXSxcbiAgICAgICAgJ2RhcmtzbGF0ZWJsdWUnOiBbNzIsNjEsMTM5LDFdLCAnZGFya3NsYXRlZ3JheSc6IFs0Nyw3OSw3OSwxXSxcbiAgICAgICAgJ2RhcmtzbGF0ZWdyZXknOiBbNDcsNzksNzksMV0sICdkYXJrdHVycXVvaXNlJzogWzAsMjA2LDIwOSwxXSxcbiAgICAgICAgJ2Rhcmt2aW9sZXQnOiBbMTQ4LDAsMjExLDFdLCAnZGVlcHBpbmsnOiBbMjU1LDIwLDE0NywxXSxcbiAgICAgICAgJ2RlZXBza3libHVlJzogWzAsMTkxLDI1NSwxXSwgJ2RpbWdyYXknOiBbMTA1LDEwNSwxMDUsMV0sXG4gICAgICAgICdkaW1ncmV5JzogWzEwNSwxMDUsMTA1LDFdLCAnZG9kZ2VyYmx1ZSc6IFszMCwxNDQsMjU1LDFdLFxuICAgICAgICAnZmlyZWJyaWNrJzogWzE3OCwzNCwzNCwxXSwgJ2Zsb3JhbHdoaXRlJzogWzI1NSwyNTAsMjQwLDFdLFxuICAgICAgICAnZm9yZXN0Z3JlZW4nOiBbMzQsMTM5LDM0LDFdLCAnZnVjaHNpYSc6IFsyNTUsMCwyNTUsMV0sXG4gICAgICAgICdnYWluc2Jvcm8nOiBbMjIwLDIyMCwyMjAsMV0sICdnaG9zdHdoaXRlJzogWzI0OCwyNDgsMjU1LDFdLFxuICAgICAgICAnZ29sZCc6IFsyNTUsMjE1LDAsMV0sICdnb2xkZW5yb2QnOiBbMjE4LDE2NSwzMiwxXSxcbiAgICAgICAgJ2dyYXknOiBbMTI4LDEyOCwxMjgsMV0sICdncmVlbic6IFswLDEyOCwwLDFdLFxuICAgICAgICAnZ3JlZW55ZWxsb3cnOiBbMTczLDI1NSw0NywxXSwgJ2dyZXknOiBbMTI4LDEyOCwxMjgsMV0sXG4gICAgICAgICdob25leWRldyc6IFsyNDAsMjU1LDI0MCwxXSwgJ2hvdHBpbmsnOiBbMjU1LDEwNSwxODAsMV0sXG4gICAgICAgICdpbmRpYW5yZWQnOiBbMjA1LDkyLDkyLDFdLCAnaW5kaWdvJzogWzc1LDAsMTMwLDFdLFxuICAgICAgICAnaXZvcnknOiBbMjU1LDI1NSwyNDAsMV0sICdraGFraSc6IFsyNDAsMjMwLDE0MCwxXSxcbiAgICAgICAgJ2xhdmVuZGVyJzogWzIzMCwyMzAsMjUwLDFdLCAnbGF2ZW5kZXJibHVzaCc6IFsyNTUsMjQwLDI0NSwxXSxcbiAgICAgICAgJ2xhd25ncmVlbic6IFsxMjQsMjUyLDAsMV0sICdsZW1vbmNoaWZmb24nOiBbMjU1LDI1MCwyMDUsMV0sXG4gICAgICAgICdsaWdodGJsdWUnOiBbMTczLDIxNiwyMzAsMV0sICdsaWdodGNvcmFsJzogWzI0MCwxMjgsMTI4LDFdLFxuICAgICAgICAnbGlnaHRjeWFuJzogWzIyNCwyNTUsMjU1LDFdLCAnbGlnaHRnb2xkZW5yb2R5ZWxsb3cnOiBbMjUwLDI1MCwyMTAsMV0sXG4gICAgICAgICdsaWdodGdyYXknOiBbMjExLDIxMSwyMTEsMV0sICdsaWdodGdyZWVuJzogWzE0NCwyMzgsMTQ0LDFdLFxuICAgICAgICAnbGlnaHRncmV5JzogWzIxMSwyMTEsMjExLDFdLCAnbGlnaHRwaW5rJzogWzI1NSwxODIsMTkzLDFdLFxuICAgICAgICAnbGlnaHRzYWxtb24nOiBbMjU1LDE2MCwxMjIsMV0sICdsaWdodHNlYWdyZWVuJzogWzMyLDE3OCwxNzAsMV0sXG4gICAgICAgICdsaWdodHNreWJsdWUnOiBbMTM1LDIwNiwyNTAsMV0sICdsaWdodHNsYXRlZ3JheSc6IFsxMTksMTM2LDE1MywxXSxcbiAgICAgICAgJ2xpZ2h0c2xhdGVncmV5JzogWzExOSwxMzYsMTUzLDFdLCAnbGlnaHRzdGVlbGJsdWUnOiBbMTc2LDE5NiwyMjIsMV0sXG4gICAgICAgICdsaWdodHllbGxvdyc6IFsyNTUsMjU1LDIyNCwxXSwgJ2xpbWUnOiBbMCwyNTUsMCwxXSxcbiAgICAgICAgJ2xpbWVncmVlbic6IFs1MCwyMDUsNTAsMV0sICdsaW5lbic6IFsyNTAsMjQwLDIzMCwxXSxcbiAgICAgICAgJ21hZ2VudGEnOiBbMjU1LDAsMjU1LDFdLCAnbWFyb29uJzogWzEyOCwwLDAsMV0sXG4gICAgICAgICdtZWRpdW1hcXVhbWFyaW5lJzogWzEwMiwyMDUsMTcwLDFdLCAnbWVkaXVtYmx1ZSc6IFswLDAsMjA1LDFdLFxuICAgICAgICAnbWVkaXVtb3JjaGlkJzogWzE4Niw4NSwyMTEsMV0sICdtZWRpdW1wdXJwbGUnOiBbMTQ3LDExMiwyMTksMV0sXG4gICAgICAgICdtZWRpdW1zZWFncmVlbic6IFs2MCwxNzksMTEzLDFdLCAnbWVkaXVtc2xhdGVibHVlJzogWzEyMywxMDQsMjM4LDFdLFxuICAgICAgICAnbWVkaXVtc3ByaW5nZ3JlZW4nOiBbMCwyNTAsMTU0LDFdLCAnbWVkaXVtdHVycXVvaXNlJzogWzcyLDIwOSwyMDQsMV0sXG4gICAgICAgICdtZWRpdW12aW9sZXRyZWQnOiBbMTk5LDIxLDEzMywxXSwgJ21pZG5pZ2h0Ymx1ZSc6IFsyNSwyNSwxMTIsMV0sXG4gICAgICAgICdtaW50Y3JlYW0nOiBbMjQ1LDI1NSwyNTAsMV0sICdtaXN0eXJvc2UnOiBbMjU1LDIyOCwyMjUsMV0sXG4gICAgICAgICdtb2NjYXNpbic6IFsyNTUsMjI4LDE4MSwxXSwgJ25hdmFqb3doaXRlJzogWzI1NSwyMjIsMTczLDFdLFxuICAgICAgICAnbmF2eSc6IFswLDAsMTI4LDFdLCAnb2xkbGFjZSc6IFsyNTMsMjQ1LDIzMCwxXSxcbiAgICAgICAgJ29saXZlJzogWzEyOCwxMjgsMCwxXSwgJ29saXZlZHJhYic6IFsxMDcsMTQyLDM1LDFdLFxuICAgICAgICAnb3JhbmdlJzogWzI1NSwxNjUsMCwxXSwgJ29yYW5nZXJlZCc6IFsyNTUsNjksMCwxXSxcbiAgICAgICAgJ29yY2hpZCc6IFsyMTgsMTEyLDIxNCwxXSwgJ3BhbGVnb2xkZW5yb2QnOiBbMjM4LDIzMiwxNzAsMV0sXG4gICAgICAgICdwYWxlZ3JlZW4nOiBbMTUyLDI1MSwxNTIsMV0sICdwYWxldHVycXVvaXNlJzogWzE3NSwyMzgsMjM4LDFdLFxuICAgICAgICAncGFsZXZpb2xldHJlZCc6IFsyMTksMTEyLDE0NywxXSwgJ3BhcGF5YXdoaXAnOiBbMjU1LDIzOSwyMTMsMV0sXG4gICAgICAgICdwZWFjaHB1ZmYnOiBbMjU1LDIxOCwxODUsMV0sICdwZXJ1JzogWzIwNSwxMzMsNjMsMV0sXG4gICAgICAgICdwaW5rJzogWzI1NSwxOTIsMjAzLDFdLCAncGx1bSc6IFsyMjEsMTYwLDIyMSwxXSxcbiAgICAgICAgJ3Bvd2RlcmJsdWUnOiBbMTc2LDIyNCwyMzAsMV0sICdwdXJwbGUnOiBbMTI4LDAsMTI4LDFdLFxuICAgICAgICAncmVkJzogWzI1NSwwLDAsMV0sICdyb3N5YnJvd24nOiBbMTg4LDE0MywxNDMsMV0sXG4gICAgICAgICdyb3lhbGJsdWUnOiBbNjUsMTA1LDIyNSwxXSwgJ3NhZGRsZWJyb3duJzogWzEzOSw2OSwxOSwxXSxcbiAgICAgICAgJ3NhbG1vbic6IFsyNTAsMTI4LDExNCwxXSwgJ3NhbmR5YnJvd24nOiBbMjQ0LDE2NCw5NiwxXSxcbiAgICAgICAgJ3NlYWdyZWVuJzogWzQ2LDEzOSw4NywxXSwgJ3NlYXNoZWxsJzogWzI1NSwyNDUsMjM4LDFdLFxuICAgICAgICAnc2llbm5hJzogWzE2MCw4Miw0NSwxXSwgJ3NpbHZlcic6IFsxOTIsMTkyLDE5MiwxXSxcbiAgICAgICAgJ3NreWJsdWUnOiBbMTM1LDIwNiwyMzUsMV0sICdzbGF0ZWJsdWUnOiBbMTA2LDkwLDIwNSwxXSxcbiAgICAgICAgJ3NsYXRlZ3JheSc6IFsxMTIsMTI4LDE0NCwxXSwgJ3NsYXRlZ3JleSc6IFsxMTIsMTI4LDE0NCwxXSxcbiAgICAgICAgJ3Nub3cnOiBbMjU1LDI1MCwyNTAsMV0sICdzcHJpbmdncmVlbic6IFswLDI1NSwxMjcsMV0sXG4gICAgICAgICdzdGVlbGJsdWUnOiBbNzAsMTMwLDE4MCwxXSwgJ3Rhbic6IFsyMTAsMTgwLDE0MCwxXSxcbiAgICAgICAgJ3RlYWwnOiBbMCwxMjgsMTI4LDFdLCAndGhpc3RsZSc6IFsyMTYsMTkxLDIxNiwxXSxcbiAgICAgICAgJ3RvbWF0byc6IFsyNTUsOTksNzEsMV0sICd0dXJxdW9pc2UnOiBbNjQsMjI0LDIwOCwxXSxcbiAgICAgICAgJ3Zpb2xldCc6IFsyMzgsMTMwLDIzOCwxXSwgJ3doZWF0JzogWzI0NSwyMjIsMTc5LDFdLFxuICAgICAgICAnd2hpdGUnOiBbMjU1LDI1NSwyNTUsMV0sICd3aGl0ZXNtb2tlJzogWzI0NSwyNDUsMjQ1LDFdLFxuICAgICAgICAneWVsbG93JzogWzI1NSwyNTUsMCwxXSwgJ3llbGxvd2dyZWVuJzogWzE1NCwyMDUsNTAsMV1cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gY2xhbXBDc3NCeXRlKGkpIHsgIC8vIENsYW1wIHRvIGludGVnZXIgMCAuLiAyNTUuXG4gICAgICAgIGkgPSBNYXRoLnJvdW5kKGkpOyAgLy8gU2VlbXMgdG8gYmUgd2hhdCBDaHJvbWUgZG9lcyAodnMgdHJ1bmNhdGlvbikuXG4gICAgICAgIHJldHVybiBpIDwgMCA/IDAgOiBpID4gMjU1ID8gMjU1IDogaTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbGFtcENzc0FuZ2xlKGkpIHsgIC8vIENsYW1wIHRvIGludGVnZXIgMCAuLiAzNjAuXG4gICAgICAgIGkgPSBNYXRoLnJvdW5kKGkpOyAgLy8gU2VlbXMgdG8gYmUgd2hhdCBDaHJvbWUgZG9lcyAodnMgdHJ1bmNhdGlvbikuXG4gICAgICAgIHJldHVybiBpIDwgMCA/IDAgOiBpID4gMzYwID8gMzYwIDogaTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbGFtcENzc0Zsb2F0KGYpIHsgIC8vIENsYW1wIHRvIGZsb2F0IDAuMCAuLiAxLjAuXG4gICAgICAgIHJldHVybiBmIDwgMCA/IDAgOiBmID4gMSA/IDEgOiBmO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlQ3NzSW50KHN0cikgeyAgLy8gaW50IG9yIHBlcmNlbnRhZ2UuXG4gICAgICAgIGlmIChzdHIubGVuZ3RoICYmIHN0ci5jaGFyQXQoc3RyLmxlbmd0aCAtIDEpID09PSAnJScpIHtcbiAgICAgICAgICAgIHJldHVybiBjbGFtcENzc0J5dGUocGFyc2VGbG9hdChzdHIpIC8gMTAwICogMjU1KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2xhbXBDc3NCeXRlKHBhcnNlSW50KHN0ciwgMTApKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZUNzc0Zsb2F0KHN0cikgeyAgLy8gZmxvYXQgb3IgcGVyY2VudGFnZS5cbiAgICAgICAgaWYgKHN0ci5sZW5ndGggJiYgc3RyLmNoYXJBdChzdHIubGVuZ3RoIC0gMSkgPT09ICclJykge1xuICAgICAgICAgICAgcmV0dXJuIGNsYW1wQ3NzRmxvYXQocGFyc2VGbG9hdChzdHIpIC8gMTAwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2xhbXBDc3NGbG9hdChwYXJzZUZsb2F0KHN0cikpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNzc0h1ZVRvUmdiKG0xLCBtMiwgaCkge1xuICAgICAgICBpZiAoaCA8IDApIHtcbiAgICAgICAgICAgIGggKz0gMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChoID4gMSkge1xuICAgICAgICAgICAgaCAtPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGggKiA2IDwgMSkge1xuICAgICAgICAgICAgcmV0dXJuIG0xICsgKG0yIC0gbTEpICogaCAqIDY7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGggKiAyIDwgMSkge1xuICAgICAgICAgICAgcmV0dXJuIG0yO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoICogMyA8IDIpIHtcbiAgICAgICAgICAgIHJldHVybiBtMSArIChtMiAtIG0xKSAqICgyLzMgLSBoKSAqIDY7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG0xO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxlcnAoYSwgYiwgcCkge1xuICAgICAgICByZXR1cm4gYSArIChiIC0gYSkgKiBwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb2xvclN0clxuICAgICAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fVxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci91dGlsL2NvbG9yXG4gICAgICovXG4gICAgZnVuY3Rpb24gcGFyc2UoY29sb3JTdHIpIHtcbiAgICAgICAgaWYgKCFjb2xvclN0cikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNvbG9yU3RyIG1heSBiZSBub3Qgc3RyaW5nXG4gICAgICAgIGNvbG9yU3RyID0gY29sb3JTdHIgKyAnJztcbiAgICAgICAgLy8gUmVtb3ZlIGFsbCB3aGl0ZXNwYWNlLCBub3QgY29tcGxpYW50LCBidXQgc2hvdWxkIGp1c3QgYmUgbW9yZSBhY2NlcHRpbmcuXG4gICAgICAgIHZhciBzdHIgPSBjb2xvclN0ci5yZXBsYWNlKC8gL2csICcnKS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgICAgIC8vIENvbG9yIGtleXdvcmRzIChhbmQgdHJhbnNwYXJlbnQpIGxvb2t1cC5cbiAgICAgICAgaWYgKHN0ciBpbiBrQ1NTQ29sb3JUYWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuIGtDU1NDb2xvclRhYmxlW3N0cl0uc2xpY2UoKTsgIC8vIGR1cC5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vICNhYmMgYW5kICNhYmMxMjMgc3ludGF4LlxuICAgICAgICBpZiAoc3RyLmNoYXJBdCgwKSA9PT0gJyMnKSB7XG4gICAgICAgICAgICBpZiAoc3RyLmxlbmd0aCA9PT0gNCkge1xuICAgICAgICAgICAgICAgIHZhciBpdiA9IHBhcnNlSW50KHN0ci5zdWJzdHIoMSksIDE2KTsgIC8vIFRPRE8oZGVhbm0pOiBTdHJpY3RlciBwYXJzaW5nLlxuICAgICAgICAgICAgICAgIGlmICghKGl2ID49IDAgJiYgaXYgPD0gMHhmZmYpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjsgIC8vIENvdmVycyBOYU4uXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICgoaXYgJiAweGYwMCkgPj4gNCkgfCAoKGl2ICYgMHhmMDApID4+IDgpLFxuICAgICAgICAgICAgICAgICAgICAoaXYgJiAweGYwKSB8ICgoaXYgJiAweGYwKSA+PiA0KSxcbiAgICAgICAgICAgICAgICAgICAgKGl2ICYgMHhmKSB8ICgoaXYgJiAweGYpIDw8IDQpLFxuICAgICAgICAgICAgICAgICAgICAxXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHN0ci5sZW5ndGggPT09IDcpIHtcbiAgICAgICAgICAgICAgICB2YXIgaXYgPSBwYXJzZUludChzdHIuc3Vic3RyKDEpLCAxNik7ICAvLyBUT0RPKGRlYW5tKTogU3RyaWN0ZXIgcGFyc2luZy5cbiAgICAgICAgICAgICAgICBpZiAoIShpdiA+PSAwICYmIGl2IDw9IDB4ZmZmZmZmKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47ICAvLyBDb3ZlcnMgTmFOLlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAoaXYgJiAweGZmMDAwMCkgPj4gMTYsXG4gICAgICAgICAgICAgICAgICAgIChpdiAmIDB4ZmYwMCkgPj4gOCxcbiAgICAgICAgICAgICAgICAgICAgaXYgJiAweGZmLFxuICAgICAgICAgICAgICAgICAgICAxXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBvcCA9IHN0ci5pbmRleE9mKCcoJyksIGVwID0gc3RyLmluZGV4T2YoJyknKTtcbiAgICAgICAgaWYgKG9wICE9PSAtMSAmJiBlcCArIDEgPT09IHN0ci5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBmbmFtZSA9IHN0ci5zdWJzdHIoMCwgb3ApO1xuICAgICAgICAgICAgdmFyIHBhcmFtcyA9IHN0ci5zdWJzdHIob3AgKyAxLCBlcCAtIChvcCArIDEpKS5zcGxpdCgnLCcpO1xuICAgICAgICAgICAgdmFyIGFscGhhID0gMTsgIC8vIFRvIGFsbG93IGNhc2UgZmFsbHRocm91Z2guXG4gICAgICAgICAgICBzd2l0Y2ggKGZuYW1lKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAncmdiYSc6XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJhbXMubGVuZ3RoICE9PSA0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYWxwaGEgPSBwYXJzZUNzc0Zsb2F0KHBhcmFtcy5wb3AoKSk7IC8vIGpzaGludCBpZ25vcmU6bGluZVxuICAgICAgICAgICAgICAgIC8vIEZhbGwgdGhyb3VnaC5cbiAgICAgICAgICAgICAgICBjYXNlICdyZ2InOlxuICAgICAgICAgICAgICAgICAgICBpZiAocGFyYW1zLmxlbmd0aCAhPT0gMykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZUNzc0ludChwYXJhbXNbMF0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VDc3NJbnQocGFyYW1zWzFdKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlQ3NzSW50KHBhcmFtc1syXSksXG4gICAgICAgICAgICAgICAgICAgICAgICBhbHBoYVxuICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2hzbGEnOlxuICAgICAgICAgICAgICAgICAgICBpZiAocGFyYW1zLmxlbmd0aCAhPT0gNCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtc1szXSA9IHBhcnNlQ3NzRmxvYXQocGFyYW1zWzNdKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhzbGEycmdiYShwYXJhbXMpO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2hzbCc6XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJhbXMubGVuZ3RoICE9PSAzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhzbGEycmdiYShwYXJhbXMpO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBoc2xhXG4gICAgICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59IHJnYmFcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBoc2xhMnJnYmEoaHNsYSkge1xuICAgICAgICB2YXIgaCA9ICgoKHBhcnNlRmxvYXQoaHNsYVswXSkgJSAzNjApICsgMzYwKSAlIDM2MCkgLyAzNjA7ICAvLyAwIC4uIDFcbiAgICAgICAgLy8gTk9URShkZWFubSk6IEFjY29yZGluZyB0byB0aGUgQ1NTIHNwZWMgcy9sIHNob3VsZCBvbmx5IGJlXG4gICAgICAgIC8vIHBlcmNlbnRhZ2VzLCBidXQgd2UgZG9uJ3QgYm90aGVyIGFuZCBsZXQgZmxvYXQgb3IgcGVyY2VudGFnZS5cbiAgICAgICAgdmFyIHMgPSBwYXJzZUNzc0Zsb2F0KGhzbGFbMV0pO1xuICAgICAgICB2YXIgbCA9IHBhcnNlQ3NzRmxvYXQoaHNsYVsyXSk7XG4gICAgICAgIHZhciBtMiA9IGwgPD0gMC41ID8gbCAqIChzICsgMSkgOiBsICsgcyAtIGwgKiBzO1xuICAgICAgICB2YXIgbTEgPSBsICogMiAtIG0yO1xuXG4gICAgICAgIHZhciByZ2JhID0gW1xuICAgICAgICAgICAgY2xhbXBDc3NCeXRlKGNzc0h1ZVRvUmdiKG0xLCBtMiwgaCArIDEgLyAzKSAqIDI1NSksXG4gICAgICAgICAgICBjbGFtcENzc0J5dGUoY3NzSHVlVG9SZ2IobTEsIG0yLCBoKSAqIDI1NSksXG4gICAgICAgICAgICBjbGFtcENzc0J5dGUoY3NzSHVlVG9SZ2IobTEsIG0yLCBoIC0gMSAvIDMpICogMjU1KVxuICAgICAgICBdO1xuXG4gICAgICAgIGlmIChoc2xhLmxlbmd0aCA9PT0gNCkge1xuICAgICAgICAgICAgcmdiYVszXSA9IGhzbGFbM107XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmdiYTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSByZ2JhXG4gICAgICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59IGhzbGFcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZ2JhMmhzbGEocmdiYSkge1xuICAgICAgICBpZiAoIXJnYmEpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJHQiBmcm9tIDAgdG8gMjU1XG4gICAgICAgIHZhciBSID0gcmdiYVswXSAvIDI1NTtcbiAgICAgICAgdmFyIEcgPSByZ2JhWzFdIC8gMjU1O1xuICAgICAgICB2YXIgQiA9IHJnYmFbMl0gLyAyNTU7XG5cbiAgICAgICAgdmFyIHZNaW4gPSBNYXRoLm1pbihSLCBHLCBCKTsgLy8gTWluLiB2YWx1ZSBvZiBSR0JcbiAgICAgICAgdmFyIHZNYXggPSBNYXRoLm1heChSLCBHLCBCKTsgLy8gTWF4LiB2YWx1ZSBvZiBSR0JcbiAgICAgICAgdmFyIGRlbHRhID0gdk1heCAtIHZNaW47IC8vIERlbHRhIFJHQiB2YWx1ZVxuXG4gICAgICAgIHZhciBMID0gKHZNYXggKyB2TWluKSAvIDI7XG4gICAgICAgIHZhciBIO1xuICAgICAgICB2YXIgUztcbiAgICAgICAgLy8gSFNMIHJlc3VsdHMgZnJvbSAwIHRvIDFcbiAgICAgICAgaWYgKGRlbHRhID09PSAwKSB7XG4gICAgICAgICAgICBIID0gMDtcbiAgICAgICAgICAgIFMgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKEwgPCAwLjUpIHtcbiAgICAgICAgICAgICAgICBTID0gZGVsdGEgLyAodk1heCArIHZNaW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgUyA9IGRlbHRhIC8gKDIgLSB2TWF4IC0gdk1pbik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBkZWx0YVIgPSAoKCh2TWF4IC0gUikgLyA2KSArIChkZWx0YSAvIDIpKSAvIGRlbHRhO1xuICAgICAgICAgICAgdmFyIGRlbHRhRyA9ICgoKHZNYXggLSBHKSAvIDYpICsgKGRlbHRhIC8gMikpIC8gZGVsdGE7XG4gICAgICAgICAgICB2YXIgZGVsdGFCID0gKCgodk1heCAtIEIpIC8gNikgKyAoZGVsdGEgLyAyKSkgLyBkZWx0YTtcblxuICAgICAgICAgICAgaWYgKFIgPT09IHZNYXgpIHtcbiAgICAgICAgICAgICAgICBIID0gZGVsdGFCIC0gZGVsdGFHO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoRyA9PT0gdk1heCkge1xuICAgICAgICAgICAgICAgIEggPSAoMSAvIDMpICsgZGVsdGFSIC0gZGVsdGFCO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoQiA9PT0gdk1heCkge1xuICAgICAgICAgICAgICAgIEggPSAoMiAvIDMpICsgZGVsdGFHIC0gZGVsdGFSO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoSCA8IDApIHtcbiAgICAgICAgICAgICAgICBIICs9IDE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChIID4gMSkge1xuICAgICAgICAgICAgICAgIEggLT0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBoc2xhID0gW0ggKiAzNjAsIFMsIExdO1xuXG4gICAgICAgIGlmIChyZ2JhWzNdICE9IG51bGwpIHtcbiAgICAgICAgICAgIGhzbGEucHVzaChyZ2JhWzNdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBoc2xhO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb2xvclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsZXZlbFxuICAgICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvdXRpbC9jb2xvclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxpZnQoY29sb3IsIGxldmVsKSB7XG4gICAgICAgIHZhciBjb2xvckFyciA9IHBhcnNlKGNvbG9yKTtcbiAgICAgICAgaWYgKGNvbG9yQXJyKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDM7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChsZXZlbCA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY29sb3JBcnJbaV0gPSBjb2xvckFycltpXSAqICgxIC0gbGV2ZWwpIHwgMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbG9yQXJyW2ldID0gKCgyNTUgLSBjb2xvckFycltpXSkgKiBsZXZlbCArIGNvbG9yQXJyW2ldKSB8IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHN0cmluZ2lmeShjb2xvckFyciwgY29sb3JBcnIubGVuZ3RoID09PSA0ID8gJ3JnYmEnIDogJ3JnYicpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbG9yXG4gICAgICogQHJldHVybiB7c3RyaW5nfVxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci91dGlsL2NvbG9yXG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9IZXgoY29sb3IsIGxldmVsKSB7XG4gICAgICAgIHZhciBjb2xvckFyciA9IHBhcnNlKGNvbG9yKTtcbiAgICAgICAgaWYgKGNvbG9yQXJyKSB7XG4gICAgICAgICAgICByZXR1cm4gKCgxIDw8IDI0KSArIChjb2xvckFyclswXSA8PCAxNikgKyAoY29sb3JBcnJbMV0gPDwgOCkgKyAoK2NvbG9yQXJyWzJdKSkudG9TdHJpbmcoMTYpLnNsaWNlKDEpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWFwIHZhbHVlIHRvIGNvbG9yLiBGYXN0ZXIgdGhhbiBtYXBUb0NvbG9yIG1ldGhvZHMgYmVjYXVzZSBjb2xvciBpcyByZXByZXNlbnRlZCBieSByZ2JhIGFycmF5XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG5vcm1hbGl6ZWRWYWx1ZSBBIGZsb2F0IGJldHdlZW4gMCBhbmQgMS5cbiAgICAgKiBAcGFyYW0ge0FycmF5LjxBcnJheS48bnVtYmVyPj59IGNvbG9ycyBMaXN0IG9mIHJnYmEgY29sb3IgYXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBbb3V0XSBNYXBwZWQgZ2JhIGNvbG9yIGFycmF5XG4gICAgICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59XG4gICAgICovXG4gICAgZnVuY3Rpb24gZmFzdE1hcFRvQ29sb3Iobm9ybWFsaXplZFZhbHVlLCBjb2xvcnMsIG91dCkge1xuICAgICAgICBpZiAoIShjb2xvcnMgJiYgY29sb3JzLmxlbmd0aClcbiAgICAgICAgICAgIHx8ICEobm9ybWFsaXplZFZhbHVlID49IDAgJiYgbm9ybWFsaXplZFZhbHVlIDw9IDEpXG4gICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIG91dCA9IG91dCB8fCBbMCwgMCwgMCwgMF07XG4gICAgICAgIHZhciB2YWx1ZSA9IG5vcm1hbGl6ZWRWYWx1ZSAqIChjb2xvcnMubGVuZ3RoIC0gMSk7XG4gICAgICAgIHZhciBsZWZ0SW5kZXggPSBNYXRoLmZsb29yKHZhbHVlKTtcbiAgICAgICAgdmFyIHJpZ2h0SW5kZXggPSBNYXRoLmNlaWwodmFsdWUpO1xuICAgICAgICB2YXIgbGVmdENvbG9yID0gY29sb3JzW2xlZnRJbmRleF07XG4gICAgICAgIHZhciByaWdodENvbG9yID0gY29sb3JzW3JpZ2h0SW5kZXhdO1xuICAgICAgICB2YXIgZHYgPSB2YWx1ZSAtIGxlZnRJbmRleDtcbiAgICAgICAgb3V0WzBdID0gY2xhbXBDc3NCeXRlKGxlcnAobGVmdENvbG9yWzBdLCByaWdodENvbG9yWzBdLCBkdikpO1xuICAgICAgICBvdXRbMV0gPSBjbGFtcENzc0J5dGUobGVycChsZWZ0Q29sb3JbMV0sIHJpZ2h0Q29sb3JbMV0sIGR2KSk7XG4gICAgICAgIG91dFsyXSA9IGNsYW1wQ3NzQnl0ZShsZXJwKGxlZnRDb2xvclsyXSwgcmlnaHRDb2xvclsyXSwgZHYpKTtcbiAgICAgICAgb3V0WzNdID0gY2xhbXBDc3NCeXRlKGxlcnAobGVmdENvbG9yWzNdLCByaWdodENvbG9yWzNdLCBkdikpO1xuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbm9ybWFsaXplZFZhbHVlIEEgZmxvYXQgYmV0d2VlbiAwIGFuZCAxLlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPHN0cmluZz59IGNvbG9ycyBDb2xvciBsaXN0LlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IGZ1bGxPdXRwdXQgRGVmYXVsdCBmYWxzZS5cbiAgICAgKiBAcmV0dXJuIHsoc3RyaW5nfE9iamVjdCl9IFJlc3VsdCBjb2xvci4gSWYgZnVsbE91dHB1dCxcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7Y29sb3I6IC4uLiwgbGVmdEluZGV4OiAuLi4sIHJpZ2h0SW5kZXg6IC4uLiwgdmFsdWU6IC4uLn0sXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL3V0aWwvY29sb3JcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXBUb0NvbG9yKG5vcm1hbGl6ZWRWYWx1ZSwgY29sb3JzLCBmdWxsT3V0cHV0KSB7XG4gICAgICAgIGlmICghKGNvbG9ycyAmJiBjb2xvcnMubGVuZ3RoKVxuICAgICAgICAgICAgfHwgIShub3JtYWxpemVkVmFsdWUgPj0gMCAmJiBub3JtYWxpemVkVmFsdWUgPD0gMSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdmFsdWUgPSBub3JtYWxpemVkVmFsdWUgKiAoY29sb3JzLmxlbmd0aCAtIDEpO1xuICAgICAgICB2YXIgbGVmdEluZGV4ID0gTWF0aC5mbG9vcih2YWx1ZSk7XG4gICAgICAgIHZhciByaWdodEluZGV4ID0gTWF0aC5jZWlsKHZhbHVlKTtcbiAgICAgICAgdmFyIGxlZnRDb2xvciA9IHBhcnNlKGNvbG9yc1tsZWZ0SW5kZXhdKTtcbiAgICAgICAgdmFyIHJpZ2h0Q29sb3IgPSBwYXJzZShjb2xvcnNbcmlnaHRJbmRleF0pO1xuICAgICAgICB2YXIgZHYgPSB2YWx1ZSAtIGxlZnRJbmRleDtcblxuICAgICAgICB2YXIgY29sb3IgPSBzdHJpbmdpZnkoXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgY2xhbXBDc3NCeXRlKGxlcnAobGVmdENvbG9yWzBdLCByaWdodENvbG9yWzBdLCBkdikpLFxuICAgICAgICAgICAgICAgIGNsYW1wQ3NzQnl0ZShsZXJwKGxlZnRDb2xvclsxXSwgcmlnaHRDb2xvclsxXSwgZHYpKSxcbiAgICAgICAgICAgICAgICBjbGFtcENzc0J5dGUobGVycChsZWZ0Q29sb3JbMl0sIHJpZ2h0Q29sb3JbMl0sIGR2KSksXG4gICAgICAgICAgICAgICAgY2xhbXBDc3NGbG9hdChsZXJwKGxlZnRDb2xvclszXSwgcmlnaHRDb2xvclszXSwgZHYpKVxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICdyZ2JhJ1xuICAgICAgICApO1xuXG4gICAgICAgIHJldHVybiBmdWxsT3V0cHV0XG4gICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICBjb2xvcjogY29sb3IsXG4gICAgICAgICAgICAgICAgbGVmdEluZGV4OiBsZWZ0SW5kZXgsXG4gICAgICAgICAgICAgICAgcmlnaHRJbmRleDogcmlnaHRJbmRleCxcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDogY29sb3I7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbG9yXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBoIDAgfiAzNjAsIGlnbm9yZSB3aGVuIG51bGwuXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBzIDAgfiAxLCBpZ25vcmUgd2hlbiBudWxsLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gbCAwIH4gMSwgaWdub3JlIHdoZW4gbnVsbC5cbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IENvbG9yIHN0cmluZyBpbiByZ2JhIGZvcm1hdC5cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvdXRpbC9jb2xvclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1vZGlmeUhTTChjb2xvciwgaCwgcywgbCkge1xuICAgICAgICBjb2xvciA9IHBhcnNlKGNvbG9yKTtcblxuICAgICAgICBpZiAoY29sb3IpIHtcbiAgICAgICAgICAgIGNvbG9yID0gcmdiYTJoc2xhKGNvbG9yKTtcbiAgICAgICAgICAgIGggIT0gbnVsbCAmJiAoY29sb3JbMF0gPSBjbGFtcENzc0FuZ2xlKGgpKTtcbiAgICAgICAgICAgIHMgIT0gbnVsbCAmJiAoY29sb3JbMV0gPSBwYXJzZUNzc0Zsb2F0KHMpKTtcbiAgICAgICAgICAgIGwgIT0gbnVsbCAmJiAoY29sb3JbMl0gPSBwYXJzZUNzc0Zsb2F0KGwpKTtcblxuICAgICAgICAgICAgcmV0dXJuIHN0cmluZ2lmeShoc2xhMnJnYmEoY29sb3IpLCAncmdiYScpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbG9yXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBhbHBoYSAwIH4gMVxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gQ29sb3Igc3RyaW5nIGluIHJnYmEgZm9ybWF0LlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci91dGlsL2NvbG9yXG4gICAgICovXG4gICAgZnVuY3Rpb24gbW9kaWZ5QWxwaGEoY29sb3IsIGFscGhhKSB7XG4gICAgICAgIGNvbG9yID0gcGFyc2UoY29sb3IpO1xuXG4gICAgICAgIGlmIChjb2xvciAmJiBhbHBoYSAhPSBudWxsKSB7XG4gICAgICAgICAgICBjb2xvclszXSA9IGNsYW1wQ3NzRmxvYXQoYWxwaGEpO1xuICAgICAgICAgICAgcmV0dXJuIHN0cmluZ2lmeShjb2xvciwgJ3JnYmEnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPHN0cmluZz59IGNvbG9ycyBDb2xvciBsaXN0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlICdyZ2JhJywgJ2hzdmEnLCAuLi5cbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFJlc3VsdCBjb2xvci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdHJpbmdpZnkoYXJyQ29sb3IsIHR5cGUpIHtcbiAgICAgICAgdmFyIGNvbG9yU3RyID0gYXJyQ29sb3JbMF0gKyAnLCcgKyBhcnJDb2xvclsxXSArICcsJyArIGFyckNvbG9yWzJdO1xuICAgICAgICBpZiAodHlwZSA9PT0gJ3JnYmEnIHx8IHR5cGUgPT09ICdoc3ZhJyB8fCB0eXBlID09PSAnaHNsYScpIHtcbiAgICAgICAgICAgIGNvbG9yU3RyICs9ICcsJyArIGFyckNvbG9yWzNdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0eXBlICsgJygnICsgY29sb3JTdHIgKyAnKSc7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgICAgIHBhcnNlOiBwYXJzZSxcbiAgICAgICAgbGlmdDogbGlmdCxcbiAgICAgICAgdG9IZXg6IHRvSGV4LFxuICAgICAgICBmYXN0TWFwVG9Db2xvcjogZmFzdE1hcFRvQ29sb3IsXG4gICAgICAgIG1hcFRvQ29sb3I6IG1hcFRvQ29sb3IsXG4gICAgICAgIG1vZGlmeUhTTDogbW9kaWZ5SFNMLFxuICAgICAgICBtb2RpZnlBbHBoYTogbW9kaWZ5QWxwaGEsXG4gICAgICAgIHN0cmluZ2lmeTogc3RyaW5naWZ5XG4gICAgfTtcblxuXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi96cmVuZGVyL2xpYi90b29sL2NvbG9yLmpzXG4gKiogbW9kdWxlIGlkID0gMTlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlxuICAgICAgICB2YXIgY29uZmlnID0gcmVxdWlyZSgnLi4vY29uZmlnJyk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBleHBvcnRzIHpyZW5kZXIvdG9vbC9sb2dcbiAgICAgICAgICogQGF1dGhvciBLZW5lciAoQEtlbmVyLeael+WzsCwga2VuZXIubGluZmVuZ0BnbWFpbC5jb20pXG4gICAgICAgICAqL1xuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKGNvbmZpZy5kZWJ1Z01vZGUgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjb25maWcuZGVidWdNb2RlID09IDEpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrIGluIGFyZ3VtZW50cykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYXJndW1lbnRzW2tdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjb25maWcuZGVidWdNb2RlID4gMSkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGsgaW4gYXJndW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGFyZ3VtZW50c1trXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8qIGZvciBkZWJ1Z1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24obWVzKSB7XG4gICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnd3JvbmctbWVzc2FnZScpLmlubmVySFRNTCA9XG4gICAgICAgICAgICAgICAgbWVzICsgJyAnICsgKG5ldyBEYXRlKCkgLSAwKVxuICAgICAgICAgICAgICAgICsgJzxici8+JyBcbiAgICAgICAgICAgICAgICArIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd3cm9uZy1tZXNzYWdlJykuaW5uZXJIVE1MO1xuICAgICAgICB9O1xuICAgICAgICAqL1xuICAgIFxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34venJlbmRlci9saWIvY29yZS9sb2cuanNcbiAqKiBtb2R1bGUgaWQgPSAyMFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXG4gICAgdmFyIGRwciA9IDE7XG4gICAgLy8gSWYgaW4gYnJvd3NlciBlbnZpcm9ubWVudFxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBkcHIgPSBNYXRoLm1heCh3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxLCAxKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogY29uZmln6buY6K6k6YWN572u6aG5XG4gICAgICogQGV4cG9ydHMgenJlbmRlci9jb25maWdcbiAgICAgKiBAYXV0aG9yIEtlbmVyIChAS2VuZXIt5p6X5bOwLCBrZW5lci5saW5mZW5nQGdtYWlsLmNvbSlcbiAgICAgKi9cbiAgICB2YXIgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogZGVidWfml6Xlv5fpgInpobnvvJpjYXRjaEJydXNoRXhjZXB0aW9u5Li6dHJ1ZeS4i+acieaViFxuICAgICAgICAgKiAwIDog5LiN55Sf5oiQZGVidWfmlbDmja7vvIzlj5HluIPnlKhcbiAgICAgICAgICogMSA6IOW8guW4uOaKm+WHuu+8jOiwg+ivleeUqFxuICAgICAgICAgKiAyIDog5o6n5Yi25Y+w6L6T5Ye677yM6LCD6K+V55SoXG4gICAgICAgICAqL1xuICAgICAgICBkZWJ1Z01vZGU6IDAsXG5cbiAgICAgICAgLy8gcmV0aW5hIOWxj+W5leS8mOWMllxuICAgICAgICBkZXZpY2VQaXhlbFJhdGlvOiBkcHJcbiAgICB9O1xuICAgIG1vZHVsZS5leHBvcnRzID0gY29uZmlnO1xuXG5cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3pyZW5kZXIvbGliL2NvbmZpZy5qc1xuICoqIG1vZHVsZSBpZCA9IDIxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIE1peGluIGZvciBkcmF3aW5nIHRleHQgaW4gYSBlbGVtZW50IGJvdW5kaW5nIHJlY3RcbiAqIEBtb2R1bGUgenJlbmRlci9taXhpbi9SZWN0VGV4dFxuICovXG5cblxuXG4gICAgdmFyIHRleHRDb250YWluID0gcmVxdWlyZSgnLi4vLi4vY29udGFpbi90ZXh0Jyk7XG4gICAgdmFyIEJvdW5kaW5nUmVjdCA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvQm91bmRpbmdSZWN0Jyk7XG5cbiAgICB2YXIgdG1wUmVjdCA9IG5ldyBCb3VuZGluZ1JlY3QoKTtcblxuICAgIHZhciBSZWN0VGV4dCA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gICAgZnVuY3Rpb24gcGFyc2VQZXJjZW50KHZhbHVlLCBtYXhWYWx1ZSkge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgaWYgKHZhbHVlLmxhc3RJbmRleE9mKCclJykgPj0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUZsb2F0KHZhbHVlKSAvIDEwMCAqIG1heFZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICBSZWN0VGV4dC5wcm90b3R5cGUgPSB7XG5cbiAgICAgICAgY29uc3RydWN0b3I6IFJlY3RUZXh0LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEcmF3IHRleHQgaW4gYSByZWN0IHdpdGggc3BlY2lmaWVkIHBvc2l0aW9uLlxuICAgICAgICAgKiBAcGFyYW0gIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0fSBjdHhcbiAgICAgICAgICogQHBhcmFtICB7T2JqZWN0fSByZWN0IERpc3BsYXlhYmxlIHJlY3RcbiAgICAgICAgICogQHJldHVybiB7T2JqZWN0fSB0ZXh0UmVjdCBBbHRlcm5hdGl2ZSBwcmVjYWxjdWxhdGVkIHRleHQgYm91bmRpbmcgcmVjdFxuICAgICAgICAgKi9cbiAgICAgICAgZHJhd1JlY3RUZXh0OiBmdW5jdGlvbiAoY3R4LCByZWN0LCB0ZXh0UmVjdCkge1xuICAgICAgICAgICAgdmFyIHN0eWxlID0gdGhpcy5zdHlsZTtcbiAgICAgICAgICAgIHZhciB0ZXh0ID0gc3R5bGUudGV4dDtcbiAgICAgICAgICAgIC8vIENvbnZlcnQgdG8gc3RyaW5nXG4gICAgICAgICAgICB0ZXh0ICE9IG51bGwgJiYgKHRleHQgKz0gJycpO1xuICAgICAgICAgICAgaWYgKCF0ZXh0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBGSVhNRVxuICAgICAgICAgICAgY3R4LnNhdmUoKTtcblxuICAgICAgICAgICAgdmFyIHg7XG4gICAgICAgICAgICB2YXIgeTtcbiAgICAgICAgICAgIHZhciB0ZXh0UG9zaXRpb24gPSBzdHlsZS50ZXh0UG9zaXRpb247XG4gICAgICAgICAgICB2YXIgZGlzdGFuY2UgPSBzdHlsZS50ZXh0RGlzdGFuY2U7XG4gICAgICAgICAgICB2YXIgYWxpZ24gPSBzdHlsZS50ZXh0QWxpZ247XG4gICAgICAgICAgICB2YXIgZm9udCA9IHN0eWxlLnRleHRGb250IHx8IHN0eWxlLmZvbnQ7XG4gICAgICAgICAgICB2YXIgYmFzZWxpbmUgPSBzdHlsZS50ZXh0QmFzZWxpbmU7XG4gICAgICAgICAgICB2YXIgdmVydGljYWxBbGlnbiA9IHN0eWxlLnRleHRWZXJ0aWNhbEFsaWduO1xuXG4gICAgICAgICAgICB0ZXh0UmVjdCA9IHRleHRSZWN0IHx8IHRleHRDb250YWluLmdldEJvdW5kaW5nUmVjdCh0ZXh0LCBmb250LCBhbGlnbiwgYmFzZWxpbmUpO1xuXG4gICAgICAgICAgICAvLyBUcmFuc2Zvcm0gcmVjdCB0byB2aWV3IHNwYWNlXG4gICAgICAgICAgICB2YXIgdHJhbnNmb3JtID0gdGhpcy50cmFuc2Zvcm07XG4gICAgICAgICAgICBpZiAoIXN0eWxlLnRleHRUcmFuc2Zvcm0pIHtcbiAgICAgICAgICAgICAgICBpZiAodHJhbnNmb3JtKSB7XG4gICAgICAgICAgICAgICAgICAgIHRtcFJlY3QuY29weShyZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgdG1wUmVjdC5hcHBseVRyYW5zZm9ybSh0cmFuc2Zvcm0pO1xuICAgICAgICAgICAgICAgICAgICByZWN0ID0gdG1wUmVjdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFRyYW5zZm9ybShjdHgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBUZXh0IHBvc2l0aW9uIHJlcHJlc2VudGVkIGJ5IGNvb3JkXG4gICAgICAgICAgICBpZiAodGV4dFBvc2l0aW9uIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgICAgICAvLyBQZXJjZW50XG4gICAgICAgICAgICAgICAgeCA9IHJlY3QueCArIHBhcnNlUGVyY2VudCh0ZXh0UG9zaXRpb25bMF0sIHJlY3Qud2lkdGgpO1xuICAgICAgICAgICAgICAgIHkgPSByZWN0LnkgKyBwYXJzZVBlcmNlbnQodGV4dFBvc2l0aW9uWzFdLCByZWN0LmhlaWdodCk7XG4gICAgICAgICAgICAgICAgYWxpZ24gPSBhbGlnbiB8fCAnbGVmdCc7XG4gICAgICAgICAgICAgICAgYmFzZWxpbmUgPSBiYXNlbGluZSB8fCAndG9wJztcblxuICAgICAgICAgICAgICAgIGlmICh2ZXJ0aWNhbEFsaWduKSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAodmVydGljYWxBbGlnbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnbWlkZGxlJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5IC09IHRleHRSZWN0LmhlaWdodCAvIDIgLSB0ZXh0UmVjdC5saW5lSGVpZ2h0IC8gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeSAtPSB0ZXh0UmVjdC5oZWlnaHQgLSB0ZXh0UmVjdC5saW5lSGVpZ2h0IC8gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeSArPSB0ZXh0UmVjdC5saW5lSGVpZ2h0IC8gMjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBGb3JjZSBic2VsaW5lIHRvIGJlIG1pZGRsZVxuICAgICAgICAgICAgICAgICAgICBiYXNlbGluZSA9ICdtaWRkbGUnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciByZXMgPSB0ZXh0Q29udGFpbi5hZGp1c3RUZXh0UG9zaXRpb25PblJlY3QoXG4gICAgICAgICAgICAgICAgICAgIHRleHRQb3NpdGlvbiwgcmVjdCwgdGV4dFJlY3QsIGRpc3RhbmNlXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB4ID0gcmVzLng7XG4gICAgICAgICAgICAgICAgeSA9IHJlcy55O1xuICAgICAgICAgICAgICAgIC8vIERlZmF1bHQgYWxpZ24gYW5kIGJhc2VsaW5lIHdoZW4gaGFzIHRleHRQb3NpdGlvblxuICAgICAgICAgICAgICAgIGFsaWduID0gYWxpZ24gfHwgcmVzLnRleHRBbGlnbjtcbiAgICAgICAgICAgICAgICBiYXNlbGluZSA9IGJhc2VsaW5lIHx8IHJlcy50ZXh0QmFzZWxpbmU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFVzZSBjYW52YXMgZGVmYXVsdCBsZWZ0IHRleHRBbGlnbi4gR2l2aW5nIGludmFsaWQgdmFsdWUgd2lsbCBjYXVzZSBzdGF0ZSBub3QgY2hhbmdlXG4gICAgICAgICAgICBjdHgudGV4dEFsaWduID0gYWxpZ24gfHwgJ2xlZnQnO1xuICAgICAgICAgICAgLy8gVXNlIGNhbnZhcyBkZWZhdWx0IGFscGhhYmV0aWMgYmFzZWxpbmVcbiAgICAgICAgICAgIGN0eC50ZXh0QmFzZWxpbmUgPSBiYXNlbGluZSB8fCAnYWxwaGFiZXRpYyc7XG5cbiAgICAgICAgICAgIHZhciB0ZXh0RmlsbCA9IHN0eWxlLnRleHRGaWxsO1xuICAgICAgICAgICAgdmFyIHRleHRTdHJva2UgPSBzdHlsZS50ZXh0U3Ryb2tlO1xuICAgICAgICAgICAgdGV4dEZpbGwgJiYgKGN0eC5maWxsU3R5bGUgPSB0ZXh0RmlsbCk7XG4gICAgICAgICAgICB0ZXh0U3Ryb2tlICYmIChjdHguc3Ryb2tlU3R5bGUgPSB0ZXh0U3Ryb2tlKTtcblxuICAgICAgICAgICAgLy8gVE9ETyBJbnZhbGlkIGZvbnRcbiAgICAgICAgICAgIGN0eC5mb250ID0gZm9udCB8fCAnMTJweCBzYW5zLXNlcmlmJztcblxuICAgICAgICAgICAgLy8gVGV4dCBzaGFkb3dcbiAgICAgICAgICAgIC8vIEFsd2F5cyBzZXQgc2hhZG93Qmx1ciBhbmQgc2hhZG93T2Zmc2V0IHRvIGF2b2lkIGxlYWsgZnJvbSBkaXNwbGF5YWJsZVxuICAgICAgICAgICAgY3R4LnNoYWRvd0JsdXIgPSBzdHlsZS50ZXh0U2hhZG93Qmx1cjtcbiAgICAgICAgICAgIGN0eC5zaGFkb3dDb2xvciA9IHN0eWxlLnRleHRTaGFkb3dDb2xvciB8fCAndHJhbnNwYXJlbnQnO1xuICAgICAgICAgICAgY3R4LnNoYWRvd09mZnNldFggPSBzdHlsZS50ZXh0U2hhZG93T2Zmc2V0WDtcbiAgICAgICAgICAgIGN0eC5zaGFkb3dPZmZzZXRZID0gc3R5bGUudGV4dFNoYWRvd09mZnNldFk7XG5cbiAgICAgICAgICAgIHZhciB0ZXh0TGluZXMgPSB0ZXh0LnNwbGl0KCdcXG4nKTtcblxuICAgICAgICAgICAgaWYgKHN0eWxlLnRleHRSb3RhdGlvbikge1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybSAmJiBjdHgudHJhbnNsYXRlKHRyYW5zZm9ybVs0XSwgdHJhbnNmb3JtWzVdKTtcbiAgICAgICAgICAgICAgICBjdHgucm90YXRlKHN0eWxlLnRleHRSb3RhdGlvbik7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtICYmIGN0eC50cmFuc2xhdGUoLXRyYW5zZm9ybVs0XSwgLXRyYW5zZm9ybVs1XSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGV4dExpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGV4dEZpbGwgJiYgY3R4LmZpbGxUZXh0KHRleHRMaW5lc1tpXSwgeCwgeSk7XG4gICAgICAgICAgICAgICAgdGV4dFN0cm9rZSAmJiBjdHguc3Ryb2tlVGV4dCh0ZXh0TGluZXNbaV0sIHgsIHkpO1xuICAgICAgICAgICAgICAgIHkgKz0gdGV4dFJlY3QubGluZUhlaWdodDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IFJlY3RUZXh0O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34venJlbmRlci9saWIvZ3JhcGhpYy9taXhpbi9SZWN0VGV4dC5qc1xuICoqIG1vZHVsZSBpZCA9IDIyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcblxuICAgIHZhciB0ZXh0V2lkdGhDYWNoZSA9IHt9O1xuICAgIHZhciB0ZXh0V2lkdGhDYWNoZUNvdW50ZXIgPSAwO1xuICAgIHZhciBURVhUX0NBQ0hFX01BWCA9IDUwMDA7XG5cbiAgICB2YXIgdXRpbCA9IHJlcXVpcmUoJy4uL2NvcmUvdXRpbCcpO1xuICAgIHZhciBCb3VuZGluZ1JlY3QgPSByZXF1aXJlKCcuLi9jb3JlL0JvdW5kaW5nUmVjdCcpO1xuICAgIHZhciByZXRyaWV2ZSA9IHV0aWwucmV0cmlldmU7XG5cbiAgICBmdW5jdGlvbiBnZXRUZXh0V2lkdGgodGV4dCwgdGV4dEZvbnQpIHtcbiAgICAgICAgdmFyIGtleSA9IHRleHQgKyAnOicgKyB0ZXh0Rm9udDtcbiAgICAgICAgaWYgKHRleHRXaWR0aENhY2hlW2tleV0pIHtcbiAgICAgICAgICAgIHJldHVybiB0ZXh0V2lkdGhDYWNoZVtrZXldO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRleHRMaW5lcyA9ICh0ZXh0ICsgJycpLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgdmFyIHdpZHRoID0gMDtcblxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHRleHRMaW5lcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIC8vIG1lYXN1cmVUZXh0IOWPr+S7peiiq+imhuebluS7peWFvOWuueS4jeaUr+aMgSBDYW52YXMg55qE546v5aKDXG4gICAgICAgICAgICB3aWR0aCA9IE1hdGgubWF4KHRleHRDb250YWluLm1lYXN1cmVUZXh0KHRleHRMaW5lc1tpXSwgdGV4dEZvbnQpLndpZHRoLCB3aWR0aCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGV4dFdpZHRoQ2FjaGVDb3VudGVyID4gVEVYVF9DQUNIRV9NQVgpIHtcbiAgICAgICAgICAgIHRleHRXaWR0aENhY2hlQ291bnRlciA9IDA7XG4gICAgICAgICAgICB0ZXh0V2lkdGhDYWNoZSA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIHRleHRXaWR0aENhY2hlQ291bnRlcisrO1xuICAgICAgICB0ZXh0V2lkdGhDYWNoZVtrZXldID0gd2lkdGg7XG5cbiAgICAgICAgcmV0dXJuIHdpZHRoO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFRleHRSZWN0KHRleHQsIHRleHRGb250LCB0ZXh0QWxpZ24sIHRleHRCYXNlbGluZSkge1xuICAgICAgICB2YXIgdGV4dExpbmVMZW4gPSAoKHRleHQgfHwgJycpICsgJycpLnNwbGl0KCdcXG4nKS5sZW5ndGg7XG5cbiAgICAgICAgdmFyIHdpZHRoID0gZ2V0VGV4dFdpZHRoKHRleHQsIHRleHRGb250KTtcbiAgICAgICAgLy8gRklYTUUg6auY5bqm6K6h566X5q+U6L6D57KX5pq0XG4gICAgICAgIHZhciBsaW5lSGVpZ2h0ID0gZ2V0VGV4dFdpZHRoKCflm70nLCB0ZXh0Rm9udCk7XG4gICAgICAgIHZhciBoZWlnaHQgPSB0ZXh0TGluZUxlbiAqIGxpbmVIZWlnaHQ7XG5cbiAgICAgICAgdmFyIHJlY3QgPSBuZXcgQm91bmRpbmdSZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAvLyBUZXh0IGhhcyBhIHNwZWNpYWwgbGluZSBoZWlnaHQgcHJvcGVydHlcbiAgICAgICAgcmVjdC5saW5lSGVpZ2h0ID0gbGluZUhlaWdodDtcblxuICAgICAgICBzd2l0Y2ggKHRleHRCYXNlbGluZSkge1xuICAgICAgICAgICAgY2FzZSAnYm90dG9tJzpcbiAgICAgICAgICAgIGNhc2UgJ2FscGhhYmV0aWMnOlxuICAgICAgICAgICAgICAgIHJlY3QueSAtPSBsaW5lSGVpZ2h0O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbWlkZGxlJzpcbiAgICAgICAgICAgICAgICByZWN0LnkgLT0gbGluZUhlaWdodCAvIDI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAvLyBjYXNlICdoYW5naW5nJzpcbiAgICAgICAgICAgIC8vIGNhc2UgJ3RvcCc6XG4gICAgICAgIH1cblxuICAgICAgICAvLyBGSVhNRSBSaWdodCB0byBsZWZ0IGxhbmd1YWdlXG4gICAgICAgIHN3aXRjaCAodGV4dEFsaWduKSB7XG4gICAgICAgICAgICBjYXNlICdlbmQnOlxuICAgICAgICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICAgICAgICAgIHJlY3QueCAtPSByZWN0LndpZHRoO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnY2VudGVyJzpcbiAgICAgICAgICAgICAgICByZWN0LnggLT0gcmVjdC53aWR0aCAvIDI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAvLyBjYXNlICdzdGFydCc6XG4gICAgICAgICAgICAvLyBjYXNlICdsZWZ0JzpcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZWN0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkanVzdFRleHRQb3NpdGlvbk9uUmVjdCh0ZXh0UG9zaXRpb24sIHJlY3QsIHRleHRSZWN0LCBkaXN0YW5jZSkge1xuXG4gICAgICAgIHZhciB4ID0gcmVjdC54O1xuICAgICAgICB2YXIgeSA9IHJlY3QueTtcblxuICAgICAgICB2YXIgaGVpZ2h0ID0gcmVjdC5oZWlnaHQ7XG4gICAgICAgIHZhciB3aWR0aCA9IHJlY3Qud2lkdGg7XG5cbiAgICAgICAgdmFyIHRleHRIZWlnaHQgPSB0ZXh0UmVjdC5oZWlnaHQ7XG5cbiAgICAgICAgdmFyIGhhbGZIZWlnaHQgPSBoZWlnaHQgLyAyIC0gdGV4dEhlaWdodCAvIDI7XG5cbiAgICAgICAgdmFyIHRleHRBbGlnbiA9ICdsZWZ0JztcblxuICAgICAgICBzd2l0Y2ggKHRleHRQb3NpdGlvbikge1xuICAgICAgICAgICAgY2FzZSAnbGVmdCc6XG4gICAgICAgICAgICAgICAgeCAtPSBkaXN0YW5jZTtcbiAgICAgICAgICAgICAgICB5ICs9IGhhbGZIZWlnaHQ7XG4gICAgICAgICAgICAgICAgdGV4dEFsaWduID0gJ3JpZ2h0JztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgICAgICAgICB4ICs9IGRpc3RhbmNlICsgd2lkdGg7XG4gICAgICAgICAgICAgICAgeSArPSBoYWxmSGVpZ2h0O1xuICAgICAgICAgICAgICAgIHRleHRBbGlnbiA9ICdsZWZ0JztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3RvcCc6XG4gICAgICAgICAgICAgICAgeCArPSB3aWR0aCAvIDI7XG4gICAgICAgICAgICAgICAgeSAtPSBkaXN0YW5jZSArIHRleHRIZWlnaHQ7XG4gICAgICAgICAgICAgICAgdGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdib3R0b20nOlxuICAgICAgICAgICAgICAgIHggKz0gd2lkdGggLyAyO1xuICAgICAgICAgICAgICAgIHkgKz0gaGVpZ2h0ICsgZGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgdGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdpbnNpZGUnOlxuICAgICAgICAgICAgICAgIHggKz0gd2lkdGggLyAyO1xuICAgICAgICAgICAgICAgIHkgKz0gaGFsZkhlaWdodDtcbiAgICAgICAgICAgICAgICB0ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2luc2lkZUxlZnQnOlxuICAgICAgICAgICAgICAgIHggKz0gZGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgeSArPSBoYWxmSGVpZ2h0O1xuICAgICAgICAgICAgICAgIHRleHRBbGlnbiA9ICdsZWZ0JztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2luc2lkZVJpZ2h0JzpcbiAgICAgICAgICAgICAgICB4ICs9IHdpZHRoIC0gZGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgeSArPSBoYWxmSGVpZ2h0O1xuICAgICAgICAgICAgICAgIHRleHRBbGlnbiA9ICdyaWdodCc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdpbnNpZGVUb3AnOlxuICAgICAgICAgICAgICAgIHggKz0gd2lkdGggLyAyO1xuICAgICAgICAgICAgICAgIHkgKz0gZGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgdGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdpbnNpZGVCb3R0b20nOlxuICAgICAgICAgICAgICAgIHggKz0gd2lkdGggLyAyO1xuICAgICAgICAgICAgICAgIHkgKz0gaGVpZ2h0IC0gdGV4dEhlaWdodCAtIGRpc3RhbmNlO1xuICAgICAgICAgICAgICAgIHRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnaW5zaWRlVG9wTGVmdCc6XG4gICAgICAgICAgICAgICAgeCArPSBkaXN0YW5jZTtcbiAgICAgICAgICAgICAgICB5ICs9IGRpc3RhbmNlO1xuICAgICAgICAgICAgICAgIHRleHRBbGlnbiA9ICdsZWZ0JztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2luc2lkZVRvcFJpZ2h0JzpcbiAgICAgICAgICAgICAgICB4ICs9IHdpZHRoIC0gZGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgeSArPSBkaXN0YW5jZTtcbiAgICAgICAgICAgICAgICB0ZXh0QWxpZ24gPSAncmlnaHQnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnaW5zaWRlQm90dG9tTGVmdCc6XG4gICAgICAgICAgICAgICAgeCArPSBkaXN0YW5jZTtcbiAgICAgICAgICAgICAgICB5ICs9IGhlaWdodCAtIHRleHRIZWlnaHQgLSBkaXN0YW5jZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2luc2lkZUJvdHRvbVJpZ2h0JzpcbiAgICAgICAgICAgICAgICB4ICs9IHdpZHRoIC0gZGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgeSArPSBoZWlnaHQgLSB0ZXh0SGVpZ2h0IC0gZGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgdGV4dEFsaWduID0gJ3JpZ2h0JztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB4OiB4LFxuICAgICAgICAgICAgeTogeSxcbiAgICAgICAgICAgIHRleHRBbGlnbjogdGV4dEFsaWduLFxuICAgICAgICAgICAgdGV4dEJhc2VsaW5lOiAndG9wJ1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNob3cgZWxsaXBzaXMgaWYgb3ZlcmZsb3cuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9IHRleHRcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9IGNvbnRhaW5lcldpZHRoXG4gICAgICogQHBhcmFtICB7c3RyaW5nfSB0ZXh0Rm9udFxuICAgICAqIEBwYXJhbSAge251bWJlcn0gW2VsbGlwc2lzPScuLi4nXVxuICAgICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBbb3B0aW9ucy5tYXhJdGVyYXRpb25zPTNdXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBbb3B0aW9ucy5taW5DaGFyPTBdIElmIHRydW5jYXRlIHJlc3VsdCBhcmUgbGVzc1xuICAgICAqICAgICAgICAgICAgICAgICAgdGhlbiBtaW5DaGFyLCBlbGxpcHNpcyB3aWxsIG5vdCBzaG93LCB3aGljaCBpc1xuICAgICAqICAgICAgICAgICAgICAgICAgYmV0dGVyIGZvciB1c2VyIGhpbnQgaW4gc29tZSBjYXNlcy5cbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IFtvcHRpb25zLnBsYWNlaG9sZGVyPScnXSBXaGVuIGFsbCB0cnVuY2F0ZWQsIHVzZSB0aGUgcGxhY2Vob2xkZXIuXG4gICAgICogQHJldHVybiB7c3RyaW5nfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRydW5jYXRlVGV4dCh0ZXh0LCBjb250YWluZXJXaWR0aCwgdGV4dEZvbnQsIGVsbGlwc2lzLCBvcHRpb25zKSB7XG4gICAgICAgIGlmICghY29udGFpbmVyV2lkdGgpIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuXG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgICAgIGVsbGlwc2lzID0gcmV0cmlldmUoZWxsaXBzaXMsICcuLi4nKTtcbiAgICAgICAgdmFyIG1heEl0ZXJhdGlvbnMgPSByZXRyaWV2ZShvcHRpb25zLm1heEl0ZXJhdGlvbnMsIDIpO1xuICAgICAgICB2YXIgbWluQ2hhciA9IHJldHJpZXZlKG9wdGlvbnMubWluQ2hhciwgMCk7XG4gICAgICAgIC8vIEZJWE1FXG4gICAgICAgIC8vIE90aGVyIGxhbmd1YWdlcz9cbiAgICAgICAgdmFyIGNuQ2hhcldpZHRoID0gZ2V0VGV4dFdpZHRoKCflm70nLCB0ZXh0Rm9udCk7XG4gICAgICAgIC8vIEZJWE1FXG4gICAgICAgIC8vIENvbnNpZGVyIHByb3BvcnRpb25hbCBmb250P1xuICAgICAgICB2YXIgYXNjQ2hhcldpZHRoID0gZ2V0VGV4dFdpZHRoKCdhJywgdGV4dEZvbnQpO1xuICAgICAgICB2YXIgcGxhY2Vob2xkZXIgPSByZXRyaWV2ZShvcHRpb25zLnBsYWNlaG9sZGVyLCAnJyk7XG5cbiAgICAgICAgLy8gRXhhbXBsZSAxOiBtaW5DaGFyOiAzLCB0ZXh0OiAnYXNkZnp4Y3YnLCB0cnVuY2F0ZSByZXN1bHQ6ICdhc2RmJywgYnV0IG5vdDogJ2EuLi4nLlxuICAgICAgICAvLyBFeGFtcGxlIDI6IG1pbkNoYXI6IDMsIHRleHQ6ICfnu7TluqYnLCB0cnVuY2F0ZSByZXN1bHQ6ICfnu7QnLCBidXQgbm90OiAnLi4uJy5cbiAgICAgICAgdmFyIGNvbnRlbnRXaWR0aCA9IGNvbnRhaW5lcldpZHRoID0gTWF0aC5tYXgoMCwgY29udGFpbmVyV2lkdGggLSAxKTsgLy8gUmVzZXJ2ZSBzb21lIGdhcC5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtaW5DaGFyICYmIGNvbnRlbnRXaWR0aCA+PSBhc2NDaGFyV2lkdGg7IGkrKykge1xuICAgICAgICAgICAgY29udGVudFdpZHRoIC09IGFzY0NoYXJXaWR0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBlbGxpcHNpc1dpZHRoID0gZ2V0VGV4dFdpZHRoKGVsbGlwc2lzKTtcbiAgICAgICAgaWYgKGVsbGlwc2lzV2lkdGggPiBjb250ZW50V2lkdGgpIHtcbiAgICAgICAgICAgIGVsbGlwc2lzID0gJyc7XG4gICAgICAgICAgICBlbGxpcHNpc1dpZHRoID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRlbnRXaWR0aCA9IGNvbnRhaW5lcldpZHRoIC0gZWxsaXBzaXNXaWR0aDtcblxuICAgICAgICB2YXIgdGV4dExpbmVzID0gKHRleHQgKyAnJykuc3BsaXQoJ1xcbicpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0ZXh0TGluZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHZhciB0ZXh0TGluZSA9IHRleHRMaW5lc1tpXTtcbiAgICAgICAgICAgIHZhciBsaW5lV2lkdGggPSBnZXRUZXh0V2lkdGgodGV4dExpbmUsIHRleHRGb250KTtcblxuICAgICAgICAgICAgaWYgKGxpbmVXaWR0aCA8PSBjb250YWluZXJXaWR0aCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDs7IGorKykge1xuICAgICAgICAgICAgICAgIGlmIChsaW5lV2lkdGggPD0gY29udGVudFdpZHRoIHx8IGogPj0gbWF4SXRlcmF0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0TGluZSArPSBlbGxpcHNpcztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIHN1Ykxlbmd0aCA9IGogPT09IDBcbiAgICAgICAgICAgICAgICAgICAgPyBlc3RpbWF0ZUxlbmd0aCh0ZXh0TGluZSwgY29udGVudFdpZHRoLCBhc2NDaGFyV2lkdGgsIGNuQ2hhcldpZHRoKVxuICAgICAgICAgICAgICAgICAgICA6IGxpbmVXaWR0aCA+IDBcbiAgICAgICAgICAgICAgICAgICAgPyBNYXRoLmZsb29yKHRleHRMaW5lLmxlbmd0aCAqIGNvbnRlbnRXaWR0aCAvIGxpbmVXaWR0aClcbiAgICAgICAgICAgICAgICAgICAgOiAwO1xuXG4gICAgICAgICAgICAgICAgdGV4dExpbmUgPSB0ZXh0TGluZS5zdWJzdHIoMCwgc3ViTGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBsaW5lV2lkdGggPSBnZXRUZXh0V2lkdGgodGV4dExpbmUsIHRleHRGb250KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRleHRMaW5lID09PSAnJykge1xuICAgICAgICAgICAgICAgIHRleHRMaW5lID0gcGxhY2Vob2xkZXI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRleHRMaW5lc1tpXSA9IHRleHRMaW5lO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRleHRMaW5lcy5qb2luKCdcXG4nKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBlc3RpbWF0ZUxlbmd0aCh0ZXh0LCBjb250ZW50V2lkdGgsIGFzY0NoYXJXaWR0aCwgY25DaGFyV2lkdGgpIHtcbiAgICAgICAgdmFyIHdpZHRoID0gMDtcbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICBmb3IgKHZhciBsZW4gPSB0ZXh0Lmxlbmd0aDsgaSA8IGxlbiAmJiB3aWR0aCA8IGNvbnRlbnRXaWR0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgY2hhckNvZGUgPSB0ZXh0LmNoYXJDb2RlQXQoaSk7XG4gICAgICAgICAgICB3aWR0aCArPSAoMCA8PSBjaGFyQ29kZSAmJiBjaGFyQ29kZSA8PSAxMjcpID8gYXNjQ2hhcldpZHRoIDogY25DaGFyV2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGk7XG4gICAgfVxuXG4gICAgdmFyIHRleHRDb250YWluID0ge1xuXG4gICAgICAgIGdldFdpZHRoOiBnZXRUZXh0V2lkdGgsXG5cbiAgICAgICAgZ2V0Qm91bmRpbmdSZWN0OiBnZXRUZXh0UmVjdCxcblxuICAgICAgICBhZGp1c3RUZXh0UG9zaXRpb25PblJlY3Q6IGFkanVzdFRleHRQb3NpdGlvbk9uUmVjdCxcblxuICAgICAgICB0cnVuY2F0ZVRleHQ6IHRydW5jYXRlVGV4dCxcblxuICAgICAgICBtZWFzdXJlVGV4dDogZnVuY3Rpb24gKHRleHQsIHRleHRGb250KSB7XG4gICAgICAgICAgICB2YXIgY3R4ID0gdXRpbC5nZXRDb250ZXh0KCk7XG4gICAgICAgICAgICBjdHguZm9udCA9IHRleHRGb250IHx8ICcxMnB4IHNhbnMtc2VyaWYnO1xuICAgICAgICAgICAgcmV0dXJuIGN0eC5tZWFzdXJlVGV4dCh0ZXh0KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHRleHRDb250YWluO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34venJlbmRlci9saWIvY29udGFpbi90ZXh0LmpzXG4gKiogbW9kdWxlIGlkID0gMjNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0Jztcbi8qKlxuICogQG1vZHVsZSBlY2hhcnRzL2NvcmUvQm91bmRpbmdSZWN0XG4gKi9cblxuXG4gICAgdmFyIHZlYzIgPSByZXF1aXJlKCcuL3ZlY3RvcicpO1xuICAgIHZhciBtYXRyaXggPSByZXF1aXJlKCcuL21hdHJpeCcpO1xuXG4gICAgdmFyIHYyQXBwbHlUcmFuc2Zvcm0gPSB2ZWMyLmFwcGx5VHJhbnNmb3JtO1xuICAgIHZhciBtYXRoTWluID0gTWF0aC5taW47XG4gICAgdmFyIG1hdGhBYnMgPSBNYXRoLmFicztcbiAgICB2YXIgbWF0aE1heCA9IE1hdGgubWF4O1xuICAgIC8qKlxuICAgICAqIEBhbGlhcyBtb2R1bGU6ZWNoYXJ0cy9jb3JlL0JvdW5kaW5nUmVjdFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEJvdW5kaW5nUmVjdCh4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy54ID0geDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnkgPSB5O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICB9XG5cbiAgICBCb3VuZGluZ1JlY3QucHJvdG90eXBlID0ge1xuXG4gICAgICAgIGNvbnN0cnVjdG9yOiBCb3VuZGluZ1JlY3QsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvY29yZS9Cb3VuZGluZ1JlY3R9IG90aGVyXG4gICAgICAgICAqL1xuICAgICAgICB1bmlvbjogZnVuY3Rpb24gKG90aGVyKSB7XG4gICAgICAgICAgICB2YXIgeCA9IG1hdGhNaW4ob3RoZXIueCwgdGhpcy54KTtcbiAgICAgICAgICAgIHZhciB5ID0gbWF0aE1pbihvdGhlci55LCB0aGlzLnkpO1xuXG4gICAgICAgICAgICB0aGlzLndpZHRoID0gbWF0aE1heChcbiAgICAgICAgICAgICAgICAgICAgb3RoZXIueCArIG90aGVyLndpZHRoLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnggKyB0aGlzLndpZHRoXG4gICAgICAgICAgICAgICAgKSAtIHg7XG4gICAgICAgICAgICB0aGlzLmhlaWdodCA9IG1hdGhNYXgoXG4gICAgICAgICAgICAgICAgICAgIG90aGVyLnkgKyBvdGhlci5oZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMueSArIHRoaXMuaGVpZ2h0XG4gICAgICAgICAgICAgICAgKSAtIHk7XG4gICAgICAgICAgICB0aGlzLnggPSB4O1xuICAgICAgICAgICAgdGhpcy55ID0geTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gbVxuICAgICAgICAgKiBAbWV0aG9kc1xuICAgICAgICAgKi9cbiAgICAgICAgYXBwbHlUcmFuc2Zvcm06IChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbWluID0gW107XG4gICAgICAgICAgICB2YXIgbWF4ID0gW107XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgICAgICAgICAvLyBJbiBjYXNlIHVzYWdlIGxpa2UgdGhpc1xuICAgICAgICAgICAgICAgIC8vIGVsLmdldEJvdW5kaW5nUmVjdCgpLmFwcGx5VHJhbnNmb3JtKGVsLnRyYW5zZm9ybSlcbiAgICAgICAgICAgICAgICAvLyBBbmQgZWxlbWVudCBoYXMgbm8gdHJhbnNmb3JtXG4gICAgICAgICAgICAgICAgaWYgKCFtKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbWluWzBdID0gdGhpcy54O1xuICAgICAgICAgICAgICAgIG1pblsxXSA9IHRoaXMueTtcbiAgICAgICAgICAgICAgICBtYXhbMF0gPSB0aGlzLnggKyB0aGlzLndpZHRoO1xuICAgICAgICAgICAgICAgIG1heFsxXSA9IHRoaXMueSArIHRoaXMuaGVpZ2h0O1xuXG4gICAgICAgICAgICAgICAgdjJBcHBseVRyYW5zZm9ybShtaW4sIG1pbiwgbSk7XG4gICAgICAgICAgICAgICAgdjJBcHBseVRyYW5zZm9ybShtYXgsIG1heCwgbSk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLnggPSBtYXRoTWluKG1pblswXSwgbWF4WzBdKTtcbiAgICAgICAgICAgICAgICB0aGlzLnkgPSBtYXRoTWluKG1pblsxXSwgbWF4WzFdKTtcbiAgICAgICAgICAgICAgICB0aGlzLndpZHRoID0gbWF0aEFicyhtYXhbMF0gLSBtaW5bMF0pO1xuICAgICAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gbWF0aEFicyhtYXhbMV0gLSBtaW5bMV0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSkoKSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2FsY3VsYXRlIG1hdHJpeCBvZiB0cmFuc2Zvcm1pbmcgZnJvbSBzZWxmIHRvIHRhcmdldCByZWN0XG4gICAgICAgICAqIEBwYXJhbSAge21vZHVsZTp6cmVuZGVyL2NvcmUvQm91bmRpbmdSZWN0fSBiXG4gICAgICAgICAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fVxuICAgICAgICAgKi9cbiAgICAgICAgY2FsY3VsYXRlVHJhbnNmb3JtOiBmdW5jdGlvbiAoYikge1xuICAgICAgICAgICAgdmFyIGEgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIHN4ID0gYi53aWR0aCAvIGEud2lkdGg7XG4gICAgICAgICAgICB2YXIgc3kgPSBiLmhlaWdodCAvIGEuaGVpZ2h0O1xuXG4gICAgICAgICAgICB2YXIgbSA9IG1hdHJpeC5jcmVhdGUoKTtcblxuICAgICAgICAgICAgLy8g55+p6Zi15Y+z5LmYXG4gICAgICAgICAgICBtYXRyaXgudHJhbnNsYXRlKG0sIG0sIFstYS54LCAtYS55XSk7XG4gICAgICAgICAgICBtYXRyaXguc2NhbGUobSwgbSwgW3N4LCBzeV0pO1xuICAgICAgICAgICAgbWF0cml4LnRyYW5zbGF0ZShtLCBtLCBbYi54LCBiLnldKTtcblxuICAgICAgICAgICAgcmV0dXJuIG07XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7KG1vZHVsZTplY2hhcnRzL2NvcmUvQm91bmRpbmdSZWN0fE9iamVjdCl9IGJcbiAgICAgICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIGludGVyc2VjdDogZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgICAgIHZhciBhID0gdGhpcztcbiAgICAgICAgICAgIHZhciBheDAgPSBhLng7XG4gICAgICAgICAgICB2YXIgYXgxID0gYS54ICsgYS53aWR0aDtcbiAgICAgICAgICAgIHZhciBheTAgPSBhLnk7XG4gICAgICAgICAgICB2YXIgYXkxID0gYS55ICsgYS5oZWlnaHQ7XG5cbiAgICAgICAgICAgIHZhciBieDAgPSBiLng7XG4gICAgICAgICAgICB2YXIgYngxID0gYi54ICsgYi53aWR0aDtcbiAgICAgICAgICAgIHZhciBieTAgPSBiLnk7XG4gICAgICAgICAgICB2YXIgYnkxID0gYi55ICsgYi5oZWlnaHQ7XG5cbiAgICAgICAgICAgIHJldHVybiAhIChheDEgPCBieDAgfHwgYngxIDwgYXgwIHx8IGF5MSA8IGJ5MCB8fCBieTEgPCBheTApO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNvbnRhaW46IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgICAgICB2YXIgcmVjdCA9IHRoaXM7XG4gICAgICAgICAgICByZXR1cm4geCA+PSByZWN0LnhcbiAgICAgICAgICAgICAgICAmJiB4IDw9IChyZWN0LnggKyByZWN0LndpZHRoKVxuICAgICAgICAgICAgICAgICYmIHkgPj0gcmVjdC55XG4gICAgICAgICAgICAgICAgJiYgeSA8PSAocmVjdC55ICsgcmVjdC5oZWlnaHQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHttb2R1bGU6ZWNoYXJ0cy9jb3JlL0JvdW5kaW5nUmVjdH1cbiAgICAgICAgICovXG4gICAgICAgIGNsb25lOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEJvdW5kaW5nUmVjdCh0aGlzLngsIHRoaXMueSwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb3B5IGZyb20gYW5vdGhlciByZWN0XG4gICAgICAgICAqL1xuICAgICAgICBjb3B5OiBmdW5jdGlvbiAob3RoZXIpIHtcbiAgICAgICAgICAgIHRoaXMueCA9IG90aGVyLng7XG4gICAgICAgICAgICB0aGlzLnkgPSBvdGhlci55O1xuICAgICAgICAgICAgdGhpcy53aWR0aCA9IG90aGVyLndpZHRoO1xuICAgICAgICAgICAgdGhpcy5oZWlnaHQgPSBvdGhlci5oZWlnaHQ7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBCb3VuZGluZ1JlY3Q7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi96cmVuZGVyL2xpYi9jb3JlL0JvdW5kaW5nUmVjdC5qc1xuICoqIG1vZHVsZSBpZCA9IDI0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG4vKipcbiAqIFBhdGgg5Luj55CG77yM5Y+v5Lul5ZyoYGJ1aWxkUGF0aGDkuK3nlKjkuo7mm7/ku6NgY3R4YCwg5Lya5L+d5a2Y5q+P5LiqcGF0aOaTjeS9nOeahOWRveS7pOWIsHBhdGhDb21tYW5kc+WxnuaAp+S4rVxuICog5Y+v5Lul55So5LqOIGlzSW5zaWRlUGF0aCDliKTmlq3ku6Xlj4rojrflj5Zib3VuZGluZ1JlY3RcbiAqXG4gKiBAbW9kdWxlIHpyZW5kZXIvY29yZS9QYXRoUHJveHlcbiAqIEBhdXRob3IgWWkgU2hlbiAoaHR0cDovL3d3dy5naXRodWIuY29tL3Bpc3NhbmcpXG4gKi9cblxuIC8vIFRPRE8gZ2V0VG90YWxMZW5ndGgsIGdldFBvaW50QXRMZW5ndGhcblxuXG4gICAgdmFyIGN1cnZlID0gcmVxdWlyZSgnLi9jdXJ2ZScpO1xuICAgIHZhciB2ZWMyID0gcmVxdWlyZSgnLi92ZWN0b3InKTtcbiAgICB2YXIgYmJveCA9IHJlcXVpcmUoJy4vYmJveCcpO1xuICAgIHZhciBCb3VuZGluZ1JlY3QgPSByZXF1aXJlKCcuL0JvdW5kaW5nUmVjdCcpO1xuICAgIHZhciBkcHIgPSByZXF1aXJlKCcuLi9jb25maWcnKS5kZXZpY2VQaXhlbFJhdGlvO1xuXG4gICAgdmFyIENNRCA9IHtcbiAgICAgICAgTTogMSxcbiAgICAgICAgTDogMixcbiAgICAgICAgQzogMyxcbiAgICAgICAgUTogNCxcbiAgICAgICAgQTogNSxcbiAgICAgICAgWjogNixcbiAgICAgICAgLy8gUmVjdFxuICAgICAgICBSOiA3XG4gICAgfTtcblxuICAgIHZhciBtaW4gPSBbXTtcbiAgICB2YXIgbWF4ID0gW107XG4gICAgdmFyIG1pbjIgPSBbXTtcbiAgICB2YXIgbWF4MiA9IFtdO1xuICAgIHZhciBtYXRoTWluID0gTWF0aC5taW47XG4gICAgdmFyIG1hdGhNYXggPSBNYXRoLm1heDtcbiAgICB2YXIgbWF0aENvcyA9IE1hdGguY29zO1xuICAgIHZhciBtYXRoU2luID0gTWF0aC5zaW47XG4gICAgdmFyIG1hdGhTcXJ0ID0gTWF0aC5zcXJ0O1xuICAgIHZhciBtYXRoQWJzID0gTWF0aC5hYnM7XG5cbiAgICB2YXIgaGFzVHlwZWRBcnJheSA9IHR5cGVvZiBGbG9hdDMyQXJyYXkgIT0gJ3VuZGVmaW5lZCc7XG5cbiAgICAvKipcbiAgICAgKiBAYWxpYXMgbW9kdWxlOnpyZW5kZXIvY29yZS9QYXRoUHJveHlcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKi9cbiAgICB2YXIgUGF0aFByb3h5ID0gZnVuY3Rpb24gKCkge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQYXRoIGRhdGEuIFN0b3JlZCBhcyBmbGF0IGFycmF5XG4gICAgICAgICAqIEB0eXBlIHtBcnJheS48T2JqZWN0Pn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZGF0YSA9IFtdO1xuXG4gICAgICAgIHRoaXMuX2xlbiA9IDA7XG5cbiAgICAgICAgdGhpcy5fY3R4ID0gbnVsbDtcblxuICAgICAgICB0aGlzLl94aSA9IDA7XG4gICAgICAgIHRoaXMuX3lpID0gMDtcblxuICAgICAgICB0aGlzLl94MCA9IDA7XG4gICAgICAgIHRoaXMuX3kwID0gMDtcblxuICAgICAgICAvLyBVbml0IHgsIFVuaXQgeS4gUHJvdmlkZSBmb3IgYXZvaWRpbmcgZHJhd2luZyB0aGF0IHRvbyBzaG9ydCBsaW5lIHNlZ21lbnRcbiAgICAgICAgdGhpcy5fdXggPSAwO1xuICAgICAgICB0aGlzLl91eSA9IDA7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIOW/q+mAn+iuoeeul1BhdGjljIXlm7Tnm5LvvIjlubbkuI3mmK/mnIDlsI/ljIXlm7Tnm5LvvIlcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAgICovXG4gICAgUGF0aFByb3h5LnByb3RvdHlwZSA9IHtcblxuICAgICAgICBjb25zdHJ1Y3RvcjogUGF0aFByb3h5LFxuXG4gICAgICAgIF9saW5lRGFzaDogbnVsbCxcblxuICAgICAgICBfZGFzaE9mZnNldDogMCxcblxuICAgICAgICBfZGFzaElkeDogMCxcblxuICAgICAgICBfZGFzaFN1bTogMCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHJlYWRPbmx5XG4gICAgICAgICAqL1xuICAgICAgICBzZXRTY2FsZTogZnVuY3Rpb24gKHN4LCBzeSkge1xuICAgICAgICAgICAgdGhpcy5fdXggPSBtYXRoQWJzKDEgLyBkcHIgLyBzeCkgfHwgMDtcbiAgICAgICAgICAgIHRoaXMuX3V5ID0gbWF0aEFicygxIC8gZHByIC8gc3kpIHx8IDA7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0Q29udGV4dDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2N0eDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtICB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgICAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvY29yZS9QYXRoUHJveHl9XG4gICAgICAgICAqL1xuICAgICAgICBiZWdpblBhdGg6IGZ1bmN0aW9uIChjdHgpIHtcblxuICAgICAgICAgICAgdGhpcy5fY3R4ID0gY3R4O1xuXG4gICAgICAgICAgICBjdHggJiYgY3R4LmJlZ2luUGF0aCgpO1xuXG4gICAgICAgICAgICBjdHggJiYgKHRoaXMuZHByID0gY3R4LmRwcik7XG5cbiAgICAgICAgICAgIC8vIFJlc2V0XG4gICAgICAgICAgICB0aGlzLl9sZW4gPSAwO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5fbGluZURhc2gpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9saW5lRGFzaCA9IG51bGw7XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9kYXNoT2Zmc2V0ID0gMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0geFxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHlcbiAgICAgICAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvY29yZS9QYXRoUHJveHl9XG4gICAgICAgICAqL1xuICAgICAgICBtb3ZlVG86IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgICAgICB0aGlzLmFkZERhdGEoQ01ELk0sIHgsIHkpO1xuICAgICAgICAgICAgdGhpcy5fY3R4ICYmIHRoaXMuX2N0eC5tb3ZlVG8oeCwgeSk7XG5cbiAgICAgICAgICAgIC8vIHgwLCB5MCwgeGksIHlpIOaYr+iusOW9leWcqCBfZGFzaGVkWFhYWFRvIOaWueazleS4reS9v+eUqFxuICAgICAgICAgICAgLy8geGksIHlpIOiusOW9leW9k+WJjeeCuSwgeDAsIHkwIOWcqCBjbG9zZVBhdGgg55qE5pe25YCZ5Zue5Yiw6LW35aeL54K544CCXG4gICAgICAgICAgICAvLyDmnInlj6/og73lnKggYmVnaW5QYXRoIOS5i+WQjuebtOaOpeiwg+eUqCBsaW5lVG/vvIzov5nml7blgJkgeDAsIHkwIOmcgOimgVxuICAgICAgICAgICAgLy8g5ZyoIGxpbmVUbyDmlrnms5XkuK3orrDlvZXvvIzov5nph4zlhYjkuI3ogIPomZHov5nnp43mg4XlhrXvvIxkYXNoZWQgbGluZSDkuZ/lj6rlnKggSUUxMC0g5Lit5LiN5pSv5oyBXG4gICAgICAgICAgICB0aGlzLl94MCA9IHg7XG4gICAgICAgICAgICB0aGlzLl95MCA9IHk7XG5cbiAgICAgICAgICAgIHRoaXMuX3hpID0geDtcbiAgICAgICAgICAgIHRoaXMuX3lpID0geTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0geFxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHlcbiAgICAgICAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvY29yZS9QYXRoUHJveHl9XG4gICAgICAgICAqL1xuICAgICAgICBsaW5lVG86IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgICAgICB2YXIgZXhjZWVkVW5pdCA9IG1hdGhBYnMoeCAtIHRoaXMuX3hpKSA+IHRoaXMuX3V4XG4gICAgICAgICAgICAgICAgfHwgbWF0aEFicyh5IC0gdGhpcy5feWkpID4gdGhpcy5fdXlcbiAgICAgICAgICAgICAgICAvLyBGb3JjZSBkcmF3IHRoZSBmaXJzdCBzZWdtZW50XG4gICAgICAgICAgICAgICAgfHwgdGhpcy5fbGVuIDwgNTtcblxuICAgICAgICAgICAgdGhpcy5hZGREYXRhKENNRC5MLCB4LCB5KTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuX2N0eCAmJiBleGNlZWRVbml0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbmVlZHNEYXNoKCkgPyB0aGlzLl9kYXNoZWRMaW5lVG8oeCwgeSlcbiAgICAgICAgICAgICAgICAgICAgOiB0aGlzLl9jdHgubGluZVRvKHgsIHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGV4Y2VlZFVuaXQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl94aSA9IHg7XG4gICAgICAgICAgICAgICAgdGhpcy5feWkgPSB5O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSB4MVxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHkxXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0geDJcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSB5MlxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHgzXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0geTNcbiAgICAgICAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvY29yZS9QYXRoUHJveHl9XG4gICAgICAgICAqL1xuICAgICAgICBiZXppZXJDdXJ2ZVRvOiBmdW5jdGlvbiAoeDEsIHkxLCB4MiwgeTIsIHgzLCB5Mykge1xuICAgICAgICAgICAgdGhpcy5hZGREYXRhKENNRC5DLCB4MSwgeTEsIHgyLCB5MiwgeDMsIHkzKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9jdHgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9uZWVkc0Rhc2goKSA/IHRoaXMuX2Rhc2hlZEJlemllclRvKHgxLCB5MSwgeDIsIHkyLCB4MywgeTMpXG4gICAgICAgICAgICAgICAgICAgIDogdGhpcy5fY3R4LmJlemllckN1cnZlVG8oeDEsIHkxLCB4MiwgeTIsIHgzLCB5Myk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl94aSA9IHgzO1xuICAgICAgICAgICAgdGhpcy5feWkgPSB5MztcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHgxXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0geTFcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSB4MlxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHkyXG4gICAgICAgICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2NvcmUvUGF0aFByb3h5fVxuICAgICAgICAgKi9cbiAgICAgICAgcXVhZHJhdGljQ3VydmVUbzogZnVuY3Rpb24gKHgxLCB5MSwgeDIsIHkyKSB7XG4gICAgICAgICAgICB0aGlzLmFkZERhdGEoQ01ELlEsIHgxLCB5MSwgeDIsIHkyKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9jdHgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9uZWVkc0Rhc2goKSA/IHRoaXMuX2Rhc2hlZFF1YWRyYXRpY1RvKHgxLCB5MSwgeDIsIHkyKVxuICAgICAgICAgICAgICAgICAgICA6IHRoaXMuX2N0eC5xdWFkcmF0aWNDdXJ2ZVRvKHgxLCB5MSwgeDIsIHkyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3hpID0geDI7XG4gICAgICAgICAgICB0aGlzLl95aSA9IHkyO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gY3hcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSBjeVxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHJcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSBzdGFydEFuZ2xlXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gZW5kQW5nbGVcbiAgICAgICAgICogQHBhcmFtICB7Ym9vbGVhbn0gYW50aWNsb2Nrd2lzZVxuICAgICAgICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9jb3JlL1BhdGhQcm94eX1cbiAgICAgICAgICovXG4gICAgICAgIGFyYzogZnVuY3Rpb24gKGN4LCBjeSwgciwgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGFudGljbG9ja3dpc2UpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkRGF0YShcbiAgICAgICAgICAgICAgICBDTUQuQSwgY3gsIGN5LCByLCByLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSAtIHN0YXJ0QW5nbGUsIDAsIGFudGljbG9ja3dpc2UgPyAwIDogMVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHRoaXMuX2N0eCAmJiB0aGlzLl9jdHguYXJjKGN4LCBjeSwgciwgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGFudGljbG9ja3dpc2UpO1xuXG4gICAgICAgICAgICB0aGlzLl94aSA9IG1hdGhDb3MoZW5kQW5nbGUpICogciArIGN4O1xuICAgICAgICAgICAgdGhpcy5feGkgPSBtYXRoU2luKGVuZEFuZ2xlKSAqIHIgKyBjeDtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIFRPRE9cbiAgICAgICAgYXJjVG86IGZ1bmN0aW9uICh4MSwgeTEsIHgyLCB5MiwgcmFkaXVzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fY3R4KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY3R4LmFyY1RvKHgxLCB5MSwgeDIsIHkyLCByYWRpdXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gVE9ET1xuICAgICAgICByZWN0OiBmdW5jdGlvbiAoeCwgeSwgdywgaCkge1xuICAgICAgICAgICAgdGhpcy5fY3R4ICYmIHRoaXMuX2N0eC5yZWN0KHgsIHksIHcsIGgpO1xuICAgICAgICAgICAgdGhpcy5hZGREYXRhKENNRC5SLCB4LCB5LCB3LCBoKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9jb3JlL1BhdGhQcm94eX1cbiAgICAgICAgICovXG4gICAgICAgIGNsb3NlUGF0aDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5hZGREYXRhKENNRC5aKTtcblxuICAgICAgICAgICAgdmFyIGN0eCA9IHRoaXMuX2N0eDtcbiAgICAgICAgICAgIHZhciB4MCA9IHRoaXMuX3gwO1xuICAgICAgICAgICAgdmFyIHkwID0gdGhpcy5feTA7XG4gICAgICAgICAgICBpZiAoY3R4KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbmVlZHNEYXNoKCkgJiYgdGhpcy5fZGFzaGVkTGluZVRvKHgwLCB5MCk7XG4gICAgICAgICAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl94aSA9IHgwO1xuICAgICAgICAgICAgdGhpcy5feWkgPSB5MDtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb250ZXh0IOS7juWklumDqOS8oOWFpe+8jOWboOS4uuacieWPr+iDveaYryByZWJ1aWxkUGF0aCDlrozkuYvlkI7lho0gZmlsbOOAglxuICAgICAgICAgKiBzdHJva2Ug5ZCM5qC3XG4gICAgICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgICAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvY29yZS9QYXRoUHJveHl9XG4gICAgICAgICAqL1xuICAgICAgICBmaWxsOiBmdW5jdGlvbiAoY3R4KSB7XG4gICAgICAgICAgICBjdHggJiYgY3R4LmZpbGwoKTtcbiAgICAgICAgICAgIHRoaXMudG9TdGF0aWMoKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAgICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9jb3JlL1BhdGhQcm94eX1cbiAgICAgICAgICovXG4gICAgICAgIHN0cm9rZTogZnVuY3Rpb24gKGN0eCkge1xuICAgICAgICAgICAgY3R4ICYmIGN0eC5zdHJva2UoKTtcbiAgICAgICAgICAgIHRoaXMudG9TdGF0aWMoKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5b+F6aG75Zyo5YW25a6D57uY5Yi25ZG95Luk5YmN6LCD55SoXG4gICAgICAgICAqIE11c3QgYmUgaW52b2tlZCBiZWZvcmUgYWxsIG90aGVyIHBhdGggZHJhd2luZyBtZXRob2RzXG4gICAgICAgICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2NvcmUvUGF0aFByb3h5fVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0TGluZURhc2g6IGZ1bmN0aW9uIChsaW5lRGFzaCkge1xuICAgICAgICAgICAgaWYgKGxpbmVEYXNoIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9saW5lRGFzaCA9IGxpbmVEYXNoO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5fZGFzaElkeCA9IDA7XG5cbiAgICAgICAgICAgICAgICB2YXIgbGluZURhc2hTdW0gPSAwO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZURhc2gubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbGluZURhc2hTdW0gKz0gbGluZURhc2hbaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX2Rhc2hTdW0gPSBsaW5lRGFzaFN1bTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlv4XpobvlnKjlhbblroPnu5jliLblkb3ku6TliY3osIPnlKhcbiAgICAgICAgICogTXVzdCBiZSBpbnZva2VkIGJlZm9yZSBhbGwgb3RoZXIgcGF0aCBkcmF3aW5nIG1ldGhvZHNcbiAgICAgICAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvY29yZS9QYXRoUHJveHl9XG4gICAgICAgICAqL1xuICAgICAgICBzZXRMaW5lRGFzaE9mZnNldDogZnVuY3Rpb24gKG9mZnNldCkge1xuICAgICAgICAgICAgdGhpcy5fZGFzaE9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgbGVuOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbGVuO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDnm7TmjqXorr7nva4gUGF0aCDmlbDmja5cbiAgICAgICAgICovXG4gICAgICAgIHNldERhdGE6IGZ1bmN0aW9uIChkYXRhKSB7XG5cbiAgICAgICAgICAgIHZhciBsZW4gPSBkYXRhLmxlbmd0aDtcblxuICAgICAgICAgICAgaWYgKCEgKHRoaXMuZGF0YSAmJiB0aGlzLmRhdGEubGVuZ3RoID09IGxlbikgJiYgaGFzVHlwZWRBcnJheSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkobGVuKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMuZGF0YVtpXSA9IGRhdGFbaV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX2xlbiA9IGxlbjtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5re75Yqg5a2Q6Lev5b6EXG4gICAgICAgICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvY29yZS9QYXRoUHJveHl8QXJyYXkuPG1vZHVsZTp6cmVuZGVyL2NvcmUvUGF0aFByb3h5Pn0gcGF0aFxuICAgICAgICAgKi9cbiAgICAgICAgYXBwZW5kUGF0aDogZnVuY3Rpb24gKHBhdGgpIHtcbiAgICAgICAgICAgIGlmICghKHBhdGggaW5zdGFuY2VvZiBBcnJheSkpIHtcbiAgICAgICAgICAgICAgICBwYXRoID0gW3BhdGhdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGxlbiA9IHBhdGgubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIGFwcGVuZFNpemUgPSAwO1xuICAgICAgICAgICAgdmFyIG9mZnNldCA9IHRoaXMuX2xlbjtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBhcHBlbmRTaXplICs9IHBhdGhbaV0ubGVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaGFzVHlwZWRBcnJheSAmJiAodGhpcy5kYXRhIGluc3RhbmNlb2YgRmxvYXQzMkFycmF5KSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkob2Zmc2V0ICsgYXBwZW5kU2l6ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFwcGVuZFBhdGhEYXRhID0gcGF0aFtpXS5kYXRhO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgYXBwZW5kUGF0aERhdGEubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kYXRhW29mZnNldCsrXSA9IGFwcGVuZFBhdGhEYXRhW2tdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2xlbiA9IG9mZnNldDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5aGr5YWFIFBhdGgg5pWw5o2u44CCXG4gICAgICAgICAqIOWwvemHj+WkjeeUqOiAjOS4jeeUs+aYjuaWsOeahOaVsOe7hOOAguWkp+mDqOWIhuWbvuW9oumHjee7mOeahOaMh+S7pOaVsOaNrumVv+W6pumDveaYr+S4jeWPmOeahOOAglxuICAgICAgICAgKi9cbiAgICAgICAgYWRkRGF0YTogZnVuY3Rpb24gKGNtZCkge1xuICAgICAgICAgICAgdmFyIGRhdGEgPSB0aGlzLmRhdGE7XG4gICAgICAgICAgICBpZiAodGhpcy5fbGVuICsgYXJndW1lbnRzLmxlbmd0aCA+IGRhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgLy8g5Zug5Li65LmL5YmN55qE5pWw57uE5bey57uP6L2s5o2i5oiQ6Z2Z5oCB55qEIEZsb2F0MzJBcnJheVxuICAgICAgICAgICAgICAgIC8vIOaJgOS7peS4jeWkn+eUqOaXtumcgOimgeaJqeWxleS4gOS4quaWsOeahOWKqOaAgeaVsOe7hFxuICAgICAgICAgICAgICAgIHRoaXMuX2V4cGFuZERhdGEoKTtcbiAgICAgICAgICAgICAgICBkYXRhID0gdGhpcy5kYXRhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBkYXRhW3RoaXMuX2xlbisrXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5fcHJldkNtZCA9IGNtZDtcbiAgICAgICAgfSxcblxuICAgICAgICBfZXhwYW5kRGF0YTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gT25seSBpZiBkYXRhIGlzIEZsb2F0MzJBcnJheVxuICAgICAgICAgICAgaWYgKCEodGhpcy5kYXRhIGluc3RhbmNlb2YgQXJyYXkpKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5ld0RhdGEgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2xlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld0RhdGFbaV0gPSB0aGlzLmRhdGFbaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuZGF0YSA9IG5ld0RhdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIG5lZWRzIGpzIGltcGxlbWVudGVkIGRhc2hlZCBsaW5lXG4gICAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBfbmVlZHNEYXNoOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbGluZURhc2g7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2Rhc2hlZExpbmVUbzogZnVuY3Rpb24gKHgxLCB5MSkge1xuICAgICAgICAgICAgdmFyIGRhc2hTdW0gPSB0aGlzLl9kYXNoU3VtO1xuICAgICAgICAgICAgdmFyIG9mZnNldCA9IHRoaXMuX2Rhc2hPZmZzZXQ7XG4gICAgICAgICAgICB2YXIgbGluZURhc2ggPSB0aGlzLl9saW5lRGFzaDtcbiAgICAgICAgICAgIHZhciBjdHggPSB0aGlzLl9jdHg7XG5cbiAgICAgICAgICAgIHZhciB4MCA9IHRoaXMuX3hpO1xuICAgICAgICAgICAgdmFyIHkwID0gdGhpcy5feWk7XG4gICAgICAgICAgICB2YXIgZHggPSB4MSAtIHgwO1xuICAgICAgICAgICAgdmFyIGR5ID0geTEgLSB5MDtcbiAgICAgICAgICAgIHZhciBkaXN0ID0gbWF0aFNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICAgICAgICAgICAgdmFyIHggPSB4MDtcbiAgICAgICAgICAgIHZhciB5ID0geTA7XG4gICAgICAgICAgICB2YXIgZGFzaDtcbiAgICAgICAgICAgIHZhciBuRGFzaCA9IGxpbmVEYXNoLmxlbmd0aDtcbiAgICAgICAgICAgIHZhciBpZHg7XG4gICAgICAgICAgICBkeCAvPSBkaXN0O1xuICAgICAgICAgICAgZHkgLz0gZGlzdDtcblxuICAgICAgICAgICAgaWYgKG9mZnNldCA8IDApIHtcbiAgICAgICAgICAgICAgICAvLyBDb252ZXJ0IHRvIHBvc2l0aXZlIG9mZnNldFxuICAgICAgICAgICAgICAgIG9mZnNldCA9IGRhc2hTdW0gKyBvZmZzZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvZmZzZXQgJT0gZGFzaFN1bTtcbiAgICAgICAgICAgIHggLT0gb2Zmc2V0ICogZHg7XG4gICAgICAgICAgICB5IC09IG9mZnNldCAqIGR5O1xuXG4gICAgICAgICAgICB3aGlsZSAoKGR4ID4gMCAmJiB4IDw9IHgxKSB8fCAoZHggPCAwICYmIHggPj0geDEpXG4gICAgICAgICAgICB8fCAoZHggPT0gMCAmJiAoKGR5ID4gMCAmJiB5IDw9IHkxKSB8fCAoZHkgPCAwICYmIHkgPj0geTEpKSkpIHtcbiAgICAgICAgICAgICAgICBpZHggPSB0aGlzLl9kYXNoSWR4O1xuICAgICAgICAgICAgICAgIGRhc2ggPSBsaW5lRGFzaFtpZHhdO1xuICAgICAgICAgICAgICAgIHggKz0gZHggKiBkYXNoO1xuICAgICAgICAgICAgICAgIHkgKz0gZHkgKiBkYXNoO1xuICAgICAgICAgICAgICAgIHRoaXMuX2Rhc2hJZHggPSAoaWR4ICsgMSkgJSBuRGFzaDtcbiAgICAgICAgICAgICAgICAvLyBTa2lwIHBvc2l0aXZlIG9mZnNldFxuICAgICAgICAgICAgICAgIGlmICgoZHggPiAwICYmIHggPCB4MCkgfHwgKGR4IDwgMCAmJiB4ID4geDApIHx8IChkeSA+IDAgJiYgeSA8IHkwKSB8fCAoZHkgPCAwICYmIHkgPiB5MCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN0eFtpZHggJSAyID8gJ21vdmVUbycgOiAnbGluZVRvJ10oXG4gICAgICAgICAgICAgICAgICAgIGR4ID49IDAgPyBtYXRoTWluKHgsIHgxKSA6IG1hdGhNYXgoeCwgeDEpLFxuICAgICAgICAgICAgICAgICAgICBkeSA+PSAwID8gbWF0aE1pbih5LCB5MSkgOiBtYXRoTWF4KHksIHkxKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBPZmZzZXQgZm9yIG5leHQgbGluZVRvXG4gICAgICAgICAgICBkeCA9IHggLSB4MTtcbiAgICAgICAgICAgIGR5ID0geSAtIHkxO1xuICAgICAgICAgICAgdGhpcy5fZGFzaE9mZnNldCA9IC1tYXRoU3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gTm90IGFjY3VyYXRlIGRhc2hlZCBsaW5lIHRvXG4gICAgICAgIF9kYXNoZWRCZXppZXJUbzogZnVuY3Rpb24gKHgxLCB5MSwgeDIsIHkyLCB4MywgeTMpIHtcbiAgICAgICAgICAgIHZhciBkYXNoU3VtID0gdGhpcy5fZGFzaFN1bTtcbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSB0aGlzLl9kYXNoT2Zmc2V0O1xuICAgICAgICAgICAgdmFyIGxpbmVEYXNoID0gdGhpcy5fbGluZURhc2g7XG4gICAgICAgICAgICB2YXIgY3R4ID0gdGhpcy5fY3R4O1xuXG4gICAgICAgICAgICB2YXIgeDAgPSB0aGlzLl94aTtcbiAgICAgICAgICAgIHZhciB5MCA9IHRoaXMuX3lpO1xuICAgICAgICAgICAgdmFyIHQ7XG4gICAgICAgICAgICB2YXIgZHg7XG4gICAgICAgICAgICB2YXIgZHk7XG4gICAgICAgICAgICB2YXIgY3ViaWNBdCA9IGN1cnZlLmN1YmljQXQ7XG4gICAgICAgICAgICB2YXIgYmV6aWVyTGVuID0gMDtcbiAgICAgICAgICAgIHZhciBpZHggPSB0aGlzLl9kYXNoSWR4O1xuICAgICAgICAgICAgdmFyIG5EYXNoID0gbGluZURhc2gubGVuZ3RoO1xuXG4gICAgICAgICAgICB2YXIgeDtcbiAgICAgICAgICAgIHZhciB5O1xuXG4gICAgICAgICAgICB2YXIgdG1wTGVuID0gMDtcblxuICAgICAgICAgICAgaWYgKG9mZnNldCA8IDApIHtcbiAgICAgICAgICAgICAgICAvLyBDb252ZXJ0IHRvIHBvc2l0aXZlIG9mZnNldFxuICAgICAgICAgICAgICAgIG9mZnNldCA9IGRhc2hTdW0gKyBvZmZzZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvZmZzZXQgJT0gZGFzaFN1bTtcbiAgICAgICAgICAgIC8vIEJlemllciBhcHByb3ggbGVuZ3RoXG4gICAgICAgICAgICBmb3IgKHQgPSAwOyB0IDwgMTsgdCArPSAwLjEpIHtcbiAgICAgICAgICAgICAgICBkeCA9IGN1YmljQXQoeDAsIHgxLCB4MiwgeDMsIHQgKyAwLjEpXG4gICAgICAgICAgICAgICAgICAgIC0gY3ViaWNBdCh4MCwgeDEsIHgyLCB4MywgdCk7XG4gICAgICAgICAgICAgICAgZHkgPSBjdWJpY0F0KHkwLCB5MSwgeTIsIHkzLCB0ICsgMC4xKVxuICAgICAgICAgICAgICAgICAgICAtIGN1YmljQXQoeTAsIHkxLCB5MiwgeTMsIHQpO1xuICAgICAgICAgICAgICAgIGJlemllckxlbiArPSBtYXRoU3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEZpbmQgaWR4IGFmdGVyIGFkZCBvZmZzZXRcbiAgICAgICAgICAgIGZvciAoOyBpZHggPCBuRGFzaDsgaWR4KyspIHtcbiAgICAgICAgICAgICAgICB0bXBMZW4gKz0gbGluZURhc2hbaWR4XTtcbiAgICAgICAgICAgICAgICBpZiAodG1wTGVuID4gb2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHQgPSAodG1wTGVuIC0gb2Zmc2V0KSAvIGJlemllckxlbjtcblxuICAgICAgICAgICAgd2hpbGUgKHQgPD0gMSkge1xuXG4gICAgICAgICAgICAgICAgeCA9IGN1YmljQXQoeDAsIHgxLCB4MiwgeDMsIHQpO1xuICAgICAgICAgICAgICAgIHkgPSBjdWJpY0F0KHkwLCB5MSwgeTIsIHkzLCB0KTtcblxuICAgICAgICAgICAgICAgIC8vIFVzZSBsaW5lIHRvIGFwcHJveGltYXRlIGRhc2hlZCBiZXppZXJcbiAgICAgICAgICAgICAgICAvLyBCYWQgcmVzdWx0IGlmIGRhc2ggaXMgbG9uZ1xuICAgICAgICAgICAgICAgIGlkeCAlIDIgPyBjdHgubW92ZVRvKHgsIHkpXG4gICAgICAgICAgICAgICAgICAgIDogY3R4LmxpbmVUbyh4LCB5KTtcblxuICAgICAgICAgICAgICAgIHQgKz0gbGluZURhc2hbaWR4XSAvIGJlemllckxlbjtcblxuICAgICAgICAgICAgICAgIGlkeCA9IChpZHggKyAxKSAlIG5EYXNoO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBGaW5pc2ggdGhlIGxhc3Qgc2VnbWVudCBhbmQgY2FsY3VsYXRlIHRoZSBuZXcgb2Zmc2V0XG4gICAgICAgICAgICAoaWR4ICUgMiAhPT0gMCkgJiYgY3R4LmxpbmVUbyh4MywgeTMpO1xuICAgICAgICAgICAgZHggPSB4MyAtIHg7XG4gICAgICAgICAgICBkeSA9IHkzIC0geTtcbiAgICAgICAgICAgIHRoaXMuX2Rhc2hPZmZzZXQgPSAtbWF0aFNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9kYXNoZWRRdWFkcmF0aWNUbzogZnVuY3Rpb24gKHgxLCB5MSwgeDIsIHkyKSB7XG4gICAgICAgICAgICAvLyBDb252ZXJ0IHF1YWRyYXRpYyB0byBjdWJpYyB1c2luZyBkZWdyZWUgZWxldmF0aW9uXG4gICAgICAgICAgICB2YXIgeDMgPSB4MjtcbiAgICAgICAgICAgIHZhciB5MyA9IHkyO1xuICAgICAgICAgICAgeDIgPSAoeDIgKyAyICogeDEpIC8gMztcbiAgICAgICAgICAgIHkyID0gKHkyICsgMiAqIHkxKSAvIDM7XG4gICAgICAgICAgICB4MSA9ICh0aGlzLl94aSArIDIgKiB4MSkgLyAzO1xuICAgICAgICAgICAgeTEgPSAodGhpcy5feWkgKyAyICogeTEpIC8gMztcblxuICAgICAgICAgICAgdGhpcy5fZGFzaGVkQmV6aWVyVG8oeDEsIHkxLCB4MiwgeTIsIHgzLCB5Myk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOi9rOaIkOmdmeaAgeeahCBGbG9hdDMyQXJyYXkg5YeP5bCR5aCG5YaF5a2Y5Y2g55SoXG4gICAgICAgICAqIENvbnZlcnQgZHluYW1pYyBhcnJheSB0byBzdGF0aWMgRmxvYXQzMkFycmF5XG4gICAgICAgICAqL1xuICAgICAgICB0b1N0YXRpYzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGRhdGEgPSB0aGlzLmRhdGE7XG4gICAgICAgICAgICBpZiAoZGF0YSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICAgICAgZGF0YS5sZW5ndGggPSB0aGlzLl9sZW47XG4gICAgICAgICAgICAgICAgaWYgKGhhc1R5cGVkQXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kYXRhID0gbmV3IEZsb2F0MzJBcnJheShkYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2NvcmUvQm91bmRpbmdSZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0Qm91bmRpbmdSZWN0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBtaW5bMF0gPSBtaW5bMV0gPSBtaW4yWzBdID0gbWluMlsxXSA9IE51bWJlci5NQVhfVkFMVUU7XG4gICAgICAgICAgICBtYXhbMF0gPSBtYXhbMV0gPSBtYXgyWzBdID0gbWF4MlsxXSA9IC1OdW1iZXIuTUFYX1ZBTFVFO1xuXG4gICAgICAgICAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICAgICAgICAgIHZhciB4aSA9IDA7XG4gICAgICAgICAgICB2YXIgeWkgPSAwO1xuICAgICAgICAgICAgdmFyIHgwID0gMDtcbiAgICAgICAgICAgIHZhciB5MCA9IDA7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7KSB7XG4gICAgICAgICAgICAgICAgdmFyIGNtZCA9IGRhdGFbaSsrXTtcblxuICAgICAgICAgICAgICAgIGlmIChpID09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8g5aaC5p6c56ys5LiA5Liq5ZG95Luk5pivIEwsIEMsIFFcbiAgICAgICAgICAgICAgICAgICAgLy8g5YiZIHByZXZpb3VzIHBvaW50IOWQjOe7mOWItuWRveS7pOeahOesrOS4gOS4qiBwb2ludFxuICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAvLyDnrKzkuIDkuKrlkb3ku6TkuLogQXJjIOeahOaDheWGteS4i+S8muWcqOWQjumdoueJueauiuWkhOeQhlxuICAgICAgICAgICAgICAgICAgICB4aSA9IGRhdGFbaV07XG4gICAgICAgICAgICAgICAgICAgIHlpID0gZGF0YVtpICsgMV07XG5cbiAgICAgICAgICAgICAgICAgICAgeDAgPSB4aTtcbiAgICAgICAgICAgICAgICAgICAgeTAgPSB5aTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGNtZCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIENNRC5NOlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbW92ZVRvIOWRveS7pOmHjeaWsOWIm+W7uuS4gOS4quaWsOeahCBzdWJwYXRoLCDlubbkuJTmm7TmlrDmlrDnmoTotbfngrlcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIOWcqCBjbG9zZVBhdGgg55qE5pe25YCZ5L2/55SoXG4gICAgICAgICAgICAgICAgICAgICAgICB4MCA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHkwID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgeGkgPSB4MDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHlpID0geTA7XG4gICAgICAgICAgICAgICAgICAgICAgICBtaW4yWzBdID0geDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBtaW4yWzFdID0geTA7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXgyWzBdID0geDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXgyWzFdID0geTA7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBDTUQuTDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGJib3guZnJvbUxpbmUoeGksIHlpLCBkYXRhW2ldLCBkYXRhW2kgKyAxXSwgbWluMiwgbWF4Mik7XG4gICAgICAgICAgICAgICAgICAgICAgICB4aSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHlpID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgQ01ELkM6XG4gICAgICAgICAgICAgICAgICAgICAgICBiYm94LmZyb21DdWJpYyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4aSwgeWksIGRhdGFbaSsrXSwgZGF0YVtpKytdLCBkYXRhW2krK10sIGRhdGFbaSsrXSwgZGF0YVtpXSwgZGF0YVtpICsgMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWluMiwgbWF4MlxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHhpID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgeWkgPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBDTUQuUTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGJib3guZnJvbVF1YWRyYXRpYyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4aSwgeWksIGRhdGFbaSsrXSwgZGF0YVtpKytdLCBkYXRhW2ldLCBkYXRhW2kgKyAxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaW4yLCBtYXgyXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgeGkgPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgICAgICB5aSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIENNRC5BOlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyBBcmMg5Yik5pat55qE5byA6ZSA5q+U6L6D5aSnXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3ggPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3kgPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcnggPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcnkgPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3RhcnRBbmdsZSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbmRBbmdsZSA9IGRhdGFbaSsrXSArIHN0YXJ0QW5nbGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPIEFyYyDml4vovaxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwc2kgPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYW50aWNsb2Nrd2lzZSA9IDEgLSBkYXRhW2krK107XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpID09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyDnm7TmjqXkvb/nlKggYXJjIOWRveS7pFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIOesrOS4gOS4quWRveS7pOi1t+eCuei/mOacquWumuS5iVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHgwID0gbWF0aENvcyhzdGFydEFuZ2xlKSAqIHJ4ICsgY3g7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeTAgPSBtYXRoU2luKHN0YXJ0QW5nbGUpICogcnkgKyBjeTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgYmJveC5mcm9tQXJjKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN4LCBjeSwgcngsIHJ5LCBzdGFydEFuZ2xlLCBlbmRBbmdsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbnRpY2xvY2t3aXNlLCBtaW4yLCBtYXgyXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB4aSA9IG1hdGhDb3MoZW5kQW5nbGUpICogcnggKyBjeDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHlpID0gbWF0aFNpbihlbmRBbmdsZSkgKiByeSArIGN5O1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgQ01ELlI6XG4gICAgICAgICAgICAgICAgICAgICAgICB4MCA9IHhpID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgeTAgPSB5aSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB3aWR0aCA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBoZWlnaHQgPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBVc2UgZnJvbUxpbmVcbiAgICAgICAgICAgICAgICAgICAgICAgIGJib3guZnJvbUxpbmUoeDAsIHkwLCB4MCArIHdpZHRoLCB5MCArIGhlaWdodCwgbWluMiwgbWF4Mik7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBDTUQuWjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHhpID0geDA7XG4gICAgICAgICAgICAgICAgICAgICAgICB5aSA9IHkwO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gVW5pb25cbiAgICAgICAgICAgICAgICB2ZWMyLm1pbihtaW4sIG1pbiwgbWluMik7XG4gICAgICAgICAgICAgICAgdmVjMi5tYXgobWF4LCBtYXgsIG1heDIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBObyBkYXRhXG4gICAgICAgICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIG1pblswXSA9IG1pblsxXSA9IG1heFswXSA9IG1heFsxXSA9IDA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBuZXcgQm91bmRpbmdSZWN0KFxuICAgICAgICAgICAgICAgIG1pblswXSwgbWluWzFdLCBtYXhbMF0gLSBtaW5bMF0sIG1heFsxXSAtIG1pblsxXVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmVidWlsZCBwYXRoIGZyb20gY3VycmVudCBkYXRhXG4gICAgICAgICAqIFJlYnVpbGQgcGF0aCB3aWxsIG5vdCBjb25zaWRlciBqYXZhc2NyaXB0IGltcGxlbWVudGVkIGxpbmUgZGFzaC5cbiAgICAgICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0fSBjdHhcbiAgICAgICAgICovXG4gICAgICAgIHJlYnVpbGRQYXRoOiBmdW5jdGlvbiAoY3R4KSB7XG4gICAgICAgICAgICB2YXIgZCA9IHRoaXMuZGF0YTtcbiAgICAgICAgICAgIHZhciB4MCwgeTA7XG4gICAgICAgICAgICB2YXIgeGksIHlpO1xuICAgICAgICAgICAgdmFyIHgsIHk7XG4gICAgICAgICAgICB2YXIgdXggPSB0aGlzLl91eDtcbiAgICAgICAgICAgIHZhciB1eSA9IHRoaXMuX3V5O1xuICAgICAgICAgICAgdmFyIGxlbiA9IHRoaXMuX2xlbjtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOykge1xuICAgICAgICAgICAgICAgIHZhciBjbWQgPSBkW2krK107XG5cbiAgICAgICAgICAgICAgICBpZiAoaSA9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIOWmguaenOesrOS4gOS4quWRveS7pOaYryBMLCBDLCBRXG4gICAgICAgICAgICAgICAgICAgIC8vIOWImSBwcmV2aW91cyBwb2ludCDlkIznu5jliLblkb3ku6TnmoTnrKzkuIDkuKogcG9pbnRcbiAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgLy8g56ys5LiA5Liq5ZG95Luk5Li6IEFyYyDnmoTmg4XlhrXkuIvkvJrlnKjlkI7pnaLnibnmrorlpITnkIZcbiAgICAgICAgICAgICAgICAgICAgeGkgPSBkW2ldO1xuICAgICAgICAgICAgICAgICAgICB5aSA9IGRbaSArIDFdO1xuXG4gICAgICAgICAgICAgICAgICAgIHgwID0geGk7XG4gICAgICAgICAgICAgICAgICAgIHkwID0geWk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN3aXRjaCAoY21kKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgQ01ELk06XG4gICAgICAgICAgICAgICAgICAgICAgICB4MCA9IHhpID0gZFtpKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgeTAgPSB5aSA9IGRbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5tb3ZlVG8oeGksIHlpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIENNRC5MOlxuICAgICAgICAgICAgICAgICAgICAgICAgeCA9IGRbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHkgPSBkW2krK107XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBOb3QgZHJhdyB0b28gc21hbGwgc2VnIGJldHdlZW5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXRoQWJzKHggLSB4aSkgPiB1eCB8fCBtYXRoQWJzKHkgLSB5aSkgPiB1eSB8fCBpID09PSBsZW4gLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmxpbmVUbyh4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4aSA9IHg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeWkgPSB5O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgQ01ELkM6XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguYmV6aWVyQ3VydmVUbyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkW2krK10sIGRbaSsrXSwgZFtpKytdLCBkW2krK10sIGRbaSsrXSwgZFtpKytdXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgeGkgPSBkW2kgLSAyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHlpID0gZFtpIC0gMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBDTUQuUTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKGRbaSsrXSwgZFtpKytdLCBkW2krK10sIGRbaSsrXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB4aSA9IGRbaSAtIDJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgeWkgPSBkW2kgLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIENNRC5BOlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGN4ID0gZFtpKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGN5ID0gZFtpKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJ4ID0gZFtpKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJ5ID0gZFtpKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRoZXRhID0gZFtpKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRUaGV0YSA9IGRbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwc2kgPSBkW2krK107XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZnMgPSBkW2krK107XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgciA9IChyeCA+IHJ5KSA/IHJ4IDogcnk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2NhbGVYID0gKHJ4ID4gcnkpID8gMSA6IHJ4IC8gcnk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2NhbGVZID0gKHJ4ID4gcnkpID8gcnkgLyByeCA6IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaXNFbGxpcHNlID0gTWF0aC5hYnMocnggLSByeSkgPiAxZS0zO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVuZEFuZ2xlID0gdGhldGEgKyBkVGhldGE7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNFbGxpcHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZShjeCwgY3kpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5yb3RhdGUocHNpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHguc2NhbGUoc2NhbGVYLCBzY2FsZVkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5hcmMoMCwgMCwgciwgdGhldGEsIGVuZEFuZ2xlLCAxIC0gZnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5zY2FsZSgxIC8gc2NhbGVYLCAxIC8gc2NhbGVZKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHgucm90YXRlKC1wc2kpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0eC50cmFuc2xhdGUoLWN4LCAtY3kpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmFyYyhjeCwgY3ksIHIsIHRoZXRhLCBlbmRBbmdsZSwgMSAtIGZzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkgPT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIOebtOaOpeS9v+eUqCBhcmMg5ZG95LukXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8g56ys5LiA5Liq5ZG95Luk6LW354K56L+Y5pyq5a6a5LmJXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeDAgPSBtYXRoQ29zKHRoZXRhKSAqIHJ4ICsgY3g7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeTAgPSBtYXRoU2luKHRoZXRhKSAqIHJ5ICsgY3k7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB4aSA9IG1hdGhDb3MoZW5kQW5nbGUpICogcnggKyBjeDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHlpID0gbWF0aFNpbihlbmRBbmdsZSkgKiByeSArIGN5O1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgQ01ELlI6XG4gICAgICAgICAgICAgICAgICAgICAgICB4MCA9IHhpID0gZFtpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHkwID0geWkgPSBkW2kgKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5yZWN0KGRbaSsrXSwgZFtpKytdLCBkW2krK10sIGRbaSsrXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBDTUQuWjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHhpID0geDA7XG4gICAgICAgICAgICAgICAgICAgICAgICB5aSA9IHkwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBQYXRoUHJveHkuQ01EID0gQ01EO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBQYXRoUHJveHk7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi96cmVuZGVyL2xpYi9jb3JlL1BhdGhQcm94eS5qc1xuICoqIG1vZHVsZSBpZCA9IDI1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG4vKipcbiAqIOabsue6v+i+heWKqeaooeWdl1xuICogQG1vZHVsZSB6cmVuZGVyL2NvcmUvY3VydmVcbiAqIEBhdXRob3IgcGlzc2FuZyhodHRwczovL3d3dy5naXRodWIuY29tL3Bpc3NhbmcpXG4gKi9cblxuXG4gICAgdmFyIHZlYzIgPSByZXF1aXJlKCcuL3ZlY3RvcicpO1xuICAgIHZhciB2MkNyZWF0ZSA9IHZlYzIuY3JlYXRlO1xuICAgIHZhciB2MkRpc3RTcXVhcmUgPSB2ZWMyLmRpc3RTcXVhcmU7XG4gICAgdmFyIG1hdGhQb3cgPSBNYXRoLnBvdztcbiAgICB2YXIgbWF0aFNxcnQgPSBNYXRoLnNxcnQ7XG5cbiAgICB2YXIgRVBTSUxPTiA9IDFlLTg7XG4gICAgdmFyIEVQU0lMT05fTlVNRVJJQyA9IDFlLTQ7XG5cbiAgICB2YXIgVEhSRUVfU1FSVCA9IG1hdGhTcXJ0KDMpO1xuICAgIHZhciBPTkVfVEhJUkQgPSAxIC8gMztcblxuICAgIC8vIOS4tOaXtuWPmOmHj1xuICAgIHZhciBfdjAgPSB2MkNyZWF0ZSgpO1xuICAgIHZhciBfdjEgPSB2MkNyZWF0ZSgpO1xuICAgIHZhciBfdjIgPSB2MkNyZWF0ZSgpO1xuICAgIC8vIHZhciBfdjMgPSB2ZWMyLmNyZWF0ZSgpO1xuXG4gICAgZnVuY3Rpb24gaXNBcm91bmRaZXJvKHZhbCkge1xuICAgICAgICByZXR1cm4gdmFsID4gLUVQU0lMT04gJiYgdmFsIDwgRVBTSUxPTjtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNOb3RBcm91bmRaZXJvKHZhbCkge1xuICAgICAgICByZXR1cm4gdmFsID4gRVBTSUxPTiB8fCB2YWwgPCAtRVBTSUxPTjtcbiAgICB9XG4gICAgLyoqXG4gICAgICog6K6h566X5LiJ5qyh6LSd5aGe5bCU5YC8XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvY3VydmVcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHAwXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBwMVxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcDJcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHAzXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSB0XG4gICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGN1YmljQXQocDAsIHAxLCBwMiwgcDMsIHQpIHtcbiAgICAgICAgdmFyIG9uZXQgPSAxIC0gdDtcbiAgICAgICAgcmV0dXJuIG9uZXQgKiBvbmV0ICogKG9uZXQgKiBwMCArIDMgKiB0ICogcDEpXG4gICAgICAgICAgICAgKyB0ICogdCAqICh0ICogcDMgKyAzICogb25ldCAqIHAyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDorqHnrpfkuInmrKHotJ3loZ7lsJTlr7zmlbDlgLxcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS9jdXJ2ZVxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcDBcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHAxXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBwMlxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcDNcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHRcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICovXG4gICAgZnVuY3Rpb24gY3ViaWNEZXJpdmF0aXZlQXQocDAsIHAxLCBwMiwgcDMsIHQpIHtcbiAgICAgICAgdmFyIG9uZXQgPSAxIC0gdDtcbiAgICAgICAgcmV0dXJuIDMgKiAoXG4gICAgICAgICAgICAoKHAxIC0gcDApICogb25ldCArIDIgKiAocDIgLSBwMSkgKiB0KSAqIG9uZXRcbiAgICAgICAgICAgICsgKHAzIC0gcDIpICogdCAqIHRcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDorqHnrpfkuInmrKHotJ3loZ7lsJTmlrnnqIvmoLnvvIzkvb/nlKjnm5vph5HlhazlvI9cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS9jdXJ2ZVxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcDBcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHAxXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBwMlxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcDNcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHZhbFxuICAgICAqIEBwYXJhbSAge0FycmF5LjxudW1iZXI+fSByb290c1xuICAgICAqIEByZXR1cm4ge251bWJlcn0g5pyJ5pWI5qC55pWw55uuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3ViaWNSb290QXQocDAsIHAxLCBwMiwgcDMsIHZhbCwgcm9vdHMpIHtcbiAgICAgICAgLy8gRXZhbHVhdGUgcm9vdHMgb2YgY3ViaWMgZnVuY3Rpb25zXG4gICAgICAgIHZhciBhID0gcDMgKyAzICogKHAxIC0gcDIpIC0gcDA7XG4gICAgICAgIHZhciBiID0gMyAqIChwMiAtIHAxICogMiArIHAwKTtcbiAgICAgICAgdmFyIGMgPSAzICogKHAxICAtIHAwKTtcbiAgICAgICAgdmFyIGQgPSBwMCAtIHZhbDtcblxuICAgICAgICB2YXIgQSA9IGIgKiBiIC0gMyAqIGEgKiBjO1xuICAgICAgICB2YXIgQiA9IGIgKiBjIC0gOSAqIGEgKiBkO1xuICAgICAgICB2YXIgQyA9IGMgKiBjIC0gMyAqIGIgKiBkO1xuXG4gICAgICAgIHZhciBuID0gMDtcblxuICAgICAgICBpZiAoaXNBcm91bmRaZXJvKEEpICYmIGlzQXJvdW5kWmVybyhCKSkge1xuICAgICAgICAgICAgaWYgKGlzQXJvdW5kWmVybyhiKSkge1xuICAgICAgICAgICAgICAgIHJvb3RzWzBdID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciB0MSA9IC1jIC8gYjsgIC8vdDEsIHQyLCB0MywgYiBpcyBub3QgemVyb1xuICAgICAgICAgICAgICAgIGlmICh0MSA+PSAwICYmIHQxIDw9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcm9vdHNbbisrXSA9IHQxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBkaXNjID0gQiAqIEIgLSA0ICogQSAqIEM7XG5cbiAgICAgICAgICAgIGlmIChpc0Fyb3VuZFplcm8oZGlzYykpIHtcbiAgICAgICAgICAgICAgICB2YXIgSyA9IEIgLyBBO1xuICAgICAgICAgICAgICAgIHZhciB0MSA9IC1iIC8gYSArIEs7ICAvLyB0MSwgYSBpcyBub3QgemVyb1xuICAgICAgICAgICAgICAgIHZhciB0MiA9IC1LIC8gMjsgIC8vIHQyLCB0M1xuICAgICAgICAgICAgICAgIGlmICh0MSA+PSAwICYmIHQxIDw9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcm9vdHNbbisrXSA9IHQxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodDIgPj0gMCAmJiB0MiA8PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvb3RzW24rK10gPSB0MjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChkaXNjID4gMCkge1xuICAgICAgICAgICAgICAgIHZhciBkaXNjU3FydCA9IG1hdGhTcXJ0KGRpc2MpO1xuICAgICAgICAgICAgICAgIHZhciBZMSA9IEEgKiBiICsgMS41ICogYSAqICgtQiArIGRpc2NTcXJ0KTtcbiAgICAgICAgICAgICAgICB2YXIgWTIgPSBBICogYiArIDEuNSAqIGEgKiAoLUIgLSBkaXNjU3FydCk7XG4gICAgICAgICAgICAgICAgaWYgKFkxIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBZMSA9IC1tYXRoUG93KC1ZMSwgT05FX1RISVJEKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIFkxID0gbWF0aFBvdyhZMSwgT05FX1RISVJEKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKFkyIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBZMiA9IC1tYXRoUG93KC1ZMiwgT05FX1RISVJEKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIFkyID0gbWF0aFBvdyhZMiwgT05FX1RISVJEKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHQxID0gKC1iIC0gKFkxICsgWTIpKSAvICgzICogYSk7XG4gICAgICAgICAgICAgICAgaWYgKHQxID49IDAgJiYgdDEgPD0gMSkge1xuICAgICAgICAgICAgICAgICAgICByb290c1tuKytdID0gdDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIFQgPSAoMiAqIEEgKiBiIC0gMyAqIGEgKiBCKSAvICgyICogbWF0aFNxcnQoQSAqIEEgKiBBKSk7XG4gICAgICAgICAgICAgICAgdmFyIHRoZXRhID0gTWF0aC5hY29zKFQpIC8gMztcbiAgICAgICAgICAgICAgICB2YXIgQVNxcnQgPSBtYXRoU3FydChBKTtcbiAgICAgICAgICAgICAgICB2YXIgdG1wID0gTWF0aC5jb3ModGhldGEpO1xuXG4gICAgICAgICAgICAgICAgdmFyIHQxID0gKC1iIC0gMiAqIEFTcXJ0ICogdG1wKSAvICgzICogYSk7XG4gICAgICAgICAgICAgICAgdmFyIHQyID0gKC1iICsgQVNxcnQgKiAodG1wICsgVEhSRUVfU1FSVCAqIE1hdGguc2luKHRoZXRhKSkpIC8gKDMgKiBhKTtcbiAgICAgICAgICAgICAgICB2YXIgdDMgPSAoLWIgKyBBU3FydCAqICh0bXAgLSBUSFJFRV9TUVJUICogTWF0aC5zaW4odGhldGEpKSkgLyAoMyAqIGEpO1xuICAgICAgICAgICAgICAgIGlmICh0MSA+PSAwICYmIHQxIDw9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcm9vdHNbbisrXSA9IHQxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodDIgPj0gMCAmJiB0MiA8PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvb3RzW24rK10gPSB0MjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHQzID49IDAgJiYgdDMgPD0gMSkge1xuICAgICAgICAgICAgICAgICAgICByb290c1tuKytdID0gdDM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOiuoeeul+S4ieasoei0neWhnuWwlOaWueeoi+aegemZkOWAvOeahOS9jee9rlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL2N1cnZlXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBwMFxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcDFcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHAyXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBwM1xuICAgICAqIEBwYXJhbSAge0FycmF5LjxudW1iZXI+fSBleHRyZW1hXG4gICAgICogQHJldHVybiB7bnVtYmVyfSDmnInmlYjmlbDnm65cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjdWJpY0V4dHJlbWEocDAsIHAxLCBwMiwgcDMsIGV4dHJlbWEpIHtcbiAgICAgICAgdmFyIGIgPSA2ICogcDIgLSAxMiAqIHAxICsgNiAqIHAwO1xuICAgICAgICB2YXIgYSA9IDkgKiBwMSArIDMgKiBwMyAtIDMgKiBwMCAtIDkgKiBwMjtcbiAgICAgICAgdmFyIGMgPSAzICogcDEgLSAzICogcDA7XG5cbiAgICAgICAgdmFyIG4gPSAwO1xuICAgICAgICBpZiAoaXNBcm91bmRaZXJvKGEpKSB7XG4gICAgICAgICAgICBpZiAoaXNOb3RBcm91bmRaZXJvKGIpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHQxID0gLWMgLyBiO1xuICAgICAgICAgICAgICAgIGlmICh0MSA+PSAwICYmIHQxIDw9MSkge1xuICAgICAgICAgICAgICAgICAgICBleHRyZW1hW24rK10gPSB0MTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgZGlzYyA9IGIgKiBiIC0gNCAqIGEgKiBjO1xuICAgICAgICAgICAgaWYgKGlzQXJvdW5kWmVybyhkaXNjKSkge1xuICAgICAgICAgICAgICAgIGV4dHJlbWFbMF0gPSAtYiAvICgyICogYSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChkaXNjID4gMCkge1xuICAgICAgICAgICAgICAgIHZhciBkaXNjU3FydCA9IG1hdGhTcXJ0KGRpc2MpO1xuICAgICAgICAgICAgICAgIHZhciB0MSA9ICgtYiArIGRpc2NTcXJ0KSAvICgyICogYSk7XG4gICAgICAgICAgICAgICAgdmFyIHQyID0gKC1iIC0gZGlzY1NxcnQpIC8gKDIgKiBhKTtcbiAgICAgICAgICAgICAgICBpZiAodDEgPj0gMCAmJiB0MSA8PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4dHJlbWFbbisrXSA9IHQxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodDIgPj0gMCAmJiB0MiA8PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4dHJlbWFbbisrXSA9IHQyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDnu4bliIbkuInmrKHotJ3loZ7lsJTmm7Lnur9cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS9jdXJ2ZVxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcDBcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHAxXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBwMlxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcDNcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHRcbiAgICAgKiBAcGFyYW0gIHtBcnJheS48bnVtYmVyPn0gb3V0XG4gICAgICovXG4gICAgZnVuY3Rpb24gY3ViaWNTdWJkaXZpZGUocDAsIHAxLCBwMiwgcDMsIHQsIG91dCkge1xuICAgICAgICB2YXIgcDAxID0gKHAxIC0gcDApICogdCArIHAwO1xuICAgICAgICB2YXIgcDEyID0gKHAyIC0gcDEpICogdCArIHAxO1xuICAgICAgICB2YXIgcDIzID0gKHAzIC0gcDIpICogdCArIHAyO1xuXG4gICAgICAgIHZhciBwMDEyID0gKHAxMiAtIHAwMSkgKiB0ICsgcDAxO1xuICAgICAgICB2YXIgcDEyMyA9IChwMjMgLSBwMTIpICogdCArIHAxMjtcblxuICAgICAgICB2YXIgcDAxMjMgPSAocDEyMyAtIHAwMTIpICogdCArIHAwMTI7XG4gICAgICAgIC8vIFNlZzBcbiAgICAgICAgb3V0WzBdID0gcDA7XG4gICAgICAgIG91dFsxXSA9IHAwMTtcbiAgICAgICAgb3V0WzJdID0gcDAxMjtcbiAgICAgICAgb3V0WzNdID0gcDAxMjM7XG4gICAgICAgIC8vIFNlZzFcbiAgICAgICAgb3V0WzRdID0gcDAxMjM7XG4gICAgICAgIG91dFs1XSA9IHAxMjM7XG4gICAgICAgIG91dFs2XSA9IHAyMztcbiAgICAgICAgb3V0WzddID0gcDM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog5oqV5bCE54K55Yiw5LiJ5qyh6LSd5aGe5bCU5puy57q/5LiK77yM6L+U5Zue5oqV5bCE6Led56a744CCXG4gICAgICog5oqV5bCE54K55pyJ5Y+v6IO95Lya5pyJ5LiA5Liq5oiW6ICF5aSa5Liq77yM6L+Z6YeM5Y+q6L+U5Zue5YW25Lit6Led56a75pyA55+t55qE5LiA5Liq44CCXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHgwXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkwXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHgxXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkxXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHgyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHgzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geVxuICAgICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IFtvdXRdIOaKleWwhOeCuVxuICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjdWJpY1Byb2plY3RQb2ludChcbiAgICAgICAgeDAsIHkwLCB4MSwgeTEsIHgyLCB5MiwgeDMsIHkzLFxuICAgICAgICB4LCB5LCBvdXRcbiAgICApIHtcbiAgICAgICAgLy8gaHR0cDovL3BvbWF4LmdpdGh1Yi5pby9iZXppZXJpbmZvLyNwcm9qZWN0aW9uc1xuICAgICAgICB2YXIgdDtcbiAgICAgICAgdmFyIGludGVydmFsID0gMC4wMDU7XG4gICAgICAgIHZhciBkID0gSW5maW5pdHk7XG4gICAgICAgIHZhciBwcmV2O1xuICAgICAgICB2YXIgbmV4dDtcbiAgICAgICAgdmFyIGQxO1xuICAgICAgICB2YXIgZDI7XG5cbiAgICAgICAgX3YwWzBdID0geDtcbiAgICAgICAgX3YwWzFdID0geTtcblxuICAgICAgICAvLyDlhYjnspfnlaXkvLDorqHkuIDkuIvlj6/og73nmoTmnIDlsI/ot53nprvnmoQgdCDlgLxcbiAgICAgICAgLy8gUEVORElOR1xuICAgICAgICBmb3IgKHZhciBfdCA9IDA7IF90IDwgMTsgX3QgKz0gMC4wNSkge1xuICAgICAgICAgICAgX3YxWzBdID0gY3ViaWNBdCh4MCwgeDEsIHgyLCB4MywgX3QpO1xuICAgICAgICAgICAgX3YxWzFdID0gY3ViaWNBdCh5MCwgeTEsIHkyLCB5MywgX3QpO1xuICAgICAgICAgICAgZDEgPSB2MkRpc3RTcXVhcmUoX3YwLCBfdjEpO1xuICAgICAgICAgICAgaWYgKGQxIDwgZCkge1xuICAgICAgICAgICAgICAgIHQgPSBfdDtcbiAgICAgICAgICAgICAgICBkID0gZDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZCA9IEluZmluaXR5O1xuXG4gICAgICAgIC8vIEF0IG1vc3QgMzIgaXRlcmF0aW9uXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMzI7IGkrKykge1xuICAgICAgICAgICAgaWYgKGludGVydmFsIDwgRVBTSUxPTl9OVU1FUklDKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcmV2ID0gdCAtIGludGVydmFsO1xuICAgICAgICAgICAgbmV4dCA9IHQgKyBpbnRlcnZhbDtcbiAgICAgICAgICAgIC8vIHQgLSBpbnRlcnZhbFxuICAgICAgICAgICAgX3YxWzBdID0gY3ViaWNBdCh4MCwgeDEsIHgyLCB4MywgcHJldik7XG4gICAgICAgICAgICBfdjFbMV0gPSBjdWJpY0F0KHkwLCB5MSwgeTIsIHkzLCBwcmV2KTtcblxuICAgICAgICAgICAgZDEgPSB2MkRpc3RTcXVhcmUoX3YxLCBfdjApO1xuXG4gICAgICAgICAgICBpZiAocHJldiA+PSAwICYmIGQxIDwgZCkge1xuICAgICAgICAgICAgICAgIHQgPSBwcmV2O1xuICAgICAgICAgICAgICAgIGQgPSBkMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHQgKyBpbnRlcnZhbFxuICAgICAgICAgICAgICAgIF92MlswXSA9IGN1YmljQXQoeDAsIHgxLCB4MiwgeDMsIG5leHQpO1xuICAgICAgICAgICAgICAgIF92MlsxXSA9IGN1YmljQXQoeTAsIHkxLCB5MiwgeTMsIG5leHQpO1xuICAgICAgICAgICAgICAgIGQyID0gdjJEaXN0U3F1YXJlKF92MiwgX3YwKTtcblxuICAgICAgICAgICAgICAgIGlmIChuZXh0IDw9IDEgJiYgZDIgPCBkKSB7XG4gICAgICAgICAgICAgICAgICAgIHQgPSBuZXh0O1xuICAgICAgICAgICAgICAgICAgICBkID0gZDI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpbnRlcnZhbCAqPSAwLjU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHRcbiAgICAgICAgaWYgKG91dCkge1xuICAgICAgICAgICAgb3V0WzBdID0gY3ViaWNBdCh4MCwgeDEsIHgyLCB4MywgdCk7XG4gICAgICAgICAgICBvdXRbMV0gPSBjdWJpY0F0KHkwLCB5MSwgeTIsIHkzLCB0KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBjb25zb2xlLmxvZyhpbnRlcnZhbCwgaSk7XG4gICAgICAgIHJldHVybiBtYXRoU3FydChkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDorqHnrpfkuozmrKHmlrnotJ3loZ7lsJTlgLxcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHAwXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBwMVxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcDJcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHRcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICovXG4gICAgZnVuY3Rpb24gcXVhZHJhdGljQXQocDAsIHAxLCBwMiwgdCkge1xuICAgICAgICB2YXIgb25ldCA9IDEgLSB0O1xuICAgICAgICByZXR1cm4gb25ldCAqIChvbmV0ICogcDAgKyAyICogdCAqIHAxKSArIHQgKiB0ICogcDI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog6K6h566X5LqM5qyh5pa56LSd5aGe5bCU5a+85pWw5YC8XG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBwMFxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcDFcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHAyXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSB0XG4gICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHF1YWRyYXRpY0Rlcml2YXRpdmVBdChwMCwgcDEsIHAyLCB0KSB7XG4gICAgICAgIHJldHVybiAyICogKCgxIC0gdCkgKiAocDEgLSBwMCkgKyB0ICogKHAyIC0gcDEpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDorqHnrpfkuozmrKHmlrnotJ3loZ7lsJTmlrnnqIvmoLlcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHAwXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBwMVxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcDJcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHRcbiAgICAgKiBAcGFyYW0gIHtBcnJheS48bnVtYmVyPn0gcm9vdHNcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IOacieaViOagueaVsOebrlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHF1YWRyYXRpY1Jvb3RBdChwMCwgcDEsIHAyLCB2YWwsIHJvb3RzKSB7XG4gICAgICAgIHZhciBhID0gcDAgLSAyICogcDEgKyBwMjtcbiAgICAgICAgdmFyIGIgPSAyICogKHAxIC0gcDApO1xuICAgICAgICB2YXIgYyA9IHAwIC0gdmFsO1xuXG4gICAgICAgIHZhciBuID0gMDtcbiAgICAgICAgaWYgKGlzQXJvdW5kWmVybyhhKSkge1xuICAgICAgICAgICAgaWYgKGlzTm90QXJvdW5kWmVybyhiKSkge1xuICAgICAgICAgICAgICAgIHZhciB0MSA9IC1jIC8gYjtcbiAgICAgICAgICAgICAgICBpZiAodDEgPj0gMCAmJiB0MSA8PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvb3RzW24rK10gPSB0MTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgZGlzYyA9IGIgKiBiIC0gNCAqIGEgKiBjO1xuICAgICAgICAgICAgaWYgKGlzQXJvdW5kWmVybyhkaXNjKSkge1xuICAgICAgICAgICAgICAgIHZhciB0MSA9IC1iIC8gKDIgKiBhKTtcbiAgICAgICAgICAgICAgICBpZiAodDEgPj0gMCAmJiB0MSA8PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvb3RzW24rK10gPSB0MTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChkaXNjID4gMCkge1xuICAgICAgICAgICAgICAgIHZhciBkaXNjU3FydCA9IG1hdGhTcXJ0KGRpc2MpO1xuICAgICAgICAgICAgICAgIHZhciB0MSA9ICgtYiArIGRpc2NTcXJ0KSAvICgyICogYSk7XG4gICAgICAgICAgICAgICAgdmFyIHQyID0gKC1iIC0gZGlzY1NxcnQpIC8gKDIgKiBhKTtcbiAgICAgICAgICAgICAgICBpZiAodDEgPj0gMCAmJiB0MSA8PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvb3RzW24rK10gPSB0MTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHQyID49IDAgJiYgdDIgPD0gMSkge1xuICAgICAgICAgICAgICAgICAgICByb290c1tuKytdID0gdDI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOiuoeeul+S6jOasoei0neWhnuWwlOaWueeoi+aegemZkOWAvFxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL2N1cnZlXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBwMFxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcDFcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHAyXG4gICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHF1YWRyYXRpY0V4dHJlbXVtKHAwLCBwMSwgcDIpIHtcbiAgICAgICAgdmFyIGRpdmlkZXIgPSBwMCArIHAyIC0gMiAqIHAxO1xuICAgICAgICBpZiAoZGl2aWRlciA9PT0gMCkge1xuICAgICAgICAgICAgLy8gcDEgaXMgY2VudGVyIG9mIHAwIGFuZCBwMlxuICAgICAgICAgICAgcmV0dXJuIDAuNTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAocDAgLSBwMSkgLyBkaXZpZGVyO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog57uG5YiG5LqM5qyh6LSd5aGe5bCU5puy57q/XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvY3VydmVcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHAwXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBwMVxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcDJcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHRcbiAgICAgKiBAcGFyYW0gIHtBcnJheS48bnVtYmVyPn0gb3V0XG4gICAgICovXG4gICAgZnVuY3Rpb24gcXVhZHJhdGljU3ViZGl2aWRlKHAwLCBwMSwgcDIsIHQsIG91dCkge1xuICAgICAgICB2YXIgcDAxID0gKHAxIC0gcDApICogdCArIHAwO1xuICAgICAgICB2YXIgcDEyID0gKHAyIC0gcDEpICogdCArIHAxO1xuICAgICAgICB2YXIgcDAxMiA9IChwMTIgLSBwMDEpICogdCArIHAwMTtcblxuICAgICAgICAvLyBTZWcwXG4gICAgICAgIG91dFswXSA9IHAwO1xuICAgICAgICBvdXRbMV0gPSBwMDE7XG4gICAgICAgIG91dFsyXSA9IHAwMTI7XG5cbiAgICAgICAgLy8gU2VnMVxuICAgICAgICBvdXRbM10gPSBwMDEyO1xuICAgICAgICBvdXRbNF0gPSBwMTI7XG4gICAgICAgIG91dFs1XSA9IHAyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOaKleWwhOeCueWIsOS6jOasoei0neWhnuWwlOabsue6v+S4iu+8jOi/lOWbnuaKleWwhOi3neemu+OAglxuICAgICAqIOaKleWwhOeCueacieWPr+iDveS8muacieS4gOS4quaIluiAheWkmuS4qu+8jOi/memHjOWPqui/lOWbnuWFtuS4rei3neemu+acgOefreeahOS4gOS4quOAglxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4MFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5MFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4MVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5MVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4MlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5MlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHlcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBvdXQg5oqV5bCE54K5XG4gICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHF1YWRyYXRpY1Byb2plY3RQb2ludChcbiAgICAgICAgeDAsIHkwLCB4MSwgeTEsIHgyLCB5MixcbiAgICAgICAgeCwgeSwgb3V0XG4gICAgKSB7XG4gICAgICAgIC8vIGh0dHA6Ly9wb21heC5naXRodWIuaW8vYmV6aWVyaW5mby8jcHJvamVjdGlvbnNcbiAgICAgICAgdmFyIHQ7XG4gICAgICAgIHZhciBpbnRlcnZhbCA9IDAuMDA1O1xuICAgICAgICB2YXIgZCA9IEluZmluaXR5O1xuXG4gICAgICAgIF92MFswXSA9IHg7XG4gICAgICAgIF92MFsxXSA9IHk7XG5cbiAgICAgICAgLy8g5YWI57KX55Wl5Lyw6K6h5LiA5LiL5Y+v6IO955qE5pyA5bCP6Led56a755qEIHQg5YC8XG4gICAgICAgIC8vIFBFTkRJTkdcbiAgICAgICAgZm9yICh2YXIgX3QgPSAwOyBfdCA8IDE7IF90ICs9IDAuMDUpIHtcbiAgICAgICAgICAgIF92MVswXSA9IHF1YWRyYXRpY0F0KHgwLCB4MSwgeDIsIF90KTtcbiAgICAgICAgICAgIF92MVsxXSA9IHF1YWRyYXRpY0F0KHkwLCB5MSwgeTIsIF90KTtcbiAgICAgICAgICAgIHZhciBkMSA9IHYyRGlzdFNxdWFyZShfdjAsIF92MSk7XG4gICAgICAgICAgICBpZiAoZDEgPCBkKSB7XG4gICAgICAgICAgICAgICAgdCA9IF90O1xuICAgICAgICAgICAgICAgIGQgPSBkMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBkID0gSW5maW5pdHk7XG5cbiAgICAgICAgLy8gQXQgbW9zdCAzMiBpdGVyYXRpb25cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAzMjsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoaW50ZXJ2YWwgPCBFUFNJTE9OX05VTUVSSUMpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBwcmV2ID0gdCAtIGludGVydmFsO1xuICAgICAgICAgICAgdmFyIG5leHQgPSB0ICsgaW50ZXJ2YWw7XG4gICAgICAgICAgICAvLyB0IC0gaW50ZXJ2YWxcbiAgICAgICAgICAgIF92MVswXSA9IHF1YWRyYXRpY0F0KHgwLCB4MSwgeDIsIHByZXYpO1xuICAgICAgICAgICAgX3YxWzFdID0gcXVhZHJhdGljQXQoeTAsIHkxLCB5MiwgcHJldik7XG5cbiAgICAgICAgICAgIHZhciBkMSA9IHYyRGlzdFNxdWFyZShfdjEsIF92MCk7XG5cbiAgICAgICAgICAgIGlmIChwcmV2ID49IDAgJiYgZDEgPCBkKSB7XG4gICAgICAgICAgICAgICAgdCA9IHByZXY7XG4gICAgICAgICAgICAgICAgZCA9IGQxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gdCArIGludGVydmFsXG4gICAgICAgICAgICAgICAgX3YyWzBdID0gcXVhZHJhdGljQXQoeDAsIHgxLCB4MiwgbmV4dCk7XG4gICAgICAgICAgICAgICAgX3YyWzFdID0gcXVhZHJhdGljQXQoeTAsIHkxLCB5MiwgbmV4dCk7XG4gICAgICAgICAgICAgICAgdmFyIGQyID0gdjJEaXN0U3F1YXJlKF92MiwgX3YwKTtcbiAgICAgICAgICAgICAgICBpZiAobmV4dCA8PSAxICYmIGQyIDwgZCkge1xuICAgICAgICAgICAgICAgICAgICB0ID0gbmV4dDtcbiAgICAgICAgICAgICAgICAgICAgZCA9IGQyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaW50ZXJ2YWwgKj0gMC41O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyB0XG4gICAgICAgIGlmIChvdXQpIHtcbiAgICAgICAgICAgIG91dFswXSA9IHF1YWRyYXRpY0F0KHgwLCB4MSwgeDIsIHQpO1xuICAgICAgICAgICAgb3V0WzFdID0gcXVhZHJhdGljQXQoeTAsIHkxLCB5MiwgdCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY29uc29sZS5sb2coaW50ZXJ2YWwsIGkpO1xuICAgICAgICByZXR1cm4gbWF0aFNxcnQoZCk7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XG5cbiAgICAgICAgY3ViaWNBdDogY3ViaWNBdCxcblxuICAgICAgICBjdWJpY0Rlcml2YXRpdmVBdDogY3ViaWNEZXJpdmF0aXZlQXQsXG5cbiAgICAgICAgY3ViaWNSb290QXQ6IGN1YmljUm9vdEF0LFxuXG4gICAgICAgIGN1YmljRXh0cmVtYTogY3ViaWNFeHRyZW1hLFxuXG4gICAgICAgIGN1YmljU3ViZGl2aWRlOiBjdWJpY1N1YmRpdmlkZSxcblxuICAgICAgICBjdWJpY1Byb2plY3RQb2ludDogY3ViaWNQcm9qZWN0UG9pbnQsXG5cbiAgICAgICAgcXVhZHJhdGljQXQ6IHF1YWRyYXRpY0F0LFxuXG4gICAgICAgIHF1YWRyYXRpY0Rlcml2YXRpdmVBdDogcXVhZHJhdGljRGVyaXZhdGl2ZUF0LFxuXG4gICAgICAgIHF1YWRyYXRpY1Jvb3RBdDogcXVhZHJhdGljUm9vdEF0LFxuXG4gICAgICAgIHF1YWRyYXRpY0V4dHJlbXVtOiBxdWFkcmF0aWNFeHRyZW11bSxcblxuICAgICAgICBxdWFkcmF0aWNTdWJkaXZpZGU6IHF1YWRyYXRpY1N1YmRpdmlkZSxcblxuICAgICAgICBxdWFkcmF0aWNQcm9qZWN0UG9pbnQ6IHF1YWRyYXRpY1Byb2plY3RQb2ludFxuICAgIH07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi96cmVuZGVyL2xpYi9jb3JlL2N1cnZlLmpzXG4gKiogbW9kdWxlIGlkID0gMjZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQGF1dGhvciBZaSBTaGVuKGh0dHBzOi8vZ2l0aHViLmNvbS9waXNzYW5nKVxuICovXG5cblxuICAgIHZhciB2ZWMyID0gcmVxdWlyZSgnLi92ZWN0b3InKTtcbiAgICB2YXIgY3VydmUgPSByZXF1aXJlKCcuL2N1cnZlJyk7XG5cbiAgICB2YXIgYmJveCA9IHt9O1xuICAgIHZhciBtYXRoTWluID0gTWF0aC5taW47XG4gICAgdmFyIG1hdGhNYXggPSBNYXRoLm1heDtcbiAgICB2YXIgbWF0aFNpbiA9IE1hdGguc2luO1xuICAgIHZhciBtYXRoQ29zID0gTWF0aC5jb3M7XG5cbiAgICB2YXIgc3RhcnQgPSB2ZWMyLmNyZWF0ZSgpO1xuICAgIHZhciBlbmQgPSB2ZWMyLmNyZWF0ZSgpO1xuICAgIHZhciBleHRyZW1pdHkgPSB2ZWMyLmNyZWF0ZSgpO1xuXG4gICAgdmFyIFBJMiA9IE1hdGguUEkgKiAyO1xuICAgIC8qKlxuICAgICAqIOS7jumhtueCueaVsOe7hOS4reiuoeeul+WHuuacgOWwj+WMheWbtOebku+8jOWGmeWFpWBtaW5g5ZKMYG1heGDkuK1cbiAgICAgKiBAbW9kdWxlIHpyZW5kZXIvY29yZS9iYm94XG4gICAgICogQHBhcmFtIHtBcnJheTxPYmplY3Q+fSBwb2ludHMg6aG254K55pWw57uEXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1pblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtYXhcbiAgICAgKi9cbiAgICBiYm94LmZyb21Qb2ludHMgPSBmdW5jdGlvbihwb2ludHMsIG1pbiwgbWF4KSB7XG4gICAgICAgIGlmIChwb2ludHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHAgPSBwb2ludHNbMF07XG4gICAgICAgIHZhciBsZWZ0ID0gcFswXTtcbiAgICAgICAgdmFyIHJpZ2h0ID0gcFswXTtcbiAgICAgICAgdmFyIHRvcCA9IHBbMV07XG4gICAgICAgIHZhciBib3R0b20gPSBwWzFdO1xuICAgICAgICB2YXIgaTtcblxuICAgICAgICBmb3IgKGkgPSAxOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBwID0gcG9pbnRzW2ldO1xuICAgICAgICAgICAgbGVmdCA9IG1hdGhNaW4obGVmdCwgcFswXSk7XG4gICAgICAgICAgICByaWdodCA9IG1hdGhNYXgocmlnaHQsIHBbMF0pO1xuICAgICAgICAgICAgdG9wID0gbWF0aE1pbih0b3AsIHBbMV0pO1xuICAgICAgICAgICAgYm90dG9tID0gbWF0aE1heChib3R0b20sIHBbMV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgbWluWzBdID0gbGVmdDtcbiAgICAgICAgbWluWzFdID0gdG9wO1xuICAgICAgICBtYXhbMF0gPSByaWdodDtcbiAgICAgICAgbWF4WzFdID0gYm90dG9tO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS9iYm94XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHgwXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkwXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHgxXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkxXG4gICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gbWluXG4gICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gbWF4XG4gICAgICovXG4gICAgYmJveC5mcm9tTGluZSA9IGZ1bmN0aW9uICh4MCwgeTAsIHgxLCB5MSwgbWluLCBtYXgpIHtcbiAgICAgICAgbWluWzBdID0gbWF0aE1pbih4MCwgeDEpO1xuICAgICAgICBtaW5bMV0gPSBtYXRoTWluKHkwLCB5MSk7XG4gICAgICAgIG1heFswXSA9IG1hdGhNYXgoeDAsIHgxKTtcbiAgICAgICAgbWF4WzFdID0gbWF0aE1heCh5MCwgeTEpO1xuICAgIH07XG5cbiAgICB2YXIgeERpbSA9IFtdO1xuICAgIHZhciB5RGltID0gW107XG4gICAgLyoqXG4gICAgICog5LuO5LiJ6Zi26LSd5aGe5bCU5puy57q/KHAwLCBwMSwgcDIsIHAzKeS4reiuoeeul+WHuuacgOWwj+WMheWbtOebku+8jOWGmeWFpWBtaW5g5ZKMYG1heGDkuK1cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS9iYm94XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHgwXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkwXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHgxXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkxXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHgyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHgzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkzXG4gICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gbWluXG4gICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gbWF4XG4gICAgICovXG4gICAgYmJveC5mcm9tQ3ViaWMgPSBmdW5jdGlvbihcbiAgICAgICAgeDAsIHkwLCB4MSwgeTEsIHgyLCB5MiwgeDMsIHkzLCBtaW4sIG1heFxuICAgICkge1xuICAgICAgICB2YXIgY3ViaWNFeHRyZW1hID0gY3VydmUuY3ViaWNFeHRyZW1hO1xuICAgICAgICB2YXIgY3ViaWNBdCA9IGN1cnZlLmN1YmljQXQ7XG4gICAgICAgIHZhciBpO1xuICAgICAgICB2YXIgbiA9IGN1YmljRXh0cmVtYSh4MCwgeDEsIHgyLCB4MywgeERpbSk7XG4gICAgICAgIG1pblswXSA9IEluZmluaXR5O1xuICAgICAgICBtaW5bMV0gPSBJbmZpbml0eTtcbiAgICAgICAgbWF4WzBdID0gLUluZmluaXR5O1xuICAgICAgICBtYXhbMV0gPSAtSW5maW5pdHk7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgdmFyIHggPSBjdWJpY0F0KHgwLCB4MSwgeDIsIHgzLCB4RGltW2ldKTtcbiAgICAgICAgICAgIG1pblswXSA9IG1hdGhNaW4oeCwgbWluWzBdKTtcbiAgICAgICAgICAgIG1heFswXSA9IG1hdGhNYXgoeCwgbWF4WzBdKTtcbiAgICAgICAgfVxuICAgICAgICBuID0gY3ViaWNFeHRyZW1hKHkwLCB5MSwgeTIsIHkzLCB5RGltKTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgdmFyIHkgPSBjdWJpY0F0KHkwLCB5MSwgeTIsIHkzLCB5RGltW2ldKTtcbiAgICAgICAgICAgIG1pblsxXSA9IG1hdGhNaW4oeSwgbWluWzFdKTtcbiAgICAgICAgICAgIG1heFsxXSA9IG1hdGhNYXgoeSwgbWF4WzFdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG1pblswXSA9IG1hdGhNaW4oeDAsIG1pblswXSk7XG4gICAgICAgIG1heFswXSA9IG1hdGhNYXgoeDAsIG1heFswXSk7XG4gICAgICAgIG1pblswXSA9IG1hdGhNaW4oeDMsIG1pblswXSk7XG4gICAgICAgIG1heFswXSA9IG1hdGhNYXgoeDMsIG1heFswXSk7XG5cbiAgICAgICAgbWluWzFdID0gbWF0aE1pbih5MCwgbWluWzFdKTtcbiAgICAgICAgbWF4WzFdID0gbWF0aE1heCh5MCwgbWF4WzFdKTtcbiAgICAgICAgbWluWzFdID0gbWF0aE1pbih5MywgbWluWzFdKTtcbiAgICAgICAgbWF4WzFdID0gbWF0aE1heCh5MywgbWF4WzFdKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICog5LuO5LqM6Zi26LSd5aGe5bCU5puy57q/KHAwLCBwMSwgcDIp5Lit6K6h566X5Ye65pyA5bCP5YyF5Zu055uS77yM5YaZ5YWlYG1pbmDlkoxgbWF4YOS4rVxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL2Jib3hcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geDBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geTBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geDFcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geTFcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geDJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geTJcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBtaW5cbiAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBtYXhcbiAgICAgKi9cbiAgICBiYm94LmZyb21RdWFkcmF0aWMgPSBmdW5jdGlvbih4MCwgeTAsIHgxLCB5MSwgeDIsIHkyLCBtaW4sIG1heCkge1xuICAgICAgICB2YXIgcXVhZHJhdGljRXh0cmVtdW0gPSBjdXJ2ZS5xdWFkcmF0aWNFeHRyZW11bTtcbiAgICAgICAgdmFyIHF1YWRyYXRpY0F0ID0gY3VydmUucXVhZHJhdGljQXQ7XG4gICAgICAgIC8vIEZpbmQgZXh0cmVtaXRpZXMsIHdoZXJlIGRlcml2YXRpdmUgaW4geCBkaW0gb3IgeSBkaW0gaXMgemVyb1xuICAgICAgICB2YXIgdHggPVxuICAgICAgICAgICAgbWF0aE1heChcbiAgICAgICAgICAgICAgICBtYXRoTWluKHF1YWRyYXRpY0V4dHJlbXVtKHgwLCB4MSwgeDIpLCAxKSwgMFxuICAgICAgICAgICAgKTtcbiAgICAgICAgdmFyIHR5ID1cbiAgICAgICAgICAgIG1hdGhNYXgoXG4gICAgICAgICAgICAgICAgbWF0aE1pbihxdWFkcmF0aWNFeHRyZW11bSh5MCwgeTEsIHkyKSwgMSksIDBcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgdmFyIHggPSBxdWFkcmF0aWNBdCh4MCwgeDEsIHgyLCB0eCk7XG4gICAgICAgIHZhciB5ID0gcXVhZHJhdGljQXQoeTAsIHkxLCB5MiwgdHkpO1xuXG4gICAgICAgIG1pblswXSA9IG1hdGhNaW4oeDAsIHgyLCB4KTtcbiAgICAgICAgbWluWzFdID0gbWF0aE1pbih5MCwgeTIsIHkpO1xuICAgICAgICBtYXhbMF0gPSBtYXRoTWF4KHgwLCB4MiwgeCk7XG4gICAgICAgIG1heFsxXSA9IG1hdGhNYXgoeTAsIHkyLCB5KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICog5LuO5ZyG5byn5Lit6K6h566X5Ye65pyA5bCP5YyF5Zu055uS77yM5YaZ5YWlYG1pbmDlkoxgbWF4YOS4rVxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS9iYm94XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByeFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByeVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydEFuZ2xlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGVuZEFuZ2xlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGFudGljbG9ja3dpc2VcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBtaW5cbiAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBtYXhcbiAgICAgKi9cbiAgICBiYm94LmZyb21BcmMgPSBmdW5jdGlvbiAoXG4gICAgICAgIHgsIHksIHJ4LCByeSwgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGFudGljbG9ja3dpc2UsIG1pbiwgbWF4XG4gICAgKSB7XG4gICAgICAgIHZhciB2ZWMyTWluID0gdmVjMi5taW47XG4gICAgICAgIHZhciB2ZWMyTWF4ID0gdmVjMi5tYXg7XG5cbiAgICAgICAgdmFyIGRpZmYgPSBNYXRoLmFicyhzdGFydEFuZ2xlIC0gZW5kQW5nbGUpO1xuXG5cbiAgICAgICAgaWYgKGRpZmYgJSBQSTIgPCAxZS00ICYmIGRpZmYgPiAxZS00KSB7XG4gICAgICAgICAgICAvLyBJcyBhIGNpcmNsZVxuICAgICAgICAgICAgbWluWzBdID0geCAtIHJ4O1xuICAgICAgICAgICAgbWluWzFdID0geSAtIHJ5O1xuICAgICAgICAgICAgbWF4WzBdID0geCArIHJ4O1xuICAgICAgICAgICAgbWF4WzFdID0geSArIHJ5O1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhcnRbMF0gPSBtYXRoQ29zKHN0YXJ0QW5nbGUpICogcnggKyB4O1xuICAgICAgICBzdGFydFsxXSA9IG1hdGhTaW4oc3RhcnRBbmdsZSkgKiByeSArIHk7XG5cbiAgICAgICAgZW5kWzBdID0gbWF0aENvcyhlbmRBbmdsZSkgKiByeCArIHg7XG4gICAgICAgIGVuZFsxXSA9IG1hdGhTaW4oZW5kQW5nbGUpICogcnkgKyB5O1xuXG4gICAgICAgIHZlYzJNaW4obWluLCBzdGFydCwgZW5kKTtcbiAgICAgICAgdmVjMk1heChtYXgsIHN0YXJ0LCBlbmQpO1xuXG4gICAgICAgIC8vIFRocmVzaCB0byBbMCwgTWF0aC5QSSAqIDJdXG4gICAgICAgIHN0YXJ0QW5nbGUgPSBzdGFydEFuZ2xlICUgKFBJMik7XG4gICAgICAgIGlmIChzdGFydEFuZ2xlIDwgMCkge1xuICAgICAgICAgICAgc3RhcnRBbmdsZSA9IHN0YXJ0QW5nbGUgKyBQSTI7XG4gICAgICAgIH1cbiAgICAgICAgZW5kQW5nbGUgPSBlbmRBbmdsZSAlIChQSTIpO1xuICAgICAgICBpZiAoZW5kQW5nbGUgPCAwKSB7XG4gICAgICAgICAgICBlbmRBbmdsZSA9IGVuZEFuZ2xlICsgUEkyO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN0YXJ0QW5nbGUgPiBlbmRBbmdsZSAmJiAhYW50aWNsb2Nrd2lzZSkge1xuICAgICAgICAgICAgZW5kQW5nbGUgKz0gUEkyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHN0YXJ0QW5nbGUgPCBlbmRBbmdsZSAmJiBhbnRpY2xvY2t3aXNlKSB7XG4gICAgICAgICAgICBzdGFydEFuZ2xlICs9IFBJMjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYW50aWNsb2Nrd2lzZSkge1xuICAgICAgICAgICAgdmFyIHRtcCA9IGVuZEFuZ2xlO1xuICAgICAgICAgICAgZW5kQW5nbGUgPSBzdGFydEFuZ2xlO1xuICAgICAgICAgICAgc3RhcnRBbmdsZSA9IHRtcDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHZhciBudW1iZXIgPSAwO1xuICAgICAgICAvLyB2YXIgc3RlcCA9IChhbnRpY2xvY2t3aXNlID8gLU1hdGguUEkgOiBNYXRoLlBJKSAvIDI7XG4gICAgICAgIGZvciAodmFyIGFuZ2xlID0gMDsgYW5nbGUgPCBlbmRBbmdsZTsgYW5nbGUgKz0gTWF0aC5QSSAvIDIpIHtcbiAgICAgICAgICAgIGlmIChhbmdsZSA+IHN0YXJ0QW5nbGUpIHtcbiAgICAgICAgICAgICAgICBleHRyZW1pdHlbMF0gPSBtYXRoQ29zKGFuZ2xlKSAqIHJ4ICsgeDtcbiAgICAgICAgICAgICAgICBleHRyZW1pdHlbMV0gPSBtYXRoU2luKGFuZ2xlKSAqIHJ5ICsgeTtcblxuICAgICAgICAgICAgICAgIHZlYzJNaW4obWluLCBleHRyZW1pdHksIG1pbik7XG4gICAgICAgICAgICAgICAgdmVjMk1heChtYXgsIGV4dHJlbWl0eSwgbWF4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGJib3g7XG5cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3pyZW5kZXIvbGliL2NvcmUvYmJveC5qc1xuICoqIG1vZHVsZSBpZCA9IDI3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cblxuICAgIHZhciBDTUQgPSByZXF1aXJlKCcuLi9jb3JlL1BhdGhQcm94eScpLkNNRDtcbiAgICB2YXIgbGluZSA9IHJlcXVpcmUoJy4vbGluZScpO1xuICAgIHZhciBjdWJpYyA9IHJlcXVpcmUoJy4vY3ViaWMnKTtcbiAgICB2YXIgcXVhZHJhdGljID0gcmVxdWlyZSgnLi9xdWFkcmF0aWMnKTtcbiAgICB2YXIgYXJjID0gcmVxdWlyZSgnLi9hcmMnKTtcbiAgICB2YXIgbm9ybWFsaXplUmFkaWFuID0gcmVxdWlyZSgnLi91dGlsJykubm9ybWFsaXplUmFkaWFuO1xuICAgIHZhciBjdXJ2ZSA9IHJlcXVpcmUoJy4uL2NvcmUvY3VydmUnKTtcblxuICAgIHZhciB3aW5kaW5nTGluZSA9IHJlcXVpcmUoJy4vd2luZGluZ0xpbmUnKTtcblxuICAgIHZhciBjb250YWluU3Ryb2tlID0gbGluZS5jb250YWluU3Ryb2tlO1xuXG4gICAgdmFyIFBJMiA9IE1hdGguUEkgKiAyO1xuXG4gICAgdmFyIEVQU0lMT04gPSAxZS00O1xuXG4gICAgZnVuY3Rpb24gaXNBcm91bmRFcXVhbChhLCBiKSB7XG4gICAgICAgIHJldHVybiBNYXRoLmFicyhhIC0gYikgPCBFUFNJTE9OO1xuICAgIH1cblxuICAgIC8vIOS4tOaXtuaVsOe7hFxuICAgIHZhciByb290cyA9IFstMSwgLTEsIC0xXTtcbiAgICB2YXIgZXh0cmVtYSA9IFstMSwgLTFdO1xuXG4gICAgZnVuY3Rpb24gc3dhcEV4dHJlbWEoKSB7XG4gICAgICAgIHZhciB0bXAgPSBleHRyZW1hWzBdO1xuICAgICAgICBleHRyZW1hWzBdID0gZXh0cmVtYVsxXTtcbiAgICAgICAgZXh0cmVtYVsxXSA9IHRtcDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB3aW5kaW5nQ3ViaWMoeDAsIHkwLCB4MSwgeTEsIHgyLCB5MiwgeDMsIHkzLCB4LCB5KSB7XG4gICAgICAgIC8vIFF1aWNrIHJlamVjdFxuICAgICAgICBpZiAoXG4gICAgICAgICAgICAoeSA+IHkwICYmIHkgPiB5MSAmJiB5ID4geTIgJiYgeSA+IHkzKVxuICAgICAgICAgICAgfHwgKHkgPCB5MCAmJiB5IDwgeTEgJiYgeSA8IHkyICYmIHkgPCB5MylcbiAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgblJvb3RzID0gY3VydmUuY3ViaWNSb290QXQoeTAsIHkxLCB5MiwgeTMsIHksIHJvb3RzKTtcbiAgICAgICAgaWYgKG5Sb290cyA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgdyA9IDA7XG4gICAgICAgICAgICB2YXIgbkV4dHJlbWEgPSAtMTtcbiAgICAgICAgICAgIHZhciB5MF8sIHkxXztcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgblJvb3RzOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgdCA9IHJvb3RzW2ldO1xuXG4gICAgICAgICAgICAgICAgLy8gQXZvaWQgd2luZGluZyBlcnJvciB3aGVuIGludGVyc2VjdGlvbiBwb2ludCBpcyB0aGUgY29ubmVjdCBwb2ludCBvZiB0d28gbGluZSBvZiBwb2x5Z29uXG4gICAgICAgICAgICAgICAgdmFyIHVuaXQgPSAodCA9PT0gMCB8fCB0ID09PSAxKSA/IDAuNSA6IDE7XG5cbiAgICAgICAgICAgICAgICB2YXIgeF8gPSBjdXJ2ZS5jdWJpY0F0KHgwLCB4MSwgeDIsIHgzLCB0KTtcbiAgICAgICAgICAgICAgICBpZiAoeF8gPCB4KSB7IC8vIFF1aWNrIHJlamVjdFxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG5FeHRyZW1hIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBuRXh0cmVtYSA9IGN1cnZlLmN1YmljRXh0cmVtYSh5MCwgeTEsIHkyLCB5MywgZXh0cmVtYSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChleHRyZW1hWzFdIDwgZXh0cmVtYVswXSAmJiBuRXh0cmVtYSA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3YXBFeHRyZW1hKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgeTBfID0gY3VydmUuY3ViaWNBdCh5MCwgeTEsIHkyLCB5MywgZXh0cmVtYVswXSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuRXh0cmVtYSA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHkxXyA9IGN1cnZlLmN1YmljQXQoeTAsIHkxLCB5MiwgeTMsIGV4dHJlbWFbMV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChuRXh0cmVtYSA9PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIOWIhuaIkOS4ieauteWNleiwg+WHveaVsFxuICAgICAgICAgICAgICAgICAgICBpZiAodCA8IGV4dHJlbWFbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHcgKz0geTBfIDwgeTAgPyB1bml0IDogLXVuaXQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodCA8IGV4dHJlbWFbMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHcgKz0geTFfIDwgeTBfID8gdW5pdCA6IC11bml0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdyArPSB5MyA8IHkxXyA/IHVuaXQgOiAtdW5pdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8g5YiG5oiQ5Lik5q615Y2V6LCD5Ye95pWwXG4gICAgICAgICAgICAgICAgICAgIGlmICh0IDwgZXh0cmVtYVswXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdyArPSB5MF8gPCB5MCA/IHVuaXQgOiAtdW5pdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHcgKz0geTMgPCB5MF8gPyB1bml0IDogLXVuaXQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHdpbmRpbmdRdWFkcmF0aWMoeDAsIHkwLCB4MSwgeTEsIHgyLCB5MiwgeCwgeSkge1xuICAgICAgICAvLyBRdWljayByZWplY3RcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgKHkgPiB5MCAmJiB5ID4geTEgJiYgeSA+IHkyKVxuICAgICAgICAgICAgfHwgKHkgPCB5MCAmJiB5IDwgeTEgJiYgeSA8IHkyKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHZhciBuUm9vdHMgPSBjdXJ2ZS5xdWFkcmF0aWNSb290QXQoeTAsIHkxLCB5MiwgeSwgcm9vdHMpO1xuICAgICAgICBpZiAoblJvb3RzID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciB0ID0gY3VydmUucXVhZHJhdGljRXh0cmVtdW0oeTAsIHkxLCB5Mik7XG4gICAgICAgICAgICBpZiAodCA+PSAwICYmIHQgPD0gMSkge1xuICAgICAgICAgICAgICAgIHZhciB3ID0gMDtcbiAgICAgICAgICAgICAgICB2YXIgeV8gPSBjdXJ2ZS5xdWFkcmF0aWNBdCh5MCwgeTEsIHkyLCB0KTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5Sb290czsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBvbmUgZW5kcG9pbnQuXG4gICAgICAgICAgICAgICAgICAgIHZhciB1bml0ID0gKHJvb3RzW2ldID09PSAwIHx8IHJvb3RzW2ldID09PSAxKSA/IDAuNSA6IDE7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHhfID0gY3VydmUucXVhZHJhdGljQXQoeDAsIHgxLCB4Miwgcm9vdHNbaV0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoeF8gPCB4KSB7ICAgLy8gUXVpY2sgcmVqZWN0XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAocm9vdHNbaV0gPCB0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3ICs9IHlfIDwgeTAgPyB1bml0IDogLXVuaXQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3ICs9IHkyIDwgeV8gPyB1bml0IDogLXVuaXQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgb25lIGVuZHBvaW50LlxuICAgICAgICAgICAgICAgIHZhciB1bml0ID0gKHJvb3RzWzBdID09PSAwIHx8IHJvb3RzWzBdID09PSAxKSA/IDAuNSA6IDE7XG5cbiAgICAgICAgICAgICAgICB2YXIgeF8gPSBjdXJ2ZS5xdWFkcmF0aWNBdCh4MCwgeDEsIHgyLCByb290c1swXSk7XG4gICAgICAgICAgICAgICAgaWYgKHhfIDwgeCkgeyAgIC8vIFF1aWNrIHJlamVjdFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHkyIDwgeTAgPyB1bml0IDogLXVuaXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUT0RPXG4gICAgLy8gQXJjIOaXi+i9rFxuICAgIGZ1bmN0aW9uIHdpbmRpbmdBcmMoXG4gICAgICAgIGN4LCBjeSwgciwgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGFudGljbG9ja3dpc2UsIHgsIHlcbiAgICApIHtcbiAgICAgICAgeSAtPSBjeTtcbiAgICAgICAgaWYgKHkgPiByIHx8IHkgPCAtcikge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRtcCA9IE1hdGguc3FydChyICogciAtIHkgKiB5KTtcbiAgICAgICAgcm9vdHNbMF0gPSAtdG1wO1xuICAgICAgICByb290c1sxXSA9IHRtcDtcblxuICAgICAgICB2YXIgZGlmZiA9IE1hdGguYWJzKHN0YXJ0QW5nbGUgLSBlbmRBbmdsZSk7XG4gICAgICAgIGlmIChkaWZmIDwgMWUtNCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRpZmYgJSBQSTIgPCAxZS00KSB7XG4gICAgICAgICAgICAvLyBJcyBhIGNpcmNsZVxuICAgICAgICAgICAgc3RhcnRBbmdsZSA9IDA7XG4gICAgICAgICAgICBlbmRBbmdsZSA9IFBJMjtcbiAgICAgICAgICAgIHZhciBkaXIgPSBhbnRpY2xvY2t3aXNlID8gMSA6IC0xO1xuICAgICAgICAgICAgaWYgKHggPj0gcm9vdHNbMF0gKyBjeCAmJiB4IDw9IHJvb3RzWzFdICsgY3gpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGlyO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhbnRpY2xvY2t3aXNlKSB7XG4gICAgICAgICAgICB2YXIgdG1wID0gc3RhcnRBbmdsZTtcbiAgICAgICAgICAgIHN0YXJ0QW5nbGUgPSBub3JtYWxpemVSYWRpYW4oZW5kQW5nbGUpO1xuICAgICAgICAgICAgZW5kQW5nbGUgPSBub3JtYWxpemVSYWRpYW4odG1wKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0YXJ0QW5nbGUgPSBub3JtYWxpemVSYWRpYW4oc3RhcnRBbmdsZSk7XG4gICAgICAgICAgICBlbmRBbmdsZSA9IG5vcm1hbGl6ZVJhZGlhbihlbmRBbmdsZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXJ0QW5nbGUgPiBlbmRBbmdsZSkge1xuICAgICAgICAgICAgZW5kQW5nbGUgKz0gUEkyO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHcgPSAwO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDI7IGkrKykge1xuICAgICAgICAgICAgdmFyIHhfID0gcm9vdHNbaV07XG4gICAgICAgICAgICBpZiAoeF8gKyBjeCA+IHgpIHtcbiAgICAgICAgICAgICAgICB2YXIgYW5nbGUgPSBNYXRoLmF0YW4yKHksIHhfKTtcbiAgICAgICAgICAgICAgICB2YXIgZGlyID0gYW50aWNsb2Nrd2lzZSA/IDEgOiAtMTtcbiAgICAgICAgICAgICAgICBpZiAoYW5nbGUgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGFuZ2xlID0gUEkyICsgYW5nbGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgKGFuZ2xlID49IHN0YXJ0QW5nbGUgJiYgYW5nbGUgPD0gZW5kQW5nbGUpXG4gICAgICAgICAgICAgICAgICAgIHx8IChhbmdsZSArIFBJMiA+PSBzdGFydEFuZ2xlICYmIGFuZ2xlICsgUEkyIDw9IGVuZEFuZ2xlKVxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYW5nbGUgPiBNYXRoLlBJIC8gMiAmJiBhbmdsZSA8IE1hdGguUEkgKiAxLjUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpciA9IC1kaXI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdyArPSBkaXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbnRhaW5QYXRoKGRhdGEsIGxpbmVXaWR0aCwgaXNTdHJva2UsIHgsIHkpIHtcbiAgICAgICAgdmFyIHcgPSAwO1xuICAgICAgICB2YXIgeGkgPSAwO1xuICAgICAgICB2YXIgeWkgPSAwO1xuICAgICAgICB2YXIgeDAgPSAwO1xuICAgICAgICB2YXIgeTAgPSAwO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7KSB7XG4gICAgICAgICAgICB2YXIgY21kID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgLy8gQmVnaW4gYSBuZXcgc3VicGF0aFxuICAgICAgICAgICAgaWYgKGNtZCA9PT0gQ01ELk0gJiYgaSA+IDEpIHtcbiAgICAgICAgICAgICAgICAvLyBDbG9zZSBwcmV2aW91cyBzdWJwYXRoXG4gICAgICAgICAgICAgICAgaWYgKCFpc1N0cm9rZSkge1xuICAgICAgICAgICAgICAgICAgICB3ICs9IHdpbmRpbmdMaW5lKHhpLCB5aSwgeDAsIHkwLCB4LCB5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8g5aaC5p6c6KKr5Lu75L2V5LiA5LiqIHN1YnBhdGgg5YyF5ZCrXG4gICAgICAgICAgICAgICAgLy8gaWYgKHcgIT09IDApIHtcbiAgICAgICAgICAgICAgICAvLyAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaSA9PSAxKSB7XG4gICAgICAgICAgICAgICAgLy8g5aaC5p6c56ys5LiA5Liq5ZG95Luk5pivIEwsIEMsIFFcbiAgICAgICAgICAgICAgICAvLyDliJkgcHJldmlvdXMgcG9pbnQg5ZCM57uY5Yi25ZG95Luk55qE56ys5LiA5LiqIHBvaW50XG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyDnrKzkuIDkuKrlkb3ku6TkuLogQXJjIOeahOaDheWGteS4i+S8muWcqOWQjumdoueJueauiuWkhOeQhlxuICAgICAgICAgICAgICAgIHhpID0gZGF0YVtpXTtcbiAgICAgICAgICAgICAgICB5aSA9IGRhdGFbaSArIDFdO1xuXG4gICAgICAgICAgICAgICAgeDAgPSB4aTtcbiAgICAgICAgICAgICAgICB5MCA9IHlpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzd2l0Y2ggKGNtZCkge1xuICAgICAgICAgICAgICAgIGNhc2UgQ01ELk06XG4gICAgICAgICAgICAgICAgICAgIC8vIG1vdmVUbyDlkb3ku6Tph43mlrDliJvlu7rkuIDkuKrmlrDnmoQgc3VicGF0aCwg5bm25LiU5pu05paw5paw55qE6LW354K5XG4gICAgICAgICAgICAgICAgICAgIC8vIOWcqCBjbG9zZVBhdGgg55qE5pe25YCZ5L2/55SoXG4gICAgICAgICAgICAgICAgICAgIHgwID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICB5MCA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgeGkgPSB4MDtcbiAgICAgICAgICAgICAgICAgICAgeWkgPSB5MDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBDTUQuTDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzU3Ryb2tlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29udGFpblN0cm9rZSh4aSwgeWksIGRhdGFbaV0sIGRhdGFbaSArIDFdLCBsaW5lV2lkdGgsIHgsIHkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBOT1RFIOWcqOesrOS4gOS4quWRveS7pOS4uiBMLCBDLCBRIOeahOaXtuWAmeS8muiuoeeul+WHuiBOYU5cbiAgICAgICAgICAgICAgICAgICAgICAgIHcgKz0gd2luZGluZ0xpbmUoeGksIHlpLCBkYXRhW2ldLCBkYXRhW2kgKyAxXSwgeCwgeSkgfHwgMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB4aSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgeWkgPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgQ01ELkM6XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1N0cm9rZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1YmljLmNvbnRhaW5TdHJva2UoeGksIHlpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFbaSsrXSwgZGF0YVtpKytdLCBkYXRhW2krK10sIGRhdGFbaSsrXSwgZGF0YVtpXSwgZGF0YVtpICsgMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZVdpZHRoLCB4LCB5XG4gICAgICAgICAgICAgICAgICAgICAgICApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3ICs9IHdpbmRpbmdDdWJpYyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4aSwgeWksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVtpKytdLCBkYXRhW2krK10sIGRhdGFbaSsrXSwgZGF0YVtpKytdLCBkYXRhW2ldLCBkYXRhW2kgKyAxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4LCB5XG4gICAgICAgICAgICAgICAgICAgICAgICApIHx8IDA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgeGkgPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgIHlpID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIENNRC5ROlxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNTdHJva2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChxdWFkcmF0aWMuY29udGFpblN0cm9rZSh4aSwgeWksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVtpKytdLCBkYXRhW2krK10sIGRhdGFbaV0sIGRhdGFbaSArIDFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVXaWR0aCwgeCwgeVxuICAgICAgICAgICAgICAgICAgICAgICAgKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdyArPSB3aW5kaW5nUXVhZHJhdGljKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhpLCB5aSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhW2krK10sIGRhdGFbaSsrXSwgZGF0YVtpXSwgZGF0YVtpICsgMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeCwgeVxuICAgICAgICAgICAgICAgICAgICAgICAgKSB8fCAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHhpID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICB5aSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBDTUQuQTpcbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyBBcmMg5Yik5pat55qE5byA6ZSA5q+U6L6D5aSnXG4gICAgICAgICAgICAgICAgICAgIHZhciBjeCA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGN5ID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcnggPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgIHZhciByeSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRoZXRhID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZFRoZXRhID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPIEFyYyDml4vovaxcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBzaSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFudGljbG9ja3dpc2UgPSAxIC0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgeDEgPSBNYXRoLmNvcyh0aGV0YSkgKiByeCArIGN4O1xuICAgICAgICAgICAgICAgICAgICB2YXIgeTEgPSBNYXRoLnNpbih0aGV0YSkgKiByeSArIGN5O1xuICAgICAgICAgICAgICAgICAgICAvLyDkuI3mmK/nm7TmjqXkvb/nlKggYXJjIOWRveS7pFxuICAgICAgICAgICAgICAgICAgICBpZiAoaSA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHcgKz0gd2luZGluZ0xpbmUoeGksIHlpLCB4MSwgeTEsIHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8g56ys5LiA5Liq5ZG95Luk6LW354K56L+Y5pyq5a6a5LmJXG4gICAgICAgICAgICAgICAgICAgICAgICB4MCA9IHgxO1xuICAgICAgICAgICAgICAgICAgICAgICAgeTAgPSB5MTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyB6ciDkvb/nlKhzY2FsZeadpeaooeaLn+akreWchiwg6L+Z6YeM5Lmf5a+5eOWBmuS4gOWumueahOe8qeaUvlxuICAgICAgICAgICAgICAgICAgICB2YXIgX3ggPSAoeCAtIGN4KSAqIHJ5IC8gcnggKyBjeDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzU3Ryb2tlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXJjLmNvbnRhaW5TdHJva2UoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3gsIGN5LCByeSwgdGhldGEsIHRoZXRhICsgZFRoZXRhLCBhbnRpY2xvY2t3aXNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVXaWR0aCwgX3gsIHlcbiAgICAgICAgICAgICAgICAgICAgICAgICkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHcgKz0gd2luZGluZ0FyYyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjeCwgY3ksIHJ5LCB0aGV0YSwgdGhldGEgKyBkVGhldGEsIGFudGljbG9ja3dpc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3gsIHlcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgeGkgPSBNYXRoLmNvcyh0aGV0YSArIGRUaGV0YSkgKiByeCArIGN4O1xuICAgICAgICAgICAgICAgICAgICB5aSA9IE1hdGguc2luKHRoZXRhICsgZFRoZXRhKSAqIHJ5ICsgY3k7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgQ01ELlI6XG4gICAgICAgICAgICAgICAgICAgIHgwID0geGkgPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgIHkwID0geWkgPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgIHZhciB3aWR0aCA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGhlaWdodCA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHgxID0geDAgKyB3aWR0aDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHkxID0geTAgKyBoZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1N0cm9rZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRhaW5TdHJva2UoeDAsIHkwLCB4MSwgeTAsIGxpbmVXaWR0aCwgeCwgeSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfHwgY29udGFpblN0cm9rZSh4MSwgeTAsIHgxLCB5MSwgbGluZVdpZHRoLCB4LCB5KVxuICAgICAgICAgICAgICAgICAgICAgICAgICB8fCBjb250YWluU3Ryb2tlKHgxLCB5MSwgeDAsIHkxLCBsaW5lV2lkdGgsIHgsIHkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHx8IGNvbnRhaW5TdHJva2UoeDAsIHkxLCB4MCwgeTAsIGxpbmVXaWR0aCwgeCwgeSlcbiAgICAgICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRklYTUUgQ2xvY2t3aXNlID9cbiAgICAgICAgICAgICAgICAgICAgICAgIHcgKz0gd2luZGluZ0xpbmUoeDEsIHkwLCB4MSwgeTEsIHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdyArPSB3aW5kaW5nTGluZSh4MCwgeTEsIHgwLCB5MCwgeCwgeSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBDTUQuWjpcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzU3Ryb2tlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29udGFpblN0cm9rZShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4aSwgeWksIHgwLCB5MCwgbGluZVdpZHRoLCB4LCB5XG4gICAgICAgICAgICAgICAgICAgICAgICApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDbG9zZSBhIHN1YnBhdGhcbiAgICAgICAgICAgICAgICAgICAgICAgIHcgKz0gd2luZGluZ0xpbmUoeGksIHlpLCB4MCwgeTAsIHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8g5aaC5p6c6KKr5Lu75L2V5LiA5LiqIHN1YnBhdGgg5YyF5ZCrXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGSVhNRSBzdWJwYXRocyBtYXkgb3ZlcmxhcFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgKHcgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB4aSA9IHgwO1xuICAgICAgICAgICAgICAgICAgICB5aSA9IHkwO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzU3Ryb2tlICYmICFpc0Fyb3VuZEVxdWFsKHlpLCB5MCkpIHtcbiAgICAgICAgICAgIHcgKz0gd2luZGluZ0xpbmUoeGksIHlpLCB4MCwgeTAsIHgsIHkpIHx8IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHcgIT09IDA7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgICAgIGNvbnRhaW46IGZ1bmN0aW9uIChwYXRoRGF0YSwgeCwgeSkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRhaW5QYXRoKHBhdGhEYXRhLCAwLCBmYWxzZSwgeCwgeSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY29udGFpblN0cm9rZTogZnVuY3Rpb24gKHBhdGhEYXRhLCBsaW5lV2lkdGgsIHgsIHkpIHtcbiAgICAgICAgICAgIHJldHVybiBjb250YWluUGF0aChwYXRoRGF0YSwgbGluZVdpZHRoLCB0cnVlLCB4LCB5KTtcbiAgICAgICAgfVxuICAgIH07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi96cmVuZGVyL2xpYi9jb250YWluL3BhdGguanNcbiAqKiBtb2R1bGUgaWQgPSAyOFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiDnur/mrrXljIXlkKvliKTmlq1cbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSAgeDBcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSAgeTBcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSAgeDFcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSAgeTFcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSAgbGluZVdpZHRoXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gIHhcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSAgeVxuICAgICAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgY29udGFpblN0cm9rZTogZnVuY3Rpb24gKHgwLCB5MCwgeDEsIHkxLCBsaW5lV2lkdGgsIHgsIHkpIHtcbiAgICAgICAgICAgIGlmIChsaW5lV2lkdGggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgX2wgPSBsaW5lV2lkdGg7XG4gICAgICAgICAgICB2YXIgX2EgPSAwO1xuICAgICAgICAgICAgdmFyIF9iID0geDA7XG4gICAgICAgICAgICAvLyBRdWljayByZWplY3RcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAoeSA+IHkwICsgX2wgJiYgeSA+IHkxICsgX2wpXG4gICAgICAgICAgICAgICAgfHwgKHkgPCB5MCAtIF9sICYmIHkgPCB5MSAtIF9sKVxuICAgICAgICAgICAgICAgIHx8ICh4ID4geDAgKyBfbCAmJiB4ID4geDEgKyBfbClcbiAgICAgICAgICAgICAgICB8fCAoeCA8IHgwIC0gX2wgJiYgeCA8IHgxIC0gX2wpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh4MCAhPT0geDEpIHtcbiAgICAgICAgICAgICAgICBfYSA9ICh5MCAtIHkxKSAvICh4MCAtIHgxKTtcbiAgICAgICAgICAgICAgICBfYiA9ICh4MCAqIHkxIC0geDEgKiB5MCkgLyAoeDAgLSB4MSkgO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE1hdGguYWJzKHggLSB4MCkgPD0gX2wgLyAyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHRtcCA9IF9hICogeCAtIHkgKyBfYjtcbiAgICAgICAgICAgIHZhciBfcyA9IHRtcCAqIHRtcCAvIChfYSAqIF9hICsgMSk7XG4gICAgICAgICAgICByZXR1cm4gX3MgPD0gX2wgLyAyICogX2wgLyAyO1xuICAgICAgICB9XG4gICAgfTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3pyZW5kZXIvbGliL2NvbnRhaW4vbGluZS5qc1xuICoqIG1vZHVsZSBpZCA9IDI5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcblxuICAgIHZhciBjdXJ2ZSA9IHJlcXVpcmUoJy4uL2NvcmUvY3VydmUnKTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICog5LiJ5qyh6LSd5aGe5bCU5puy57q/5o+P6L655YyF5ZCr5Yik5patXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gIHgwXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gIHkwXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gIHgxXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gIHkxXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gIHgyXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gIHkyXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gIHgzXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gIHkzXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gIGxpbmVXaWR0aFxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9ICB4XG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gIHlcbiAgICAgICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIGNvbnRhaW5TdHJva2U6IGZ1bmN0aW9uKHgwLCB5MCwgeDEsIHkxLCB4MiwgeTIsIHgzLCB5MywgbGluZVdpZHRoLCB4LCB5KSB7XG4gICAgICAgICAgICBpZiAobGluZVdpZHRoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIF9sID0gbGluZVdpZHRoO1xuICAgICAgICAgICAgLy8gUXVpY2sgcmVqZWN0XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgKHkgPiB5MCArIF9sICYmIHkgPiB5MSArIF9sICYmIHkgPiB5MiArIF9sICYmIHkgPiB5MyArIF9sKVxuICAgICAgICAgICAgICAgIHx8ICh5IDwgeTAgLSBfbCAmJiB5IDwgeTEgLSBfbCAmJiB5IDwgeTIgLSBfbCAmJiB5IDwgeTMgLSBfbClcbiAgICAgICAgICAgICAgICB8fCAoeCA+IHgwICsgX2wgJiYgeCA+IHgxICsgX2wgJiYgeCA+IHgyICsgX2wgJiYgeCA+IHgzICsgX2wpXG4gICAgICAgICAgICAgICAgfHwgKHggPCB4MCAtIF9sICYmIHggPCB4MSAtIF9sICYmIHggPCB4MiAtIF9sICYmIHggPCB4MyAtIF9sKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGQgPSBjdXJ2ZS5jdWJpY1Byb2plY3RQb2ludChcbiAgICAgICAgICAgICAgICB4MCwgeTAsIHgxLCB5MSwgeDIsIHkyLCB4MywgeTMsXG4gICAgICAgICAgICAgICAgeCwgeSwgbnVsbFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJldHVybiBkIDw9IF9sIC8gMjtcbiAgICAgICAgfVxuICAgIH07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi96cmVuZGVyL2xpYi9jb250YWluL2N1YmljLmpzXG4gKiogbW9kdWxlIGlkID0gMzBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlxuXG4gICAgdmFyIGN1cnZlID0gcmVxdWlyZSgnLi4vY29yZS9jdXJ2ZScpO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiDkuozmrKHotJ3loZ7lsJTmm7Lnur/mj4/ovrnljIXlkKvliKTmlq1cbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSAgeDBcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSAgeTBcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSAgeDFcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSAgeTFcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSAgeDJcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSAgeTJcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSAgbGluZVdpZHRoXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gIHhcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSAgeVxuICAgICAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgY29udGFpblN0cm9rZTogZnVuY3Rpb24gKHgwLCB5MCwgeDEsIHkxLCB4MiwgeTIsIGxpbmVXaWR0aCwgeCwgeSkge1xuICAgICAgICAgICAgaWYgKGxpbmVXaWR0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBfbCA9IGxpbmVXaWR0aDtcbiAgICAgICAgICAgIC8vIFF1aWNrIHJlamVjdFxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICh5ID4geTAgKyBfbCAmJiB5ID4geTEgKyBfbCAmJiB5ID4geTIgKyBfbClcbiAgICAgICAgICAgICAgICB8fCAoeSA8IHkwIC0gX2wgJiYgeSA8IHkxIC0gX2wgJiYgeSA8IHkyIC0gX2wpXG4gICAgICAgICAgICAgICAgfHwgKHggPiB4MCArIF9sICYmIHggPiB4MSArIF9sICYmIHggPiB4MiArIF9sKVxuICAgICAgICAgICAgICAgIHx8ICh4IDwgeDAgLSBfbCAmJiB4IDwgeDEgLSBfbCAmJiB4IDwgeDIgLSBfbClcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBkID0gY3VydmUucXVhZHJhdGljUHJvamVjdFBvaW50KFxuICAgICAgICAgICAgICAgIHgwLCB5MCwgeDEsIHkxLCB4MiwgeTIsXG4gICAgICAgICAgICAgICAgeCwgeSwgbnVsbFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJldHVybiBkIDw9IF9sIC8gMjtcbiAgICAgICAgfVxuICAgIH07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi96cmVuZGVyL2xpYi9jb250YWluL3F1YWRyYXRpYy5qc1xuICoqIG1vZHVsZSBpZCA9IDMxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcblxuICAgIHZhciBub3JtYWxpemVSYWRpYW4gPSByZXF1aXJlKCcuL3V0aWwnKS5ub3JtYWxpemVSYWRpYW47XG4gICAgdmFyIFBJMiA9IE1hdGguUEkgKiAyO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlnIblvKfmj4/ovrnljIXlkKvliKTmlq1cbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSAgY3hcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSAgY3lcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSAgclxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9ICBzdGFydEFuZ2xlXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gIGVuZEFuZ2xlXG4gICAgICAgICAqIEBwYXJhbSAge2Jvb2xlYW59ICBhbnRpY2xvY2t3aXNlXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gbGluZVdpZHRoXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gIHhcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSAgeVxuICAgICAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgY29udGFpblN0cm9rZTogZnVuY3Rpb24gKFxuICAgICAgICAgICAgY3gsIGN5LCByLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgYW50aWNsb2Nrd2lzZSxcbiAgICAgICAgICAgIGxpbmVXaWR0aCwgeCwgeVxuICAgICAgICApIHtcblxuICAgICAgICAgICAgaWYgKGxpbmVXaWR0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBfbCA9IGxpbmVXaWR0aDtcblxuICAgICAgICAgICAgeCAtPSBjeDtcbiAgICAgICAgICAgIHkgLT0gY3k7XG4gICAgICAgICAgICB2YXIgZCA9IE1hdGguc3FydCh4ICogeCArIHkgKiB5KTtcblxuICAgICAgICAgICAgaWYgKChkIC0gX2wgPiByKSB8fCAoZCArIF9sIDwgcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoTWF0aC5hYnMoc3RhcnRBbmdsZSAtIGVuZEFuZ2xlKSAlIFBJMiA8IDFlLTQpIHtcbiAgICAgICAgICAgICAgICAvLyBJcyBhIGNpcmNsZVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFudGljbG9ja3dpc2UpIHtcbiAgICAgICAgICAgICAgICB2YXIgdG1wID0gc3RhcnRBbmdsZTtcbiAgICAgICAgICAgICAgICBzdGFydEFuZ2xlID0gbm9ybWFsaXplUmFkaWFuKGVuZEFuZ2xlKTtcbiAgICAgICAgICAgICAgICBlbmRBbmdsZSA9IG5vcm1hbGl6ZVJhZGlhbih0bXApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdGFydEFuZ2xlID0gbm9ybWFsaXplUmFkaWFuKHN0YXJ0QW5nbGUpO1xuICAgICAgICAgICAgICAgIGVuZEFuZ2xlID0gbm9ybWFsaXplUmFkaWFuKGVuZEFuZ2xlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdGFydEFuZ2xlID4gZW5kQW5nbGUpIHtcbiAgICAgICAgICAgICAgICBlbmRBbmdsZSArPSBQSTI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBhbmdsZSA9IE1hdGguYXRhbjIoeSwgeCk7XG4gICAgICAgICAgICBpZiAoYW5nbGUgPCAwKSB7XG4gICAgICAgICAgICAgICAgYW5nbGUgKz0gUEkyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIChhbmdsZSA+PSBzdGFydEFuZ2xlICYmIGFuZ2xlIDw9IGVuZEFuZ2xlKVxuICAgICAgICAgICAgICAgIHx8IChhbmdsZSArIFBJMiA+PSBzdGFydEFuZ2xlICYmIGFuZ2xlICsgUEkyIDw9IGVuZEFuZ2xlKTtcbiAgICAgICAgfVxuICAgIH07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi96cmVuZGVyL2xpYi9jb250YWluL2FyYy5qc1xuICoqIG1vZHVsZSBpZCA9IDMyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcblxuICAgIHZhciBQSTIgPSBNYXRoLlBJICogMjtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAgICAgbm9ybWFsaXplUmFkaWFuOiBmdW5jdGlvbihhbmdsZSkge1xuICAgICAgICAgICAgYW5nbGUgJT0gUEkyO1xuICAgICAgICAgICAgaWYgKGFuZ2xlIDwgMCkge1xuICAgICAgICAgICAgICAgIGFuZ2xlICs9IFBJMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhbmdsZTtcbiAgICAgICAgfVxuICAgIH07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi96cmVuZGVyL2xpYi9jb250YWluL3V0aWwuanNcbiAqKiBtb2R1bGUgaWQgPSAzM1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB3aW5kaW5nTGluZSh4MCwgeTAsIHgxLCB5MSwgeCwgeSkge1xuICAgICAgICBpZiAoKHkgPiB5MCAmJiB5ID4geTEpIHx8ICh5IDwgeTAgJiYgeSA8IHkxKSkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWdub3JlIGhvcml6b250YWwgbGluZVxuICAgICAgICBpZiAoeTEgPT09IHkwKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGlyID0geTEgPCB5MCA/IDEgOiAtMTtcbiAgICAgICAgdmFyIHQgPSAoeSAtIHkwKSAvICh5MSAtIHkwKTtcblxuICAgICAgICAvLyBBdm9pZCB3aW5kaW5nIGVycm9yIHdoZW4gaW50ZXJzZWN0aW9uIHBvaW50IGlzIHRoZSBjb25uZWN0IHBvaW50IG9mIHR3byBsaW5lIG9mIHBvbHlnb25cbiAgICAgICAgaWYgKHQgPT09IDEgfHwgdCA9PT0gMCkge1xuICAgICAgICAgICAgZGlyID0geTEgPCB5MCA/IDAuNSA6IC0wLjU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgeF8gPSB0ICogKHgxIC0geDApICsgeDA7XG5cbiAgICAgICAgcmV0dXJuIHhfID4geCA/IGRpciA6IDA7XG4gICAgfTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3pyZW5kZXIvbGliL2NvbnRhaW4vd2luZGluZ0xpbmUuanNcbiAqKiBtb2R1bGUgaWQgPSAzNFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXG5cbiAgICB2YXIgUGF0dGVybiA9IGZ1bmN0aW9uIChpbWFnZSwgcmVwZWF0KSB7XG4gICAgICAgIHRoaXMuaW1hZ2UgPSBpbWFnZTtcbiAgICAgICAgdGhpcy5yZXBlYXQgPSByZXBlYXQ7XG5cbiAgICAgICAgLy8gQ2FuIGJlIGNsb25lZFxuICAgICAgICB0aGlzLnR5cGUgPSAncGF0dGVybic7XG4gICAgfTtcblxuICAgIFBhdHRlcm4ucHJvdG90eXBlLmdldENhbnZhc1BhdHRlcm4gPSBmdW5jdGlvbiAoY3R4KSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2NhbnZhc1BhdHRlcm5cbiAgICAgICAgICAgIHx8ICh0aGlzLl9jYW52YXNQYXR0ZXJuID0gY3R4LmNyZWF0ZVBhdHRlcm4odGhpcy5pbWFnZSwgdGhpcy5yZXBlYXQpKTtcbiAgICB9O1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBQYXR0ZXJuO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34venJlbmRlci9saWIvZ3JhcGhpYy9QYXR0ZXJuLmpzXG4gKiogbW9kdWxlIGlkID0gMzVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlxuXG4gICAgdmFyIENNRCA9IHJlcXVpcmUoJy4uL2NvcmUvUGF0aFByb3h5JykuQ01EO1xuICAgIHZhciB2ZWMyID0gcmVxdWlyZSgnLi4vY29yZS92ZWN0b3InKTtcbiAgICB2YXIgdjJBcHBseVRyYW5zZm9ybSA9IHZlYzIuYXBwbHlUcmFuc2Zvcm07XG5cbiAgICB2YXIgcG9pbnRzID0gW1tdLCBbXSwgW11dO1xuICAgIHZhciBtYXRoU3FydCA9IE1hdGguc3FydDtcbiAgICB2YXIgbWF0aEF0YW4yID0gTWF0aC5hdGFuMjtcbiAgICBmdW5jdGlvbiB0cmFuc2Zvcm1QYXRoKHBhdGgsIG0pIHtcbiAgICAgICAgdmFyIGRhdGEgPSBwYXRoLmRhdGE7XG4gICAgICAgIHZhciBjbWQ7XG4gICAgICAgIHZhciBuUG9pbnQ7XG4gICAgICAgIHZhciBpO1xuICAgICAgICB2YXIgajtcbiAgICAgICAgdmFyIGs7XG4gICAgICAgIHZhciBwO1xuXG4gICAgICAgIHZhciBNID0gQ01ELk07XG4gICAgICAgIHZhciBDID0gQ01ELkM7XG4gICAgICAgIHZhciBMID0gQ01ELkw7XG4gICAgICAgIHZhciBSID0gQ01ELlI7XG4gICAgICAgIHZhciBBID0gQ01ELkE7XG4gICAgICAgIHZhciBRID0gQ01ELlE7XG5cbiAgICAgICAgZm9yIChpID0gMCwgaiA9IDA7IGkgPCBkYXRhLmxlbmd0aDspIHtcbiAgICAgICAgICAgIGNtZCA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgIGogPSBpO1xuICAgICAgICAgICAgblBvaW50ID0gMDtcblxuICAgICAgICAgICAgc3dpdGNoIChjbWQpIHtcbiAgICAgICAgICAgICAgICBjYXNlIE06XG4gICAgICAgICAgICAgICAgICAgIG5Qb2ludCA9IDE7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgTDpcbiAgICAgICAgICAgICAgICAgICAgblBvaW50ID0gMTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBDOlxuICAgICAgICAgICAgICAgICAgICBuUG9pbnQgPSAzO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFE6XG4gICAgICAgICAgICAgICAgICAgIG5Qb2ludCA9IDI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgQTpcbiAgICAgICAgICAgICAgICAgICAgdmFyIHggPSBtWzRdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgeSA9IG1bNV07XG4gICAgICAgICAgICAgICAgICAgIHZhciBzeCA9IG1hdGhTcXJ0KG1bMF0gKiBtWzBdICsgbVsxXSAqIG1bMV0pO1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3kgPSBtYXRoU3FydChtWzJdICogbVsyXSArIG1bM10gKiBtWzNdKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFuZ2xlID0gbWF0aEF0YW4yKC1tWzFdIC8gc3ksIG1bMF0gLyBzeCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIGN4XG4gICAgICAgICAgICAgICAgICAgIGRhdGFbaSsrXSArPSB4O1xuICAgICAgICAgICAgICAgICAgICAvLyBjeVxuICAgICAgICAgICAgICAgICAgICBkYXRhW2krK10gKz0geTtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2NhbGUgcnggYW5kIHJ5XG4gICAgICAgICAgICAgICAgICAgIC8vIEZJWE1FIEFzc3VtZSBwc2kgaXMgMCBoZXJlXG4gICAgICAgICAgICAgICAgICAgIGRhdGFbaSsrXSAqPSBzeDtcbiAgICAgICAgICAgICAgICAgICAgZGF0YVtpKytdICo9IHN5O1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFN0YXJ0IGFuZ2xlXG4gICAgICAgICAgICAgICAgICAgIGRhdGFbaSsrXSArPSBhbmdsZTtcbiAgICAgICAgICAgICAgICAgICAgLy8gZW5kIGFuZ2xlXG4gICAgICAgICAgICAgICAgICAgIGRhdGFbaSsrXSArPSBhbmdsZTtcbiAgICAgICAgICAgICAgICAgICAgLy8gRklYTUUgcHNpXG4gICAgICAgICAgICAgICAgICAgIGkgKz0gMjtcbiAgICAgICAgICAgICAgICAgICAgaiA9IGk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgUjpcbiAgICAgICAgICAgICAgICAgICAgLy8geDAsIHkwXG4gICAgICAgICAgICAgICAgICAgIHBbMF0gPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgIHBbMV0gPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgIHYyQXBwbHlUcmFuc2Zvcm0ocCwgcCwgbSk7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFbaisrXSA9IHBbMF07XG4gICAgICAgICAgICAgICAgICAgIGRhdGFbaisrXSA9IHBbMV07XG4gICAgICAgICAgICAgICAgICAgIC8vIHgxLCB5MVxuICAgICAgICAgICAgICAgICAgICBwWzBdICs9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgcFsxXSArPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgIHYyQXBwbHlUcmFuc2Zvcm0ocCwgcCwgbSk7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFbaisrXSA9IHBbMF07XG4gICAgICAgICAgICAgICAgICAgIGRhdGFbaisrXSA9IHBbMV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAoayA9IDA7IGsgPCBuUG9pbnQ7IGsrKykge1xuICAgICAgICAgICAgICAgIHZhciBwID0gcG9pbnRzW2tdO1xuICAgICAgICAgICAgICAgIHBbMF0gPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgcFsxXSA9IGRhdGFbaSsrXTtcblxuICAgICAgICAgICAgICAgIHYyQXBwbHlUcmFuc2Zvcm0ocCwgcCwgbSk7XG4gICAgICAgICAgICAgICAgLy8gV3JpdGUgYmFja1xuICAgICAgICAgICAgICAgIGRhdGFbaisrXSA9IHBbMF07XG4gICAgICAgICAgICAgICAgZGF0YVtqKytdID0gcFsxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gdHJhbnNmb3JtUGF0aDtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3pyZW5kZXIvbGliL3Rvb2wvdHJhbnNmb3JtUGF0aC5qc1xuICoqIG1vZHVsZSBpZCA9IDM2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPE9iamVjdD59IGNvbG9yU3RvcHNcbiAgICAgKi9cbiAgICB2YXIgR3JhZGllbnQgPSBmdW5jdGlvbiAoY29sb3JTdG9wcykge1xuXG4gICAgICAgIHRoaXMuY29sb3JTdG9wcyA9IGNvbG9yU3RvcHMgfHwgW107XG4gICAgfTtcblxuICAgIEdyYWRpZW50LnByb3RvdHlwZSA9IHtcblxuICAgICAgICBjb25zdHJ1Y3RvcjogR3JhZGllbnQsXG5cbiAgICAgICAgYWRkQ29sb3JTdG9wOiBmdW5jdGlvbiAob2Zmc2V0LCBjb2xvcikge1xuICAgICAgICAgICAgdGhpcy5jb2xvclN0b3BzLnB1c2goe1xuXG4gICAgICAgICAgICAgICAgb2Zmc2V0OiBvZmZzZXQsXG5cbiAgICAgICAgICAgICAgICBjb2xvcjogY29sb3JcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gR3JhZGllbnQ7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi96cmVuZGVyL2xpYi9ncmFwaGljL0dyYWRpZW50LmpzXG4gKiogbW9kdWxlIGlkID0gMzdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIFRPRE8gRHJhZ2dhYmxlIGZvciBncm91cFxuLy8gRklYTUUgRHJhZ2dhYmxlIG9uIGVsZW1lbnQgd2hpY2ggaGFzIHBhcmVudCByb3RhdGlvbiBvciBzY2FsZVxuXG4gICAgZnVuY3Rpb24gRHJhZ2dhYmxlKCkge1xuXG4gICAgICAgIHRoaXMub24oJ21vdXNlZG93bicsIHRoaXMuX2RyYWdTdGFydCwgdGhpcyk7XG4gICAgICAgIHRoaXMub24oJ21vdXNlbW92ZScsIHRoaXMuX2RyYWcsIHRoaXMpO1xuICAgICAgICB0aGlzLm9uKCdtb3VzZXVwJywgdGhpcy5fZHJhZ0VuZCwgdGhpcyk7XG4gICAgICAgIHRoaXMub24oJ2dsb2JhbG91dCcsIHRoaXMuX2RyYWdFbmQsIHRoaXMpO1xuICAgICAgICAvLyB0aGlzLl9kcm9wVGFyZ2V0ID0gbnVsbDtcbiAgICAgICAgLy8gdGhpcy5fZHJhZ2dpbmdUYXJnZXQgPSBudWxsO1xuXG4gICAgICAgIC8vIHRoaXMuX3ggPSAwO1xuICAgICAgICAvLyB0aGlzLl95ID0gMDtcbiAgICB9XG5cbiAgICBEcmFnZ2FibGUucHJvdG90eXBlID0ge1xuXG4gICAgICAgIGNvbnN0cnVjdG9yOiBEcmFnZ2FibGUsXG5cbiAgICAgICAgX2RyYWdTdGFydDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHZhciBkcmFnZ2luZ1RhcmdldCA9IGUudGFyZ2V0O1xuICAgICAgICAgICAgaWYgKGRyYWdnaW5nVGFyZ2V0ICYmIGRyYWdnaW5nVGFyZ2V0LmRyYWdnYWJsZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdnaW5nVGFyZ2V0ID0gZHJhZ2dpbmdUYXJnZXQ7XG4gICAgICAgICAgICAgICAgZHJhZ2dpbmdUYXJnZXQuZHJhZ2dpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuX3ggPSBlLm9mZnNldFg7XG4gICAgICAgICAgICAgICAgdGhpcy5feSA9IGUub2Zmc2V0WTtcblxuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hUb0VsZW1lbnQoZHJhZ2dpbmdUYXJnZXQsICdkcmFnc3RhcnQnLCBlLmV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBfZHJhZzogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHZhciBkcmFnZ2luZ1RhcmdldCA9IHRoaXMuX2RyYWdnaW5nVGFyZ2V0O1xuICAgICAgICAgICAgaWYgKGRyYWdnaW5nVGFyZ2V0KSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgeCA9IGUub2Zmc2V0WDtcbiAgICAgICAgICAgICAgICB2YXIgeSA9IGUub2Zmc2V0WTtcblxuICAgICAgICAgICAgICAgIHZhciBkeCA9IHggLSB0aGlzLl94O1xuICAgICAgICAgICAgICAgIHZhciBkeSA9IHkgLSB0aGlzLl95O1xuICAgICAgICAgICAgICAgIHRoaXMuX3ggPSB4O1xuICAgICAgICAgICAgICAgIHRoaXMuX3kgPSB5O1xuXG4gICAgICAgICAgICAgICAgZHJhZ2dpbmdUYXJnZXQuZHJpZnQoZHgsIGR5LCBlKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoVG9FbGVtZW50KGRyYWdnaW5nVGFyZ2V0LCAnZHJhZycsIGUuZXZlbnQpO1xuXG4gICAgICAgICAgICAgICAgdmFyIGRyb3BUYXJnZXQgPSB0aGlzLmZpbmRIb3Zlcih4LCB5LCBkcmFnZ2luZ1RhcmdldCk7XG4gICAgICAgICAgICAgICAgdmFyIGxhc3REcm9wVGFyZ2V0ID0gdGhpcy5fZHJvcFRhcmdldDtcbiAgICAgICAgICAgICAgICB0aGlzLl9kcm9wVGFyZ2V0ID0gZHJvcFRhcmdldDtcblxuICAgICAgICAgICAgICAgIGlmIChkcmFnZ2luZ1RhcmdldCAhPT0gZHJvcFRhcmdldCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobGFzdERyb3BUYXJnZXQgJiYgZHJvcFRhcmdldCAhPT0gbGFzdERyb3BUYXJnZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hUb0VsZW1lbnQobGFzdERyb3BUYXJnZXQsICdkcmFnbGVhdmUnLCBlLmV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZHJvcFRhcmdldCAmJiBkcm9wVGFyZ2V0ICE9PSBsYXN0RHJvcFRhcmdldCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaFRvRWxlbWVudChkcm9wVGFyZ2V0LCAnZHJhZ2VudGVyJywgZS5ldmVudCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2RyYWdFbmQ6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICB2YXIgZHJhZ2dpbmdUYXJnZXQgPSB0aGlzLl9kcmFnZ2luZ1RhcmdldDtcblxuICAgICAgICAgICAgaWYgKGRyYWdnaW5nVGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgZHJhZ2dpbmdUYXJnZXQuZHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaFRvRWxlbWVudChkcmFnZ2luZ1RhcmdldCwgJ2RyYWdlbmQnLCBlLmV2ZW50KTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuX2Ryb3BUYXJnZXQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoVG9FbGVtZW50KHRoaXMuX2Ryb3BUYXJnZXQsICdkcm9wJywgZS5ldmVudCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX2RyYWdnaW5nVGFyZ2V0ID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX2Ryb3BUYXJnZXQgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICB9O1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBEcmFnZ2FibGU7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi96cmVuZGVyL2xpYi9taXhpbi9EcmFnZ2FibGUuanNcbiAqKiBtb2R1bGUgaWQgPSAzOFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBHcm91cOaYr+S4gOS4quWuueWZqO+8jOWPr+S7peaPkuWFpeWtkOiKgueCue+8jEdyb3Vw55qE5Y+Y5o2i5Lmf5Lya6KKr5bqU55So5Yiw5a2Q6IqC54K55LiKXG4gKiBAbW9kdWxlIHpyZW5kZXIvZ3JhcGhpYy9Hcm91cFxuICogQGV4YW1wbGVcbiAqICAgICB2YXIgR3JvdXAgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb250YWluZXIvR3JvdXAnKTtcbiAqICAgICB2YXIgQ2lyY2xlID0gcmVxdWlyZSgnenJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9DaXJjbGUnKTtcbiAqICAgICB2YXIgZyA9IG5ldyBHcm91cCgpO1xuICogICAgIGcucG9zaXRpb25bMF0gPSAxMDA7XG4gKiAgICAgZy5wb3NpdGlvblsxXSA9IDEwMDtcbiAqICAgICBnLmFkZChuZXcgQ2lyY2xlKHtcbiAqICAgICAgICAgc3R5bGU6IHtcbiAqICAgICAgICAgICAgIHg6IDEwMCxcbiAqICAgICAgICAgICAgIHk6IDEwMCxcbiAqICAgICAgICAgICAgIHI6IDIwLFxuICogICAgICAgICB9XG4gKiAgICAgfSkpO1xuICogICAgIHpyLmFkZChnKTtcbiAqL1xuXG5cbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnLi4vY29yZS91dGlsJyk7XG4gICAgdmFyIEVsZW1lbnQgPSByZXF1aXJlKCcuLi9FbGVtZW50Jyk7XG4gICAgdmFyIEJvdW5kaW5nUmVjdCA9IHJlcXVpcmUoJy4uL2NvcmUvQm91bmRpbmdSZWN0Jyk7XG5cbiAgICAvKipcbiAgICAgKiBAYWxpYXMgbW9kdWxlOnpyZW5kZXIvZ3JhcGhpYy9Hcm91cFxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBleHRlbmRzIG1vZHVsZTp6cmVuZGVyL21peGluL1RyYW5zZm9ybWFibGVcbiAgICAgKiBAZXh0ZW5kcyBtb2R1bGU6enJlbmRlci9taXhpbi9FdmVudGZ1bFxuICAgICAqL1xuICAgIHZhciBHcm91cCA9IGZ1bmN0aW9uIChvcHRzKSB7XG5cbiAgICAgICAgb3B0cyA9IG9wdHMgfHwge307XG5cbiAgICAgICAgRWxlbWVudC5jYWxsKHRoaXMsIG9wdHMpO1xuXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBvcHRzKSB7XG4gICAgICAgICAgICB0aGlzW2tleV0gPSBvcHRzW2tleV07XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9jaGlsZHJlbiA9IFtdO1xuXG4gICAgICAgIHRoaXMuX19zdG9yYWdlID0gbnVsbDtcblxuICAgICAgICB0aGlzLl9fZGlydHkgPSB0cnVlO1xuICAgIH07XG5cbiAgICBHcm91cC5wcm90b3R5cGUgPSB7XG5cbiAgICAgICAgY29uc3RydWN0b3I6IEdyb3VwLFxuXG4gICAgICAgIGlzR3JvdXA6IHRydWUsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICB0eXBlOiAnZ3JvdXAnLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmiYDmnInlrZDlrZnlhYPntKDmmK/lkKblk43lupTpvKDmoIfkuovku7ZcbiAgICAgICAgICogQG5hbWUgbW9kdWxlOi96cmVuZGVyL2NvbnRhaW5lci9Hcm91cCNzaWxlbnRcbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICBzaWxlbnQ6IGZhbHNlLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHtBcnJheS48bW9kdWxlOnpyZW5kZXIvRWxlbWVudD59XG4gICAgICAgICAqL1xuICAgICAgICBjaGlsZHJlbjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NoaWxkcmVuLnNsaWNlKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOiOt+WPluaMh+WumiBpbmRleCDnmoTlhL/lrZDoioLngrlcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSBpZHhcbiAgICAgICAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvRWxlbWVudH1cbiAgICAgICAgICovXG4gICAgICAgIGNoaWxkQXQ6IGZ1bmN0aW9uIChpZHgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jaGlsZHJlbltpZHhdO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDojrflj5bmjIflrprlkI3lrZfnmoTlhL/lrZDoioLngrlcbiAgICAgICAgICogQHBhcmFtICB7c3RyaW5nfSBuYW1lXG4gICAgICAgICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL0VsZW1lbnR9XG4gICAgICAgICAqL1xuICAgICAgICBjaGlsZE9mTmFtZTogZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChjaGlsZHJlbltpXS5uYW1lID09PSBuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBjaGlsZENvdW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmt7vliqDlrZDoioLngrnliLDmnIDlkI5cbiAgICAgICAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9FbGVtZW50fSBjaGlsZFxuICAgICAgICAgKi9cbiAgICAgICAgYWRkOiBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICAgIGlmIChjaGlsZCAmJiBjaGlsZCAhPT0gdGhpcyAmJiBjaGlsZC5wYXJlbnQgIT09IHRoaXMpIHtcblxuICAgICAgICAgICAgICAgIHRoaXMuX2NoaWxkcmVuLnB1c2goY2hpbGQpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5fZG9BZGQoY2hpbGQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5re75Yqg5a2Q6IqC54K55ZyoIG5leHRTaWJsaW5nIOS5i+WJjVxuICAgICAgICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL0VsZW1lbnR9IGNoaWxkXG4gICAgICAgICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvRWxlbWVudH0gbmV4dFNpYmxpbmdcbiAgICAgICAgICovXG4gICAgICAgIGFkZEJlZm9yZTogZnVuY3Rpb24gKGNoaWxkLCBuZXh0U2libGluZykge1xuICAgICAgICAgICAgaWYgKGNoaWxkICYmIGNoaWxkICE9PSB0aGlzICYmIGNoaWxkLnBhcmVudCAhPT0gdGhpc1xuICAgICAgICAgICAgICAgICYmIG5leHRTaWJsaW5nICYmIG5leHRTaWJsaW5nLnBhcmVudCA9PT0gdGhpcykge1xuXG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW47XG4gICAgICAgICAgICAgICAgdmFyIGlkeCA9IGNoaWxkcmVuLmluZGV4T2YobmV4dFNpYmxpbmcpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuLnNwbGljZShpZHgsIDAsIGNoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZG9BZGQoY2hpbGQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2RvQWRkOiBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICAgIGlmIChjaGlsZC5wYXJlbnQpIHtcbiAgICAgICAgICAgICAgICBjaGlsZC5wYXJlbnQucmVtb3ZlKGNoaWxkKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2hpbGQucGFyZW50ID0gdGhpcztcblxuICAgICAgICAgICAgdmFyIHN0b3JhZ2UgPSB0aGlzLl9fc3RvcmFnZTtcbiAgICAgICAgICAgIHZhciB6ciA9IHRoaXMuX196cjtcbiAgICAgICAgICAgIGlmIChzdG9yYWdlICYmIHN0b3JhZ2UgIT09IGNoaWxkLl9fc3RvcmFnZSkge1xuXG4gICAgICAgICAgICAgICAgc3RvcmFnZS5hZGRUb01hcChjaGlsZCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBHcm91cCkge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZC5hZGRDaGlsZHJlblRvU3RvcmFnZShzdG9yYWdlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHpyICYmIHpyLnJlZnJlc2goKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog56e76Zmk5a2Q6IqC54K5XG4gICAgICAgICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvRWxlbWVudH0gY2hpbGRcbiAgICAgICAgICovXG4gICAgICAgIHJlbW92ZTogZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgICAgICB2YXIgenIgPSB0aGlzLl9fenI7XG4gICAgICAgICAgICB2YXIgc3RvcmFnZSA9IHRoaXMuX19zdG9yYWdlO1xuICAgICAgICAgICAgdmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW47XG5cbiAgICAgICAgICAgIHZhciBpZHggPSB6clV0aWwuaW5kZXhPZihjaGlsZHJlbiwgY2hpbGQpO1xuICAgICAgICAgICAgaWYgKGlkeCA8IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNoaWxkcmVuLnNwbGljZShpZHgsIDEpO1xuXG4gICAgICAgICAgICBjaGlsZC5wYXJlbnQgPSBudWxsO1xuXG4gICAgICAgICAgICBpZiAoc3RvcmFnZSkge1xuXG4gICAgICAgICAgICAgICAgc3RvcmFnZS5kZWxGcm9tTWFwKGNoaWxkLmlkKTtcblxuICAgICAgICAgICAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIEdyb3VwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkLmRlbENoaWxkcmVuRnJvbVN0b3JhZ2Uoc3RvcmFnZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB6ciAmJiB6ci5yZWZyZXNoKCk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDnp7vpmaTmiYDmnInlrZDoioLngrlcbiAgICAgICAgICovXG4gICAgICAgIHJlbW92ZUFsbDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW47XG4gICAgICAgICAgICB2YXIgc3RvcmFnZSA9IHRoaXMuX19zdG9yYWdlO1xuICAgICAgICAgICAgdmFyIGNoaWxkO1xuICAgICAgICAgICAgdmFyIGk7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgIGlmIChzdG9yYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0b3JhZ2UuZGVsRnJvbU1hcChjaGlsZC5pZCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIEdyb3VwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZC5kZWxDaGlsZHJlbkZyb21TdG9yYWdlKHN0b3JhZ2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNoaWxkLnBhcmVudCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjaGlsZHJlbi5sZW5ndGggPSAwO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog6YGN5Y6G5omA5pyJ5a2Q6IqC54K5XG4gICAgICAgICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBjYlxuICAgICAgICAgKiBAcGFyYW0gIHt9ICAgY29udGV4dFxuICAgICAgICAgKi9cbiAgICAgICAgZWFjaENoaWxkOiBmdW5jdGlvbiAoY2IsIGNvbnRleHQpIHtcbiAgICAgICAgICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgIGNiLmNhbGwoY29udGV4dCwgY2hpbGQsIGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOa3seW6puS8mOWFiOmBjeWOhuaJgOacieWtkOWtmeiKgueCuVxuICAgICAgICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gY2JcbiAgICAgICAgICogQHBhcmFtICB7fSAgIGNvbnRleHRcbiAgICAgICAgICovXG4gICAgICAgIHRyYXZlcnNlOiBmdW5jdGlvbiAoY2IsIGNvbnRleHQpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGQgPSB0aGlzLl9jaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgICBjYi5jYWxsKGNvbnRleHQsIGNoaWxkKTtcblxuICAgICAgICAgICAgICAgIGlmIChjaGlsZC50eXBlID09PSAnZ3JvdXAnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkLnRyYXZlcnNlKGNiLCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBhZGRDaGlsZHJlblRvU3RvcmFnZTogZnVuY3Rpb24gKHN0b3JhZ2UpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGQgPSB0aGlzLl9jaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgICBzdG9yYWdlLmFkZFRvTWFwKGNoaWxkKTtcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBHcm91cCkge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZC5hZGRDaGlsZHJlblRvU3RvcmFnZShzdG9yYWdlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgZGVsQ2hpbGRyZW5Gcm9tU3RvcmFnZTogZnVuY3Rpb24gKHN0b3JhZ2UpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGQgPSB0aGlzLl9jaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgICBzdG9yYWdlLmRlbEZyb21NYXAoY2hpbGQuaWQpO1xuICAgICAgICAgICAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIEdyb3VwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkLmRlbENoaWxkcmVuRnJvbVN0b3JhZ2Uoc3RvcmFnZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGRpcnR5OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl9fZGlydHkgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fX3pyICYmIHRoaXMuX196ci5yZWZyZXNoKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvY29yZS9Cb3VuZGluZ1JlY3R9XG4gICAgICAgICAqL1xuICAgICAgICBnZXRCb3VuZGluZ1JlY3Q6IGZ1bmN0aW9uIChpbmNsdWRlQ2hpbGRyZW4pIHtcbiAgICAgICAgICAgIC8vIFRPRE8gQ2FjaGluZ1xuICAgICAgICAgICAgLy8gVE9ETyBUcmFuc2Zvcm1cbiAgICAgICAgICAgIHZhciByZWN0ID0gbnVsbDtcbiAgICAgICAgICAgIHZhciB0bXBSZWN0ID0gbmV3IEJvdW5kaW5nUmVjdCgwLCAwLCAwLCAwKTtcbiAgICAgICAgICAgIHZhciBjaGlsZHJlbiA9IGluY2x1ZGVDaGlsZHJlbiB8fCB0aGlzLl9jaGlsZHJlbjtcbiAgICAgICAgICAgIHZhciB0bXBNYXQgPSBbXTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgIGlmIChjaGlsZC5pZ25vcmUgfHwgY2hpbGQuaW52aXNpYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBjaGlsZFJlY3QgPSBjaGlsZC5nZXRCb3VuZGluZ1JlY3QoKTtcbiAgICAgICAgICAgICAgICB2YXIgdHJhbnNmb3JtID0gY2hpbGQuZ2V0TG9jYWxUcmFuc2Zvcm0odG1wTWF0KTtcbiAgICAgICAgICAgICAgICBpZiAodHJhbnNmb3JtKSB7XG4gICAgICAgICAgICAgICAgICAgIHRtcFJlY3QuY29weShjaGlsZFJlY3QpO1xuICAgICAgICAgICAgICAgICAgICB0bXBSZWN0LmFwcGx5VHJhbnNmb3JtKHRyYW5zZm9ybSk7XG4gICAgICAgICAgICAgICAgICAgIHJlY3QgPSByZWN0IHx8IHRtcFJlY3QuY2xvbmUoKTtcbiAgICAgICAgICAgICAgICAgICAgcmVjdC51bmlvbih0bXBSZWN0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlY3QgPSByZWN0IHx8IGNoaWxkUmVjdC5jbG9uZSgpO1xuICAgICAgICAgICAgICAgICAgICByZWN0LnVuaW9uKGNoaWxkUmVjdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlY3QgfHwgdG1wUmVjdDtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB6clV0aWwuaW5oZXJpdHMoR3JvdXAsIEVsZW1lbnQpO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBHcm91cDtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3pyZW5kZXIvbGliL2NvbnRhaW5lci9Hcm91cC5qc1xuICoqIG1vZHVsZSBpZCA9IDM5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIEltYWdlIGVsZW1lbnRcbiAqIEBtb2R1bGUgenJlbmRlci9ncmFwaGljL0ltYWdlXG4gKi9cblxuXG5cbiAgICB2YXIgRGlzcGxheWFibGUgPSByZXF1aXJlKCcuL0Rpc3BsYXlhYmxlJyk7XG4gICAgdmFyIEJvdW5kaW5nUmVjdCA9IHJlcXVpcmUoJy4uL2NvcmUvQm91bmRpbmdSZWN0Jyk7XG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJy4uL2NvcmUvdXRpbCcpO1xuXG4gICAgdmFyIExSVSA9IHJlcXVpcmUoJy4uL2NvcmUvTFJVJyk7XG4gICAgdmFyIGdsb2JhbEltYWdlQ2FjaGUgPSBuZXcgTFJVKDUwKTtcbiAgICAvKipcbiAgICAgKiBAYWxpYXMgenJlbmRlci9ncmFwaGljL0ltYWdlXG4gICAgICogQGV4dGVuZHMgbW9kdWxlOnpyZW5kZXIvZ3JhcGhpYy9EaXNwbGF5YWJsZVxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gICAgICovXG4gICAgZnVuY3Rpb24gWkltYWdlKG9wdHMpIHtcbiAgICAgICAgRGlzcGxheWFibGUuY2FsbCh0aGlzLCBvcHRzKTtcbiAgICB9XG5cbiAgICBaSW1hZ2UucHJvdG90eXBlID0ge1xuXG4gICAgICAgIGNvbnN0cnVjdG9yOiBaSW1hZ2UsXG5cbiAgICAgICAgdHlwZTogJ2ltYWdlJyxcblxuICAgICAgICBicnVzaDogZnVuY3Rpb24gKGN0eCwgcHJldkVsKSB7XG4gICAgICAgICAgICB2YXIgc3R5bGUgPSB0aGlzLnN0eWxlO1xuICAgICAgICAgICAgdmFyIHNyYyA9IHN0eWxlLmltYWdlO1xuICAgICAgICAgICAgdmFyIGltYWdlO1xuXG4gICAgICAgICAgICAvLyBNdXN0IGJpbmQgZWFjaCB0aW1lXG4gICAgICAgICAgICBzdHlsZS5iaW5kKGN0eCwgdGhpcywgcHJldkVsKTtcbiAgICAgICAgICAgIC8vIHN0eWxlLmltYWdlIGlzIGEgdXJsIHN0cmluZ1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBzcmMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgaW1hZ2UgPSB0aGlzLl9pbWFnZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHN0eWxlLmltYWdlIGlzIGFuIEhUTUxJbWFnZUVsZW1lbnQgb3IgSFRNTENhbnZhc0VsZW1lbnQgb3IgQ2FudmFzXG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbWFnZSA9IHNyYztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEZJWE1FIENhc2UgY3JlYXRlIG1hbnkgaW1hZ2VzIHdpdGggc3JjXG4gICAgICAgICAgICBpZiAoIWltYWdlICYmIHNyYykge1xuICAgICAgICAgICAgICAgIC8vIFRyeSBnZXQgZnJvbSBnbG9iYWwgaW1hZ2UgY2FjaGVcbiAgICAgICAgICAgICAgICB2YXIgY2FjaGVkSW1nT2JqID0gZ2xvYmFsSW1hZ2VDYWNoZS5nZXQoc3JjKTtcbiAgICAgICAgICAgICAgICBpZiAoIWNhY2hlZEltZ09iaikge1xuICAgICAgICAgICAgICAgICAgICAvLyBDcmVhdGUgYSBuZXcgaW1hZ2VcbiAgICAgICAgICAgICAgICAgICAgaW1hZ2UgPSBuZXcgSW1hZ2UoKTtcbiAgICAgICAgICAgICAgICAgICAgaW1hZ2Uub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2Uub25sb2FkID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2FjaGVkSW1nT2JqLnBlbmRpbmcubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWNoZWRJbWdPYmoucGVuZGluZ1tpXS5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBjYWNoZWRJbWdPYmogPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbWFnZTogaW1hZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBwZW5kaW5nOiBbdGhpc11cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgaW1hZ2Uuc3JjID0gc3JjO1xuICAgICAgICAgICAgICAgICAgICBnbG9iYWxJbWFnZUNhY2hlLnB1dChzcmMsIGNhY2hlZEltZ09iaik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2ltYWdlID0gaW1hZ2U7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGltYWdlID0gY2FjaGVkSW1nT2JqLmltYWdlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbWFnZSA9IGltYWdlO1xuICAgICAgICAgICAgICAgICAgICAvLyBJbWFnZSBpcyBub3QgY29tcGxldGUgZmluaXNoLCBhZGQgdG8gcGVuZGluZyBsaXN0XG4gICAgICAgICAgICAgICAgICAgIGlmICghaW1hZ2Uud2lkdGggfHwgIWltYWdlLmhlaWdodCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGVkSW1nT2JqLnBlbmRpbmcucHVzaCh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGltYWdlKSB7XG4gICAgICAgICAgICAgICAgLy8g5Zu+54mH5bey57uP5Yqg6L295a6M5oiQXG4gICAgICAgICAgICAgICAgLy8gaWYgKGltYWdlLm5vZGVOYW1lLnRvVXBwZXJDYXNlKCkgPT0gJ0lNRycpIHtcbiAgICAgICAgICAgICAgICAvLyAgICAgaWYgKCFpbWFnZS5jb21wbGV0ZSkge1xuICAgICAgICAgICAgICAgIC8vICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIC8vICAgICB9XG4gICAgICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgICAgIC8vIEVsc2UgaXMgY2FudmFzXG5cbiAgICAgICAgICAgICAgICB2YXIgd2lkdGggPSBzdHlsZS53aWR0aCB8fCBpbWFnZS53aWR0aDtcbiAgICAgICAgICAgICAgICB2YXIgaGVpZ2h0ID0gc3R5bGUuaGVpZ2h0IHx8IGltYWdlLmhlaWdodDtcbiAgICAgICAgICAgICAgICB2YXIgeCA9IHN0eWxlLnggfHwgMDtcbiAgICAgICAgICAgICAgICB2YXIgeSA9IHN0eWxlLnkgfHwgMDtcbiAgICAgICAgICAgICAgICAvLyDlm77niYfliqDovb3lpLHotKVcbiAgICAgICAgICAgICAgICBpZiAoIWltYWdlLndpZHRoIHx8ICFpbWFnZS5oZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIOiuvue9rnRyYW5zZm9ybVxuICAgICAgICAgICAgICAgIHRoaXMuc2V0VHJhbnNmb3JtKGN0eCk7XG5cblxuICAgICAgICAgICAgICAgIGlmIChzdHlsZS5zV2lkdGggJiYgc3R5bGUuc0hlaWdodCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3ggPSBzdHlsZS5zeCB8fCAwO1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3kgPSBzdHlsZS5zeSB8fCAwO1xuICAgICAgICAgICAgICAgICAgICBjdHguZHJhd0ltYWdlKFxuICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBzeCwgc3ksIHN0eWxlLnNXaWR0aCwgc3R5bGUuc0hlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHgsIHksIHdpZHRoLCBoZWlnaHRcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc3R5bGUuc3ggJiYgc3R5bGUuc3kpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN4ID0gc3R5bGUuc3g7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzeSA9IHN0eWxlLnN5O1xuICAgICAgICAgICAgICAgICAgICB2YXIgc1dpZHRoID0gd2lkdGggLSBzeDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNIZWlnaHQgPSBoZWlnaHQgLSBzeTtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmRyYXdJbWFnZShcbiAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3gsIHN5LCBzV2lkdGgsIHNIZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgICAgICB4LCB5LCB3aWR0aCwgaGVpZ2h0XG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjdHguZHJhd0ltYWdlKGltYWdlLCB4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyDlpoLmnpzmsqHorr7nva7lrr3lkozpq5jnmoTor53oh6rliqjmoLnmja7lm77niYflrr3pq5jorr7nva5cbiAgICAgICAgICAgICAgICBpZiAoc3R5bGUud2lkdGggPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBzdHlsZS53aWR0aCA9IHdpZHRoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc3R5bGUuaGVpZ2h0ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMucmVzdG9yZVRyYW5zZm9ybShjdHgpO1xuXG4gICAgICAgICAgICAgICAgLy8gRHJhdyByZWN0IHRleHRcbiAgICAgICAgICAgICAgICBpZiAoc3R5bGUudGV4dCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1JlY3RUZXh0KGN0eCwgdGhpcy5nZXRCb3VuZGluZ1JlY3QoKSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0Qm91bmRpbmdSZWN0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgc3R5bGUgPSB0aGlzLnN0eWxlO1xuICAgICAgICAgICAgaWYgKCEgdGhpcy5fcmVjdCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlY3QgPSBuZXcgQm91bmRpbmdSZWN0KFxuICAgICAgICAgICAgICAgICAgICBzdHlsZS54IHx8IDAsIHN0eWxlLnkgfHwgMCwgc3R5bGUud2lkdGggfHwgMCwgc3R5bGUuaGVpZ2h0IHx8IDBcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JlY3Q7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgenJVdGlsLmluaGVyaXRzKFpJbWFnZSwgRGlzcGxheWFibGUpO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBaSW1hZ2U7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi96cmVuZGVyL2xpYi9ncmFwaGljL0ltYWdlLmpzXG4gKiogbW9kdWxlIGlkID0gNDBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIFNpbXBsZSBMUlUgY2FjaGUgdXNlIGRvdWJseSBsaW5rZWQgbGlzdFxuLy8gQG1vZHVsZSB6cmVuZGVyL2NvcmUvTFJVXG5cblxuICAgIC8qKlxuICAgICAqIFNpbXBsZSBkb3VibGUgbGlua2VkIGxpc3QuIENvbXBhcmVkIHdpdGggYXJyYXksIGl0IGhhcyBPKDEpIHJlbW92ZSBvcGVyYXRpb24uXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICovXG4gICAgdmFyIExpbmtlZExpc3QgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge21vZHVsZTp6cmVuZGVyL2NvcmUvTFJVfkVudHJ5fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5oZWFkID0gbnVsbDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge21vZHVsZTp6cmVuZGVyL2NvcmUvTFJVfkVudHJ5fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50YWlsID0gbnVsbDtcblxuICAgICAgICB0aGlzLl9sZW4gPSAwO1xuICAgIH07XG5cbiAgICB2YXIgbGlua2VkTGlzdFByb3RvID0gTGlua2VkTGlzdC5wcm90b3R5cGU7XG4gICAgLyoqXG4gICAgICogSW5zZXJ0IGEgbmV3IHZhbHVlIGF0IHRoZSB0YWlsXG4gICAgICogQHBhcmFtICB7fSB2YWxcbiAgICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9jb3JlL0xSVX5FbnRyeX1cbiAgICAgKi9cbiAgICBsaW5rZWRMaXN0UHJvdG8uaW5zZXJ0ID0gZnVuY3Rpb24odmFsKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IG5ldyBFbnRyeSh2YWwpO1xuICAgICAgICB0aGlzLmluc2VydEVudHJ5KGVudHJ5KTtcbiAgICAgICAgcmV0dXJuIGVudHJ5O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBJbnNlcnQgYW4gZW50cnkgYXQgdGhlIHRhaWxcbiAgICAgKiBAcGFyYW0gIHttb2R1bGU6enJlbmRlci9jb3JlL0xSVX5FbnRyeX0gZW50cnlcbiAgICAgKi9cbiAgICBsaW5rZWRMaXN0UHJvdG8uaW5zZXJ0RW50cnkgPSBmdW5jdGlvbihlbnRyeSkge1xuICAgICAgICBpZiAoIXRoaXMuaGVhZCkge1xuICAgICAgICAgICAgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gZW50cnk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnRhaWwubmV4dCA9IGVudHJ5O1xuICAgICAgICAgICAgZW50cnkucHJldiA9IHRoaXMudGFpbDtcbiAgICAgICAgICAgIHRoaXMudGFpbCA9IGVudHJ5O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2xlbisrO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgZW50cnkuXG4gICAgICogQHBhcmFtICB7bW9kdWxlOnpyZW5kZXIvY29yZS9MUlV+RW50cnl9IGVudHJ5XG4gICAgICovXG4gICAgbGlua2VkTGlzdFByb3RvLnJlbW92ZSA9IGZ1bmN0aW9uKGVudHJ5KSB7XG4gICAgICAgIHZhciBwcmV2ID0gZW50cnkucHJldjtcbiAgICAgICAgdmFyIG5leHQgPSBlbnRyeS5uZXh0O1xuICAgICAgICBpZiAocHJldikge1xuICAgICAgICAgICAgcHJldi5uZXh0ID0gbmV4dDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIElzIGhlYWRcbiAgICAgICAgICAgIHRoaXMuaGVhZCA9IG5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5leHQpIHtcbiAgICAgICAgICAgIG5leHQucHJldiA9IHByZXY7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBJcyB0YWlsXG4gICAgICAgICAgICB0aGlzLnRhaWwgPSBwcmV2O1xuICAgICAgICB9XG4gICAgICAgIGVudHJ5Lm5leHQgPSBlbnRyeS5wcmV2ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fbGVuLS07XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgKi9cbiAgICBsaW5rZWRMaXN0UHJvdG8ubGVuID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sZW47XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7fSB2YWxcbiAgICAgKi9cbiAgICB2YXIgRW50cnkgPSBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHt9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7bW9kdWxlOnpyZW5kZXIvY29yZS9MUlV+RW50cnl9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm5leHQ7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHttb2R1bGU6enJlbmRlci9jb3JlL0xSVX5FbnRyeX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucHJldjtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogTFJVIENhY2hlXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQGFsaWFzIG1vZHVsZTp6cmVuZGVyL2NvcmUvTFJVXG4gICAgICovXG4gICAgdmFyIExSVSA9IGZ1bmN0aW9uKG1heFNpemUpIHtcblxuICAgICAgICB0aGlzLl9saXN0ID0gbmV3IExpbmtlZExpc3QoKTtcblxuICAgICAgICB0aGlzLl9tYXAgPSB7fTtcblxuICAgICAgICB0aGlzLl9tYXhTaXplID0gbWF4U2l6ZSB8fCAxMDtcbiAgICB9O1xuXG4gICAgdmFyIExSVVByb3RvID0gTFJVLnByb3RvdHlwZTtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSAge3N0cmluZ30ga2V5XG4gICAgICogQHBhcmFtICB7fSB2YWx1ZVxuICAgICAqL1xuICAgIExSVVByb3RvLnB1dCA9IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgICAgdmFyIGxpc3QgPSB0aGlzLl9saXN0O1xuICAgICAgICB2YXIgbWFwID0gdGhpcy5fbWFwO1xuICAgICAgICBpZiAobWFwW2tleV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIGxlbiA9IGxpc3QubGVuKCk7XG4gICAgICAgICAgICBpZiAobGVuID49IHRoaXMuX21heFNpemUgJiYgbGVuID4gMCkge1xuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgbGVhc3QgcmVjZW50bHkgdXNlZFxuICAgICAgICAgICAgICAgIHZhciBsZWFzdFVzZWRFbnRyeSA9IGxpc3QuaGVhZDtcbiAgICAgICAgICAgICAgICBsaXN0LnJlbW92ZShsZWFzdFVzZWRFbnRyeSk7XG4gICAgICAgICAgICAgICAgZGVsZXRlIG1hcFtsZWFzdFVzZWRFbnRyeS5rZXldO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgZW50cnkgPSBsaXN0Lmluc2VydCh2YWx1ZSk7XG4gICAgICAgICAgICBlbnRyeS5rZXkgPSBrZXk7XG4gICAgICAgICAgICBtYXBba2V5XSA9IGVudHJ5O1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSAge3N0cmluZ30ga2V5XG4gICAgICogQHJldHVybiB7fVxuICAgICAqL1xuICAgIExSVVByb3RvLmdldCA9IGZ1bmN0aW9uKGtleSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLl9tYXBba2V5XTtcbiAgICAgICAgdmFyIGxpc3QgPSB0aGlzLl9saXN0O1xuICAgICAgICBpZiAoZW50cnkgIT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gUHV0IHRoZSBsYXRlc3QgdXNlZCBlbnRyeSBpbiB0aGUgdGFpbFxuICAgICAgICAgICAgaWYgKGVudHJ5ICE9PSBsaXN0LnRhaWwpIHtcbiAgICAgICAgICAgICAgICBsaXN0LnJlbW92ZShlbnRyeSk7XG4gICAgICAgICAgICAgICAgbGlzdC5pbnNlcnRFbnRyeShlbnRyeSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBlbnRyeS52YWx1ZTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDbGVhciB0aGUgY2FjaGVcbiAgICAgKi9cbiAgICBMUlVQcm90by5jbGVhciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl9saXN0LmNsZWFyKCk7XG4gICAgICAgIHRoaXMuX21hcCA9IHt9O1xuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IExSVTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3pyZW5kZXIvbGliL2NvcmUvTFJVLmpzXG4gKiogbW9kdWxlIGlkID0gNDFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogVGV4dCBlbGVtZW50XG4gKiBAbW9kdWxlIHpyZW5kZXIvZ3JhcGhpYy9UZXh0XG4gKlxuICogVE9ETyBXcmFwcGluZ1xuICpcbiAqIFRleHQgbm90IHN1cHBvcnQgZ3JhZGllbnRcbiAqL1xuXG5cblxuICAgIHZhciBEaXNwbGF5YWJsZSA9IHJlcXVpcmUoJy4vRGlzcGxheWFibGUnKTtcbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnLi4vY29yZS91dGlsJyk7XG4gICAgdmFyIHRleHRDb250YWluID0gcmVxdWlyZSgnLi4vY29udGFpbi90ZXh0Jyk7XG5cbiAgICAvKipcbiAgICAgKiBAYWxpYXMgenJlbmRlci9ncmFwaGljL1RleHRcbiAgICAgKiBAZXh0ZW5kcyBtb2R1bGU6enJlbmRlci9ncmFwaGljL0Rpc3BsYXlhYmxlXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAgICAgKi9cbiAgICB2YXIgVGV4dCA9IGZ1bmN0aW9uIChvcHRzKSB7XG4gICAgICAgIERpc3BsYXlhYmxlLmNhbGwodGhpcywgb3B0cyk7XG4gICAgfTtcblxuICAgIFRleHQucHJvdG90eXBlID0ge1xuXG4gICAgICAgIGNvbnN0cnVjdG9yOiBUZXh0LFxuXG4gICAgICAgIHR5cGU6ICd0ZXh0JyxcblxuICAgICAgICBicnVzaDogZnVuY3Rpb24gKGN0eCwgcHJldkVsKSB7XG4gICAgICAgICAgICB2YXIgc3R5bGUgPSB0aGlzLnN0eWxlO1xuICAgICAgICAgICAgdmFyIHggPSBzdHlsZS54IHx8IDA7XG4gICAgICAgICAgICB2YXIgeSA9IHN0eWxlLnkgfHwgMDtcbiAgICAgICAgICAgIC8vIENvbnZlcnQgdG8gc3RyaW5nXG4gICAgICAgICAgICB2YXIgdGV4dCA9IHN0eWxlLnRleHQ7XG5cbiAgICAgICAgICAgIC8vIENvbnZlcnQgdG8gc3RyaW5nXG4gICAgICAgICAgICB0ZXh0ICE9IG51bGwgJiYgKHRleHQgKz0gJycpO1xuXG4gICAgICAgICAgICAvLyBBbHdheXMgYmluZCBzdHlsZVxuICAgICAgICAgICAgc3R5bGUuYmluZChjdHgsIHRoaXMsIHByZXZFbCk7XG5cbiAgICAgICAgICAgIGlmICh0ZXh0KSB7XG5cbiAgICAgICAgICAgICAgICB0aGlzLnNldFRyYW5zZm9ybShjdHgpO1xuXG4gICAgICAgICAgICAgICAgdmFyIHRleHRCYXNlbGluZTtcbiAgICAgICAgICAgICAgICB2YXIgdGV4dEFsaWduID0gc3R5bGUudGV4dEFsaWduO1xuICAgICAgICAgICAgICAgIHZhciBmb250ID0gc3R5bGUudGV4dEZvbnQgfHwgc3R5bGUuZm9udDtcbiAgICAgICAgICAgICAgICBpZiAoc3R5bGUudGV4dFZlcnRpY2FsQWxpZ24pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlY3QgPSB0ZXh0Q29udGFpbi5nZXRCb3VuZGluZ1JlY3QoXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0LCBmb250LCBzdHlsZS50ZXh0QWxpZ24sICd0b3AnXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIC8vIElnbm9yZSB0ZXh0QmFzZWxpbmVcbiAgICAgICAgICAgICAgICAgICAgdGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoc3R5bGUudGV4dFZlcnRpY2FsQWxpZ24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ21pZGRsZSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeSAtPSByZWN0LmhlaWdodCAvIDIgLSByZWN0LmxpbmVIZWlnaHQgLyAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnYm90dG9tJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5IC09IHJlY3QuaGVpZ2h0IC0gcmVjdC5saW5lSGVpZ2h0IC8gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeSArPSByZWN0LmxpbmVIZWlnaHQgLyAyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0QmFzZWxpbmUgPSBzdHlsZS50ZXh0QmFzZWxpbmU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gVE9ETyBJbnZhbGlkIGZvbnRcbiAgICAgICAgICAgICAgICBjdHguZm9udCA9IGZvbnQgfHwgJzEycHggc2Fucy1zZXJpZic7XG4gICAgICAgICAgICAgICAgY3R4LnRleHRBbGlnbiA9IHRleHRBbGlnbiB8fCAnbGVmdCc7XG4gICAgICAgICAgICAgICAgLy8gVXNlIGNhbnZhcyBkZWZhdWx0IGxlZnQgdGV4dEFsaWduLiBHaXZpbmcgaW52YWxpZCB2YWx1ZSB3aWxsIGNhdXNlIHN0YXRlIG5vdCBjaGFuZ2VcbiAgICAgICAgICAgICAgICBpZiAoY3R4LnRleHRBbGlnbiAhPT0gdGV4dEFsaWduKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eC50ZXh0QWxpZ24gPSAnbGVmdCc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN0eC50ZXh0QmFzZWxpbmUgPSB0ZXh0QmFzZWxpbmUgfHwgJ2FscGhhYmV0aWMnO1xuICAgICAgICAgICAgICAgIC8vIFVzZSBjYW52YXMgZGVmYXVsdCBhbHBoYWJldGljIGJhc2VsaW5lXG4gICAgICAgICAgICAgICAgaWYgKGN0eC50ZXh0QmFzZWxpbmUgIT09IHRleHRCYXNlbGluZSkge1xuICAgICAgICAgICAgICAgICAgICBjdHgudGV4dEJhc2VsaW5lID0gJ2FscGhhYmV0aWMnO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBsaW5lSGVpZ2h0ID0gdGV4dENvbnRhaW4ubWVhc3VyZVRleHQoJ+WbvScsIGN0eC5mb250KS53aWR0aDtcblxuICAgICAgICAgICAgICAgIHZhciB0ZXh0TGluZXMgPSB0ZXh0LnNwbGl0KCdcXG4nKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRleHRMaW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBzdHlsZS5oYXNGaWxsKCkgJiYgY3R4LmZpbGxUZXh0KHRleHRMaW5lc1tpXSwgeCwgeSk7XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlLmhhc1N0cm9rZSgpICYmIGN0eC5zdHJva2VUZXh0KHRleHRMaW5lc1tpXSwgeCwgeSk7XG4gICAgICAgICAgICAgICAgICAgIHkgKz0gbGluZUhlaWdodDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLnJlc3RvcmVUcmFuc2Zvcm0oY3R4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBnZXRCb3VuZGluZ1JlY3Q6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fcmVjdCkge1xuICAgICAgICAgICAgICAgIHZhciBzdHlsZSA9IHRoaXMuc3R5bGU7XG4gICAgICAgICAgICAgICAgdmFyIHRleHRWZXJ0aWNhbEFsaWduID0gc3R5bGUudGV4dFZlcnRpY2FsQWxpZ247XG4gICAgICAgICAgICAgICAgdmFyIHJlY3QgPSB0ZXh0Q29udGFpbi5nZXRCb3VuZGluZ1JlY3QoXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlLnRleHQgKyAnJywgc3R5bGUudGV4dEZvbnQgfHwgc3R5bGUuZm9udCwgc3R5bGUudGV4dEFsaWduLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0VmVydGljYWxBbGlnbiA/ICd0b3AnIDogc3R5bGUudGV4dEJhc2VsaW5lXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHRleHRWZXJ0aWNhbEFsaWduKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ21pZGRsZSc6XG4gICAgICAgICAgICAgICAgICAgICAgICByZWN0LnkgLT0gcmVjdC5oZWlnaHQgLyAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICAgICAgICAgICAgICAgICAgICByZWN0LnkgLT0gcmVjdC5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVjdC54ICs9IHN0eWxlLnggfHwgMDtcbiAgICAgICAgICAgICAgICByZWN0LnkgKz0gc3R5bGUueSB8fCAwO1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlY3QgPSByZWN0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JlY3Q7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgenJVdGlsLmluaGVyaXRzKFRleHQsIERpc3BsYXlhYmxlKTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gVGV4dDtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvVGV4dC5qc1xuICoqIG1vZHVsZSBpZCA9IDQyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG4vKipcbiAqIOWchuW9olxuICogQG1vZHVsZSB6cmVuZGVyL3NoYXBlL0NpcmNsZVxuICovXG5cblxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi9QYXRoJykuZXh0ZW5kKHtcblxuICAgICAgICB0eXBlOiAnY2lyY2xlJyxcblxuICAgICAgICBzaGFwZToge1xuICAgICAgICAgICAgY3g6IDAsXG4gICAgICAgICAgICBjeTogMCxcbiAgICAgICAgICAgIHI6IDBcbiAgICAgICAgfSxcblxuXG4gICAgICAgIGJ1aWxkUGF0aCA6IGZ1bmN0aW9uIChjdHgsIHNoYXBlLCBpbkJ1bmRsZSkge1xuICAgICAgICAgICAgLy8gQmV0dGVyIHN0cm9raW5nIGluIFNoYXBlQnVuZGxlXG4gICAgICAgICAgICAvLyBBbHdheXMgZG8gaXQgbWF5IGhhdmUgcGVyZm9ybWVuY2UgaXNzdWUgKCBmaWxsIG1heSBiZSAyeCBtb3JlIGNvc3QpXG4gICAgICAgICAgICBpZiAoaW5CdW5kbGUpIHtcbiAgICAgICAgICAgICAgICBjdHgubW92ZVRvKHNoYXBlLmN4ICsgc2hhcGUuciwgc2hhcGUuY3kpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQmV0dGVyIHN0cm9raW5nIGluIFNoYXBlQnVuZGxlXG4gICAgICAgICAgICAvLyBjdHgubW92ZVRvKHNoYXBlLmN4ICsgc2hhcGUuciwgc2hhcGUuY3kpO1xuICAgICAgICAgICAgY3R4LmFyYyhzaGFwZS5jeCwgc2hhcGUuY3ksIHNoYXBlLnIsIDAsIE1hdGguUEkgKiAyLCB0cnVlKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi96cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL0NpcmNsZS5qc1xuICoqIG1vZHVsZSBpZCA9IDQzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIOaJh+W9olxuICogQG1vZHVsZSB6cmVuZGVyL2dyYXBoaWMvc2hhcGUvU2VjdG9yXG4gKi9cblxuXG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uL1BhdGgnKS5leHRlbmQoe1xuXG4gICAgICAgIHR5cGU6ICdzZWN0b3InLFxuXG4gICAgICAgIHNoYXBlOiB7XG5cbiAgICAgICAgICAgIGN4OiAwLFxuXG4gICAgICAgICAgICBjeTogMCxcblxuICAgICAgICAgICAgcjA6IDAsXG5cbiAgICAgICAgICAgIHI6IDAsXG5cbiAgICAgICAgICAgIHN0YXJ0QW5nbGU6IDAsXG5cbiAgICAgICAgICAgIGVuZEFuZ2xlOiBNYXRoLlBJICogMixcblxuICAgICAgICAgICAgY2xvY2t3aXNlOiB0cnVlXG4gICAgICAgIH0sXG5cbiAgICAgICAgYnVpbGRQYXRoOiBmdW5jdGlvbiAoY3R4LCBzaGFwZSkge1xuXG4gICAgICAgICAgICB2YXIgeCA9IHNoYXBlLmN4O1xuICAgICAgICAgICAgdmFyIHkgPSBzaGFwZS5jeTtcbiAgICAgICAgICAgIHZhciByMCA9IE1hdGgubWF4KHNoYXBlLnIwIHx8IDAsIDApO1xuICAgICAgICAgICAgdmFyIHIgPSBNYXRoLm1heChzaGFwZS5yLCAwKTtcbiAgICAgICAgICAgIHZhciBzdGFydEFuZ2xlID0gc2hhcGUuc3RhcnRBbmdsZTtcbiAgICAgICAgICAgIHZhciBlbmRBbmdsZSA9IHNoYXBlLmVuZEFuZ2xlO1xuICAgICAgICAgICAgdmFyIGNsb2Nrd2lzZSA9IHNoYXBlLmNsb2Nrd2lzZTtcblxuICAgICAgICAgICAgdmFyIHVuaXRYID0gTWF0aC5jb3Moc3RhcnRBbmdsZSk7XG4gICAgICAgICAgICB2YXIgdW5pdFkgPSBNYXRoLnNpbihzdGFydEFuZ2xlKTtcblxuICAgICAgICAgICAgY3R4Lm1vdmVUbyh1bml0WCAqIHIwICsgeCwgdW5pdFkgKiByMCArIHkpO1xuXG4gICAgICAgICAgICBjdHgubGluZVRvKHVuaXRYICogciArIHgsIHVuaXRZICogciArIHkpO1xuXG4gICAgICAgICAgICBjdHguYXJjKHgsIHksIHIsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCAhY2xvY2t3aXNlKTtcblxuICAgICAgICAgICAgY3R4LmxpbmVUbyhcbiAgICAgICAgICAgICAgICBNYXRoLmNvcyhlbmRBbmdsZSkgKiByMCArIHgsXG4gICAgICAgICAgICAgICAgTWF0aC5zaW4oZW5kQW5nbGUpICogcjAgKyB5XG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBpZiAocjAgIT09IDApIHtcbiAgICAgICAgICAgICAgICBjdHguYXJjKHgsIHksIHIwLCBlbmRBbmdsZSwgc3RhcnRBbmdsZSwgY2xvY2t3aXNlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICB9XG4gICAgfSk7XG5cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvU2VjdG9yLmpzXG4gKiogbW9kdWxlIGlkID0gNDRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICog5ZyG546vXG4gKiBAbW9kdWxlIHpyZW5kZXIvZ3JhcGhpYy9zaGFwZS9SaW5nXG4gKi9cblxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi9QYXRoJykuZXh0ZW5kKHtcblxuICAgICAgICB0eXBlOiAncmluZycsXG5cbiAgICAgICAgc2hhcGU6IHtcbiAgICAgICAgICAgIGN4OiAwLFxuICAgICAgICAgICAgY3k6IDAsXG4gICAgICAgICAgICByOiAwLFxuICAgICAgICAgICAgcjA6IDBcbiAgICAgICAgfSxcblxuICAgICAgICBidWlsZFBhdGg6IGZ1bmN0aW9uIChjdHgsIHNoYXBlKSB7XG4gICAgICAgICAgICB2YXIgeCA9IHNoYXBlLmN4O1xuICAgICAgICAgICAgdmFyIHkgPSBzaGFwZS5jeTtcbiAgICAgICAgICAgIHZhciBQSTIgPSBNYXRoLlBJICogMjtcbiAgICAgICAgICAgIGN0eC5tb3ZlVG8oeCArIHNoYXBlLnIsIHkpO1xuICAgICAgICAgICAgY3R4LmFyYyh4LCB5LCBzaGFwZS5yLCAwLCBQSTIsIGZhbHNlKTtcbiAgICAgICAgICAgIGN0eC5tb3ZlVG8oeCArIHNoYXBlLnIwLCB5KTtcbiAgICAgICAgICAgIGN0eC5hcmMoeCwgeSwgc2hhcGUucjAsIDAsIFBJMiwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34venJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9SaW5nLmpzXG4gKiogbW9kdWxlIGlkID0gNDVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICog5aSa6L655b2iXG4gKiBAbW9kdWxlIHpyZW5kZXIvc2hhcGUvUG9seWdvblxuICovXG5cblxuICAgIHZhciBwb2x5SGVscGVyID0gcmVxdWlyZSgnLi4vaGVscGVyL3BvbHknKTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vUGF0aCcpLmV4dGVuZCh7XG4gICAgICAgIFxuICAgICAgICB0eXBlOiAncG9seWdvbicsXG5cbiAgICAgICAgc2hhcGU6IHtcbiAgICAgICAgICAgIHBvaW50czogbnVsbCxcblxuICAgICAgICAgICAgc21vb3RoOiBmYWxzZSxcblxuICAgICAgICAgICAgc21vb3RoQ29uc3RyYWludDogbnVsbFxuICAgICAgICB9LFxuXG4gICAgICAgIGJ1aWxkUGF0aDogZnVuY3Rpb24gKGN0eCwgc2hhcGUpIHtcbiAgICAgICAgICAgIHBvbHlIZWxwZXIuYnVpbGRQYXRoKGN0eCwgc2hhcGUsIHRydWUpO1xuICAgICAgICB9XG4gICAgfSk7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi96cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL1BvbHlnb24uanNcbiAqKiBtb2R1bGUgaWQgPSA0NlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXG5cbiAgICB2YXIgc21vb3RoU3BsaW5lID0gcmVxdWlyZSgnLi9zbW9vdGhTcGxpbmUnKTtcbiAgICB2YXIgc21vb3RoQmV6aWVyID0gcmVxdWlyZSgnLi9zbW9vdGhCZXppZXInKTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0ge1xuICAgICAgICBidWlsZFBhdGg6IGZ1bmN0aW9uIChjdHgsIHNoYXBlLCBjbG9zZVBhdGgpIHtcbiAgICAgICAgICAgIHZhciBwb2ludHMgPSBzaGFwZS5wb2ludHM7XG4gICAgICAgICAgICB2YXIgc21vb3RoID0gc2hhcGUuc21vb3RoO1xuICAgICAgICAgICAgaWYgKHBvaW50cyAmJiBwb2ludHMubGVuZ3RoID49IDIpIHtcbiAgICAgICAgICAgICAgICBpZiAoc21vb3RoICYmIHNtb290aCAhPT0gJ3NwbGluZScpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnRyb2xQb2ludHMgPSBzbW9vdGhCZXppZXIoXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludHMsIHNtb290aCwgY2xvc2VQYXRoLCBzaGFwZS5zbW9vdGhDb25zdHJhaW50XG4gICAgICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAgICAgY3R4Lm1vdmVUbyhwb2ludHNbMF1bMF0sIHBvaW50c1swXVsxXSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsZW4gPSBwb2ludHMubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IChjbG9zZVBhdGggPyBsZW4gOiBsZW4gLSAxKTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3AxID0gY29udHJvbFBvaW50c1tpICogMl07XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3AyID0gY29udHJvbFBvaW50c1tpICogMiArIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHAgPSBwb2ludHNbKGkgKyAxKSAlIGxlbl07XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguYmV6aWVyQ3VydmVUbyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjcDFbMF0sIGNwMVsxXSwgY3AyWzBdLCBjcDJbMV0sIHBbMF0sIHBbMV1cbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzbW9vdGggPT09ICdzcGxpbmUnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludHMgPSBzbW9vdGhTcGxpbmUocG9pbnRzLCBjbG9zZVBhdGgpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgY3R4Lm1vdmVUbyhwb2ludHNbMF1bMF0sIHBvaW50c1swXVsxXSk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAxLCBsID0gcG9pbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmxpbmVUbyhwb2ludHNbaV1bMF0sIHBvaW50c1tpXVsxXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjbG9zZVBhdGggJiYgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvaGVscGVyL3BvbHkuanNcbiAqKiBtb2R1bGUgaWQgPSA0N1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDYXRtdWxsLVJvbSBzcGxpbmUg5o+S5YC85oqY57q/XG4gKiBAbW9kdWxlIHpyZW5kZXIvc2hhcGUvdXRpbC9zbW9vdGhTcGxpbmVcbiAqIEBhdXRob3IgcGlzc2FuZyAoaHR0cHM6Ly93d3cuZ2l0aHViLmNvbS9waXNzYW5nKVxuICogICAgICAgICBLZW5lciAoQEtlbmVyLeael+WzsCwga2VuZXIubGluZmVuZ0BnbWFpbC5jb20pXG4gKiAgICAgICAgIGVycm9ycmlrIChlcnJvcnJpa0BnbWFpbC5jb20pXG4gKi9cblxuICAgIHZhciB2ZWMyID0gcmVxdWlyZSgnLi4vLi4vY29yZS92ZWN0b3InKTtcblxuICAgIC8qKlxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGludGVycG9sYXRlKHAwLCBwMSwgcDIsIHAzLCB0LCB0MiwgdDMpIHtcbiAgICAgICAgdmFyIHYwID0gKHAyIC0gcDApICogMC41O1xuICAgICAgICB2YXIgdjEgPSAocDMgLSBwMSkgKiAwLjU7XG4gICAgICAgIHJldHVybiAoMiAqIChwMSAtIHAyKSArIHYwICsgdjEpICogdDNcbiAgICAgICAgICAgICAgICArICgtMyAqIChwMSAtIHAyKSAtIDIgKiB2MCAtIHYxKSAqIHQyXG4gICAgICAgICAgICAgICAgKyB2MCAqIHQgKyBwMTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAYWxpYXMgbW9kdWxlOnpyZW5kZXIvc2hhcGUvdXRpbC9zbW9vdGhTcGxpbmVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwb2ludHMg57q/5q616aG254K55pWw57uEXG4gICAgICogQHBhcmFtIHtib29sZWFufSBpc0xvb3BcbiAgICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICAgKi9cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChwb2ludHMsIGlzTG9vcCkge1xuICAgICAgICB2YXIgbGVuID0gcG9pbnRzLmxlbmd0aDtcbiAgICAgICAgdmFyIHJldCA9IFtdO1xuXG4gICAgICAgIHZhciBkaXN0YW5jZSA9IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGRpc3RhbmNlICs9IHZlYzIuZGlzdGFuY2UocG9pbnRzW2kgLSAxXSwgcG9pbnRzW2ldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzZWdzID0gZGlzdGFuY2UgLyAyO1xuICAgICAgICBzZWdzID0gc2VncyA8IGxlbiA/IGxlbiA6IHNlZ3M7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VnczsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgcG9zID0gaSAvIChzZWdzIC0gMSkgKiAoaXNMb29wID8gbGVuIDogbGVuIC0gMSk7XG4gICAgICAgICAgICB2YXIgaWR4ID0gTWF0aC5mbG9vcihwb3MpO1xuXG4gICAgICAgICAgICB2YXIgdyA9IHBvcyAtIGlkeDtcblxuICAgICAgICAgICAgdmFyIHAwO1xuICAgICAgICAgICAgdmFyIHAxID0gcG9pbnRzW2lkeCAlIGxlbl07XG4gICAgICAgICAgICB2YXIgcDI7XG4gICAgICAgICAgICB2YXIgcDM7XG4gICAgICAgICAgICBpZiAoIWlzTG9vcCkge1xuICAgICAgICAgICAgICAgIHAwID0gcG9pbnRzW2lkeCA9PT0gMCA/IGlkeCA6IGlkeCAtIDFdO1xuICAgICAgICAgICAgICAgIHAyID0gcG9pbnRzW2lkeCA+IGxlbiAtIDIgPyBsZW4gLSAxIDogaWR4ICsgMV07XG4gICAgICAgICAgICAgICAgcDMgPSBwb2ludHNbaWR4ID4gbGVuIC0gMyA/IGxlbiAtIDEgOiBpZHggKyAyXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHAwID0gcG9pbnRzWyhpZHggLSAxICsgbGVuKSAlIGxlbl07XG4gICAgICAgICAgICAgICAgcDIgPSBwb2ludHNbKGlkeCArIDEpICUgbGVuXTtcbiAgICAgICAgICAgICAgICBwMyA9IHBvaW50c1soaWR4ICsgMikgJSBsZW5dO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgdzIgPSB3ICogdztcbiAgICAgICAgICAgIHZhciB3MyA9IHcgKiB3MjtcblxuICAgICAgICAgICAgcmV0LnB1c2goW1xuICAgICAgICAgICAgICAgIGludGVycG9sYXRlKHAwWzBdLCBwMVswXSwgcDJbMF0sIHAzWzBdLCB3LCB3MiwgdzMpLFxuICAgICAgICAgICAgICAgIGludGVycG9sYXRlKHAwWzFdLCBwMVsxXSwgcDJbMV0sIHAzWzFdLCB3LCB3MiwgdzMpXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG5cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvaGVscGVyL3Ntb290aFNwbGluZS5qc1xuICoqIG1vZHVsZSBpZCA9IDQ4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIOi0neWhnuWwlOW5s+a7keabsue6v1xuICogQG1vZHVsZSB6cmVuZGVyL3NoYXBlL3V0aWwvc21vb3RoQmV6aWVyXG4gKiBAYXV0aG9yIHBpc3NhbmcgKGh0dHBzOi8vd3d3LmdpdGh1Yi5jb20vcGlzc2FuZylcbiAqICAgICAgICAgS2VuZXIgKEBLZW5lci3mnpfls7AsIGtlbmVyLmxpbmZlbmdAZ21haWwuY29tKVxuICogICAgICAgICBlcnJvcnJpayAoZXJyb3JyaWtAZ21haWwuY29tKVxuICovXG5cblxuICAgIHZhciB2ZWMyID0gcmVxdWlyZSgnLi4vLi4vY29yZS92ZWN0b3InKTtcbiAgICB2YXIgdjJNaW4gPSB2ZWMyLm1pbjtcbiAgICB2YXIgdjJNYXggPSB2ZWMyLm1heDtcbiAgICB2YXIgdjJTY2FsZSA9IHZlYzIuc2NhbGU7XG4gICAgdmFyIHYyRGlzdGFuY2UgPSB2ZWMyLmRpc3RhbmNlO1xuICAgIHZhciB2MkFkZCA9IHZlYzIuYWRkO1xuXG4gICAgLyoqXG4gICAgICog6LSd5aGe5bCU5bmz5ruR5puy57q/XG4gICAgICogQGFsaWFzIG1vZHVsZTp6cmVuZGVyL3NoYXBlL3V0aWwvc21vb3RoQmV6aWVyXG4gICAgICogQHBhcmFtIHtBcnJheX0gcG9pbnRzIOe6v+autemhtueCueaVsOe7hFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzbW9vdGgg5bmz5ruR562J57qnLCAwLTFcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzTG9vcFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGNvbnN0cmFpbnQg5bCG6K6h566X5Ye65p2l55qE5o6n5Yi254K557qm5p2f5Zyo5LiA5Liq5YyF5Zu055uS5YaFXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICDmr5TlpoIgW1swLCAwXSwgWzEwMCwgMTAwXV0sIOi/meS4quWMheWbtOebkuS8muS4jlxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAg5pW05Liq5oqY57q/55qE5YyF5Zu055uS5YGa5LiA5Liq5bm26ZuG55So5p2l57qm5p2f5o6n5Yi254K544CCXG4gICAgICogQHBhcmFtIHtBcnJheX0g6K6h566X5Ye65p2l55qE5o6n5Yi254K55pWw57uEXG4gICAgICovXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAocG9pbnRzLCBzbW9vdGgsIGlzTG9vcCwgY29uc3RyYWludCkge1xuICAgICAgICB2YXIgY3BzID0gW107XG5cbiAgICAgICAgdmFyIHYgPSBbXTtcbiAgICAgICAgdmFyIHYxID0gW107XG4gICAgICAgIHZhciB2MiA9IFtdO1xuICAgICAgICB2YXIgcHJldlBvaW50O1xuICAgICAgICB2YXIgbmV4dFBvaW50O1xuXG4gICAgICAgIHZhciBtaW4sIG1heDtcbiAgICAgICAgaWYgKGNvbnN0cmFpbnQpIHtcbiAgICAgICAgICAgIG1pbiA9IFtJbmZpbml0eSwgSW5maW5pdHldO1xuICAgICAgICAgICAgbWF4ID0gWy1JbmZpbml0eSwgLUluZmluaXR5XTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBwb2ludHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2Mk1pbihtaW4sIG1pbiwgcG9pbnRzW2ldKTtcbiAgICAgICAgICAgICAgICB2Mk1heChtYXgsIG1heCwgcG9pbnRzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIOS4juaMh+WumueahOWMheWbtOebkuWBmuW5tumbhlxuICAgICAgICAgICAgdjJNaW4obWluLCBtaW4sIGNvbnN0cmFpbnRbMF0pO1xuICAgICAgICAgICAgdjJNYXgobWF4LCBtYXgsIGNvbnN0cmFpbnRbMV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHBvaW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgdmFyIHBvaW50ID0gcG9pbnRzW2ldO1xuXG4gICAgICAgICAgICBpZiAoaXNMb29wKSB7XG4gICAgICAgICAgICAgICAgcHJldlBvaW50ID0gcG9pbnRzW2kgPyBpIC0gMSA6IGxlbiAtIDFdO1xuICAgICAgICAgICAgICAgIG5leHRQb2ludCA9IHBvaW50c1soaSArIDEpICUgbGVuXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChpID09PSAwIHx8IGkgPT09IGxlbiAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgY3BzLnB1c2godmVjMi5jbG9uZShwb2ludHNbaV0pKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwcmV2UG9pbnQgPSBwb2ludHNbaSAtIDFdO1xuICAgICAgICAgICAgICAgICAgICBuZXh0UG9pbnQgPSBwb2ludHNbaSArIDFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmVjMi5zdWIodiwgbmV4dFBvaW50LCBwcmV2UG9pbnQpO1xuXG4gICAgICAgICAgICAvLyB1c2UgZGVncmVlIHRvIHNjYWxlIHRoZSBoYW5kbGUgbGVuZ3RoXG4gICAgICAgICAgICB2MlNjYWxlKHYsIHYsIHNtb290aCk7XG5cbiAgICAgICAgICAgIHZhciBkMCA9IHYyRGlzdGFuY2UocG9pbnQsIHByZXZQb2ludCk7XG4gICAgICAgICAgICB2YXIgZDEgPSB2MkRpc3RhbmNlKHBvaW50LCBuZXh0UG9pbnQpO1xuICAgICAgICAgICAgdmFyIHN1bSA9IGQwICsgZDE7XG4gICAgICAgICAgICBpZiAoc3VtICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgZDAgLz0gc3VtO1xuICAgICAgICAgICAgICAgIGQxIC89IHN1bTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdjJTY2FsZSh2MSwgdiwgLWQwKTtcbiAgICAgICAgICAgIHYyU2NhbGUodjIsIHYsIGQxKTtcbiAgICAgICAgICAgIHZhciBjcDAgPSB2MkFkZChbXSwgcG9pbnQsIHYxKTtcbiAgICAgICAgICAgIHZhciBjcDEgPSB2MkFkZChbXSwgcG9pbnQsIHYyKTtcbiAgICAgICAgICAgIGlmIChjb25zdHJhaW50KSB7XG4gICAgICAgICAgICAgICAgdjJNYXgoY3AwLCBjcDAsIG1pbik7XG4gICAgICAgICAgICAgICAgdjJNaW4oY3AwLCBjcDAsIG1heCk7XG4gICAgICAgICAgICAgICAgdjJNYXgoY3AxLCBjcDEsIG1pbik7XG4gICAgICAgICAgICAgICAgdjJNaW4oY3AxLCBjcDEsIG1heCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjcHMucHVzaChjcDApO1xuICAgICAgICAgICAgY3BzLnB1c2goY3AxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0xvb3ApIHtcbiAgICAgICAgICAgIGNwcy5wdXNoKGNwcy5zaGlmdCgpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjcHM7XG4gICAgfTtcblxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34venJlbmRlci9saWIvZ3JhcGhpYy9oZWxwZXIvc21vb3RoQmV6aWVyLmpzXG4gKiogbW9kdWxlIGlkID0gNDlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQG1vZHVsZSB6cmVuZGVyL2dyYXBoaWMvc2hhcGUvUG9seWxpbmVcbiAqL1xuXG5cbiAgICB2YXIgcG9seUhlbHBlciA9IHJlcXVpcmUoJy4uL2hlbHBlci9wb2x5Jyk7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uL1BhdGgnKS5leHRlbmQoe1xuICAgICAgICBcbiAgICAgICAgdHlwZTogJ3BvbHlsaW5lJyxcblxuICAgICAgICBzaGFwZToge1xuICAgICAgICAgICAgcG9pbnRzOiBudWxsLFxuXG4gICAgICAgICAgICBzbW9vdGg6IGZhbHNlLFxuXG4gICAgICAgICAgICBzbW9vdGhDb25zdHJhaW50OiBudWxsXG4gICAgICAgIH0sXG5cbiAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgIHN0cm9rZTogJyMwMDAnLFxuXG4gICAgICAgICAgICBmaWxsOiBudWxsXG4gICAgICAgIH0sXG5cbiAgICAgICAgYnVpbGRQYXRoOiBmdW5jdGlvbiAoY3R4LCBzaGFwZSkge1xuICAgICAgICAgICAgcG9seUhlbHBlci5idWlsZFBhdGgoY3R4LCBzaGFwZSwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgfSk7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi96cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL1BvbHlsaW5lLmpzXG4gKiogbW9kdWxlIGlkID0gNTBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICog55+p5b2iXG4gKiBAbW9kdWxlIHpyZW5kZXIvZ3JhcGhpYy9zaGFwZS9SZWN0XG4gKi9cblxuXG4gICAgdmFyIHJvdW5kUmVjdEhlbHBlciA9IHJlcXVpcmUoJy4uL2hlbHBlci9yb3VuZFJlY3QnKTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vUGF0aCcpLmV4dGVuZCh7XG5cbiAgICAgICAgdHlwZTogJ3JlY3QnLFxuXG4gICAgICAgIHNoYXBlOiB7XG4gICAgICAgICAgICAvLyDlt6bkuIrjgIHlj7PkuIrjgIHlj7PkuIvjgIHlt6bkuIvop5LnmoTljYrlvoTkvp3mrKHkuLpyMeOAgXIy44CBcjPjgIFyNFxuICAgICAgICAgICAgLy8gcue8qeWGmeS4ujEgICAgICAgICDnm7jlvZPkuo4gWzEsIDEsIDEsIDFdXG4gICAgICAgICAgICAvLyBy57yp5YaZ5Li6WzFdICAgICAgIOebuOW9k+S6jiBbMSwgMSwgMSwgMV1cbiAgICAgICAgICAgIC8vIHLnvKnlhpnkuLpbMSwgMl0gICAg55u45b2T5LqOIFsxLCAyLCAxLCAyXVxuICAgICAgICAgICAgLy8gcue8qeWGmeS4ulsxLCAyLCAzXSDnm7jlvZPkuo4gWzEsIDIsIDMsIDJdXG4gICAgICAgICAgICByOiAwLFxuXG4gICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgeTogMCxcbiAgICAgICAgICAgIHdpZHRoOiAwLFxuICAgICAgICAgICAgaGVpZ2h0OiAwXG4gICAgICAgIH0sXG5cbiAgICAgICAgYnVpbGRQYXRoOiBmdW5jdGlvbiAoY3R4LCBzaGFwZSkge1xuICAgICAgICAgICAgdmFyIHggPSBzaGFwZS54O1xuICAgICAgICAgICAgdmFyIHkgPSBzaGFwZS55O1xuICAgICAgICAgICAgdmFyIHdpZHRoID0gc2hhcGUud2lkdGg7XG4gICAgICAgICAgICB2YXIgaGVpZ2h0ID0gc2hhcGUuaGVpZ2h0O1xuICAgICAgICAgICAgaWYgKCFzaGFwZS5yKSB7XG4gICAgICAgICAgICAgICAgY3R4LnJlY3QoeCwgeSwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByb3VuZFJlY3RIZWxwZXIuYnVpbGRQYXRoKGN0eCwgc2hhcGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfSk7XG5cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvUmVjdC5qc1xuICoqIG1vZHVsZSBpZCA9IDUxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcblxuICAgIG1vZHVsZS5leHBvcnRzID0ge1xuICAgICAgICBidWlsZFBhdGg6IGZ1bmN0aW9uIChjdHgsIHNoYXBlKSB7XG4gICAgICAgICAgICB2YXIgeCA9IHNoYXBlLng7XG4gICAgICAgICAgICB2YXIgeSA9IHNoYXBlLnk7XG4gICAgICAgICAgICB2YXIgd2lkdGggPSBzaGFwZS53aWR0aDtcbiAgICAgICAgICAgIHZhciBoZWlnaHQgPSBzaGFwZS5oZWlnaHQ7XG4gICAgICAgICAgICB2YXIgciA9IHNoYXBlLnI7XG4gICAgICAgICAgICB2YXIgcjE7XG4gICAgICAgICAgICB2YXIgcjI7XG4gICAgICAgICAgICB2YXIgcjM7XG4gICAgICAgICAgICB2YXIgcjQ7XG5cbiAgICAgICAgICAgIC8vIENvbnZlcnQgd2lkdGggYW5kIGhlaWdodCB0byBwb3NpdGl2ZSBmb3IgYmV0dGVyIGJvcmRlclJhZGl1c1xuICAgICAgICAgICAgaWYgKHdpZHRoIDwgMCkge1xuICAgICAgICAgICAgICAgIHggPSB4ICsgd2lkdGg7XG4gICAgICAgICAgICAgICAgd2lkdGggPSAtd2lkdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaGVpZ2h0IDwgMCkge1xuICAgICAgICAgICAgICAgIHkgPSB5ICsgaGVpZ2h0O1xuICAgICAgICAgICAgICAgIGhlaWdodCA9IC1oZWlnaHQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgciA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICByMSA9IHIyID0gcjMgPSByNCA9IHI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChyIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgICAgICBpZiAoci5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcjEgPSByMiA9IHIzID0gcjQgPSByWzBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChyLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgICAgICAgICByMSA9IHIzID0gclswXTtcbiAgICAgICAgICAgICAgICAgICAgcjIgPSByNCA9IHJbMV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHIubGVuZ3RoID09PSAzKSB7XG4gICAgICAgICAgICAgICAgICAgIHIxID0gclswXTtcbiAgICAgICAgICAgICAgICAgICAgcjIgPSByNCA9IHJbMV07XG4gICAgICAgICAgICAgICAgICAgIHIzID0gclsyXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHIxID0gclswXTtcbiAgICAgICAgICAgICAgICAgICAgcjIgPSByWzFdO1xuICAgICAgICAgICAgICAgICAgICByMyA9IHJbMl07XG4gICAgICAgICAgICAgICAgICAgIHI0ID0gclszXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByMSA9IHIyID0gcjMgPSByNCA9IDA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciB0b3RhbDtcbiAgICAgICAgICAgIGlmIChyMSArIHIyID4gd2lkdGgpIHtcbiAgICAgICAgICAgICAgICB0b3RhbCA9IHIxICsgcjI7XG4gICAgICAgICAgICAgICAgcjEgKj0gd2lkdGggLyB0b3RhbDtcbiAgICAgICAgICAgICAgICByMiAqPSB3aWR0aCAvIHRvdGFsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHIzICsgcjQgPiB3aWR0aCkge1xuICAgICAgICAgICAgICAgIHRvdGFsID0gcjMgKyByNDtcbiAgICAgICAgICAgICAgICByMyAqPSB3aWR0aCAvIHRvdGFsO1xuICAgICAgICAgICAgICAgIHI0ICo9IHdpZHRoIC8gdG90YWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocjIgKyByMyA+IGhlaWdodCkge1xuICAgICAgICAgICAgICAgIHRvdGFsID0gcjIgKyByMztcbiAgICAgICAgICAgICAgICByMiAqPSBoZWlnaHQgLyB0b3RhbDtcbiAgICAgICAgICAgICAgICByMyAqPSBoZWlnaHQgLyB0b3RhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyMSArIHI0ID4gaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgdG90YWwgPSByMSArIHI0O1xuICAgICAgICAgICAgICAgIHIxICo9IGhlaWdodCAvIHRvdGFsO1xuICAgICAgICAgICAgICAgIHI0ICo9IGhlaWdodCAvIHRvdGFsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3R4Lm1vdmVUbyh4ICsgcjEsIHkpO1xuICAgICAgICAgICAgY3R4LmxpbmVUbyh4ICsgd2lkdGggLSByMiwgeSk7XG4gICAgICAgICAgICByMiAhPT0gMCAmJiBjdHgucXVhZHJhdGljQ3VydmVUbyhcbiAgICAgICAgICAgICAgICB4ICsgd2lkdGgsIHksIHggKyB3aWR0aCwgeSArIHIyXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgY3R4LmxpbmVUbyh4ICsgd2lkdGgsIHkgKyBoZWlnaHQgLSByMyk7XG4gICAgICAgICAgICByMyAhPT0gMCAmJiBjdHgucXVhZHJhdGljQ3VydmVUbyhcbiAgICAgICAgICAgICAgICB4ICsgd2lkdGgsIHkgKyBoZWlnaHQsIHggKyB3aWR0aCAtIHIzLCB5ICsgaGVpZ2h0XG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgY3R4LmxpbmVUbyh4ICsgcjQsIHkgKyBoZWlnaHQpO1xuICAgICAgICAgICAgcjQgIT09IDAgJiYgY3R4LnF1YWRyYXRpY0N1cnZlVG8oXG4gICAgICAgICAgICAgICAgeCwgeSArIGhlaWdodCwgeCwgeSArIGhlaWdodCAtIHI0XG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgY3R4LmxpbmVUbyh4LCB5ICsgcjEpO1xuICAgICAgICAgICAgcjEgIT09IDAgJiYgY3R4LnF1YWRyYXRpY0N1cnZlVG8oeCwgeSwgeCArIHIxLCB5KTtcbiAgICAgICAgfVxuICAgIH07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi96cmVuZGVyL2xpYi9ncmFwaGljL2hlbHBlci9yb3VuZFJlY3QuanNcbiAqKiBtb2R1bGUgaWQgPSA1MlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiDnm7Tnur9cbiAqIEBtb2R1bGUgenJlbmRlci9ncmFwaGljL3NoYXBlL0xpbmVcbiAqL1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi9QYXRoJykuZXh0ZW5kKHtcblxuICAgICAgICB0eXBlOiAnbGluZScsXG5cbiAgICAgICAgc2hhcGU6IHtcbiAgICAgICAgICAgIC8vIFN0YXJ0IHBvaW50XG4gICAgICAgICAgICB4MTogMCxcbiAgICAgICAgICAgIHkxOiAwLFxuICAgICAgICAgICAgLy8gRW5kIHBvaW50XG4gICAgICAgICAgICB4MjogMCxcbiAgICAgICAgICAgIHkyOiAwLFxuXG4gICAgICAgICAgICBwZXJjZW50OiAxXG4gICAgICAgIH0sXG5cbiAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgIHN0cm9rZTogJyMwMDAnLFxuICAgICAgICAgICAgZmlsbDogbnVsbFxuICAgICAgICB9LFxuXG4gICAgICAgIGJ1aWxkUGF0aDogZnVuY3Rpb24gKGN0eCwgc2hhcGUpIHtcbiAgICAgICAgICAgIHZhciB4MSA9IHNoYXBlLngxO1xuICAgICAgICAgICAgdmFyIHkxID0gc2hhcGUueTE7XG4gICAgICAgICAgICB2YXIgeDIgPSBzaGFwZS54MjtcbiAgICAgICAgICAgIHZhciB5MiA9IHNoYXBlLnkyO1xuICAgICAgICAgICAgdmFyIHBlcmNlbnQgPSBzaGFwZS5wZXJjZW50O1xuXG4gICAgICAgICAgICBpZiAocGVyY2VudCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY3R4Lm1vdmVUbyh4MSwgeTEpO1xuXG4gICAgICAgICAgICBpZiAocGVyY2VudCA8IDEpIHtcbiAgICAgICAgICAgICAgICB4MiA9IHgxICogKDEgLSBwZXJjZW50KSArIHgyICogcGVyY2VudDtcbiAgICAgICAgICAgICAgICB5MiA9IHkxICogKDEgLSBwZXJjZW50KSArIHkyICogcGVyY2VudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN0eC5saW5lVG8oeDIsIHkyKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHBvaW50IGF0IHBlcmNlbnRcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSBwZXJjZW50XG4gICAgICAgICAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fVxuICAgICAgICAgKi9cbiAgICAgICAgcG9pbnRBdDogZnVuY3Rpb24gKHApIHtcbiAgICAgICAgICAgIHZhciBzaGFwZSA9IHRoaXMuc2hhcGU7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIHNoYXBlLngxICogKDEgLSBwKSArIHNoYXBlLngyICogcCxcbiAgICAgICAgICAgICAgICBzaGFwZS55MSAqICgxIC0gcCkgKyBzaGFwZS55MiAqIHBcbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICB9KTtcblxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34venJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9MaW5lLmpzXG4gKiogbW9kdWxlIGlkID0gNTNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0Jztcbi8qKlxuICog6LSd5aGe5bCU5puy57q/XG4gKiBAbW9kdWxlIHpyZW5kZXIvc2hhcGUvQmV6aWVyQ3VydmVcbiAqL1xuXG5cbiAgICB2YXIgY3VydmVUb29sID0gcmVxdWlyZSgnLi4vLi4vY29yZS9jdXJ2ZScpO1xuICAgIHZhciB2ZWMyID0gcmVxdWlyZSgnLi4vLi4vY29yZS92ZWN0b3InKTtcbiAgICB2YXIgcXVhZHJhdGljU3ViZGl2aWRlID0gY3VydmVUb29sLnF1YWRyYXRpY1N1YmRpdmlkZTtcbiAgICB2YXIgY3ViaWNTdWJkaXZpZGUgPSBjdXJ2ZVRvb2wuY3ViaWNTdWJkaXZpZGU7XG4gICAgdmFyIHF1YWRyYXRpY0F0ID0gY3VydmVUb29sLnF1YWRyYXRpY0F0O1xuICAgIHZhciBjdWJpY0F0ID0gY3VydmVUb29sLmN1YmljQXQ7XG4gICAgdmFyIHF1YWRyYXRpY0Rlcml2YXRpdmVBdCA9IGN1cnZlVG9vbC5xdWFkcmF0aWNEZXJpdmF0aXZlQXQ7XG4gICAgdmFyIGN1YmljRGVyaXZhdGl2ZUF0ID0gY3VydmVUb29sLmN1YmljRGVyaXZhdGl2ZUF0O1xuXG4gICAgdmFyIG91dCA9IFtdO1xuXG4gICAgZnVuY3Rpb24gc29tZVZlY3RvckF0KHNoYXBlLCB0LCBpc1RhbmdlbnQpIHtcbiAgICAgICAgdmFyIGNweDIgPSBzaGFwZS5jcHgyO1xuICAgICAgICB2YXIgY3B5MiA9IHNoYXBlLmNweTI7XG4gICAgICAgIGlmIChjcHgyID09PSBudWxsIHx8IGNweTIgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgKGlzVGFuZ2VudCA/IGN1YmljRGVyaXZhdGl2ZUF0IDogY3ViaWNBdCkoc2hhcGUueDEsIHNoYXBlLmNweDEsIHNoYXBlLmNweDIsIHNoYXBlLngyLCB0KSxcbiAgICAgICAgICAgICAgICAoaXNUYW5nZW50ID8gY3ViaWNEZXJpdmF0aXZlQXQgOiBjdWJpY0F0KShzaGFwZS55MSwgc2hhcGUuY3B5MSwgc2hhcGUuY3B5Miwgc2hhcGUueTIsIHQpXG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAoaXNUYW5nZW50ID8gcXVhZHJhdGljRGVyaXZhdGl2ZUF0IDogcXVhZHJhdGljQXQpKHNoYXBlLngxLCBzaGFwZS5jcHgxLCBzaGFwZS54MiwgdCksXG4gICAgICAgICAgICAgICAgKGlzVGFuZ2VudCA/IHF1YWRyYXRpY0Rlcml2YXRpdmVBdCA6IHF1YWRyYXRpY0F0KShzaGFwZS55MSwgc2hhcGUuY3B5MSwgc2hhcGUueTIsIHQpXG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG4gICAgfVxuICAgIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vUGF0aCcpLmV4dGVuZCh7XG5cbiAgICAgICAgdHlwZTogJ2Jlemllci1jdXJ2ZScsXG5cbiAgICAgICAgc2hhcGU6IHtcbiAgICAgICAgICAgIHgxOiAwLFxuICAgICAgICAgICAgeTE6IDAsXG4gICAgICAgICAgICB4MjogMCxcbiAgICAgICAgICAgIHkyOiAwLFxuICAgICAgICAgICAgY3B4MTogMCxcbiAgICAgICAgICAgIGNweTE6IDAsXG4gICAgICAgICAgICAvLyBjcHgyOiAwLFxuICAgICAgICAgICAgLy8gY3B5MjogMFxuXG4gICAgICAgICAgICAvLyBDdXJ2ZSBzaG93IHBlcmNlbnQsIGZvciBhbmltYXRpbmdcbiAgICAgICAgICAgIHBlcmNlbnQ6IDFcbiAgICAgICAgfSxcblxuICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgc3Ryb2tlOiAnIzAwMCcsXG4gICAgICAgICAgICBmaWxsOiBudWxsXG4gICAgICAgIH0sXG5cbiAgICAgICAgYnVpbGRQYXRoOiBmdW5jdGlvbiAoY3R4LCBzaGFwZSkge1xuICAgICAgICAgICAgdmFyIHgxID0gc2hhcGUueDE7XG4gICAgICAgICAgICB2YXIgeTEgPSBzaGFwZS55MTtcbiAgICAgICAgICAgIHZhciB4MiA9IHNoYXBlLngyO1xuICAgICAgICAgICAgdmFyIHkyID0gc2hhcGUueTI7XG4gICAgICAgICAgICB2YXIgY3B4MSA9IHNoYXBlLmNweDE7XG4gICAgICAgICAgICB2YXIgY3B5MSA9IHNoYXBlLmNweTE7XG4gICAgICAgICAgICB2YXIgY3B4MiA9IHNoYXBlLmNweDI7XG4gICAgICAgICAgICB2YXIgY3B5MiA9IHNoYXBlLmNweTI7XG4gICAgICAgICAgICB2YXIgcGVyY2VudCA9IHNoYXBlLnBlcmNlbnQ7XG4gICAgICAgICAgICBpZiAocGVyY2VudCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY3R4Lm1vdmVUbyh4MSwgeTEpO1xuXG4gICAgICAgICAgICBpZiAoY3B4MiA9PSBudWxsIHx8IGNweTIgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmIChwZXJjZW50IDwgMSkge1xuICAgICAgICAgICAgICAgICAgICBxdWFkcmF0aWNTdWJkaXZpZGUoXG4gICAgICAgICAgICAgICAgICAgICAgICB4MSwgY3B4MSwgeDIsIHBlcmNlbnQsIG91dFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICBjcHgxID0gb3V0WzFdO1xuICAgICAgICAgICAgICAgICAgICB4MiA9IG91dFsyXTtcbiAgICAgICAgICAgICAgICAgICAgcXVhZHJhdGljU3ViZGl2aWRlKFxuICAgICAgICAgICAgICAgICAgICAgICAgeTEsIGNweTEsIHkyLCBwZXJjZW50LCBvdXRcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgY3B5MSA9IG91dFsxXTtcbiAgICAgICAgICAgICAgICAgICAgeTIgPSBvdXRbMl07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY3R4LnF1YWRyYXRpY0N1cnZlVG8oXG4gICAgICAgICAgICAgICAgICAgIGNweDEsIGNweTEsXG4gICAgICAgICAgICAgICAgICAgIHgyLCB5MlxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAocGVyY2VudCA8IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgY3ViaWNTdWJkaXZpZGUoXG4gICAgICAgICAgICAgICAgICAgICAgICB4MSwgY3B4MSwgY3B4MiwgeDIsIHBlcmNlbnQsIG91dFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICBjcHgxID0gb3V0WzFdO1xuICAgICAgICAgICAgICAgICAgICBjcHgyID0gb3V0WzJdO1xuICAgICAgICAgICAgICAgICAgICB4MiA9IG91dFszXTtcbiAgICAgICAgICAgICAgICAgICAgY3ViaWNTdWJkaXZpZGUoXG4gICAgICAgICAgICAgICAgICAgICAgICB5MSwgY3B5MSwgY3B5MiwgeTIsIHBlcmNlbnQsIG91dFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICBjcHkxID0gb3V0WzFdO1xuICAgICAgICAgICAgICAgICAgICBjcHkyID0gb3V0WzJdO1xuICAgICAgICAgICAgICAgICAgICB5MiA9IG91dFszXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3R4LmJlemllckN1cnZlVG8oXG4gICAgICAgICAgICAgICAgICAgIGNweDEsIGNweTEsXG4gICAgICAgICAgICAgICAgICAgIGNweDIsIGNweTIsXG4gICAgICAgICAgICAgICAgICAgIHgyLCB5MlxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCBwb2ludCBhdCBwZXJjZW50XG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gdFxuICAgICAgICAgKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn1cbiAgICAgICAgICovXG4gICAgICAgIHBvaW50QXQ6IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICByZXR1cm4gc29tZVZlY3RvckF0KHRoaXMuc2hhcGUsIHQsIGZhbHNlKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRhbmdlbnQgYXQgcGVyY2VudFxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHRcbiAgICAgICAgICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59XG4gICAgICAgICAqL1xuICAgICAgICB0YW5nZW50QXQ6IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICB2YXIgcCA9IHNvbWVWZWN0b3JBdCh0aGlzLnNoYXBlLCB0LCB0cnVlKTtcbiAgICAgICAgICAgIHJldHVybiB2ZWMyLm5vcm1hbGl6ZShwLCBwKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi96cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL0JlemllckN1cnZlLmpzXG4gKiogbW9kdWxlIGlkID0gNTRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICog5ZyG5bynXG4gKiBAbW9kdWxlIHpyZW5kZXIvZ3JhcGhpYy9zaGFwZS9BcmNcbiAqL1xuIFxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi9QYXRoJykuZXh0ZW5kKHtcblxuICAgICAgICB0eXBlOiAnYXJjJyxcblxuICAgICAgICBzaGFwZToge1xuXG4gICAgICAgICAgICBjeDogMCxcblxuICAgICAgICAgICAgY3k6IDAsXG5cbiAgICAgICAgICAgIHI6IDAsXG5cbiAgICAgICAgICAgIHN0YXJ0QW5nbGU6IDAsXG5cbiAgICAgICAgICAgIGVuZEFuZ2xlOiBNYXRoLlBJICogMixcblxuICAgICAgICAgICAgY2xvY2t3aXNlOiB0cnVlXG4gICAgICAgIH0sXG5cbiAgICAgICAgc3R5bGU6IHtcblxuICAgICAgICAgICAgc3Ryb2tlOiAnIzAwMCcsXG5cbiAgICAgICAgICAgIGZpbGw6IG51bGxcbiAgICAgICAgfSxcblxuICAgICAgICBidWlsZFBhdGg6IGZ1bmN0aW9uIChjdHgsIHNoYXBlKSB7XG5cbiAgICAgICAgICAgIHZhciB4ID0gc2hhcGUuY3g7XG4gICAgICAgICAgICB2YXIgeSA9IHNoYXBlLmN5O1xuICAgICAgICAgICAgdmFyIHIgPSBNYXRoLm1heChzaGFwZS5yLCAwKTtcbiAgICAgICAgICAgIHZhciBzdGFydEFuZ2xlID0gc2hhcGUuc3RhcnRBbmdsZTtcbiAgICAgICAgICAgIHZhciBlbmRBbmdsZSA9IHNoYXBlLmVuZEFuZ2xlO1xuICAgICAgICAgICAgdmFyIGNsb2Nrd2lzZSA9IHNoYXBlLmNsb2Nrd2lzZTtcblxuICAgICAgICAgICAgdmFyIHVuaXRYID0gTWF0aC5jb3Moc3RhcnRBbmdsZSk7XG4gICAgICAgICAgICB2YXIgdW5pdFkgPSBNYXRoLnNpbihzdGFydEFuZ2xlKTtcblxuICAgICAgICAgICAgY3R4Lm1vdmVUbyh1bml0WCAqIHIgKyB4LCB1bml0WSAqIHIgKyB5KTtcbiAgICAgICAgICAgIGN0eC5hcmMoeCwgeSwgciwgc3RhcnRBbmdsZSwgZW5kQW5nbGUsICFjbG9ja3dpc2UpO1xuICAgICAgICB9XG4gICAgfSk7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi96cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL0FyYy5qc1xuICoqIG1vZHVsZSBpZCA9IDU1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cblxuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCcuLi9jb3JlL3V0aWwnKTtcblxuICAgIHZhciBHcmFkaWVudCA9IHJlcXVpcmUoJy4vR3JhZGllbnQnKTtcblxuICAgIC8qKlxuICAgICAqIHgsIHksIHgyLCB5MiBhcmUgYWxsIHBlcmNlbnQgZnJvbSAwIHRvIDFcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3g9MF1cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3k9MF1cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3gyPTFdXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFt5Mj0wXVxuICAgICAqIEBwYXJhbSB7QXJyYXkuPE9iamVjdD59IGNvbG9yU3RvcHNcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtnbG9iYWxDb29yZD1mYWxzZV1cbiAgICAgKi9cbiAgICB2YXIgTGluZWFyR3JhZGllbnQgPSBmdW5jdGlvbiAoeCwgeSwgeDIsIHkyLCBjb2xvclN0b3BzLCBnbG9iYWxDb29yZCkge1xuICAgICAgICB0aGlzLnggPSB4ID09IG51bGwgPyAwIDogeDtcblxuICAgICAgICB0aGlzLnkgPSB5ID09IG51bGwgPyAwIDogeTtcblxuICAgICAgICB0aGlzLngyID0geDIgPT0gbnVsbCA/IDEgOiB4MjtcblxuICAgICAgICB0aGlzLnkyID0geTIgPT0gbnVsbCA/IDAgOiB5MjtcblxuICAgICAgICAvLyBDYW4gYmUgY2xvbmVkXG4gICAgICAgIHRoaXMudHlwZSA9ICdsaW5lYXInO1xuXG4gICAgICAgIC8vIElmIHVzZSBnbG9iYWwgY29vcmRcbiAgICAgICAgdGhpcy5nbG9iYWwgPSBnbG9iYWxDb29yZCB8fCBmYWxzZTtcblxuICAgICAgICBHcmFkaWVudC5jYWxsKHRoaXMsIGNvbG9yU3RvcHMpO1xuICAgIH07XG5cbiAgICBMaW5lYXJHcmFkaWVudC5wcm90b3R5cGUgPSB7XG5cbiAgICAgICAgY29uc3RydWN0b3I6IExpbmVhckdyYWRpZW50XG4gICAgfTtcblxuICAgIHpyVXRpbC5pbmhlcml0cyhMaW5lYXJHcmFkaWVudCwgR3JhZGllbnQpO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBMaW5lYXJHcmFkaWVudDtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvTGluZWFyR3JhZGllbnQuanNcbiAqKiBtb2R1bGUgaWQgPSA1NlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5cbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnLi4vY29yZS91dGlsJyk7XG5cbiAgICB2YXIgR3JhZGllbnQgPSByZXF1aXJlKCcuL0dyYWRpZW50Jyk7XG5cbiAgICAvKipcbiAgICAgKiB4LCB5LCByIGFyZSBhbGwgcGVyY2VudCBmcm9tIDAgdG8gMVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbeD0wLjVdXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFt5PTAuNV1cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3I9MC41XVxuICAgICAqIEBwYXJhbSB7QXJyYXkuPE9iamVjdD59IFtjb2xvclN0b3BzXVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2dsb2JhbENvb3JkPWZhbHNlXVxuICAgICAqL1xuICAgIHZhciBSYWRpYWxHcmFkaWVudCA9IGZ1bmN0aW9uICh4LCB5LCByLCBjb2xvclN0b3BzLCBnbG9iYWxDb29yZCkge1xuICAgICAgICB0aGlzLnggPSB4ID09IG51bGwgPyAwLjUgOiB4O1xuXG4gICAgICAgIHRoaXMueSA9IHkgPT0gbnVsbCA/IDAuNSA6IHk7XG5cbiAgICAgICAgdGhpcy5yID0gciA9PSBudWxsID8gMC41IDogcjtcblxuICAgICAgICAvLyBDYW4gYmUgY2xvbmVkXG4gICAgICAgIHRoaXMudHlwZSA9ICdyYWRpYWwnO1xuXG4gICAgICAgIC8vIElmIHVzZSBnbG9iYWwgY29vcmRcbiAgICAgICAgdGhpcy5nbG9iYWwgPSBnbG9iYWxDb29yZCB8fCBmYWxzZTtcblxuICAgICAgICBHcmFkaWVudC5jYWxsKHRoaXMsIGNvbG9yU3RvcHMpO1xuICAgIH07XG5cbiAgICBSYWRpYWxHcmFkaWVudC5wcm90b3R5cGUgPSB7XG5cbiAgICAgICAgY29uc3RydWN0b3I6IFJhZGlhbEdyYWRpZW50XG4gICAgfTtcblxuICAgIHpyVXRpbC5pbmhlcml0cyhSYWRpYWxHcmFkaWVudCwgR3JhZGllbnQpO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBSYWRpYWxHcmFkaWVudDtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvUmFkaWFsR3JhZGllbnQuanNcbiAqKiBtb2R1bGUgaWQgPSA1N1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXHJcblxyXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xyXG5cclxuICAgIHZhciBhcGlMaXN0ID0gW1xyXG4gICAgICAgICdnZXREb20nLCAnZ2V0WnInLCAnZ2V0V2lkdGgnLCAnZ2V0SGVpZ2h0JywgJ2Rpc3BhdGNoQWN0aW9uJyxcclxuICAgICAgICAnb24nLCAnb2ZmJywgJ3RyaWdnZXInLCAnZ2V0RGF0YVVSTCcsICdnZXRDb25uZWN0ZWREYXRhVVJMJywgJ2dldE1vZGVsJywgJ2dldE9wdGlvbidcclxuICAgIF07XHJcblxyXG4gICAgZnVuY3Rpb24gRXh0ZW5zaW9uQVBJKGluc3RhbmNlKSB7XHJcbiAgICAgICAgenJVdGlsLmVhY2goYXBpTGlzdCwgZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgICAgICAgICAgdGhpc1tuYW1lXSA9IHpyVXRpbC5iaW5kKGluc3RhbmNlW25hbWVdLCBpbnN0YW5jZSk7XHJcbiAgICAgICAgfSwgdGhpcyk7XHJcbiAgICB9XHJcblxyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBFeHRlbnNpb25BUEk7XHJcblxyXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vbGliL2Zpc2gtdG9wby1icG1uL2xpYi9FeHRlbnNpb25BcGkuanNcbiAqKiBtb2R1bGUgaWQgPSA1OFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXHJcblxyXG4gICAgLyoqXHJcbiAgICAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBQb2ludFxyXG4gICAgICAqXHJcbiAgICAgICpcclxuICAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAgKiBAdGhpcyB7UG9pbnR9XHJcbiAgICAgICogQHBhcmFtIHtOdW1iZXJ9IHggVGhlIHggY29vcmRpbmF0ZSBvZiBwb2ludC5cclxuICAgICAgKiBAcGFyYW0ge051bWJlcn0geSBUaGUgeSBjb29yZGluYXRlIG9mIHBvaW50LlxyXG4gICAgICAqIE5vdGU6IEV2ZW4gaWYgaXQgaXMgbmFtZWQgUG9pbnQgdGhpcyBjbGFzcyBzaG91bGQgYmUgbmFtZWQgRG90IGFzIERvdCBpcyBjbG9zZXJcclxuICAgICAgKiB0aGVuIFBvaW50IGZyb20gbWF0aCBwZXJzcGVjdGl2ZS5cclxuICAgICAgKiovXHJcbiAgICBmdW5jdGlvbiBQb2ludCh4LCB5KXtcclxuICAgICAgICAvKipUaGUgeCBjb29yZGluYXRlIG9mIHBvaW50Ki9cclxuICAgICAgICB0aGlzLnggPSB4O1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8qKlRoZSB5IGNvb3JkaW5hdGUgb2YgcG9pbnQqL1xyXG4gICAgICAgIHRoaXMueSA9IHk7XHJcbiAgICAgICAgXHJcblxyXG4gICAgfVxyXG5cclxuICAgIC8qKkNyZWF0ZXMgYSB7UG9pbnR9IG91dCBvZiBKU09OIHBhcnNlZCBvYmplY3RcclxuICAgICAqQHBhcmFtIHtKU09OT2JqZWN0fSBvIC0gdGhlIEpTT04gcGFyc2VkIG9iamVjdFxyXG4gICAgICpAcmV0dXJuIHtQb2ludH0gYSBuZXdseSBjb25zdHJ1Y3RlZCBQb2ludFxyXG4gICAgICoqL1xyXG4gICAgUG9pbnQubG9hZCA9IGZ1bmN0aW9uKG8pe1xyXG4gICAgICAgIHZhciBuZXdQb2ludCA9IG5ldyBQb2ludChOdW1iZXIoby54KSwgTnVtYmVyKG8ueSkpO1xyXG4gICAgICAgIHJldHVybiBuZXdQb2ludDtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qKkNyZWF0ZXMgYW4gYXJyYXkgb2YgcG9pbnRzIGZyb20gYW4gYXJyYXkgb2Yge0pTT05PYmplY3R9c1xyXG4gICAgICpAcGFyYW0ge0FycmF5fSB2IC0gdGhlIGFycmF5IG9mIEpTT05PYmplY3RzXHJcbiAgICAgKkByZXR1cm4gYW4ge0FycmF5fSBvZiB7UG9pbnR9c1xyXG4gICAgICoqL1xyXG4gICAgUG9pbnQubG9hZEFycmF5ID0gZnVuY3Rpb24odil7XHJcbiAgICAgICAgdmFyIG5ld1BvaW50cyA9IFtdO1xyXG4gICAgICAgIGZvcih2YXIgaT0wOyBpPCB2Lmxlbmd0aDsgaSsrKXtcclxuICAgICAgICAgICAgbmV3UG9pbnRzLnB1c2goUG9pbnQubG9hZCh2W2ldKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXdQb2ludHM7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKipDbG9uZXMgYW4gYXJyYXkgb2YgcG9pbnRzXHJcbiAgICAgKkBwYXJhbSB7QXJyYXl9IHYgLSB0aGUgYXJyYXkgb2Yge1BvaW50fXNcclxuICAgICAqQHJldHVybiBhbiB7QXJyYXl9IG9mIHtQb2ludH1zXHJcbiAgICAgKiovXHJcbiAgICBQb2ludC5jbG9uZUFycmF5ID0gZnVuY3Rpb24odil7XHJcbiAgICAgICAgdmFyIG5ld1BvaW50cyA9IFtdO1xyXG4gICAgICAgIGZvcih2YXIgaT0wOyBpPCB2Lmxlbmd0aDsgaSsrKXtcclxuICAgICAgICAgICAgbmV3UG9pbnRzLnB1c2godltpXS5jbG9uZSgpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ld1BvaW50cztcclxuICAgIH07XHJcblxyXG4gICAgUG9pbnQucHJvdG90eXBlID0ge1xyXG4gICAgICAgIGNvbnN0cnVjdG9yIDogUG9pbnQsXHJcbiAgICAgICAgXHJcbiAgICAgICAgdHJhbnNmb3JtOmZ1bmN0aW9uKG1hdHJpeCl7XHJcbiAgICAgICAgICAgIHZhciBvbGRYID0gdGhpcy54O1xyXG4gICAgICAgICAgICB2YXIgb2xkWSA9IHRoaXMueTtcclxuICAgICAgICAgICAgdGhpcy54ID0gbWF0cml4WzBdWzBdICogb2xkWCArIG1hdHJpeFswXVsxXSAqIG9sZFkgKyBtYXRyaXhbMF1bMl07XHJcbiAgICAgICAgICAgIHRoaXMueSA9IG1hdHJpeFsxXVswXSAqIG9sZFggKyBtYXRyaXhbMV1bMV0gKiBvbGRZICsgbWF0cml4WzFdWzJdO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXHJcbiAgICAgICAgLyoqVGVzdHMgaWYgdGhpcyBwb2ludCBpcyBzaW1pbGFyIHRvIG90aGVyIHBvaW50XHJcbiAgICAgICAgICpAcGFyYW0ge1BvaW50fSBhbm90aGVyUG9pbnQgLSB0aGUgb3RoZXIgcG9pbnRcclxuICAgICAgICAgKiovXHJcbiAgICAgICAgZXF1YWxzOmZ1bmN0aW9uKGFub3RoZXJQb2ludCl7XHJcbiAgICAgICAgICAgIGlmKCEgKGFub3RoZXJQb2ludCBpbnN0YW5jZW9mIFBvaW50KSApe1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiAodGhpcy54ID09IGFub3RoZXJQb2ludC54KVxyXG4gICAgICAgICAgICAmJiAodGhpcy55ID09IGFub3RoZXJQb2ludC55KVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKkNsb25lIGN1cnJlbnQgUG9pbnRcclxuICAgICAgICAgKiovXHJcbiAgICAgICAgY2xvbmU6IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgICAgIHZhciBuZXdQb2ludCA9IG5ldyBQb2ludCh0aGlzLngsIHRoaXMueSk7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXdQb2ludDtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipUZXN0cyB0byBzZWUgaWYgYSBwb2ludCAoeCwgeSkgaXMgd2l0aGluIGEgcmFuZ2Ugb2YgY3VycmVudCBQb2ludFxyXG4gICAgICAgICAqQHBhcmFtIHtOdW1lcmljfSB4IC0gdGhlIHggY29vcmRpbmF0ZSBvZiB0ZXN0ZWQgcG9pbnRcclxuICAgICAgICAgKkBwYXJhbSB7TnVtZXJpY30geSAtIHRoZSB4IGNvb3JkaW5hdGUgb2YgdGVzdGVkIHBvaW50XHJcbiAgICAgICAgICpAcGFyYW0ge051bWVyaWN9IHJhZGl1cyAtIHRoZSByYWRpdXMgb2YgdGhlIHZpY2luaXR5XHJcbiAgICAgICAgICoqL1xyXG4gICAgICAgIG5lYXI6ZnVuY3Rpb24oeCwgeSwgcmFkaXVzKXtcclxuICAgICAgICAgICAgdmFyIGRpc3RhbmNlID0gTWF0aC5zcXJ0KE1hdGgucG93KHRoaXMueCAtIHgsIDIpICsgTWF0aC5wb3codGhpcy55IC0geSwgMikpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIChkaXN0YW5jZSA8PSByYWRpdXMpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGNvbnRhaW5zOiBmdW5jdGlvbih4LHkpe1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy54ID09IHggJiYgdGhpcy55ID09IHk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgdG9TdHJpbmc6ZnVuY3Rpb24oKXtcclxuICAgICAgICAgICAgcmV0dXJuICdbJyArIHRoaXMueCArICcsJyArIHRoaXMueSArICddJztcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBnZXRQb2ludHM6ZnVuY3Rpb24oKXtcclxuICAgICAgICAgICAgcmV0dXJuIFt0aGlzXTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBQb2ludDtcclxuICAgIFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9saWIvZmlzaC10b3BvLWNvcmUvbGliL1BvaW50LmpzXG4gKiogbW9kdWxlIGlkID0gNTlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qIVxuICogWlJlbmRlciwgYSBoaWdoIHBlcmZvcm1hbmNlIDJkIGRyYXdpbmcgbGlicmFyeS5cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMsIEJhaWR1IEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTElDRU5TRVxuICogaHR0cHM6Ly9naXRodWIuY29tL2Vjb21mZS96cmVuZGVyL2Jsb2IvbWFzdGVyL0xJQ0VOU0UudHh0XG4gKi9cbi8vIEdsb2JhbCBkZWZpbmVzXG5cbiAgICB2YXIgZ3VpZCA9IHJlcXVpcmUoJy4vY29yZS9ndWlkJyk7XG4gICAgdmFyIGVudiA9IHJlcXVpcmUoJy4vY29yZS9lbnYnKTtcblxuICAgIHZhciBIYW5kbGVyID0gcmVxdWlyZSgnLi9IYW5kbGVyJyk7XG4gICAgdmFyIFN0b3JhZ2UgPSByZXF1aXJlKCcuL1N0b3JhZ2UnKTtcbiAgICB2YXIgQW5pbWF0aW9uID0gcmVxdWlyZSgnLi9hbmltYXRpb24vQW5pbWF0aW9uJyk7XG4gICAgdmFyIEhhbmRsZXJQcm94eSA9IHJlcXVpcmUoJy4vZG9tL0hhbmRsZXJQcm94eScpO1xuXG4gICAgdmFyIHVzZVZNTCA9ICFlbnYuY2FudmFzU3VwcG9ydGVkO1xuXG4gICAgdmFyIHBhaW50ZXJDdG9ycyA9IHtcbiAgICAgICAgY2FudmFzOiByZXF1aXJlKCcuL1BhaW50ZXInKVxuICAgIH07XG5cbiAgICB2YXIgaW5zdGFuY2VzID0ge307ICAgIC8vIFpSZW5kZXLlrp7kvottYXDntKLlvJVcblxuICAgIHZhciB6cmVuZGVyID0ge307XG4gICAgLyoqXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB6cmVuZGVyLnZlcnNpb24gPSAnMy4xLjMnO1xuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6aW5nIGEgenJlbmRlciBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGRvbVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLnJlbmRlcmVyPSdjYW52YXMnXSAnY2FudmFzJyBvciAnc3ZnJ1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0cy5kZXZpY2VQaXhlbFJhdGlvXVxuICAgICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL1pSZW5kZXJ9XG4gICAgICovXG4gICAgenJlbmRlci5pbml0ID0gZnVuY3Rpb24oZG9tLCBvcHRzKSB7XG4gICAgICAgIHZhciB6ciA9IG5ldyBaUmVuZGVyKGd1aWQoKSwgZG9tLCBvcHRzKTtcbiAgICAgICAgaW5zdGFuY2VzW3pyLmlkXSA9IHpyO1xuICAgICAgICByZXR1cm4genI7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIERpc3Bvc2UgenJlbmRlciBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvWlJlbmRlcn0genJcbiAgICAgKi9cbiAgICB6cmVuZGVyLmRpc3Bvc2UgPSBmdW5jdGlvbiAoenIpIHtcbiAgICAgICAgaWYgKHpyKSB7XG4gICAgICAgICAgICB6ci5kaXNwb3NlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gaW5zdGFuY2VzKSB7XG4gICAgICAgICAgICAgICAgaW5zdGFuY2VzW2tleV0uZGlzcG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW5zdGFuY2VzID0ge307XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4genJlbmRlcjtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IHpyZW5kZXIgaW5zdGFuY2UgYnkgaWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgenJlbmRlciBpbnN0YW5jZSBpZFxuICAgICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL1pSZW5kZXJ9XG4gICAgICovXG4gICAgenJlbmRlci5nZXRJbnN0YW5jZSA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICByZXR1cm4gaW5zdGFuY2VzW2lkXTtcbiAgICB9O1xuXG4gICAgenJlbmRlci5yZWdpc3RlclBhaW50ZXIgPSBmdW5jdGlvbiAobmFtZSwgQ3Rvcikge1xuICAgICAgICBwYWludGVyQ3RvcnNbbmFtZV0gPSBDdG9yO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBkZWxJbnN0YW5jZShpZCkge1xuICAgICAgICBkZWxldGUgaW5zdGFuY2VzW2lkXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbW9kdWxlIHpyZW5kZXIvWlJlbmRlclxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBhbGlhcyBtb2R1bGU6enJlbmRlci9aUmVuZGVyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGlkXG4gICAgICogQHBhcmFtIHtIVE1MRG9tRWxlbWVudH0gZG9tXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMucmVuZGVyZXI9J2NhbnZhcyddICdjYW52YXMnIG9yICdzdmcnXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRzLmRldmljZVBpeGVsUmF0aW9dXG4gICAgICovXG4gICAgdmFyIFpSZW5kZXIgPSBmdW5jdGlvbihpZCwgZG9tLCBvcHRzKSB7XG5cbiAgICAgICAgb3B0cyA9IG9wdHMgfHwge307XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtIVE1MRG9tRWxlbWVudH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZG9tID0gZG9tO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pZCA9IGlkO1xuXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIHN0b3JhZ2UgPSBuZXcgU3RvcmFnZSgpO1xuXG4gICAgICAgIHZhciByZW5kZXJlclR5cGUgPSBvcHRzLnJlbmRlcmVyO1xuICAgICAgICBpZiAodXNlVk1MKSB7XG4gICAgICAgICAgICBpZiAoIXBhaW50ZXJDdG9ycy52bWwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBuZWVkIHRvIHJlcXVpcmUgXFwnenJlbmRlci92bWwvdm1sXFwnIHRvIHN1cHBvcnQgSUU4Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZW5kZXJlclR5cGUgPSAndm1sJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghcmVuZGVyZXJUeXBlIHx8ICFwYWludGVyQ3RvcnNbcmVuZGVyZXJUeXBlXSkge1xuICAgICAgICAgICAgcmVuZGVyZXJUeXBlID0gJ2NhbnZhcyc7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBhaW50ZXIgPSBuZXcgcGFpbnRlckN0b3JzW3JlbmRlcmVyVHlwZV0oZG9tLCBzdG9yYWdlLCBvcHRzKTtcblxuICAgICAgICB0aGlzLnN0b3JhZ2UgPSBzdG9yYWdlO1xuICAgICAgICB0aGlzLnBhaW50ZXIgPSBwYWludGVyO1xuXG4gICAgICAgIHZhciBoYW5kZXJQcm94eSA9ICFlbnYubm9kZSA/IG5ldyBIYW5kbGVyUHJveHkocGFpbnRlci5nZXRWaWV3cG9ydFJvb3QoKSkgOiBudWxsO1xuICAgICAgICB0aGlzLmhhbmRsZXIgPSBuZXcgSGFuZGxlcihzdG9yYWdlLCBwYWludGVyLCBoYW5kZXJQcm94eSk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHttb2R1bGU6enJlbmRlci9hbmltYXRpb24vQW5pbWF0aW9ufVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5hbmltYXRpb24gPSBuZXcgQW5pbWF0aW9uKHtcbiAgICAgICAgICAgIHN0YWdlOiB7XG4gICAgICAgICAgICAgICAgdXBkYXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLl9uZWVkc1JlZnJlc2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYucmVmcmVzaEltbWVkaWF0ZWx5KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuX25lZWRzUmVmcmVzaEhvdmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnJlZnJlc2hIb3ZlckltbWVkaWF0ZWx5KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmFuaW1hdGlvbi5zdGFydCgpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX25lZWRzUmVmcmVzaDtcblxuICAgICAgICAvLyDkv67mlLkgc3RvcmFnZS5kZWxGcm9tTWFwLCDmr4/mrKHliKDpmaTlhYPntKDkuYvliY3liKDpmaTliqjnlLtcbiAgICAgICAgLy8gRklYTUUg5pyJ54K5dWdseVxuICAgICAgICB2YXIgb2xkRGVsRnJvbU1hcCA9IHN0b3JhZ2UuZGVsRnJvbU1hcDtcbiAgICAgICAgdmFyIG9sZEFkZFRvTWFwID0gc3RvcmFnZS5hZGRUb01hcDtcblxuICAgICAgICBzdG9yYWdlLmRlbEZyb21NYXAgPSBmdW5jdGlvbiAoZWxJZCkge1xuICAgICAgICAgICAgdmFyIGVsID0gc3RvcmFnZS5nZXQoZWxJZCk7XG5cbiAgICAgICAgICAgIG9sZERlbEZyb21NYXAuY2FsbChzdG9yYWdlLCBlbElkKTtcblxuICAgICAgICAgICAgZWwgJiYgZWwucmVtb3ZlU2VsZkZyb21acihzZWxmKTtcbiAgICAgICAgfTtcblxuICAgICAgICBzdG9yYWdlLmFkZFRvTWFwID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICBvbGRBZGRUb01hcC5jYWxsKHN0b3JhZ2UsIGVsKTtcblxuICAgICAgICAgICAgZWwuYWRkU2VsZlRvWnIoc2VsZik7XG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIFpSZW5kZXIucHJvdG90eXBlID0ge1xuXG4gICAgICAgIGNvbnN0cnVjdG9yOiBaUmVuZGVyLFxuICAgICAgICAvKipcbiAgICAgICAgICog6I635Y+W5a6e5L6L5ZSv5LiA5qCH6K+GXG4gICAgICAgICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIGdldElkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pZDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5re75Yqg5YWD57SgXG4gICAgICAgICAqIEBwYXJhbSAge21vZHVsZTp6cmVuZGVyL0VsZW1lbnR9IGVsXG4gICAgICAgICAqL1xuICAgICAgICBhZGQ6IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgdGhpcy5zdG9yYWdlLmFkZFJvb3QoZWwpO1xuICAgICAgICAgICAgdGhpcy5fbmVlZHNSZWZyZXNoID0gdHJ1ZTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5Yig6Zmk5YWD57SgXG4gICAgICAgICAqIEBwYXJhbSAge21vZHVsZTp6cmVuZGVyL0VsZW1lbnR9IGVsXG4gICAgICAgICAqL1xuICAgICAgICByZW1vdmU6IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgdGhpcy5zdG9yYWdlLmRlbFJvb3QoZWwpO1xuICAgICAgICAgICAgdGhpcy5fbmVlZHNSZWZyZXNoID0gdHJ1ZTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2hhbmdlIGNvbmZpZ3VyYXRpb24gb2YgbGF5ZXJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHpMZXZlbFxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY29uZmlnLmNsZWFyQ29sb3I9MF0gQ2xlYXIgY29sb3JcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtjb25maWcubW90aW9uQmx1cj1mYWxzZV0gSWYgZW5hYmxlIG1vdGlvbiBibHVyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbY29uZmlnLmxhc3RGcmFtZUFscGhhPTAuN10gTW90aW9uIGJsdXIgZmFjdG9yLiBMYXJnZXIgdmFsdWUgY2F1c2UgbG9uZ2VyIHRyYWlsZXJcbiAgICAgICAgKi9cbiAgICAgICAgY29uZmlnTGF5ZXI6IGZ1bmN0aW9uICh6TGV2ZWwsIGNvbmZpZykge1xuICAgICAgICAgICAgdGhpcy5wYWludGVyLmNvbmZpZ0xheWVyKHpMZXZlbCwgY29uZmlnKTtcbiAgICAgICAgICAgIHRoaXMuX25lZWRzUmVmcmVzaCA9IHRydWU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlcGFpbnQgdGhlIGNhbnZhcyBpbW1lZGlhdGVseVxuICAgICAgICAgKi9cbiAgICAgICAgcmVmcmVzaEltbWVkaWF0ZWx5OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBDbGVhciBuZWVkc1JlZnJlc2ggYWhlYWQgdG8gYXZvaWQgc29tZXRoaW5nIHdyb25nIGhhcHBlbnMgaW4gcmVmcmVzaFxuICAgICAgICAgICAgLy8gT3IgaXQgd2lsbCBjYXVzZSB6cmVuZGVyIHJlZnJlc2hlcyBhZ2FpbiBhbmQgYWdhaW4uXG4gICAgICAgICAgICB0aGlzLl9uZWVkc1JlZnJlc2ggPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMucGFpbnRlci5yZWZyZXNoKCk7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEF2b2lkIHRyaWdnZXIgenIucmVmcmVzaCBpbiBFbGVtZW50I2JlZm9yZVVwZGF0ZSBob29rXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuX25lZWRzUmVmcmVzaCA9IGZhbHNlO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNYXJrIGFuZCByZXBhaW50IHRoZSBjYW52YXMgaW4gdGhlIG5leHQgZnJhbWUgb2YgYnJvd3NlclxuICAgICAgICAgKi9cbiAgICAgICAgcmVmcmVzaDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLl9uZWVkc1JlZnJlc2ggPSB0cnVlO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBZGQgZWxlbWVudCB0byBob3ZlciBsYXllclxuICAgICAgICAgKiBAcGFyYW0gIHttb2R1bGU6enJlbmRlci9FbGVtZW50fSBlbFxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gc3R5bGVcbiAgICAgICAgICovXG4gICAgICAgIGFkZEhvdmVyOiBmdW5jdGlvbiAoZWwsIHN0eWxlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wYWludGVyLmFkZEhvdmVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wYWludGVyLmFkZEhvdmVyKGVsLCBzdHlsZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWZyZXNoSG92ZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQWRkIGVsZW1lbnQgZnJvbSBob3ZlciBsYXllclxuICAgICAgICAgKiBAcGFyYW0gIHttb2R1bGU6enJlbmRlci9FbGVtZW50fSBlbFxuICAgICAgICAgKi9cbiAgICAgICAgcmVtb3ZlSG92ZXI6IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucGFpbnRlci5yZW1vdmVIb3Zlcikge1xuICAgICAgICAgICAgICAgIHRoaXMucGFpbnRlci5yZW1vdmVIb3ZlcihlbCk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWZyZXNoSG92ZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2xlYXIgYWxsIGhvdmVyIGVsZW1lbnRzIGluIGhvdmVyIGxheWVyXG4gICAgICAgICAqIEBwYXJhbSAge21vZHVsZTp6cmVuZGVyL0VsZW1lbnR9IGVsXG4gICAgICAgICAqL1xuICAgICAgICBjbGVhckhvdmVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wYWludGVyLmNsZWFySG92ZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBhaW50ZXIuY2xlYXJIb3ZlcigpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVmcmVzaEhvdmVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlZnJlc2ggaG92ZXIgaW4gbmV4dCBmcmFtZVxuICAgICAgICAgKi9cbiAgICAgICAgcmVmcmVzaEhvdmVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl9uZWVkc1JlZnJlc2hIb3ZlciA9IHRydWU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlZnJlc2ggaG92ZXIgaW1tZWRpYXRlbHlcbiAgICAgICAgICovXG4gICAgICAgIHJlZnJlc2hIb3ZlckltbWVkaWF0ZWx5OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl9uZWVkc1JlZnJlc2hIb3ZlciA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5wYWludGVyLnJlZnJlc2hIb3ZlciAmJiB0aGlzLnBhaW50ZXIucmVmcmVzaEhvdmVyKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlc2l6ZSB0aGUgY2FudmFzLlxuICAgICAgICAgKiBTaG91bGQgYmUgaW52b2tlZCB3aGVuIGNvbnRhaW5lciBzaXplIGlzIGNoYW5nZWRcbiAgICAgICAgICovXG4gICAgICAgIHJlc2l6ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLnBhaW50ZXIucmVzaXplKCk7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZXIucmVzaXplKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFN0b3AgYW5kIGNsZWFyIGFsbCBhbmltYXRpb24gaW1tZWRpYXRlbHlcbiAgICAgICAgICovXG4gICAgICAgIGNsZWFyQW5pbWF0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLmFuaW1hdGlvbi5jbGVhcigpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgY29udGFpbmVyIHdpZHRoXG4gICAgICAgICAqL1xuICAgICAgICBnZXRXaWR0aDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYWludGVyLmdldFdpZHRoKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCBjb250YWluZXIgaGVpZ2h0XG4gICAgICAgICAqL1xuICAgICAgICBnZXRIZWlnaHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFpbnRlci5nZXRIZWlnaHQoKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogRXhwb3J0IHRoZSBjYW52YXMgYXMgQmFzZTY0IFVSTFxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2JhY2tncm91bmRDb2xvcj0nI2ZmZiddXG4gICAgICAgICAqIEByZXR1cm4ge3N0cmluZ30gQmFzZTY0IFVSTFxuICAgICAgICAgKi9cbiAgICAgICAgLy8gdG9EYXRhVVJMOiBmdW5jdGlvbih0eXBlLCBiYWNrZ3JvdW5kQ29sb3IpIHtcbiAgICAgICAgLy8gICAgIHJldHVybiB0aGlzLnBhaW50ZXIuZ2V0UmVuZGVyZWRDYW52YXMoe1xuICAgICAgICAvLyAgICAgICAgIGJhY2tncm91bmRDb2xvcjogYmFja2dyb3VuZENvbG9yXG4gICAgICAgIC8vICAgICB9KS50b0RhdGFVUkwodHlwZSk7XG4gICAgICAgIC8vIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnZlcnRpbmcgYSBwYXRoIHRvIGltYWdlLlxuICAgICAgICAgKiBJdCBoYXMgbXVjaCBiZXR0ZXIgcGVyZm9ybWFuY2Ugb2YgZHJhd2luZyBpbWFnZSByYXRoZXIgdGhhbiBkcmF3aW5nIGEgdmVjdG9yIHBhdGguXG4gICAgICAgICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvZ3JhcGhpYy9QYXRofSBlXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aFxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0XG4gICAgICAgICAqL1xuICAgICAgICBwYXRoVG9JbWFnZTogZnVuY3Rpb24oZSwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgICAgICAgdmFyIGlkID0gZ3VpZCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFpbnRlci5wYXRoVG9JbWFnZShpZCwgZSwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldCBkZWZhdWx0IGN1cnNvclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2N1cnNvclN0eWxlPSdkZWZhdWx0J10g5L6L5aaCIGNyb3NzaGFpclxuICAgICAgICAgKi9cbiAgICAgICAgc2V0Q3Vyc29yU3R5bGU6IGZ1bmN0aW9uIChjdXJzb3JTdHlsZSkge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVyLnNldEN1cnNvclN0eWxlKGN1cnNvclN0eWxlKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQmluZCBldmVudFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lIEV2ZW50IG5hbWVcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXZlbnRIYW5kbGVyIEhhbmRsZXIgZnVuY3Rpb25cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IFtjb250ZXh0XSBDb250ZXh0IG9iamVjdFxuICAgICAgICAgKi9cbiAgICAgICAgb246IGZ1bmN0aW9uKGV2ZW50TmFtZSwgZXZlbnRIYW5kbGVyLCBjb250ZXh0KSB7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZXIub24oZXZlbnROYW1lLCBldmVudEhhbmRsZXIsIGNvbnRleHQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVbmJpbmQgZXZlbnRcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSBFdmVudCBuYW1lXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtldmVudEhhbmRsZXJdIEhhbmRsZXIgZnVuY3Rpb25cbiAgICAgICAgICovXG4gICAgICAgIG9mZjogZnVuY3Rpb24oZXZlbnROYW1lLCBldmVudEhhbmRsZXIpIHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlci5vZmYoZXZlbnROYW1lLCBldmVudEhhbmRsZXIpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUcmlnZ2VyIGV2ZW50IG1hbnVhbGx5XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUgRXZlbnQgbmFtZVxuICAgICAgICAgKiBAcGFyYW0ge2V2ZW50PX0gZXZlbnQgRXZlbnQgb2JqZWN0XG4gICAgICAgICAqL1xuICAgICAgICB0cmlnZ2VyOiBmdW5jdGlvbiAoZXZlbnROYW1lLCBldmVudCkge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVyLnRyaWdnZXIoZXZlbnROYW1lLCBldmVudCk7XG4gICAgICAgIH0sXG5cblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2xlYXIgYWxsIG9iamVjdHMgYW5kIHRoZSBjYW52YXMuXG4gICAgICAgICAqL1xuICAgICAgICBjbGVhcjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5zdG9yYWdlLmRlbFJvb3QoKTtcbiAgICAgICAgICAgIHRoaXMucGFpbnRlci5jbGVhcigpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEaXNwb3NlIHNlbGYuXG4gICAgICAgICAqL1xuICAgICAgICBkaXNwb3NlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLmFuaW1hdGlvbi5zdG9wKCk7XG5cbiAgICAgICAgICAgIHRoaXMuY2xlYXIoKTtcbiAgICAgICAgICAgIHRoaXMuc3RvcmFnZS5kaXNwb3NlKCk7XG4gICAgICAgICAgICB0aGlzLnBhaW50ZXIuZGlzcG9zZSgpO1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVyLmRpc3Bvc2UoKTtcblxuICAgICAgICAgICAgdGhpcy5hbmltYXRpb24gPVxuICAgICAgICAgICAgdGhpcy5zdG9yYWdlID1cbiAgICAgICAgICAgIHRoaXMucGFpbnRlciA9XG4gICAgICAgICAgICB0aGlzLmhhbmRsZXIgPSBudWxsO1xuXG4gICAgICAgICAgICBkZWxJbnN0YW5jZSh0aGlzLmlkKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHpyZW5kZXI7XG5cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3pyZW5kZXIvbGliL3pyZW5kZXIuanNcbiAqKiBtb2R1bGUgaWQgPSA2MFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBlY2hhcnRz6K6+5aSH546v5aKD6K+G5YirXG4gKlxuICogQGRlc2MgZWNoYXJ0c+WfuuS6jkNhbnZhc++8jOe6r0phdmFzY3JpcHTlm77ooajlupPvvIzmj5Dkvpvnm7Top4LvvIznlJ/liqjvvIzlj6/kuqTkupLvvIzlj6/kuKrmgKfljJblrprliLbnmoTmlbDmja7nu5/orqHlm77ooajjgIJcbiAqIEBhdXRob3IgZmlyZWRlW2ZpcmVkZUBmaXJlZGUudXNdXG4gKiBAZGVzYyB0aGFua3MgemVwdG8uXG4gKi9cblxuICAgIHZhciBlbnYgPSB7fTtcbiAgICBpZiAodHlwZW9mIG5hdmlnYXRvciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgLy8gSW4gbm9kZVxuICAgICAgICBlbnYgPSB7XG4gICAgICAgICAgICBicm93c2VyOiB7fSxcbiAgICAgICAgICAgIG9zOiB7fSxcbiAgICAgICAgICAgIG5vZGU6IHRydWUsXG4gICAgICAgICAgICAvLyBBc3N1bWUgY2FudmFzIGlzIHN1cHBvcnRlZFxuICAgICAgICAgICAgY2FudmFzU3VwcG9ydGVkOiB0cnVlXG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBlbnYgPSBkZXRlY3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBlbnY7XG5cbiAgICAvLyBaZXB0by5qc1xuICAgIC8vIChjKSAyMDEwLTIwMTMgVGhvbWFzIEZ1Y2hzXG4gICAgLy8gWmVwdG8uanMgbWF5IGJlIGZyZWVseSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG5cbiAgICBmdW5jdGlvbiBkZXRlY3QodWEpIHtcbiAgICAgICAgdmFyIG9zID0ge307XG4gICAgICAgIHZhciBicm93c2VyID0ge307XG4gICAgICAgIC8vIHZhciB3ZWJraXQgPSB1YS5tYXRjaCgvV2ViW2tLXWl0W1xcL117MCwxfShbXFxkLl0rKS8pO1xuICAgICAgICAvLyB2YXIgYW5kcm9pZCA9IHVhLm1hdGNoKC8oQW5kcm9pZCk7P1tcXHNcXC9dKyhbXFxkLl0rKT8vKTtcbiAgICAgICAgLy8gdmFyIGlwYWQgPSB1YS5tYXRjaCgvKGlQYWQpLipPU1xccyhbXFxkX10rKS8pO1xuICAgICAgICAvLyB2YXIgaXBvZCA9IHVhLm1hdGNoKC8oaVBvZCkoLipPU1xccyhbXFxkX10rKSk/Lyk7XG4gICAgICAgIC8vIHZhciBpcGhvbmUgPSAhaXBhZCAmJiB1YS5tYXRjaCgvKGlQaG9uZVxcc09TKVxccyhbXFxkX10rKS8pO1xuICAgICAgICAvLyB2YXIgd2Vib3MgPSB1YS5tYXRjaCgvKHdlYk9TfGhwd09TKVtcXHNcXC9dKFtcXGQuXSspLyk7XG4gICAgICAgIC8vIHZhciB0b3VjaHBhZCA9IHdlYm9zICYmIHVhLm1hdGNoKC9Ub3VjaFBhZC8pO1xuICAgICAgICAvLyB2YXIga2luZGxlID0gdWEubWF0Y2goL0tpbmRsZVxcLyhbXFxkLl0rKS8pO1xuICAgICAgICAvLyB2YXIgc2lsayA9IHVhLm1hdGNoKC9TaWxrXFwvKFtcXGQuX10rKS8pO1xuICAgICAgICAvLyB2YXIgYmxhY2tiZXJyeSA9IHVhLm1hdGNoKC8oQmxhY2tCZXJyeSkuKlZlcnNpb25cXC8oW1xcZC5dKykvKTtcbiAgICAgICAgLy8gdmFyIGJiMTAgPSB1YS5tYXRjaCgvKEJCMTApLipWZXJzaW9uXFwvKFtcXGQuXSspLyk7XG4gICAgICAgIC8vIHZhciByaW10YWJsZXRvcyA9IHVhLm1hdGNoKC8oUklNXFxzVGFibGV0XFxzT1MpXFxzKFtcXGQuXSspLyk7XG4gICAgICAgIC8vIHZhciBwbGF5Ym9vayA9IHVhLm1hdGNoKC9QbGF5Qm9vay8pO1xuICAgICAgICAvLyB2YXIgY2hyb21lID0gdWEubWF0Y2goL0Nocm9tZVxcLyhbXFxkLl0rKS8pIHx8IHVhLm1hdGNoKC9DcmlPU1xcLyhbXFxkLl0rKS8pO1xuICAgICAgICB2YXIgZmlyZWZveCA9IHVhLm1hdGNoKC9GaXJlZm94XFwvKFtcXGQuXSspLyk7XG4gICAgICAgIC8vIHZhciBzYWZhcmkgPSB3ZWJraXQgJiYgdWEubWF0Y2goL01vYmlsZVxcLy8pICYmICFjaHJvbWU7XG4gICAgICAgIC8vIHZhciB3ZWJ2aWV3ID0gdWEubWF0Y2goLyhpUGhvbmV8aVBvZHxpUGFkKS4qQXBwbGVXZWJLaXQoPyEuKlNhZmFyaSkvKSAmJiAhY2hyb21lO1xuICAgICAgICB2YXIgaWUgPSB1YS5tYXRjaCgvTVNJRVxccyhbXFxkLl0rKS8pXG4gICAgICAgICAgICAvLyBJRSAxMSBUcmlkZW50LzcuMDsgcnY6MTEuMFxuICAgICAgICAgICAgfHwgdWEubWF0Y2goL1RyaWRlbnRcXC8uKz9ydjooKFtcXGQuXSspKS8pO1xuICAgICAgICB2YXIgZWRnZSA9IHVhLm1hdGNoKC9FZGdlXFwvKFtcXGQuXSspLyk7IC8vIElFIDEyIGFuZCAxMitcblxuICAgICAgICAvLyBUb2RvOiBjbGVhbiB0aGlzIHVwIHdpdGggYSBiZXR0ZXIgT1MvYnJvd3NlciBzZXBlcmF0aW9uOlxuICAgICAgICAvLyAtIGRpc2Nlcm4gKG1vcmUpIGJldHdlZW4gbXVsdGlwbGUgYnJvd3NlcnMgb24gYW5kcm9pZFxuICAgICAgICAvLyAtIGRlY2lkZSBpZiBraW5kbGUgZmlyZSBpbiBzaWxrIG1vZGUgaXMgYW5kcm9pZCBvciBub3RcbiAgICAgICAgLy8gLSBGaXJlZm94IG9uIEFuZHJvaWQgZG9lc24ndCBzcGVjaWZ5IHRoZSBBbmRyb2lkIHZlcnNpb25cbiAgICAgICAgLy8gLSBwb3NzaWJseSBkZXZpZGUgaW4gb3MsIGRldmljZSBhbmQgYnJvd3NlciBoYXNoZXNcblxuICAgICAgICAvLyBpZiAoYnJvd3Nlci53ZWJraXQgPSAhIXdlYmtpdCkgYnJvd3Nlci52ZXJzaW9uID0gd2Via2l0WzFdO1xuXG4gICAgICAgIC8vIGlmIChhbmRyb2lkKSBvcy5hbmRyb2lkID0gdHJ1ZSwgb3MudmVyc2lvbiA9IGFuZHJvaWRbMl07XG4gICAgICAgIC8vIGlmIChpcGhvbmUgJiYgIWlwb2QpIG9zLmlvcyA9IG9zLmlwaG9uZSA9IHRydWUsIG9zLnZlcnNpb24gPSBpcGhvbmVbMl0ucmVwbGFjZSgvXy9nLCAnLicpO1xuICAgICAgICAvLyBpZiAoaXBhZCkgb3MuaW9zID0gb3MuaXBhZCA9IHRydWUsIG9zLnZlcnNpb24gPSBpcGFkWzJdLnJlcGxhY2UoL18vZywgJy4nKTtcbiAgICAgICAgLy8gaWYgKGlwb2QpIG9zLmlvcyA9IG9zLmlwb2QgPSB0cnVlLCBvcy52ZXJzaW9uID0gaXBvZFszXSA/IGlwb2RbM10ucmVwbGFjZSgvXy9nLCAnLicpIDogbnVsbDtcbiAgICAgICAgLy8gaWYgKHdlYm9zKSBvcy53ZWJvcyA9IHRydWUsIG9zLnZlcnNpb24gPSB3ZWJvc1syXTtcbiAgICAgICAgLy8gaWYgKHRvdWNocGFkKSBvcy50b3VjaHBhZCA9IHRydWU7XG4gICAgICAgIC8vIGlmIChibGFja2JlcnJ5KSBvcy5ibGFja2JlcnJ5ID0gdHJ1ZSwgb3MudmVyc2lvbiA9IGJsYWNrYmVycnlbMl07XG4gICAgICAgIC8vIGlmIChiYjEwKSBvcy5iYjEwID0gdHJ1ZSwgb3MudmVyc2lvbiA9IGJiMTBbMl07XG4gICAgICAgIC8vIGlmIChyaW10YWJsZXRvcykgb3MucmltdGFibGV0b3MgPSB0cnVlLCBvcy52ZXJzaW9uID0gcmltdGFibGV0b3NbMl07XG4gICAgICAgIC8vIGlmIChwbGF5Ym9vaykgYnJvd3Nlci5wbGF5Ym9vayA9IHRydWU7XG4gICAgICAgIC8vIGlmIChraW5kbGUpIG9zLmtpbmRsZSA9IHRydWUsIG9zLnZlcnNpb24gPSBraW5kbGVbMV07XG4gICAgICAgIC8vIGlmIChzaWxrKSBicm93c2VyLnNpbGsgPSB0cnVlLCBicm93c2VyLnZlcnNpb24gPSBzaWxrWzFdO1xuICAgICAgICAvLyBpZiAoIXNpbGsgJiYgb3MuYW5kcm9pZCAmJiB1YS5tYXRjaCgvS2luZGxlIEZpcmUvKSkgYnJvd3Nlci5zaWxrID0gdHJ1ZTtcbiAgICAgICAgLy8gaWYgKGNocm9tZSkgYnJvd3Nlci5jaHJvbWUgPSB0cnVlLCBicm93c2VyLnZlcnNpb24gPSBjaHJvbWVbMV07XG4gICAgICAgIGlmIChmaXJlZm94KSBicm93c2VyLmZpcmVmb3ggPSB0cnVlLCBicm93c2VyLnZlcnNpb24gPSBmaXJlZm94WzFdO1xuICAgICAgICAvLyBpZiAoc2FmYXJpICYmICh1YS5tYXRjaCgvU2FmYXJpLykgfHwgISFvcy5pb3MpKSBicm93c2VyLnNhZmFyaSA9IHRydWU7XG4gICAgICAgIC8vIGlmICh3ZWJ2aWV3KSBicm93c2VyLndlYnZpZXcgPSB0cnVlO1xuICAgICAgICBpZiAoaWUpIHtcbiAgICAgICAgICAgIGJyb3dzZXIuaWUgPSB0cnVlOyBicm93c2VyLnZlcnNpb24gPSBpZVsxXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaWUpIHtcbiAgICAgICAgICAgIGJyb3dzZXIuaWUgPSB0cnVlO1xuICAgICAgICAgICAgYnJvd3Nlci52ZXJzaW9uID0gaWVbMV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVkZ2UpIHtcbiAgICAgICAgICAgIGJyb3dzZXIuZWRnZSA9IHRydWU7XG4gICAgICAgICAgICBicm93c2VyLnZlcnNpb24gPSBlZGdlWzFdO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gb3MudGFibGV0ID0gISEoaXBhZCB8fCBwbGF5Ym9vayB8fCAoYW5kcm9pZCAmJiAhdWEubWF0Y2goL01vYmlsZS8pKSB8fFxuICAgICAgICAvLyAgICAgKGZpcmVmb3ggJiYgdWEubWF0Y2goL1RhYmxldC8pKSB8fCAoaWUgJiYgIXVhLm1hdGNoKC9QaG9uZS8pICYmIHVhLm1hdGNoKC9Ub3VjaC8pKSk7XG4gICAgICAgIC8vIG9zLnBob25lICA9ICEhKCFvcy50YWJsZXQgJiYgIW9zLmlwb2QgJiYgKGFuZHJvaWQgfHwgaXBob25lIHx8IHdlYm9zIHx8XG4gICAgICAgIC8vICAgICAoY2hyb21lICYmIHVhLm1hdGNoKC9BbmRyb2lkLykpIHx8IChjaHJvbWUgJiYgdWEubWF0Y2goL0NyaU9TXFwvKFtcXGQuXSspLykpIHx8XG4gICAgICAgIC8vICAgICAoZmlyZWZveCAmJiB1YS5tYXRjaCgvTW9iaWxlLykpIHx8IChpZSAmJiB1YS5tYXRjaCgvVG91Y2gvKSkpKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYnJvd3NlcjogYnJvd3NlcixcbiAgICAgICAgICAgIG9zOiBvcyxcbiAgICAgICAgICAgIG5vZGU6IGZhbHNlLFxuICAgICAgICAgICAgLy8g5Y6f55SfY2FudmFz5pSv5oyB77yM5pS55p6B56uv54K55LqGXG4gICAgICAgICAgICAvLyBjYW52YXNTdXBwb3J0ZWQgOiAhKGJyb3dzZXIuaWUgJiYgcGFyc2VGbG9hdChicm93c2VyLnZlcnNpb24pIDwgOSlcbiAgICAgICAgICAgIGNhbnZhc1N1cHBvcnRlZCA6IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpLmdldENvbnRleHQgPyB0cnVlIDogZmFsc2UsXG4gICAgICAgICAgICAvLyBAc2VlIDxodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzQ4MTcwMjkvd2hhdHMtdGhlLWJlc3Qtd2F5LXRvLWRldGVjdC1hLXRvdWNoLXNjcmVlbi1kZXZpY2UtdXNpbmctamF2YXNjcmlwdD5cbiAgICAgICAgICAgIC8vIHdvcmtzIG9uIG1vc3QgYnJvd3NlcnNcbiAgICAgICAgICAgIC8vIElFMTAvMTEgZG9lcyBub3Qgc3VwcG9ydCB0b3VjaCBldmVudCwgYW5kIE1TIEVkZ2Ugc3VwcG9ydHMgdGhlbSBidXQgbm90IGJ5XG4gICAgICAgICAgICAvLyBkZWZhdWx0LCBzbyB3ZSBkb250IGNoZWNrIG5hdmlnYXRvci5tYXhUb3VjaFBvaW50cyBmb3IgdGhlbSBoZXJlLlxuICAgICAgICAgICAgdG91Y2hFdmVudHNTdXBwb3J0ZWQ6ICdvbnRvdWNoc3RhcnQnIGluIHdpbmRvdyAmJiAhYnJvd3Nlci5pZSAmJiAhYnJvd3Nlci5lZGdlLFxuICAgICAgICAgICAgLy8gPGh0dHA6Ly9jYW5pdXNlLmNvbS8jc2VhcmNoPXBvaW50ZXIlMjBldmVudD4uXG4gICAgICAgICAgICBwb2ludGVyRXZlbnRzU3VwcG9ydGVkOiAnb25wb2ludGVyZG93bicgaW4gd2luZG93XG4gICAgICAgICAgICAgICAgLy8gRmlyZWZveCBzdXBwb3J0cyBwb2ludGVyIGJ1dCBub3QgYnkgZGVmYXVsdCxcbiAgICAgICAgICAgICAgICAvLyBvbmx5IE1TIGJyb3dzZXJzIGFyZSByZWxpYWJsZSBvbiBwb2ludGVyIGV2ZW50cyBjdXJyZW50bHkuXG4gICAgICAgICAgICAgICAgJiYgKGJyb3dzZXIuZWRnZSB8fCAoYnJvd3Nlci5pZSAmJiBicm93c2VyLnZlcnNpb24gPj0gMTApKVxuICAgICAgICB9O1xuICAgIH1cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3pyZW5kZXIvbGliL2NvcmUvZW52LmpzXG4gKiogbW9kdWxlIGlkID0gNjFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0Jztcbi8qKlxuICogSGFuZGxlclxuICogQG1vZHVsZSB6cmVuZGVyL0hhbmRsZXJcbiAqIEBhdXRob3IgS2VuZXIgKEBLZW5lci3mnpfls7AsIGtlbmVyLmxpbmZlbmdAZ21haWwuY29tKVxuICogICAgICAgICBlcnJvcnJpayAoZXJyb3JyaWtAZ21haWwuY29tKVxuICogICAgICAgICBwaXNzYW5nIChzaGVueWkuOTE0QGdtYWlsLmNvbSlcbiAqL1xuXG5cbiAgICB2YXIgdXRpbCA9IHJlcXVpcmUoJy4vY29yZS91dGlsJyk7XG4gICAgdmFyIERyYWdnYWJsZSA9IHJlcXVpcmUoJy4vbWl4aW4vRHJhZ2dhYmxlJyk7XG5cbiAgICB2YXIgRXZlbnRmdWwgPSByZXF1aXJlKCcuL21peGluL0V2ZW50ZnVsJyk7XG5cbiAgICBmdW5jdGlvbiBtYWtlRXZlbnRQYWNrZXQoZXZlVHlwZSwgdGFyZ2V0LCBldmVudCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogZXZlVHlwZSxcbiAgICAgICAgICAgIGV2ZW50OiBldmVudCxcbiAgICAgICAgICAgIHRhcmdldDogdGFyZ2V0LFxuICAgICAgICAgICAgY2FuY2VsQnViYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIG9mZnNldFg6IGV2ZW50LnpyWCxcbiAgICAgICAgICAgIG9mZnNldFk6IGV2ZW50LnpyWSxcbiAgICAgICAgICAgIGdlc3R1cmVFdmVudDogZXZlbnQuZ2VzdHVyZUV2ZW50LFxuICAgICAgICAgICAgcGluY2hYOiBldmVudC5waW5jaFgsXG4gICAgICAgICAgICBwaW5jaFk6IGV2ZW50LnBpbmNoWSxcbiAgICAgICAgICAgIHBpbmNoU2NhbGU6IGV2ZW50LnBpbmNoU2NhbGUsXG4gICAgICAgICAgICB3aGVlbERlbHRhOiBldmVudC56ckRlbHRhXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gRW1wdHlQcm94eSAoKSB7fVxuICAgIEVtcHR5UHJveHkucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7fTtcblxuICAgIHZhciBoYW5kbGVyTmFtZXMgPSBbXG4gICAgICAgICdjbGljaycsICdkYmxjbGljaycsICdtb3VzZXdoZWVsJywgJ21vdXNlb3V0JyxcbiAgICAgICAgJ21vdXNldXAnLCAnbW91c2Vkb3duJywgJ21vdXNlbW92ZSdcbiAgICBdO1xuICAgIC8qKlxuICAgICAqIEBhbGlhcyBtb2R1bGU6enJlbmRlci9IYW5kbGVyXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQGV4dGVuZHMgbW9kdWxlOnpyZW5kZXIvbWl4aW4vRXZlbnRmdWxcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSByb290IE1haW4gSFRNTCBlbGVtZW50IGZvciBwYWludGluZy5cbiAgICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL1N0b3JhZ2V9IHN0b3JhZ2UgU3RvcmFnZSBpbnN0YW5jZS5cbiAgICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL1BhaW50ZXJ9IHBhaW50ZXIgUGFpbnRlciBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICB2YXIgSGFuZGxlciA9IGZ1bmN0aW9uKHN0b3JhZ2UsIHBhaW50ZXIsIHByb3h5KSB7XG4gICAgICAgIEV2ZW50ZnVsLmNhbGwodGhpcyk7XG5cbiAgICAgICAgdGhpcy5zdG9yYWdlID0gc3RvcmFnZTtcblxuICAgICAgICB0aGlzLnBhaW50ZXIgPSBwYWludGVyO1xuXG4gICAgICAgIHByb3h5ID0gcHJveHkgfHwgbmV3IEVtcHR5UHJveHkoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFByb3h5IG9mIGV2ZW50LiBjYW4gYmUgRG9tLCBXZWJHTFN1cmZhY2UsIGV0Yy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucHJveHkgPSBwcm94eTtcblxuICAgICAgICAvLyBBdHRhY2ggaGFuZGxlclxuICAgICAgICBwcm94eS5oYW5kbGVyID0gdGhpcztcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9ob3ZlcmVkO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAdHlwZSB7RGF0ZX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2xhc3RUb3VjaE1vbWVudDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2xhc3RYO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fbGFzdFk7XG5cblxuICAgICAgICBEcmFnZ2FibGUuY2FsbCh0aGlzKTtcblxuICAgICAgICB1dGlsLmVhY2goaGFuZGxlck5hbWVzLCBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgcHJveHkub24gJiYgcHJveHkub24obmFtZSwgdGhpc1tuYW1lXSwgdGhpcyk7XG4gICAgICAgIH0sIHRoaXMpO1xuICAgIH07XG5cbiAgICBIYW5kbGVyLnByb3RvdHlwZSA9IHtcblxuICAgICAgICBjb25zdHJ1Y3RvcjogSGFuZGxlcixcblxuICAgICAgICBtb3VzZW1vdmU6IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgdmFyIHggPSBldmVudC56clg7XG4gICAgICAgICAgICB2YXIgeSA9IGV2ZW50LnpyWTtcblxuICAgICAgICAgICAgdmFyIGhvdmVyZWQgPSB0aGlzLmZpbmRIb3Zlcih4LCB5LCBudWxsKTtcbiAgICAgICAgICAgIHZhciBsYXN0SG92ZXJlZCA9IHRoaXMuX2hvdmVyZWQ7XG4gICAgICAgICAgICB2YXIgcHJveHkgPSB0aGlzLnByb3h5O1xuXG4gICAgICAgICAgICB0aGlzLl9ob3ZlcmVkID0gaG92ZXJlZDtcblxuICAgICAgICAgICAgcHJveHkuc2V0Q3Vyc29yICYmIHByb3h5LnNldEN1cnNvcihob3ZlcmVkID8gaG92ZXJlZC5jdXJzb3IgOiAnZGVmYXVsdCcpO1xuXG4gICAgICAgICAgICAvLyBNb3VzZSBvdXQgb24gcHJldmlvdXMgaG92ZXJlZCBlbGVtZW50XG4gICAgICAgICAgICBpZiAobGFzdEhvdmVyZWQgJiYgaG92ZXJlZCAhPT0gbGFzdEhvdmVyZWQgJiYgbGFzdEhvdmVyZWQuX196cikge1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hUb0VsZW1lbnQobGFzdEhvdmVyZWQsICdtb3VzZW91dCcsIGV2ZW50KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gTW91c2UgbW92aW5nIG9uIG9uZSBlbGVtZW50XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoVG9FbGVtZW50KGhvdmVyZWQsICdtb3VzZW1vdmUnLCBldmVudCk7XG5cbiAgICAgICAgICAgIC8vIE1vdXNlIG92ZXIgb24gYSBuZXcgZWxlbWVudFxuICAgICAgICAgICAgaWYgKGhvdmVyZWQgJiYgaG92ZXJlZCAhPT0gbGFzdEhvdmVyZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoVG9FbGVtZW50KGhvdmVyZWQsICdtb3VzZW92ZXInLCBldmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgbW91c2VvdXQ6IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaFRvRWxlbWVudCh0aGlzLl9ob3ZlcmVkLCAnbW91c2VvdXQnLCBldmVudCk7XG5cbiAgICAgICAgICAgIHRoaXMudHJpZ2dlcignZ2xvYmFsb3V0Jywge1xuICAgICAgICAgICAgICAgIGV2ZW50OiBldmVudFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlc2l6ZVxuICAgICAgICAgKi9cbiAgICAgICAgcmVzaXplOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuX2hvdmVyZWQgPSBudWxsO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEaXNwYXRjaCBldmVudFxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lXG4gICAgICAgICAqIEBwYXJhbSB7ZXZlbnQ9fSBldmVudEFyZ3NcbiAgICAgICAgICovXG4gICAgICAgIGRpc3BhdGNoOiBmdW5jdGlvbiAoZXZlbnROYW1lLCBldmVudEFyZ3MpIHtcbiAgICAgICAgICAgIHZhciBoYW5kbGVyID0gdGhpc1tldmVudE5hbWVdO1xuICAgICAgICAgICAgaGFuZGxlciAmJiBoYW5kbGVyLmNhbGwodGhpcywgZXZlbnRBcmdzKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGlzcG9zZVxuICAgICAgICAgKi9cbiAgICAgICAgZGlzcG9zZTogZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICB0aGlzLnByb3h5LmRpc3Bvc2UoKTtcblxuICAgICAgICAgICAgdGhpcy5zdG9yYWdlID1cbiAgICAgICAgICAgIHRoaXMucHJveHkgPVxuICAgICAgICAgICAgdGhpcy5wYWludGVyID0gbnVsbDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog6K6+572u6buY6K6k55qEY3Vyc29yIHN0eWxlXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY3Vyc29yU3R5bGU9J2RlZmF1bHQnXSDkvovlpoIgY3Jvc3NoYWlyXG4gICAgICAgICAqL1xuICAgICAgICBzZXRDdXJzb3JTdHlsZTogZnVuY3Rpb24gKGN1cnNvclN0eWxlKSB7XG4gICAgICAgICAgICB2YXIgcHJveHkgPSB0aGlzLnByb3h5O1xuICAgICAgICAgICAgcHJveHkuc2V0Q3Vyc29yICYmIHByb3h5LnNldEN1cnNvcihjdXJzb3JTdHlsZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOS6i+S7tuWIhuWPkeS7o+eQhlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0RWwg55uu5qCH5Zu+5b2i5YWD57SgXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUg5LqL5Lu25ZCN56ewXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCDkuovku7blr7nosaFcbiAgICAgICAgICovXG4gICAgICAgIGRpc3BhdGNoVG9FbGVtZW50OiBmdW5jdGlvbiAodGFyZ2V0RWwsIGV2ZW50TmFtZSwgZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBldmVudEhhbmRsZXIgPSAnb24nICsgZXZlbnROYW1lO1xuICAgICAgICAgICAgdmFyIGV2ZW50UGFja2V0ID0gbWFrZUV2ZW50UGFja2V0KGV2ZW50TmFtZSwgdGFyZ2V0RWwsIGV2ZW50KTtcblxuICAgICAgICAgICAgdmFyIGVsID0gdGFyZ2V0RWw7XG5cbiAgICAgICAgICAgIHdoaWxlIChlbCkge1xuICAgICAgICAgICAgICAgIGVsW2V2ZW50SGFuZGxlcl1cbiAgICAgICAgICAgICAgICAgICAgJiYgKGV2ZW50UGFja2V0LmNhbmNlbEJ1YmJsZSA9IGVsW2V2ZW50SGFuZGxlcl0uY2FsbChlbCwgZXZlbnRQYWNrZXQpKTtcblxuICAgICAgICAgICAgICAgIGVsLnRyaWdnZXIoZXZlbnROYW1lLCBldmVudFBhY2tldCk7XG5cbiAgICAgICAgICAgICAgICBlbCA9IGVsLnBhcmVudDtcblxuICAgICAgICAgICAgICAgIGlmIChldmVudFBhY2tldC5jYW5jZWxCdWJibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWV2ZW50UGFja2V0LmNhbmNlbEJ1YmJsZSkge1xuICAgICAgICAgICAgICAgIC8vIOWGkuazoeWIsOmhtue6pyB6cmVuZGVyIOWvueixoVxuICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlcihldmVudE5hbWUsIGV2ZW50UGFja2V0KTtcbiAgICAgICAgICAgICAgICAvLyDliIblj5Hkuovku7bliLDnlKjmiLfoh6rlrprkuYnlsYJcbiAgICAgICAgICAgICAgICAvLyDnlKjmiLfmnInlj6/og73lnKjlhajlsYAgY2xpY2sg5LqL5Lu25LitIGRpc3Bvc2XvvIzmiYDku6XpnIDopoHliKTmlq3kuIsgcGFpbnRlciDmmK/lkKblrZjlnKhcbiAgICAgICAgICAgICAgICB0aGlzLnBhaW50ZXIgJiYgdGhpcy5wYWludGVyLmVhY2hPdGhlckxheWVyKGZ1bmN0aW9uIChsYXllcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mKGxheWVyW2V2ZW50SGFuZGxlcl0pID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxheWVyW2V2ZW50SGFuZGxlcl0uY2FsbChsYXllciwgZXZlbnRQYWNrZXQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChsYXllci50cmlnZ2VyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYXllci50cmlnZ2VyKGV2ZW50TmFtZSwgZXZlbnRQYWNrZXQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gICAgICAgICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvZ3JhcGhpYy9EaXNwbGF5YWJsZX0gZXhjbHVkZVxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqL1xuICAgICAgICBmaW5kSG92ZXI6IGZ1bmN0aW9uKHgsIHksIGV4Y2x1ZGUpIHtcbiAgICAgICAgICAgIHZhciBsaXN0ID0gdGhpcy5zdG9yYWdlLmdldERpc3BsYXlMaXN0KCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gbGlzdC5sZW5ndGggLSAxOyBpID49IDAgOyBpLS0pIHtcbiAgICAgICAgICAgICAgICBpZiAoIWxpc3RbaV0uc2lsZW50XG4gICAgICAgICAgICAgICAgICYmIGxpc3RbaV0gIT09IGV4Y2x1ZGVcbiAgICAgICAgICAgICAgICAgLy8gZ2V0RGlzcGxheUxpc3QgbWF5IGluY2x1ZGUgaWdub3JlZCBpdGVtIGluIFZNTCBtb2RlXG4gICAgICAgICAgICAgICAgICYmICFsaXN0W2ldLmlnbm9yZVxuICAgICAgICAgICAgICAgICAmJiBpc0hvdmVyKGxpc3RbaV0sIHgsIHkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBsaXN0W2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBDb21tb24gaGFuZGxlcnNcbiAgICB1dGlsLmVhY2goWydjbGljaycsICdtb3VzZWRvd24nLCAnbW91c2V1cCcsICdtb3VzZXdoZWVsJywgJ2RibGNsaWNrJ10sIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIEhhbmRsZXIucHJvdG90eXBlW25hbWVdID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAvLyBGaW5kIGhvdmVyIGFnYWluIHRvIGF2b2lkIGNsaWNrIGV2ZW50IGlzIGRpc3BhdGNoZWQgbWFudWFsbHkuIE9yIGNsaWNrIGlzIHRyaWdnZXJlZCB3aXRob3V0IG1vdXNlb3ZlclxuICAgICAgICAgICAgdmFyIGhvdmVyZWQgPSB0aGlzLmZpbmRIb3ZlcihldmVudC56clgsIGV2ZW50LnpyWSwgbnVsbCk7XG5cbiAgICAgICAgICAgIGlmIChuYW1lID09PSAnbW91c2Vkb3duJykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2Rvd25lbCA9IGhvdmVyZWQ7XG4gICAgICAgICAgICAgICAgLy8gSW4gY2FzZSBjbGljayB0cmlnZ2VyZWQgYmVmb3JlIG1vdXNldXBcbiAgICAgICAgICAgICAgICB0aGlzLl91cGVsID0gaG92ZXJlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG5hbWUgPT09ICdtb3N1ZXVwJykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3VwZWwgPSBob3ZlcmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobmFtZSA9PT0gJ2NsaWNrJykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9kb3duZWwgIT09IHRoaXMuX3VwZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaFRvRWxlbWVudChob3ZlcmVkLCBuYW1lLCBldmVudCk7XG4gICAgICAgIH07XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBpc0hvdmVyKGRpc3BsYXlhYmxlLCB4LCB5KSB7XG4gICAgICAgIGlmIChkaXNwbGF5YWJsZVtkaXNwbGF5YWJsZS5yZWN0SG92ZXIgPyAncmVjdENvbnRhaW4nIDogJ2NvbnRhaW4nXSh4LCB5KSkge1xuICAgICAgICAgICAgdmFyIGVsID0gZGlzcGxheWFibGU7XG4gICAgICAgICAgICB3aGlsZSAoZWwpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBhbmNlc3RvciBpcyBzaWxlbnQgb3IgY2xpcHBlZCBieSBhbmNlc3RvclxuICAgICAgICAgICAgICAgIGlmIChlbC5zaWxlbnQgfHwgKGVsLmNsaXBQYXRoICYmICFlbC5jbGlwUGF0aC5jb250YWluKHgsIHkpKSkgIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbCA9IGVsLnBhcmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHV0aWwubWl4aW4oSGFuZGxlciwgRXZlbnRmdWwpO1xuICAgIHV0aWwubWl4aW4oSGFuZGxlciwgRHJhZ2dhYmxlKTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gSGFuZGxlcjtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3pyZW5kZXIvbGliL0hhbmRsZXIuanNcbiAqKiBtb2R1bGUgaWQgPSA2MlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuLyoqXG4gKiBTdG9yYWdl5YaF5a655LuT5bqT5qih5Z2XXG4gKiBAbW9kdWxlIHpyZW5kZXIvU3RvcmFnZVxuICogQGF1dGhvciBLZW5lciAoQEtlbmVyLeael+WzsCwga2VuZXIubGluZmVuZ0BnbWFpbC5jb20pXG4gKiBAYXV0aG9yIGVycm9ycmlrIChlcnJvcnJpa0BnbWFpbC5jb20pXG4gKiBAYXV0aG9yIHBpc3NhbmcgKGh0dHBzOi8vZ2l0aHViLmNvbS9waXNzYW5nLylcbiAqL1xuXG5cbiAgICB2YXIgdXRpbCA9IHJlcXVpcmUoJy4vY29yZS91dGlsJyk7XG4gICAgdmFyIGVudiA9IHJlcXVpcmUoJy4vY29yZS9lbnYnKTtcblxuICAgIHZhciBHcm91cCA9IHJlcXVpcmUoJy4vY29udGFpbmVyL0dyb3VwJyk7XG5cbiAgICAvLyBVc2UgdGltc29ydCBiZWNhdXNlIGluIG1vc3QgY2FzZSBlbGVtZW50cyBhcmUgcGFydGlhbGx5IHNvcnRlZFxuICAgIC8vIGh0dHBzOi8vanNmaWRkbGUubmV0L3Bpc3NhbmcvanI0eDdtZG0vOC9cbiAgICB2YXIgdGltc29ydCA9IHJlcXVpcmUoJy4vY29yZS90aW1zb3J0Jyk7XG5cbiAgICBmdW5jdGlvbiBzaGFwZUNvbXBhcmVGdW5jKGEsIGIpIHtcbiAgICAgICAgaWYgKGEuemxldmVsID09PSBiLnpsZXZlbCkge1xuICAgICAgICAgICAgaWYgKGEueiA9PT0gYi56KSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgKGEuejIgPT09IGIuejIpIHtcbiAgICAgICAgICAgICAgICAvLyAgICAgLy8gRklYTUUgU2xvdyBoYXMgcmVuZGVyaWR4IGNvbXBhcmVcbiAgICAgICAgICAgICAgICAvLyAgICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8yMDg4MzQyMS9zb3J0aW5nLWluLWphdmFzY3JpcHQtc2hvdWxkLWV2ZXJ5LWNvbXBhcmUtZnVuY3Rpb24taGF2ZS1hLXJldHVybi0wLXN0YXRlbWVudFxuICAgICAgICAgICAgICAgIC8vICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vdjgvdjgvYmxvYi80N2NjZTU0NGEzMWVkNTU3N2ZmZTI5NjNmNjdhY2I0MTQ0ZWUwMjMyL3NyYy9qcy9hcnJheS5qcyNMMTAxMlxuICAgICAgICAgICAgICAgIC8vICAgICByZXR1cm4gYS5fX3JlbmRlcmlkeCAtIGIuX19yZW5kZXJpZHg7XG4gICAgICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgICAgIHJldHVybiBhLnoyIC0gYi56MjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhLnogLSBiLno7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGEuemxldmVsIC0gYi56bGV2ZWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIOWGheWuueS7k+W6kyAoTSlcbiAgICAgKiBAYWxpYXMgbW9kdWxlOnpyZW5kZXIvU3RvcmFnZVxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIHZhciBTdG9yYWdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyDmiYDmnInluLjop4TlvaLnirbvvIxpZOe0ouW8leeahG1hcFxuICAgICAgICB0aGlzLl9lbGVtZW50cyA9IHt9O1xuXG4gICAgICAgIHRoaXMuX3Jvb3RzID0gW107XG5cbiAgICAgICAgdGhpcy5fZGlzcGxheUxpc3QgPSBbXTtcblxuICAgICAgICB0aGlzLl9kaXNwbGF5TGlzdExlbiA9IDA7XG4gICAgfTtcblxuICAgIFN0b3JhZ2UucHJvdG90eXBlID0ge1xuXG4gICAgICAgIGNvbnN0cnVjdG9yOiBTdG9yYWdlLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gY2JcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIHRyYXZlcnNlOiBmdW5jdGlvbiAoY2IsIGNvbnRleHQpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fcm9vdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yb290c1tpXS50cmF2ZXJzZShjYiwgY29udGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOi/lOWbnuaJgOacieWbvuW9oueahOe7mOWItumYn+WIl1xuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFt1cGRhdGU9ZmFsc2VdIOaYr+WQpuWcqOi/lOWbnuWJjeabtOaWsOivpeaVsOe7hFxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpbmNsdWRlSWdub3JlPWZhbHNlXSDmmK/lkKbljIXlkKsgaWdub3JlIOeahOaVsOe7hCwg5ZyoIHVwZGF0ZSDkuLogdHJ1ZSDnmoTml7blgJnmnInmlYhcbiAgICAgICAgICpcbiAgICAgICAgICog6K+m6KeBe0BsaW5rIG1vZHVsZTp6cmVuZGVyL2dyYXBoaWMvRGlzcGxheWFibGUucHJvdG90eXBlLnVwZGF0ZURpc3BsYXlMaXN0fVxuICAgICAgICAgKiBAcmV0dXJuIHtBcnJheS48bW9kdWxlOnpyZW5kZXIvZ3JhcGhpYy9EaXNwbGF5YWJsZT59XG4gICAgICAgICAqL1xuICAgICAgICBnZXREaXNwbGF5TGlzdDogZnVuY3Rpb24gKHVwZGF0ZSwgaW5jbHVkZUlnbm9yZSkge1xuICAgICAgICAgICAgaW5jbHVkZUlnbm9yZSA9IGluY2x1ZGVJZ25vcmUgfHwgZmFsc2U7XG4gICAgICAgICAgICBpZiAodXBkYXRlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVEaXNwbGF5TGlzdChpbmNsdWRlSWdub3JlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kaXNwbGF5TGlzdDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5pu05paw5Zu+5b2i55qE57uY5Yi26Zif5YiX44CCXG4gICAgICAgICAqIOavj+asoee7mOWItuWJjemDveS8muiwg+eUqO+8jOivpeaWueazleS8muWFiOa3seW6puS8mOWFiOmBjeWOhuaVtOS4quagke+8jOabtOaWsOaJgOaciUdyb3Vw5ZKMU2hhcGXnmoTlj5jmjaLlubbkuJTmiormiYDmnInlj6/op4HnmoRTaGFwZeS/neWtmOWIsOaVsOe7hOS4re+8jFxuICAgICAgICAgKiDmnIDlkI7moLnmja7nu5jliLbnmoTkvJjlhYjnuqfvvIh6bGV2ZWwgPiB6ID4g5o+S5YWl6aG65bqP77yJ5o6S5bqP5b6X5Yiw57uY5Yi26Zif5YiXXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2luY2x1ZGVJZ25vcmU9ZmFsc2VdIOaYr+WQpuWMheWQqyBpZ25vcmUg55qE5pWw57uEXG4gICAgICAgICAqL1xuICAgICAgICB1cGRhdGVEaXNwbGF5TGlzdDogZnVuY3Rpb24gKGluY2x1ZGVJZ25vcmUpIHtcbiAgICAgICAgICAgIHRoaXMuX2Rpc3BsYXlMaXN0TGVuID0gMDtcbiAgICAgICAgICAgIHZhciByb290cyA9IHRoaXMuX3Jvb3RzO1xuICAgICAgICAgICAgdmFyIGRpc3BsYXlMaXN0ID0gdGhpcy5fZGlzcGxheUxpc3Q7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gcm9vdHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVBbmRBZGREaXNwbGF5YWJsZShyb290c1tpXSwgbnVsbCwgaW5jbHVkZUlnbm9yZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkaXNwbGF5TGlzdC5sZW5ndGggPSB0aGlzLl9kaXNwbGF5TGlzdExlbjtcblxuICAgICAgICAgICAgLy8gZm9yICh2YXIgaSA9IDAsIGxlbiA9IGRpc3BsYXlMaXN0Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAvLyAgICAgZGlzcGxheUxpc3RbaV0uX19yZW5kZXJpZHggPSBpO1xuICAgICAgICAgICAgLy8gfVxuXG4gICAgICAgICAgICAvLyBkaXNwbGF5TGlzdC5zb3J0KHNoYXBlQ29tcGFyZUZ1bmMpO1xuICAgICAgICAgICAgZW52LmNhbnZhc1N1cHBvcnRlZCAmJiB0aW1zb3J0KGRpc3BsYXlMaXN0LCBzaGFwZUNvbXBhcmVGdW5jKTtcbiAgICAgICAgfSxcblxuICAgICAgICBfdXBkYXRlQW5kQWRkRGlzcGxheWFibGU6IGZ1bmN0aW9uIChlbCwgY2xpcFBhdGhzLCBpbmNsdWRlSWdub3JlKSB7XG5cbiAgICAgICAgICAgIGlmIChlbC5pZ25vcmUgJiYgIWluY2x1ZGVJZ25vcmUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGVsLmJlZm9yZVVwZGF0ZSgpO1xuXG4gICAgICAgICAgICBpZiAoZWwuX19kaXJ0eSkge1xuXG4gICAgICAgICAgICAgICAgZWwudXBkYXRlKCk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZWwuYWZ0ZXJVcGRhdGUoKTtcblxuICAgICAgICAgICAgdmFyIGNsaXBQYXRoID0gZWwuY2xpcFBhdGg7XG4gICAgICAgICAgICBpZiAoY2xpcFBhdGgpIHtcbiAgICAgICAgICAgICAgICAvLyBjbGlwUGF0aCDnmoTlj5jmjaLmmK/ln7rkuo4gZ3JvdXAg55qE5Y+Y5o2iXG4gICAgICAgICAgICAgICAgY2xpcFBhdGgucGFyZW50ID0gZWw7XG4gICAgICAgICAgICAgICAgY2xpcFBhdGgudXBkYXRlVHJhbnNmb3JtKCk7XG5cbiAgICAgICAgICAgICAgICAvLyBGSVhNRSDmlYjnjoflvbHlk41cbiAgICAgICAgICAgICAgICBpZiAoY2xpcFBhdGhzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsaXBQYXRocyA9IGNsaXBQYXRocy5zbGljZSgpO1xuICAgICAgICAgICAgICAgICAgICBjbGlwUGF0aHMucHVzaChjbGlwUGF0aCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjbGlwUGF0aHMgPSBbY2xpcFBhdGhdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGVsLmlzR3JvdXApIHtcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGRyZW4gPSBlbC5fY2hpbGRyZW47XG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIEZvcmNlIHRvIG1hcmsgYXMgZGlydHkgaWYgZ3JvdXAgaXMgZGlydHlcbiAgICAgICAgICAgICAgICAgICAgLy8gRklYTUUgX19kaXJ0eVBhdGggP1xuICAgICAgICAgICAgICAgICAgICBpZiAoZWwuX19kaXJ0eSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGQuX19kaXJ0eSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVBbmRBZGREaXNwbGF5YWJsZShjaGlsZCwgY2xpcFBhdGhzLCBpbmNsdWRlSWdub3JlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBNYXJrIGdyb3VwIGNsZWFuIGhlcmVcbiAgICAgICAgICAgICAgICBlbC5fX2RpcnR5ID0gZmFsc2U7XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGVsLl9fY2xpcFBhdGhzID0gY2xpcFBhdGhzO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5fZGlzcGxheUxpc3RbdGhpcy5fZGlzcGxheUxpc3RMZW4rK10gPSBlbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5re75Yqg5Zu+5b2iKFNoYXBlKeaIluiAhee7hChHcm91cCnliLDmoLnoioLngrlcbiAgICAgICAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9FbGVtZW50fSBlbFxuICAgICAgICAgKi9cbiAgICAgICAgYWRkUm9vdDogZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICAvLyBFbGVtZW50IGhhcyBiZWVuIGFkZGVkXG4gICAgICAgICAgICBpZiAodGhpcy5fZWxlbWVudHNbZWwuaWRdKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZWwgaW5zdGFuY2VvZiBHcm91cCkge1xuICAgICAgICAgICAgICAgIGVsLmFkZENoaWxkcmVuVG9TdG9yYWdlKHRoaXMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmFkZFRvTWFwKGVsKTtcbiAgICAgICAgICAgIHRoaXMuX3Jvb3RzLnB1c2goZWwpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDliKDpmaTmjIflrprnmoTlm77lvaIoU2hhcGUp5oiW6ICF57uEKEdyb3VwKVxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ3xBcnJheS48c3RyaW5nPn0gW2VsSWRdIOWmguaenOS4uuepuua4heepuuaVtOS4qlN0b3JhZ2VcbiAgICAgICAgICovXG4gICAgICAgIGRlbFJvb3Q6IGZ1bmN0aW9uIChlbElkKSB7XG4gICAgICAgICAgICBpZiAoZWxJZCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgLy8g5LiN5oyH5a6aZWxJZOa4heepulxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fcm9vdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJvb3QgPSB0aGlzLl9yb290c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJvb3QgaW5zdGFuY2VvZiBHcm91cCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcm9vdC5kZWxDaGlsZHJlbkZyb21TdG9yYWdlKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5fZWxlbWVudHMgPSB7fTtcbiAgICAgICAgICAgICAgICB0aGlzLl9yb290cyA9IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuX2Rpc3BsYXlMaXN0ID0gW107XG4gICAgICAgICAgICAgICAgdGhpcy5fZGlzcGxheUxpc3RMZW4gPSAwO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZWxJZCBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBlbElkLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlbFJvb3QoZWxJZFtpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGVsO1xuICAgICAgICAgICAgaWYgKHR5cGVvZihlbElkKSA9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGVsID0gdGhpcy5fZWxlbWVudHNbZWxJZF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBlbCA9IGVsSWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBpZHggPSB1dGlsLmluZGV4T2YodGhpcy5fcm9vdHMsIGVsKTtcbiAgICAgICAgICAgIGlmIChpZHggPj0gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGVsRnJvbU1hcChlbC5pZCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcm9vdHMuc3BsaWNlKGlkeCwgMSk7XG4gICAgICAgICAgICAgICAgaWYgKGVsIGluc3RhbmNlb2YgR3JvdXApIHtcbiAgICAgICAgICAgICAgICAgICAgZWwuZGVsQ2hpbGRyZW5Gcm9tU3RvcmFnZSh0aGlzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgYWRkVG9NYXA6IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgaWYgKGVsIGluc3RhbmNlb2YgR3JvdXApIHtcbiAgICAgICAgICAgICAgICBlbC5fX3N0b3JhZ2UgPSB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWwuZGlydHkoZmFsc2UpO1xuXG4gICAgICAgICAgICB0aGlzLl9lbGVtZW50c1tlbC5pZF0gPSBlbDtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoZWxJZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2VsZW1lbnRzW2VsSWRdO1xuICAgICAgICB9LFxuXG4gICAgICAgIGRlbEZyb21NYXA6IGZ1bmN0aW9uIChlbElkKSB7XG4gICAgICAgICAgICB2YXIgZWxlbWVudHMgPSB0aGlzLl9lbGVtZW50cztcbiAgICAgICAgICAgIHZhciBlbCA9IGVsZW1lbnRzW2VsSWRdO1xuICAgICAgICAgICAgaWYgKGVsKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGVsZW1lbnRzW2VsSWRdO1xuICAgICAgICAgICAgICAgIGlmIChlbCBpbnN0YW5jZW9mIEdyb3VwKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsLl9fc3RvcmFnZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5riF56m65bm25LiU6YeK5pS+U3RvcmFnZVxuICAgICAgICAgKi9cbiAgICAgICAgZGlzcG9zZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5fZWxlbWVudHMgPVxuICAgICAgICAgICAgdGhpcy5fcmVuZGVyTGlzdCA9XG4gICAgICAgICAgICB0aGlzLl9yb290cyA9IG51bGw7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZGlzcGxheWFibGVTb3J0RnVuYzogc2hhcGVDb21wYXJlRnVuY1xuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IFN0b3JhZ2U7XG5cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3pyZW5kZXIvbGliL1N0b3JhZ2UuanNcbiAqKiBtb2R1bGUgaWQgPSA2M1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL216aWNjYXJkL25vZGUtdGltc29ydFxuXG4gICAgdmFyIERFRkFVTFRfTUlOX01FUkdFID0gMzI7XG5cbiAgICB2YXIgREVGQVVMVF9NSU5fR0FMTE9QSU5HID0gNztcblxuICAgIHZhciBERUZBVUxUX1RNUF9TVE9SQUdFX0xFTkdUSCA9IDI1NjtcblxuICAgIGZ1bmN0aW9uIG1pblJ1bkxlbmd0aChuKSB7XG4gICAgICAgIHZhciByID0gMDtcblxuICAgICAgICB3aGlsZSAobiA+PSBERUZBVUxUX01JTl9NRVJHRSkge1xuICAgICAgICAgICAgciB8PSBuICYgMTtcbiAgICAgICAgICAgIG4gPj49IDE7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbiArIHI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWFrZUFzY2VuZGluZ1J1bihhcnJheSwgbG8sIGhpLCBjb21wYXJlKSB7XG4gICAgICAgIHZhciBydW5IaSA9IGxvICsgMTtcblxuICAgICAgICBpZiAocnVuSGkgPT09IGhpKSB7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb21wYXJlKGFycmF5W3J1bkhpKytdLCBhcnJheVtsb10pIDwgMCkge1xuICAgICAgICAgICAgd2hpbGUgKHJ1bkhpIDwgaGkgJiYgY29tcGFyZShhcnJheVtydW5IaV0sIGFycmF5W3J1bkhpIC0gMV0pIDwgMCkge1xuICAgICAgICAgICAgICAgIHJ1bkhpKys7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldmVyc2VSdW4oYXJyYXksIGxvLCBydW5IaSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB3aGlsZSAocnVuSGkgPCBoaSAmJiBjb21wYXJlKGFycmF5W3J1bkhpXSwgYXJyYXlbcnVuSGkgLSAxXSkgPj0gMCkge1xuICAgICAgICAgICAgICAgIHJ1bkhpKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcnVuSGkgLSBsbztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZXZlcnNlUnVuKGFycmF5LCBsbywgaGkpIHtcbiAgICAgICAgaGktLTtcblxuICAgICAgICB3aGlsZSAobG8gPCBoaSkge1xuICAgICAgICAgICAgdmFyIHQgPSBhcnJheVtsb107XG4gICAgICAgICAgICBhcnJheVtsbysrXSA9IGFycmF5W2hpXTtcbiAgICAgICAgICAgIGFycmF5W2hpLS1dID0gdDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGJpbmFyeUluc2VydGlvblNvcnQoYXJyYXksIGxvLCBoaSwgc3RhcnQsIGNvbXBhcmUpIHtcbiAgICAgICAgaWYgKHN0YXJ0ID09PSBsbykge1xuICAgICAgICAgICAgc3RhcnQrKztcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoOyBzdGFydCA8IGhpOyBzdGFydCsrKSB7XG4gICAgICAgICAgICB2YXIgcGl2b3QgPSBhcnJheVtzdGFydF07XG5cbiAgICAgICAgICAgIHZhciBsZWZ0ID0gbG87XG4gICAgICAgICAgICB2YXIgcmlnaHQgPSBzdGFydDtcbiAgICAgICAgICAgIHZhciBtaWQ7XG5cbiAgICAgICAgICAgIHdoaWxlIChsZWZ0IDwgcmlnaHQpIHtcbiAgICAgICAgICAgICAgICBtaWQgPSBsZWZ0ICsgcmlnaHQgPj4+IDE7XG5cbiAgICAgICAgICAgICAgICBpZiAoY29tcGFyZShwaXZvdCwgYXJyYXlbbWlkXSkgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gbWlkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGVmdCA9IG1pZCArIDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgbiA9IHN0YXJ0IC0gbGVmdDtcblxuICAgICAgICAgICAgc3dpdGNoIChuKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICBhcnJheVtsZWZ0ICsgM10gPSBhcnJheVtsZWZ0ICsgMl07XG5cbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIGFycmF5W2xlZnQgKyAyXSA9IGFycmF5W2xlZnQgKyAxXTtcblxuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgYXJyYXlbbGVmdCArIDFdID0gYXJyYXlbbGVmdF07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChuID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJyYXlbbGVmdCArIG5dID0gYXJyYXlbbGVmdCArIG4gLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG4tLTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBhcnJheVtsZWZ0XSA9IHBpdm90O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2FsbG9wTGVmdCh2YWx1ZSwgYXJyYXksIHN0YXJ0LCBsZW5ndGgsIGhpbnQsIGNvbXBhcmUpIHtcbiAgICAgICAgdmFyIGxhc3RPZmZzZXQgPSAwO1xuICAgICAgICB2YXIgbWF4T2Zmc2V0ID0gMDtcbiAgICAgICAgdmFyIG9mZnNldCA9IDE7XG5cbiAgICAgICAgaWYgKGNvbXBhcmUodmFsdWUsIGFycmF5W3N0YXJ0ICsgaGludF0pID4gMCkge1xuICAgICAgICAgICAgbWF4T2Zmc2V0ID0gbGVuZ3RoIC0gaGludDtcblxuICAgICAgICAgICAgd2hpbGUgKG9mZnNldCA8IG1heE9mZnNldCAmJiBjb21wYXJlKHZhbHVlLCBhcnJheVtzdGFydCArIGhpbnQgKyBvZmZzZXRdKSA+IDApIHtcbiAgICAgICAgICAgICAgICBsYXN0T2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICAgICAgICAgIG9mZnNldCA9IChvZmZzZXQgPDwgMSkgKyAxO1xuXG4gICAgICAgICAgICAgICAgaWYgKG9mZnNldCA8PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG9mZnNldCA9IG1heE9mZnNldDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChvZmZzZXQgPiBtYXhPZmZzZXQpIHtcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSBtYXhPZmZzZXQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxhc3RPZmZzZXQgKz0gaGludDtcbiAgICAgICAgICAgIG9mZnNldCArPSBoaW50O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWF4T2Zmc2V0ID0gaGludCArIDE7XG4gICAgICAgICAgICB3aGlsZSAob2Zmc2V0IDwgbWF4T2Zmc2V0ICYmIGNvbXBhcmUodmFsdWUsIGFycmF5W3N0YXJ0ICsgaGludCAtIG9mZnNldF0pIDw9IDApIHtcbiAgICAgICAgICAgICAgICBsYXN0T2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICAgICAgICAgIG9mZnNldCA9IChvZmZzZXQgPDwgMSkgKyAxO1xuXG4gICAgICAgICAgICAgICAgaWYgKG9mZnNldCA8PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG9mZnNldCA9IG1heE9mZnNldDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob2Zmc2V0ID4gbWF4T2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gbWF4T2Zmc2V0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgdG1wID0gbGFzdE9mZnNldDtcbiAgICAgICAgICAgIGxhc3RPZmZzZXQgPSBoaW50IC0gb2Zmc2V0O1xuICAgICAgICAgICAgb2Zmc2V0ID0gaGludCAtIHRtcDtcbiAgICAgICAgfVxuXG4gICAgICAgIGxhc3RPZmZzZXQrKztcbiAgICAgICAgd2hpbGUgKGxhc3RPZmZzZXQgPCBvZmZzZXQpIHtcbiAgICAgICAgICAgIHZhciBtID0gbGFzdE9mZnNldCArIChvZmZzZXQgLSBsYXN0T2Zmc2V0ID4+PiAxKTtcblxuICAgICAgICAgICAgaWYgKGNvbXBhcmUodmFsdWUsIGFycmF5W3N0YXJ0ICsgbV0pID4gMCkge1xuICAgICAgICAgICAgICAgIGxhc3RPZmZzZXQgPSBtICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG9mZnNldCA9IG07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9mZnNldDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnYWxsb3BSaWdodCh2YWx1ZSwgYXJyYXksIHN0YXJ0LCBsZW5ndGgsIGhpbnQsIGNvbXBhcmUpIHtcbiAgICAgICAgdmFyIGxhc3RPZmZzZXQgPSAwO1xuICAgICAgICB2YXIgbWF4T2Zmc2V0ID0gMDtcbiAgICAgICAgdmFyIG9mZnNldCA9IDE7XG5cbiAgICAgICAgaWYgKGNvbXBhcmUodmFsdWUsIGFycmF5W3N0YXJ0ICsgaGludF0pIDwgMCkge1xuICAgICAgICAgICAgbWF4T2Zmc2V0ID0gaGludCArIDE7XG5cbiAgICAgICAgICAgIHdoaWxlIChvZmZzZXQgPCBtYXhPZmZzZXQgJiYgY29tcGFyZSh2YWx1ZSwgYXJyYXlbc3RhcnQgKyBoaW50IC0gb2Zmc2V0XSkgPCAwKSB7XG4gICAgICAgICAgICAgICAgbGFzdE9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSAob2Zmc2V0IDw8IDEpICsgMTtcblxuICAgICAgICAgICAgICAgIGlmIChvZmZzZXQgPD0gMCkge1xuICAgICAgICAgICAgICAgICAgICBvZmZzZXQgPSBtYXhPZmZzZXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAob2Zmc2V0ID4gbWF4T2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gbWF4T2Zmc2V0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgdG1wID0gbGFzdE9mZnNldDtcbiAgICAgICAgICAgIGxhc3RPZmZzZXQgPSBoaW50IC0gb2Zmc2V0O1xuICAgICAgICAgICAgb2Zmc2V0ID0gaGludCAtIHRtcDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1heE9mZnNldCA9IGxlbmd0aCAtIGhpbnQ7XG5cbiAgICAgICAgICAgIHdoaWxlIChvZmZzZXQgPCBtYXhPZmZzZXQgJiYgY29tcGFyZSh2YWx1ZSwgYXJyYXlbc3RhcnQgKyBoaW50ICsgb2Zmc2V0XSkgPj0gMCkge1xuICAgICAgICAgICAgICAgIGxhc3RPZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gKG9mZnNldCA8PCAxKSArIDE7XG5cbiAgICAgICAgICAgICAgICBpZiAob2Zmc2V0IDw9IDApIHtcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ID0gbWF4T2Zmc2V0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG9mZnNldCA+IG1heE9mZnNldCkge1xuICAgICAgICAgICAgICAgIG9mZnNldCA9IG1heE9mZnNldDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGFzdE9mZnNldCArPSBoaW50O1xuICAgICAgICAgICAgb2Zmc2V0ICs9IGhpbnQ7XG4gICAgICAgIH1cblxuICAgICAgICBsYXN0T2Zmc2V0Kys7XG5cbiAgICAgICAgd2hpbGUgKGxhc3RPZmZzZXQgPCBvZmZzZXQpIHtcbiAgICAgICAgICAgIHZhciBtID0gbGFzdE9mZnNldCArIChvZmZzZXQgLSBsYXN0T2Zmc2V0ID4+PiAxKTtcblxuICAgICAgICAgICAgaWYgKGNvbXBhcmUodmFsdWUsIGFycmF5W3N0YXJ0ICsgbV0pIDwgMCkge1xuICAgICAgICAgICAgICAgIG9mZnNldCA9IG07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsYXN0T2Zmc2V0ID0gbSArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb2Zmc2V0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIFRpbVNvcnQoYXJyYXksIGNvbXBhcmUpIHtcbiAgICAgICAgdmFyIG1pbkdhbGxvcCA9IERFRkFVTFRfTUlOX0dBTExPUElORztcbiAgICAgICAgdmFyIGxlbmd0aCA9IDA7XG4gICAgICAgIHZhciB0bXBTdG9yYWdlTGVuZ3RoID0gREVGQVVMVF9UTVBfU1RPUkFHRV9MRU5HVEg7XG4gICAgICAgIHZhciBzdGFja0xlbmd0aCA9IDA7XG4gICAgICAgIHZhciBydW5TdGFydDtcbiAgICAgICAgdmFyIHJ1bkxlbmd0aDtcbiAgICAgICAgdmFyIHN0YWNrU2l6ZSA9IDA7XG5cbiAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gICAgICAgIGlmIChsZW5ndGggPCAyICogREVGQVVMVF9UTVBfU1RPUkFHRV9MRU5HVEgpIHtcbiAgICAgICAgICAgIHRtcFN0b3JhZ2VMZW5ndGggPSBsZW5ndGggPj4+IDE7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdG1wID0gW107XG5cbiAgICAgICAgc3RhY2tMZW5ndGggPSBsZW5ndGggPCAxMjAgPyA1IDogbGVuZ3RoIDwgMTU0MiA/IDEwIDogbGVuZ3RoIDwgMTE5MTUxID8gMTkgOiA0MDtcblxuICAgICAgICBydW5TdGFydCA9IFtdO1xuICAgICAgICBydW5MZW5ndGggPSBbXTtcblxuICAgICAgICBmdW5jdGlvbiBwdXNoUnVuKF9ydW5TdGFydCwgX3J1bkxlbmd0aCkge1xuICAgICAgICAgICAgcnVuU3RhcnRbc3RhY2tTaXplXSA9IF9ydW5TdGFydDtcbiAgICAgICAgICAgIHJ1bkxlbmd0aFtzdGFja1NpemVdID0gX3J1bkxlbmd0aDtcbiAgICAgICAgICAgIHN0YWNrU2l6ZSArPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gbWVyZ2VSdW5zKCkge1xuICAgICAgICAgICAgd2hpbGUgKHN0YWNrU2l6ZSA+IDEpIHtcbiAgICAgICAgICAgICAgICB2YXIgbiA9IHN0YWNrU2l6ZSAtIDI7XG5cbiAgICAgICAgICAgICAgICBpZiAobiA+PSAxICYmIHJ1bkxlbmd0aFtuIC0gMV0gPD0gcnVuTGVuZ3RoW25dICsgcnVuTGVuZ3RoW24gKyAxXSB8fCBuID49IDIgJiYgcnVuTGVuZ3RoW24gLSAyXSA8PSBydW5MZW5ndGhbbl0gKyBydW5MZW5ndGhbbiAtIDFdKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChydW5MZW5ndGhbbiAtIDFdIDwgcnVuTGVuZ3RoW24gKyAxXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbi0tO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJ1bkxlbmd0aFtuXSA+IHJ1bkxlbmd0aFtuICsgMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG1lcmdlQXQobik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBmb3JjZU1lcmdlUnVucygpIHtcbiAgICAgICAgICAgIHdoaWxlIChzdGFja1NpemUgPiAxKSB7XG4gICAgICAgICAgICAgICAgdmFyIG4gPSBzdGFja1NpemUgLSAyO1xuXG4gICAgICAgICAgICAgICAgaWYgKG4gPiAwICYmIHJ1bkxlbmd0aFtuIC0gMV0gPCBydW5MZW5ndGhbbiArIDFdKSB7XG4gICAgICAgICAgICAgICAgICAgIG4tLTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBtZXJnZUF0KG4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gbWVyZ2VBdChpKSB7XG4gICAgICAgICAgICB2YXIgc3RhcnQxID0gcnVuU3RhcnRbaV07XG4gICAgICAgICAgICB2YXIgbGVuZ3RoMSA9IHJ1bkxlbmd0aFtpXTtcbiAgICAgICAgICAgIHZhciBzdGFydDIgPSBydW5TdGFydFtpICsgMV07XG4gICAgICAgICAgICB2YXIgbGVuZ3RoMiA9IHJ1bkxlbmd0aFtpICsgMV07XG5cbiAgICAgICAgICAgIHJ1bkxlbmd0aFtpXSA9IGxlbmd0aDEgKyBsZW5ndGgyO1xuXG4gICAgICAgICAgICBpZiAoaSA9PT0gc3RhY2tTaXplIC0gMykge1xuICAgICAgICAgICAgICAgIHJ1blN0YXJ0W2kgKyAxXSA9IHJ1blN0YXJ0W2kgKyAyXTtcbiAgICAgICAgICAgICAgICBydW5MZW5ndGhbaSArIDFdID0gcnVuTGVuZ3RoW2kgKyAyXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc3RhY2tTaXplLS07XG5cbiAgICAgICAgICAgIHZhciBrID0gZ2FsbG9wUmlnaHQoYXJyYXlbc3RhcnQyXSwgYXJyYXksIHN0YXJ0MSwgbGVuZ3RoMSwgMCwgY29tcGFyZSk7XG4gICAgICAgICAgICBzdGFydDEgKz0gaztcbiAgICAgICAgICAgIGxlbmd0aDEgLT0gaztcblxuICAgICAgICAgICAgaWYgKGxlbmd0aDEgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxlbmd0aDIgPSBnYWxsb3BMZWZ0KGFycmF5W3N0YXJ0MSArIGxlbmd0aDEgLSAxXSwgYXJyYXksIHN0YXJ0MiwgbGVuZ3RoMiwgbGVuZ3RoMiAtIDEsIGNvbXBhcmUpO1xuXG4gICAgICAgICAgICBpZiAobGVuZ3RoMiA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGxlbmd0aDEgPD0gbGVuZ3RoMikge1xuICAgICAgICAgICAgICAgIG1lcmdlTG93KHN0YXJ0MSwgbGVuZ3RoMSwgc3RhcnQyLCBsZW5ndGgyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG1lcmdlSGlnaChzdGFydDEsIGxlbmd0aDEsIHN0YXJ0MiwgbGVuZ3RoMik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBtZXJnZUxvdyhzdGFydDEsIGxlbmd0aDEsIHN0YXJ0MiwgbGVuZ3RoMikge1xuICAgICAgICAgICAgdmFyIGkgPSAwO1xuXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoMTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdG1wW2ldID0gYXJyYXlbc3RhcnQxICsgaV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBjdXJzb3IxID0gMDtcbiAgICAgICAgICAgIHZhciBjdXJzb3IyID0gc3RhcnQyO1xuICAgICAgICAgICAgdmFyIGRlc3QgPSBzdGFydDE7XG5cbiAgICAgICAgICAgIGFycmF5W2Rlc3QrK10gPSBhcnJheVtjdXJzb3IyKytdO1xuXG4gICAgICAgICAgICBpZiAoLS1sZW5ndGgyID09PSAwKSB7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDE7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBhcnJheVtkZXN0ICsgaV0gPSB0bXBbY3Vyc29yMSArIGldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChsZW5ndGgxID09PSAxKSB7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDI7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBhcnJheVtkZXN0ICsgaV0gPSBhcnJheVtjdXJzb3IyICsgaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFycmF5W2Rlc3QgKyBsZW5ndGgyXSA9IHRtcFtjdXJzb3IxXTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBfbWluR2FsbG9wID0gbWluR2FsbG9wO1xuICAgICAgICAgICAgdmFyIGNvdW50MSwgY291bnQyLCBleGl0O1xuXG4gICAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgICAgIGNvdW50MSA9IDA7XG4gICAgICAgICAgICAgICAgY291bnQyID0gMDtcbiAgICAgICAgICAgICAgICBleGl0ID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb21wYXJlKGFycmF5W2N1cnNvcjJdLCB0bXBbY3Vyc29yMV0pIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJyYXlbZGVzdCsrXSA9IGFycmF5W2N1cnNvcjIrK107XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudDIrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50MSA9IDA7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgtLWxlbmd0aDIgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGl0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFycmF5W2Rlc3QrK10gPSB0bXBbY3Vyc29yMSsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50MSsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY291bnQyID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgtLWxlbmd0aDEgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGl0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gd2hpbGUgKChjb3VudDEgfCBjb3VudDIpIDwgX21pbkdhbGxvcCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoZXhpdCkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50MSA9IGdhbGxvcFJpZ2h0KGFycmF5W2N1cnNvcjJdLCB0bXAsIGN1cnNvcjEsIGxlbmd0aDEsIDAsIGNvbXBhcmUpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb3VudDEgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb3VudDE7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFycmF5W2Rlc3QgKyBpXSA9IHRtcFtjdXJzb3IxICsgaV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGRlc3QgKz0gY291bnQxO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3Vyc29yMSArPSBjb3VudDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZW5ndGgxIC09IGNvdW50MTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsZW5ndGgxIDw9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGl0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGFycmF5W2Rlc3QrK10gPSBhcnJheVtjdXJzb3IyKytdO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICgtLWxlbmd0aDIgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4aXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBjb3VudDIgPSBnYWxsb3BMZWZ0KHRtcFtjdXJzb3IxXSwgYXJyYXksIGN1cnNvcjIsIGxlbmd0aDIsIDAsIGNvbXBhcmUpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb3VudDIgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb3VudDI7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFycmF5W2Rlc3QgKyBpXSA9IGFycmF5W2N1cnNvcjIgKyBpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgZGVzdCArPSBjb3VudDI7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3IyICs9IGNvdW50MjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlbmd0aDIgLT0gY291bnQyO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobGVuZ3RoMiA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4aXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGFycmF5W2Rlc3QrK10gPSB0bXBbY3Vyc29yMSsrXTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoLS1sZW5ndGgxID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBleGl0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgX21pbkdhbGxvcC0tO1xuICAgICAgICAgICAgICAgIH0gd2hpbGUgKGNvdW50MSA+PSBERUZBVUxUX01JTl9HQUxMT1BJTkcgfHwgY291bnQyID49IERFRkFVTFRfTUlOX0dBTExPUElORyk7XG5cbiAgICAgICAgICAgICAgICBpZiAoZXhpdCkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoX21pbkdhbGxvcCA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgX21pbkdhbGxvcCA9IDA7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgX21pbkdhbGxvcCArPSAyO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtaW5HYWxsb3AgPSBfbWluR2FsbG9wO1xuXG4gICAgICAgICAgICBtaW5HYWxsb3AgPCAxICYmIChtaW5HYWxsb3AgPSAxKTtcblxuICAgICAgICAgICAgaWYgKGxlbmd0aDEgPT09IDEpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoMjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGFycmF5W2Rlc3QgKyBpXSA9IGFycmF5W2N1cnNvcjIgKyBpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYXJyYXlbZGVzdCArIGxlbmd0aDJdID0gdG1wW2N1cnNvcjFdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobGVuZ3RoMSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigpO1xuICAgICAgICAgICAgICAgIC8vIHRocm93IG5ldyBFcnJvcignbWVyZ2VMb3cgcHJlY29uZGl0aW9ucyB3ZXJlIG5vdCByZXNwZWN0ZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGgxOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgYXJyYXlbZGVzdCArIGldID0gdG1wW2N1cnNvcjEgKyBpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBtZXJnZUhpZ2ggKHN0YXJ0MSwgbGVuZ3RoMSwgc3RhcnQyLCBsZW5ndGgyKSB7XG4gICAgICAgICAgICB2YXIgaSA9IDA7XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGgyOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0bXBbaV0gPSBhcnJheVtzdGFydDIgKyBpXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGN1cnNvcjEgPSBzdGFydDEgKyBsZW5ndGgxIC0gMTtcbiAgICAgICAgICAgIHZhciBjdXJzb3IyID0gbGVuZ3RoMiAtIDE7XG4gICAgICAgICAgICB2YXIgZGVzdCA9IHN0YXJ0MiArIGxlbmd0aDIgLSAxO1xuICAgICAgICAgICAgdmFyIGN1c3RvbUN1cnNvciA9IDA7XG4gICAgICAgICAgICB2YXIgY3VzdG9tRGVzdCA9IDA7XG5cbiAgICAgICAgICAgIGFycmF5W2Rlc3QtLV0gPSBhcnJheVtjdXJzb3IxLS1dO1xuXG4gICAgICAgICAgICBpZiAoLS1sZW5ndGgxID09PSAwKSB7XG4gICAgICAgICAgICAgICAgY3VzdG9tQ3Vyc29yID0gZGVzdCAtIChsZW5ndGgyIC0gMSk7XG5cbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoMjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGFycmF5W2N1c3RvbUN1cnNvciArIGldID0gdG1wW2ldO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGxlbmd0aDIgPT09IDEpIHtcbiAgICAgICAgICAgICAgICBkZXN0IC09IGxlbmd0aDE7XG4gICAgICAgICAgICAgICAgY3Vyc29yMSAtPSBsZW5ndGgxO1xuICAgICAgICAgICAgICAgIGN1c3RvbURlc3QgPSBkZXN0ICsgMTtcbiAgICAgICAgICAgICAgICBjdXN0b21DdXJzb3IgPSBjdXJzb3IxICsgMTtcblxuICAgICAgICAgICAgICAgIGZvciAoaSA9IGxlbmd0aDEgLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgICAgICBhcnJheVtjdXN0b21EZXN0ICsgaV0gPSBhcnJheVtjdXN0b21DdXJzb3IgKyBpXTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBhcnJheVtkZXN0XSA9IHRtcFtjdXJzb3IyXTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBfbWluR2FsbG9wID0gbWluR2FsbG9wO1xuXG4gICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgICAgIHZhciBjb3VudDEgPSAwO1xuICAgICAgICAgICAgICAgIHZhciBjb3VudDIgPSAwO1xuICAgICAgICAgICAgICAgIHZhciBleGl0ID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb21wYXJlKHRtcFtjdXJzb3IyXSwgYXJyYXlbY3Vyc29yMV0pIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJyYXlbZGVzdC0tXSA9IGFycmF5W2N1cnNvcjEtLV07XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudDErKztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50MiA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoLS1sZW5ndGgxID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhpdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcnJheVtkZXN0LS1dID0gdG1wW2N1cnNvcjItLV07XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudDIrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50MSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoLS1sZW5ndGgyID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhpdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IHdoaWxlICgoY291bnQxIHwgY291bnQyKSA8IF9taW5HYWxsb3ApO1xuXG4gICAgICAgICAgICAgICAgaWYgKGV4aXQpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICBjb3VudDEgPSBsZW5ndGgxIC0gZ2FsbG9wUmlnaHQodG1wW2N1cnNvcjJdLCBhcnJheSwgc3RhcnQxLCBsZW5ndGgxLCBsZW5ndGgxIC0gMSwgY29tcGFyZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvdW50MSAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVzdCAtPSBjb3VudDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3IxIC09IGNvdW50MTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlbmd0aDEgLT0gY291bnQxO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VzdG9tRGVzdCA9IGRlc3QgKyAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VzdG9tQ3Vyc29yID0gY3Vyc29yMSArIDE7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IGNvdW50MSAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJyYXlbY3VzdG9tRGVzdCArIGldID0gYXJyYXlbY3VzdG9tQ3Vyc29yICsgaV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsZW5ndGgxID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhpdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBhcnJheVtkZXN0LS1dID0gdG1wW2N1cnNvcjItLV07XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKC0tbGVuZ3RoMiA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXhpdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGNvdW50MiA9IGxlbmd0aDIgLSBnYWxsb3BMZWZ0KGFycmF5W2N1cnNvcjFdLCB0bXAsIDAsIGxlbmd0aDIsIGxlbmd0aDIgLSAxLCBjb21wYXJlKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoY291bnQyICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZXN0IC09IGNvdW50MjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvcjIgLT0gY291bnQyO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVuZ3RoMiAtPSBjb3VudDI7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXN0b21EZXN0ID0gZGVzdCArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXN0b21DdXJzb3IgPSBjdXJzb3IyICsgMTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGNvdW50MjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJyYXlbY3VzdG9tRGVzdCArIGldID0gdG1wW2N1c3RvbUN1cnNvciArIGldO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobGVuZ3RoMiA8PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhpdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBhcnJheVtkZXN0LS1dID0gYXJyYXlbY3Vyc29yMS0tXTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoLS1sZW5ndGgxID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBleGl0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgX21pbkdhbGxvcC0tO1xuICAgICAgICAgICAgICAgIH0gd2hpbGUgKGNvdW50MSA+PSBERUZBVUxUX01JTl9HQUxMT1BJTkcgfHwgY291bnQyID49IERFRkFVTFRfTUlOX0dBTExPUElORyk7XG5cbiAgICAgICAgICAgICAgICBpZiAoZXhpdCkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoX21pbkdhbGxvcCA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgX21pbkdhbGxvcCA9IDA7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgX21pbkdhbGxvcCArPSAyO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtaW5HYWxsb3AgPSBfbWluR2FsbG9wO1xuXG4gICAgICAgICAgICBpZiAobWluR2FsbG9wIDwgMSkge1xuICAgICAgICAgICAgICAgIG1pbkdhbGxvcCA9IDE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChsZW5ndGgyID09PSAxKSB7XG4gICAgICAgICAgICAgICAgZGVzdCAtPSBsZW5ndGgxO1xuICAgICAgICAgICAgICAgIGN1cnNvcjEgLT0gbGVuZ3RoMTtcbiAgICAgICAgICAgICAgICBjdXN0b21EZXN0ID0gZGVzdCArIDE7XG4gICAgICAgICAgICAgICAgY3VzdG9tQ3Vyc29yID0gY3Vyc29yMSArIDE7XG5cbiAgICAgICAgICAgICAgICBmb3IgKGkgPSBsZW5ndGgxIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgYXJyYXlbY3VzdG9tRGVzdCArIGldID0gYXJyYXlbY3VzdG9tQ3Vyc29yICsgaV07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYXJyYXlbZGVzdF0gPSB0bXBbY3Vyc29yMl07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChsZW5ndGgyID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCk7XG4gICAgICAgICAgICAgICAgLy8gdGhyb3cgbmV3IEVycm9yKCdtZXJnZUhpZ2ggcHJlY29uZGl0aW9ucyB3ZXJlIG5vdCByZXNwZWN0ZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGN1c3RvbUN1cnNvciA9IGRlc3QgLSAobGVuZ3RoMiAtIDEpO1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGgyOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgYXJyYXlbY3VzdG9tQ3Vyc29yICsgaV0gPSB0bXBbaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5tZXJnZVJ1bnMgPSBtZXJnZVJ1bnM7XG4gICAgICAgIHRoaXMuZm9yY2VNZXJnZVJ1bnMgPSBmb3JjZU1lcmdlUnVucztcbiAgICAgICAgdGhpcy5wdXNoUnVuID0gcHVzaFJ1bjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzb3J0KGFycmF5LCBjb21wYXJlLCBsbywgaGkpIHtcbiAgICAgICAgaWYgKCFsbykge1xuICAgICAgICAgICAgbG8gPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaGkpIHtcbiAgICAgICAgICAgIGhpID0gYXJyYXkubGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlbWFpbmluZyA9IGhpIC0gbG87XG5cbiAgICAgICAgaWYgKHJlbWFpbmluZyA8IDIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBydW5MZW5ndGggPSAwO1xuXG4gICAgICAgIGlmIChyZW1haW5pbmcgPCBERUZBVUxUX01JTl9NRVJHRSkge1xuICAgICAgICAgICAgcnVuTGVuZ3RoID0gbWFrZUFzY2VuZGluZ1J1bihhcnJheSwgbG8sIGhpLCBjb21wYXJlKTtcbiAgICAgICAgICAgIGJpbmFyeUluc2VydGlvblNvcnQoYXJyYXksIGxvLCBoaSwgbG8gKyBydW5MZW5ndGgsIGNvbXBhcmUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRzID0gbmV3IFRpbVNvcnQoYXJyYXksIGNvbXBhcmUpO1xuXG4gICAgICAgIHZhciBtaW5SdW4gPSBtaW5SdW5MZW5ndGgocmVtYWluaW5nKTtcblxuICAgICAgICBkbyB7XG4gICAgICAgICAgICBydW5MZW5ndGggPSBtYWtlQXNjZW5kaW5nUnVuKGFycmF5LCBsbywgaGksIGNvbXBhcmUpO1xuICAgICAgICAgICAgaWYgKHJ1bkxlbmd0aCA8IG1pblJ1bikge1xuICAgICAgICAgICAgICAgIHZhciBmb3JjZSA9IHJlbWFpbmluZztcbiAgICAgICAgICAgICAgICBpZiAoZm9yY2UgPiBtaW5SdW4pIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yY2UgPSBtaW5SdW47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYmluYXJ5SW5zZXJ0aW9uU29ydChhcnJheSwgbG8sIGxvICsgZm9yY2UsIGxvICsgcnVuTGVuZ3RoLCBjb21wYXJlKTtcbiAgICAgICAgICAgICAgICBydW5MZW5ndGggPSBmb3JjZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdHMucHVzaFJ1bihsbywgcnVuTGVuZ3RoKTtcbiAgICAgICAgICAgIHRzLm1lcmdlUnVucygpO1xuXG4gICAgICAgICAgICByZW1haW5pbmcgLT0gcnVuTGVuZ3RoO1xuICAgICAgICAgICAgbG8gKz0gcnVuTGVuZ3RoO1xuICAgICAgICB9IHdoaWxlIChyZW1haW5pbmcgIT09IDApO1xuXG4gICAgICAgIHRzLmZvcmNlTWVyZ2VSdW5zKCk7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBzb3J0O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34venJlbmRlci9saWIvY29yZS90aW1zb3J0LmpzXG4gKiogbW9kdWxlIGlkID0gNjRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0Jztcbi8qKlxuICog5Yqo55S75Li757G7LCDosIPluqblkoznrqHnkIbmiYDmnInliqjnlLvmjqfliLblmahcbiAqXG4gKiBAbW9kdWxlIHpyZW5kZXIvYW5pbWF0aW9uL0FuaW1hdGlvblxuICogQGF1dGhvciBwaXNzYW5nKGh0dHBzOi8vZ2l0aHViLmNvbS9waXNzYW5nKVxuICovXG4vLyBUT0RPIEFkZGl0aXZlIGFuaW1hdGlvblxuLy8gaHR0cDovL2lvc290ZXJpYy5jb20vYWRkaXRpdmUtYW5pbWF0aW9ucy1hbmltYXRld2l0aGR1cmF0aW9uLWluLWlvcy04L1xuLy8gaHR0cHM6Ly9kZXZlbG9wZXIuYXBwbGUuY29tL3ZpZGVvcy93d2RjMjAxNC8jMjM2XG5cblxuICAgIHZhciB1dGlsID0gcmVxdWlyZSgnLi4vY29yZS91dGlsJyk7XG4gICAgdmFyIERpc3BhdGNoZXIgPSByZXF1aXJlKCcuLi9jb3JlL2V2ZW50JykuRGlzcGF0Y2hlcjtcblxuICAgIHZhciByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSByZXF1aXJlKCcuL3JlcXVlc3RBbmltYXRpb25GcmFtZScpO1xuXG4gICAgdmFyIEFuaW1hdG9yID0gcmVxdWlyZSgnLi9BbmltYXRvcicpO1xuICAgIC8qKlxuICAgICAqIEB0eXBlZGVmIHtPYmplY3R9IElaUmVuZGVyU3RhZ2VcbiAgICAgKiBAcHJvcGVydHkge0Z1bmN0aW9ufSB1cGRhdGVcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEBhbGlhcyBtb2R1bGU6enJlbmRlci9hbmltYXRpb24vQW5pbWF0aW9uXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLm9uZnJhbWVdXG4gICAgICogQHBhcmFtIHtJWlJlbmRlclN0YWdlfSBbb3B0aW9ucy5zdGFnZV1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqICAgICB2YXIgYW5pbWF0aW9uID0gbmV3IEFuaW1hdGlvbigpO1xuICAgICAqICAgICB2YXIgb2JqID0ge1xuICAgICAqICAgICAgICAgeDogMTAwLFxuICAgICAqICAgICAgICAgeTogMTAwXG4gICAgICogICAgIH07XG4gICAgICogICAgIGFuaW1hdGlvbi5hbmltYXRlKG5vZGUucG9zaXRpb24pXG4gICAgICogICAgICAgICAud2hlbigxMDAwLCB7XG4gICAgICogICAgICAgICAgICAgeDogNTAwLFxuICAgICAqICAgICAgICAgICAgIHk6IDUwMFxuICAgICAqICAgICAgICAgfSlcbiAgICAgKiAgICAgICAgIC53aGVuKDIwMDAsIHtcbiAgICAgKiAgICAgICAgICAgICB4OiAxMDAsXG4gICAgICogICAgICAgICAgICAgeTogMTAwXG4gICAgICogICAgICAgICB9KVxuICAgICAqICAgICAgICAgLnN0YXJ0KCdzcGxpbmUnKTtcbiAgICAgKi9cbiAgICB2YXIgQW5pbWF0aW9uID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcblxuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgICAgICB0aGlzLnN0YWdlID0gb3B0aW9ucy5zdGFnZSB8fCB7fTtcblxuICAgICAgICB0aGlzLm9uZnJhbWUgPSBvcHRpb25zLm9uZnJhbWUgfHwgZnVuY3Rpb24oKSB7fTtcblxuICAgICAgICAvLyBwcml2YXRlIHByb3BlcnRpZXNcbiAgICAgICAgdGhpcy5fY2xpcHMgPSBbXTtcblxuICAgICAgICB0aGlzLl9ydW5uaW5nID0gZmFsc2U7XG5cbiAgICAgICAgdGhpcy5fdGltZTtcblxuICAgICAgICB0aGlzLl9wYXVzZWRUaW1lO1xuXG4gICAgICAgIHRoaXMuX3BhdXNlU3RhcnQ7XG5cbiAgICAgICAgdGhpcy5fcGF1c2VkID0gZmFsc2U7XG5cbiAgICAgICAgRGlzcGF0Y2hlci5jYWxsKHRoaXMpO1xuICAgIH07XG5cbiAgICBBbmltYXRpb24ucHJvdG90eXBlID0ge1xuXG4gICAgICAgIGNvbnN0cnVjdG9yOiBBbmltYXRpb24sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmt7vliqAgY2xpcFxuICAgICAgICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL2FuaW1hdGlvbi9DbGlwfSBjbGlwXG4gICAgICAgICAqL1xuICAgICAgICBhZGRDbGlwOiBmdW5jdGlvbiAoY2xpcCkge1xuICAgICAgICAgICAgdGhpcy5fY2xpcHMucHVzaChjbGlwKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOa3u+WKoCBhbmltYXRvclxuICAgICAgICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL2FuaW1hdGlvbi9BbmltYXRvcn0gYW5pbWF0b3JcbiAgICAgICAgICovXG4gICAgICAgIGFkZEFuaW1hdG9yOiBmdW5jdGlvbiAoYW5pbWF0b3IpIHtcbiAgICAgICAgICAgIGFuaW1hdG9yLmFuaW1hdGlvbiA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgY2xpcHMgPSBhbmltYXRvci5nZXRDbGlwcygpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbGlwcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkQ2xpcChjbGlwc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDliKDpmaTliqjnlLvniYfmrrVcbiAgICAgICAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9hbmltYXRpb24vQ2xpcH0gY2xpcFxuICAgICAgICAgKi9cbiAgICAgICAgcmVtb3ZlQ2xpcDogZnVuY3Rpb24oY2xpcCkge1xuICAgICAgICAgICAgdmFyIGlkeCA9IHV0aWwuaW5kZXhPZih0aGlzLl9jbGlwcywgY2xpcCk7XG4gICAgICAgICAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jbGlwcy5zcGxpY2UoaWR4LCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5Yig6Zmk5Yqo55S754mH5q61XG4gICAgICAgICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvYW5pbWF0aW9uL0FuaW1hdG9yfSBhbmltYXRvclxuICAgICAgICAgKi9cbiAgICAgICAgcmVtb3ZlQW5pbWF0b3I6IGZ1bmN0aW9uIChhbmltYXRvcikge1xuICAgICAgICAgICAgdmFyIGNsaXBzID0gYW5pbWF0b3IuZ2V0Q2xpcHMoKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2xpcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZUNsaXAoY2xpcHNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYW5pbWF0b3IuYW5pbWF0aW9uID0gbnVsbDtcbiAgICAgICAgfSxcblxuICAgICAgICBfdXBkYXRlOiBmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgdmFyIHRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKSAtIHRoaXMuX3BhdXNlZFRpbWU7XG4gICAgICAgICAgICB2YXIgZGVsdGEgPSB0aW1lIC0gdGhpcy5fdGltZTtcbiAgICAgICAgICAgIHZhciBjbGlwcyA9IHRoaXMuX2NsaXBzO1xuICAgICAgICAgICAgdmFyIGxlbiA9IGNsaXBzLmxlbmd0aDtcblxuICAgICAgICAgICAgdmFyIGRlZmVycmVkRXZlbnRzID0gW107XG4gICAgICAgICAgICB2YXIgZGVmZXJyZWRDbGlwcyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBjbGlwID0gY2xpcHNbaV07XG4gICAgICAgICAgICAgICAgdmFyIGUgPSBjbGlwLnN0ZXAodGltZSk7XG4gICAgICAgICAgICAgICAgLy8gVGhyb3cgb3V0IHRoZSBldmVudHMgbmVlZCB0byBiZSBjYWxsZWQgYWZ0ZXJcbiAgICAgICAgICAgICAgICAvLyBzdGFnZS51cGRhdGUsIGxpa2UgZGVzdHJveVxuICAgICAgICAgICAgICAgIGlmIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlZmVycmVkRXZlbnRzLnB1c2goZSk7XG4gICAgICAgICAgICAgICAgICAgIGRlZmVycmVkQ2xpcHMucHVzaChjbGlwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgZmluaXNoZWQgY2xpcFxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47KSB7XG4gICAgICAgICAgICAgICAgaWYgKGNsaXBzW2ldLl9uZWVkc1JlbW92ZSkge1xuICAgICAgICAgICAgICAgICAgICBjbGlwc1tpXSA9IGNsaXBzW2xlbiAtIDFdO1xuICAgICAgICAgICAgICAgICAgICBjbGlwcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgbGVuLS07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZW4gPSBkZWZlcnJlZEV2ZW50cy5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZGVmZXJyZWRDbGlwc1tpXS5maXJlKGRlZmVycmVkRXZlbnRzW2ldKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5fdGltZSA9IHRpbWU7XG5cbiAgICAgICAgICAgIHRoaXMub25mcmFtZShkZWx0YSk7XG5cbiAgICAgICAgICAgIHRoaXMudHJpZ2dlcignZnJhbWUnLCBkZWx0YSk7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLnN0YWdlLnVwZGF0ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhZ2UudXBkYXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgX3N0YXJ0TG9vcDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgICAgICB0aGlzLl9ydW5uaW5nID0gdHJ1ZTtcblxuICAgICAgICAgICAgZnVuY3Rpb24gc3RlcCgpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5fcnVubmluZykge1xuXG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShzdGVwKTtcblxuICAgICAgICAgICAgICAgICAgICAhc2VsZi5fcGF1c2VkICYmIHNlbGYuX3VwZGF0ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHN0ZXApO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlvIDlp4vov5DooYzliqjnlLtcbiAgICAgICAgICovXG4gICAgICAgIHN0YXJ0OiBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgIHRoaXMuX3RpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgICAgICAgIHRoaXMuX3BhdXNlZFRpbWUgPSAwO1xuXG4gICAgICAgICAgICB0aGlzLl9zdGFydExvb3AoKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWBnOatoui/kOihjOWKqOeUu1xuICAgICAgICAgKi9cbiAgICAgICAgc3RvcDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5fcnVubmluZyA9IGZhbHNlO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQYXVzZVxuICAgICAgICAgKi9cbiAgICAgICAgcGF1c2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fcGF1c2VkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGF1c2VTdGFydCA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3BhdXNlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlc3VtZVxuICAgICAgICAgKi9cbiAgICAgICAgcmVzdW1lOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fcGF1c2VkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGF1c2VkVGltZSArPSAobmV3IERhdGUoKS5nZXRUaW1lKCkpIC0gdGhpcy5fcGF1c2VTdGFydDtcbiAgICAgICAgICAgICAgICB0aGlzLl9wYXVzZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5riF6Zmk5omA5pyJ5Yqo55S754mH5q61XG4gICAgICAgICAqL1xuICAgICAgICBjbGVhcjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5fY2xpcHMgPSBbXTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWvueS4gOS4quebruagh+WIm+W7uuS4gOS4qmFuaW1hdG9y5a+56LGh77yM5Y+v5Lul5oyH5a6a55uu5qCH5Lit55qE5bGe5oCn5L2/55So5Yqo55S7XG4gICAgICAgICAqIEBwYXJhbSAge09iamVjdH0gdGFyZ2V0XG4gICAgICAgICAqIEBwYXJhbSAge09iamVjdH0gb3B0aW9uc1xuICAgICAgICAgKiBAcGFyYW0gIHtib29sZWFufSBbb3B0aW9ucy5sb29wPWZhbHNlXSDmmK/lkKblvqrnjq/mkq3mlL7liqjnlLtcbiAgICAgICAgICogQHBhcmFtICB7RnVuY3Rpb259IFtvcHRpb25zLmdldHRlcj1udWxsXVxuICAgICAgICAgKiAgICAgICAgIOWmguaenOaMh+WummdldHRlcuWHveaVsO+8jOS8mumAmui/h2dldHRlcuWHveaVsOWPluWxnuaAp+WAvFxuICAgICAgICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gW29wdGlvbnMuc2V0dGVyPW51bGxdXG4gICAgICAgICAqICAgICAgICAg5aaC5p6c5oyH5a6ac2V0dGVy5Ye95pWw77yM5Lya6YCa6L+Hc2V0dGVy5Ye95pWw6K6+572u5bGe5oCn5YC8XG4gICAgICAgICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2FuaW1hdGlvbi9BbmltYXRpb25+QW5pbWF0b3J9XG4gICAgICAgICAqL1xuICAgICAgICAvLyBUT0RPIEdhcFxuICAgICAgICBhbmltYXRlOiBmdW5jdGlvbiAodGFyZ2V0LCBvcHRpb25zKSB7XG4gICAgICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgICAgICAgIHZhciBhbmltYXRvciA9IG5ldyBBbmltYXRvcihcbiAgICAgICAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5sb29wLFxuICAgICAgICAgICAgICAgIG9wdGlvbnMuZ2V0dGVyLFxuICAgICAgICAgICAgICAgIG9wdGlvbnMuc2V0dGVyXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICByZXR1cm4gYW5pbWF0b3I7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdXRpbC5taXhpbihBbmltYXRpb24sIERpc3BhdGNoZXIpO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBBbmltYXRpb247XG5cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3pyZW5kZXIvbGliL2FuaW1hdGlvbi9BbmltYXRpb24uanNcbiAqKiBtb2R1bGUgaWQgPSA2NVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuLyoqXG4gKiDkuovku7bovoXliqnnsbtcbiAqIEBtb2R1bGUgenJlbmRlci9jb3JlL2V2ZW50XG4gKiBAYXV0aG9yIEtlbmVyIChAS2VuZXIt5p6X5bOwLCBrZW5lci5saW5mZW5nQGdtYWlsLmNvbSlcbiAqL1xuXG5cbiAgICB2YXIgRXZlbnRmdWwgPSByZXF1aXJlKCcuLi9taXhpbi9FdmVudGZ1bCcpO1xuXG4gICAgdmFyIGlzRG9tTGV2ZWwyID0gKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSAmJiAhIXdpbmRvdy5hZGRFdmVudExpc3RlbmVyO1xuXG4gICAgZnVuY3Rpb24gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGVsKSB7XG4gICAgICAgIC8vIEJsYWNrQmVycnkgNSwgaU9TIDMgKG9yaWdpbmFsIGlQaG9uZSkgZG9uJ3QgaGF2ZSBnZXRCb3VuZGluZ1JlY3RcbiAgICAgICAgcmV0dXJuIGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCA/IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpIDoge2xlZnQ6IDAsIHRvcDogMH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xpZW50VG9Mb2NhbChlbCwgZSwgb3V0KSB7XG4gICAgICAgIC8vIGNsaWVudFgvY2xpZW50WSBpcyBhY2NvcmRpbmcgdG8gdmlldyBwb3J0LlxuICAgICAgICB2YXIgYm94ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGVsKTtcbiAgICAgICAgb3V0ID0gb3V0IHx8IHt9O1xuICAgICAgICBvdXQuenJYID0gZS5jbGllbnRYIC0gYm94LmxlZnQ7XG4gICAgICAgIG91dC56clkgPSBlLmNsaWVudFkgLSBib3gudG9wO1xuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOWmguaenOWtmOWcqOesrOS4ieaWueW1jOWFpeeahOS4gOS6m2RvbeinpuWPkeeahOS6i+S7tu+8jOaIlnRvdWNo5LqL5Lu277yM6ZyA6KaB6L2s5o2i5LiA5LiL5LqL5Lu25Z2Q5qCHXG4gICAgICovXG4gICAgZnVuY3Rpb24gbm9ybWFsaXplRXZlbnQoZWwsIGUpIHtcblxuICAgICAgICBlID0gZSB8fCB3aW5kb3cuZXZlbnQ7XG5cbiAgICAgICAgaWYgKGUuenJYICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGV2ZW50VHlwZSA9IGUudHlwZTtcbiAgICAgICAgdmFyIGlzVG91Y2ggPSBldmVudFR5cGUgJiYgZXZlbnRUeXBlLmluZGV4T2YoJ3RvdWNoJykgPj0gMDtcblxuICAgICAgICBpZiAoIWlzVG91Y2gpIHtcbiAgICAgICAgICAgIGNsaWVudFRvTG9jYWwoZWwsIGUsIGUpO1xuICAgICAgICAgICAgZS56ckRlbHRhID0gKGUud2hlZWxEZWx0YSkgPyBlLndoZWVsRGVsdGEgLyAxMjAgOiAtKGUuZGV0YWlsIHx8IDApIC8gMztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciB0b3VjaCA9IGV2ZW50VHlwZSAhPSAndG91Y2hlbmQnXG4gICAgICAgICAgICAgICAgPyBlLnRhcmdldFRvdWNoZXNbMF1cbiAgICAgICAgICAgICAgICA6IGUuY2hhbmdlZFRvdWNoZXNbMF07XG4gICAgICAgICAgICB0b3VjaCAmJiBjbGllbnRUb0xvY2FsKGVsLCB0b3VjaCwgZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGRFdmVudExpc3RlbmVyKGVsLCBuYW1lLCBoYW5kbGVyKSB7XG4gICAgICAgIGlmIChpc0RvbUxldmVsMikge1xuICAgICAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcihuYW1lLCBoYW5kbGVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVsLmF0dGFjaEV2ZW50KCdvbicgKyBuYW1lLCBoYW5kbGVyKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlbW92ZUV2ZW50TGlzdGVuZXIoZWwsIG5hbWUsIGhhbmRsZXIpIHtcbiAgICAgICAgaWYgKGlzRG9tTGV2ZWwyKSB7XG4gICAgICAgICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKG5hbWUsIGhhbmRsZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZWwuZGV0YWNoRXZlbnQoJ29uJyArIG5hbWUsIGhhbmRsZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog5YGc5q2i5YaS5rOh5ZKM6Zi75q2i6buY6K6k6KGM5Li6XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvZXZlbnRcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQHBhcmFtIHtFdmVudH0gZSA6IGV2ZW505a+56LGhXG4gICAgICovXG4gICAgdmFyIHN0b3AgPSBpc0RvbUxldmVsMlxuICAgICAgICA/IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgZS5jYW5jZWxCdWJibGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGUucmV0dXJuVmFsdWUgPSBmYWxzZTtcbiAgICAgICAgICAgIGUuY2FuY2VsQnViYmxlID0gdHJ1ZTtcbiAgICAgICAgfTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0ge1xuICAgICAgICBjbGllbnRUb0xvY2FsOiBjbGllbnRUb0xvY2FsLFxuICAgICAgICBub3JtYWxpemVFdmVudDogbm9ybWFsaXplRXZlbnQsXG4gICAgICAgIGFkZEV2ZW50TGlzdGVuZXI6IGFkZEV2ZW50TGlzdGVuZXIsXG4gICAgICAgIHJlbW92ZUV2ZW50TGlzdGVuZXI6IHJlbW92ZUV2ZW50TGlzdGVuZXIsXG5cbiAgICAgICAgc3RvcDogc3RvcCxcbiAgICAgICAgLy8g5YGa5ZCR5LiK5YW85a65XG4gICAgICAgIERpc3BhdGNoZXI6IEV2ZW50ZnVsXG4gICAgfTtcblxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34venJlbmRlci9saWIvY29yZS9ldmVudC5qc1xuICoqIG1vZHVsZSBpZCA9IDY2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcblxuICAgIG1vZHVsZS5leHBvcnRzID0gKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAod2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfHwgd2luZG93Lm1zUmVxdWVzdEFuaW1hdGlvbkZyYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8fCB3aW5kb3cubW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8fCB3aW5kb3cud2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfHwgZnVuY3Rpb24gKGZ1bmMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuYywgMTYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi96cmVuZGVyL2xpYi9hbmltYXRpb24vcmVxdWVzdEFuaW1hdGlvbkZyYW1lLmpzXG4gKiogbW9kdWxlIGlkID0gNjdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlxuXG4gICAgdmFyIGV2ZW50VG9vbCA9IHJlcXVpcmUoJy4uL2NvcmUvZXZlbnQnKTtcbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnLi4vY29yZS91dGlsJyk7XG4gICAgdmFyIEV2ZW50ZnVsID0gcmVxdWlyZSgnLi4vbWl4aW4vRXZlbnRmdWwnKTtcbiAgICB2YXIgZW52ID0gcmVxdWlyZSgnLi4vY29yZS9lbnYnKTtcbiAgICB2YXIgR2VzdHVyZU1nciA9IHJlcXVpcmUoJy4uL2NvcmUvR2VzdHVyZU1ncicpO1xuXG4gICAgdmFyIGFkZEV2ZW50TGlzdGVuZXIgPSBldmVudFRvb2wuYWRkRXZlbnRMaXN0ZW5lcjtcbiAgICB2YXIgcmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGV2ZW50VG9vbC5yZW1vdmVFdmVudExpc3RlbmVyO1xuICAgIHZhciBub3JtYWxpemVFdmVudCA9IGV2ZW50VG9vbC5ub3JtYWxpemVFdmVudDtcblxuICAgIHZhciBUT1VDSF9DTElDS19ERUxBWSA9IDMwMDtcblxuICAgIHZhciBtb3VzZUhhbmRsZXJOYW1lcyA9IFtcbiAgICAgICAgJ2NsaWNrJywgJ2RibGNsaWNrJywgJ21vdXNld2hlZWwnLCAnbW91c2VvdXQnLFxuICAgICAgICAnbW91c2V1cCcsICdtb3VzZWRvd24nLCAnbW91c2Vtb3ZlJ1xuICAgIF07XG5cbiAgICB2YXIgdG91Y2hIYW5kbGVyTmFtZXMgPSBbXG4gICAgICAgICd0b3VjaHN0YXJ0JywgJ3RvdWNoZW5kJywgJ3RvdWNobW92ZSdcbiAgICBdO1xuXG4gICAgZnVuY3Rpb24gZXZlbnROYW1lRml4KG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIChuYW1lID09PSAnbW91c2V3aGVlbCcgJiYgZW52LmJyb3dzZXIuZmlyZWZveCkgPyAnRE9NTW91c2VTY3JvbGwnIDogbmFtZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcm9jZXNzR2VzdHVyZShwcm94eSwgZXZlbnQsIHN0YWdlKSB7XG4gICAgICAgIHZhciBnZXN0dXJlTWdyID0gcHJveHkuX2dlc3R1cmVNZ3I7XG5cbiAgICAgICAgc3RhZ2UgPT09ICdzdGFydCcgJiYgZ2VzdHVyZU1nci5jbGVhcigpO1xuXG4gICAgICAgIHZhciBnZXN0dXJlSW5mbyA9IGdlc3R1cmVNZ3IucmVjb2duaXplKFxuICAgICAgICAgICAgZXZlbnQsXG4gICAgICAgICAgICBwcm94eS5oYW5kbGVyLmZpbmRIb3ZlcihldmVudC56clgsIGV2ZW50LnpyWSwgbnVsbCksXG4gICAgICAgICAgICBwcm94eS5kb21cbiAgICAgICAgKTtcblxuICAgICAgICBzdGFnZSA9PT0gJ2VuZCcgJiYgZ2VzdHVyZU1nci5jbGVhcigpO1xuXG4gICAgICAgIGlmIChnZXN0dXJlSW5mbykge1xuICAgICAgICAgICAgLy8gZXZlbnRUb29sLnN0b3AoZXZlbnQpO1xuICAgICAgICAgICAgdmFyIHR5cGUgPSBnZXN0dXJlSW5mby50eXBlO1xuICAgICAgICAgICAgZXZlbnQuZ2VzdHVyZUV2ZW50ID0gdHlwZTtcblxuICAgICAgICAgICAgcHJveHkuaGFuZGxlci5kaXNwYXRjaFRvRWxlbWVudChnZXN0dXJlSW5mby50YXJnZXQsIHR5cGUsIGdlc3R1cmVJbmZvLmV2ZW50KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFByZXZlbnQgbW91c2UgZXZlbnQgZnJvbSBiZWluZyBkaXNwYXRjaGVkIGFmdGVyIFRvdWNoIEV2ZW50cyBhY3Rpb25cbiAgICAgKiBAc2VlIDxodHRwczovL2dpdGh1Yi5jb20vZGVsdGFrb3NoL2hhbmRqcy9ibG9iL21hc3Rlci9zcmMvaGFuZC5iYXNlLmpzPlxuICAgICAqIDEuIE1vYmlsZSBicm93c2VycyBkaXNwYXRjaCBtb3VzZSBldmVudHMgMzAwbXMgYWZ0ZXIgdG91Y2hlbmQuXG4gICAgICogMi4gQ2hyb21lIGZvciBBbmRyb2lkIGRpc3BhdGNoIG1vdXNlZG93biBmb3IgbG9uZy10b3VjaCBhYm91dCA2NTBtc1xuICAgICAqIFJlc3VsdDogQmxvY2tpbmcgTW91c2UgRXZlbnRzIGZvciA3MDBtcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzZXRUb3VjaFRpbWVyKGluc3RhbmNlKSB7XG4gICAgICAgIGluc3RhbmNlLl90b3VjaGluZyA9IHRydWU7XG4gICAgICAgIGNsZWFyVGltZW91dChpbnN0YW5jZS5fdG91Y2hUaW1lcik7XG4gICAgICAgIGluc3RhbmNlLl90b3VjaFRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpbnN0YW5jZS5fdG91Y2hpbmcgPSBmYWxzZTtcbiAgICAgICAgfSwgNzAwKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1c2VUb3VjaEV2ZW50KCkge1xuICAgICAgICByZXR1cm4gZW52LnRvdWNoRXZlbnRzU3VwcG9ydGVkO1xuICAgIH1cblxuICAgIHZhciBkb21IYW5kbGVycyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1vdXNlIG1vdmUgaGFuZGxlclxuICAgICAgICAgKiBAaW5uZXJcbiAgICAgICAgICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAgICAgICAgICovXG4gICAgICAgIG1vdXNlbW92ZTogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICBldmVudCA9IG5vcm1hbGl6ZUV2ZW50KHRoaXMuZG9tLCBldmVudCk7XG5cbiAgICAgICAgICAgIHRoaXMudHJpZ2dlcignbW91c2Vtb3ZlJywgZXZlbnQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNb3VzZSBvdXQgaGFuZGxlclxuICAgICAgICAgKiBAaW5uZXJcbiAgICAgICAgICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAgICAgICAgICovXG4gICAgICAgIG1vdXNlb3V0OiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIGV2ZW50ID0gbm9ybWFsaXplRXZlbnQodGhpcy5kb20sIGV2ZW50KTtcblxuICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSBldmVudC50b0VsZW1lbnQgfHwgZXZlbnQucmVsYXRlZFRhcmdldDtcbiAgICAgICAgICAgIGlmIChlbGVtZW50ICE9IHRoaXMuZG9tKSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGVsZW1lbnQgJiYgZWxlbWVudC5ub2RlVHlwZSAhPSA5KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIOW/veeVpeWMheWQq+WcqHJvb3TkuK3nmoRkb23lvJXotbfnmoRtb3VzZU91dFxuICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbWVudCA9PT0gdGhpcy5kb20pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQgPSBlbGVtZW50LnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnRyaWdnZXIoJ21vdXNlb3V0JywgZXZlbnQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUb3VjaOW8gOWni+WTjeW6lOWHveaVsFxuICAgICAgICAgKiBAaW5uZXJcbiAgICAgICAgICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAgICAgICAgICovXG4gICAgICAgIHRvdWNoc3RhcnQ6IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgLy8gRGVmYXVsdCBtb3VzZSBiZWhhdmlvdXIgc2hvdWxkIG5vdCBiZSBkaXNhYmxlZCBoZXJlLlxuICAgICAgICAgICAgLy8gRm9yIGV4YW1wbGUsIHBhZ2UgbWF5IG5lZWRzIHRvIGJlIHNsaWRlZC5cblxuICAgICAgICAgICAgZXZlbnQgPSBub3JtYWxpemVFdmVudCh0aGlzLmRvbSwgZXZlbnQpO1xuXG4gICAgICAgICAgICB0aGlzLl9sYXN0VG91Y2hNb21lbnQgPSBuZXcgRGF0ZSgpO1xuXG4gICAgICAgICAgICBwcm9jZXNzR2VzdHVyZSh0aGlzLCBldmVudCwgJ3N0YXJ0Jyk7XG5cbiAgICAgICAgICAgIC8vIOW5s+adv+ihpeWFheS4gOasoWZpbmRIb3ZlclxuICAgICAgICAgICAgLy8gdGhpcy5fbW9iaWxlRmluZEZpeGVkKGV2ZW50KTtcbiAgICAgICAgICAgIC8vIFRyaWdnZXIgbW91c2Vtb3ZlIGFuZCBtb3VzZWRvd25cbiAgICAgICAgICAgIGRvbUhhbmRsZXJzLm1vdXNlbW92ZS5jYWxsKHRoaXMsIGV2ZW50KTtcblxuICAgICAgICAgICAgZG9tSGFuZGxlcnMubW91c2Vkb3duLmNhbGwodGhpcywgZXZlbnQpO1xuXG4gICAgICAgICAgICBzZXRUb3VjaFRpbWVyKHRoaXMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUb3VjaOenu+WKqOWTjeW6lOWHveaVsFxuICAgICAgICAgKiBAaW5uZXJcbiAgICAgICAgICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAgICAgICAgICovXG4gICAgICAgIHRvdWNobW92ZTogZnVuY3Rpb24gKGV2ZW50KSB7XG5cbiAgICAgICAgICAgIGV2ZW50ID0gbm9ybWFsaXplRXZlbnQodGhpcy5kb20sIGV2ZW50KTtcblxuICAgICAgICAgICAgcHJvY2Vzc0dlc3R1cmUodGhpcywgZXZlbnQsICdjaGFuZ2UnKTtcblxuICAgICAgICAgICAgLy8gTW91c2UgbW92ZSBzaG91bGQgYWx3YXlzIGJlIHRyaWdnZXJlZCBubyBtYXR0ZXIgd2hldGhlclxuICAgICAgICAgICAgLy8gdGhlcmUgaXMgZ2VzdHJ1ZSBldmVudCwgYmVjYXVzZSBtb3VzZSBtb3ZlIGFuZCBwaW5jaCBtYXlcbiAgICAgICAgICAgIC8vIGJlIHVzZWQgYXQgdGhlIHNhbWUgdGltZS5cbiAgICAgICAgICAgIGRvbUhhbmRsZXJzLm1vdXNlbW92ZS5jYWxsKHRoaXMsIGV2ZW50KTtcblxuICAgICAgICAgICAgc2V0VG91Y2hUaW1lcih0aGlzKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVG91Y2jnu5PmnZ/lk43lupTlh73mlbBcbiAgICAgICAgICogQGlubmVyXG4gICAgICAgICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gICAgICAgICAqL1xuICAgICAgICB0b3VjaGVuZDogZnVuY3Rpb24gKGV2ZW50KSB7XG5cbiAgICAgICAgICAgIGV2ZW50ID0gbm9ybWFsaXplRXZlbnQodGhpcy5kb20sIGV2ZW50KTtcblxuICAgICAgICAgICAgcHJvY2Vzc0dlc3R1cmUodGhpcywgZXZlbnQsICdlbmQnKTtcblxuICAgICAgICAgICAgZG9tSGFuZGxlcnMubW91c2V1cC5jYWxsKHRoaXMsIGV2ZW50KTtcblxuICAgICAgICAgICAgLy8gY2xpY2sgZXZlbnQgc2hvdWxkIGFsd2F5cyBiZSB0cmlnZ2VyZWQgbm8gbWF0dGVyIHdoZXRoZXJcbiAgICAgICAgICAgIC8vIHRoZXJlIGlzIGdlc3RydWUgZXZlbnQuIFN5c3RlbSBjbGljayBjYW4gbm90IGJlIHByZXZlbnRlZC5cbiAgICAgICAgICAgIGlmICgrbmV3IERhdGUoKSAtIHRoaXMuX2xhc3RUb3VjaE1vbWVudCA8IFRPVUNIX0NMSUNLX0RFTEFZKSB7XG4gICAgICAgICAgICAgICAgZG9tSGFuZGxlcnMuY2xpY2suY2FsbCh0aGlzLCBldmVudCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNldFRvdWNoVGltZXIodGhpcyk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gQ29tbW9uIGhhbmRsZXJzXG4gICAgenJVdGlsLmVhY2goWydjbGljaycsICdtb3VzZWRvd24nLCAnbW91c2V1cCcsICdtb3VzZXdoZWVsJywgJ2RibGNsaWNrJ10sIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIGRvbUhhbmRsZXJzW25hbWVdID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICBldmVudCA9IG5vcm1hbGl6ZUV2ZW50KHRoaXMuZG9tLCBldmVudCk7XG4gICAgICAgICAgICB0aGlzLnRyaWdnZXIobmFtZSwgZXZlbnQpO1xuICAgICAgICB9O1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICog5Li65o6n5Yi257G75a6e5L6L5Yid5aeL5YyWZG9tIOS6i+S7tuWkhOeQhuWHveaVsFxuICAgICAqXG4gICAgICogQGlubmVyXG4gICAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9IYW5kbGVyfSBpbnN0YW5jZSDmjqfliLbnsbvlrp7kvotcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbml0RG9tSGFuZGxlcihpbnN0YW5jZSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRvdWNoSGFuZGxlck5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgbmFtZSA9IHRvdWNoSGFuZGxlck5hbWVzW2ldO1xuICAgICAgICAgICAgaW5zdGFuY2UuX2hhbmRsZXJzW25hbWVdID0genJVdGlsLmJpbmQoZG9tSGFuZGxlcnNbbmFtZV0sIGluc3RhbmNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbW91c2VIYW5kbGVyTmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBuYW1lID0gbW91c2VIYW5kbGVyTmFtZXNbaV07XG4gICAgICAgICAgICBpbnN0YW5jZS5faGFuZGxlcnNbbmFtZV0gPSBtYWtlTW91c2VIYW5kbGVyKGRvbUhhbmRsZXJzW25hbWVdLCBpbnN0YW5jZSk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBtYWtlTW91c2VIYW5kbGVyKGZuLCBpbnN0YW5jZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5zdGFuY2UuX3RvdWNoaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZuLmFwcGx5KGluc3RhbmNlLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgZnVuY3Rpb24gSGFuZGxlckRvbVByb3h5KGRvbSkge1xuICAgICAgICBFdmVudGZ1bC5jYWxsKHRoaXMpO1xuXG4gICAgICAgIHRoaXMuZG9tID0gZG9tO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3RvdWNoaW5nID0gZmFsc2U7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl90b3VjaFRpbWVyO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAdHlwZSB7bW9kdWxlOnpyZW5kZXIvY29yZS9HZXN0dXJlTWdyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fZ2VzdHVyZU1nciA9IG5ldyBHZXN0dXJlTWdyKCk7XG5cbiAgICAgICAgdGhpcy5faGFuZGxlcnMgPSB7fTtcblxuICAgICAgICBpbml0RG9tSGFuZGxlcih0aGlzKTtcblxuICAgICAgICBpZiAodXNlVG91Y2hFdmVudCgpKSB7XG4gICAgICAgICAgICBtb3VudEhhbmRsZXJzKHRvdWNoSGFuZGxlck5hbWVzLCB0aGlzKTtcblxuICAgICAgICAgICAgLy8gSGFuZGxlciBvZiAnbW91c2VvdXQnIGV2ZW50IGlzIG5lZWRlZCBpbiB0b3VjaCBtb2RlLCB3aGljaCB3aWxsIGJlIG1vdW50ZWQgYmVsb3cuXG4gICAgICAgICAgICAvLyBhZGRFdmVudExpc3RlbmVyKHJvb3QsICdtb3VzZW91dCcsIHRoaXMuX21vdXNlb3V0SGFuZGxlcik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDb25zaWRlcmluZyBzb21lIGRldmljZXMgdGhhdCBib3RoIGVuYWJsZSB0b3VjaCBhbmQgbW91c2UgZXZlbnQgKGxpa2UgTVMgU3VyZmFjZVxuICAgICAgICAvLyBhbmQgbGVub3ZvIFgyNDAsIEBzZWUgIzIzNTApLCB3ZSBtYWtlIG1vdXNlIGV2ZW50IGJlIGFsd2F5cyBsaXN0ZW5lZCwgb3RoZXJ3aXNlXG4gICAgICAgIC8vIG1vdXNlIGV2ZW50IGNhbiBub3QgYmUgaGFuZGxlIGluIHRob3NlIGRldmljZXMuXG4gICAgICAgIG1vdW50SGFuZGxlcnMobW91c2VIYW5kbGVyTmFtZXMsIHRoaXMpO1xuXG4gICAgICAgIGZ1bmN0aW9uIG1vdW50SGFuZGxlcnMoaGFuZGxlck5hbWVzLCBpbnN0YW5jZSkge1xuICAgICAgICAgICAgenJVdGlsLmVhY2goaGFuZGxlck5hbWVzLCBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgICAgIGFkZEV2ZW50TGlzdGVuZXIoZG9tLCBldmVudE5hbWVGaXgobmFtZSksIGluc3RhbmNlLl9oYW5kbGVyc1tuYW1lXSk7XG4gICAgICAgICAgICB9LCBpbnN0YW5jZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgaGFuZGxlckRvbVByb3h5UHJvdG8gPSBIYW5kbGVyRG9tUHJveHkucHJvdG90eXBlO1xuICAgIGhhbmRsZXJEb21Qcm94eVByb3RvLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBoYW5kbGVyTmFtZXMgPSBtb3VzZUhhbmRsZXJOYW1lcy5jb25jYXQodG91Y2hIYW5kbGVyTmFtZXMpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaGFuZGxlck5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgbmFtZSA9IGhhbmRsZXJOYW1lc1tpXTtcbiAgICAgICAgICAgIHJlbW92ZUV2ZW50TGlzdGVuZXIodGhpcy5kb20sIGV2ZW50TmFtZUZpeChuYW1lKSwgdGhpcy5faGFuZGxlcnNbbmFtZV0pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGhhbmRsZXJEb21Qcm94eVByb3RvLnNldEN1cnNvciA9IGZ1bmN0aW9uIChjdXJzb3JTdHlsZSkge1xuICAgICAgICB0aGlzLmRvbS5zdHlsZS5jdXJzb3IgPSBjdXJzb3JTdHlsZSB8fCAnZGVmYXVsdCc7XG4gICAgfTtcblxuICAgIHpyVXRpbC5taXhpbihIYW5kbGVyRG9tUHJveHksIEV2ZW50ZnVsKTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gSGFuZGxlckRvbVByb3h5O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34venJlbmRlci9saWIvZG9tL0hhbmRsZXJQcm94eS5qc1xuICoqIG1vZHVsZSBpZCA9IDY4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG4vKipcbiAqIE9ubHkgaW1wbGVtZW50cyBuZWVkZWQgZ2VzdHVyZXMgZm9yIG1vYmlsZS5cbiAqL1xuXG5cbiAgICB2YXIgZXZlbnRVdGlsID0gcmVxdWlyZSgnLi9ldmVudCcpO1xuXG4gICAgdmFyIEdlc3R1cmVNZ3IgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEB0eXBlIHtBcnJheS48T2JqZWN0Pn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3RyYWNrID0gW107XG4gICAgfTtcblxuICAgIEdlc3R1cmVNZ3IucHJvdG90eXBlID0ge1xuXG4gICAgICAgIGNvbnN0cnVjdG9yOiBHZXN0dXJlTWdyLFxuXG4gICAgICAgIHJlY29nbml6ZTogZnVuY3Rpb24gKGV2ZW50LCB0YXJnZXQsIHJvb3QpIHtcbiAgICAgICAgICAgIHRoaXMuX2RvVHJhY2soZXZlbnQsIHRhcmdldCwgcm9vdCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVjb2duaXplKGV2ZW50KTtcbiAgICAgICAgfSxcblxuICAgICAgICBjbGVhcjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5fdHJhY2subGVuZ3RoID0gMDtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9kb1RyYWNrOiBmdW5jdGlvbiAoZXZlbnQsIHRhcmdldCwgcm9vdCkge1xuICAgICAgICAgICAgdmFyIHRvdWNoZXMgPSBldmVudC50b3VjaGVzO1xuXG4gICAgICAgICAgICBpZiAoIXRvdWNoZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciB0cmFja0l0ZW0gPSB7XG4gICAgICAgICAgICAgICAgcG9pbnRzOiBbXSxcbiAgICAgICAgICAgICAgICB0b3VjaGVzOiBbXSxcbiAgICAgICAgICAgICAgICB0YXJnZXQ6IHRhcmdldCxcbiAgICAgICAgICAgICAgICBldmVudDogZXZlbnRcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0b3VjaGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRvdWNoID0gdG91Y2hlc1tpXTtcbiAgICAgICAgICAgICAgICB2YXIgcG9zID0gZXZlbnRVdGlsLmNsaWVudFRvTG9jYWwocm9vdCwgdG91Y2gpO1xuICAgICAgICAgICAgICAgIHRyYWNrSXRlbS5wb2ludHMucHVzaChbcG9zLnpyWCwgcG9zLnpyWV0pO1xuICAgICAgICAgICAgICAgIHRyYWNrSXRlbS50b3VjaGVzLnB1c2godG91Y2gpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl90cmFjay5wdXNoKHRyYWNrSXRlbSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX3JlY29nbml6ZTogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICBmb3IgKHZhciBldmVudE5hbWUgaW4gcmVjb2duaXplcnMpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVjb2duaXplcnMuaGFzT3duUHJvcGVydHkoZXZlbnROYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZ2VzdHVyZUluZm8gPSByZWNvZ25pemVyc1tldmVudE5hbWVdKHRoaXMuX3RyYWNrLCBldmVudCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChnZXN0dXJlSW5mbykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdlc3R1cmVJbmZvO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGRpc3QocG9pbnRQYWlyKSB7XG4gICAgICAgIHZhciBkeCA9IHBvaW50UGFpclsxXVswXSAtIHBvaW50UGFpclswXVswXTtcbiAgICAgICAgdmFyIGR5ID0gcG9pbnRQYWlyWzFdWzFdIC0gcG9pbnRQYWlyWzBdWzFdO1xuXG4gICAgICAgIHJldHVybiBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNlbnRlcihwb2ludFBhaXIpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIChwb2ludFBhaXJbMF1bMF0gKyBwb2ludFBhaXJbMV1bMF0pIC8gMixcbiAgICAgICAgICAgIChwb2ludFBhaXJbMF1bMV0gKyBwb2ludFBhaXJbMV1bMV0pIC8gMlxuICAgICAgICBdO1xuICAgIH1cblxuICAgIHZhciByZWNvZ25pemVycyA9IHtcblxuICAgICAgICBwaW5jaDogZnVuY3Rpb24gKHRyYWNrLCBldmVudCkge1xuICAgICAgICAgICAgdmFyIHRyYWNrTGVuID0gdHJhY2subGVuZ3RoO1xuXG4gICAgICAgICAgICBpZiAoIXRyYWNrTGVuKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgcGluY2hFbmQgPSAodHJhY2tbdHJhY2tMZW4gLSAxXSB8fCB7fSkucG9pbnRzO1xuICAgICAgICAgICAgdmFyIHBpbmNoUHJlID0gKHRyYWNrW3RyYWNrTGVuIC0gMl0gfHwge30pLnBvaW50cyB8fCBwaW5jaEVuZDtcblxuICAgICAgICAgICAgaWYgKHBpbmNoUHJlXG4gICAgICAgICAgICAgICAgJiYgcGluY2hQcmUubGVuZ3RoID4gMVxuICAgICAgICAgICAgICAgICYmIHBpbmNoRW5kXG4gICAgICAgICAgICAgICAgJiYgcGluY2hFbmQubGVuZ3RoID4gMVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBpbmNoU2NhbGUgPSBkaXN0KHBpbmNoRW5kKSAvIGRpc3QocGluY2hQcmUpO1xuICAgICAgICAgICAgICAgICFpc0Zpbml0ZShwaW5jaFNjYWxlKSAmJiAocGluY2hTY2FsZSA9IDEpO1xuXG4gICAgICAgICAgICAgICAgZXZlbnQucGluY2hTY2FsZSA9IHBpbmNoU2NhbGU7XG5cbiAgICAgICAgICAgICAgICB2YXIgcGluY2hDZW50ZXIgPSBjZW50ZXIocGluY2hFbmQpO1xuICAgICAgICAgICAgICAgIGV2ZW50LnBpbmNoWCA9IHBpbmNoQ2VudGVyWzBdO1xuICAgICAgICAgICAgICAgIGV2ZW50LnBpbmNoWSA9IHBpbmNoQ2VudGVyWzFdO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3BpbmNoJyxcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiB0cmFja1swXS50YXJnZXQsXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50OiBldmVudFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBPbmx5IHBpbmNoIGN1cnJlbnRseS5cbiAgICB9O1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBHZXN0dXJlTWdyO1xuXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi96cmVuZGVyL2xpYi9jb3JlL0dlc3R1cmVNZ3IuanNcbiAqKiBtb2R1bGUgaWQgPSA2OVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuLyoqXG4gKiBEZWZhdWx0IGNhbnZhcyBwYWludGVyXG4gKiBAbW9kdWxlIHpyZW5kZXIvUGFpbnRlclxuICogQGF1dGhvciBLZW5lciAoQEtlbmVyLeael+WzsCwga2VuZXIubGluZmVuZ0BnbWFpbC5jb20pXG4gKiAgICAgICAgIGVycm9ycmlrIChlcnJvcnJpa0BnbWFpbC5jb20pXG4gKiAgICAgICAgIHBpc3NhbmcgKGh0dHBzOi8vd3d3LmdpdGh1Yi5jb20vcGlzc2FuZylcbiAqL1xuIFxuXG4gICAgdmFyIGNvbmZpZyA9IHJlcXVpcmUoJy4vY29uZmlnJyk7XG4gICAgdmFyIHV0aWwgPSByZXF1aXJlKCcuL2NvcmUvdXRpbCcpO1xuICAgIHZhciBsb2cgPSByZXF1aXJlKCcuL2NvcmUvbG9nJyk7XG4gICAgdmFyIEJvdW5kaW5nUmVjdCA9IHJlcXVpcmUoJy4vY29yZS9Cb3VuZGluZ1JlY3QnKTtcbiAgICB2YXIgdGltc29ydCA9IHJlcXVpcmUoJy4vY29yZS90aW1zb3J0Jyk7XG5cbiAgICB2YXIgTGF5ZXIgPSByZXF1aXJlKCcuL0xheWVyJyk7XG5cbiAgICB2YXIgcmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gcmVxdWlyZSgnLi9hbmltYXRpb24vcmVxdWVzdEFuaW1hdGlvbkZyYW1lJyk7XG5cbiAgICAvLyBQRU5ESUdOXG4gICAgLy8gTGF5ZXIgZXhjZWVkcyBNQVhfUFJPR1JFU1NJVkVfTEFZRVJfTlVNQkVSIG1heSBoYXZlIHNvbWUgcHJvYmxlbSB3aGVuIGZsdXNoIGRpcmVjdGx5IHNlY29uZCB0aW1lLlxuICAgIC8vXG4gICAgLy8gTWF4aW11bSBwcm9ncmVzc2l2ZSBsYXllci4gV2hlbiBleGNlZWRpbmcgdGhpcyBudW1iZXIuIEFsbCBlbGVtZW50cyB3aWxsIGJlIGRyYXdlZCBpbiB0aGUgbGFzdCBsYXllci5cbiAgICB2YXIgTUFYX1BST0dSRVNTSVZFX0xBWUVSX05VTUJFUiA9IDU7XG5cbiAgICBmdW5jdGlvbiBwYXJzZUludDEwKHZhbCkge1xuICAgICAgICByZXR1cm4gcGFyc2VJbnQodmFsLCAxMCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNMYXllclZhbGlkKGxheWVyKSB7XG4gICAgICAgIGlmICghbGF5ZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsYXllci5pc0J1aWxkaW4pIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZihsYXllci5yZXNpemUpICE9PSAnZnVuY3Rpb24nXG4gICAgICAgICAgICB8fCB0eXBlb2YobGF5ZXIucmVmcmVzaCkgIT09ICdmdW5jdGlvbidcbiAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcmVQcm9jZXNzTGF5ZXIobGF5ZXIpIHtcbiAgICAgICAgbGF5ZXIuX191bnVzZWRDb3VudCsrO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBvc3RQcm9jZXNzTGF5ZXIobGF5ZXIpIHtcbiAgICAgICAgaWYgKGxheWVyLl9fdW51c2VkQ291bnQgPT0gMSkge1xuICAgICAgICAgICAgbGF5ZXIuY2xlYXIoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciB0bXBSZWN0ID0gbmV3IEJvdW5kaW5nUmVjdCgwLCAwLCAwLCAwKTtcbiAgICB2YXIgdmlld1JlY3QgPSBuZXcgQm91bmRpbmdSZWN0KDAsIDAsIDAsIDApO1xuICAgIGZ1bmN0aW9uIGlzRGlzcGxheWFibGVDdWxsZWQoZWwsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgdG1wUmVjdC5jb3B5KGVsLmdldEJvdW5kaW5nUmVjdCgpKTtcbiAgICAgICAgaWYgKGVsLnRyYW5zZm9ybSkge1xuICAgICAgICAgICAgdG1wUmVjdC5hcHBseVRyYW5zZm9ybShlbC50cmFuc2Zvcm0pO1xuICAgICAgICB9XG4gICAgICAgIHZpZXdSZWN0LndpZHRoID0gd2lkdGg7XG4gICAgICAgIHZpZXdSZWN0LmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgcmV0dXJuICF0bXBSZWN0LmludGVyc2VjdCh2aWV3UmVjdCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNDbGlwUGF0aENoYW5nZWQoY2xpcFBhdGhzLCBwcmV2Q2xpcFBhdGhzKSB7XG4gICAgICAgIGlmIChjbGlwUGF0aHMgPT0gcHJldkNsaXBQYXRocykgeyAvLyBDYW4gYm90aCBiZSBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFjbGlwUGF0aHMgfHwgIXByZXZDbGlwUGF0aHMgfHwgKGNsaXBQYXRocy5sZW5ndGggIT09IHByZXZDbGlwUGF0aHMubGVuZ3RoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbGlwUGF0aHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChjbGlwUGF0aHNbaV0gIT09IHByZXZDbGlwUGF0aHNbaV0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRvQ2xpcChjbGlwUGF0aHMsIGN0eCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNsaXBQYXRocy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGNsaXBQYXRoID0gY2xpcFBhdGhzW2ldO1xuICAgICAgICAgICAgdmFyIHBhdGggPSBjbGlwUGF0aC5wYXRoO1xuXG4gICAgICAgICAgICBjbGlwUGF0aC5zZXRUcmFuc2Zvcm0oY3R4KTtcbiAgICAgICAgICAgIHBhdGguYmVnaW5QYXRoKGN0eCk7XG4gICAgICAgICAgICBjbGlwUGF0aC5idWlsZFBhdGgocGF0aCwgY2xpcFBhdGguc2hhcGUpO1xuICAgICAgICAgICAgY3R4LmNsaXAoKTtcbiAgICAgICAgICAgIC8vIFRyYW5zZm9ybSBiYWNrXG4gICAgICAgICAgICBjbGlwUGF0aC5yZXN0b3JlVHJhbnNmb3JtKGN0eCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVSb290KHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgdmFyIGRvbVJvb3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdmFyIGRvbVJvb3RTdHlsZSA9IGRvbVJvb3Quc3R5bGU7XG5cbiAgICAgICAgLy8gZG9tUm9vdC5vbnNlbGVjdHN0YXJ0ID0gcmV0dXJuRmFsc2U7IC8vIOmBv+WFjemhtemdoumAieS4reeahOWwtOWwrFxuICAgICAgICBkb21Sb290U3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnO1xuICAgICAgICBkb21Sb290U3R5bGUub3ZlcmZsb3cgPSAnaGlkZGVuJztcbiAgICAgICAgZG9tUm9vdFN0eWxlLndpZHRoID0gd2lkdGggKyAncHgnO1xuICAgICAgICBkb21Sb290U3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgJ3B4JztcbiAgICAgICAgcmV0dXJuIGRvbVJvb3Q7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGFsaWFzIG1vZHVsZTp6cmVuZGVyL1BhaW50ZXJcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSByb290IOe7mOWbvuWuueWZqFxuICAgICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvU3RvcmFnZX0gc3RvcmFnZVxuICAgICAqIEBwYXJhbSB7T2piZWN0fSBvcHRzXG4gICAgICovXG4gICAgdmFyIFBhaW50ZXIgPSBmdW5jdGlvbiAocm9vdCwgc3RvcmFnZSwgb3B0cykge1xuICAgICAgICAvLyBJbiBub2RlIGVudmlyb25tZW50IHVzaW5nIG5vZGUtY2FudmFzXG4gICAgICAgIHZhciBzaW5nbGVDYW52YXMgPSAhcm9vdC5ub2RlTmFtZSAvLyBJbiBub2RlID9cbiAgICAgICAgICAgIHx8IHJvb3Qubm9kZU5hbWUudG9VcHBlckNhc2UoKSA9PT0gJ0NBTlZBUyc7XG5cbiAgICAgICAgb3B0cyA9IG9wdHMgfHwge307XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRwciA9IG9wdHMuZGV2aWNlUGl4ZWxSYXRpbyB8fCBjb25maWcuZGV2aWNlUGl4ZWxSYXRpbztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fc2luZ2xlQ2FudmFzID0gc2luZ2xlQ2FudmFzO1xuICAgICAgICAvKipcbiAgICAgICAgICog57uY5Zu+5a655ZmoXG4gICAgICAgICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucm9vdCA9IHJvb3Q7XG5cbiAgICAgICAgdmFyIHJvb3RTdHlsZSA9IHJvb3Quc3R5bGU7XG5cbiAgICAgICAgaWYgKHJvb3RTdHlsZSkge1xuICAgICAgICAgICAgcm9vdFN0eWxlWyctd2Via2l0LXRhcC1oaWdobGlnaHQtY29sb3InXSA9ICd0cmFuc3BhcmVudCc7XG4gICAgICAgICAgICByb290U3R5bGVbJy13ZWJraXQtdXNlci1zZWxlY3QnXSA9XG4gICAgICAgICAgICByb290U3R5bGVbJ3VzZXItc2VsZWN0J10gPVxuICAgICAgICAgICAgcm9vdFN0eWxlWyctd2Via2l0LXRvdWNoLWNhbGxvdXQnXSA9ICdub25lJztcblxuICAgICAgICAgICAgcm9vdC5pbm5lckhUTUwgPSAnJztcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7bW9kdWxlOnpyZW5kZXIvU3RvcmFnZX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3RvcmFnZSA9IHN0b3JhZ2U7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtBcnJheS48bnVtYmVyPn1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHZhciB6bGV2ZWxMaXN0ID0gdGhpcy5femxldmVsTGlzdCA9IFtdO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsIG1vZHVsZTp6cmVuZGVyL0xheWVyPn1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHZhciBsYXllcnMgPSB0aGlzLl9sYXllcnMgPSB7fTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge09iamVjdC48c3RyaW5nLCBPYmplY3Q+fVxuICAgICAgICAgKiBAdHlwZSB7cHJpdmF0ZX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2xheWVyQ29uZmlnID0ge307XG5cbiAgICAgICAgaWYgKCFzaW5nbGVDYW52YXMpIHtcbiAgICAgICAgICAgIHRoaXMuX3dpZHRoID0gdGhpcy5fZ2V0V2lkdGgoKTtcbiAgICAgICAgICAgIHRoaXMuX2hlaWdodCA9IHRoaXMuX2dldEhlaWdodCgpO1xuXG4gICAgICAgICAgICB2YXIgZG9tUm9vdCA9IHRoaXMuX2RvbVJvb3QgPSBjcmVhdGVSb290KFxuICAgICAgICAgICAgICAgIHRoaXMuX3dpZHRoLCB0aGlzLl9oZWlnaHRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICByb290LmFwcGVuZENoaWxkKGRvbVJvb3QpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gVXNlIGNhbnZhcyB3aWR0aCBhbmQgaGVpZ2h0IGRpcmVjdGx5XG4gICAgICAgICAgICB2YXIgd2lkdGggPSByb290LndpZHRoO1xuICAgICAgICAgICAgdmFyIGhlaWdodCA9IHJvb3QuaGVpZ2h0O1xuICAgICAgICAgICAgdGhpcy5fd2lkdGggPSB3aWR0aDtcbiAgICAgICAgICAgIHRoaXMuX2hlaWdodCA9IGhlaWdodDtcblxuICAgICAgICAgICAgLy8gQ3JlYXRlIGxheWVyIGlmIG9ubHkgb25lIGdpdmVuIGNhbnZhc1xuICAgICAgICAgICAgLy8gRGV2aWNlIHBpeGVsIHJhdGlvIGlzIGZpeGVkIHRvIDEgYmVjYXVzZSBnaXZlbiBjYW52YXMgaGFzIGl0cyBzcGVjaWZpZWQgd2lkdGggYW5kIGhlaWdodFxuICAgICAgICAgICAgdmFyIG1haW5MYXllciA9IG5ldyBMYXllcihyb290LCB0aGlzLCAxKTtcbiAgICAgICAgICAgIG1haW5MYXllci5pbml0Q29udGV4dCgpO1xuICAgICAgICAgICAgLy8gRklYTUUgVXNlIGNhbnZhcyB3aWR0aCBhbmQgaGVpZ2h0XG4gICAgICAgICAgICAvLyBtYWluTGF5ZXIucmVzaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgICAgbGF5ZXJzWzBdID0gbWFpbkxheWVyO1xuICAgICAgICAgICAgemxldmVsTGlzdC5wdXNoKDApO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5wYXRoVG9JbWFnZSA9IHRoaXMuX2NyZWF0ZVBhdGhUb0ltYWdlKCk7XG5cbiAgICAgICAgLy8gTGF5ZXJzIGZvciBwcm9ncmVzc2l2ZSByZW5kZXJpbmdcbiAgICAgICAgdGhpcy5fcHJvZ3Jlc3NpdmVMYXllcnMgPSBbXTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge21vZHVsZTp6cmVuZGVyL0xheWVyfVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5faG92ZXJsYXllcjtcblxuICAgICAgICB0aGlzLl9ob3ZlckVsZW1lbnRzID0gW107XG4gICAgfTtcblxuICAgIFBhaW50ZXIucHJvdG90eXBlID0ge1xuXG4gICAgICAgIGNvbnN0cnVjdG9yOiBQYWludGVyLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiBwYWludGVyIHVzZSBhIHNpbmdsZSBjYW52YXNcbiAgICAgICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIGlzU2luZ2xlQ2FudmFzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2luZ2xlQ2FudmFzO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7SFRNTERpdkVsZW1lbnR9XG4gICAgICAgICAqL1xuICAgICAgICBnZXRWaWV3cG9ydFJvb3Q6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zaW5nbGVDYW52YXMgPyB0aGlzLl9sYXllcnNbMF0uZG9tIDogdGhpcy5fZG9tUm9vdDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5Yi35pawXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3BhaW50QWxsPWZhbHNlXSDlvLrliLbnu5jliLbmiYDmnIlkaXNwbGF5YWJsZVxuICAgICAgICAgKi9cbiAgICAgICAgcmVmcmVzaDogZnVuY3Rpb24gKHBhaW50QWxsKSB7XG5cbiAgICAgICAgICAgIHZhciBsaXN0ID0gdGhpcy5zdG9yYWdlLmdldERpc3BsYXlMaXN0KHRydWUpO1xuXG4gICAgICAgICAgICB2YXIgemxldmVsTGlzdCA9IHRoaXMuX3psZXZlbExpc3Q7XG5cbiAgICAgICAgICAgIHRoaXMuX3BhaW50TGlzdChsaXN0LCBwYWludEFsbCk7XG5cbiAgICAgICAgICAgIC8vIFBhaW50IGN1c3R1bSBsYXllcnNcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgemxldmVsTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciB6ID0gemxldmVsTGlzdFtpXTtcbiAgICAgICAgICAgICAgICB2YXIgbGF5ZXIgPSB0aGlzLl9sYXllcnNbel07XG4gICAgICAgICAgICAgICAgaWYgKCFsYXllci5pc0J1aWxkaW4gJiYgbGF5ZXIucmVmcmVzaCkge1xuICAgICAgICAgICAgICAgICAgICBsYXllci5yZWZyZXNoKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnJlZnJlc2hIb3ZlcigpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5fcHJvZ3Jlc3NpdmVMYXllcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhcnRQcm9nZXNzaXZlKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGFkZEhvdmVyOiBmdW5jdGlvbiAoZWwsIGhvdmVyU3R5bGUpIHtcbiAgICAgICAgICAgIGlmIChlbC5fX2hvdmVyTWlyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGVsTWlycm9yID0gbmV3IGVsLmNvbnN0cnVjdG9yKHtcbiAgICAgICAgICAgICAgICBzdHlsZTogZWwuc3R5bGUsXG4gICAgICAgICAgICAgICAgc2hhcGU6IGVsLnNoYXBlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGVsTWlycm9yLl9fZnJvbSA9IGVsO1xuICAgICAgICAgICAgZWwuX19ob3Zlck1pciA9IGVsTWlycm9yO1xuICAgICAgICAgICAgZWxNaXJyb3Iuc2V0U3R5bGUoaG92ZXJTdHlsZSk7XG4gICAgICAgICAgICB0aGlzLl9ob3ZlckVsZW1lbnRzLnB1c2goZWxNaXJyb3IpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHJlbW92ZUhvdmVyOiBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgIHZhciBlbE1pcnJvciA9IGVsLl9faG92ZXJNaXI7XG4gICAgICAgICAgICB2YXIgaG92ZXJFbGVtZW50cyA9IHRoaXMuX2hvdmVyRWxlbWVudHM7XG4gICAgICAgICAgICB2YXIgaWR4ID0gdXRpbC5pbmRleE9mKGhvdmVyRWxlbWVudHMsIGVsTWlycm9yKTtcbiAgICAgICAgICAgIGlmIChpZHggPj0gMCkge1xuICAgICAgICAgICAgICAgIGhvdmVyRWxlbWVudHMuc3BsaWNlKGlkeCwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbC5fX2hvdmVyTWlyID0gbnVsbDtcbiAgICAgICAgfSxcblxuICAgICAgICBjbGVhckhvdmVyOiBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgIHZhciBob3ZlckVsZW1lbnRzID0gdGhpcy5faG92ZXJFbGVtZW50cztcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaG92ZXJFbGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBmcm9tID0gaG92ZXJFbGVtZW50c1tpXS5fX2Zyb207XG4gICAgICAgICAgICAgICAgaWYgKGZyb20pIHtcbiAgICAgICAgICAgICAgICAgICAgZnJvbS5fX2hvdmVyTWlyID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBob3ZlckVsZW1lbnRzLmxlbmd0aCA9IDA7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVmcmVzaEhvdmVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgaG92ZXJFbGVtZW50cyA9IHRoaXMuX2hvdmVyRWxlbWVudHM7XG4gICAgICAgICAgICB2YXIgbGVuID0gaG92ZXJFbGVtZW50cy5sZW5ndGg7XG4gICAgICAgICAgICB2YXIgaG92ZXJMYXllciA9IHRoaXMuX2hvdmVybGF5ZXI7XG4gICAgICAgICAgICBob3ZlckxheWVyICYmIGhvdmVyTGF5ZXIuY2xlYXIoKTtcblxuICAgICAgICAgICAgaWYgKCFsZW4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aW1zb3J0KGhvdmVyRWxlbWVudHMsIHRoaXMuc3RvcmFnZS5kaXNwbGF5YWJsZVNvcnRGdW5jKTtcblxuICAgICAgICAgICAgLy8gVXNlIGEgZXh0cmVhbSBsYXJnZSB6bGV2ZWxcbiAgICAgICAgICAgIC8vIEZJWE1FP1xuICAgICAgICAgICAgaWYgKCFob3ZlckxheWVyKSB7XG4gICAgICAgICAgICAgICAgaG92ZXJMYXllciA9IHRoaXMuX2hvdmVybGF5ZXIgPSB0aGlzLmdldExheWVyKDFlNSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBzY29wZSA9IHt9O1xuICAgICAgICAgICAgaG92ZXJMYXllci5jdHguc2F2ZSgpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47KSB7XG4gICAgICAgICAgICAgICAgdmFyIGVsID0gaG92ZXJFbGVtZW50c1tpXTtcbiAgICAgICAgICAgICAgICB2YXIgb3JpZ2luYWxFbCA9IGVsLl9fZnJvbTtcbiAgICAgICAgICAgICAgICAvLyBPcmlnaW5hbCBlbCBpcyByZW1vdmVkXG4gICAgICAgICAgICAgICAgLy8gUEVORElOR1xuICAgICAgICAgICAgICAgIGlmICghKG9yaWdpbmFsRWwgJiYgb3JpZ2luYWxFbC5fX3pyKSkge1xuICAgICAgICAgICAgICAgICAgICBob3ZlckVsZW1lbnRzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxFbC5fX2hvdmVyTWlyID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgbGVuLS07XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpKys7XG5cbiAgICAgICAgICAgICAgICAvLyBVc2UgdHJhbnNmb3JtXG4gICAgICAgICAgICAgICAgLy8gRklYTUUgc3R5bGUgYW5kIHNoYXBlID9cbiAgICAgICAgICAgICAgICBpZiAoIW9yaWdpbmFsRWwuaW52aXNpYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsLnRyYW5zZm9ybSA9IG9yaWdpbmFsRWwudHJhbnNmb3JtO1xuICAgICAgICAgICAgICAgICAgICBlbC5pbnZUcmFuc2Zvcm0gPSBvcmlnaW5hbEVsLmludlRyYW5zZm9ybTtcbiAgICAgICAgICAgICAgICAgICAgZWwuX19jbGlwUGF0aHMgPSBvcmlnaW5hbEVsLl9fY2xpcFBhdGhzO1xuICAgICAgICAgICAgICAgICAgICAvLyBlbC5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZG9QYWludEVsKGVsLCBob3ZlckxheWVyLCB0cnVlLCBzY29wZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaG92ZXJMYXllci5jdHgucmVzdG9yZSgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9zdGFydFByb2dlc3NpdmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICAgICAgaWYgKCFzZWxmLl9mdXJ0aGVyUHJvZ3Jlc3NpdmUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFVzZSBhIHRva2VuIHRvIHN0b3AgcHJvZ3Jlc3Mgc3RlcHMgdHJpZ2dlcmVkIGJ5XG4gICAgICAgICAgICAvLyBwcmV2aW91cyB6ci5yZWZyZXNoIGNhbGxpbmcuXG4gICAgICAgICAgICB2YXIgdG9rZW4gPSBzZWxmLl9wcm9ncmVzc2l2ZVRva2VuID0gK25ldyBEYXRlKCk7XG5cbiAgICAgICAgICAgIHNlbGYuX3Byb2dyZXNzKys7XG4gICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoc3RlcCk7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIHN0ZXAoKSB7XG4gICAgICAgICAgICAgICAgLy8gSW4gY2FzZSByZWZyZXNoZWQgb3IgZGlzcG9zZWRcbiAgICAgICAgICAgICAgICBpZiAodG9rZW4gPT09IHNlbGYuX3Byb2dyZXNzaXZlVG9rZW4gJiYgc2VsZi5zdG9yYWdlKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgc2VsZi5fZG9QYWludExpc3Qoc2VsZi5zdG9yYWdlLmdldERpc3BsYXlMaXN0KCkpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLl9mdXJ0aGVyUHJvZ3Jlc3NpdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX3Byb2dyZXNzKys7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoc3RlcCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9wcm9ncmVzc2l2ZVRva2VuID0gLTE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2NsZWFyUHJvZ3Jlc3NpdmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX3Byb2dyZXNzaXZlVG9rZW4gPSAtMTtcbiAgICAgICAgICAgIHRoaXMuX3Byb2dyZXNzID0gMDtcbiAgICAgICAgICAgIHV0aWwuZWFjaCh0aGlzLl9wcm9ncmVzc2l2ZUxheWVycywgZnVuY3Rpb24gKGxheWVyKSB7XG4gICAgICAgICAgICAgICAgbGF5ZXIuX19kaXJ0eSAmJiBsYXllci5jbGVhcigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX3BhaW50TGlzdDogZnVuY3Rpb24gKGxpc3QsIHBhaW50QWxsKSB7XG5cbiAgICAgICAgICAgIGlmIChwYWludEFsbCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcGFpbnRBbGwgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5fdXBkYXRlTGF5ZXJTdGF0dXMobGlzdCk7XG5cbiAgICAgICAgICAgIHRoaXMuX2NsZWFyUHJvZ3Jlc3NpdmUoKTtcblxuICAgICAgICAgICAgdGhpcy5lYWNoQnVpbGRpbkxheWVyKHByZVByb2Nlc3NMYXllcik7XG5cbiAgICAgICAgICAgIHRoaXMuX2RvUGFpbnRMaXN0KGxpc3QsIHBhaW50QWxsKTtcblxuICAgICAgICAgICAgdGhpcy5lYWNoQnVpbGRpbkxheWVyKHBvc3RQcm9jZXNzTGF5ZXIpO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9kb1BhaW50TGlzdDogZnVuY3Rpb24gKGxpc3QsIHBhaW50QWxsKSB7XG4gICAgICAgICAgICB2YXIgY3VycmVudExheWVyO1xuICAgICAgICAgICAgdmFyIGN1cnJlbnRaTGV2ZWw7XG4gICAgICAgICAgICB2YXIgY3R4O1xuXG4gICAgICAgICAgICAvLyB2YXIgaW52VHJhbnNmb3JtID0gW107XG4gICAgICAgICAgICB2YXIgc2NvcGU7XG5cbiAgICAgICAgICAgIHZhciBwcm9ncmVzc2l2ZUxheWVySWR4ID0gMDtcbiAgICAgICAgICAgIHZhciBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllcjtcblxuICAgICAgICAgICAgdmFyIHdpZHRoID0gdGhpcy5fd2lkdGg7XG4gICAgICAgICAgICB2YXIgaGVpZ2h0ID0gdGhpcy5faGVpZ2h0O1xuICAgICAgICAgICAgdmFyIGxheWVyUHJvZ3Jlc3M7XG4gICAgICAgICAgICB2YXIgZnJhbWUgPSB0aGlzLl9wcm9ncmVzcztcbiAgICAgICAgICAgIGZ1bmN0aW9uIGZsdXNoUHJvZ3Jlc3NpdmVMYXllcihsYXllcikge1xuICAgICAgICAgICAgICAgIHZhciBkcHIgPSBjdHguZHByIHx8IDE7XG4gICAgICAgICAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSAxO1xuICAgICAgICAgICAgICAgIGN0eC5zaGFkb3dCbHVyID0gMDtcbiAgICAgICAgICAgICAgICAvLyBBdm9pZCBsYXllciBkb24ndCBjbGVhciBpbiBuZXh0IHByb2dyZXNzaXZlIGZyYW1lXG4gICAgICAgICAgICAgICAgY3VycmVudExheWVyLl9fZGlydHkgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGN0eC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG4gICAgICAgICAgICAgICAgY3R4LmRyYXdJbWFnZShsYXllci5kb20sIDAsIDAsIHdpZHRoICogZHByLCBoZWlnaHQgKiBkcHIpO1xuICAgICAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gbGlzdC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgZWwgPSBsaXN0W2ldO1xuICAgICAgICAgICAgICAgIHZhciBlbFpMZXZlbCA9IHRoaXMuX3NpbmdsZUNhbnZhcyA/IDAgOiBlbC56bGV2ZWw7XG5cbiAgICAgICAgICAgICAgICB2YXIgZWxGcmFtZSA9IGVsLl9fZnJhbWU7XG5cbiAgICAgICAgICAgICAgICAvLyBGbHVzaCBhdCBjdXJyZW50IGNvbnRleHRcbiAgICAgICAgICAgICAgICAvLyBQRU5ESU5HXG4gICAgICAgICAgICAgICAgaWYgKGVsRnJhbWUgPCAwICYmIGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGZsdXNoUHJvZ3Jlc3NpdmVMYXllcihjdXJyZW50UHJvZ3Jlc3NpdmVMYXllcik7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBDaGFuZ2UgZHJhdyBsYXllclxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50WkxldmVsICE9PSBlbFpMZXZlbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY3R4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gUmVzZXQgc2NvcGVcbiAgICAgICAgICAgICAgICAgICAgc2NvcGUgPSB7fTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBPbmx5IDAgemxldmVsIGlmIG9ubHkgaGFzIG9uZSBjYW52YXNcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFpMZXZlbCA9IGVsWkxldmVsO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50TGF5ZXIgPSB0aGlzLmdldExheWVyKGN1cnJlbnRaTGV2ZWwpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICghY3VycmVudExheWVyLmlzQnVpbGRpbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdaTGV2ZWwgJyArIGN1cnJlbnRaTGV2ZWxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICArICcgaGFzIGJlZW4gdXNlZCBieSB1bmtvd24gbGF5ZXIgJyArIGN1cnJlbnRMYXllci5pZFxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IGN1cnJlbnRMYXllci5jdHg7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5zYXZlKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gUmVzZXQgdGhlIGNvdW50XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRMYXllci5fX3VudXNlZENvdW50ID0gMDtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudExheWVyLl9fZGlydHkgfHwgcGFpbnRBbGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRMYXllci5jbGVhcigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCEoY3VycmVudExheWVyLl9fZGlydHkgfHwgcGFpbnRBbGwpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChlbEZyYW1lID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUHJvZ3Jlc3NpdmUgbGF5ZXIgY2hhbmdlZFxuICAgICAgICAgICAgICAgICAgICBpZiAoIWN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllciA9IHRoaXMuX3Byb2dyZXNzaXZlTGF5ZXJzW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1hdGgubWluKHByb2dyZXNzaXZlTGF5ZXJJZHgrKywgTUFYX1BST0dSRVNTSVZFX0xBWUVSX05VTUJFUiAtIDEpXG4gICAgICAgICAgICAgICAgICAgICAgICBdO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllci5jdHguc2F2ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFByb2dyZXNzaXZlTGF5ZXIucmVuZGVyU2NvcGUgPSB7fTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgKGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyLl9fcHJvZ3Jlc3MgPiBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllci5fX21heFByb2dyZXNzKVxuICAgICAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZmx1c2hQcm9ncmVzc2l2ZUxheWVyKGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBRdWljayBqdW1wIGFsbCBwcm9ncmVzc2l2ZSBlbGVtZW50c1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFsbCBwcm9ncmVzc2l2ZSBlbGVtZW50IGFyZSBub3QgZGlydHksIGp1bXAgb3ZlciBhbmQgZmx1c2ggZGlyZWN0bHlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpID0gY3VycmVudFByb2dyZXNzaXZlTGF5ZXIuX19uZXh0SWR4Tm90UHJvZyAtIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY3VycmVudFByb2dyZXNzaXZlTGF5ZXIgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBsYXllclByb2dyZXNzID0gY3VycmVudFByb2dyZXNzaXZlTGF5ZXIuX19wcm9ncmVzcztcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjdXJyZW50UHJvZ3Jlc3NpdmVMYXllci5fX2RpcnR5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gS2VlcCByZW5kZXJpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcmFtZSA9IGxheWVyUHJvZ3Jlc3M7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyLl9fcHJvZ3Jlc3MgPSBmcmFtZSArIDE7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoZWxGcmFtZSA9PT0gZnJhbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2RvUGFpbnRFbChlbCwgY3VycmVudFByb2dyZXNzaXZlTGF5ZXIsIHRydWUsIGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyLnJlbmRlclNjb3BlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZG9QYWludEVsKGVsLCBjdXJyZW50TGF5ZXIsIHBhaW50QWxsLCBzY29wZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZWwuX19kaXJ0eSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoY3VycmVudFByb2dyZXNzaXZlTGF5ZXIpIHtcbiAgICAgICAgICAgICAgICBmbHVzaFByb2dyZXNzaXZlTGF5ZXIoY3VycmVudFByb2dyZXNzaXZlTGF5ZXIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBSZXN0b3JlIHRoZSBsYXN0TGF5ZXIgY3R4XG4gICAgICAgICAgICBjdHggJiYgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgICAgIC8vIElmIHN0aWxsIGhhcyBjbGlwcGluZyBzdGF0ZVxuICAgICAgICAgICAgLy8gaWYgKHNjb3BlLnByZXZFbENsaXBQYXRocykge1xuICAgICAgICAgICAgLy8gICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgICAgICAvLyB9XG5cbiAgICAgICAgICAgIHRoaXMuX2Z1cnRoZXJQcm9ncmVzc2l2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgdXRpbC5lYWNoKHRoaXMuX3Byb2dyZXNzaXZlTGF5ZXJzLCBmdW5jdGlvbiAobGF5ZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAobGF5ZXIuX19tYXhQcm9ncmVzcyA+PSBsYXllci5fX3Byb2dyZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2Z1cnRoZXJQcm9ncmVzc2l2ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2RvUGFpbnRFbDogZnVuY3Rpb24gKGVsLCBjdXJyZW50TGF5ZXIsIGZvcmNlUGFpbnQsIHNjb3BlKSB7XG4gICAgICAgICAgICB2YXIgY3R4ID0gY3VycmVudExheWVyLmN0eDtcbiAgICAgICAgICAgIHZhciBtID0gZWwudHJhbnNmb3JtO1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIChjdXJyZW50TGF5ZXIuX19kaXJ0eSB8fCBmb3JjZVBhaW50KVxuICAgICAgICAgICAgICAgIC8vIElnbm9yZSBpbnZpc2libGUgZWxlbWVudFxuICAgICAgICAgICAgICAgICYmICFlbC5pbnZpc2libGVcbiAgICAgICAgICAgICAgICAvLyBJZ25vcmUgdHJhbnNwYXJlbnQgZWxlbWVudFxuICAgICAgICAgICAgICAgICYmIGVsLnN0eWxlLm9wYWNpdHkgIT09IDBcbiAgICAgICAgICAgICAgICAvLyBJZ25vcmUgc2NhbGUgMCBlbGVtZW50LCBpbiBzb21lIGVudmlyb25tZW50IGxpa2Ugbm9kZS1jYW52YXNcbiAgICAgICAgICAgICAgICAvLyBEcmF3IGEgc2NhbGUgMCBlbGVtZW50IGNhbiBjYXVzZSBhbGwgZm9sbG93aW5nIGRyYXcgd3JvbmdcbiAgICAgICAgICAgICAgICAvLyBBbmQgc2V0VHJhbnNmb3JtIHdpdGggc2NhbGUgMCB3aWxsIGNhdXNlIHNldCBiYWNrIHRyYW5zZm9ybSBmYWlsZWQuXG4gICAgICAgICAgICAgICAgJiYgIShtICYmICFtWzBdICYmICFtWzNdKVxuICAgICAgICAgICAgICAgIC8vIElnbm9yZSBjdWxsZWQgZWxlbWVudFxuICAgICAgICAgICAgICAgICYmICEoZWwuY3VsbGluZyAmJiBpc0Rpc3BsYXlhYmxlQ3VsbGVkKGVsLCB0aGlzLl93aWR0aCwgdGhpcy5faGVpZ2h0KSlcbiAgICAgICAgICAgICkge1xuXG4gICAgICAgICAgICAgICAgdmFyIGNsaXBQYXRocyA9IGVsLl9fY2xpcFBhdGhzO1xuXG4gICAgICAgICAgICAgICAgLy8gT3B0aW1pemUgd2hlbiBjbGlwcGluZyBvbiBncm91cCB3aXRoIHNldmVyYWwgZWxlbWVudHNcbiAgICAgICAgICAgICAgICBpZiAoc2NvcGUucHJldkNsaXBMYXllciAhPT0gY3VycmVudExheWVyXG4gICAgICAgICAgICAgICAgICAgIHx8IGlzQ2xpcFBhdGhDaGFuZ2VkKGNsaXBQYXRocywgc2NvcGUucHJldkVsQ2xpcFBhdGhzKVxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiBoYXMgcHJldmlvdXMgY2xpcHBpbmcgc3RhdGUsIHJlc3RvcmUgZnJvbSBpdFxuICAgICAgICAgICAgICAgICAgICBpZiAoc2NvcGUucHJldkVsQ2xpcFBhdGhzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzY29wZS5wcmV2Q2xpcExheWVyLmN0eC5yZXN0b3JlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzY29wZS5wcmV2Q2xpcExheWVyID0gc2NvcGUucHJldkVsQ2xpcFBhdGhzID0gbnVsbDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVzZXQgcHJldkVsIHNpbmNlIGNvbnRleHQgaGFzIGJlZW4gcmVzdG9yZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlLnByZXZFbCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gTmV3IGNsaXBwaW5nIHN0YXRlXG4gICAgICAgICAgICAgICAgICAgIGlmIChjbGlwUGF0aHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb0NsaXAoY2xpcFBhdGhzLCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGUucHJldkNsaXBMYXllciA9IGN1cnJlbnRMYXllcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlLnByZXZFbENsaXBQYXRocyA9IGNsaXBQYXRocztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbC5iZWZvcmVCcnVzaCAmJiBlbC5iZWZvcmVCcnVzaChjdHgpO1xuXG4gICAgICAgICAgICAgICAgZWwuYnJ1c2goY3R4LCBzY29wZS5wcmV2RWwgfHwgbnVsbCk7XG4gICAgICAgICAgICAgICAgc2NvcGUucHJldkVsID0gZWw7XG5cbiAgICAgICAgICAgICAgICBlbC5hZnRlckJydXNoICYmIGVsLmFmdGVyQnJ1c2goY3R4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog6I635Y+WIHpsZXZlbCDmiYDlnKjlsYLvvIzlpoLmnpzkuI3lrZjlnKjliJnkvJrliJvlu7rkuIDkuKrmlrDnmoTlsYJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHpsZXZlbFxuICAgICAgICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9MYXllcn1cbiAgICAgICAgICovXG4gICAgICAgIGdldExheWVyOiBmdW5jdGlvbiAoemxldmVsKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fc2luZ2xlQ2FudmFzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xheWVyc1swXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGxheWVyID0gdGhpcy5fbGF5ZXJzW3psZXZlbF07XG4gICAgICAgICAgICBpZiAoIWxheWVyKSB7XG4gICAgICAgICAgICAgICAgLy8gQ3JlYXRlIGEgbmV3IGxheWVyXG4gICAgICAgICAgICAgICAgbGF5ZXIgPSBuZXcgTGF5ZXIoJ3pyXycgKyB6bGV2ZWwsIHRoaXMsIHRoaXMuZHByKTtcbiAgICAgICAgICAgICAgICBsYXllci5pc0J1aWxkaW4gPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2xheWVyQ29uZmlnW3psZXZlbF0pIHtcbiAgICAgICAgICAgICAgICAgICAgdXRpbC5tZXJnZShsYXllciwgdGhpcy5fbGF5ZXJDb25maWdbemxldmVsXSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5pbnNlcnRMYXllcih6bGV2ZWwsIGxheWVyKTtcblxuICAgICAgICAgICAgICAgIC8vIENvbnRleHQgaXMgY3JlYXRlZCBhZnRlciBkb20gaW5zZXJ0ZWQgdG8gZG9jdW1lbnRcbiAgICAgICAgICAgICAgICAvLyBPciBleGNhbnZhcyB3aWxsIGdldCAwcHggY2xpZW50V2lkdGggYW5kIGNsaWVudEhlaWdodFxuICAgICAgICAgICAgICAgIGxheWVyLmluaXRDb250ZXh0KCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBsYXllcjtcbiAgICAgICAgfSxcblxuICAgICAgICBpbnNlcnRMYXllcjogZnVuY3Rpb24gKHpsZXZlbCwgbGF5ZXIpIHtcblxuICAgICAgICAgICAgdmFyIGxheWVyc01hcCA9IHRoaXMuX2xheWVycztcbiAgICAgICAgICAgIHZhciB6bGV2ZWxMaXN0ID0gdGhpcy5femxldmVsTGlzdDtcbiAgICAgICAgICAgIHZhciBsZW4gPSB6bGV2ZWxMaXN0Lmxlbmd0aDtcbiAgICAgICAgICAgIHZhciBwcmV2TGF5ZXIgPSBudWxsO1xuICAgICAgICAgICAgdmFyIGkgPSAtMTtcbiAgICAgICAgICAgIHZhciBkb21Sb290ID0gdGhpcy5fZG9tUm9vdDtcblxuICAgICAgICAgICAgaWYgKGxheWVyc01hcFt6bGV2ZWxdKSB7XG4gICAgICAgICAgICAgICAgbG9nKCdaTGV2ZWwgJyArIHpsZXZlbCArICcgaGFzIGJlZW4gdXNlZCBhbHJlYWR5Jyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgaXMgYSB2YWxpZCBsYXllclxuICAgICAgICAgICAgaWYgKCFpc0xheWVyVmFsaWQobGF5ZXIpKSB7XG4gICAgICAgICAgICAgICAgbG9nKCdMYXllciBvZiB6bGV2ZWwgJyArIHpsZXZlbCArICcgaXMgbm90IHZhbGlkJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobGVuID4gMCAmJiB6bGV2ZWwgPiB6bGV2ZWxMaXN0WzBdKSB7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbiAtIDE7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgICB6bGV2ZWxMaXN0W2ldIDwgemxldmVsXG4gICAgICAgICAgICAgICAgICAgICAgICAmJiB6bGV2ZWxMaXN0W2kgKyAxXSA+IHpsZXZlbFxuICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHByZXZMYXllciA9IGxheWVyc01hcFt6bGV2ZWxMaXN0W2ldXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHpsZXZlbExpc3Quc3BsaWNlKGkgKyAxLCAwLCB6bGV2ZWwpO1xuXG4gICAgICAgICAgICBpZiAocHJldkxheWVyKSB7XG4gICAgICAgICAgICAgICAgdmFyIHByZXZEb20gPSBwcmV2TGF5ZXIuZG9tO1xuICAgICAgICAgICAgICAgIGlmIChwcmV2RG9tLm5leHRTaWJsaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIGRvbVJvb3QuaW5zZXJ0QmVmb3JlKFxuICAgICAgICAgICAgICAgICAgICAgICAgbGF5ZXIuZG9tLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJldkRvbS5uZXh0U2libGluZ1xuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZG9tUm9vdC5hcHBlbmRDaGlsZChsYXllci5kb20pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChkb21Sb290LmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgZG9tUm9vdC5pbnNlcnRCZWZvcmUobGF5ZXIuZG9tLCBkb21Sb290LmZpcnN0Q2hpbGQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZG9tUm9vdC5hcHBlbmRDaGlsZChsYXllci5kb20pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGF5ZXJzTWFwW3psZXZlbF0gPSBsYXllcjtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBJdGVyYXRlIGVhY2ggbGF5ZXJcbiAgICAgICAgZWFjaExheWVyOiBmdW5jdGlvbiAoY2IsIGNvbnRleHQpIHtcbiAgICAgICAgICAgIHZhciB6bGV2ZWxMaXN0ID0gdGhpcy5femxldmVsTGlzdDtcbiAgICAgICAgICAgIHZhciB6O1xuICAgICAgICAgICAgdmFyIGk7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgemxldmVsTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHogPSB6bGV2ZWxMaXN0W2ldO1xuICAgICAgICAgICAgICAgIGNiLmNhbGwoY29udGV4dCwgdGhpcy5fbGF5ZXJzW3pdLCB6KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvLyBJdGVyYXRlIGVhY2ggYnVpbGRpbiBsYXllclxuICAgICAgICBlYWNoQnVpbGRpbkxheWVyOiBmdW5jdGlvbiAoY2IsIGNvbnRleHQpIHtcbiAgICAgICAgICAgIHZhciB6bGV2ZWxMaXN0ID0gdGhpcy5femxldmVsTGlzdDtcbiAgICAgICAgICAgIHZhciBsYXllcjtcbiAgICAgICAgICAgIHZhciB6O1xuICAgICAgICAgICAgdmFyIGk7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgemxldmVsTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHogPSB6bGV2ZWxMaXN0W2ldO1xuICAgICAgICAgICAgICAgIGxheWVyID0gdGhpcy5fbGF5ZXJzW3pdO1xuICAgICAgICAgICAgICAgIGlmIChsYXllci5pc0J1aWxkaW4pIHtcbiAgICAgICAgICAgICAgICAgICAgY2IuY2FsbChjb250ZXh0LCBsYXllciwgeik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8vIEl0ZXJhdGUgZWFjaCBvdGhlciBsYXllciBleGNlcHQgYnVpbGRpbiBsYXllclxuICAgICAgICBlYWNoT3RoZXJMYXllcjogZnVuY3Rpb24gKGNiLCBjb250ZXh0KSB7XG4gICAgICAgICAgICB2YXIgemxldmVsTGlzdCA9IHRoaXMuX3psZXZlbExpc3Q7XG4gICAgICAgICAgICB2YXIgbGF5ZXI7XG4gICAgICAgICAgICB2YXIgejtcbiAgICAgICAgICAgIHZhciBpO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHpsZXZlbExpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB6ID0gemxldmVsTGlzdFtpXTtcbiAgICAgICAgICAgICAgICBsYXllciA9IHRoaXMuX2xheWVyc1t6XTtcbiAgICAgICAgICAgICAgICBpZiAoISBsYXllci5pc0J1aWxkaW4pIHtcbiAgICAgICAgICAgICAgICAgICAgY2IuY2FsbChjb250ZXh0LCBsYXllciwgeik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDojrflj5bmiYDmnInlt7LliJvlu7rnmoTlsYJcbiAgICAgICAgICogQHBhcmFtIHtBcnJheS48bW9kdWxlOnpyZW5kZXIvTGF5ZXI+fSBbcHJldkxheWVyXVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0TGF5ZXJzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbGF5ZXJzO1xuICAgICAgICB9LFxuXG4gICAgICAgIF91cGRhdGVMYXllclN0YXR1czogZnVuY3Rpb24gKGxpc3QpIHtcblxuICAgICAgICAgICAgdmFyIGxheWVycyA9IHRoaXMuX2xheWVycztcbiAgICAgICAgICAgIHZhciBwcm9ncmVzc2l2ZUxheWVycyA9IHRoaXMuX3Byb2dyZXNzaXZlTGF5ZXJzO1xuXG4gICAgICAgICAgICB2YXIgZWxDb3VudHNMYXN0RnJhbWUgPSB7fTtcbiAgICAgICAgICAgIHZhciBwcm9ncmVzc2l2ZUVsQ291bnRzTGFzdEZyYW1lID0ge307XG5cbiAgICAgICAgICAgIHRoaXMuZWFjaEJ1aWxkaW5MYXllcihmdW5jdGlvbiAobGF5ZXIsIHopIHtcbiAgICAgICAgICAgICAgICBlbENvdW50c0xhc3RGcmFtZVt6XSA9IGxheWVyLmVsQ291bnQ7XG4gICAgICAgICAgICAgICAgbGF5ZXIuZWxDb3VudCA9IDA7XG4gICAgICAgICAgICAgICAgbGF5ZXIuX19kaXJ0eSA9IGZhbHNlO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHV0aWwuZWFjaChwcm9ncmVzc2l2ZUxheWVycywgZnVuY3Rpb24gKGxheWVyLCBpZHgpIHtcbiAgICAgICAgICAgICAgICBwcm9ncmVzc2l2ZUVsQ291bnRzTGFzdEZyYW1lW2lkeF0gPSBsYXllci5lbENvdW50O1xuICAgICAgICAgICAgICAgIGxheWVyLmVsQ291bnQgPSAwO1xuICAgICAgICAgICAgICAgIGxheWVyLl9fZGlydHkgPSBmYWxzZTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB2YXIgcHJvZ3Jlc3NpdmVMYXllckNvdW50ID0gMDtcbiAgICAgICAgICAgIHZhciBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllcjtcbiAgICAgICAgICAgIHZhciBsYXN0UHJvZ3Jlc3NpdmVLZXk7XG4gICAgICAgICAgICB2YXIgZnJhbWVDb3VudCA9IDA7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGxpc3QubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVsID0gbGlzdFtpXTtcbiAgICAgICAgICAgICAgICB2YXIgemxldmVsID0gdGhpcy5fc2luZ2xlQ2FudmFzID8gMCA6IGVsLnpsZXZlbDtcbiAgICAgICAgICAgICAgICB2YXIgbGF5ZXIgPSBsYXllcnNbemxldmVsXTtcbiAgICAgICAgICAgICAgICB2YXIgZWxQcm9ncmVzcyA9IGVsLnByb2dyZXNzaXZlO1xuICAgICAgICAgICAgICAgIGlmIChsYXllcikge1xuICAgICAgICAgICAgICAgICAgICBsYXllci5lbENvdW50Kys7XG4gICAgICAgICAgICAgICAgICAgIGxheWVyLl9fZGlydHkgPSBsYXllci5fX2RpcnR5IHx8IGVsLl9fZGlydHk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8vLy8vLyBVcGRhdGUgcHJvZ3Jlc3NpdmVcbiAgICAgICAgICAgICAgICBpZiAoZWxQcm9ncmVzcyA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEZpeCB3cm9uZyBwcm9ncmVzc2l2ZSBzZXF1ZW5jZSBwcm9ibGVtLlxuICAgICAgICAgICAgICAgICAgICBpZiAobGFzdFByb2dyZXNzaXZlS2V5ICE9PSBlbFByb2dyZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0UHJvZ3Jlc3NpdmVLZXkgPSBlbFByb2dyZXNzO1xuICAgICAgICAgICAgICAgICAgICAgICAgZnJhbWVDb3VudCsrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBlbEZyYW1lID0gZWwuX19mcmFtZSA9IGZyYW1lQ291bnQgLSAxO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaWR4ID0gTWF0aC5taW4ocHJvZ3Jlc3NpdmVMYXllckNvdW50LCBNQVhfUFJPR1JFU1NJVkVfTEFZRVJfTlVNQkVSIC0gMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllciA9IHByb2dyZXNzaXZlTGF5ZXJzW2lkeF07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFByb2dyZXNzaXZlTGF5ZXIgPSBwcm9ncmVzc2l2ZUxheWVyc1tpZHhdID0gbmV3IExheWVyKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAncHJvZ3Jlc3NpdmUnLCB0aGlzLCB0aGlzLmRwclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFByb2dyZXNzaXZlTGF5ZXIuaW5pdENvbnRleHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyLl9fbWF4UHJvZ3Jlc3MgPSAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyLl9fZGlydHkgPSBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllci5fX2RpcnR5IHx8IGVsLl9fZGlydHk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyLmVsQ291bnQrKztcblxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllci5fX21heFByb2dyZXNzID0gTWF0aC5tYXgoXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllci5fX21heFByb2dyZXNzLCBlbEZyYW1lXG4gICAgICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyLl9fbWF4UHJvZ3Jlc3MgPj0gY3VycmVudFByb2dyZXNzaXZlTGF5ZXIuX19wcm9ncmVzcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2hvdWxkIGtlZXAgcmVuZGVyaW5nIHRoaXMgIGxheWVyIGJlY2F1c2UgcHJvZ3Jlc3NpdmUgcmVuZGVyaW5nIGlzIG5vdCBmaW5pc2hlZCB5ZXRcbiAgICAgICAgICAgICAgICAgICAgICAgIGxheWVyLl9fZGlydHkgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBlbC5fX2ZyYW1lID0gLTE7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllci5fX25leHRJZHhOb3RQcm9nID0gaTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2dyZXNzaXZlTGF5ZXJDb3VudCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFByb2dyZXNzaXZlTGF5ZXIgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoY3VycmVudFByb2dyZXNzaXZlTGF5ZXIpIHtcbiAgICAgICAgICAgICAgICBwcm9ncmVzc2l2ZUxheWVyQ291bnQrKztcbiAgICAgICAgICAgICAgICBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllci5fX25leHRJZHhOb3RQcm9nID0gaTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8g5bGC5Lit55qE5YWD57Sg5pWw6YeP5pyJ5Y+R55Sf5Y+Y5YyWXG4gICAgICAgICAgICB0aGlzLmVhY2hCdWlsZGluTGF5ZXIoZnVuY3Rpb24gKGxheWVyLCB6KSB7XG4gICAgICAgICAgICAgICAgaWYgKGVsQ291bnRzTGFzdEZyYW1lW3pdICE9PSBsYXllci5lbENvdW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGxheWVyLl9fZGlydHkgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBwcm9ncmVzc2l2ZUxheWVycy5sZW5ndGggPSBNYXRoLm1pbihwcm9ncmVzc2l2ZUxheWVyQ291bnQsIE1BWF9QUk9HUkVTU0lWRV9MQVlFUl9OVU1CRVIpO1xuICAgICAgICAgICAgdXRpbC5lYWNoKHByb2dyZXNzaXZlTGF5ZXJzLCBmdW5jdGlvbiAobGF5ZXIsIGlkeCkge1xuICAgICAgICAgICAgICAgIGlmIChwcm9ncmVzc2l2ZUVsQ291bnRzTGFzdEZyYW1lW2lkeF0gIT09IGxheWVyLmVsQ291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgZWwuX19kaXJ0eSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChsYXllci5fX2RpcnR5KSB7XG4gICAgICAgICAgICAgICAgICAgIGxheWVyLl9fcHJvZ3Jlc3MgPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmuIXpmaRob3ZlcuWxguWkluaJgOacieWGheWuuVxuICAgICAgICAgKi9cbiAgICAgICAgY2xlYXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuZWFjaEJ1aWxkaW5MYXllcih0aGlzLl9jbGVhckxheWVyKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9jbGVhckxheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcbiAgICAgICAgICAgIGxheWVyLmNsZWFyKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOS/ruaUueaMh+WumnpsZXZlbOeahOe7mOWItuWPguaVsFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gemxldmVsXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcg6YWN572u5a+56LGhXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY29uZmlnLmNsZWFyQ29sb3I9MF0g5q+P5qyh5riF56m655S75biD55qE6aKc6ImyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY29uZmlnLm1vdGlvbkJsdXI9ZmFsc2VdIOaYr+WQpuW8gOWQr+WKqOaAgeaooeezilxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2NvbmZpZy5sYXN0RnJhbWVBbHBoYT0wLjddXG4gICAgICAgICAqICAgICAgICAgICAgICAgICDlnKjlvIDlkK/liqjmgIHmqKHns4rnmoTml7blgJnkvb/nlKjvvIzkuI7kuIrkuIDluKfmt7flkIjnmoRhbHBoYeWAvO+8jOWAvOi2iuWkp+Wwvui/uei2iuaYjuaYvlxuICAgICAgICAgKi9cbiAgICAgICAgY29uZmlnTGF5ZXI6IGZ1bmN0aW9uICh6bGV2ZWwsIGNvbmZpZykge1xuICAgICAgICAgICAgaWYgKGNvbmZpZykge1xuICAgICAgICAgICAgICAgIHZhciBsYXllckNvbmZpZyA9IHRoaXMuX2xheWVyQ29uZmlnO1xuICAgICAgICAgICAgICAgIGlmICghbGF5ZXJDb25maWdbemxldmVsXSkge1xuICAgICAgICAgICAgICAgICAgICBsYXllckNvbmZpZ1t6bGV2ZWxdID0gY29uZmlnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdXRpbC5tZXJnZShsYXllckNvbmZpZ1t6bGV2ZWxdLCBjb25maWcsIHRydWUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBsYXllciA9IHRoaXMuX2xheWVyc1t6bGV2ZWxdO1xuXG4gICAgICAgICAgICAgICAgaWYgKGxheWVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHV0aWwubWVyZ2UobGF5ZXIsIGxheWVyQ29uZmlnW3psZXZlbF0sIHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5Yig6Zmk5oyH5a6a5bGCXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB6bGV2ZWwg5bGC5omA5Zyo55qEemxldmVsXG4gICAgICAgICAqL1xuICAgICAgICBkZWxMYXllcjogZnVuY3Rpb24gKHpsZXZlbCkge1xuICAgICAgICAgICAgdmFyIGxheWVycyA9IHRoaXMuX2xheWVycztcbiAgICAgICAgICAgIHZhciB6bGV2ZWxMaXN0ID0gdGhpcy5femxldmVsTGlzdDtcbiAgICAgICAgICAgIHZhciBsYXllciA9IGxheWVyc1t6bGV2ZWxdO1xuICAgICAgICAgICAgaWYgKCFsYXllcikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxheWVyLmRvbS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGxheWVyLmRvbSk7XG4gICAgICAgICAgICBkZWxldGUgbGF5ZXJzW3psZXZlbF07XG5cbiAgICAgICAgICAgIHpsZXZlbExpc3Quc3BsaWNlKHV0aWwuaW5kZXhPZih6bGV2ZWxMaXN0LCB6bGV2ZWwpLCAxKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5Yy65Z+f5aSn5bCP5Y+Y5YyW5ZCO6YeN57uYXG4gICAgICAgICAqL1xuICAgICAgICByZXNpemU6IGZ1bmN0aW9uICh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgICAgICB2YXIgZG9tUm9vdCA9IHRoaXMuX2RvbVJvb3Q7XG4gICAgICAgICAgICAvLyBGSVhNRSBXaHkgP1xuICAgICAgICAgICAgZG9tUm9vdC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuXG4gICAgICAgICAgICB3aWR0aCA9IHdpZHRoIHx8IHRoaXMuX2dldFdpZHRoKCk7XG4gICAgICAgICAgICBoZWlnaHQgPSBoZWlnaHQgfHwgdGhpcy5fZ2V0SGVpZ2h0KCk7XG5cbiAgICAgICAgICAgIGRvbVJvb3Quc3R5bGUuZGlzcGxheSA9ICcnO1xuXG4gICAgICAgICAgICAvLyDkvJjljJbmsqHmnInlrp7pmYXmlLnlj5jnmoRyZXNpemVcbiAgICAgICAgICAgIGlmICh0aGlzLl93aWR0aCAhPSB3aWR0aCB8fCBoZWlnaHQgIT0gdGhpcy5faGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgZG9tUm9vdC5zdHlsZS53aWR0aCA9IHdpZHRoICsgJ3B4JztcbiAgICAgICAgICAgICAgICBkb21Sb290LnN0eWxlLmhlaWdodCA9IGhlaWdodCArICdweCc7XG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpZCBpbiB0aGlzLl9sYXllcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbGF5ZXJzW2lkXS5yZXNpemUod2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5yZWZyZXNoKHRydWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl93aWR0aCA9IHdpZHRoO1xuICAgICAgICAgICAgdGhpcy5faGVpZ2h0ID0gaGVpZ2h0O1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5riF6Zmk5Y2V54us55qE5LiA5Liq5bGCXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB6bGV2ZWxcbiAgICAgICAgICovXG4gICAgICAgIGNsZWFyTGF5ZXI6IGZ1bmN0aW9uICh6bGV2ZWwpIHtcbiAgICAgICAgICAgIHZhciBsYXllciA9IHRoaXMuX2xheWVyc1t6bGV2ZWxdO1xuICAgICAgICAgICAgaWYgKGxheWVyKSB7XG4gICAgICAgICAgICAgICAgbGF5ZXIuY2xlYXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog6YeK5pS+XG4gICAgICAgICAqL1xuICAgICAgICBkaXNwb3NlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLnJvb3QuaW5uZXJIVE1MID0gJyc7XG5cbiAgICAgICAgICAgIHRoaXMucm9vdCA9XG4gICAgICAgICAgICB0aGlzLnN0b3JhZ2UgPVxuXG4gICAgICAgICAgICB0aGlzLl9kb21Sb290ID1cbiAgICAgICAgICAgIHRoaXMuX2xheWVycyA9IG51bGw7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCBjYW52YXMgd2hpY2ggaGFzIGFsbCB0aGluZyByZW5kZXJlZFxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuYmFja2dyb3VuZENvbG9yXVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0UmVuZGVyZWRDYW52YXM6IGZ1bmN0aW9uIChvcHRzKSB7XG4gICAgICAgICAgICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9zaW5nbGVDYW52YXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbGF5ZXJzWzBdLmRvbTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGltYWdlTGF5ZXIgPSBuZXcgTGF5ZXIoJ2ltYWdlJywgdGhpcywgb3B0cy5waXhlbFJhdGlvIHx8IHRoaXMuZHByKTtcbiAgICAgICAgICAgIGltYWdlTGF5ZXIuaW5pdENvbnRleHQoKTtcblxuICAgICAgICAgICAgaW1hZ2VMYXllci5jbGVhckNvbG9yID0gb3B0cy5iYWNrZ3JvdW5kQ29sb3I7XG4gICAgICAgICAgICBpbWFnZUxheWVyLmNsZWFyKCk7XG5cbiAgICAgICAgICAgIHZhciBkaXNwbGF5TGlzdCA9IHRoaXMuc3RvcmFnZS5nZXREaXNwbGF5TGlzdCh0cnVlKTtcblxuICAgICAgICAgICAgdmFyIHNjb3BlID0ge307XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpc3BsYXlMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVsID0gZGlzcGxheUxpc3RbaV07XG4gICAgICAgICAgICAgICAgdGhpcy5fZG9QYWludEVsKGVsLCBpbWFnZUxheWVyLCB0cnVlLCBzY29wZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBpbWFnZUxheWVyLmRvbTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOiOt+WPlue7mOWbvuWMuuWfn+WuveW6plxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0V2lkdGg6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl93aWR0aDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog6I635Y+W57uY5Zu+5Yy65Z+f6auY5bqmXG4gICAgICAgICAqL1xuICAgICAgICBnZXRIZWlnaHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9oZWlnaHQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2dldFdpZHRoOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcm9vdCA9IHRoaXMucm9vdDtcbiAgICAgICAgICAgIHZhciBzdGwgPSBkb2N1bWVudC5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKHJvb3QpO1xuXG4gICAgICAgICAgICAvLyBGSVhNRSBCZXR0ZXIgd2F5IHRvIGdldCB0aGUgd2lkdGggYW5kIGhlaWdodCB3aGVuIGVsZW1lbnQgaGFzIG5vdCBiZWVuIGFwcGVuZCB0byB0aGUgZG9jdW1lbnRcbiAgICAgICAgICAgIHJldHVybiAoKHJvb3QuY2xpZW50V2lkdGggfHwgcGFyc2VJbnQxMChzdGwud2lkdGgpIHx8IHBhcnNlSW50MTAocm9vdC5zdHlsZS53aWR0aCkpXG4gICAgICAgICAgICAgICAgICAgIC0gKHBhcnNlSW50MTAoc3RsLnBhZGRpbmdMZWZ0KSB8fCAwKVxuICAgICAgICAgICAgICAgICAgICAtIChwYXJzZUludDEwKHN0bC5wYWRkaW5nUmlnaHQpIHx8IDApKSB8IDA7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2dldEhlaWdodDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHJvb3QgPSB0aGlzLnJvb3Q7XG4gICAgICAgICAgICB2YXIgc3RsID0gZG9jdW1lbnQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZShyb290KTtcblxuICAgICAgICAgICAgcmV0dXJuICgocm9vdC5jbGllbnRIZWlnaHQgfHwgcGFyc2VJbnQxMChzdGwuaGVpZ2h0KSB8fCBwYXJzZUludDEwKHJvb3Quc3R5bGUuaGVpZ2h0KSlcbiAgICAgICAgICAgICAgICAgICAgLSAocGFyc2VJbnQxMChzdGwucGFkZGluZ1RvcCkgfHwgMClcbiAgICAgICAgICAgICAgICAgICAgLSAocGFyc2VJbnQxMChzdGwucGFkZGluZ0JvdHRvbSkgfHwgMCkpIHwgMDtcbiAgICAgICAgfSxcblxuICAgICAgICBfcGF0aFRvSW1hZ2U6IGZ1bmN0aW9uIChpZCwgcGF0aCwgd2lkdGgsIGhlaWdodCwgZHByKSB7XG4gICAgICAgICAgICB2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgICAgICB2YXIgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG5cbiAgICAgICAgICAgIGNhbnZhcy53aWR0aCA9IHdpZHRoICogZHByO1xuICAgICAgICAgICAgY2FudmFzLmhlaWdodCA9IGhlaWdodCAqIGRwcjtcblxuICAgICAgICAgICAgY3R4LmNsZWFyUmVjdCgwLCAwLCB3aWR0aCAqIGRwciwgaGVpZ2h0ICogZHByKTtcblxuICAgICAgICAgICAgdmFyIHBhdGhUcmFuc2Zvcm0gPSB7XG4gICAgICAgICAgICAgICAgcG9zaXRpb246IHBhdGgucG9zaXRpb24sXG4gICAgICAgICAgICAgICAgcm90YXRpb246IHBhdGgucm90YXRpb24sXG4gICAgICAgICAgICAgICAgc2NhbGU6IHBhdGguc2NhbGVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBwYXRoLnBvc2l0aW9uID0gWzAsIDAsIDBdO1xuICAgICAgICAgICAgcGF0aC5yb3RhdGlvbiA9IDA7XG4gICAgICAgICAgICBwYXRoLnNjYWxlID0gWzEsIDFdO1xuICAgICAgICAgICAgaWYgKHBhdGgpIHtcbiAgICAgICAgICAgICAgICBwYXRoLmJydXNoKGN0eCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBJbWFnZVNoYXBlID0gcmVxdWlyZSgnLi9ncmFwaGljL0ltYWdlJyk7XG4gICAgICAgICAgICB2YXIgaW1nU2hhcGUgPSBuZXcgSW1hZ2VTaGFwZSh7XG4gICAgICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICAgICAgICAgIHk6IDAsXG4gICAgICAgICAgICAgICAgICAgIGltYWdlOiBjYW52YXNcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKHBhdGhUcmFuc2Zvcm0ucG9zaXRpb24gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGltZ1NoYXBlLnBvc2l0aW9uID0gcGF0aC5wb3NpdGlvbiA9IHBhdGhUcmFuc2Zvcm0ucG9zaXRpb247XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChwYXRoVHJhbnNmb3JtLnJvdGF0aW9uICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpbWdTaGFwZS5yb3RhdGlvbiA9IHBhdGgucm90YXRpb24gPSBwYXRoVHJhbnNmb3JtLnJvdGF0aW9uO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocGF0aFRyYW5zZm9ybS5zY2FsZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaW1nU2hhcGUuc2NhbGUgPSBwYXRoLnNjYWxlID0gcGF0aFRyYW5zZm9ybS5zY2FsZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGltZ1NoYXBlO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9jcmVhdGVQYXRoVG9JbWFnZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG1lID0gdGhpcztcblxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChpZCwgZSwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtZS5fcGF0aFRvSW1hZ2UoXG4gICAgICAgICAgICAgICAgICAgIGlkLCBlLCB3aWR0aCwgaGVpZ2h0LCBtZS5kcHJcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IFBhaW50ZXI7XG5cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3pyZW5kZXIvbGliL1BhaW50ZXIuanNcbiAqKiBtb2R1bGUgaWQgPSA3MFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBAbW9kdWxlIHpyZW5kZXIvTGF5ZXJcbiAqIEBhdXRob3IgcGlzc2FuZyhodHRwczovL3d3dy5naXRodWIuY29tL3Bpc3NhbmcpXG4gKi9cblxuXG4gICAgdmFyIHV0aWwgPSByZXF1aXJlKCcuL2NvcmUvdXRpbCcpO1xuICAgIHZhciBjb25maWcgPSByZXF1aXJlKCcuL2NvbmZpZycpO1xuICAgIHZhciBTdHlsZSA9IHJlcXVpcmUoJy4vZ3JhcGhpYy9TdHlsZScpO1xuICAgIHZhciBQYXR0ZXJuID0gcmVxdWlyZSgnLi9ncmFwaGljL1BhdHRlcm4nKTtcblxuICAgIGZ1bmN0aW9uIHJldHVybkZhbHNlKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog5Yib5bu6ZG9tXG4gICAgICpcbiAgICAgKiBAaW5uZXJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgZG9tIGlkIOW+heeUqFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIGRvbSB0eXBl77yMc3VjaCBhcyBjYW52YXMsIGRpdiBldGMuXG4gICAgICogQHBhcmFtIHtQYWludGVyfSBwYWludGVyIHBhaW50ZXIgaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbnVtYmVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlRG9tKGlkLCB0eXBlLCBwYWludGVyLCBkcHIpIHtcbiAgICAgICAgdmFyIG5ld0RvbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodHlwZSk7XG4gICAgICAgIHZhciB3aWR0aCA9IHBhaW50ZXIuZ2V0V2lkdGgoKTtcbiAgICAgICAgdmFyIGhlaWdodCA9IHBhaW50ZXIuZ2V0SGVpZ2h0KCk7XG5cbiAgICAgICAgdmFyIG5ld0RvbVN0eWxlID0gbmV3RG9tLnN0eWxlO1xuICAgICAgICAvLyDmsqFhcHBlbmTlkaLvvIzor7fljp/osIXmiJHov5nmoLflhpnvvIzmuIXmmbB+XG4gICAgICAgIG5ld0RvbVN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgICAgbmV3RG9tU3R5bGUubGVmdCA9IDA7XG4gICAgICAgIG5ld0RvbVN0eWxlLnRvcCA9IDA7XG4gICAgICAgIG5ld0RvbVN0eWxlLndpZHRoID0gd2lkdGggKyAncHgnO1xuICAgICAgICBuZXdEb21TdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyAncHgnO1xuICAgICAgICBuZXdEb20ud2lkdGggPSB3aWR0aCAqIGRwcjtcbiAgICAgICAgbmV3RG9tLmhlaWdodCA9IGhlaWdodCAqIGRwcjtcblxuICAgICAgICAvLyBpZOS4jeS9nOS4uue0ouW8leeUqO+8jOmBv+WFjeWPr+iDvemAoOaIkOeahOmHjeWQje+8jOWumuS5ieS4uuengeacieWxnuaAp1xuICAgICAgICBuZXdEb20uc2V0QXR0cmlidXRlKCdkYXRhLXpyLWRvbS1pZCcsIGlkKTtcbiAgICAgICAgcmV0dXJuIG5ld0RvbTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAYWxpYXMgbW9kdWxlOnpyZW5kZXIvTGF5ZXJcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAZXh0ZW5kcyBtb2R1bGU6enJlbmRlci9taXhpbi9UcmFuc2Zvcm1hYmxlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGlkXG4gICAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9QYWludGVyfSBwYWludGVyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtkcHJdXG4gICAgICovXG4gICAgdmFyIExheWVyID0gZnVuY3Rpb24oaWQsIHBhaW50ZXIsIGRwcikge1xuICAgICAgICB2YXIgZG9tO1xuICAgICAgICBkcHIgPSBkcHIgfHwgY29uZmlnLmRldmljZVBpeGVsUmF0aW87XG4gICAgICAgIGlmICh0eXBlb2YgaWQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBkb20gPSBjcmVhdGVEb20oaWQsICdjYW52YXMnLCBwYWludGVyLCBkcHIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5vdCB1c2luZyBpc0RvbSBiZWNhdXNlIGluIG5vZGUgaXQgd2lsbCByZXR1cm4gZmFsc2VcbiAgICAgICAgZWxzZSBpZiAodXRpbC5pc09iamVjdChpZCkpIHtcbiAgICAgICAgICAgIGRvbSA9IGlkO1xuICAgICAgICAgICAgaWQgPSBkb20uaWQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pZCA9IGlkO1xuICAgICAgICB0aGlzLmRvbSA9IGRvbTtcblxuICAgICAgICB2YXIgZG9tU3R5bGUgPSBkb20uc3R5bGU7XG4gICAgICAgIGlmIChkb21TdHlsZSkgeyAvLyBOb3QgaW4gbm9kZVxuICAgICAgICAgICAgZG9tLm9uc2VsZWN0c3RhcnQgPSByZXR1cm5GYWxzZTsgLy8g6YG/5YWN6aG16Z2i6YCJ5Lit55qE5bC05bCsXG4gICAgICAgICAgICBkb21TdHlsZVsnLXdlYmtpdC11c2VyLXNlbGVjdCddID0gJ25vbmUnO1xuICAgICAgICAgICAgZG9tU3R5bGVbJ3VzZXItc2VsZWN0J10gPSAnbm9uZSc7XG4gICAgICAgICAgICBkb21TdHlsZVsnLXdlYmtpdC10b3VjaC1jYWxsb3V0J10gPSAnbm9uZSc7XG4gICAgICAgICAgICBkb21TdHlsZVsnLXdlYmtpdC10YXAtaGlnaGxpZ2h0LWNvbG9yJ10gPSAncmdiYSgwLDAsMCwwKSc7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmRvbUJhY2sgPSBudWxsO1xuICAgICAgICB0aGlzLmN0eEJhY2sgPSBudWxsO1xuXG4gICAgICAgIHRoaXMucGFpbnRlciA9IHBhaW50ZXI7XG5cbiAgICAgICAgdGhpcy5jb25maWcgPSBudWxsO1xuXG4gICAgICAgIC8vIENvbmZpZ3NcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOavj+asoea4heepuueUu+W4g+eahOminOiJslxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKiBAZGVmYXVsdCAwXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNsZWFyQ29sb3IgPSAwO1xuICAgICAgICAvKipcbiAgICAgICAgICog5piv5ZCm5byA5ZCv5Yqo5oCB5qih57OKXG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5tb3Rpb25CbHVyID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlnKjlvIDlkK/liqjmgIHmqKHns4rnmoTml7blgJnkvb/nlKjvvIzkuI7kuIrkuIDluKfmt7flkIjnmoRhbHBoYeWAvO+8jOWAvOi2iuWkp+Wwvui/uei2iuaYjuaYvlxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKiBAZGVmYXVsdCAwLjdcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubGFzdEZyYW1lQWxwaGEgPSAwLjc7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIExheWVyIGRwclxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kcHIgPSBkcHI7XG4gICAgfTtcblxuICAgIExheWVyLnByb3RvdHlwZSA9IHtcblxuICAgICAgICBjb25zdHJ1Y3RvcjogTGF5ZXIsXG5cbiAgICAgICAgZWxDb3VudDogMCxcblxuICAgICAgICBfX2RpcnR5OiB0cnVlLFxuXG4gICAgICAgIGluaXRDb250ZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLmN0eCA9IHRoaXMuZG9tLmdldENvbnRleHQoJzJkJyk7XG5cbiAgICAgICAgICAgIHRoaXMuY3R4LmRwciA9IHRoaXMuZHByO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNyZWF0ZUJhY2tCdWZmZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBkcHIgPSB0aGlzLmRwcjtcblxuICAgICAgICAgICAgdGhpcy5kb21CYWNrID0gY3JlYXRlRG9tKCdiYWNrLScgKyB0aGlzLmlkLCAnY2FudmFzJywgdGhpcy5wYWludGVyLCBkcHIpO1xuICAgICAgICAgICAgdGhpcy5jdHhCYWNrID0gdGhpcy5kb21CYWNrLmdldENvbnRleHQoJzJkJyk7XG5cbiAgICAgICAgICAgIGlmIChkcHIgIT0gMSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY3R4QmFjay5zY2FsZShkcHIsIGRwcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gd2lkdGhcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSBoZWlnaHRcbiAgICAgICAgICovXG4gICAgICAgIHJlc2l6ZTogZnVuY3Rpb24gKHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgICAgIHZhciBkcHIgPSB0aGlzLmRwcjtcblxuICAgICAgICAgICAgdmFyIGRvbSA9IHRoaXMuZG9tO1xuICAgICAgICAgICAgdmFyIGRvbVN0eWxlID0gZG9tLnN0eWxlO1xuICAgICAgICAgICAgdmFyIGRvbUJhY2sgPSB0aGlzLmRvbUJhY2s7XG5cbiAgICAgICAgICAgIGRvbVN0eWxlLndpZHRoID0gd2lkdGggKyAncHgnO1xuICAgICAgICAgICAgZG9tU3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgJ3B4JztcblxuICAgICAgICAgICAgZG9tLndpZHRoID0gd2lkdGggKiBkcHI7XG4gICAgICAgICAgICBkb20uaGVpZ2h0ID0gaGVpZ2h0ICogZHByO1xuXG4gICAgICAgICAgICBpZiAoZG9tQmFjaykge1xuICAgICAgICAgICAgICAgIGRvbUJhY2sud2lkdGggPSB3aWR0aCAqIGRwcjtcbiAgICAgICAgICAgICAgICBkb21CYWNrLmhlaWdodCA9IGhlaWdodCAqIGRwcjtcblxuICAgICAgICAgICAgICAgIGlmIChkcHIgIT0gMSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmN0eEJhY2suc2NhbGUoZHByLCBkcHIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5riF56m66K+l5bGC55S75biDXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gY2xlYXJBbGwgQ2xlYXIgYWxsIHdpdGggb3V0IG1vdGlvbiBibHVyXG4gICAgICAgICAqL1xuICAgICAgICBjbGVhcjogZnVuY3Rpb24gKGNsZWFyQWxsKSB7XG4gICAgICAgICAgICB2YXIgZG9tID0gdGhpcy5kb207XG4gICAgICAgICAgICB2YXIgY3R4ID0gdGhpcy5jdHg7XG4gICAgICAgICAgICB2YXIgd2lkdGggPSBkb20ud2lkdGg7XG4gICAgICAgICAgICB2YXIgaGVpZ2h0ID0gZG9tLmhlaWdodDtcblxuICAgICAgICAgICAgdmFyIGNsZWFyQ29sb3IgPSB0aGlzLmNsZWFyQ29sb3I7XG4gICAgICAgICAgICB2YXIgaGF2ZU1vdGlvbkJMdXIgPSB0aGlzLm1vdGlvbkJsdXIgJiYgIWNsZWFyQWxsO1xuICAgICAgICAgICAgdmFyIGxhc3RGcmFtZUFscGhhID0gdGhpcy5sYXN0RnJhbWVBbHBoYTtcblxuICAgICAgICAgICAgdmFyIGRwciA9IHRoaXMuZHByO1xuXG4gICAgICAgICAgICBpZiAoaGF2ZU1vdGlvbkJMdXIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuZG9tQmFjaykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNyZWF0ZUJhY2tCdWZmZXIoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLmN0eEJhY2suZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gJ2NvcHknO1xuICAgICAgICAgICAgICAgIHRoaXMuY3R4QmFjay5kcmF3SW1hZ2UoXG4gICAgICAgICAgICAgICAgICAgIGRvbSwgMCwgMCxcbiAgICAgICAgICAgICAgICAgICAgd2lkdGggLyBkcHIsXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodCAvIGRwclxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgICBpZiAoY2xlYXJDb2xvcikge1xuICAgICAgICAgICAgICAgIHZhciBjbGVhckNvbG9yR3JhZGllbnRPclBhdHRlcm47XG4gICAgICAgICAgICAgICAgLy8gR3JhZGllbnRcbiAgICAgICAgICAgICAgICBpZiAoY2xlYXJDb2xvci5jb2xvclN0b3BzKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIENhY2hlIGNhbnZhcyBncmFkaWVudFxuICAgICAgICAgICAgICAgICAgICBjbGVhckNvbG9yR3JhZGllbnRPclBhdHRlcm4gPSBjbGVhckNvbG9yLl9fY2FudmFzR3JhZGllbnQgfHwgU3R5bGUuZ2V0R3JhZGllbnQoY3R4LCBjbGVhckNvbG9yLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgeTogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIGNsZWFyQ29sb3IuX19jYW52YXNHcmFkaWVudCA9IGNsZWFyQ29sb3JHcmFkaWVudE9yUGF0dGVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gUGF0dGVyblxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNsZWFyQ29sb3IuaW1hZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJDb2xvckdyYWRpZW50T3JQYXR0ZXJuID0gUGF0dGVybi5wcm90b3R5cGUuZ2V0Q2FudmFzUGF0dGVybi5jYWxsKGNsZWFyQ29sb3IsIGN0eCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGNsZWFyQ29sb3JHcmFkaWVudE9yUGF0dGVybiB8fCBjbGVhckNvbG9yO1xuICAgICAgICAgICAgICAgIGN0eC5maWxsUmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaGF2ZU1vdGlvbkJMdXIpIHtcbiAgICAgICAgICAgICAgICB2YXIgZG9tQmFjayA9IHRoaXMuZG9tQmFjaztcbiAgICAgICAgICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICAgICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IGxhc3RGcmFtZUFscGhhO1xuICAgICAgICAgICAgICAgIGN0eC5kcmF3SW1hZ2UoZG9tQmFjaywgMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IExheWVyO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34venJlbmRlci9saWIvTGF5ZXIuanNcbiAqKiBtb2R1bGUgaWQgPSA3MVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXHJcbiAqL1xyXG5cclxuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcclxuICAgIHZhciB1dGlsID0gcmVxdWlyZShcIi4uLy4uL2Zpc2gtdG9wby1jb3JlL2xpYi91dGlsLmpzXCIpO1xyXG4gICAgdmFyIEJQTU5Ob2RlID0gcmVxdWlyZShcIi4vbm9kZS9CUE1OTm9kZS5qc1wiKTtcclxuICAgIHZhciBCUE1OTW9kZWwgPSByZXF1aXJlKFwiLi9tb2RlbC9CUE1OTW9kZWwuanNcIik7XHJcbiAgICB2YXIgU3RhcnRFdmVudE5vZGUgPSByZXF1aXJlKFwiLi9ub2RlL2V2ZW50L1N0YXJ0RXZlbnROb2RlXCIpO1xyXG4gICAgdmFyIEVuZEV2ZW50Tm9kZSA9IHJlcXVpcmUoXCIuL25vZGUvZXZlbnQvRW5kRXZlbnROb2RlXCIpO1xyXG4gICAgdmFyIFVzZXJUYXNrTm9kZSA9IHJlcXVpcmUoXCIuL25vZGUvdGFzay9Vc2VyVGFza05vZGVcIik7XHJcbiAgICB2YXIgTWFudWFsVGFza05vZGUgPSByZXF1aXJlKFwiLi9ub2RlL3Rhc2svTWFudWFsVGFza05vZGVcIik7XHJcbiAgICB2YXIgU2NyaXB0VGFza05vZGUgPSByZXF1aXJlKFwiLi9ub2RlL3Rhc2svU2NyaXB0VGFza05vZGVcIik7XHJcbiAgICB2YXIgTWFpbFRhc2tOb2RlID0gcmVxdWlyZShcIi4vbm9kZS90YXNrL01haWxUYXNrTm9kZVwiKTtcclxuICAgIHZhciBDYXRjaFRpbWVyRXZlbnROb2RlID0gcmVxdWlyZShcIi4vbm9kZS9ldmVudC9ib3VuZGFyeWV2ZW50L0NhdGNoVGltZXJFdmVudE5vZGVcIik7XHJcbiAgICB2YXIgQ2F0Y2hTaWduYWxFdmVudE5vZGUgPSByZXF1aXJlKFwiLi9ub2RlL2V2ZW50L2JvdW5kYXJ5ZXZlbnQvQ2F0Y2hTaWduYWxFdmVudE5vZGVcIik7XHJcbiAgICB2YXIgVGhyb3dTaWduYWxFdmVudE5vZGUgPSByZXF1aXJlKFwiLi9ub2RlL2V2ZW50L2JvdW5kYXJ5ZXZlbnQvVGhyb3dTaWduYWxFdmVudE5vZGVcIik7XHJcbiAgICB2YXIgSW5jbHVzaXZlR2F0ZXdheU5vZGUgPSByZXF1aXJlKFwiLi9ub2RlL2dhdGV3YXkvSW5jbHVzaXZlR2F0ZXdheU5vZGVcIik7XHJcbiAgICB2YXIgRXhjbHVzaXZlR2F0ZXdheU5vZGUgPSByZXF1aXJlKFwiLi9ub2RlL2dhdGV3YXkvRXhjbHVzaXZlR2F0ZXdheU5vZGVcIik7XHJcbiAgICB2YXIgUGFyYWxsZWxHYXRld2F5Tm9kZSA9IHJlcXVpcmUoXCIuL25vZGUvZ2F0ZXdheS9QYXJhbGxlbEdhdGV3YXlOb2RlXCIpO1xyXG4gICAgdmFyIFN1YlByY2Vzc05vZGUgPSByZXF1aXJlKFwiLi9ub2RlL1N1YlByb2Nlc3NOb2RlXCIpO1xyXG4gICAgdmFyIEJwbW4gPSByZXF1aXJlKFwiLi9CcG1uLmpzXCIpO1xyXG4gICAgLyoqXHJcbiAgICAgKiDmoLnmja7nu5PngrnmlbDnu4Qg5a+85Ye6SlNPTuagvOW8j+eahOaVsOaNrlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IG5vZGVzIOe7k+eCueaVsOe7hFxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGJwbW5Nb2RlbCBicG1u55qEbW9kZWxcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGNvbm5lY3RvcnMg5omA5pyJ6L+e57q/XHJcbiAgICAgKiBAcmV0dXJuIHtKU09OfSBKU09O5qC85byP55qE5pWw5o2uXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHRvSnNvbihicG1uTW9kZWwsIG5vZGVzLCBjb25uZWN0b3JzKSB7XHJcbiAgICAgICAgdmFyIGpzb25BcnIgPSBbXTtcclxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoO2krKyl7XHJcbiAgICAgICAgICAgIHZhciBub2RlID0gbm9kZXNbaV07XHJcbiAgICAgICAgICAgIC8v5Y675o6J5a2Q5rWB56iL6YeM6Z2i55qE6IqC54K5XHJcbiAgICAgICAgICAgIGlmIChub2RlLnBhcmVudCAmJiBCcG1uLmlzU3ViUHJvY2Vzcyhub2RlLnBhcmVudCkpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmKCBub2RlICYmIG5vZGUudG9KU09OKSB7XHJcbiAgICAgICAgICAgICAgICBqc29uQXJyLnB1c2gobm9kZS50b0pTT04oKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy/lop7liqDnur9cclxuICAgICAgICBmb3IodmFyIGogPSAwOyBqIDwgY29ubmVjdG9ycy5sZW5ndGg7aisrKXtcclxuICAgICAgICAgICAgdmFyIGNvbm5lY3RvciA9IGNvbm5lY3RvcnNbal07XHJcbiAgICAgICAgICAgIC8v5Y675o6J5a2Q5rWB56iL6YeM6Z2i55qE57q/5q61XHJcbiAgICAgICAgICAgIGlmIChjb25uZWN0b3IucGFyZW50ICYmIEJwbW4uaXNTdWJQcm9jZXNzKGNvbm5lY3Rvci5wYXJlbnQpKSB7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiggY29ubmVjdG9yICYmIGNvbm5lY3Rvci50b0pTT04pIHtcclxuICAgICAgICAgICAgICAgIGpzb25BcnIucHVzaChjb25uZWN0b3IudG9KU09OKCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGJwbW5Nb2RlbC5zZXQoXCJjaGlsZFNoYXBlc1wiLCBqc29uQXJyKTtcclxuXHJcblxyXG4gICAgICAgIHJldHVybiBicG1uTW9kZWwub3B0aW9uO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog5qC55o2uIEpTT04g55Sf5oiQ6IqC54K5XHJcbiAgICAgKiBAcGFyYW0gIHtbdHlwZV19IGZpc2hUb3BvQnBtbiBbZGVzY3JpcHRpb25dXHJcbiAgICAgKiBAcGFyYW0gIHtbdHlwZV19IGpzb24gICAgICAgICBbZGVzY3JpcHRpb25dXHJcbiAgICAgKiBAcmV0dXJuIHtbdHlwZV19ICAgICAgICAgICAgICBbZGVzY3JpcHRpb25dXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGZyb21Kc29uKGZpc2hUb3BvQnBtbiwganNvbikge1xyXG4gICAgICAgIC8vIDEu5riF56m655S75biDXHJcbiAgICAgICAgZmlzaFRvcG9CcG1uLmNsZWFyKHRydWUpO1xyXG5cclxuICAgICAgICAvLyAyLuWFiOWIm+W7uuiKgueCuSAg6YGN5Y6G5b2i54q2IOiOt+WPluaooeWei1xyXG4gICAgICAgIHZhciBicG1uTW9kZWwgPSBuZXcgQlBNTk1vZGVsKGpzb24pO1xyXG5cclxuICAgICAgICBmaXNoVG9wb0JwbW4ubW9kZWwgPSBicG1uTW9kZWw7XHJcblxyXG4gICAgICAgIHZhciBicG1uV2lkdGggPSBicG1uTW9kZWwuZ2V0KFwicHJvcGVydGllcy53aWR0aFwiKTtcclxuICAgICAgICB2YXIgYnBtbkhlaWdodCA9IGJwbW5Nb2RlbC5nZXQoXCJwcm9wZXJ0aWVzLmhlaWdodFwiKTtcclxuICAgICAgICBpZiAoYnBtbldpZHRoID4gMCAmJiBicG1uSGVpZ2h0ID4gMCkge1xyXG4gICAgICAgICAgICBmaXNoVG9wb0JwbW4ucmVzaXplKGJwbW5XaWR0aCxicG1uSGVpZ2h0KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBjaGlsZFNoYXBlcyA9IGJwbW5Nb2RlbC5nZXQoXCJjaGlsZFNoYXBlc1wiKTtcclxuICAgICAgICB2YXIgY29ubmVjdG9ycyA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRTaGFwZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIHNoYXBlID0gY2hpbGRTaGFwZXNbaV07XHJcbiAgICAgICAgICAgIHZhciB0eXBlID0gc2hhcGUuc3RlbmNpbC50eXBlO1xyXG5cclxuXHJcbiAgICAgICAgICAgIGlmICh0eXBlID09PSBCcG1uLlNFUVVFTkNFX0ZMT1cpIHtcclxuICAgICAgICAgICAgICAgIGNvbm5lY3RvcnMucHVzaChzaGFwZSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbW9kZWwgPSBuZXcgQlBNTk1vZGVsKHNoYXBlKTtcclxuICAgICAgICAgICAgICAgIHZhciBjcmVhdGVkTm9kZSA9IGZpc2hUb3BvQnBtbi5hZGROb2RlQnlNb2RlbChtb2RlbCxmYWxzZSx0cnVlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09IEJwbW4uU1VCX1BST0NFU1MpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc3ViTm9kZSA9IG1vZGVsLmdldChcImNoaWxkU2hhcGVzXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgc3ViTm9kZS5sZW5ndGg7IGorKykge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN1Yk1vZGVsID0gbmV3IEJQTU5Nb2RlbChzdWJOb2RlW2pdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoQnBtbi5pc0Zsb3dNb2RlbChzdWJNb2RlbCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpc2hUb3BvQnBtbi5hZGRDb25uZWN0b3JCeU1vZGVsKHN1Yk1vZGVsLCBjcmVhdGVkTm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3VwZXJVcHBlckxlZnQgPSBtb2RlbC5nZXQoXCJib3VuZHMudXBwZXJMZWZ0XCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN1YlVwcGVyTGVmdCA9IHN1Yk1vZGVsLmdldChcImJvdW5kcy51cHBlckxlZnRcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJNb2RlbC5zZXQoXCJib3VuZHMudXBwZXJMZWZ0XCIsIHsgeDogc3ViVXBwZXJMZWZ0LnggKyBzdXBlclVwcGVyTGVmdC54LCB5OiBzdWJVcHBlckxlZnQueSArIHN1cGVyVXBwZXJMZWZ0LnkgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaXNoVG9wb0JwbW4uYWRkTm9kZUJ5TW9kZWwoc3ViTW9kZWwsdHJ1ZSx0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyAzLiDlho3liJvlu7rnur9cclxuICAgICAgICBmb3IodmFyIGsgPSAwLCBsZW4gPSBjb25uZWN0b3JzLmxlbmd0aDsgayA8IGxlbjsgaysrKSB7XHJcbiAgICAgICAgICAgIHZhciBtb2RlbExpbmUgPSBuZXcgQlBNTk1vZGVsKGNvbm5lY3RvcnNba10pOyAvLyBzaGFwZVxyXG4gICAgICAgICAgICBmaXNoVG9wb0JwbW4uYWRkQ29ubmVjdG9yQnlNb2RlbChtb2RlbExpbmUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gNC7liJvlu7rkuovku7bmj5Lmp71cclxuICAgICAgICBmb3IgKHZhciBtID0gMDsgbSA8IGNoaWxkU2hhcGVzLmxlbmd0aDsgbSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChjaGlsZFNoYXBlc1ttXS5wcm9wZXJ0aWVzLnNsb3RFdmVudCkge1xyXG4gICAgICAgICAgICAgICAgZm9yKHZhciBuID0gMDtuIDwgY2hpbGRTaGFwZXNbbV0ucHJvcGVydGllcy5zbG90RXZlbnQubGVuZ3RoOyBuKyspe1xyXG4gICAgICAgICAgICAgICAgICAgIGZpbmROb2RlQnlJZChmaXNoVG9wb0JwbW4sY2hpbGRTaGFwZXNbbV0ucmVzb3VyY2VJZCkuc2xvdEV2ZW50LnB1c2goZmluZE5vZGVCeUlkKGZpc2hUb3BvQnBtbixjaGlsZFNoYXBlc1ttXS5wcm9wZXJ0aWVzLnNsb3RFdmVudFtuXSkpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOagueaNrmlk5ZyoZmlzaFRvcG9CcG1u5Lit5p+l5om+XHJcbiAgICAgKiBAcGFyYW0gIHtbdHlwZV19IGZpc2hUb3BvQnBtbiAgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICogQHBhcmFtICB7W3R5cGVdfSBub2RlSWQgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICogQHJldHVybiB7W3R5cGVdfSAgICAgICAgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBmaW5kTm9kZUJ5SWQoZmlzaFRvcG9CcG1uLCBub2RlSWQpIHtcclxuICAgICAgICB2YXIgbm9kZTtcclxuICAgICAgICBmb3IgKHZhciBpID0gZmlzaFRvcG9CcG1uLmFsbE5vZGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgICAgICAgIGlmIChmaXNoVG9wb0JwbW4uYWxsTm9kZXNbaV0ubW9kZWwuZ2V0KFwicmVzb3VyY2VJZFwiKSA9PSBub2RlSWQpIHtcclxuICAgICAgICAgICAgICAgIG5vZGUgPSBmaXNoVG9wb0JwbW4uYWxsTm9kZXNbaV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5vZGU7XHJcbiAgICB9XHJcblxyXG5cclxuXHJcbiAgICBmdW5jdGlvbiByZWdpc3RlckJQTU5Ob2RlICgpIHtcclxuICAgICAgICBCUE1OTm9kZS5yZWdpc3RlckNsYXNzKFN0YXJ0RXZlbnROb2RlLCBcIlN0YXJ0Tm9uZUV2ZW50XCIpO1xyXG4gICAgICAgIEJQTU5Ob2RlLnJlZ2lzdGVyQ2xhc3MoRW5kRXZlbnROb2RlLCBcIkVuZE5vbmVFdmVudFwiKTtcclxuICAgICAgICBCUE1OTm9kZS5yZWdpc3RlckNsYXNzKFVzZXJUYXNrTm9kZSwgXCJVc2VyVGFza1wiKTtcclxuICAgICAgICBCUE1OTm9kZS5yZWdpc3RlckNsYXNzKE1hbnVhbFRhc2tOb2RlLCBcIk1hbnVhbFRhc2tcIik7XHJcbiAgICAgICAgQlBNTk5vZGUucmVnaXN0ZXJDbGFzcyhTY3JpcHRUYXNrTm9kZSwgXCJTY3JpcHRUYXNrXCIpO1xyXG4gICAgICAgIEJQTU5Ob2RlLnJlZ2lzdGVyQ2xhc3MoTWFpbFRhc2tOb2RlLCBcIk1haWxUYXNrXCIpO1xyXG4gICAgICAgIEJQTU5Ob2RlLnJlZ2lzdGVyQ2xhc3MoQ2F0Y2hUaW1lckV2ZW50Tm9kZSwgXCJDYXRjaFRpbWVyRXZlbnRcIik7XHJcbiAgICAgICAgQlBNTk5vZGUucmVnaXN0ZXJDbGFzcyhDYXRjaFNpZ25hbEV2ZW50Tm9kZSwgXCJDYXRjaFNpZ25hbEV2ZW50XCIpO1xyXG4gICAgICAgIEJQTU5Ob2RlLnJlZ2lzdGVyQ2xhc3MoVGhyb3dTaWduYWxFdmVudE5vZGUsIFwiVGhyb3dTaWduYWxFdmVudFwiKTtcclxuICAgICAgICBCUE1OTm9kZS5yZWdpc3RlckNsYXNzKEluY2x1c2l2ZUdhdGV3YXlOb2RlLCBcIkluY2x1c2l2ZUdhdGV3YXlcIik7XHJcbiAgICAgICAgQlBNTk5vZGUucmVnaXN0ZXJDbGFzcyhFeGNsdXNpdmVHYXRld2F5Tm9kZSwgXCJFeGNsdXNpdmVHYXRld2F5XCIpO1xyXG4gICAgICAgIEJQTU5Ob2RlLnJlZ2lzdGVyQ2xhc3MoUGFyYWxsZWxHYXRld2F5Tm9kZSwgXCJQYXJhbGxlbEdhdGV3YXlcIik7XHJcbiAgICAgICAgQlBNTk5vZGUucmVnaXN0ZXJDbGFzcyhTdWJQcmNlc3NOb2RlLCBcIlN1YlByb2Nlc3NcIik7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIGZ1bmN0aW9uIGlzSG92ZXIobm9kZSwgeCwgeSkge1xyXG4gICAgICAgIHZhciBjeCAsIGN5O1xyXG4gICAgICAgIGlmKG5vZGUucGFyZW50KXtcclxuICAgICAgICAgICAgaWYobm9kZS5wYXJlbnQubW9kZWwuZ2V0KFwic3RlbmNpbC50eXBlXCIpID09IFwiU3ViUHJvY2Vzc1wiKXtcclxuICAgICAgICAgICAgICAgIGN4ID0geCAtIG5vZGUucGFyZW50LmdldFJlY3QoKS5ib3VuZGluZ1JlY3QueDtcclxuICAgICAgICAgICAgICAgIGN5ID0geSAtIG5vZGUucGFyZW50LmdldFJlY3QoKS5ib3VuZGluZ1JlY3QueTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBub2RlLnJlY3RDb250YWluKGN4LCBjeSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICByZXR1cm4gbm9kZS5yZWN0Q29udGFpbih4LCB5KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBmaW5kSG92ZXIobGlzdCwgeCwgeSwgZXhjbHVkZXMpIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gbGlzdC5sZW5ndGggLSAxOyBpID49IDAgOyBpLS0pIHtcclxuICAgICAgICAgICAgaWYgKGlzRXhjbHVkZShleGNsdWRlcyxsaXN0W2ldKSAvL2xpc3RbaV0gIT09IGV4Y2x1ZGVcclxuICAgICAgICAgICAgIC8vIGdldERpc3BsYXlMaXN0IG1heSBpbmNsdWRlIGlnbm9yZWQgaXRlbSBpbiBWTUwgbW9kZVxyXG4gICAgICAgICAgICAgJiYgIWxpc3RbaV0uaWdub3JlXHJcbiAgICAgICAgICAgICAmJiBpc0hvdmVyKGxpc3RbaV0sIHgsIHkpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbGlzdFtpXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcblxyXG4gICAgZnVuY3Rpb24gaXNFeGNsdWRlKGV4Y2x1ZGVzLCBub2RlKSB7XHJcbiAgICAgICAgcmV0dXJuIHpyVXRpbC5pbmRleE9mKGV4Y2x1ZGVzLG5vZGUpID09IC0xO1xyXG4gICAgIH1cclxuXHJcblxyXG5cclxuXHJcbiAgICB2YXIgQnBtblV0aWwgPSB7XHJcbiAgICAgICAgdG9Kc29uOiB0b0pzb24sXHJcbiAgICAgICAgZnJvbUpzb246IGZyb21Kc29uLFxyXG4gICAgICAgIHJlZ2lzdGVyQlBNTk5vZGU6IHJlZ2lzdGVyQlBNTk5vZGUsXHJcbiAgICAgICAgZmluZEhvdmVyOiBmaW5kSG92ZXJcclxuICAgIH07XHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IEJwbW5VdGlsO1xyXG5cclxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2xpYi9maXNoLXRvcG8tYnBtbi9saWIvQnBtblV0aWwuanNcbiAqKiBtb2R1bGUgaWQgPSA3MlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXHJcbiAqIOW3peWFt+aWueazleexu1xyXG4gKiBAYXV0aG9yIHdhbmcueGlhb2h1XHJcbiAqL1xyXG5cclxuICAgIHZhciBQb2ludCA9IHJlcXVpcmUoXCIuL1BvaW50LmpzXCIpO1xyXG4gICAgdmFyIExpbmUgPSByZXF1aXJlKFwiLi9MaW5lU3RydWN0LmpzXCIpO1xyXG4gICAgdmFyIGdyYXBoaWMgPSByZXF1aXJlKFwiLi9ncmFwaGljLmpzXCIpO1xyXG4gICAgdmFyIEJvdW5kaW5nUmVjdCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvQm91bmRpbmdSZWN0Jyk7XHJcbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XHJcbiAgICAvKipcclxuICAgICAqIOaehOmAoOexu+e7p+aJv+WFs+ezu1xyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNsYXp6IOa6kOexu1xyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gYmFzZUNsYXp6IOWfuuexu1xyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBpbmhlcml0cyhjbGF6eiwgYmFzZUNsYXp6KSB7XHJcbiAgICAgICAgdmFyIGNsYXp6UHJvdG90eXBlID0gY2xhenoucHJvdG90eXBlO1xyXG5cclxuICAgICAgICBmdW5jdGlvbiBGKCkge31cclxuICAgICAgICBGLnByb3RvdHlwZSA9IGJhc2VDbGF6ei5wcm90b3R5cGU7XHJcbiAgICAgICAgY2xhenoucHJvdG90eXBlID0gbmV3IEYoKTtcclxuXHJcbiAgICAgICAgZm9yICh2YXIgcHJvcCBpbiBjbGF6elByb3RvdHlwZSkge1xyXG4gICAgICAgICAgICBjbGF6ei5wcm90b3R5cGVbcHJvcF0gPSBjbGF6elByb3RvdHlwZVtwcm9wXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2xhenoucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY2xheno7XHJcbiAgICAgICAgY2xhenouc3VwZXJDbGFzcyA9IGJhc2VDbGF6ejtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBnZXRVVUlEKCkge1xyXG4gICAgICAgIHZhciBjaGFycyA9ICcwMTIzNDU2Nzg5QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5eicuc3BsaXQoJycpLFxyXG4gICAgICAgICAgICB1dWlkID0gbmV3IEFycmF5KDM2KSxcclxuICAgICAgICAgICAgcm5kID0gMCxcclxuICAgICAgICAgICAgcjtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDM2OyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKGkgPT0gOCB8fCBpID09IDEzIHx8IGkgPT0gMTggfHwgaSA9PSAyMykge1xyXG4gICAgICAgICAgICAgICAgdXVpZFtpXSA9ICctJztcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChpID09IDE0KSB7XHJcbiAgICAgICAgICAgICAgICB1dWlkW2ldID0gJzQnO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKHJuZCA8PSAweDAyKSBybmQgPSAweDIwMDAwMDAgKyAoTWF0aC5yYW5kb20oKSAqIDB4MTAwMDAwMCkgfCAwO1xyXG4gICAgICAgICAgICAgICAgciA9IHJuZCAmIDB4ZjtcclxuICAgICAgICAgICAgICAgIHJuZCA9IHJuZCA+PiA0O1xyXG4gICAgICAgICAgICAgICAgdXVpZFtpXSA9IGNoYXJzWyhpID09IDE5KSA/IChyICYgMHgzKSB8IDB4OCA6IHJdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBcInNpZC1cIiArIHV1aWQuam9pbignJyk7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICog6K6h566X5Lik54K55LmL6Ze055qE6Led56a7XHJcbiAgICAgKkBwYXJhbSB7UG9pbnR9IHAxIC0gZmlyc3Qge1BvaW50fVxyXG4gICAgICpAcGFyYW0ge1BvaW50fSBwMiAtIHNlY29uZCB7UG9pbnR9XHJcbiAgICAgKkByZXR1cm4ge051bWJlcn0gLSB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0aG9zZSAyIHBvaW50cy4gSXQgaXMgYWx3YXlzIHBvc2l0aXZlLlxyXG4gICAgICoqL1xyXG4gICAgZnVuY3Rpb24gZGlzdGFuY2UocDEsIHAyKSB7XHJcbiAgICAgICAgcmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyhwMS54IC0gcDIueCwgMikgKyBNYXRoLnBvdyhwMS55IC0gcDIueSwgMikpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog6L+U5Zue5LiA5p2h5oqY57q/IOacgOmVv+eahOS4pOS4queCuVxyXG4gICAgICogQHBhcmFtICB7W3R5cGVdfSBwb2ludHMgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICogQHJldHVybiB7W3R5cGVdfSAgICAgICAgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBnZXRNYXhMaW5lTGVuZ3RoKHBvaW50cykge1xyXG4gICAgICAgIHZhciBtID0gZGlzdGFuY2UocG9pbnRzWzBdLCBwb2ludHNbMV0pO1xyXG4gICAgICAgIHZhciByZXN1bHQgPSBbcG9pbnRzWzBdLCBwb2ludHNbMV1dO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgcG9pbnRzLmxlbmd0aCAtIDE7IGkrKykge1xyXG5cclxuICAgICAgICAgICAgaWYgKG0gPCBkaXN0YW5jZShwb2ludHNbaV0sIHBvaW50c1tpICsgMV0pKSB7XHJcbiAgICAgICAgICAgICAgICBtID0gZGlzdGFuY2UocG9pbnRzW2ldLCBwb2ludHNbaSArIDFdKVxyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gW3BvaW50c1tpXSwgcG9pbnRzW2kgKyAxXV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqUmV0dXJucyB0aGUgbGVuZ3RoIG9mIGEgUG9seWxpbmUgdGhhdCB3b3VsZCBiZSBjcmVhdGVkIHdpdGggYSBzZXQgb2YgcG9pbnRzXHJcbiAgICAgKkBwYXJhbSB7QXJyYXl9IHYgLSBhbiB7QXJyYXl9IG9mIHtQb2ludHN9XHJcbiAgICAgKkByZXR1cm4ge051bWJlcn0gLSBhIHBvc2l0aXZlIG51bWJlciBlcXVhbCB3aXRoIHRvdGFsIGxlbmd0aCovXHJcbiAgICBmdW5jdGlvbiBnZXRQb2x5bGluZUxlbmd0aCh2KSB7XHJcbiAgICAgICAgdmFyIGwgPSAwO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdi5sZW5ndGggLSAxOyBpKyspIHtcclxuICAgICAgICAgICAgbCArPSBkaXN0YW5jZSh2W2ldLCB2W2kgKyAxXSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gbDtcclxuICAgIH1cclxuXHJcblxyXG4gICAgLyoqUmV0dXJucyB0aGUgbWF4IG9mIGEgdmVjdG9yXHJcbiAgICAgKkBwYXJhbSB7QXJyYXl9IHYgLSB2ZWN0b3Igb2Yge051bWJlcn1zXHJcbiAgICAgKkByZXR1cm4ge051bWJlcn0gLSB0aGUgbWF4aW11bSBudW1iZXIgZnJvbSB0aGUgdmVjdG9yIG9yIE5hTiBpZiB2ZWN0b3IgaXMgZW1wdHlcclxuICAgICAqKi9cclxuICAgIGZ1bmN0aW9uIG1heCh2KSB7XHJcbiAgICAgICAgaWYgKHYubGVuZ2h0ID09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIE5hTjtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB2YXIgbSA9IHZbMF07XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKG0gPCB2W2ldKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbSA9IHZbaV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBtO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcblxyXG4gICAgLyoqUmV0dXJucyB0aGUgbWluIG9mIGEgdmVjdG9yXHJcbiAgICAgKkBwYXJhbSB7QXJyYXl9IHYgLSB2ZWN0b3Igb2Yge051bWJlcn1zXHJcbiAgICAgKkByZXR1cm4ge051bWJlcn0gLSB0aGUgbWluaW11bSBudW1iZXIgZnJvbSB0aGUgdmVjdG9yIG9yIE5hTiBpZiB2ZWN0b3IgaXMgZW1wdHlcclxuICAgICAqQGF1dGhvciBhbGV4QHNjcmlwdG9pZC5jb21cclxuICAgICAqKi9cclxuICAgIGZ1bmN0aW9uIG1pbih2KSB7XHJcbiAgICAgICAgaWYgKHYubGVuZ2h0ID09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIE5hTjtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB2YXIgbSA9IHZbMF07XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKG0gPiB2W2ldKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbSA9IHZbaV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBtO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOWIpOaWrSDngrnmlbDnu4Qg5piv5ZCm5q2j5Lqk55u057q/6Lev5b6EXHJcbiAgICAgKlRlc3RzIGlmIGEgdmVjdG9yIG9mIHBvaW50cyBpcyBhbiBvcnRob2dvbmFsIHBhdGggKG1vdmluZyBpbiBtdWx0aXBsZXMgb2YgOTAgZGVncmVlcylcclxuICAgICAqQHBhcmFtIHtBcnJheX0gdiAtIGFuIHtBcnJheX0gb2Yge1BvaW50fXNcclxuICAgICAqQHJldHVybiB7Qm9vbGVhbn0gLSB0cnVlIGlmIHBhdGggaXMgdmFsaWQsIGZhbHNlIG90aGVyd2lzZVxyXG4gICAgICoqL1xyXG4gICAgZnVuY3Rpb24gb3J0aG9nb25hbFBhdGgodikge1xyXG4gICAgICAgIGlmICh2Lmxlbmd0aCA8PSAxKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2Lmxlbmd0aCAtIDE7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAodltpXS54ICE9IHZbaSArIDFdLnggJiYgdltpXS55ICE9IHZbaSArIDFdLnkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICpUZXN0IHRvIHNlZSBpZiAyIHtMaW5lfXMgaW50ZXJzZWN0cy4gVGhleSBhcmUgY29uc2lkZXJlZCBmaW5pdGUgc2VnbWVudHNcclxuICAgICAqYW5kIG5vdCB0aGUgaW5maW5pdGUgbGluZXMgZnJvbSBnZW9tZXRyeVxyXG4gICAgICpAcGFyYW0ge0xpbmV9IGwxIC0gZmlzdCBsaW5lL3NlZ21lbnRcclxuICAgICAqQHBhcmFtIHtMaW5lfSBsMiAtIGxhc3QgbGluZS9zZWdtZW50XHJcbiAgICAgKkByZXR1cm4ge0Jvb2xlYW59IHRydWUgLSBpZiB0aGUgbGluZXMgaW50ZXJzZWN0IG9yIGZhbHNlIGlmIG5vdFxyXG4gICAgICoqL1xyXG4gICAgZnVuY3Rpb24gbGluZUludGVyc2VjdHNMaW5lKGwxLCBsMikge1xyXG4gICAgICAgIC8vIGNoZWNrIGZvciB0d28gdmVydGljYWwgbGluZXNcclxuICAgICAgICBpZiAobDEuc3RhcnRQb2ludC54ID09IGwxLmVuZFBvaW50LnggJiYgbDIuc3RhcnRQb2ludC54ID09IGwyLmVuZFBvaW50LngpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGwxLnN0YXJ0UG9pbnQueCA9PSBsMi5zdGFydFBvaW50LnggPyAvLyBpZiAnaW5maW5pdGUgJ2xpbmVzIGRvIGNvaW5jaWRlLFxyXG4gICAgICAgICAgICAgICAgLy8gdGhlbiBjaGVjayBzZWdtZW50IGJvdW5kcyBmb3Igb3ZlcmxhcHBpbmdcclxuICAgICAgICAgICAgICAgIGwxLmNvbnRhaW5zKGwyLnN0YXJ0UG9pbnQueCwgbDIuc3RhcnRQb2ludC55KSB8fFxyXG4gICAgICAgICAgICAgICAgbDEuY29udGFpbnMobDIuZW5kUG9pbnQueCwgbDIuZW5kUG9pbnQueSkgOlxyXG4gICAgICAgICAgICAgICAgLy8gbGluZXMgYXJlIHBhcmFsZWxcclxuICAgICAgICAgICAgICAgIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBpZiBvbmUgbGluZSBpcyB2ZXJ0aWNhbCwgYW5kIGFub3RoZXIgbGluZSBpcyBub3QgdmVydGljYWxcclxuICAgICAgICBlbHNlIGlmIChsMS5zdGFydFBvaW50LnggPT0gbDEuZW5kUG9pbnQueCB8fCBsMi5zdGFydFBvaW50LnggPT0gbDIuZW5kUG9pbnQueCkge1xyXG4gICAgICAgICAgICAvLyBsZXQgYXNzdW1lIGwyIGlzIHZlcnRpY2FsLCBvdGhlcndpc2UgZXhjaGFuZ2UgdGhlbVxyXG4gICAgICAgICAgICBpZiAobDEuc3RhcnRQb2ludC54ID09IGwxLmVuZFBvaW50LngpIHtcclxuICAgICAgICAgICAgICAgIHZhciBsID0gbDE7XHJcbiAgICAgICAgICAgICAgICBsMSA9IGwyO1xyXG4gICAgICAgICAgICAgICAgbDIgPSBsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGZpbmRpbmcgaW50ZXJzZWN0aW9uIG9mICdpbmZpbml0ZScgbGluZXNcclxuICAgICAgICAgICAgLy8gZXF1YXRpb24gb2YgdGhlIGZpcnN0IGxpbmUgaXMgeSA9IGF4ICsgYiwgc2Vjb25kOiB4ID0gY1xyXG4gICAgICAgICAgICB2YXIgYSA9IChsMS5lbmRQb2ludC55IC0gbDEuc3RhcnRQb2ludC55KSAvIChsMS5lbmRQb2ludC54IC0gbDEuc3RhcnRQb2ludC54KTtcclxuICAgICAgICAgICAgdmFyIGIgPSBsMS5zdGFydFBvaW50LnkgLSBhICogbDEuc3RhcnRQb2ludC54O1xyXG4gICAgICAgICAgICB2YXIgeDAgPSBsMi5zdGFydFBvaW50Lng7XHJcbiAgICAgICAgICAgIHZhciB5MCA9IGEgKiB4MCArIGI7XHJcbiAgICAgICAgICAgIHJldHVybiBsMS5jb250YWlucyh4MCwgeTApICYmIGwyLmNvbnRhaW5zKHgwLCB5MCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBjaGVjayBub3JtYWwgY2FzZSAtIGJvdGggbGluZXMgYXJlIG5vdCB2ZXJ0aWNhbFxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvL2xpbmUgZXF1YXRpb24gaXMgOiB5ID0gYSp4ICsgYiwgYiA9IHkgLSBhICogeFxyXG4gICAgICAgICAgICB2YXIgYTEgPSAobDEuZW5kUG9pbnQueSAtIGwxLnN0YXJ0UG9pbnQueSkgLyAobDEuZW5kUG9pbnQueCAtIGwxLnN0YXJ0UG9pbnQueCk7XHJcbiAgICAgICAgICAgIHZhciBiMSA9IGwxLnN0YXJ0UG9pbnQueSAtIGExICogbDEuc3RhcnRQb2ludC54O1xyXG5cclxuICAgICAgICAgICAgdmFyIGEyID0gKGwyLmVuZFBvaW50LnkgLSBsMi5zdGFydFBvaW50LnkpIC8gKGwyLmVuZFBvaW50LnggLSBsMi5zdGFydFBvaW50LngpO1xyXG4gICAgICAgICAgICB2YXIgYjIgPSBsMi5zdGFydFBvaW50LnkgLSBhMiAqIGwyLnN0YXJ0UG9pbnQueDtcclxuXHJcbiAgICAgICAgICAgIGlmIChhMSA9PSBhMikgeyAvL3BhcmFsZWwgbGluZXNcclxuICAgICAgICAgICAgICAgIHJldHVybiBiMSA9PSBiMiA/XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZm9yIGNvaW5jaWRlIGxpbmVzLCBjaGVjayBmb3Igc2VnbWVudCBib3VuZHMgb3ZlcmxhcHBpbmdcclxuICAgICAgICAgICAgICAgICAgICBsMS5jb250YWlucyhsMi5zdGFydFBvaW50LngsIGwyLnN0YXJ0UG9pbnQueSkgfHwgbDEuY29udGFpbnMobDIuZW5kUG9pbnQueCwgbDIuZW5kUG9pbnQueSkgOlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIG5vdCBjb2luY2lkZSBwYXJhbGVsIGxpbmVzIGhhdmUgbm8gY2hhbmNlIHRvIGludGVyc2VjdFxyXG4gICAgICAgICAgICAgICAgICAgIGZhbHNlO1xyXG4gICAgICAgICAgICB9IGVsc2UgeyAvL3VzdWFsIGNhc2UgLSBub24gcGFyYWxlbCwgdGhlICdpbmZpbml0ZScgbGluZXMgaW50ZXJzZWN0cy4uLndlIG9ubHkgbmVlZCB0byBrbm93IGlmIGluc2lkZSB0aGUgc2VnbWVudFxyXG5cclxuICAgICAgICAgICAgICAgIC8qXHJcbiAgICAgICAgICAgICAgICAgKiBpZiBvbmUgb2YgdGhlIGxpbmVzIGFyZSB2ZXJ0aWNhbCwgdGhlbiB4MCBpcyBlcXVhbCB0byB0aGVpciB4LFxyXG4gICAgICAgICAgICAgICAgICogb3RoZXJ3aXNlOlxyXG4gICAgICAgICAgICAgICAgICogeTEgPSBhMSAqIHggKyBiMVxyXG4gICAgICAgICAgICAgICAgICogeTIgPSBhMiAqIHggKyBiMlxyXG4gICAgICAgICAgICAgICAgICogPT4geDAgPSAoYjIgLSBiMSkgLyAoYTEgLSBhMilcclxuICAgICAgICAgICAgICAgICAqID0+IHkwID0gYTEgKiB4MCArIGIxXHJcbiAgICAgICAgICAgICAgICAgKiovXHJcbiAgICAgICAgICAgICAgICB4MCA9IChiMiAtIGIxKSAvIChhMSAtIGEyKTtcclxuICAgICAgICAgICAgICAgIHkwID0gYTEgKiB4MCArIGIxO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGwxLmNvbnRhaW5zKHgwLCB5MCkgJiYgbDIuY29udGFpbnMoeDAsIHkwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqXHJcbiAgICAgKlRlc3RzIGlmIGEgYSBwb2x5bGluZSBkZWZpbmVkIGJ5IGEgc2V0IG9mIHBvaW50cyBpbnRlcnNlY3RzIGEgcmVjdGFuZ2xlXHJcbiAgICAgKkBwYXJhbSB7QXJyYXl9IHBvaW50cyAtIGFuZCB7QXJyYXl9IG9mIHtQb2ludH1zXHJcbiAgICAgKkBwYXJhbSB7QXJyYXl9IGJvdW5kcyAtIHRoZSBib3VuZHMgb2YgdGhlIHJlY3RhbmdsZSBkZWZpbmVkIGJ5ICh4MSwgeTEsIHgyLCB5MilcclxuICAgICAqQHBhcmFtIHtCb29sZWFufSBjbG9zZWRQb2x5bGluZSAtIGluY2FzZSBwb2x5bGluZSBpcyBjbG9zZWQgZmlndXJlIHRoZW4gdHJ1ZSwgZWxzZSBmYWxzZVxyXG4gICAgICpcclxuICAgICAqQHJldHVybiB0cnVlIC0gaWYgbGluZSBpbnRlcnNlY3RzIHRoZSByZWN0YW5nbGUsIGZhbHNlIC0gaWYgbm90XHJcbiAgICAgKiovXHJcbiAgICBmdW5jdGlvbiBwb2x5bGluZUludGVyc2VjdHNSZWN0YW5nbGUocG9pbnRzLCBib3VuZHMsIGNsb3NlZFBvbHlsaW5lKSB7XHJcblxyXG5cclxuICAgICAgICAvL2dldCB0aGUgNCBsaW5lcy9zZWdtZW50cyByZXByZXNlbnRlZCBieSB0aGUgYm91bmRzXHJcbiAgICAgICAgdmFyIGxpbmVzID0gW107XHJcbiAgICAgICAgbGluZXMucHVzaChuZXcgTGluZShuZXcgUG9pbnQoYm91bmRzWzBdLCBib3VuZHNbMV0pLCBuZXcgUG9pbnQoYm91bmRzWzJdLCBib3VuZHNbMV0pKSk7XHJcbiAgICAgICAgbGluZXMucHVzaChuZXcgTGluZShuZXcgUG9pbnQoYm91bmRzWzJdLCBib3VuZHNbMV0pLCBuZXcgUG9pbnQoYm91bmRzWzJdLCBib3VuZHNbM10pKSk7XHJcbiAgICAgICAgbGluZXMucHVzaChuZXcgTGluZShuZXcgUG9pbnQoYm91bmRzWzJdLCBib3VuZHNbM10pLCBuZXcgUG9pbnQoYm91bmRzWzBdLCBib3VuZHNbM10pKSk7XHJcbiAgICAgICAgbGluZXMucHVzaChuZXcgTGluZShuZXcgUG9pbnQoYm91bmRzWzBdLCBib3VuZHNbM10pLCBuZXcgUG9pbnQoYm91bmRzWzBdLCBib3VuZHNbMV0pKSk7XHJcblxyXG4gICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgcG9pbnRzLmxlbmd0aCAtIDE7IGsrKykge1xyXG4gICAgICAgICAgICAvL2NyZWF0ZSBhIGxpbmUgb3V0IG9mIGVhY2ggMiBjb25zZWN1dGl2ZSBwb2ludHNcclxuICAgICAgICAgICAgdmFyIHRlbXBMaW5lID0gbmV3IExpbmUocG9pbnRzW2tdLCBwb2ludHNbayArIDFdKTtcclxuXHJcbiAgICAgICAgICAgIC8vc2VlIGlmIHRoYXQgbGluZSBpbnRlcnNlY3QgYW55IG9mIHRoZSBsaW5lIG9uIGJvdW5kcyBib3JkZXJcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGxpbmVJbnRlcnNlY3RzTGluZSh0ZW1wTGluZSwgbGluZXNbaV0pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vY2hlY2sgdGhlIGNsb3NlZCBmaWd1cmUgLSB0aGF0IGlzIGxhc3QgcG9pbnQgY29ubmVjdGVkIHRvIHRoZSBmaXJzdFxyXG4gICAgICAgIGlmIChjbG9zZWRQb2x5bGluZSkge1xyXG4gICAgICAgICAgICAvL2NyZWF0ZSBhIGxpbmUgb3V0IG9mIGVhY2ggMiBjb25zZWN1dGl2ZSBwb2ludHNcclxuICAgICAgICAgICAgdmFyIHRlbXBMaW5lMSA9IG5ldyBMaW5lKHBvaW50c1twb2ludHMubGVuZ3RoIC0gMV0sIHBvaW50c1swXSk7XHJcblxyXG4gICAgICAgICAgICAvL3NlZSBpZiB0aGF0IGxpbmUgaW50ZXJzZWN0IGFueSBvZiB0aGUgbGluZSBvbiBib3VuZHMgYm9yZGVyXHJcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbGluZXMubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgICAgIGlmIChsaW5lSW50ZXJzZWN0c0xpbmUodGVtcExpbmUxLCBsaW5lc1tqXSkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog6K6h566X6Lev5b6E55qE5YiG5pWwXHJcbiAgICAgKiBTY29yZSBhIG9ydG9nb25hbCBwYXRoIG1hZGUgb3V0IG9mIFBvaW50c1xyXG4gICAgICpJdGVyYXRlcyBvdmVyIGEgc2V0IG9mIHBvaW50cyAobWluaW11bSAzKVxyXG4gICAgICpGb3IgZWFjaCAzIHBvaW50cyAoaSwgaSsxLCBpKzIpIDpcclxuICAgICAqICAtIGlmIHRoZSAzcmQgb25lIGlzIGFmdGVyIHRoZSAybmQgb24gdGhlIHNhbWUgbGluZSB3ZSBhZGQgKzFcclxuICAgICAqICAtIGlmIHRoZSAzcmQgaXMgdXAgb3IgZG93biByZWxhdGVkIHRvIHRoZSAybmQgd2UgZG8gbm90IGRvIGFueXRoaW5nICswXHJcbiAgICAgKiAgLSBpZiB0aGUgM3JkIGdvZXMgYmFjayB3ZSBpbWVkaWF0ZWxseSByZXR1cm4gLTFcclxuICAgICAqQHBhcmFtIHtBcnJheX0gdiAtIGFuIGFycmF5IG9mIHtQb2ludH1zXHJcbiAgICAgKkByZXR1cm4ge051bWJlcn0gLSAtMSBpZiB0aGUgcGF0aCBpcyB3cm9uZyAoZ29lcyBiYWNrKSBvciBzb21ldGhpbmcgPj0gMCBpZiBpcyBmaW5lXHJcbiAgICAgKiAgVGhlIGJpZ2dlciB0aGUgbnVtYmVyIHRoZSBzbW9vdGggdGhlIHBhdGggaXNcclxuICAgICAqKi9cclxuICAgIGZ1bmN0aW9uIHNjb3JlUGF0aCh2KSB7XHJcbiAgICAgICAgaWYgKHYubGVuZ3RoIDw9IDIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHNjb3JlID0gMDtcclxuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IHYubGVuZ3RoIC0gMTsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmICh2W2kgLSAxXS54ID09IHZbaV0ueCAmJiB2W2ldLnggPT0gdltpICsgMV0ueCkgeyAvL29uIHRoZSBzYW1lIHZlcnRpY2FsXHJcbiAgICAgICAgICAgICAgICBpZiAoc2lnbnVtKHZbaSArIDFdLnkgLSB2W2ldLnkpID09IHNpZ251bSh2W2ldLnkgLSB2W2kgLSAxXS55KSkgeyAvL3NhbWUgZGlyZWN0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgc2NvcmUrKztcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7IC8vZ29pbmcgYmFjayAtIG5vIGdvb2RcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodltpIC0gMV0ueSA9PSB2W2ldLnkgJiYgdltpXS55ID09IHZbaSArIDFdLnkpIHsgLy9vbiB0aGUgc2FtZSBob3Jpem9udGFsXHJcbiAgICAgICAgICAgICAgICBpZiAoc2lnbnVtKHZbaSArIDFdLnggLSB2W2ldLngpID09IHNpZ251bSh2W2ldLnggLSB2W2kgLSAxXS54KSkgeyAvL3NhbWUgZGlyZWN0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgc2NvcmUrKztcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7IC8vZ29pbmcgYmFjayAtIG5vIGdvb2RcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7IC8vbm90IG9uIHNhbWUgdmVydGljYWwgbm9yIGhvcml6b250YWxcclxuICAgICAgICAgICAgICAgIHNjb3JlLS07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBzY29yZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOi/lOWbnuaVsOWtl+espuWPt++8iCsgLSlcclxuICAgICAqIFJldHVybnMgdGhlIHNpZ24gb2YgYSBudW1iZXJcclxuICAgICAqQHBhcmFtIHtOdW1iZXJ9IHggLSB0aGUgbnVtYmVyXHJcbiAgICAgKkByZXR1cm5zIHtOdW1iZXJ9XHJcbiAgICAgKkBzZWUgPGEgaHJlZj1cImh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU2lnbl9mdW5jdGlvblwiPmh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU2lnbl9mdW5jdGlvbjwvYT5cclxuICAgICAqKi9cclxuICAgIGZ1bmN0aW9uIHNpZ251bSh4KSB7XHJcbiAgICAgICAgaWYgKHggPiAwKVxyXG4gICAgICAgICAgICByZXR1cm4gMTtcclxuICAgICAgICBlbHNlIGlmICh4IDwgMClcclxuICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDliKTmlq0g54K55pWw57uEIOaYr+S4jeaYr+acieaViOi3r+W+hO+8iOayoeacieWbnui3r++8iVxyXG4gICAgICpUZXN0cyBpZiBhIHZlY3RvciBvZiBwb2ludHMgaXMgYSB2YWxpZCBwYXRoIChub3QgZ29pbmcgYmFjaylcclxuICAgICAqVGhlcmUgYXJlIGEgZmV3IHByb2JsZW1zIGhlcmUuIElmIHlvdSBoYXZlIHAxLCBwMiwgcDMgYW5kIHA0IGFuZCBwMiA9IHAzIHlvdSBuZWVkIHRvIGlnbm9yZSB0aGF0XHJcbiAgICAgKkBwYXJhbSB7QXJyYXl9IHYgLSBhbiB7QXJyYXl9IG9mIHtQb2ludH1zXHJcbiAgICAgKkByZXR1cm4ge0Jvb2xlYW59IC0gdHJ1ZSBpZiBwYXRoIGlzIHZhbGlkLCBmYWxzZSBvdGhlcndpc2VcclxuICAgICAqKi9cclxuICAgIGZ1bmN0aW9uIGZvcndhcmRQYXRoKHYpIHtcclxuICAgICAgICBpZiAodi5sZW5ndGggPD0gMikge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdi5sZW5ndGggLSAyOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKHZbaV0ueCA9PSB2W2kgKyAxXS54ICYmIHZbaSArIDFdLnggPT0gdltpICsgMl0ueCkgeyAvL29uIHRoZSBzYW1lIHZlcnRpY2FsXHJcbiAgICAgICAgICAgICAgICBpZiAoc2lnbnVtKHZbaSArIDFdLnkgLSB2W2ldLnkpICE9IDApIHsgLy90ZXN0IG9ubHkgd2UgaGF2ZSBhIHByb2dyZXNzaW5nIHBhdGhcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc2lnbnVtKHZbaSArIDFdLnkgLSB2W2ldLnkpID09IC0xICogc2lnbnVtKHZbaSArIDJdLnkgLSB2W2kgKyAxXS55KSkgeyAvL2dvaW5nIGJhY2sgKGlnbm9yZSB6ZXJvKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHZbaV0ueSA9PSB2W2kgKyAxXS55ICYmIHZbaSArIDFdLnkgPT0gdltpICsgMl0ueSkgeyAvL29uIHRoZSBzYW1lIGhvcml6b250YWxcclxuICAgICAgICAgICAgICAgIGlmIChzaWdudW0odltpICsgMV0ueCAtIHZbaV0ueCkgIT0gMCkgeyAvL3Rlc3Qgb25seSB3ZSBoYXZlIGEgcHJvZ3Jlc3NpbmcgcGF0aFxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzaWdudW0odltpICsgMV0ueCAtIHZbaV0ueCkgPT0gLTEgKiBzaWdudW0odltpICsgMl0ueCAtIHZbaSArIDFdLngpKSB7IC8vZ29pbmcgYmFjayAoaWdub3JlIHplcm8pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog5bCGW3g6MCx5OjBd6L2s5YyW5Li6WzAsIDBdICDnu5l6cmVuZGVy5L2/55SoXHJcbiAgICAgKiBAcGFyYW0gIHtbdHlwZV19IHBvaW50cyBbZGVzY3JpcHRpb25dXHJcbiAgICAgKiBAcGFyYW0gIHtbdHlwZV19IGlzUmV2ZXJ0IFtkZXNjcmlwdGlvbl1cclxuICAgICAqIEByZXR1cm4ge1t0eXBlXX0gICAgICAgIFtkZXNjcmlwdGlvbl1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gdHJhc2xhdGVQb2ludHMocG9pbnRzLCBpc1JldmVydCkge1xyXG4gICAgICAgIHZhciBuZXdQb2ludHMgPSBbXTtcclxuICAgICAgICBpZiAoaXNSZXZlcnQpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBwb2ludCA9IHBvaW50c1tpXTtcclxuICAgICAgICAgICAgICAgIG5ld1BvaW50cy5wdXNoKG5ldyBQb2ludChwb2ludFswXSwgcG9pbnRbMV0pKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbmV3UG9pbnRzO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcG9pbnRzLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcG9pbnQxID0gcG9pbnRzW2pdO1xyXG4gICAgICAgICAgICAgICAgbmV3UG9pbnRzLnB1c2goW3BvaW50MS54LCBwb2ludDEueV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBuZXdQb2ludHM7XHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gcm90YXRpb25NYXRyaXgoYW5nbGUpIHtcclxuICAgICAgICB2YXIgbVJldHVybiA9IFtcclxuICAgICAgICAgICAgW01hdGguY29zKGFuZ2xlKSwgLU1hdGguc2luKGFuZ2xlKSwgMF0sXHJcbiAgICAgICAgICAgIFtNYXRoLnNpbihhbmdsZSksIE1hdGguY29zKGFuZ2xlKSwgMF0sXHJcbiAgICAgICAgICAgIFswLCAwLCAxXVxyXG4gICAgICAgIF07XHJcbiAgICAgICAgcmV0dXJuIG1SZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gdHJhbnNsYXRpb25NYXRyaXgoZHgsIGR5KSB7XHJcbiAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgWzEsIDAsIGR4XSxcclxuICAgICAgICAgICAgWzAsIDEsIGR5XSxcclxuICAgICAgICAgICAgWzAsIDAsIDFdXHJcbiAgICAgICAgXTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBzY2FsZU1hdHJpeChzeCwgc3kpIHtcclxuICAgICAgICBpZiAoc3kgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBzeSA9IHN4O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICBbc3gsIDAsIDBdLFxyXG4gICAgICAgICAgICBbMCwgc3ksIDBdLFxyXG4gICAgICAgICAgICBbMCwgMCwgMV1cclxuICAgICAgICBdO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBJdCB3aWxsIHJldHVybiB0aGUgZW5kIHBvaW50IG9mIGEgbGluZSBvbiBhIGdpdmVuIGFuZ2xlIChjbG9ja3dpc2UpLlxyXG4gICAgICogQHBhcmFtIHtQb2ludH0gc3RhcnRQb2ludCAtIHRoZSBzdGFydCBvZiB0aGUgbGluZVxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxlbmd0aCAtIHRoZSBsZW5ndGggb2YgdGhlIGxpbmVcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhbmdsZSAtIHRoZSBhbmdsZSBvZiB0aGUgbGluZSBpbiByYWRpYW5zXHJcbiAgICAgKiBAcmV0dXJuIHtQb2ludH0gLSB0aGUgZW5kUG9pbnQgb2YgdGhlIGxpbmVcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZ2V0RW5kUG9pbnQoc3RhcnRQb2ludCwgbGVuZ3RoLCBhbmdsZSkge1xyXG4gICAgICAgIHZhciBlbmRQb2ludCA9IHN0YXJ0UG9pbnQuY2xvbmUoKTtcclxuICAgICAgICBlbmRQb2ludC50cmFuc2Zvcm0odHJhbnNsYXRpb25NYXRyaXgoLXN0YXJ0UG9pbnQueCwgLXN0YXJ0UG9pbnQueSkpO1xyXG4gICAgICAgIGVuZFBvaW50LnkgLT0gbGVuZ3RoO1xyXG4gICAgICAgIGVuZFBvaW50LnRyYW5zZm9ybShyb3RhdGlvbk1hdHJpeChhbmdsZSkpO1xyXG4gICAgICAgIGVuZFBvaW50LnRyYW5zZm9ybSh0cmFuc2xhdGlvbk1hdHJpeChzdGFydFBvaW50LngsIHN0YXJ0UG9pbnQueSkpO1xyXG4gICAgICAgIHJldHVybiBlbmRQb2ludDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOiOt+WPluiOt+WPluS4pOS4quWbvuW9oueahOWklumdouWbm+S4qui/nuaOpeeCuVxyXG4gICAgICogQHBhcmFtICB7W3R5cGVdfSBub2RlIFtkZXNjcmlwdGlvbl1cclxuICAgICAqIEByZXR1cm4ge1t0eXBlXX0gICAgICBbZGVzY3JpcHRpb25dXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGdldENvbm5lY3RvclBvaW50cyhub2RlKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgbGVmdDogbmV3IFBvaW50KG5vZGUueCwgbm9kZS55ICsgbm9kZS5oZWlnaHQgLyAyKSwgLy/nn6nlvaIg5bem5Lit55qE5L2N572uXHJcbiAgICAgICAgICAgIHRvcDogbmV3IFBvaW50KG5vZGUueCArIG5vZGUud2lkdGggLyAyLCBub2RlLnkpLCAvL+efqeW9oiDkuIrkuK3nmoTkvY3nva5cclxuICAgICAgICAgICAgcmlnaHQ6IG5ldyBQb2ludChub2RlLnggKyBub2RlLndpZHRoLCBub2RlLnkgKyBub2RlLmhlaWdodCAvIDIpLCAvL+efqeW9oiDlj7PkuK3nmoTkvY3nva5cclxuICAgICAgICAgICAgYm90dG9tOiBuZXcgUG9pbnQobm9kZS54ICsgbm9kZS53aWR0aCAvIDIsIG5vZGUueSArIG5vZGUuaGVpZ2h0KSwgLy/nn6nlvaIg5LiL5Lit55qE5L2N572uXHJcbiAgICAgICAgICAgIGNlbnRlcjogbmV3IFBvaW50KG5vZGUueCArIG5vZGUud2lkdGggLyAyLCBub2RlLnkgKyBub2RlLmhlaWdodCAvIDIpIC8v5Lit6Ze05L2N572uXHJcblxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDojrflj5bojrflj5bkuKTkuKrlm77lvaLnmoTlpJbpnaLlm5vkuKrov57mjqXngrlcclxuICAgICAqIEBwYXJhbSAge1t0eXBlXX0gbm9kZSBbZGVzY3JpcHRpb25dXHJcbiAgICAgKiBAcmV0dXJuIHtbdHlwZV19ICAgICAgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBnZXRTb2x0UG9pbnRzKG5vZGUpIHtcclxuICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICAvL3RvcFxyXG4gICAgICAgICAgICBbTWF0aC5yb3VuZChub2RlLmdldFJlY3QoKS53aWR0aCAvIDMgLzEwKSoxMCwgMCBdLFxyXG4gICAgICAgICAgICBbTWF0aC5yb3VuZCgyKm5vZGUuZ2V0UmVjdCgpLndpZHRoIC8gMyAvMTApKjEwLCAwIF0sXHJcbiAgICAgICAgICAgIC8vcmlnaHRcclxuICAgICAgICAgICAgW25vZGUuZ2V0UmVjdCgpLndpZHRoLCBNYXRoLnJvdW5kKG5vZGUuZ2V0UmVjdCgpLmhlaWdodCAvIDMgLzEwKSoxMCBdLFxyXG4gICAgICAgICAgICBbbm9kZS5nZXRSZWN0KCkud2lkdGgsIE1hdGgucm91bmQoMipub2RlLmdldFJlY3QoKS5oZWlnaHQgLyAzIC8xMCkqMTAgXSxcclxuICAgICAgICAgICAgLy9ib3R0b21cclxuICAgICAgICAgICAgW01hdGgucm91bmQobm9kZS5nZXRSZWN0KCkud2lkdGggLyAzIC8xMCkqMTAsIG5vZGUuZ2V0UmVjdCgpLmhlaWdodCBdLFxyXG4gICAgICAgICAgICBbTWF0aC5yb3VuZCgyKm5vZGUuZ2V0UmVjdCgpLndpZHRoIC8gMyAvMTApKjEwLCBub2RlLmdldFJlY3QoKS5oZWlnaHQgXSxcclxuICAgICAgICAgICAgLy9sZWZ0XHJcbiAgICAgICAgICAgIFswLCBNYXRoLnJvdW5kKG5vZGUuZ2V0UmVjdCgpLmhlaWdodCAvIDMgLzEwKSoxMCBdLFxyXG4gICAgICAgICAgICBbMCwgTWF0aC5yb3VuZCgyKm5vZGUuZ2V0UmVjdCgpLmhlaWdodCAvIDMgLzEwKSoxMCBdXHJcblxyXG4gICAgICAgIF1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOiuoeeulyBwMSBwMuS4pOeCueaJgOi/nuaOpeeahOebtOe6v+eahOinkuW6plxyXG4gICAgICogQHBhcmFtICB7W3R5cGVdfSBwMSBbZGVzY3JpcHRpb25dXHJcbiAgICAgKiBAcGFyYW0gIHtbdHlwZV19IHAyIFtkZXNjcmlwdGlvbl1cclxuICAgICAqIEByZXR1cm4ge1t0eXBlXX0gICAgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiB0YW5nZW50Um90YXRpb24ocDEsIHAyKSB7XHJcbiAgICAgICAgcmV0dXJuIC1NYXRoLlBJIC8gMiAtIE1hdGguYXRhbjIoXHJcbiAgICAgICAgICAgIHAyLnkgLSBwMS55LCBwMi54IC0gcDEueFxyXG4gICAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDliKTmlq0z54K55piv5ZCm5Zyo5LiA5p2h55u057q/5LiKXHJcbiAgICAgKiBUZXN0cyBpZiAzIHBvaW50cyBhcmUgY29saW5pYXIgd2l0aCBtYXRyaXggZGV0ZXJtaW5hbnRzLlxyXG4gICAgICogSWYgdGhlIGRldGVybWluYXQgb2YgbWF0cml4XHJcbiAgICAgKiAvICAgICAgICAgXFxcclxuICAgICAqIHwgeDEgeTEgMSB8XHJcbiAgICAgKiB8IHgyIHkyIDEgfFxyXG4gICAgICogfCB4MyB5MyAxIHxcclxuICAgICAqIFxcICAgICAgICAgL1xyXG4gICAgICogaXMgemVybyBpdCBtZWFucyB0aGF0IHRoZSBwb2ludHMgYXJlIGNvbGluZWFyXHJcbiAgICAgKkBwYXJhbSB7UG9pbnR9IHAxIC0gZmlyc3QgcG9pbnRcclxuICAgICAqQHBhcmFtIHtQb2ludH0gcDIgLSBzZWNvbmQgcG9pbnRcclxuICAgICAqQHBhcmFtIHtQb2ludH0gcDMgLSB0aGlyZCBwb2ludFxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHByZWNpc3Npb25cclxuICAgICAqQHJldHVybiB7Qm9vbGVhbn0gLSB0cnVlIGlmIGNvbGluaWFyIGFuZCBmYWxzZSBpZiBub3RcclxuICAgICAqQGF1dGhvciBBbGV4XHJcbiAgICAgKkBzZWUgaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9EZXRlcm1pbmFudFxyXG4gICAgICpAc2VlIGh0dHBzOi8vcGVvcGxlLnJpY2hsYW5kLmVkdS9qYW1lcy9sZWN0dXJlL20xMTYvbWF0cmljZXMvYXBwbGljYXRpb25zLmh0bWxcclxuICAgICAqKi9cclxuICAgIGZ1bmN0aW9uIGNvbGxpbmVhcml0eShwMSwgcDIsIHAzLCBwcmVjaXNzaW9uKSB7XHJcbiAgICAgICAgdmFyIGRldGVybWluYW50ID0gKHAxLnggKiBwMi55ICsgcDEueSAqIHAzLnggKyBwMi54ICogcDMueSkgLSAocDIueSAqIHAzLnggKyBwMS55ICogcDIueCArIHAxLnggKiBwMy55KTtcclxuXHJcbiAgICAgICAgaWYgKHByZWNpc3Npb24pIHtcclxuICAgICAgICAgICAgcmV0dXJuIE1hdGguYWJzKGRldGVybWluYW50KSA8PSBwcmVjaXNzaW9uO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBkZXRlcm1pbmFudCA9PT0gMDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICog5Zub6IiN5LqU5YWlIOS/neWtmGRlY2ltYWxz55qE5bCP5pWwXHJcbiAgICAgKiovXHJcbiAgICBmdW5jdGlvbiBlbmhhbmNlZFJvdW5kKG51bWJlciwgZGVjaW1hbHMpIHtcclxuICAgICAgICByZXR1cm4gTWF0aC5yb3VuZChudW1iZXIgKiBNYXRoLnBvdygxMCwgZGVjaW1hbHMpKSAvIE1hdGgucG93KDEwLCBkZWNpbWFscyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDojrflj5bkuKTngrnkuYvpl7TnmoTplb/luqZcclxuICAgICAqKi9cclxuICAgIGZ1bmN0aW9uIGdldExlbmd0aChzdGFydFBvaW50LCBlbmRQb2ludCkge1xyXG4gICAgICAgIHJldHVybiBNYXRoLnNxcnQoTWF0aC5wb3coc3RhcnRQb2ludC54IC0gZW5kUG9pbnQueCwgMikgKyBNYXRoLnBvdyhzdGFydFBvaW50LnkgLSBlbmRQb2ludC55LCAyKSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDojrflj5bop5LluqZcclxuICAgICAqIEBwYXJhbSAge1t0eXBlXX0gY2VudGVyUG9pbnQgIFtkZXNjcmlwdGlvbl1cclxuICAgICAqIEBwYXJhbSAge1t0eXBlXX0gb3V0c2lkZVBvaW50IFtkZXNjcmlwdGlvbl1cclxuICAgICAqIEBwYXJhbSAge1t0eXBlXX0gcm91bmQgICAgICAgIFtkZXNjcmlwdGlvbl1cclxuICAgICAqIEByZXR1cm4ge1t0eXBlXX0gICAgICAgICAgICAgIFtkZXNjcmlwdGlvbl1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZ2V0QW5nbGUoY2VudGVyUG9pbnQsIG91dHNpZGVQb2ludCwgcm91bmQpIHtcclxuICAgICAgICBjZW50ZXJQb2ludC54ID0gZW5oYW5jZWRSb3VuZChjZW50ZXJQb2ludC54LCA1KTtcclxuICAgICAgICBjZW50ZXJQb2ludC55ID0gZW5oYW5jZWRSb3VuZChjZW50ZXJQb2ludC55LCA1KTtcclxuICAgICAgICBvdXRzaWRlUG9pbnQueCA9IGVuaGFuY2VkUm91bmQob3V0c2lkZVBvaW50LngsIDUpO1xyXG4gICAgICAgIG91dHNpZGVQb2ludC55ID0gZW5oYW5jZWRSb3VuZChvdXRzaWRlUG9pbnQueSwgNSk7XHJcbiAgICAgICAgdmFyIGFuZ2xlID0gTWF0aC5hdGFuKChvdXRzaWRlUG9pbnQueCAtIGNlbnRlclBvaW50LngpIC8gKG91dHNpZGVQb2ludC55IC0gY2VudGVyUG9pbnQueSkpO1xyXG4gICAgICAgIGFuZ2xlID0gLWFuZ2xlO1xyXG5cclxuICAgICAgICAvL2VuZEFuZ2xlKz05MDtcclxuICAgICAgICBpZiAob3V0c2lkZVBvaW50LnggPj0gY2VudGVyUG9pbnQueCAmJiBvdXRzaWRlUG9pbnQueSA+PSBjZW50ZXJQb2ludC55KSB7XHJcbiAgICAgICAgICAgIGFuZ2xlICs9IE1hdGguUEk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChvdXRzaWRlUG9pbnQueCA8PSBjZW50ZXJQb2ludC54ICYmIG91dHNpZGVQb2ludC55ID49IGNlbnRlclBvaW50LnkpIHtcclxuICAgICAgICAgICAgYW5nbGUgKz0gTWF0aC5QSTtcclxuICAgICAgICB9IGVsc2UgaWYgKG91dHNpZGVQb2ludC54IDw9IGNlbnRlclBvaW50LnggJiYgb3V0c2lkZVBvaW50LnkgPD0gY2VudGVyUG9pbnQueSkge1xyXG4gICAgICAgICAgICBhbmdsZSArPSBNYXRoLlBJICogMjtcclxuICAgICAgICB9XHJcbiAgICAgICAgd2hpbGUgKGFuZ2xlID49IE1hdGguUEkgKiAyKSB7XHJcbiAgICAgICAgICAgIGFuZ2xlIC09IE1hdGguUEkgKiAyO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaXNOYU4oYW5nbGUpKSB7IC8vTmFuXHJcbiAgICAgICAgICAgIGFuZ2xlID0gMDsgLy93ZSBhcmUgYXQgY2VudGVyIHBvaW50O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocm91bmQpIHtcclxuICAgICAgICAgICAgYW5nbGUgPSBNYXRoLnJvdW5kKGFuZ2xlIC8gcm91bmQpICogcm91bmRcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGFuZ2xlO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGdldFJlY3Qobm9kZSkge1xyXG4gICAgICAgIHZhciBib3VuZGluZ1JlY3QgPSBub2RlLmdldEJvdW5kaW5nUmVjdCgpO1xyXG4gICAgICAgIC8v5Yib5bu65pyA5bCP5YyF5Zu055uS6Jma57q/XHJcbiAgICAgICAgdmFyIHBvaW50cyA9IFtdO1xyXG4gICAgICAgIHBvaW50c1swXSA9IFstYm91bmRpbmdSZWN0LndpZHRoIC8gMiwgLWJvdW5kaW5nUmVjdC5oZWlnaHQgLyAyXTtcclxuICAgICAgICBwb2ludHNbMV0gPSBbYm91bmRpbmdSZWN0LndpZHRoIC8gMiwgLWJvdW5kaW5nUmVjdC5oZWlnaHQgLyAyXTtcclxuICAgICAgICBwb2ludHNbMl0gPSBbYm91bmRpbmdSZWN0LndpZHRoIC8gMiwgYm91bmRpbmdSZWN0LmhlaWdodCAvIDJdO1xyXG4gICAgICAgIHBvaW50c1szXSA9IFstYm91bmRpbmdSZWN0LndpZHRoIC8gMiwgYm91bmRpbmdSZWN0LmhlaWdodCAvIDJdO1xyXG4gICAgICAgIHBvaW50c1s0XSA9IFstYm91bmRpbmdSZWN0LndpZHRoIC8gMiwgLWJvdW5kaW5nUmVjdC5oZWlnaHQgLyAyXTtcclxuXHJcbiAgICAgICAgdmFyIGJvdW5kUmVjdCwgY3gsIGN5O1xyXG4gICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgZ3JhcGhpYy5DaXJjbGUpIHtcclxuICAgICAgICAgICAgLy/ms6g6IOWboOS6i+S7tuS4uuWchuW9oiAg5omA5LulIHggeSDkuLrlnIblv4PnmoTkvY3nva4gIOWMheWbtOefqeW9ouimgeWHj+WOu+WuveW6puS4gOWNilxyXG4gICAgICAgICAgICBib3VuZFJlY3QgPSBuZXcgQm91bmRpbmdSZWN0KE51bWJlcihub2RlLnBvc2l0aW9uWzBdKSAtIE51bWJlcihib3VuZGluZ1JlY3Qud2lkdGggLyAyKSxcclxuICAgICAgICAgICAgICAgIE51bWJlcihub2RlLnBvc2l0aW9uWzFdKSAtIE51bWJlcihib3VuZGluZ1JlY3QuaGVpZ2h0IC8gMiksXHJcbiAgICAgICAgICAgICAgICBOdW1iZXIoYm91bmRpbmdSZWN0LndpZHRoKSwgTnVtYmVyKGJvdW5kaW5nUmVjdC5oZWlnaHQpKTtcclxuICAgICAgICAgICAgY3ggPSBOdW1iZXIobm9kZS5wb3NpdGlvblswXSk7XHJcbiAgICAgICAgICAgIGN5ID0gTnVtYmVyKG5vZGUucG9zaXRpb25bMV0pO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGJvdW5kUmVjdCA9IG5ldyBCb3VuZGluZ1JlY3QoTnVtYmVyKG5vZGUucG9zaXRpb25bMF0pLFxyXG4gICAgICAgICAgICAgICAgTnVtYmVyKG5vZGUucG9zaXRpb25bMV0pLFxyXG4gICAgICAgICAgICAgICAgTnVtYmVyKGJvdW5kaW5nUmVjdC53aWR0aCksIE51bWJlcihib3VuZGluZ1JlY3QuaGVpZ2h0KSk7XHJcbiAgICAgICAgICAgIGN4ID0gTnVtYmVyKG5vZGUucG9zaXRpb25bMF0pICsgTnVtYmVyKGJvdW5kaW5nUmVjdC53aWR0aCkgLyAyO1xyXG4gICAgICAgICAgICBjeSA9IE51bWJlcihub2RlLnBvc2l0aW9uWzFdKSArIE51bWJlcihib3VuZGluZ1JlY3QuaGVpZ2h0KSAvIDI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHg6IE51bWJlcihjeCksXHJcbiAgICAgICAgICAgIHk6IE51bWJlcihjeSksXHJcbiAgICAgICAgICAgIHdpZHRoOiBOdW1iZXIoYm91bmRpbmdSZWN0LndpZHRoKSxcclxuICAgICAgICAgICAgaGVpZ2h0OiBOdW1iZXIoYm91bmRpbmdSZWN0LmhlaWdodCksXHJcbiAgICAgICAgICAgIHBvaW50czogcG9pbnRzLFxyXG4gICAgICAgICAgICBib3VuZGluZ1JlY3Q6IGJvdW5kUmVjdFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIFN0YWNrZWRNYXAgPSB7XHJcbiAgICAgICAgY3JlYXRlTmV3OiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdmFyIHN0YWNrID0gW107XHJcblxyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgYWRkOiBmdW5jdGlvbihrZXksIHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFycktleSA9IHRoaXMuZ2V0KGtleSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYXJyS2V5LnB1c2godmFsdWUpXHJcblxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oa2V5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdGFjay5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoa2V5ID09IHN0YWNrW2ldLmtleSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0YWNrW2ldLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIC8v5aaC5p6c5rKh5pyJ5om+5Yiw55qE6K+d77yM5YiZ5Yib5bu65LiA5Liq5paw55qE5pWw57uEXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhY2sucHVzaCh7IGtleToga2V5LCB2YWx1ZTogdmFsdWUgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGtleXM6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBrZXlzID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdGFjay5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXlzLnB1c2goc3RhY2tbaV0ua2V5KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGtleXM7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgdG9wOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV07XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbihrZXkpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaWR4ID0gLTE7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdGFjay5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoa2V5ID09IHN0YWNrW2ldLmtleSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWR4ID0gaTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdGFjay5zcGxpY2UoaWR4LCAxKVswXTtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICByZW1vdmVJdGVtOiBmdW5jdGlvbihrZXksIGl0ZW0pIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYXJyS2V5ID0gdGhpcy5nZXQoa2V5KTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSB6clV0aWwuaW5kZXhPZihhcnJLZXksIGl0ZW0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGFycktleS5zcGxpY2UoaW5kZXgsIDEpO1xyXG5cclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICByZW1vdmVUb3A6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdGFjay5zcGxpY2Uoc3RhY2subGVuZ3RoIC0gMSwgMSlbMF07XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgbGVuZ3RoOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RhY2subGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGNsZWFyOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgICBzdGFjay5zcGxpY2UoMCwgc3RhY2subGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIGZ1bmN0aW9uIHJhbmRvbUNvbG9yKCkge1xyXG4gICAgICAgIHZhciBhcnJIZXggPSBbXCIwXCIsIFwiMlwiLCBcIjNcIiwgXCI0XCIsIFwiNVwiLCBcIjZcIiwgXCI3XCIsIFwiOFwiLCBcIjlcIiwgXCJhXCIsIFwiYlwiLCBcImNcIiwgXCJkXCJdLFxyXG4gICAgICAgICAgICBzdHJIZXggPSBcIiNcIixcclxuICAgICAgICAgICAgaW5kZXg7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA2OyBpKyspIHtcclxuICAgICAgICAgICAgaW5kZXggPSBNYXRoLnJvdW5kKE1hdGgucmFuZG9tKCkgKiAxNSk7XHJcbiAgICAgICAgICAgIHN0ckhleCArPSBhcnJIZXhbaW5kZXhdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc3RySGV4O1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGlzVW5kZWZpbmVkKG9iaikge1xyXG4gICAgICAgIHJldHVybiBvYmogPT09IHZvaWQgMDtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBjb2xsaW5lYXJSZWR1Y3Rpb24gKHYpIHtcclxuICAgICAgICB2YXIgciA9IFtdO1xyXG5cclxuICAgICAgICBpZih2Lmxlbmd0aCA8IDMpe1xyXG4gICAgICAgICAgICByZXR1cm4gUG9pbnQuY2xvbmVBcnJheSh2KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHIucHVzaCggdlswXS5jbG9uZSgpICk7XHJcbiAgICAgICAgZm9yKHZhciBpPTE7IGkgPCB2Lmxlbmd0aC0xOyBpKyspe1xyXG4gICAgICAgICAgICBpZiggKHZbaS0xXS54ID09IHZbaV0ueCAmJiB2W2ldLnggPT0gdltpKzFdLngpICB8fCAgKHZbaS0xXS55ID09IHZbaV0ueSAmJiB2W2ldLnkgPT0gdltpKzFdLnkpIClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZXtcclxuICAgICAgICAgICAgICAgIHIucHVzaCggdltpXS5jbG9uZSgpICk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgci5wdXNoKCB2W3YubGVuZ3RoLTFdLmNsb25lKCkgKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHI7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQnkgZGVmYXVsdCwgVW5kZXJzY29yZSB1c2VzIEVSQi1zdHlsZSB0ZW1wbGF0ZSBkZWxpbWl0ZXJzLCBjaGFuZ2UgdGhlXHJcbiAgICAvLyBmb2xsb3dpbmcgdGVtcGxhdGUgc2V0dGluZ3MgdG8gdXNlIGFsdGVybmF0aXZlIGRlbGltaXRlcnMuXHJcbiAgICB2YXIgdGVtcGxhdGVTZXR0aW5ncyA9IHtcclxuICAgICAgICBldmFsdWF0ZTogLzwlKFtcXHNcXFNdKz8pJT4vZyxcclxuICAgICAgICBpbnRlcnBvbGF0ZTogLzwlPShbXFxzXFxTXSs/KSU+L2csXHJcbiAgICAgICAgZXNjYXBlOiAvPCUtKFtcXHNcXFNdKz8pJT4vZ1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyBXaGVuIGN1c3RvbWl6aW5nIGB0ZW1wbGF0ZVNldHRpbmdzYCwgaWYgeW91IGRvbid0IHdhbnQgdG8gZGVmaW5lIGFuXHJcbiAgICAvLyBpbnRlcnBvbGF0aW9uLCBldmFsdWF0aW9uIG9yIGVzY2FwaW5nIHJlZ2V4LCB3ZSBuZWVkIG9uZSB0aGF0IGlzXHJcbiAgICAvLyBndWFyYW50ZWVkIG5vdCB0byBtYXRjaC5cclxuICAgIHZhciBub01hdGNoID0gLyguKV4vO1xyXG5cclxuICAgIC8vIENlcnRhaW4gY2hhcmFjdGVycyBuZWVkIHRvIGJlIGVzY2FwZWQgc28gdGhhdCB0aGV5IGNhbiBiZSBwdXQgaW50byBhXHJcbiAgICAvLyBzdHJpbmcgbGl0ZXJhbC5cclxuICAgIHZhciBlc2NhcGVzID0ge1xyXG4gICAgICAgIFwiJ1wiOiBcIidcIixcclxuICAgICAgICAnXFxcXCc6ICdcXFxcJyxcclxuICAgICAgICAnXFxyJzogJ3InLFxyXG4gICAgICAgICdcXG4nOiAnbicsXHJcbiAgICAgICAgJ1xcdTIwMjgnOiAndTIwMjgnLFxyXG4gICAgICAgICdcXHUyMDI5JzogJ3UyMDI5J1xyXG4gICAgfTtcclxuXHJcbiAgICB2YXIgZXNjYXBlciA9IC9cXFxcfCd8XFxyfFxcbnxcXHUyMDI4fFxcdTIwMjkvZztcclxuXHJcbiAgICB2YXIgZXNjYXBlQ2hhciA9IGZ1bmN0aW9uKG1hdGNoKSB7XHJcbiAgICAgICAgcmV0dXJuICdcXFxcJyArIGVzY2FwZXNbbWF0Y2hdO1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyBKYXZhU2NyaXB0IG1pY3JvLXRlbXBsYXRpbmcsIHNpbWlsYXIgdG8gSm9obiBSZXNpZydzIGltcGxlbWVudGF0aW9uLlxyXG4gICAgLy8gVW5kZXJzY29yZSB0ZW1wbGF0aW5nIGhhbmRsZXMgYXJiaXRyYXJ5IGRlbGltaXRlcnMsIHByZXNlcnZlcyB3aGl0ZXNwYWNlLFxyXG4gICAgLy8gYW5kIGNvcnJlY3RseSBlc2NhcGVzIHF1b3RlcyB3aXRoaW4gaW50ZXJwb2xhdGVkIGNvZGUuXHJcbiAgICAvLyBOQjogYG9sZFNldHRpbmdzYCBvbmx5IGV4aXN0cyBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXHJcbiAgICBmdW5jdGlvbiB0ZW1wbGF0ZSh0ZXh0LCBzZXR0aW5ncywgb2xkU2V0dGluZ3MpIHtcclxuICAgICAgICBpZiAoIXNldHRpbmdzICYmIG9sZFNldHRpbmdzKSBzZXR0aW5ncyA9IG9sZFNldHRpbmdzO1xyXG4gICAgICAgIHNldHRpbmdzID0gc2V0dGluZ3MgfHwge307XHJcbiAgICAgICAgc2V0dGluZ3MgPSB6clV0aWwuZGVmYXVsdHMoc2V0dGluZ3MsIHRlbXBsYXRlU2V0dGluZ3MsIHRydWUpO1xyXG5cclxuICAgICAgICAvLyBDb21iaW5lIGRlbGltaXRlcnMgaW50byBvbmUgcmVndWxhciBleHByZXNzaW9uIHZpYSBhbHRlcm5hdGlvbi5cclxuICAgICAgICB2YXIgbWF0Y2hlciA9IFJlZ0V4cChbXHJcbiAgICAgICAgICAgIChzZXR0aW5ncy5lc2NhcGUgfHwgbm9NYXRjaCkuc291cmNlLFxyXG4gICAgICAgICAgICAoc2V0dGluZ3MuaW50ZXJwb2xhdGUgfHwgbm9NYXRjaCkuc291cmNlLFxyXG4gICAgICAgICAgICAoc2V0dGluZ3MuZXZhbHVhdGUgfHwgbm9NYXRjaCkuc291cmNlXHJcbiAgICAgICAgXS5qb2luKCd8JykgKyAnfCQnLCAnZycpO1xyXG5cclxuICAgICAgICAvLyBDb21waWxlIHRoZSB0ZW1wbGF0ZSBzb3VyY2UsIGVzY2FwaW5nIHN0cmluZyBsaXRlcmFscyBhcHByb3ByaWF0ZWx5LlxyXG4gICAgICAgIHZhciBpbmRleCA9IDA7XHJcbiAgICAgICAgdmFyIHNvdXJjZSA9IFwiX19wKz0nXCI7XHJcbiAgICAgICAgdGV4dC5yZXBsYWNlKG1hdGNoZXIsIGZ1bmN0aW9uKG1hdGNoLCBlc2NhcGUsIGludGVycG9sYXRlLCBldmFsdWF0ZSwgb2Zmc2V0KSB7XHJcbiAgICAgICAgICAgIHNvdXJjZSArPSB0ZXh0LnNsaWNlKGluZGV4LCBvZmZzZXQpLnJlcGxhY2UoZXNjYXBlciwgZXNjYXBlQ2hhcik7XHJcbiAgICAgICAgICAgIGluZGV4ID0gb2Zmc2V0ICsgbWF0Y2gubGVuZ3RoO1xyXG5cclxuICAgICAgICAgICAgaWYgKGVzY2FwZSkge1xyXG4gICAgICAgICAgICAgICAgc291cmNlICs9IFwiJytcXG4oKF9fdD0oXCIgKyBlc2NhcGUgKyBcIikpPT1udWxsPycnOl8uZXNjYXBlKF9fdCkpK1xcbidcIjtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChpbnRlcnBvbGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgc291cmNlICs9IFwiJytcXG4oKF9fdD0oXCIgKyBpbnRlcnBvbGF0ZSArIFwiKSk9PW51bGw/Jyc6X190KStcXG4nXCI7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZXZhbHVhdGUpIHtcclxuICAgICAgICAgICAgICAgIHNvdXJjZSArPSBcIic7XFxuXCIgKyBldmFsdWF0ZSArIFwiXFxuX19wKz0nXCI7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIEFkb2JlIFZNcyBuZWVkIHRoZSBtYXRjaCByZXR1cm5lZCB0byBwcm9kdWNlIHRoZSBjb3JyZWN0IG9mZmVzdC5cclxuICAgICAgICAgICAgcmV0dXJuIG1hdGNoO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHNvdXJjZSArPSBcIic7XFxuXCI7XHJcblxyXG4gICAgICAgIC8vIElmIGEgdmFyaWFibGUgaXMgbm90IHNwZWNpZmllZCwgcGxhY2UgZGF0YSB2YWx1ZXMgaW4gbG9jYWwgc2NvcGUuXHJcbiAgICAgICAgaWYgKCFzZXR0aW5ncy52YXJpYWJsZSkgc291cmNlID0gJ3dpdGgob2JqfHx7fSl7XFxuJyArIHNvdXJjZSArICd9XFxuJztcclxuXHJcbiAgICAgICAgc291cmNlID0gXCJ2YXIgX190LF9fcD0nJyxfX2o9QXJyYXkucHJvdG90eXBlLmpvaW4sXCIgK1xyXG4gICAgICAgICAgICBcInByaW50PWZ1bmN0aW9uKCl7X19wKz1fX2ouY2FsbChhcmd1bWVudHMsJycpO307XFxuXCIgK1xyXG4gICAgICAgICAgICBzb3VyY2UgKyAncmV0dXJuIF9fcDtcXG4nO1xyXG5cclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICB2YXIgcmVuZGVyID0gbmV3IEZ1bmN0aW9uKHNldHRpbmdzLnZhcmlhYmxlIHx8ICdvYmonLCBzb3VyY2UpO1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgZS5zb3VyY2UgPSBzb3VyY2U7XHJcbiAgICAgICAgICAgIHRocm93IGU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgdGVtcGxhdGUgPSBmdW5jdGlvbihkYXRhKSB7XHJcbiAgICAgICAgICAgIHJldHVybiByZW5kZXIuY2FsbCh0aGlzLCBkYXRhKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvLyBQcm92aWRlIHRoZSBjb21waWxlZCBzb3VyY2UgYXMgYSBjb252ZW5pZW5jZSBmb3IgcHJlY29tcGlsYXRpb24uXHJcbiAgICAgICAgdmFyIGFyZ3VtZW50ID0gc2V0dGluZ3MudmFyaWFibGUgfHwgJ29iaic7XHJcbiAgICAgICAgdGVtcGxhdGUuc291cmNlID0gJ2Z1bmN0aW9uKCcgKyBhcmd1bWVudCArICcpe1xcbicgKyBzb3VyY2UgKyAnfSc7XHJcblxyXG4gICAgICAgIHJldHVybiB0ZW1wbGF0ZTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBpc0VtcHR5KG9iaikge1xyXG4gICAgICAgIGlmIChvYmogPT0gbnVsbCkgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgaWYgKHpyVXRpbC5pc0FycmF5TGlrZShvYmopICYmICh6clV0aWwuaXNBcnJheShvYmopIHx8IHpyVXRpbC5pc1N0cmluZyhvYmopKSkgcmV0dXJuIG9iai5sZW5ndGggPT09IDA7XHJcbiAgICB9XHJcblxyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgICAgICAgaW5oZXJpdHM6IGluaGVyaXRzLFxyXG4gICAgICAgIGdldFVVSUQ6IGdldFVVSUQsXHJcbiAgICAgICAgZGlzdGFuY2U6IGRpc3RhbmNlLFxyXG4gICAgICAgIGdldFBvbHlsaW5lTGVuZ3RoOiBnZXRQb2x5bGluZUxlbmd0aCxcclxuICAgICAgICBtYXg6IG1heCxcclxuICAgICAgICBtaW46IG1pbixcclxuICAgICAgICBpc0VtcHR5OiBpc0VtcHR5LFxyXG4gICAgICAgIG9ydGhvZ29uYWxQYXRoOiBvcnRob2dvbmFsUGF0aCxcclxuICAgICAgICBwb2x5bGluZUludGVyc2VjdHNSZWN0YW5nbGU6IHBvbHlsaW5lSW50ZXJzZWN0c1JlY3RhbmdsZSxcclxuICAgICAgICBzY29yZVBhdGg6IHNjb3JlUGF0aCxcclxuICAgICAgICBmb3J3YXJkUGF0aDogZm9yd2FyZFBhdGgsXHJcbiAgICAgICAgdHJhc2xhdGVQb2ludHM6IHRyYXNsYXRlUG9pbnRzLFxyXG4gICAgICAgIGdldEVuZFBvaW50OiBnZXRFbmRQb2ludCxcclxuICAgICAgICBnZXRDb25uZWN0b3JQb2ludHM6IGdldENvbm5lY3RvclBvaW50cyxcclxuICAgICAgICB0YW5nZW50Um90YXRpb246IHRhbmdlbnRSb3RhdGlvbixcclxuICAgICAgICBjb2xsaW5lYXJpdHk6IGNvbGxpbmVhcml0eSxcclxuICAgICAgICB0cmFuc2xhdGlvbk1hdHJpeDogdHJhbnNsYXRpb25NYXRyaXgsXHJcbiAgICAgICAgc2NhbGVNYXRyaXg6IHNjYWxlTWF0cml4LFxyXG4gICAgICAgIHJvdW5kOiBlbmhhbmNlZFJvdW5kLFxyXG4gICAgICAgIGdldExlbmd0aDogZ2V0TGVuZ3RoLFxyXG4gICAgICAgIGdldEFuZ2xlOiBnZXRBbmdsZSxcclxuICAgICAgICBnZXRSZWN0OiBnZXRSZWN0LFxyXG4gICAgICAgIFN0YWNrZWRNYXA6IFN0YWNrZWRNYXAsXHJcbiAgICAgICAgZ2V0TWF4TGluZUxlbmd0aDogZ2V0TWF4TGluZUxlbmd0aCxcclxuICAgICAgICByYW5kb21Db2xvcjogcmFuZG9tQ29sb3IsXHJcbiAgICAgICAgdGVtcGxhdGU6IHRlbXBsYXRlLFxyXG4gICAgICAgIGlzVW5kZWZpbmVkOiBpc1VuZGVmaW5lZCxcclxuICAgICAgICBnZXRTb2x0UG9pbnRzOmdldFNvbHRQb2ludHMsXHJcbiAgICAgICAgY29sbGluZWFyUmVkdWN0aW9uOiBjb2xsaW5lYXJSZWR1Y3Rpb25cclxuICAgIH07XHJcblxyXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vbGliL2Zpc2gtdG9wby1jb3JlL2xpYi91dGlsLmpzXG4gKiogbW9kdWxlIGlkID0gNzNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlxyXG5cclxuICAgIC8qKlxyXG4gICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgYSBMaW5lLiBBIExpbmUgaXMgYWN0dWFsbHkgYSBzZWdtZW50IGFuZCBub3QgYSBwdXJlXHJcbiAgICAgICogZ2VvbWV0cmljYWwgTGluZVxyXG4gICAgICAqXHJcbiAgICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgICogQHRoaXMge0xpbmV9XHJcbiAgICAgICogQHBhcmFtIHtQb2ludH0gc3RhcnRQb2ludCAtIHN0YXJ0aW5nIHBvaW50IG9mIHRoZSBsaW5lXHJcbiAgICAgICogQHBhcmFtIHtQb2ludH0gZW5kUG9pbnQgLSB0aGUgZW5kaW5nIHBvaW50IG9mIHRoZSBsaW5lXHJcbiAgICAgICoqL1xyXG4gICAgZnVuY3Rpb24gTGluZShzdGFydFBvaW50LCBlbmRQb2ludCl7XHJcbiAgICAgICAgLyoqU3RhcnRpbmcge0BsaW5rIFBvaW50fSBvZiB0aGUgbGluZSovXHJcbiAgICAgICAgdGhpcy5zdGFydFBvaW50ID0gc3RhcnRQb2ludDtcclxuXHJcbiAgICAgICAgLyoqRW5kaW5nIHtAbGluayBQb2ludH0gb2YgdGhlIGxpbmUqL1xyXG4gICAgICAgIHRoaXMuZW5kUG9pbnQgPSBlbmRQb2ludDtcclxuXHJcbiAgICAgICAgLyoqU2VyaWFsaXphdGlvbiB0eXBlKi9cclxuICAgICAgICB0aGlzLm9UeXBlID0gJ0xpbmUnOyAvL29iamVjdCB0eXBlIHVzZWQgZm9yIEpTT04gZGVzZXJpYWxpemF0aW9uXHJcbiAgICB9XHJcblxyXG4gICAgLyoqQ3JlYXRlcyBhIHtMaW5lfSBvdXQgb2YgSlNPTiBwYXJzZWQgb2JqZWN0XHJcbiAgICAgKkBwYXJhbSB7SlNPTk9iamVjdH0gbyAtIHRoZSBKU09OIHBhcnNlZCBvYmplY3RcclxuICAgICAqQHJldHVybiB7TGluZX0gYSBuZXdseSBjb25zdHJ1Y3RlZCBMaW5lXHJcbiAgICAgKiovXHJcbiAgICBMaW5lLmxvYWQgPSBmdW5jdGlvbihvKXtcclxuICAgICAgICB2YXIgbmV3TGluZSA9IG5ldyBMaW5lKFxyXG4gICAgICAgICAgICBQb2ludC5sb2FkKG8uc3RhcnRQb2ludCksXHJcbiAgICAgICAgICAgIFBvaW50LmxvYWQoby5lbmRQb2ludClcclxuICAgICAgICApO1xyXG5cclxuICAgICAgICByZXR1cm4gbmV3TGluZTtcclxuICAgIH07XHJcblxyXG4gICAgTGluZS5wcm90b3R5cGUgPSB7XHJcbiAgICAgICAgY29udHJ1Y3RvcjogTGluZSxcclxuXHJcblxyXG5cclxuICAgICAgICBjbG9uZTpmdW5jdGlvbigpe1xyXG4gICAgICAgICAgICB2YXIgcmV0ID0gbmV3IExpbmUodGhpcy5zdGFydFBvaW50LmNsb25lKCksIHRoaXMuZW5kUG9pbnQuY2xvbmUoKSk7XHJcbiAgICAgICAgICAgIHJldHVybiByZXQ7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgZXF1YWxzOmZ1bmN0aW9uKGFub3RoZXJMaW5lKXtcclxuICAgICAgICAgICAgaWYoIWFub3RoZXJMaW5lIGluc3RhbmNlb2YgTGluZSl7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RhcnRQb2ludC5lcXVhbHMoYW5vdGhlckxpbmUuc3RhcnRQb2ludClcclxuICAgICAgICAgICAgJiYgdGhpcy5lbmRQb2ludC5lcXVhbHMoYW5vdGhlckxpbmUuZW5kUG9pbnQpXHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqIFRlc3RzIHRvIHNlZSBpZiBhIHBvaW50IGJlbG9uZ3MgdG8gdGhpcyBsaW5lIChub3QgYXMgaW5maW5pdGUgbGluZSBidXQgbW9yZSBsaWtlIGEgc2VnbWVudClcclxuICAgICAgICAgKiBBbGdvcml0aG06IENvbXB1dGUgbGluZSdzIGVxdWF0aW9uIGFuZCBzZWUgaWYgKHgsIHkpIHZlcmlmaWVzIGl0LlxyXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4IC0gdGhlIFggY29vcmRpbmF0ZXNcclxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0geSAtIHRoZSBZIGNvb3JkaW5hdGVzXHJcbiAgICAgICAgICoqL1xyXG4gICAgICAgIGNvbnRhaW5zOiBmdW5jdGlvbih4LCB5KXtcclxuICAgICAgICAgICAgLy8gaWYgdGhlIHBvaW50IGlzIGluc2lkZSByZWN0YW5nbGUgYm91bmRzIG9mIHRoZSBzZWdtZW50XHJcbiAgICAgICAgICAgIGlmIChNYXRoLm1pbih0aGlzLnN0YXJ0UG9pbnQueCwgdGhpcy5lbmRQb2ludC54KSA8PSB4XHJcbiAgICAgICAgICAgICAgICAmJiB4IDw9IE1hdGgubWF4KHRoaXMuc3RhcnRQb2ludC54LCB0aGlzLmVuZFBvaW50LngpXHJcbiAgICAgICAgICAgICAgICAmJiBNYXRoLm1pbih0aGlzLnN0YXJ0UG9pbnQueSwgdGhpcy5lbmRQb2ludC55KSA8PSB5XHJcbiAgICAgICAgICAgICAgICAmJiB5IDw9IE1hdGgubWF4KHRoaXMuc3RhcnRQb2ludC55LCB0aGlzLmVuZFBvaW50LnkpKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgZm9yIHZlcnRpY2FsIGxpbmVcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnN0YXJ0UG9pbnQueCA9PSB0aGlzLmVuZFBvaW50LngpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4geCA9PSB0aGlzLnN0YXJ0UG9pbnQueDtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7IC8vIHVzdWFsIChub3QgdmVydGljYWwpIGxpbmUgY2FuIGJlIHJlcHJlc2VudGVkIGFzIHkgPSBhICogeCArIGJcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYSA9ICh0aGlzLmVuZFBvaW50LnkgLSB0aGlzLnN0YXJ0UG9pbnQueSkgLyAodGhpcy5lbmRQb2ludC54IC0gdGhpcy5zdGFydFBvaW50LngpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBiID0gdGhpcy5zdGFydFBvaW50LnkgLSBhICogdGhpcy5zdGFydFBvaW50Lng7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHkgPT0gYSAqIHggKyBiO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLypcclxuICAgICAgICAgKlNlZSBpZiB3ZSBhcmUgbmVhciBhIHtMaW5lfSBieSBhIGNlcnRhaW4gcmFkaXVzIChhbHNvIGluY2x1ZGVzIHRoZSBleHRyZW1pdGllcyBpbnRvIGNvbXB1dGF0aW9uKVxyXG4gICAgICAgICAqQHBhcmFtIHtOdW1iZXJ9IHggLSB0aGUgeCBjb29yZGluYXRlc1xyXG4gICAgICAgICAqQHBhcmFtIHtOdW1iZXJ9IHkgLSB0aGUgeSBjb29yZGluYXRlc1xyXG4gICAgICAgICAqQHBhcmFtIHtOdW1iZXJ9IHJhZGl1cyAtIHRoZSByYWRpdXMgdG8gc2VhcmNoIGZvclxyXG4gICAgICAgICAqQHNlZSBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Rpc3RhbmNlX2Zyb21fYV9wb2ludF90b19hX2xpbmVcclxuICAgICAgICAgKkBzZWUgXCJNYXRoZW1hdGljcyBmb3IgQ29tcHV0ZXIgR3JhcGhpY3MsIDJuZCBFZC4sIGJ5IEpvaG4gVmljZSwgcGFnZSAyMjdcIlxyXG4gICAgICAgICAqKi9cclxuICAgICAgICBuZWFyOmZ1bmN0aW9uKHgseSxyYWRpdXMpe1xyXG5cclxuICAgICAgICAgICAgaWYodGhpcy5lbmRQb2ludC54ID09PSB0aGlzLnN0YXJ0UG9pbnQueCl7IC8vVmVydGljYWwgbGluZSwgc28gdGhlIHZpY2luaXR5IGFyZWEgaXMgYSByZWN0YW5nbGVcclxuICAgICAgICAgICAgICAgIHJldHVybiAoICh0aGlzLnN0YXJ0UG9pbnQueS1yYWRpdXM8PXkgJiYgdGhpcy5lbmRQb2ludC55K3JhZGl1cz49eSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgfHwgKHRoaXMuZW5kUG9pbnQueS1yYWRpdXM8PXkgJiYgdGhpcy5zdGFydFBvaW50LnkrcmFkaXVzPj15KSlcclxuICAgICAgICAgICAgICAgICYmIHggPiB0aGlzLnN0YXJ0UG9pbnQueCAtIHJhZGl1cyAmJiB4IDwgdGhpcy5zdGFydFBvaW50LnggKyByYWRpdXMgO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZih0aGlzLnN0YXJ0UG9pbnQueSA9PT0gdGhpcy5lbmRQb2ludC55KXsgLy9Ib3Jpem9udGFsIGxpbmUsIHNvIHRoZSB2aWNpbml0eSBhcmVhIGlzIGEgcmVjdGFuZ2xlXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKCAodGhpcy5zdGFydFBvaW50LnggLSByYWRpdXM8PXggJiYgdGhpcy5lbmRQb2ludC54K3JhZGl1cz49eClcclxuICAgICAgICAgICAgICAgICAgICAgICAgfHwgKHRoaXMuZW5kUG9pbnQueC1yYWRpdXM8PXggJiYgdGhpcy5zdGFydFBvaW50LngrcmFkaXVzPj14KSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgJiYgeT50aGlzLnN0YXJ0UG9pbnQueS1yYWRpdXMgJiYgeTx0aGlzLnN0YXJ0UG9pbnQueStyYWRpdXMgO1xyXG4gICAgICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAgICAgdmFyIHN0YXJ0WCA9IE1hdGgubWluKHRoaXMuZW5kUG9pbnQueCx0aGlzLnN0YXJ0UG9pbnQueCk7XHJcbiAgICAgICAgICAgIHZhciBzdGFydFkgPSBNYXRoLm1pbih0aGlzLmVuZFBvaW50LnksdGhpcy5zdGFydFBvaW50LnkpO1xyXG4gICAgICAgICAgICB2YXIgZW5kWCA9IE1hdGgubWF4KHRoaXMuZW5kUG9pbnQueCx0aGlzLnN0YXJ0UG9pbnQueCk7XHJcbiAgICAgICAgICAgIHZhciBlbmRZID0gTWF0aC5tYXgodGhpcy5lbmRQb2ludC55LHRoaXMuc3RhcnRQb2ludC55KTtcclxuXHJcbiAgICAgICAgICAgIC8qV2Ugd2lsbCBjb21wdXRlIHRoZSBkaXN0YW5jZSBmcm9tIHBvaW50IHRvIHRoZSBsaW5lXHJcbiAgICAgICAgICAgICAqIGJ5IHVzaW5nIHRoZSBhbGdvcml0aG0gZnJvbVxyXG4gICAgICAgICAgICAgKiBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Rpc3RhbmNlX2Zyb21fYV9wb2ludF90b19hX2xpbmVcclxuICAgICAgICAgICAgICogKi9cclxuXHJcbiAgICAgICAgICAgIC8vRmlyc3Qgd2UgbmVlZCB0byBmaW5kIGEsYixjIG9mIHRoZSBsaW5lIGVxdWF0aW9uIGF4ICsgYnkgKyBjID0gMFxyXG4gICAgICAgICAgICB2YXIgYSA9IHRoaXMuZW5kUG9pbnQueSAtIHRoaXMuc3RhcnRQb2ludC55O1xyXG4gICAgICAgICAgICB2YXIgYiA9IHRoaXMuc3RhcnRQb2ludC54IC0gdGhpcy5lbmRQb2ludC54O1xyXG4gICAgICAgICAgICB2YXIgYyA9IC0odGhpcy5zdGFydFBvaW50LnggKiB0aGlzLmVuZFBvaW50LnkgLSB0aGlzLmVuZFBvaW50LnggKiB0aGlzLnN0YXJ0UG9pbnQueSk7XHJcblxyXG4gICAgICAgICAgICAvL1NlY29uZGx5IHdlIGdldCB0aGUgZGlzdGFuY2UgXCJNYXRoZW1hdGljcyBmb3IgQ29tcHV0ZXIgR3JhcGhpY3MsIDJuZCBFZC4sIGJ5IEpvaG4gVmljZSwgcGFnZSAyMjdcIlxyXG4gICAgICAgICAgICB2YXIgZCA9IE1hdGguYWJzKCAoYSp4ICsgYip5ICsgYykgLyBNYXRoLnNxcnQoTWF0aC5wb3coYSwyKSArIE1hdGgucG93KGIsMikpICk7XHJcblxyXG4gICAgICAgICAgICAvL1RoaXJkbHkgd2UgZ2V0IGNvb3JkaW5hdGVzIG9mIGNsb3Nlc3QgbGluZSdzIHBvaW50IHRvIHRhcmdldCBwb2ludFxyXG4gICAgICAgICAgICAvL2h0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRGlzdGFuY2VfZnJvbV9hX3BvaW50X3RvX2FfbGluZSNDYXJ0ZXNpYW5fY29vcmRpbmF0ZXNcclxuICAgICAgICAgICAgdmFyIGNsb3Nlc3RYID0gKGIgKiAoYip4IC0gYSp5KSAtIGEqYykgLyAoIE1hdGgucG93KGEsMikgKyBNYXRoLnBvdyhiLDIpICk7XHJcbiAgICAgICAgICAgIHZhciBjbG9zZXN0WSA9IChhICogKC1iKnggKyBhKnkpIC0gYipjKSAvICggTWF0aC5wb3coYSwyKSArIE1hdGgucG93KGIsMikgKTtcclxuXHJcbiAgICAgICAgICAgIHZhciByID0gKCBkIDw9IHJhZGl1cyAmJiBlbmRYPj1jbG9zZXN0WCAmJiBjbG9zZXN0WD49c3RhcnRYICYmIGVuZFk+PWNsb3Nlc3RZICYmIGNsb3Nlc3RZPj1zdGFydFkgKSAvL3RoZSBwcm9qZWN0aW9uIG9mIHRoZSBwb2ludCBmYWxscyBJTlNJREUgb2YgdGhlIHNlZ21lbnRcclxuICAgICAgICAgICAgICAgIHx8IHRoaXMuc3RhcnRQb2ludC5uZWFyKHgseSxyYWRpdXMpIHx8IHRoaXMuZW5kUG9pbnQubmVhcih4LHkscmFkaXVzKTsgLy90aGUgcHJvamVjdGlvbiBvZiB0aGUgcG9pbnQgZmFsbHMgT1VUU0lERSBvZiB0aGUgc2VnbWVudFxyXG5cclxuICAgICAgICAgICAgcmV0dXJuICByO1xyXG5cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKip3ZSBuZWVkIHRvIGNyZWF0ZSBhIG5ldyBhcnJheSBlYWNoIHRpbWUsIG9yIHdlIHdpbGwgYWZmZWN0IHRoZSBhY3R1YWwgc2hhcGUqL1xyXG4gICAgICAgIGdldFBvaW50czpmdW5jdGlvbigpe1xyXG4gICAgICAgICAgICB2YXIgcG9pbnRzID0gW107XHJcbiAgICAgICAgICAgIHBvaW50cy5wdXNoKHRoaXMuc3RhcnRQb2ludCk7XHJcbiAgICAgICAgICAgIHBvaW50cy5wdXNoKHRoaXMuZW5kUG9pbnQpO1xyXG4gICAgICAgICAgICByZXR1cm4gcG9pbnRzO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlJldHVybiB0aGUge1BvaW50fSBjb3JyZXNwb25kaW5nIHRoZSB0IGNlcnRhaW4gdCB2YWx1ZVxyXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSB0IHRoZSB2YWx1ZSBvZiBwYXJhbWV0ZXIgdCwgd2hlcmUgdCBpbiBbMCwxXSwgdCBpcyBsaWtlIGEgcGVyY2VudCovXHJcbiAgICAgICAgZ2V0UG9pbnQ6IGZ1bmN0aW9uKHQpe1xyXG4gICAgICAgICAgICB2YXIgWHAgPSB0ICogKHRoaXMuZW5kUG9pbnQueCAtIHRoaXMuc3RhcnRQb2ludC54KSArIHRoaXMuc3RhcnRQb2ludC54O1xyXG4gICAgICAgICAgICB2YXIgWXAgPSB0ICogKHRoaXMuZW5kUG9pbnQueSAtIHRoaXMuc3RhcnRQb2ludC55KSArIHRoaXMuc3RhcnRQb2ludC55O1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludChYcCwgWXApO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8vIC8qKlxyXG4gICAgICAgIC8vICAqIFJldHVybnMgdGhlIG1pZGRsZSBvZiB0aGUgbGluZVxyXG4gICAgICAgIC8vICAqIEByZXR1cm4ge1BvaW50fSB0aGUgbWlkZGxlIHBvaW50XHJcbiAgICAgICAgLy8gICogKi9cclxuICAgICAgICAvLyBnZXRNaWRkbGUgOiBmdW5jdGlvbigpe1xyXG4gICAgICAgIC8vICAgICByZXR1cm4gVXRpbC5nZXRNaWRkbGUodGhpcy5zdGFydFBvaW50LCB0aGlzLmVuZFBvaW50KTtcclxuICAgICAgICAvLyB9LFxyXG5cclxuXHJcbiAgICAgICAgLy8gZ2V0TGVuZ3RoIDogZnVuY3Rpb24oKXtcclxuICAgICAgICAvLyAgICAgcmV0dXJuIFV0aWwuZ2V0TGVuZ3RoKHRoaXMuc3RhcnRQb2ludCwgdGhpcy5lbmRQb2ludCk7XHJcbiAgICAgICAgLy8gfSxcclxuXHJcbiAgICAgICAgLy8gLyoqXHJcbiAgICAgICAgLy8gICpHZXQgYm91bmRzIGZvciB0aGlzIGxpbmVcclxuICAgICAgICAvLyAgKkBhdXRob3IgQWxleCBHaGVvcmdoaXUgPGFsZXhAc2NyaXB0b2lkLmNvbT5cclxuICAgICAgICAvLyAgKiovXHJcbiAgICAgICAgLy8gZ2V0Qm91bmRzOmZ1bmN0aW9uKCl7XHJcbiAgICAgICAgLy8gICAgIHJldHVybiBVdGlsLmdldEJvdW5kcyh0aGlzLmdldFBvaW50cygpKTtcclxuICAgICAgICAvLyB9LFxyXG5cclxuICAgICAgICAvKipTdHJpbmcgcmVwcmVzZW50YXRpb24qL1xyXG4gICAgICAgIHRvU3RyaW5nOmZ1bmN0aW9uKCl7XHJcbiAgICAgICAgICAgIHJldHVybiAnbGluZSgnICsgdGhpcy5zdGFydFBvaW50ICsgJywnICsgdGhpcy5lbmRQb2ludCArICcpJztcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBMaW5lO1xyXG5cclxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2xpYi9maXNoLXRvcG8tY29yZS9saWIvTGluZVN0cnVjdC5qc1xuICoqIG1vZHVsZSBpZCA9IDc0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcclxuICogQlBNTuiKgueCueexuyAg5omA5pyJ55qEQlBNTuW9oueKtumDvee7p+aJv+S4juWug++8jOeUqOaIt+iHquWumuS5ieiKgueCueWPr+S7pee7p+aJv+Wug+W5tuazqOWGjOWNs+WPr+S9v+eUqFxyXG4gKiBAY2xhc3MgZmlzaC50b3BvLkZpc2hUb3BvQnBtbi5CUE1OTm9kZVxyXG4gKi9cclxuXHJcblxyXG5cdHZhciBOb2RlID0gcmVxdWlyZShcIi4uLy4uLy4uL2Zpc2gtdG9wby1jb3JlL2xpYi9Ob2RlXCIpO1xyXG5cdHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcclxuXHR2YXIgZ3JhcGhpYyA9IHJlcXVpcmUoXCIuLi8uLi8uLi9maXNoLXRvcG8tY29yZS9saWIvZ3JhcGhpYy5qc1wiKTtcclxuXHR2YXIgY2xhenpVdGlsID0gcmVxdWlyZSgnLi4vLi4vLi4vZmlzaC10b3BvLWNvcmUvbGliL2NsYXp6Jyk7XHJcblx0Ly/liJvlu7pOb2Rl57G7IOaJgOacieW9oueKtumDvee7p+aJv05vZGVcclxuXHRmdW5jdGlvbiBCUE1OTm9kZShtb2RlbCwgYXBpKSB7XHJcblx0XHROb2RlLmNhbGwodGhpcyk7XHJcblx0XHR0aGlzLm1vZGVsID0gbW9kZWw7XHJcblx0XHR0aGlzLm9wdGlvbnMgPVxyXG5cdFx0e1xyXG5cdFx0XHRvdXRsaW5lOiB7XHJcblx0XHRcdFx0ZW5hYmxlOiB0cnVlLCAvLyDmmK/lkKbmnInlpJbmoYZcclxuXHRcdFx0XHRyYWRpdXM6IHRydWUsIC8vIOaYr+WQpuWchuinklxyXG5cdFx0XHRcdGluaXRWaXNpYmxlOiBmYWxzZVxyXG5cdFx0XHR9LFxyXG5cdFx0XHR0ZXh0OiB7XHJcblx0XHRcdFx0Y29sb3I6ICcjMDAwMDAwJywgLy8g5paH5pys6aKc6ImyXHJcblx0XHRcdFx0bGluZUhlaWdodDogMjQgLy8g5paH5pys6KGM6auYXHJcblx0XHRcdH1cclxuXHRcdH07XHJcblx0XHR0aGlzLmJwbW5JbmZvID0ge3R5cGU6IC0xLCBuYW1lOlwiQlBNTkRpYWdyYW1cIiwgZGlzcGxheU5hbWU6XCJUYXNrXCIgfTsgICAgLy/oioLngrnkv6Hmga9cclxuXHRcdHZhciByZXNvdXJjZUlkID0gbW9kZWwuZ2V0KFwicmVzb3VyY2VJZFwiKTtcclxuXHRcdGlmKHJlc291cmNlSWQgJiYgcmVzb3VyY2VJZCAhPSBcIlwiKSB7XHJcblx0XHRcdHRoaXMucmVzb3VyY2VJZCA9IHJlc291cmNlSWQ7XHJcblx0XHR9XHJcblxyXG4gICAgICAgIC8v5Yik5pat5piv5ZCm5pyJb3BlcmF0aW9uTm9kZVxyXG4gICAgICAgIHZhciBwcm9wID0gbW9kZWwuZ2V0KFwicHJvcGVydGllc1wiKTtcclxuICAgICAgICBpZiAocHJvcC5vcGVyYXRpb25JY29ucykge1xyXG4gICAgICAgICAgICB0aGlzLm9wZXJhdGlvbkljb25zID0gcHJvcC5vcGVyYXRpb25JY29ucztcclxuICAgICAgICB9XHJcblx0XHR0aGlzLmluaXRFdmVudChhcGkpO1xyXG5cdH1cclxuXHJcbiAgICBCUE1OTm9kZS5wcm90b3R5cGUuaW5pdEV2ZW50ID0gZnVuY3Rpb24oYXBpKSB7XHJcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgICAgIHZhciBNT1VTRV9FVkVOVF9OQU1FUyA9IFsnZGJsY2xpY2snLCAnY2xpY2snXTsvLydjbGljaycsICdkYmxjbGljaycsICdtb3VzZW92ZXInLCAnbW91c2VvdXQnXHJcblxyXG5cclxuICAgICAgICB6clV0aWwuZWFjaChNT1VTRV9FVkVOVF9OQU1FUywgZnVuY3Rpb24gKGV2ZU5hbWUpIHtcclxuICAgICAgICAgICAgdGhhdC5vbihldmVOYW1lLCBmdW5jdGlvbiAoZSkge1xyXG5cdCAgICAgICAgICAgIHZhciBwYXJhbXMgPSB7fTtcclxuXHQgICAgICAgICAgICBwYXJhbXMuZXZlbnQgPSBlO1xyXG5cdCAgICAgICAgICAgIHBhcmFtcy50eXBlID0gZXZlTmFtZTtcclxuXHQgICAgICAgICAgICBwYXJhbXMudGFyZ2V0ID0gdGhhdDtcclxuXHQgICAgICAgICAgICBhcGkudHJpZ2dlcihldmVOYW1lLCBwYXJhbXMpO1xyXG4gICAgICAgICAgICB9LCB0aGlzKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDojrflj5blvZPliY3oioLngrnnmoTljIXlm7Tlkowg55u45YWz5Y+C5pWwXHJcbiAgICAgKiBAcmV0dXJucyB7e3g6TnVtYmVyLCB5Ok51bWJlciwgd2lkdGg6TnVtYmVyLCBoZWlnaHQ6TnVtYmVyLCBwb2ludHM6QXJyYXksIGJvdW5kaW5nUmVjdDpPYmplY3R9fVxyXG4gICAgICogQHJldHVybnMge051bWJlcn0gcmV0dXJuLngg5b2T5YmN6IqC54K555qE5Lit5b+D54K5eOWAvFxyXG4gICAgICogQHJldHVybnMge051bWJlcn0gcmV0dXJuLnkg5b2T5YmN6IqC54K555qE5Lit5b+D54K5eeWAvFxyXG4gICAgICogQHJldHVybnMge051bWJlcn0gcmV0dXJuLndpZHRoIOW9k+WJjeiKgueCueeahOWuveW6plxyXG4gICAgICogQHJldHVybnMge051bWJlcn0gcmV0dXJuLmhlaWdodCDlvZPliY3oioLngrnnmoTpq5jluqZcclxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gcmV0dXJuLnBvaW50cyDlvZPliY3oioLngrnnmoTljIXlm7TlkowgW+W3puS4iuinkuWdkOagh++8jOWPs+S4iuinkuWdkOagh++8jOWPs+S4i+inkuWdkOagh++8jOWPs+S4i+inkuWdkOagh10g55So5LqO6IqC54K56YCJ5Lit5pe25YyF5Zu06Jma57q/5qGGXHJcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSByZXR1cm4uYm91bmRpbmdSZWN0IOW9k+WJjeiKgueCueeahOWMheWbtOefqeW9olxyXG4gICAgICovXHJcbiAgICBCUE1OTm9kZS5wcm90b3R5cGUuZ2V0UmVjdCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIOi/lOWbnuW9k+WJjeiKgueCueeahOWMheWbtOefqeW9olxyXG4gICAgICogQHJldHVybiB7T2JqZWN0fSDlvZPliY3oioLngrnnmoTljIXlm7Tnn6nlvaIgIOS4gOiIrOS4jeWMheaLrOS4i+mdoueahOaWh+Wtl1xyXG4gICAgICovXHJcbiAgICBCUE1OTm9kZS5wcm90b3R5cGUuZ2V0Qm91bmRpbmdSZWN0ID0gZnVuY3Rpb24oKSB7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICog6K6+572u5Zu+5YWD55qE5L2N572uXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geCB45Z2Q5qCHXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geSB55Z2Q5qCHXHJcbiAgICAgKi9cclxuICAgIEJQTU5Ob2RlLnByb3RvdHlwZS5zZXRQb3NpdGlvbiAgPSBmdW5jdGlvbih4LCB5KSB7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIOafpeeci+W9k+WJjeiKgueCueaYr+WQpiDljIXmi6x4ICx5IOWdkOagh1xyXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSB4IHjlnZDmoIdcclxuICAgICAqIEBwYXJhbSAge251bWJlcn0geSB55Z2Q5qCHXHJcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSAgIOaYr+WQpuWcqOiMg+WbtOWGhVxyXG4gICAgICovXHJcbiAgICBCUE1OTm9kZS5wcm90b3R5cGUucmVjdENvbnRhaW4gPSBmdW5jdGlvbih4LCB5KSB7XHJcbiAgICBcdHZhciByZWN0ID0gdGhpcy5nZXRSZWN0KCk7XHJcbiAgICAgICAgcmV0dXJuIHJlY3QuYm91bmRpbmdSZWN0LmNvbnRhaW4oeCx5KTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDov5Tlm55qc29u5a+56LGhXHJcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IGpzb27lr7nosaFcclxuICAgICAqL1xyXG5cdEJQTU5Ob2RlLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbigpIHtcclxuXHRcdHRoaXMubW9kZWwuc2V0KFwicmVzb3VyY2VJZFwiLCB0aGlzLnJlc291cmNlSWQpO1xyXG5cdFx0dGhpcy5tb2RlbC5zZXQoXCJwcm9wZXJ0aWVzLnR5cGVcIiwgdGhpcy5icG1uSW5mby50eXBlKTtcclxuXHRcdHRoaXMubW9kZWwuc2V0KFwic3RlbmNpbC50eXBlXCIsIHRoaXMuYnBtbkluZm8ubmFtZSk7ICAvL3N0ZW5jaWwuaWRcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuc2xvdEV2ZW50ICYmIHRoaXMuc2xvdEV2ZW50Lmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgdmFyIGFyclNsb3RFdmVudCA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gdGhpcy5zbG90RXZlbnQubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgICAgICAgICAgIGFyclNsb3RFdmVudC5wdXNoKHRoaXMuc2xvdEV2ZW50W2ldLnJlc291cmNlSWQpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5tb2RlbC5zZXQoXCJwcm9wZXJ0aWVzLnNsb3RFdmVudFwiLCBhcnJTbG90RXZlbnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLm1vZGVsLnNldChcInByb3BlcnRpZXMudHlwZVwiLCB0aGlzLmJwbW5JbmZvLnR5cGUpO1xyXG5cclxuICAgICAgICB2YXIgcmVjdCA9IHRoaXMuZ2V0UmVjdCgpLmJvdW5kaW5nUmVjdDtcclxuICAgICAgICB0aGlzLm1vZGVsLnNldChcImJvdW5kcy51cHBlckxlZnQueFwiLCByZWN0LngpO1xyXG4gICAgICAgIHRoaXMubW9kZWwuc2V0KFwiYm91bmRzLnVwcGVyTGVmdC55XCIsIHJlY3QueSk7XHJcbiAgICAgICAgdGhpcy5tb2RlbC5zZXQoXCJib3VuZHMubG93ZXJSaWdodC54XCIsIHJlY3QueCArIHJlY3Qud2lkdGgpO1xyXG4gICAgICAgIHRoaXMubW9kZWwuc2V0KFwiYm91bmRzLmxvd2VyUmlnaHQueVwiLCByZWN0LnkgKyByZWN0LmhlaWdodCk7XHJcblx0XHRyZXR1cm4gdGhpcy5tb2RlbC5vcHRpb247XHJcblx0fTtcclxuXHJcblx0LyoqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICog5qC55o2u5bGe5oCn6K6+572u5qih5Z6L5pWw5o2uXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uIOaooeWei+aVsOaNrlxyXG4gICAgICovXHJcbiAgICBCUE1OTm9kZS5wcm90b3R5cGUuc2V0TW9kZWwgPSBmdW5jdGlvbihvcHRpb24pIHtcclxuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XHJcbiAgICAgICAgdmFyIG9yaWdpblRleHQgPSB0aGlzLm1vZGVsLmdldChcInByb3BlcnRpZXMubmFtZVwiKTtcclxuICAgICAgICB0aGlzLm1vZGVsLm1lcmdlT3B0aW9uKG9wdGlvbik7XHJcbiAgICAgICAgaWYob3JpZ2luVGV4dCAhPSBvcHRpb24ucHJvcGVydGllcy5uYW1lKSB7XHJcbiAgICAgICAgICAgIHZhciB0aXRsZSA9IHRoaXMuY2hpbGRPZk5hbWUoXCJUaXRsZVwiKTtcclxuICAgICAgICAgICAgdmFyIG5hbWVCeXRlTGVuZ3RoID0gb3B0aW9uLnByb3BlcnRpZXMubmFtZS5sZW5ndGg7XHJcbiAgICAgICAgICAgIHZhciBzaG93TmFtZTtcclxuICAgICAgICAgICAgaWYobmFtZUJ5dGVMZW5ndGggPiA2NCl7XHJcbiAgICAgICAgICAgICAgICBzaG93TmFtZSA9IG9wdGlvbi5wcm9wZXJ0aWVzLm5hbWUuc3Vic3RyKDAsNjQpKycuLic7XHJcbiAgICAgICAgICAgICAgICBpZih0aGlzLmFsYXJtKXtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFsYXJtLmlzU2hvdyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICAgICAgc2hvd05hbWUgPSBvcHRpb24ucHJvcGVydGllcy5uYW1lO1xyXG4gICAgICAgICAgICAgICAgaWYodGhpcy5hbGFybSl7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hbGFybS5pc1Nob3cgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGl0bGUuYXR0cihcInN0eWxlXCIse3RleHQ6c2hvd05hbWV9KTtcclxuICAgICAgICAgICAgdGhhdC5yZWZyZXNoVGV4dCh0aGF0KTtcclxuICAgICAgICAgICAgdmFyIG5hbWUgPSBvcHRpb24ucHJvcGVydGllcy5uYW1lO1xyXG4gICAgICAgICAgICB2YXIgdGV4dCA9IHRoaXMuYWxhcm0uY2hpbGRPZk5hbWUoXCJUZXh0XCIpO1xyXG4gICAgICAgICAgICB0ZXh0LmF0dHIoXCJzdHlsZVwiLHt0ZXh0Om5hbWV9KTtcclxuICAgICAgICAgICAgdmFyIGdyb3VwV2lkdGggPSB0ZXh0LmdldEJvdW5kaW5nUmVjdCgpLndpZHRoKzQ7XHJcbiAgICAgICAgICAgIHZhciBncm91cEhlaWdodCA9IHRleHQuZ2V0Qm91bmRpbmdSZWN0KCkuaGVpZ2h0Kzg7XHJcbiAgICAgICAgICAgIHZhciBwb2ludHMgPSBbXHJcbiAgICAgICAgICAgICAgICBbMCwwXSxcclxuICAgICAgICAgICAgICAgIFtncm91cFdpZHRoLDBdLFxyXG4gICAgICAgICAgICAgICAgW2dyb3VwV2lkdGgsZ3JvdXBIZWlnaHRdLFxyXG4gICAgICAgICAgICAgICAgW2dyb3VwV2lkdGgtMyxncm91cEhlaWdodF0sXHJcbiAgICAgICAgICAgICAgICBbZ3JvdXBXaWR0aC02LGdyb3VwSGVpZ2h0KzNdLFxyXG4gICAgICAgICAgICAgICAgW2dyb3VwV2lkdGgtOSxncm91cEhlaWdodF0sXHJcbiAgICAgICAgICAgICAgICBbMCxncm91cEhlaWdodF0sXHJcbiAgICAgICAgICAgICAgICBbMCwwXVxyXG4gICAgICAgICAgICBdO1xyXG4gICAgICAgICAgICB2YXIgUG9seWxpbmUgPSB0aGlzLmFsYXJtLmNoaWxkT2ZOYW1lKFwiUG9seWxpbmVcIik7XHJcbiAgICAgICAgICAgIFBvbHlsaW5lLmF0dHIoXCJzaGFwZVwiLHtwb2ludHM6cG9pbnRzfSk7XHJcbiAgICAgICAgICAgIHZhciBncm91cFBvc2l0aW9uID0gW3RoaXMucG9zaXRpb25bMF0rdGhpcy5nZXRCb3VuZGluZ1JlY3QoKS53aWR0aC0odGhpcy5hbGFybS5nZXRCb3VuZGluZ1JlY3QoKS53aWR0aC02KSx0aGlzLnBvc2l0aW9uWzFdLXRoaXMuYWxhcm0uZ2V0Qm91bmRpbmdSZWN0KCkuaGVpZ2h0LTNdO1xyXG4gICAgICAgICAgICB0aGlzLmFsYXJtLmF0dHIoXCJwb3NpdGlvblwiLGdyb3VwUG9zaXRpb24pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG5cclxuXHR6clV0aWwuaW5oZXJpdHMoQlBNTk5vZGUsTm9kZSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDms6jlhoxCUE1O6IqC54K555qE57G777yM5Y+q5pyJ5rOo5YaM6L+H5ZCO77yM5omN6IO95ZyoQlBNTue8lui+keWZqOS4rea3u+WKoFxyXG4gICAgICogQG1ldGhvZCByZWdpc3RlckNsYXNzXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gQ2xhenog57un5om/5LqGQlBNTk5vZGXnmoTlrp7njrDnsbtcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjb21wb25lbnRUeXBlIOazqOWGjOexu+eahOWQjeensFxyXG4gICAgICpcclxuICAgICAqICoq5L2/55So6IyD5L6LKirvvJpcclxuICAgICAqXHJcbiAgICAgKiAgICAgQGV4YW1wbGVcclxuICAgICAqICAgICBCUE1OTm9kZS5yZWdpc3RlckNsYXNzKEN1c3RvbU5vZGUsIFwiQ3VzdG9tTm9kZVwiKTtcclxuICAgICAqL1xyXG5cdGNsYXp6VXRpbC5lbmFibGVDbGFzc01hbmFnZW1lbnQoQlBNTk5vZGUsIHtcclxuICAgICAgICByZWdpc3RlcldoZW5FeHRlbmQ6IHRydWVcclxuICAgIH0pO1xyXG5cdG1vZHVsZS5leHBvcnRzID0gQlBNTk5vZGU7XHJcblxyXG5cclxuXHJcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9saWIvZmlzaC10b3BvLWJwbW4vbGliL25vZGUvQlBNTk5vZGUuanNcbiAqKiBtb2R1bGUgaWQgPSA3NVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXHJcbiAgICB2YXIgZ3JhcGhpYyA9IHJlcXVpcmUoJy4vZ3JhcGhpYycpO1xyXG4gICAgdmFyIHV0aWwgPSByZXF1aXJlKFwiLi91dGlsLmpzXCIpXHJcbiAgICAvL+WIm+W7uk5vZGXnsbsg5omA5pyJ5b2i54q26YO957un5om/Tm9kZSAg5YyF5ousZnJvbUpTT04gdG9KU09OXHJcbiAgICBmdW5jdGlvbiBOb2RlKCkge1xyXG4gICAgICAgIHRoaXMucmVzb3VyY2VJZCA9IHV0aWwuZ2V0VVVJRCgpOyAvLyDnlJ/miJDoioLngrlJRFxyXG4gICAgICAgIGdyYXBoaWMuR3JvdXAuY2FsbCh0aGlzKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOeUseeItuexu+WunueOsFxyXG4gICAgICogQHJldHVybiB7W3R5cGVdfSBbZGVzY3JpcHRpb25dXHJcbiAgICAgKi9cclxuICAgIE5vZGUucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uKCkge307XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDnlLHniLbnsbvlrp7njrBcclxuICAgICAqIEBwYXJhbSAge1t0eXBlXX0ganNvbiBbZGVzY3JpcHRpb25dXHJcbiAgICAgKiBAcmV0dXJuIHtbdHlwZV19ICAgICAgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICovXHJcbiAgICBOb2RlLnByb3RvdHlwZS5nZXRSZWN0ID0gZnVuY3Rpb24oanNvbikge307XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBkcmF3VGV4dFxyXG4gICAgICogQGRlc2NyaXB0aW9uIOeUu+S4gOS4quaWh+acrFxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb2xvclxyXG4gICAgICovXHJcbiAgICBOb2RlLnByb3RvdHlwZS5kcmF3VGV4dCA9IGZ1bmN0aW9uKG5hbWUsY29sb3IpIHtcclxuICAgICAgICB2YXIgdGV4dE5hbWUgPSB0aGlzLmJwbW5JbmZvLm5hbWU7XHJcbiAgICAgICAgaWYobmFtZSAhPSBudWxsKXtcclxuICAgICAgICAgICAgdGV4dE5hbWUgPSBuYW1lO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgdGV4dCA9IG5ldyBncmFwaGljLlRleHQoe1xyXG4gICAgICAgICAgICBzdHlsZToge1xyXG4gICAgICAgICAgICAgICAgdGV4dDogdGV4dE5hbWUsXHJcbiAgICAgICAgICAgICAgICBjb2xvcjogY29sb3IgPyBjb2xvciA6IHRoaXMub3B0aW9ucy50ZXh0LmNvbG9yLFxyXG4gICAgICAgICAgICAgICAgdGV4dEZvbnQ6ICcxMnB4IE1pY3Jvc29mdCBZYUhlaSdcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgemxldmVsOiAyMFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8v5paH5a2X57uY5Yi255qE5L2N572uICBcclxuICAgICAgICAvL3ggPSDkuK3lv4PngrkueCAtIOi1t+Wni+S9jee9ri54IC0g5paH5a2X5a695bqm55qE5LiA5Y2KXHJcbiAgICAgICAgdmFyIHggPSB0aGlzLmdldFJlY3QoKS54IC0gdGhpcy5wb3NpdGlvblswXSAtIHRleHQuZ2V0Qm91bmRpbmdSZWN0KCkud2lkdGggLyAyO1xyXG4gICAgICAgIC8veSA9IOS4reW/g+eCuS55IC0g6LW35aeL5L2N572uLnkgKyDoioLngrnpq5jluqbnmoTkuIDljYogKyDlgY/np7vlgLzvvIg277yJXHJcbiAgICAgICAgdmFyIHkgPSB0aGlzLmdldFJlY3QoKS55IC0gdGhpcy5wb3NpdGlvblsxXSArIHRoaXMuZ2V0Qm91bmRpbmdSZWN0KCkuaGVpZ2h0IC8gMiArIHRleHQuZ2V0Qm91bmRpbmdSZWN0KCkuaGVpZ2h0ICsgNjtcclxuICAgICAgICB0ZXh0LmF0dHIoXCJzdHlsZVwiLCB7IHg6IHgsIHk6IHkgfSk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgdGV4dDogdGV4dCxcclxuICAgICAgICAgICAgcmVjdDogdGV4dC5nZXRCb3VuZGluZ1JlY3QoKVxyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiByZWZyZXNoVGV4dFxyXG4gICAgICogQGRlc2NyaXB0aW9uIOWIt+aWsOaWh+acrFxyXG4gICAgICovXHJcbiAgICBOb2RlLnByb3RvdHlwZS5yZWZyZXNoVGV4dCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciB0ZXh0ID0gdGhpcy5jaGlsZE9mTmFtZShcIlRpdGxlXCIpO1xyXG4gICAgICAgIHZhciB4ID0gdGhpcy5nZXRSZWN0KCkueCAtIHRoaXMucG9zaXRpb25bMF0gLSB0ZXh0LmdldEJvdW5kaW5nUmVjdCgpLndpZHRoIC8gMjtcclxuICAgICAgICB2YXIgeSA9IHRoaXMuZ2V0UmVjdCgpLnkgLSB0aGlzLnBvc2l0aW9uWzFdICsgdGhpcy5nZXRCb3VuZGluZ1JlY3QoKS5oZWlnaHQgLyAyICsgdGV4dC5nZXRCb3VuZGluZ1JlY3QoKS5oZWlnaHQgKyA2O1xyXG4gICAgICAgIHRleHQuYXR0cihcInN0eWxlXCIsIHsgeDogeCwgeTogeSB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIOeUseeItuexu+WunueOsFxyXG4gICAgICogQHJldHVybiB7W3R5cGVdfSBbZGVzY3JpcHRpb25dXHJcbiAgICAgKi9cclxuICAgIE5vZGUucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uKCkge307XHJcblxyXG4gICAgZ3JhcGhpYy5VdGlsLmluaGVyaXRzKE5vZGUsIGdyYXBoaWMuR3JvdXApO1xyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBOb2RlO1xyXG5cclxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2xpYi9maXNoLXRvcG8tY29yZS9saWIvTm9kZS5qc1xuICoqIG1vZHVsZSBpZCA9IDc2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcclxuXHJcbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XHJcblxyXG4gICAgdmFyIGNsYXp6ID0ge307XHJcblxyXG4gICAgdmFyIFRZUEVfREVMSU1JVEVSID0gJy4nO1xyXG4gICAgdmFyIElTX0NPTlRBSU5FUiA9ICdfX19GVF9fQ09NUE9ORU5UX19DT05UQUlORVJfX18nO1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcHVibGljXHJcbiAgICAgKi9cclxuICAgIHZhciBwYXJzZUNsYXNzVHlwZSA9IGNsYXp6LnBhcnNlQ2xhc3NUeXBlID0gZnVuY3Rpb24gKGNvbXBvbmVudFR5cGUpIHtcclxuICAgICAgICB2YXIgcmV0ID0ge21haW46ICcnLCBzdWI6ICcnfTtcclxuICAgICAgICBpZiAoY29tcG9uZW50VHlwZSkge1xyXG4gICAgICAgICAgICBjb21wb25lbnRUeXBlID0gY29tcG9uZW50VHlwZS5zcGxpdChUWVBFX0RFTElNSVRFUik7XHJcbiAgICAgICAgICAgIHJldC5tYWluID0gY29tcG9uZW50VHlwZVswXSB8fCAnJztcclxuICAgICAgICAgICAgcmV0LnN1YiA9IGNvbXBvbmVudFR5cGVbMV0gfHwgJyc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXQ7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcHVibGljICDnm7jmr5Qg55u05o6l55SoenJVdGlsLmluaGVyaXRzIOWlveWkhOaYryAg5Y+v5Lul55u05o6l6LCD55So54i257G755qE5p6E6YCg5Ye95pWwXHJcbiAgICAgKi9cclxuICAgIGNsYXp6LmVuYWJsZUNsYXNzRXh0ZW5kID0gZnVuY3Rpb24gKFJvb3RDbGFzcywgcHJlQ29uc3RydWN0KSB7XHJcbiAgICAgICAgUm9vdENsYXNzLmV4dGVuZCA9IGZ1bmN0aW9uIChwcm90bykge1xyXG4gICAgICAgICAgICB2YXIgRXh0ZW5kZWRDbGFzcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHByZUNvbnN0cnVjdCAmJiBwcmVDb25zdHJ1Y3QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgICAgIFJvb3RDbGFzcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgenJVdGlsLmV4dGVuZChFeHRlbmRlZENsYXNzLnByb3RvdHlwZSwgcHJvdG8pO1xyXG5cclxuICAgICAgICAgICAgRXh0ZW5kZWRDbGFzcy5leHRlbmQgPSB0aGlzLmV4dGVuZDtcclxuICAgICAgICAgICAgRXh0ZW5kZWRDbGFzcy5zdXBlckNhbGwgPSBzdXBlckNhbGw7XHJcbiAgICAgICAgICAgIEV4dGVuZGVkQ2xhc3Muc3VwZXJBcHBseSA9IHN1cGVyQXBwbHk7XHJcbiAgICAgICAgICAgIHpyVXRpbC5pbmhlcml0cyhFeHRlbmRlZENsYXNzLCB0aGlzKTtcclxuICAgICAgICAgICAgRXh0ZW5kZWRDbGFzcy5zdXBlckNsYXNzID0gdGhpcztcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBFeHRlbmRlZENsYXNzO1xyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIHN1cGVyQ2FsbCBzaG91bGQgaGF2ZSBjbGFzcyBpbmZvLCB3aGljaCBjYW4gbm90IGJlIGZldGNoIGZyb20gJ3RoaXMnLlxyXG4gICAgLy8gQ29uc2lkZXIgdGhpcyBjYXNlOlxyXG4gICAgLy8gY2xhc3MgQSBoYXMgbWV0aG9kIGYsXHJcbiAgICAvLyBjbGFzcyBCIGluaGVyaXRzIGNsYXNzIEEsIG92ZXJyaWRlcyBtZXRob2QgZiwgZiBjYWxsIHN1cGVyQXBwbHkoJ2YnKSxcclxuICAgIC8vIGNsYXNzIEMgaW5oZXJpdHMgY2xhc3MgQiwgZG8gbm90IG92ZXJyaWRlcyBtZXRob2QgZixcclxuICAgIC8vIHRoZW4gd2hlbiBtZXRob2Qgb2YgY2xhc3MgQyBpcyBjYWxsZWQsIGRlYWQgbG9vcCBvY2N1cmVkLlxyXG4gICAgZnVuY3Rpb24gc3VwZXJDYWxsKGNvbnRleHQsIG1ldGhvZE5hbWUpIHtcclxuICAgICAgICB2YXIgYXJncyA9IHpyVXRpbC5zbGljZShhcmd1bWVudHMsIDIpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLnN1cGVyQ2xhc3MucHJvdG90eXBlW21ldGhvZE5hbWVdLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHN1cGVyQXBwbHkoY29udGV4dCwgbWV0aG9kTmFtZSwgYXJncykge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnN1cGVyQ2xhc3MucHJvdG90eXBlW21ldGhvZE5hbWVdLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGVudGl0eVxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMucmVnaXN0ZXJXaGVuRXh0ZW5kXVxyXG4gICAgICogQHB1YmxpY1xyXG4gICAgICovXHJcbiAgICBjbGF6ei5lbmFibGVDbGFzc01hbmFnZW1lbnQgPSBmdW5jdGlvbiAoZW50aXR5LCBvcHRpb25zKSB7XHJcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENvbXBvbmVudCBtb2RlbCBjbGFzc2VzXHJcbiAgICAgICAgICoga2V5OiBjb21wb25lbnRUeXBlLFxyXG4gICAgICAgICAqIHZhbHVlOlxyXG4gICAgICAgICAqICAgICBjb21wb25lbnRDbGFzcywgd2hlbiBjb21wb25lbnRUeXBlIGlzICd4eHgnXHJcbiAgICAgICAgICogICAgIG9yIE9iamVjdC48c3ViS2V5LCBjb21wb25lbnRDbGFzcz4sIHdoZW4gY29tcG9uZW50VHlwZSBpcyAneHh4Lnl5J1xyXG4gICAgICAgICAqIEB0eXBlIHtPYmplY3R9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdmFyIHN0b3JhZ2UgPSB7fTtcclxuXHJcbiAgICAgICAgZW50aXR5LnJlZ2lzdGVyQ2xhc3MgPSBmdW5jdGlvbiAoQ2xhenosIGNvbXBvbmVudFR5cGUpIHtcclxuICAgICAgICAgICAgaWYgKGNvbXBvbmVudFR5cGUpIHtcclxuICAgICAgICAgICAgICAgIGNvbXBvbmVudFR5cGUgPSBwYXJzZUNsYXNzVHlwZShjb21wb25lbnRUeXBlKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIWNvbXBvbmVudFR5cGUuc3ViKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0b3JhZ2VbY29tcG9uZW50VHlwZS5tYWluXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL+W3sue7j+azqOWGjOi/h+S6hu+8jOebtOaOpei/lOWbnlxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHN0b3JhZ2VbY29tcG9uZW50VHlwZS5tYWluXSA9IENsYXp6O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY29tcG9uZW50VHlwZS5zdWIgIT09IElTX0NPTlRBSU5FUikge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjb250YWluZXIgPSBtYWtlQ29udGFpbmVyKGNvbXBvbmVudFR5cGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lcltjb21wb25lbnRUeXBlLnN1Yl0gPSBDbGF6ejtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gQ2xheno7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgZW50aXR5LmdldENsYXNzID0gZnVuY3Rpb24gKGNvbXBvbmVudFR5cGVNYWluLCBzdWJUeXBlLCB0aHJvd1doZW5Ob3RGb3VuZCkge1xyXG4gICAgICAgICAgICB2YXIgQ2xhenogPSBzdG9yYWdlW2NvbXBvbmVudFR5cGVNYWluXTtcclxuXHJcbiAgICAgICAgICAgIGlmIChDbGF6eiAmJiBDbGF6eltJU19DT05UQUlORVJdKSB7XHJcbiAgICAgICAgICAgICAgICBDbGF6eiA9IHN1YlR5cGUgPyBDbGF6eltzdWJUeXBlXSA6IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICh0aHJvd1doZW5Ob3RGb3VuZCAmJiAhQ2xhenopIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcclxuICAgICAgICAgICAgICAgICAgICAnQ29tcG9uZW50ICcgKyBjb21wb25lbnRUeXBlTWFpbiArICcuJyArIChzdWJUeXBlIHx8ICcnKSArICcgbm90IGV4aXN0cy4gTG9hZCBpdCBmaXJzdC4nXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gQ2xheno7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgZW50aXR5LmdldENsYXNzZXNCeU1haW5UeXBlID0gZnVuY3Rpb24gKGNvbXBvbmVudFR5cGUpIHtcclxuICAgICAgICAgICAgY29tcG9uZW50VHlwZSA9IHBhcnNlQ2xhc3NUeXBlKGNvbXBvbmVudFR5cGUpO1xyXG5cclxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xyXG4gICAgICAgICAgICB2YXIgb2JqID0gc3RvcmFnZVtjb21wb25lbnRUeXBlLm1haW5dO1xyXG5cclxuICAgICAgICAgICAgaWYgKG9iaiAmJiBvYmpbSVNfQ09OVEFJTkVSXSkge1xyXG4gICAgICAgICAgICAgICAgenJVdGlsLmVhY2gob2JqLCBmdW5jdGlvbiAobywgdHlwZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHR5cGUgIT09IElTX0NPTlRBSU5FUiAmJiByZXN1bHQucHVzaChvKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gob2JqKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBlbnRpdHkuaGFzQ2xhc3MgPSBmdW5jdGlvbiAoY29tcG9uZW50VHlwZSkge1xyXG4gICAgICAgICAgICAvLyBKdXN0IGNvbnNpZGVyIGNvbXBvbmVudFR5cGUubWFpbi5cclxuICAgICAgICAgICAgY29tcG9uZW50VHlwZSA9IHBhcnNlQ2xhc3NUeXBlKGNvbXBvbmVudFR5cGUpO1xyXG4gICAgICAgICAgICByZXR1cm4gISFzdG9yYWdlW2NvbXBvbmVudFR5cGUubWFpbl07XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHJldHVybiB7QXJyYXkuPHN0cmluZz59IExpa2UgWydhYScsICdiYiddLCBidXQgY2FuIG5vdCBiZSBbJ2FhLnh4J11cclxuICAgICAgICAgKi9cclxuICAgICAgICBlbnRpdHkuZ2V0QWxsQ2xhc3NNYWluVHlwZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciB0eXBlcyA9IFtdO1xyXG4gICAgICAgICAgICB6clV0aWwuZWFjaChzdG9yYWdlLCBmdW5jdGlvbiAob2JqLCB0eXBlKSB7XHJcbiAgICAgICAgICAgICAgICB0eXBlcy5wdXNoKHR5cGUpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIHR5cGVzO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIElmIGEgbWFpbiB0eXBlIGlzIGNvbnRhaW5lciBhbmQgaGFzIHN1YiB0eXBlc1xyXG4gICAgICAgICAqIEBwYXJhbSAge3N0cmluZ30gIGNvbXBvbmVudFR5cGVcclxuICAgICAgICAgKiBAcmV0dXJuIHtib29sZWFufVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGVudGl0eS5oYXNTdWJUeXBlcyA9IGZ1bmN0aW9uIChjb21wb25lbnRUeXBlKSB7XHJcbiAgICAgICAgICAgIGNvbXBvbmVudFR5cGUgPSBwYXJzZUNsYXNzVHlwZShjb21wb25lbnRUeXBlKTtcclxuICAgICAgICAgICAgdmFyIG9iaiA9IHN0b3JhZ2VbY29tcG9uZW50VHlwZS5tYWluXTtcclxuICAgICAgICAgICAgcmV0dXJuIG9iaiAmJiBvYmpbSVNfQ09OVEFJTkVSXTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBlbnRpdHkucGFyc2VDbGFzc1R5cGUgPSBwYXJzZUNsYXNzVHlwZTtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gbWFrZUNvbnRhaW5lcihjb21wb25lbnRUeXBlKSB7XHJcbiAgICAgICAgICAgIHZhciBjb250YWluZXIgPSBzdG9yYWdlW2NvbXBvbmVudFR5cGUubWFpbl07XHJcbiAgICAgICAgICAgIGlmICghY29udGFpbmVyIHx8ICFjb250YWluZXJbSVNfQ09OVEFJTkVSXSkge1xyXG4gICAgICAgICAgICAgICAgY29udGFpbmVyID0gc3RvcmFnZVtjb21wb25lbnRUeXBlLm1haW5dID0ge307XHJcbiAgICAgICAgICAgICAgICBjb250YWluZXJbSVNfQ09OVEFJTkVSXSA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGNvbnRhaW5lcjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChvcHRpb25zLnJlZ2lzdGVyV2hlbkV4dGVuZCkge1xyXG4gICAgICAgICAgICB2YXIgb3JpZ2luYWxFeHRlbmQgPSBlbnRpdHkuZXh0ZW5kO1xyXG4gICAgICAgICAgICBpZiAob3JpZ2luYWxFeHRlbmQpIHtcclxuICAgICAgICAgICAgICAgIGVudGl0eS5leHRlbmQgPSBmdW5jdGlvbiAocHJvdG8pIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgRXh0ZW5kZWRDbGFzcyA9IG9yaWdpbmFsRXh0ZW5kLmNhbGwodGhpcywgcHJvdG8pO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlbnRpdHkucmVnaXN0ZXJDbGFzcyhFeHRlbmRlZENsYXNzLCBwcm90by50eXBlKTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBlbnRpdHk7XHJcbiAgICB9O1xyXG5cclxuICAgIG1vZHVsZS5leHBvcnRzID0gY2xheno7XHJcblxyXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vbGliL2Zpc2gtdG9wby1jb3JlL2xpYi9jbGF6ei5qc1xuICoqIG1vZHVsZSBpZCA9IDc3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcclxuICogQlBNTiBtb2RlbFxyXG4gKlxyXG4gKi9cclxuXHJcblxyXG4gICAgdmFyIE1vZGVsID0gcmVxdWlyZSgnLi4vLi4vLi4vZmlzaC10b3BvLWNvcmUvbGliL01vZGVsJyk7XHJcbiAgICB2YXIgQlBNTk1vZGVsID0gTW9kZWwuZXh0ZW5kKHtcclxuXHJcbiAgICAgICAgdHlwZTogJ0JQTU4nLFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEB0eXBlIHtPYmplY3R9XHJcbiAgICAgICAgICogQHByb3RlY3RlZFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGRlZmF1bHRPcHRpb246IHtcclxuICAgICAgICAgICAgcmVzb3VyY2VJZDogXCJcIiwgIC8v6LWE5rqQSURcclxuXHJcbiAgICAgICAgICAgIHByb3BlcnRpZXM6IHtcclxuICAgICAgICAgICAgICAgIHR5cGU6IC0xLCAgLy/nsbvlnotcclxuICAgICAgICAgICAgICAgIG5hbWU6IG51bGwsIC8v5ZCN56ewXHJcbiAgICAgICAgICAgICAgICBub3RlczogXCJcIiwgIC8v5aSH5rOoXHJcbiAgICAgICAgICAgICAgICAvL25vOiBcIlwiXHJcbiAgICAgICAgICAgICAgICBleHRQcm9wZXJ0aWVzOiB7fSAgLy/mianlsZXlsZ7mgKdcclxuICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgIHN0ZW5jaWw6IHt0eXBlOiBcIkJQTU5EaWFncmFtXCJ9LFxyXG5cclxuICAgICAgICAgICAgY2hpbGRTaGFwZXM6IFtdLCAgICAvL+WtkOW9oueKtlxyXG5cclxuICAgICAgICAgICAgb3V0Z29pbmc6IFtdLCAgLy8g5LiL5LiA5Liq6KaB6L+e5o6l55qE5b2i54q2XHJcblxyXG4gICAgICAgICAgICBib3VuZHM6IHtcclxuICAgICAgICAgICAgICAgIHVwcGVyTGVmdDoge3g6MCwgeTowfSwgIC8v5bem5LiK6KeS5Z2Q5qCHXHJcbiAgICAgICAgICAgICAgICBsb3dlclJpZ2h0OiB7eDowLCB5OjB9IC8v5Y+z5LiL6KeS5Z2Q5qCHXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIG1vZHVsZS5leHBvcnRzID0gQlBNTk1vZGVsO1xyXG5cclxuXHJcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9saWIvZmlzaC10b3BvLWJwbW4vbGliL21vZGVsL0JQTU5Nb2RlbC5qc1xuICoqIG1vZHVsZSBpZCA9IDc4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcclxuICog6IqC54K5562J55qE5qih5Z6LXHJcbiAqIOmHjOmdouWtmOeahOaVsOaNrueUqOadpeWkhOeQhuW6j+WIl+WMluWSjOWPjeW6j+WIl+WMllxyXG4gKiBAY2xhc3MgZmlzaC50b3BvLm1vZGVsXHJcbiAqL1xyXG5cclxuXHJcbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XHJcbiAgICB2YXIgY2xhenpVdGlsID0gcmVxdWlyZSgnLi9jbGF6eicpO1xyXG5cclxuICAgIGZ1bmN0aW9uIE1vZGVsKG9wdGlvbiwgcGFyZW50TW9kZWwsICBleHRyYU9wdCkge1xyXG4gICAgICAgIHRoaXMucGFyZW50TW9kZWwgPSBwYXJlbnRNb2RlbDtcclxuICAgICAgICB0aGlzLm9wdGlvbiA9IG9wdGlvbjtcclxuXHJcbiAgICAgICAgLy8gU2ltcGxlIG9wdGltaXphdGlvblxyXG4gICAgICAgIGlmICh0aGlzLmluaXQpIHtcclxuICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPD0gMykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pbml0KG9wdGlvbiwgcGFyZW50TW9kZWwsICBleHRyYU9wdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmluaXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBNb2RlbC5wcm90b3R5cGUgPSB7XHJcblxyXG4gICAgICAgIGNvbnN0cnVjdG9yOiBNb2RlbCxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogTW9kZWwg55qE5Yid5aeL5YyW5Ye95pWwXHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgaW5pdDogZnVuY3Rpb24gKG9wdGlvbikge1xyXG4gICAgICAgICAgICB6clV0aWwubWVyZ2Uob3B0aW9uLCB0aGlzLmdldERlZmF1bHRPcHRpb24oKSk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgZ2V0RGVmYXVsdE9wdGlvbjogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuaGFzT3duUHJvcGVydHkoJ19fZGVmYXVsdE9wdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgb3B0TGlzdCA9IFtdO1xyXG4gICAgICAgICAgICAgICAgdmFyIENsYXNzID0gdGhpcy5jb25zdHJ1Y3RvcjtcclxuICAgICAgICAgICAgICAgIHdoaWxlIChDbGFzcykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBvcHQgPSBDbGFzcy5wcm90b3R5cGUuZGVmYXVsdE9wdGlvbjtcclxuICAgICAgICAgICAgICAgICAgICBvcHQgJiYgb3B0TGlzdC5wdXNoKG9wdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgQ2xhc3MgPSBDbGFzcy5zdXBlckNsYXNzO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHZhciBkZWZhdWx0T3B0aW9uID0ge307XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gb3B0TGlzdC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHRPcHRpb24gPSB6clV0aWwubWVyZ2UoZGVmYXVsdE9wdGlvbiwgb3B0TGlzdFtpXSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9fZGVmYXVsdE9wdGlvbiA9IGRlZmF1bHRPcHRpb247XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX19kZWZhdWx0T3B0aW9uO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgbWVyZ2VPcHRpb246IGZ1bmN0aW9uIChvcHRpb24pIHtcclxuICAgICAgICAgICAgenJVdGlsLm1lcmdlKHRoaXMub3B0aW9uLCBvcHRpb24sIHRydWUpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIOiOt+WPlm1vZGVs55qE5p+Q5Liq5bGe5oCn55qE5YC8XHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGggbW9kZWzkuK3nmoTlsZ7mgKdcclxuICAgICAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAqKuS9v+eUqOiMg+S+iyoq77yaXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgIEBleGFtcGxlXHJcbiAgICAgICAgICogICAgICAgICAgbm9kZS5tb2RlbC5nZXQoXCJvcHRpb25zLnRleHRcIik7XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAocGF0aCwgaWdub3JlUGFyZW50KSB7XHJcbiAgICAgICAgICAgIGlmICghcGF0aCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9uO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHBhdGggPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgICAgICBwYXRoID0gcGF0aC5zcGxpdCgnLicpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgb2JqID0gdGhpcy5vcHRpb247XHJcbiAgICAgICAgICAgIHZhciBwYXJlbnRNb2RlbCA9IHRoaXMucGFyZW50TW9kZWw7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0aC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgLy8gb2JqIGNvdWxkIGJlIG51bWJlci9zdHJpbmcvLi4uIChsaWtlIDApXHJcbiAgICAgICAgICAgICAgICBvYmogPSAob2JqICYmIHR5cGVvZiBvYmogPT09ICdvYmplY3QnKSA/IG9ialtwYXRoW2ldXSA6IG51bGw7XHJcbiAgICAgICAgICAgICAgICBpZiAob2JqID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAob2JqID09IG51bGwgJiYgcGFyZW50TW9kZWwgJiYgIWlnbm9yZVBhcmVudCkge1xyXG4gICAgICAgICAgICAgICAgb2JqID0gcGFyZW50TW9kZWwuZ2V0KHBhdGgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBvYmo7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICog6K6+572ubW9kZWznmoTmn5DkuKrlsZ7mgKfnmoTlgLxcclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBtb2RlbOS4reeahOWxnuaAp1xyXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZSDmiYDpnIDopoHorr7nva7nmoTlgLxcclxuICAgICAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAqKuS9v+eUqOiMg+S+iyoq77yaXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgIEBleGFtcGxlXHJcbiAgICAgICAgICogICAgICAgICAgbm9kZS5tb2RlbC5zZXQoXCJvcHRpb25zLnRleHRcIixcIuS+i+WtkFwiKTtcclxuICAgICAgICAgKi9cclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChwYXRoLCB2YWx1ZSkge1xyXG4gICAgICAgICAgICB2YXIgb2JqID0gdGhpcy5vcHRpb247XHJcblxyXG4gICAgICAgICAgICBpZiAocGF0aC5pbmRleE9mKFwiLlwiKSA9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgb2JqW3BhdGhdID0gdmFsdWU7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZmllbGRBcnJheSAgPSBwYXRoLnNwbGl0KCcuJyk7XHJcbiAgICAgICAgICAgICAgICB2YXIgbiA9IGZpZWxkQXJyYXkubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgdmFyIGN1cnJlbnRSZWYgPSBvYmo7XHJcbiAgICAgICAgICAgICAgICB2YXIgZmllbGROYW1lO1xyXG5cclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbiAtIDE7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGZpZWxkTmFtZSA9IGZpZWxkQXJyYXlbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoY3VycmVudFJlZltmaWVsZE5hbWVdID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFJlZltmaWVsZE5hbWVdID0ge307XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRSZWYgPSBjdXJyZW50UmVmW2ZpZWxkTmFtZV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBmaWVsZE5hbWUgPSBmaWVsZEFycmF5W24tMV07XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50UmVmW2ZpZWxkTmFtZV0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0U2hhbGxvdzogZnVuY3Rpb24gKGtleSwgaWdub3JlUGFyZW50KSB7XHJcbiAgICAgICAgICAgIHZhciBvcHRpb24gPSB0aGlzLm9wdGlvbjtcclxuICAgICAgICAgICAgdmFyIHZhbCA9IG9wdGlvbiAmJiBvcHRpb25ba2V5XTtcclxuICAgICAgICAgICAgdmFyIHBhcmVudE1vZGVsID0gdGhpcy5wYXJlbnRNb2RlbDtcclxuICAgICAgICAgICAgaWYgKHZhbCA9PSBudWxsICYmIHBhcmVudE1vZGVsICYmICFpZ25vcmVQYXJlbnQpIHtcclxuICAgICAgICAgICAgICAgIHZhbCA9IHBhcmVudE1vZGVsLmdldFNoYWxsb3coa2V5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdmFsO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0TW9kZWw6IGZ1bmN0aW9uIChwYXRoLCBwYXJlbnRNb2RlbCkge1xyXG4gICAgICAgICAgICB2YXIgb2JqID0gdGhpcy5nZXQocGF0aCwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIHZhciB0aGlzUGFyZW50TW9kZWwgPSB0aGlzLnBhcmVudE1vZGVsO1xyXG4gICAgICAgICAgICB2YXIgbW9kZWwgPSBuZXcgTW9kZWwoXHJcbiAgICAgICAgICAgICAgICBvYmosIHBhcmVudE1vZGVsIHx8ICh0aGlzUGFyZW50TW9kZWwgJiYgdGhpc1BhcmVudE1vZGVsLmdldE1vZGVsKHBhdGgpKVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICByZXR1cm4gbW9kZWw7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICrmuIXnqbptb2RlbOeahG9wdGlvblxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgaXNFbXB0eTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vcHRpb24gPT0gbnVsbDtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICByZXN0b3JlRGF0YTogZnVuY3Rpb24gKCkge30sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgY2xvbmU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIEN0b3IgPSB0aGlzLmNvbnN0cnVjdG9yO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEN0b3IoenJVdGlsLmNsb25lKHRoaXMub3B0aW9uKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvLyBFbmFibGUgTW9kZWwuZXh0ZW5kLlxyXG4gICAgY2xhenpVdGlsLmVuYWJsZUNsYXNzRXh0ZW5kKE1vZGVsKTtcclxuXHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IE1vZGVsO1xyXG5cclxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2xpYi9maXNoLXRvcG8tY29yZS9saWIvTW9kZWwuanNcbiAqKiBtb2R1bGUgaWQgPSA3OVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXHJcblx0dmFyIEV2ZW50Tm9kZSA9IHJlcXVpcmUoXCIuL0V2ZW50Tm9kZVwiKTtcclxuXHR2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XHJcbiAgICB2YXIgZ3JhcGhpYyA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi9maXNoLXRvcG8tY29yZS9saWIvZ3JhcGhpYy5qc1wiKTtcclxuXHJcbi8qKlxyXG4gKiA8ZyBwb2ludGVyLWV2ZW50cz1cImZpbGxcIiBpZD1cInNpZC1GRjBBREZDMC1EM0VDLTQyMzctQUQxNi1BMzYyNzNEMUZFNkRcIiB0aXRsZT1cIlN0YXJ0IGV2ZW50XCI+XHJcbiAqICAgIDxjaXJjbGUgaWQ9XCJzaWQtRkYwQURGQzAtRDNFQy00MjM3LUFEMTYtQTM2MjczRDFGRTZEYmdfZnJhbWVcIiBjeD1cIjE1XCIgY3k9XCIxNVwiIHI9XCIxNVwiIHN0cm9rZT1cIlwiIGZpbGw9XCIjN0VEMzIxXCI+PC9jaXJjbGU+XHJcbiAqICAgIDxwYXRoIGQ9XCJNMTEuMjUsOC4yNSBMMTEuMjUsMjIuNSBMMjIuNSwxNS4zNzUgTDExLjI1LDguMjUgWlwiIGlkPVwic2lkLUZGMEFERkMwLUQzRUMtNDIzNy1BRDE2LUEzNjI3M0QxRkU2RHBhdGgxXCIgZmlsbD1cIiNGRkZGRkZcIj48L3BhdGg+XHJcbiAqIDwvZz5cclxuICovXHJcblxyXG5cdGZ1bmN0aW9uIFN0YXJ0RXZlbnROb2RlKG1vZGVsLCBhcGkpIHtcclxuXHRcdEV2ZW50Tm9kZS5jYWxsKHRoaXMsIG1vZGVsLCBhcGkpO1xyXG4gICAgICAgIHRoaXMuc3RhcnRJY29uID0gJ00xMS4yNSw4LjI1IEwxMS4yNSwyMi41IEwyMi41LDE1LjM3NSBMMTEuMjUsOC4yNSBaJztcclxuICAgICAgICB0aGlzLml0ZW1TaXplID0gMjA7XHJcblx0XHR0aGlzLmJwbW5JbmZvID0ge3R5cGU6IDI5LCBuYW1lOlwiU3RhcnROb25lRXZlbnRcIiB9OyAgICAvL+iKgueCueS/oeaBr1xyXG5cclxuICAgICAgICB0aGlzLnJlbmRlcihtb2RlbCk7XHJcblxyXG5cdH1cclxuXHJcbiAgICBTdGFydEV2ZW50Tm9kZS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24obW9kZWwpIHtcclxuICAgICAgICB0aGlzLnJlbW92ZUFsbCgpO1xyXG4gICAgICAgIHRoaXMubW9kZWwgPSBtb2RlbDtcclxuICAgICAgICB2YXIgY2lyY2xlID0gbmV3IGdyYXBoaWMuQ2lyY2xlKHtcclxuICAgICAgICAgICAgICAgIHNoYXBlOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgY3g6IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgY3k6IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgcjogdGhpcy5pdGVtU2l6ZVxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgZmlsbDogJyM3RUQzMjEnXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgejoyXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgY2lyY2xlLm5hbWUgPSBcIkNpcmNsZVwiO1xyXG4gICAgICAgIHRoaXMuYWRkKGNpcmNsZSk7XHJcbiAgICAgICAgdmFyIGl0ZW1TaXplID0gdGhpcy5pdGVtU2l6ZTtcclxuICAgICAgICB2YXIgcmVjdCA9IHt4Oi1pdGVtU2l6ZS8yLCB5OiAtaXRlbVNpemUvMiwgd2lkdGg6IGl0ZW1TaXplLCBoZWlnaHQ6aXRlbVNpemV9O1xyXG4gICAgICAgIHRoaXMuYWRkKGdyYXBoaWMubWFrZVBhdGgodGhpcy5zdGFydEljb24sIHtzdHlsZToge2ZpbGw6ICcjRkZGRkZGJ30sejoyfSwgcmVjdCxcImNlbnRlclwiKSk7XHJcbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IFttb2RlbC5nZXQoXCJib3VuZHMudXBwZXJMZWZ0LnhcIikraXRlbVNpemUgLCBtb2RlbC5nZXQoXCJib3VuZHMudXBwZXJMZWZ0LnlcIikraXRlbVNpemVdO1xyXG4gICAgICAgIHZhciB0aXRsZSA9IHRoaXMuZHJhd1RleHQobW9kZWwuZ2V0KFwicHJvcGVydGllcy5uYW1lXCIpKTtcclxuICAgICAgICB0aXRsZS50ZXh0Lm5hbWUgPSBcIlRpdGxlXCI7XHJcbiAgICAgICAgdGhpcy5hZGQodGl0bGUudGV4dCk7XHJcbiAgICB9O1xyXG5cclxuXHJcblx0enJVdGlsLmluaGVyaXRzKFN0YXJ0RXZlbnROb2RlLCBFdmVudE5vZGUpO1xyXG5cdG1vZHVsZS5leHBvcnRzID0gU3RhcnRFdmVudE5vZGU7XHJcblxyXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vbGliL2Zpc2gtdG9wby1icG1uL2xpYi9ub2RlL2V2ZW50L1N0YXJ0RXZlbnROb2RlLmpzXG4gKiogbW9kdWxlIGlkID0gODBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlxyXG4gICAgdmFyIEJQTU5Ob2RlID0gcmVxdWlyZShcIi4uL0JQTU5Ob2RlXCIpO1xyXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xyXG4gICAgdmFyIEJvdW5kaW5nUmVjdCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvQm91bmRpbmdSZWN0LmpzJyk7XHJcbiAgICAvL+WIm+W7uk5vZGXnsbsg5omA5pyJ5b2i54q26YO957un5om/Tm9kZSAg5YyF5ousZnJvbUpTT04gdG9KU09OXHJcbiAgICAvL1xyXG4gICAgZnVuY3Rpb24gRXZlbnROb2RlKG1vZGVsLGFwaSkge1xyXG4gICAgICAgIEJQTU5Ob2RlLmNhbGwodGhpcywgbW9kZWwsIGFwaSk7XHJcbiAgICAgICAgdGhpcy5icG1uSW5mbyA9IHt0eXBlOiAtMSwgbmFtZTpcIkV2ZW50Tm9kZVwiIH07ICAgIC8v6IqC54K55L+h5oGvXHJcbiAgICAgICAgdGhpcy5tb2RlbCA9IG1vZGVsO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICBFdmVudE5vZGUucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uKCkge1xyXG5cclxuICAgIH07XHJcblxyXG5cclxuICAgIEV2ZW50Tm9kZS5wcm90b3R5cGUuZ2V0UmVjdCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIC8vIGJvZHkuLi5cclxuICAgICAgICB2YXIgYm91bmRpbmdSZWN0ID0gdGhpcy5nZXRCb3VuZGluZ1JlY3QoKTtcclxuICAgICAgICAvL+WIm+W7uuacgOWwj+WMheWbtOebkuiZmue6v1xyXG4gICAgICAgIHZhciBwb2ludHMgPSBbXTtcclxuICAgICAgICBwb2ludHNbMF0gPVstYm91bmRpbmdSZWN0LndpZHRoLzIsLWJvdW5kaW5nUmVjdC5oZWlnaHQvMl07XHJcbiAgICAgICAgcG9pbnRzWzFdID1bYm91bmRpbmdSZWN0LndpZHRoLzIsLWJvdW5kaW5nUmVjdC5oZWlnaHQvMl07XHJcbiAgICAgICAgcG9pbnRzWzJdID1bYm91bmRpbmdSZWN0LndpZHRoLzIsYm91bmRpbmdSZWN0LmhlaWdodC8yXTtcclxuICAgICAgICBwb2ludHNbM10gPVstYm91bmRpbmdSZWN0LndpZHRoLzIsYm91bmRpbmdSZWN0LmhlaWdodC8yXTtcclxuICAgICAgICBwb2ludHNbNF0gPVstYm91bmRpbmdSZWN0LndpZHRoLzIsLWJvdW5kaW5nUmVjdC5oZWlnaHQvMl07XHJcblxyXG4gICAgICAgIC8v5rOoOiDlm6Dkuovku7bkuLrlnIblvaIgIOaJgOS7pSB4IHkg5Li65ZyG5b+D55qE5L2N572uICDljIXlm7Tnn6nlvaLopoHlh4/ljrvlrr3luqbkuIDljYpcclxuICAgICAgICB2YXIgYm91bmRSZWN0ID0gbmV3IEJvdW5kaW5nUmVjdCh0aGlzLnBvc2l0aW9uWzBdIC0gYm91bmRpbmdSZWN0LndpZHRoLzIgLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucG9zaXRpb25bMV0gLSBib3VuZGluZ1JlY3QuaGVpZ2h0LzIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm91bmRpbmdSZWN0LndpZHRoLCBib3VuZGluZ1JlY3QuaGVpZ2h0KTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB4OiB0aGlzLnBvc2l0aW9uWzBdLFxyXG4gICAgICAgICAgICB5OiB0aGlzLnBvc2l0aW9uWzFdLFxyXG4gICAgICAgICAgICB3aWR0aDogYm91bmRpbmdSZWN0LndpZHRoLzIsXHJcbiAgICAgICAgICAgIGhlaWdodDogYm91bmRpbmdSZWN0LmhlaWdodC8yLFxyXG4gICAgICAgICAgICBwb2ludHM6IHBvaW50cyxcclxuICAgICAgICAgICAgYm91bmRpbmdSZWN0OiBib3VuZFJlY3RcclxuICAgICAgICB9O1xyXG5cclxuICAgIH07XHJcbiAgICBFdmVudE5vZGUucHJvdG90eXBlLnNldFBvc2l0aW9uID0gZnVuY3Rpb24ocFgscFkpIHtcclxuICAgICAgICAvLyBib2R5Li4uXHJcbiAgICAgICAgdGhpcy5hdHRyKCdwb3NpdGlvbicsW3BYLHBZXSk7XHJcbiAgICB9O1xyXG5cclxuICAgIEV2ZW50Tm9kZS5wcm90b3R5cGUuZ2V0Qm91bmRpbmdSZWN0ID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIGNpcmNsZSA9IHRoaXMuY2hpbGRPZk5hbWUoXCJDaXJjbGVcIik7XHJcbiAgICAgICAgcmV0dXJuIGNpcmNsZS5nZXRCb3VuZGluZ1JlY3QoKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIHpyVXRpbC5pbmhlcml0cyhFdmVudE5vZGUsQlBNTk5vZGUpO1xyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBFdmVudE5vZGU7XHJcblxyXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vbGliL2Zpc2gtdG9wby1icG1uL2xpYi9ub2RlL2V2ZW50L0V2ZW50Tm9kZS5qc1xuICoqIG1vZHVsZSBpZCA9IDgxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcclxuXHR2YXIgRXZlbnROb2RlID0gcmVxdWlyZShcIi4vRXZlbnROb2RlXCIpO1xyXG5cdHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcclxuICAgIHZhciB1dGlsID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uL2Zpc2gtdG9wby1jb3JlL2xpYi91dGlsLmpzXCIpO1xyXG4gICAgdmFyIGdyYXBoaWMgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vZmlzaC10b3BvLWNvcmUvbGliL2dyYXBoaWMuanNcIik7XHJcblxyXG4vKipcclxuPGcgcG9pbnRlci1ldmVudHM9XCJmaWxsXCIgaWQ9XCJzaWQtMzlFRjA0NUUtNjZCNS00NDlELUIzMDAtNUNCQ0U0RDY2OThFXCIgdGl0bGU9XCJJbnRlcm1lZGlhdGUgc2lnbmFsIGNhdGNoaW5nIGV2ZW50XCI+XHJcbiAgPGNpcmNsZSBpZD1cInNpZC0zOUVGMDQ1RS02NkI1LTQ0OUQtQjMwMC01Q0JDRTRENjY5OEViZ19mcmFtZVwiIGN4PVwiMTVcIiBjeT1cIjE1XCIgcj1cIjE1XCIgZmlsbD1cIiNEMDAxMUJcIj48L2NpcmNsZT5cclxuICA8cmVjdCBpZD1cInNpZC0zOUVGMDQ1RS02NkI1LTQ0OUQtQjMwMC01Q0JDRTRENjY5OEViZ19yZWN0XCIgZmlsbD1cIiNGRkZGRkZcIiB4PVwiOVwiIHk9XCI5XCIgd2lkdGg9XCIxMlwiIGhlaWdodD1cIjEyXCI+PC9yZWN0PlxyXG48L2c+XHJcbiAqL1xyXG5cclxuXHRmdW5jdGlvbiBFbmRFdmVudE5vZGUobW9kZWwsIGFwaSkge1xyXG5cdFx0RXZlbnROb2RlLmNhbGwodGhpcyxtb2RlbCwgYXBpKTtcclxuICAgICAgICB0aGlzLmJwbW5UeXBlID0gXCJFbmROb25lRXZlbnRcIjtcclxuICAgICAgICB0aGlzLml0ZW1TaXplID0gMjA7XHJcbiAgICAgICAgdGhpcy5yZWN0U2l6ZSA9IDEyO1xyXG5cdFx0dGhpcy5icG1uSW5mbyA9IHt0eXBlOiAzMSwgbmFtZTpcIkVuZE5vbmVFdmVudFwiIH07ICAgIC8v6IqC54K55L+h5oGvXHJcbiAgICAgICAgdGhpcy5yZW5kZXIobW9kZWwpO1xyXG5cdH1cclxuXHJcbiAgICBFbmRFdmVudE5vZGUucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uKG1vZGVsKSB7XHJcbiAgICAgICAgdGhpcy5tb2RlbCA9IG1vZGVsO1xyXG4gICAgICAgIHZhciBjaXJjbGUgPSBuZXcgZ3JhcGhpYy5DaXJjbGUoe1xyXG4gICAgICAgICAgICBzaGFwZToge1xyXG4gICAgICAgICAgICAgICAgY3g6IDAsXHJcbiAgICAgICAgICAgICAgICBjeTogMCxcclxuICAgICAgICAgICAgICAgIHI6IHRoaXMuaXRlbVNpemVcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgIGZpbGw6ICcjRDAwMTFCJ1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB6OjJcclxuICAgICAgICB9KTtcclxuICAgICAgICBjaXJjbGUubmFtZSA9IFwiQ2lyY2xlXCI7XHJcbiAgICAgICAgdGhpcy5hZGQoY2lyY2xlKTtcclxuICAgICAgICB2YXIgcmVjdCA9IG5ldyBncmFwaGljLlJlY3Qoe1xyXG4gICAgICAgICAgICBzaGFwZToge1xyXG4gICAgICAgICAgICAgICAgeDogLXRoaXMucmVjdFNpemUvMixcclxuICAgICAgICAgICAgICAgIHk6IC10aGlzLnJlY3RTaXplLzIsXHJcbiAgICAgICAgICAgICAgICB3aWR0aDogdGhpcy5yZWN0U2l6ZSxcclxuICAgICAgICAgICAgICAgIGhlaWdodDogdGhpcy5yZWN0U2l6ZVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBzdHlsZToge1xyXG4gICAgICAgICAgICAgICAgZmlsbDogJyNGRkZGRkYnXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHo6MlxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuYWRkKHJlY3QpO1xyXG4gICAgICAgIHZhciBpdGVtU2l6ZSA9IHRoaXMuaXRlbVNpemUqMjtcclxuICAgICAgICB0aGlzLnBvc2l0aW9uID0gW21vZGVsLmdldChcImJvdW5kcy51cHBlckxlZnQueFwiKStpdGVtU2l6ZS8yICwgbW9kZWwuZ2V0KFwiYm91bmRzLnVwcGVyTGVmdC55XCIpK2l0ZW1TaXplLzJdO1xyXG4gICAgICAgIHZhciB0aXRsZSA9IHRoaXMuZHJhd1RleHQobW9kZWwuZ2V0KFwicHJvcGVydGllcy5uYW1lXCIpKTtcclxuICAgICAgICB0aXRsZS50ZXh0Lm5hbWUgPSBcIlRpdGxlXCI7XHJcbiAgICAgICAgdGhpcy5hZGQodGl0bGUudGV4dCk7XHJcbiAgICB9O1xyXG5cclxuXHR6clV0aWwuaW5oZXJpdHMoRW5kRXZlbnROb2RlLCBFdmVudE5vZGUpO1xyXG5cdG1vZHVsZS5leHBvcnRzID0gRW5kRXZlbnROb2RlO1xyXG5cclxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2xpYi9maXNoLXRvcG8tYnBtbi9saWIvbm9kZS9ldmVudC9FbmRFdmVudE5vZGUuanNcbiAqKiBtb2R1bGUgaWQgPSA4MlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXHJcblx0dmFyIFRhc2tOb2RlID0gcmVxdWlyZShcIi4vVGFza05vZGUuanNcIik7XHJcblx0dmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xyXG4gICAgdmFyIGdyYXBoaWMgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vZmlzaC10b3BvLWNvcmUvbGliL2dyYXBoaWMuanNcIik7XHJcbi8qKlxyXG4gKlxyXG4gKiA8ZyBwb2ludGVyLWV2ZW50cz1cImZpbGxcIiBtaW5pbXVtU2l6ZT1cIjg1IDU1XCIgaWQ9XCJzaWQtOEExQ0RBMjEtOUNEMC00OEVDLUI0OUQtNjQ0NzRFRURFRjZEXCIgdGl0bGU9XCJVc2VyIHRhc2tcIj5cclxuICogICA8cmVjdCBpZD1cInNpZC04QTFDREEyMS05Q0QwLTQ4RUMtQjQ5RC02NDQ3NEVFREVGNkR0ZXh0X2ZyYW1lXCIgYW5jaG9ycz1cImJvdHRvbSB0b3AgcmlnaHQgbGVmdFwiIHg9XCIxLjAwMDAwMDA1OTgzNzc1NVwiIHk9XCIxLjAxNjIwMjQ5MjRcIiB3aWR0aD1cIjcyXCIgaGVpZ2h0PVwiMjIuMDAwMDAwMDAwMDAwMDA0XCIgcng9XCI3XCIgcnk9XCI3XCIgc3Ryb2tlPVwibm9uZVwiIHN0cm9rZS13aWR0aD1cIjBcIiBmaWxsPVwibm9uZVwiPlxyXG4gKiAgIDwvcmVjdD5cclxuICogICA8cmVjdCBpZD1cInNpZC04QTFDREEyMS05Q0QwLTQ4RUMtQjQ5RC02NDQ3NEVFREVGNkRiZ19mcmFtZVwiIHJlc2l6ZT1cInZlcnRpY2FsIGhvcml6b250YWxcIiB4PVwiNS45ODM3NzU0OWUtOFwiIHk9XCIwLjAxNjIwMjQ5MjRcIiB3aWR0aD1cIjg1XCIgaGVpZ2h0PVwiNTVcIiByeD1cIjdcIiByeT1cIjdcIiBzdHJva2U9XCIjYmJiYmJiXCIgc3Ryb2tlLXdpZHRoPVwiMVwiIGZpbGw9XCIjZjlmOWY5XCI+XHJcbiAqICAgPC9yZWN0PlxyXG4gKiAgIDxyZWN0IHhtbG5zOm9yeXg9XCJodHRwOi8vd3d3LmIzbW4ub3JnL29yeXhcIiB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgaWQ9XCJzaWQtOEExQ0RBMjEtOUNEMC00OEVDLUI0OUQtNjQ0NzRFRURFRjZEYXJlYV9zdGF0ZVwiIGFuY2hvcnM9XCJib3R0b21cIiB4PVwiNS45ODM3NzU0OWUtOFwiIHk9XCI0NS4wMTYyMDI0OTI0XCIgd2lkdGg9XCI4NVwiIGhlaWdodD1cIjEwXCIgcng9XCIxMFwiIHJ5PVwiMTBcIiByZXNpemU9XCJob3Jpem9udGFsXCIgc3Ryb2tlPVwibm9uZVwiIHN0cm9rZS13aWR0aD1cIjBcIiBmaWxsPVwibm9uZVwiIHN0eWxlPVwiXCI+XHJcbiAqICAgPC9yZWN0PlxyXG4gKiAgIDx0ZXh0IHhtbG5zOm9yeXg9XCJodHRwOi8vd3d3LmIzbW4ub3JnL29yeXhcIiB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgZm9udC1zaXplPVwiMTJcIiBpZD1cInNpZC04QTFDREEyMS05Q0QwLTQ4RUMtQjQ5RC02NDQ3NEVFREVGNkR0ZXh0X25hbWVcIiB4PVwiNTJcIiB5PVwiMzVcIiBhbGlnbj1cIm1pZGRsZSBjZW50ZXJcIiBmaXR0b2VsZW09XCJ0ZXh0X2ZyYW1lXCIgc3Ryb2tlPVwiIzM3M2U0OFwiIHN0cm9rZS13aWR0aD1cIjBwdFwiIGxldHRlci1zcGFjaW5nPVwiLTAuMDFweFwiIHRyYW5zZm9ybT1cInJvdGF0ZSgwIDUyIDM1KVwiIG9yeXg6Zm9udFNpemU9XCIxMlwiIHRleHQtYW5jaG9yPVwibWlkZGxlXCI+XHJcbiAqICAgICAgIDx0c3BhbiB4PVwiNTJcIiB5PVwiMzVcIiBkeT1cIjVcIj5UYXNrXHJcbiAqICAgICAgIDwvdHNwYW4+XHJcbiAqICAgPC90ZXh0PlxyXG4gKiAgIDxnIGlkPVwic2lkLThBMUNEQTIxLTlDRDAtNDhFQy1CNDlELTY0NDc0RUVERUY2RHVzZXJUYXNrXCIgdHJhbnNmb3JtPVwidHJhbnNsYXRlKDUuMDAwMDAwLCA1LjAwMDAwMClcIiBmaWxsPVwiIzQ5OTBFMlwiPlxyXG4gKiAgICAgICA8cGF0aCBhbmNob3JzPVwidG9wIGxlZnRcIiBkPVwiIE00LjY4OTc1NDc0OTgzNzc1NSAwLjc1NDc0OTcyMTQwMDAwMDEgIEMzLjEyNDkwODYzOTgzNzc1NSAxLjUwOTQ5OTQ0MjQgMi41MzY5MDI5ODk4Mzc3NTUgMi44MzU5NDA0NTI0IDMuMDM4ODUzMjk5ODM3NzU0NyA1LjM4NzgxOTQ3MjM5OTk5OTUgIEMzLjU0MDgwMzU5OTgzNzc1NSA3LjkzOTY5ODUwMjQgNC4yNTY4NTQzNzk4Mzc3NTYgNy45NzI5MjE4MTI0IDQuNjg5NzU0NzQ5ODM3NzU1IDguOTIwNzYyNTkyNCAgQzUuMTIyNjU1MTE5ODM3NzU1IDkuODY4NjAzMzcyMzk5OTk5IDQuODM0MDU0ODg5ODM3NzU1NiAxMC42NzA2MjI0OTI0IDMuODIzOTUzODc5ODM3NzU0NiAxMS4xMDgwODc0OTI0ICBDMi44MTM4NTI4Nzk4Mzc3NTUgMTEuNTQ1NTUyNDkyNCAxLjE5Njc1NTA5NDk5OTk5OTllLTcgMTIuODU3OTQ3MzkyNCA1Ljk4Mzc3NTQ5ZS04IDEzLjU4NzA1NTY5MjQgIEMwIDE0LjMxNjE2Mzk5MjQgMS4yMjY1NTEyODk4Mzc3NTUgMTQuMjQzMjUzMDkyNCAyLjMwODgwMjM2OTgzNzc1NDcgMTQuMjQzMjUzMDkyNCAgQzMuMzkxMDUzNDQ5ODM3NzU1IDE0LjI0MzI1MzA5MjQgOS4wOTA5MDkxNDk4Mzc3NTUgMTQuMjQzMjUzMDkyNCA5LjA5MDkwOTE0OTgzNzc1NSAxNC4yNDMyNTMwOTI0ICBMOS4xNjMwNTkyMTk4Mzc3NTQgMC41MjM3NzA0ODA0MDAwMDAxICBDOS4xNjMwNTkyMTk4Mzc3NTQgMC41MjM3NzA0ODA0MDAwMDAxIDYuMjU0NjAwODU5ODM3NzU2IDAgNC42ODk3NTQ3NDk4Mzc3NTUgMC43NTQ3NDk3MjE0MDAwMDAxICB6XCIgaWQ9XCJzaWQtOEExQ0RBMjEtOUNEMC00OEVDLUI0OUQtNjQ0NzRFRURFRjZEUGF0aC0xNFwiPlxyXG4gKiAgICAgICA8L3BhdGg+XHJcbiAqICAgICAgIDxwYXRoIGFuY2hvcnM9XCJ0b3AgbGVmdFwiIGQ9XCIgTTkuNTk1OTU5NjU5ODM3NzU3IDAuNzU0NzQ5NzIxNDAwMDAwMSAgQzExLjE2MDgwNTc1OTgzNzc1MyAxLjUwOTQ5OTQ0MjQgMTEuNTc2NTE3ODU5ODM3NzU0IDIuNzQ2NjU0NjgyNCAxMS4wNzQ1Njc1NTk4Mzc3NTcgNS4yOTg1MzM3MDIzOTk5OTkgIEMxMC41NzI2MTcyNTk4Mzc3NTYgNy44NTA0MTI3MzI0IDEwLjAyODg2MDA1OTgzNzc1NCA3Ljk3MjkyMTgxMjQgOS41OTU5NTk2NTk4Mzc3NTcgOC45MjA3NjI1OTI0ICBDOS4xNjMwNTkyNzk4Mzc3NTMgOS44Njg2MDMzNzIzOTk5OTkgOS40NTE2NTk1MTk4Mzc3NTQgMTAuNjcwNjIyNDkyNCAxMC40NjE3NjA1NTk4Mzc3NTcgMTEuMTA4MDg3NDkyNCAgQzExLjQ3MTg2MTU1OTgzNzc1NSAxMS41NDU1NTI0OTI0IDE0LjI4NTcxNDI1OTgzNzc1NSAxMi44NTc5NDczOTI0IDE0LjI4NTcxNDM1OTgzNzc1NyAxMy41ODcwNTU2OTI0ICBDMTQuMjg1NzE0MzU5ODM3NzU3IDE0LjMxNjE2Mzk5MjQgMTMuMDU5MTYzMTU5ODM3NzU1IDE0LjI0MzI1MzA5MjQgMTEuOTc2OTEyMDU5ODM3NzU1IDE0LjI0MzI1MzA5MjQgIEMxMC44OTQ2NjA5NTk4Mzc3NTQgMTQuMjQzMjUzMDkyNCA2LjM0OTIwNjQwOTgzNzc1NSAxNC4yNDMyNTMwOTI0IDYuMzQ5MjA2NDA5ODM3NzU1IDE0LjI0MzI1MzA5MjQgIEw2LjE1MjA2MTk2OTgzNzc1NSAwLjQyOTkyNjI2OTQgIEM2LjE1MjA2MTk2OTgzNzc1NSAwLjQyOTkyNjI2OTQgOC4wMzExMTM1NDk4Mzc3NTUgMCA5LjU5NTk1OTY1OTgzNzc1NyAwLjc1NDc0OTcyMTQwMDAwMDEgIHpcIiBpZD1cInNpZC04QTFDREEyMS05Q0QwLTQ4RUMtQjQ5RC02NDQ3NEVFREVGNkRQYXRoLTE0LUNvcHlcIj5cclxuICogICAgICAgPC9wYXRoPlxyXG4gKiAgIDwvZz5cclxuICogPC9nPlxyXG4gKi9cclxuXHJcbiAgICBmdW5jdGlvbiBVc2VyVGFza05vZGUobW9kZWwsYXBpKSB7XHJcbiAgICAgICAgVGFza05vZGUuY2FsbCh0aGlzLG1vZGVsLCBhcGkpO1xyXG4gICAgICAgIHRoaXMucmVjdFNpemUgPSB7d2lkdGg6MTAwLCBoZWlnaHQ6NjB9O1xyXG4gICAgICAgIHRoaXMuaWNvblBhdGggPSBcIk03NjUuNTczNzQxIDcxOC40ODk4ODhjLTE0Ljk5OTYyMi0xMTIuNjU5ODczLTExOS42NzE1NjctMTk2LjQzODk3NC0yMzcuNzc2NDUyLTE5Ni40Mzg5NzQtMTE4LjkxMjI3MyAwLTIyMC41MTQyOTkgODUuMjc3MjIyLTIzOC4yMDMxNyAxOTguNzcwMDY2LTExLjg0MDY3NiA3Ni4wNzE1NTkgNTQuNTg1MTk5IDcxLjMyNjQ4OSA1NC41ODUxOTkgNzEuMzI2NDg5bDM2MC43MzQ4NzggMEM3MDQuOTEzMTczIDc5Mi4xNDg0OTEgNzc2LjYwODA1MiA4MDEuMzY0Mzg3IDc2NS41NzM3NDEgNzE4LjQ4OTg4OHpNNjkwLjI0OTE5NSAzNjUuNzE4Mzc5YzAgODkuOTExNzc2LTcyLjg4OTA3NyAxNjIuODEwMDYzLTE2Mi43OTY3NiAxNjIuODEwMDYzLTg5LjkwODcwNiAwLTE2Mi43OTc3ODMtNzIuODk4Mjg3LTE2Mi43OTc3ODMtMTYyLjgxMDA2MyAwLTg5LjkxNjg5MiA3Mi44ODkwNzctMTYyLjgwNTk3IDE2Mi43OTc3ODMtMTYyLjgwNTk3QzYxNy4zNjAxMTggMjAyLjkxMjQwOSA2OTAuMjQ5MTk1IDI3NS44MDE0ODcgNjkwLjI0OTE5NSAzNjUuNzE4Mzc5elwiO1xyXG4gICAgICAgIHRoaXMuYnBtbkluZm8gPSB7dHlwZTogMCwgbmFtZTpcIlVzZXJUYXNrXCIgfTsgICAgLy/oioLngrnkv6Hmga9cclxuICAgICAgICB0aGlzLnJlbmRlcihtb2RlbCk7XHJcbiAgICB9XHJcblxyXG4gICAgVXNlclRhc2tOb2RlLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbihtb2RlbCkge1xyXG4gICAgICAgIHZhciByZWN0ID0gbmV3IGdyYXBoaWMuUmVjdCh7XHJcbiAgICAgICAgICAgIHNoYXBlOiB7XHJcbiAgICAgICAgICAgICAgICB4OiAwLjUsXHJcbiAgICAgICAgICAgICAgICB5OiAwLjUsXHJcbiAgICAgICAgICAgICAgICB3aWR0aDogdGhpcy5yZWN0U2l6ZS53aWR0aC0xLFxyXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLnJlY3RTaXplLmhlaWdodC0xLFxyXG4gICAgICAgICAgICAgICAgcjogN1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBzdHlsZToge1xyXG5cclxuICAgICAgICAgICAgICAgIGZpbGw6ICcjZjlmOWY5JyxcclxuICAgICAgICAgICAgICAgIHN0cm9rZTogJyNiYmJiYmInXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHo6MlxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJlY3QubmFtZSA9IFwiUmVjdFwiO1xyXG4gICAgICAgIHRoaXMuYWRkKHJlY3QpO1xyXG5cclxuICAgICAgICB2YXIgaWNvblJlY3QgPSB7eDo1LCB5OiA1LCB3aWR0aDogMTUsIGhlaWdodDoxNX07XHJcbiAgICAgICAgdmFyIHBhdGhJY29uID0gZ3JhcGhpYy5tYWtlUGF0aCh0aGlzLmljb25QYXRoLCB7c3R5bGU6IHtmaWxsOiAnIzQ5OTBFMid9LHo6Mn0sIGljb25SZWN0KTtcclxuICAgICAgICB0aGlzLmFkZChwYXRoSWNvbik7XHJcbiAgICAgICAvLyB0aGlzLmFkZChncmFwaGljLm1ha2VQYXRoKHRoaXMuaWNvblBhdGgyLCB7c3R5bGU6IHtmaWxsOiAnIzQ5OTBFMid9fSwgcmVjdCxcImNlbnRlclwiKSk7XHJcbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9ICBbbW9kZWwuZ2V0KFwiYm91bmRzLnVwcGVyTGVmdC54XCIpLCBtb2RlbC5nZXQoXCJib3VuZHMudXBwZXJMZWZ0LnlcIildO1xyXG4gICAgICAgIHZhciB0aXRsZSA9IHRoaXMuZHJhd1RleHQobW9kZWwuZ2V0KFwicHJvcGVydGllcy5uYW1lXCIpKTtcclxuICAgICAgICB0aXRsZS50ZXh0Lm5hbWUgPSBcIlRpdGxlXCI7XHJcbiAgICAgICAgdGhpcy5hZGQodGl0bGUudGV4dCk7XHJcbiAgICB9O1xyXG5cclxuXHJcblxyXG5cdHpyVXRpbC5pbmhlcml0cyhVc2VyVGFza05vZGUsVGFza05vZGUpO1xyXG5cdG1vZHVsZS5leHBvcnRzID0gVXNlclRhc2tOb2RlO1xyXG5cclxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2xpYi9maXNoLXRvcG8tYnBtbi9saWIvbm9kZS90YXNrL1VzZXJUYXNrTm9kZS5qc1xuICoqIG1vZHVsZSBpZCA9IDgzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcclxuXHR2YXIgQlBNTk5vZGUgPSByZXF1aXJlKFwiLi4vQlBNTk5vZGVcIik7XHJcblx0dmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xyXG4gICAgdmFyIEJvdW5kaW5nUmVjdCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvQm91bmRpbmdSZWN0LmpzJyk7XHJcblx0Ly/liJvlu7pOb2Rl57G7IOaJgOacieW9oueKtumDvee7p+aJv05vZGVcclxuXHQvL1xyXG5cdGZ1bmN0aW9uIFRhc2tOb2RlKG1vZGVsLCBhcGkpIHtcclxuXHJcblx0XHRCUE1OTm9kZS5jYWxsKHRoaXMsIG1vZGVsLCBhcGkpO1xyXG5cdFx0dGhpcy5icG1uSW5mbyA9IHt0eXBlOiAtMSwgbmFtZTpcIlRhc2tOb2RlXCIgfTsgICAgLy/oioLngrnkv6Hmga9cclxuICAgICAgICB0aGlzLm1vZGVsID0gbW9kZWw7XHJcbiAgICAgICAgdGhpcy5zbG90ID0gW107XHJcbiAgICAgICAgdGhpcy5zbG90RXZlbnQgPSBbXTtcclxuICAgICAgICB0aGlzLmlzQ2FuU2xvdCA9IHRydWU7ICAvL+eUqOS6juaOp+WItuacrOiKgueCueaYr+WQpuWPr+S7peiiq+aPkuanvVxyXG5cdH1cclxuXHJcbiAgICBUYXNrTm9kZS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICBUYXNrTm9kZS5wcm90b3R5cGUuZ2V0UmVjdCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBib3VuZGluZ1JlY3QgPSB0aGlzLmdldEJvdW5kaW5nUmVjdCgpO1xyXG4gICAgICAgIC8v5Yib5bu65pyA5bCP5YyF5Zu055uS6Jma57q/XHJcbiAgICAgICAgdmFyIHBvaW50cyA9IFtdO1xyXG4gICAgICAgIHBvaW50c1swXSA9Wy1ib3VuZGluZ1JlY3Qud2lkdGgvMiwtYm91bmRpbmdSZWN0LmhlaWdodC8yXTtcclxuICAgICAgICBwb2ludHNbMV0gPVtib3VuZGluZ1JlY3Qud2lkdGgvMiwtYm91bmRpbmdSZWN0LmhlaWdodC8yXTtcclxuICAgICAgICBwb2ludHNbMl0gPVtib3VuZGluZ1JlY3Qud2lkdGgvMixib3VuZGluZ1JlY3QuaGVpZ2h0LzJdO1xyXG4gICAgICAgIHBvaW50c1szXSA9Wy1ib3VuZGluZ1JlY3Qud2lkdGgvMixib3VuZGluZ1JlY3QuaGVpZ2h0LzJdO1xyXG4gICAgICAgIHBvaW50c1s0XSA9Wy1ib3VuZGluZ1JlY3Qud2lkdGgvMiwtYm91bmRpbmdSZWN0LmhlaWdodC8yXTtcclxuXHJcbiAgICAgICAgdmFyIGJvdW5kUmVjdCA9IG5ldyBCb3VuZGluZ1JlY3QodGhpcy5wb3NpdGlvblswXSAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wb3NpdGlvblsxXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3VuZGluZ1JlY3Qud2lkdGgsIGJvdW5kaW5nUmVjdC5oZWlnaHQpO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHg6IHRoaXMucG9zaXRpb25bMF0rYm91bmRpbmdSZWN0LndpZHRoLzIsXHJcbiAgICAgICAgICAgIHk6IHRoaXMucG9zaXRpb25bMV0rYm91bmRpbmdSZWN0LmhlaWdodC8yLFxyXG4gICAgICAgICAgICB3aWR0aDogYm91bmRpbmdSZWN0LndpZHRoLFxyXG4gICAgICAgICAgICBoZWlnaHQ6IGJvdW5kaW5nUmVjdC5oZWlnaHQsXHJcbiAgICAgICAgICAgIHBvaW50czogcG9pbnRzLFxyXG4gICAgICAgICAgICBib3VuZGluZ1JlY3Q6IGJvdW5kUmVjdFxyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG5cclxuICAgIFRhc2tOb2RlLnByb3RvdHlwZS5nZXRCb3VuZGluZ1JlY3QgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgcmVjdCA9IHRoaXMuY2hpbGRPZk5hbWUoXCJSZWN0XCIpO1xyXG4gICAgICAgIHJldHVybiByZWN0LmdldEJvdW5kaW5nUmVjdCgpO1xyXG4gICAgfTtcclxuXHJcbiAgICBUYXNrTm9kZS5wcm90b3R5cGUuc2V0UG9zaXRpb24gPSBmdW5jdGlvbihwWCxwWSkge1xyXG4gICAgICAgIHZhciBib3VuZGluZ1JlY3QgPSB0aGlzLmdldEJvdW5kaW5nUmVjdCgpO1xyXG4gICAgICAgIHRoaXMuYXR0cigncG9zaXRpb24nLFtwWC1ib3VuZGluZ1JlY3Qud2lkdGgvMixwWS1ib3VuZGluZ1JlY3QuaGVpZ2h0LzJdKTtcclxuXHJcbiAgICB9O1xyXG5cclxuXHR6clV0aWwuaW5oZXJpdHMoVGFza05vZGUsQlBNTk5vZGUpO1xyXG5cdG1vZHVsZS5leHBvcnRzID0gVGFza05vZGU7XHJcblxyXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vbGliL2Zpc2gtdG9wby1icG1uL2xpYi9ub2RlL3Rhc2svVGFza05vZGUuanNcbiAqKiBtb2R1bGUgaWQgPSA4NFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy9NYW51YWxUYXNr6IqC54K5XHJcblxyXG5cdHZhciBUYXNrTm9kZSA9IHJlcXVpcmUoXCIuL1Rhc2tOb2RlLmpzXCIpO1xyXG5cdHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcclxuICAgIHZhciBncmFwaGljID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uL2Zpc2gtdG9wby1jb3JlL2xpYi9ncmFwaGljLmpzXCIpO1xyXG4vKipcclxuICpcclxuICogIDxnIHBvaW50ZXItZXZlbnRzPVwiZmlsbFwiIG1pbmltdW1TaXplPVwiODIgNDJcIiBpZD1cInNpZC1BOTU0NTIyNC00Q0FFLTQ1MEQtODkzRC0xMkNGQTdFNjg4MjVcIiB0aXRsZT1cIk1hbnVhbCB0YXNrXCI+XHJcbiAqICAgICA8cmVjdCBpZD1cInNpZC1BOTU0NTIyNC00Q0FFLTQ1MEQtODkzRC0xMkNGQTdFNjg4MjV0ZXh0X2ZyYW1lXCIgYW5jaG9ycz1cImJvdHRvbSB0b3AgcmlnaHQgbGVmdFwiIHg9XCIxXCIgeT1cIjFcIiB3aWR0aD1cIjc0XCIgaGVpZ2h0PVwiMzlcIiByeD1cIjEwXCIgcnk9XCIxMFwiIHN0cm9rZT1cIm5vbmVcIiBzdHJva2Utd2lkdGg9XCIwXCIgZmlsbD1cIm5vbmVcIj48L3JlY3Q+XHJcbiAqICAgICA8cmVjdCBpZD1cInNpZC1BOTU0NTIyNC00Q0FFLTQ1MEQtODkzRC0xMkNGQTdFNjg4MjViZ19mcmFtZVwiIHJlc2l6ZT1cInZlcnRpY2FsIGhvcml6b250YWxcIiB4PVwiMFwiIHk9XCIwXCIgd2lkdGg9XCI4MFwiIGhlaWdodD1cIjQwXCIgcng9XCIxMFwiIHJ5PVwiMTBcIiBzdHJva2U9XCIjYmJiYmJiXCIgc3Ryb2tlLXdpZHRoPVwiMVwiIGZpbGw9XCIjZjlmOWY5XCI+PC9yZWN0PlxyXG4gKiAgICAgPHJlY3QgeG1sbnM6b3J5eD1cImh0dHA6Ly93d3cuYjNtbi5vcmcvb3J5eFwiIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiBpZD1cInNpZC1BOTU0NTIyNC00Q0FFLTQ1MEQtODkzRC0xMkNGQTdFNjg4MjVhcmVhX3N0YXRlXCIgYW5jaG9ycz1cImJvdHRvbVwiIHg9XCIwXCIgeT1cIjMwXCIgd2lkdGg9XCI4MFwiIGhlaWdodD1cIjEwXCIgcng9XCIxMFwiIHJ5PVwiMTBcIiByZXNpemU9XCJob3Jpem9udGFsXCIgc3Ryb2tlPVwibm9uZVwiIHN0cm9rZS13aWR0aD1cIjBcIiBmaWxsPVwibm9uZVwiIHN0eWxlPVwiXCI+PC9yZWN0PlxyXG4gKiAgICAgPHRleHQgeG1sbnM6b3J5eD1cImh0dHA6Ly93d3cuYjNtbi5vcmcvb3J5eFwiIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiBmb250LXNpemU9XCIxMlwiIGlkPVwic2lkLUE5NTQ1MjI0LTRDQUUtNDUwRC04OTNELTEyQ0ZBN0U2ODgyNXRleHRfbmFtZVwiIHg9XCI0M1wiIHk9XCIyNFwiIGFsaWduPVwibWlkZGxlIGNlbnRlclwiIGZpdHRvZWxlbT1cInRleHRfZnJhbWVcIiBzdHJva2U9XCIjMzczZTQ4XCIgc3Ryb2tlLXdpZHRoPVwiMHB0XCIgbGV0dGVyLXNwYWNpbmc9XCItMC4wMXB4XCIgdHJhbnNmb3JtPVwicm90YXRlKDAgNDMgMjQpXCIgb3J5eDpmb250U2l6ZT1cIjEyXCIgdGV4dC1hbmNob3I9XCJtaWRkbGVcIj48dHNwYW4geD1cIjQzXCIgeT1cIjI0XCIgZHk9XCI1XCI+VGFzazwvdHNwYW4+PC90ZXh0PlxyXG4gKiAgICAgPGcgaWQ9XCJzaWQtQTk1NDUyMjQtNENBRS00NTBELTg5M0QtMTJDRkE3RTY4ODI1bWFudWFsVGFza1wiIHRyYW5zZm9ybT1cInRyYW5zbGF0ZSgzLDEpIHNjYWxlKDAuOClcIj5cclxuICogICAgIDxwYXRoIGFuY2hvcnM9XCJ0b3AgbGVmdFwiIHN0eWxlPVwiZmlsbDojZDFiNTc1O3N0cm9rZT1ub25lXCIgZD1cIm0gMTcsOS4zMjkwMzI2IGMgLTAuMDA2OSwwLjU1MTI0NjEgLTAuNDU1MTY2LDEuMDQ1NTg5NCAtMC45NDA3NzgsMS4wMzc2NjA0IGwgLTUuNzkyNzQ2LDAgYyAwLjAwNTMsMC4xMTkzODEgMC4wMDI2LDAuMjM3MTA3IDAuMDA2MSwwLjM1NTk2NSBsIDUuMTU0OTE4LDAgYyAwLjQ4MjAzMiwtMC4wMDk2IDAuOTI1NTI5LDAuNDkwNTEgMC45MTk1MjUsMS4wMzc1NzQgLTAuMDA3OCwwLjUzNzEyOCAtMC40NDYyODMsMS4wMTc1MzEgLTAuOTE5NTIxLDEuMDA3NjgzIGwgLTUuMjQ1MjczLDAgYyAtMC4wMTUwNywwLjEwNDQ4NCAtMC4wMzM4OSwwLjIwNDA4MSAtMC4wNTMxNiwwLjMwMTU5MSBsIDIuNjMwMTc1LDAgYyAwLjQ1NDEzNywtMC4wMDk2IDAuODcyMTEyLDAuNDYxNzU0IDAuODY2Mzg2LDAuOTc3MTg2IEMgMTMuNjE5NTI2LDE0LjU1NDEwNiAxMy4yMDYyOTMsMTUuMDA5NDk4IDEyLjc1OTI0LDE1IEwgMy43NzUzMDU0LDE1IEMgMy42MDQ1ODEyLDE1IDMuNDMzNTUyLDE0Ljk0NDIzIDMuMjkxNjM2MywxNC44MzcxMzYgYyAtMC4wMDE3NCwwIC0wLjAwNDM2LDAgLTAuMDA2MDksMCBDIDEuNzIxMjAzNSwxNC4zNjc4MDEgMC45OTk5ODI1NSwxMS40NTg2NDEgMSwxMS40NTg2NDEgTCAxLDcuNDU4ODM5MyBjIDAsMCAwLjY2MjMxNDQsLTEuMzE2MzMzIDEuODM5MDU4MywtMi4wODcyNTg0IDEuMTc2NzYxNCwtMC43NzExODY4IDYuODA1MzM1OCwtMi40MDQ5NyA3LjI1ODc4NDcsLTIuODA1MjkwMSAwLjQ1MzQ4NCwtMC40MDAzMiAxLjY2MDIxMywxLjQ4NTk5NDIgMC4wNDc3NSwyLjQwMTA0ODcgQyA4LjUzMzIzMTUsNS44ODIzOTQgOC41MDczNTEsNS43OTk2MTEzIDguNDM3MDI5Miw1Ljc5MzY4NTkgbCA2LjM1Njk3NDgsLTAuMDA4NzEgYyAwLjQ5NzA0NiwtMC4wMDk1OCAwLjk1MjI3MywwLjUwOTc2NzYgMC45NDYxMiwxLjA3MzgyMzIgLTAuMDA1MywwLjU1NjEyNiAtMC40NTYxNzYsMS4wNTY2NTY2IC0wLjk0NjEyLDEuMDQ5Njg1NCBsIC00LjcyNDM1LDAgYyAwLjAxMzA3LDAuMTE0OTM3NCAwLjAyNDQsMC4yMjgxMzE5IDAuMDM3MjEsMC4zNDk4NjYxIGwgNS45NTIxOTUsMCBjIDAuNDk0NTE3LC0wLjAwODcxIDAuOTQ3OTA2LDAuNTA2NjMwNSAwLjk0MDc5NSwxLjA2Nzk4NDggelwiIGlkPVwic2lkLUE5NTQ1MjI0LTRDQUUtNDUwRC04OTNELTEyQ0ZBN0U2ODgyNV9zaWQtQTk1NDUyMjQtNENBRS00NTBELTg5M0QtMTJDRkE3RTY4ODI1XzE3XCI+PC9wYXRoPlxyXG4gKiAgICAgPC9nPlxyXG4gKiA8L2c+XHJcbiAqL1xyXG4gICAgZnVuY3Rpb24gTWFudWFsVGFza05vZGUobW9kZWwsYXBpKSB7XHJcbiAgICAgICAgVGFza05vZGUuY2FsbCh0aGlzLG1vZGVsLCBhcGkpO1xyXG4gICAgICAgIHRoaXMucmVjdFNpemUgPSB7d2lkdGg6MTAwLCBoZWlnaHQ6NjB9O1xyXG4gICAgICAgIHRoaXMuaWNvblBhdGggPSBcIm0gMTcsOS4zMjkwMzI2IGMgLTAuMDA2OSwwLjU1MTI0NjEgLTAuNDU1MTY2LDEuMDQ1NTg5NCAtMC45NDA3NzgsMS4wMzc2NjA0IGwgLTUuNzkyNzQ2LDAgYyAwLjAwNTMsMC4xMTkzODEgMC4wMDI2LDAuMjM3MTA3IDAuMDA2MSwwLjM1NTk2NSBsIDUuMTU0OTE4LDAgYyAwLjQ4MjAzMiwtMC4wMDk2IDAuOTI1NTI5LDAuNDkwNTEgMC45MTk1MjUsMS4wMzc1NzQgLTAuMDA3OCwwLjUzNzEyOCAtMC40NDYyODMsMS4wMTc1MzEgLTAuOTE5NTIxLDEuMDA3NjgzIGwgLTUuMjQ1MjczLDAgYyAtMC4wMTUwNywwLjEwNDQ4NCAtMC4wMzM4OSwwLjIwNDA4MSAtMC4wNTMxNiwwLjMwMTU5MSBsIDIuNjMwMTc1LDAgYyAwLjQ1NDEzNywtMC4wMDk2IDAuODcyMTEyLDAuNDYxNzU0IDAuODY2Mzg2LDAuOTc3MTg2IEMgMTMuNjE5NTI2LDE0LjU1NDEwNiAxMy4yMDYyOTMsMTUuMDA5NDk4IDEyLjc1OTI0LDE1IEwgMy43NzUzMDU0LDE1IEMgMy42MDQ1ODEyLDE1IDMuNDMzNTUyLDE0Ljk0NDIzIDMuMjkxNjM2MywxNC44MzcxMzYgYyAtMC4wMDE3NCwwIC0wLjAwNDM2LDAgLTAuMDA2MDksMCBDIDEuNzIxMjAzNSwxNC4zNjc4MDEgMC45OTk5ODI1NSwxMS40NTg2NDEgMSwxMS40NTg2NDEgTCAxLDcuNDU4ODM5MyBjIDAsMCAwLjY2MjMxNDQsLTEuMzE2MzMzIDEuODM5MDU4MywtMi4wODcyNTg0IDEuMTc2NzYxNCwtMC43NzExODY4IDYuODA1MzM1OCwtMi40MDQ5NyA3LjI1ODc4NDcsLTIuODA1MjkwMSAwLjQ1MzQ4NCwtMC40MDAzMiAxLjY2MDIxMywxLjQ4NTk5NDIgMC4wNDc3NSwyLjQwMTA0ODcgQyA4LjUzMzIzMTUsNS44ODIzOTQgOC41MDczNTEsNS43OTk2MTEzIDguNDM3MDI5Miw1Ljc5MzY4NTkgbCA2LjM1Njk3NDgsLTAuMDA4NzEgYyAwLjQ5NzA0NiwtMC4wMDk1OCAwLjk1MjI3MywwLjUwOTc2NzYgMC45NDYxMiwxLjA3MzgyMzIgLTAuMDA1MywwLjU1NjEyNiAtMC40NTYxNzYsMS4wNTY2NTY2IC0wLjk0NjEyLDEuMDQ5Njg1NCBsIC00LjcyNDM1LDAgYyAwLjAxMzA3LDAuMTE0OTM3NCAwLjAyNDQsMC4yMjgxMzE5IDAuMDM3MjEsMC4zNDk4NjYxIGwgNS45NTIxOTUsMCBjIDAuNDk0NTE3LC0wLjAwODcxIDAuOTQ3OTA2LDAuNTA2NjMwNSAwLjk0MDc5NSwxLjA2Nzk4NDggelwiO1xyXG4gICAgICAvLyAgdGhpcy5pY29uUGF0aDIgPSBcIk05LjU5NTk1OTY1OTgzNzc1NyAwLjc1NDc0OTcyMTQwMDAwMDEgIEMxMS4xNjA4MDU3NTk4Mzc3NTMgMS41MDk0OTk0NDI0IDExLjU3NjUxNzg1OTgzNzc1NCAyLjc0NjY1NDY4MjQgMTEuMDc0NTY3NTU5ODM3NzU3IDUuMjk4NTMzNzAyMzk5OTk5ICBDMTAuNTcyNjE3MjU5ODM3NzU2IDcuODUwNDEyNzMyNCAxMC4wMjg4NjAwNTk4Mzc3NTQgNy45NzI5MjE4MTI0IDkuNTk1OTU5NjU5ODM3NzU3IDguOTIwNzYyNTkyNCAgQzkuMTYzMDU5Mjc5ODM3NzUzIDkuODY4NjAzMzcyMzk5OTk5IDkuNDUxNjU5NTE5ODM3NzU0IDEwLjY3MDYyMjQ5MjQgMTAuNDYxNzYwNTU5ODM3NzU3IDExLjEwODA4NzQ5MjQgIEMxMS40NzE4NjE1NTk4Mzc3NTUgMTEuNTQ1NTUyNDkyNCAxNC4yODU3MTQyNTk4Mzc3NTUgMTIuODU3OTQ3MzkyNCAxNC4yODU3MTQzNTk4Mzc3NTcgMTMuNTg3MDU1NjkyNCAgQzE0LjI4NTcxNDM1OTgzNzc1NyAxNC4zMTYxNjM5OTI0IDEzLjA1OTE2MzE1OTgzNzc1NSAxNC4yNDMyNTMwOTI0IDExLjk3NjkxMjA1OTgzNzc1NSAxNC4yNDMyNTMwOTI0ICBDMTAuODk0NjYwOTU5ODM3NzU0IDE0LjI0MzI1MzA5MjQgNi4zNDkyMDY0MDk4Mzc3NTUgMTQuMjQzMjUzMDkyNCA2LjM0OTIwNjQwOTgzNzc1NSAxNC4yNDMyNTMwOTI0ICBMNi4xNTIwNjE5Njk4Mzc3NTUgMC40Mjk5MjYyNjk0ICBDNi4xNTIwNjE5Njk4Mzc3NTUgMC40Mjk5MjYyNjk0IDguMDMxMTEzNTQ5ODM3NzU1IDAgOS41OTU5NTk2NTk4Mzc3NTcgMC43NTQ3NDk3MjE0MDAwMDAxICB6XCI7XHJcbiAgICAgICAgdGhpcy5icG1uSW5mbyA9IHt0eXBlOiA0LCBuYW1lOlwiTWFudWFsVGFza1wiIH07ICAgIC8v6IqC54K55L+h5oGvXHJcbiAgICAgICAgdGhpcy5yZW5kZXIobW9kZWwpO1xyXG4gICAgfVxyXG5cclxuICAgIE1hbnVhbFRhc2tOb2RlLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbihtb2RlbCkge1xyXG4gICAgICAgIHZhciByZWN0ID0gbmV3IGdyYXBoaWMuUmVjdCh7XHJcbiAgICAgICAgICAgIHNoYXBlOiB7XHJcbiAgICAgICAgICAgICAgICB4OiAwLjUsXHJcbiAgICAgICAgICAgICAgICB5OiAwLjUsXHJcbiAgICAgICAgICAgICAgICB3aWR0aDogdGhpcy5yZWN0U2l6ZS53aWR0aC0xLFxyXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLnJlY3RTaXplLmhlaWdodC0xLFxyXG4gICAgICAgICAgICAgICAgcjogN1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBzdHlsZToge1xyXG5cclxuICAgICAgICAgICAgICAgIGZpbGw6ICcjZjlmOWY5JyxcclxuICAgICAgICAgICAgICAgIHN0cm9rZTogJyNiYmJiYmInXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHo6MlxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJlY3QubmFtZSA9IFwiUmVjdFwiO1xyXG4gICAgICAgIHRoaXMuYWRkKHJlY3QpO1xyXG5cclxuICAgICAgICB2YXIgaWNvbnJlY3QgPSB7eDo1LCB5OiA1LCB3aWR0aDogMTUsIGhlaWdodDoxNX07XHJcbiAgICAgICAgdGhpcy5hZGQoZ3JhcGhpYy5tYWtlUGF0aCh0aGlzLmljb25QYXRoLCB7c3R5bGU6IHtmaWxsOiAnI2QxYjU3NSd9LHo6Mn0sIGljb25yZWN0KSk7XHJcblxyXG4gICAgICAgLy8gdGhpcy5hZGQoZ3JhcGhpYy5tYWtlUGF0aCh0aGlzLmljb25QYXRoMiwge3N0eWxlOiB7ZmlsbDogJyM0OTkwRTInfX0sIHJlY3QsXCJjZW50ZXJcIikpO1xyXG4gICAgICAgIHRoaXMucG9zaXRpb24gPSAgW21vZGVsLmdldChcImJvdW5kcy51cHBlckxlZnQueFwiKSwgbW9kZWwuZ2V0KFwiYm91bmRzLnVwcGVyTGVmdC55XCIpXTtcclxuICAgICAgICB2YXIgdGl0bGUgPSB0aGlzLmRyYXdUZXh0KG1vZGVsLmdldChcInByb3BlcnRpZXMubmFtZVwiKSk7XHJcbiAgICAgICAgdGl0bGUudGV4dC5uYW1lID0gXCJUaXRsZVwiO1xyXG4gICAgICAgIHRoaXMuYWRkKHRpdGxlLnRleHQpO1xyXG4gICAgfTtcclxuXHJcblx0enJVdGlsLmluaGVyaXRzKE1hbnVhbFRhc2tOb2RlLFRhc2tOb2RlKTtcclxuXHRtb2R1bGUuZXhwb3J0cyA9IE1hbnVhbFRhc2tOb2RlO1xyXG5cclxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2xpYi9maXNoLXRvcG8tYnBtbi9saWIvbm9kZS90YXNrL01hbnVhbFRhc2tOb2RlLmpzXG4gKiogbW9kdWxlIGlkID0gODVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vU2NyaXB0VGFza+iKgueCuVxyXG5cclxuXHR2YXIgVGFza05vZGUgPSByZXF1aXJlKFwiLi9UYXNrTm9kZS5qc1wiKTtcclxuXHR2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XHJcbiAgICB2YXIgZ3JhcGhpYyA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi9maXNoLXRvcG8tY29yZS9saWIvZ3JhcGhpYy5qc1wiKTtcclxuLyoqXHJcbiAqXHJcbiAqICA8ZyBwb2ludGVyLWV2ZW50cz1cImZpbGxcIiBtaW5pbXVtU2l6ZT1cIjgyIDQyXCIgaWQ9XCJzaWQtQjgzREZBOUUtMDA2Ni00MDMyLUE5RTgtQTdGRjE5QzFBQjVEXCIgdGl0bGU9XCJTY3JpcHQgdGFza1wiPlxyXG4gKiAgICAgPHJlY3QgaWQ9XCJzaWQtQjgzREZBOUUtMDA2Ni00MDMyLUE5RTgtQTdGRjE5QzFBQjVEdGV4dF9mcmFtZVwiIGFuY2hvcnM9XCJib3R0b20gdG9wIHJpZ2h0IGxlZnRcIiB4PVwiMVwiIHk9XCIxXCIgd2lkdGg9XCI3NFwiIGhlaWdodD1cIjM5XCIgcng9XCIxMFwiIHJ5PVwiMTBcIiBzdHJva2U9XCJub25lXCIgc3Ryb2tlLXdpZHRoPVwiMFwiIGZpbGw9XCJub25lXCI+PC9yZWN0PlxyXG4gKiAgICAgPHJlY3QgaWQ9XCJzaWQtQjgzREZBOUUtMDA2Ni00MDMyLUE5RTgtQTdGRjE5QzFBQjVEYmdfZnJhbWVcIiByZXNpemU9XCJ2ZXJ0aWNhbCBob3Jpem9udGFsXCIgeD1cIjBcIiB5PVwiMFwiIHdpZHRoPVwiODBcIiBoZWlnaHQ9XCI0MFwiIHJ4PVwiMTBcIiByeT1cIjEwXCIgc3Ryb2tlPVwiI2JiYmJiYlwiIHN0cm9rZS13aWR0aD1cIjFcIiBmaWxsPVwiI2Y5ZjlmOVwiPjwvcmVjdD5cclxuICogICAgIDxyZWN0IHhtbG5zOm9yeXg9XCJodHRwOi8vd3d3LmIzbW4ub3JnL29yeXhcIiB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgaWQ9XCJzaWQtQjgzREZBOUUtMDA2Ni00MDMyLUE5RTgtQTdGRjE5QzFBQjVEYXJlYV9zdGF0ZVwiIGFuY2hvcnM9XCJib3R0b21cIiB4PVwiMFwiIHk9XCIzMFwiIHdpZHRoPVwiODBcIiBoZWlnaHQ9XCIxMFwiIHJ4PVwiMTBcIiByeT1cIjEwXCIgcmVzaXplPVwiaG9yaXpvbnRhbFwiIHN0cm9rZT1cIm5vbmVcIiBzdHJva2Utd2lkdGg9XCIwXCIgZmlsbD1cIm5vbmVcIiBzdHlsZT1cIlwiPjwvcmVjdD5cclxuICogICAgIDx0ZXh0IHhtbG5zOm9yeXg9XCJodHRwOi8vd3d3LmIzbW4ub3JnL29yeXhcIiB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgZm9udC1zaXplPVwiMTJcIiBpZD1cInNpZC1CODNERkE5RS0wMDY2LTQwMzItQTlFOC1BN0ZGMTlDMUFCNUR0ZXh0X25hbWVcIiB4PVwiNDNcIiB5PVwiMjRcIiBhbGlnbj1cIm1pZGRsZSBjZW50ZXJcIiBmaXR0b2VsZW09XCJ0ZXh0X2ZyYW1lXCIgc3Ryb2tlPVwiIzM3M2U0OFwiIHN0cm9rZS13aWR0aD1cIjBwdFwiIGxldHRlci1zcGFjaW5nPVwiLTAuMDFweFwiIHRyYW5zZm9ybT1cInJvdGF0ZSgwIDQzIDI0KVwiIG9yeXg6Zm9udFNpemU9XCIxMlwiIHRleHQtYW5jaG9yPVwibWlkZGxlXCI+PHRzcGFuIHg9XCI0M1wiIHk9XCIyNFwiIGR5PVwiNVwiPlRhc2s8L3RzcGFuPjwvdGV4dD5cclxuICogICAgIDxnIGlkPVwic2lkLUI4M0RGQTlFLTAwNjYtNDAzMi1BOUU4LUE3RkYxOUMxQUI1RHNjcmlwdFRhc2tcIiB0cmFuc2Zvcm09XCJ0cmFuc2xhdGUoMiwyKSBzY2FsZSgwLjgpXCI+XHJcbiAqICAgICA8cGF0aCBhbmNob3JzPVwidG9wIGxlZnRcIiBkPVwibSA1LDIgMCwwLjA5NCBjIDAuMjM3MDYsMC4wNjQgMC41MzE4OSwwLjE2NDUgMC44MTI1LDAuMzc1IDAuNTU4MiwwLjQxODYgMS4wNTEwOSwxLjIyOCAxLjE1NjI1LDIuNTMxMiBsIDguMDMxMjUsMCAxLDAgMSwwIGMgMCwtMyAtMiwtMyAtMiwtMyBsIC0xMCwwIHogTSA0LDMgNCwxMyAyLDEzIGMgMCwzIDIsMyAyLDMgbCA5LDAgYyAwLDAgMiwwIDIsLTMgTCAxNSw2IDYsNiA2LDUuNSBDIDYsNC4xMTExIDUuNTU5NSwzLjUyOSA1LjE4NzUsMy4yNSA0LjgxNTUsMi45NzEgNC41LDMgNC41LDMgTCA0LDMgelwiIHN0eWxlPVwiZmlsbDojNzJhN2QwO3N0cm9rZTpub25lXCIgaWQ9XCJzaWQtQjgzREZBOUUtMDA2Ni00MDMyLUE5RTgtQTdGRjE5QzFBQjVEX3NpZC1CODNERkE5RS0wMDY2LTQwMzItQTlFOC1BN0ZGMTlDMUFCNURfMTdcIj48L3BhdGg+XHJcbiAqICAgICA8L2c+XHJcbiAqIDwvZz5cclxuICovXHJcbiAgICBmdW5jdGlvbiBTY3JpcHRUYXNrTm9kZShtb2RlbCxhcGkpIHtcclxuICAgICAgICBUYXNrTm9kZS5jYWxsKHRoaXMsbW9kZWwsIGFwaSk7XHJcbiAgICAgICAgdGhpcy5yZWN0U2l6ZSA9IHt3aWR0aDoxMDAsIGhlaWdodDo2MH07XHJcbiAgICAgICAgdGhpcy5pY29uUGF0aCA9IFwibSA1LDIgMCwwLjA5NCBjIDAuMjM3MDYsMC4wNjQgMC41MzE4OSwwLjE2NDUgMC44MTI1LDAuMzc1IDAuNTU4MiwwLjQxODYgMS4wNTEwOSwxLjIyOCAxLjE1NjI1LDIuNTMxMiBsIDguMDMxMjUsMCAxLDAgMSwwIGMgMCwtMyAtMiwtMyAtMiwtMyBsIC0xMCwwIHogTSA0LDMgNCwxMyAyLDEzIGMgMCwzIDIsMyAyLDMgbCA5LDAgYyAwLDAgMiwwIDIsLTMgTCAxNSw2IDYsNiA2LDUuNSBDIDYsNC4xMTExIDUuNTU5NSwzLjUyOSA1LjE4NzUsMy4yNSA0LjgxNTUsMi45NzEgNC41LDMgNC41LDMgTCA0LDMgelwiO1xyXG4gICAgICAvLyAgdGhpcy5pY29uUGF0aDIgPSBcIk05LjU5NTk1OTY1OTgzNzc1NyAwLjc1NDc0OTcyMTQwMDAwMDEgIEMxMS4xNjA4MDU3NTk4Mzc3NTMgMS41MDk0OTk0NDI0IDExLjU3NjUxNzg1OTgzNzc1NCAyLjc0NjY1NDY4MjQgMTEuMDc0NTY3NTU5ODM3NzU3IDUuMjk4NTMzNzAyMzk5OTk5ICBDMTAuNTcyNjE3MjU5ODM3NzU2IDcuODUwNDEyNzMyNCAxMC4wMjg4NjAwNTk4Mzc3NTQgNy45NzI5MjE4MTI0IDkuNTk1OTU5NjU5ODM3NzU3IDguOTIwNzYyNTkyNCAgQzkuMTYzMDU5Mjc5ODM3NzUzIDkuODY4NjAzMzcyMzk5OTk5IDkuNDUxNjU5NTE5ODM3NzU0IDEwLjY3MDYyMjQ5MjQgMTAuNDYxNzYwNTU5ODM3NzU3IDExLjEwODA4NzQ5MjQgIEMxMS40NzE4NjE1NTk4Mzc3NTUgMTEuNTQ1NTUyNDkyNCAxNC4yODU3MTQyNTk4Mzc3NTUgMTIuODU3OTQ3MzkyNCAxNC4yODU3MTQzNTk4Mzc3NTcgMTMuNTg3MDU1NjkyNCAgQzE0LjI4NTcxNDM1OTgzNzc1NyAxNC4zMTYxNjM5OTI0IDEzLjA1OTE2MzE1OTgzNzc1NSAxNC4yNDMyNTMwOTI0IDExLjk3NjkxMjA1OTgzNzc1NSAxNC4yNDMyNTMwOTI0ICBDMTAuODk0NjYwOTU5ODM3NzU0IDE0LjI0MzI1MzA5MjQgNi4zNDkyMDY0MDk4Mzc3NTUgMTQuMjQzMjUzMDkyNCA2LjM0OTIwNjQwOTgzNzc1NSAxNC4yNDMyNTMwOTI0ICBMNi4xNTIwNjE5Njk4Mzc3NTUgMC40Mjk5MjYyNjk0ICBDNi4xNTIwNjE5Njk4Mzc3NTUgMC40Mjk5MjYyNjk0IDguMDMxMTEzNTQ5ODM3NzU1IDAgOS41OTU5NTk2NTk4Mzc3NTcgMC43NTQ3NDk3MjE0MDAwMDAxICB6XCI7XHJcbiAgICAgICAgdGhpcy5icG1uSW5mbyA9IHt0eXBlOiA3LCBuYW1lOlwiU2NyaXB0VGFza1wiIH07ICAgIC8v6IqC54K55L+h5oGvXHJcbiAgICAgICAgdGhpcy5yZW5kZXIobW9kZWwpO1xyXG4gICAgfVxyXG5cclxuICAgIFNjcmlwdFRhc2tOb2RlLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbihtb2RlbCkge1xyXG4gICAgICAgIHZhciByZWN0ID0gbmV3IGdyYXBoaWMuUmVjdCh7XHJcbiAgICAgICAgICAgIHNoYXBlOiB7XHJcbiAgICAgICAgICAgICAgICB4OiAwLjUsXHJcbiAgICAgICAgICAgICAgICB5OiAwLjUsXHJcbiAgICAgICAgICAgICAgICB3aWR0aDogdGhpcy5yZWN0U2l6ZS53aWR0aC0xLFxyXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLnJlY3RTaXplLmhlaWdodC0xLFxyXG4gICAgICAgICAgICAgICAgcjogN1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBzdHlsZToge1xyXG5cclxuICAgICAgICAgICAgICAgIGZpbGw6ICcjZjlmOWY5JyxcclxuICAgICAgICAgICAgICAgIHN0cm9rZTogJyNiYmJiYmInXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHo6MlxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJlY3QubmFtZSA9IFwiUmVjdFwiO1xyXG4gICAgICAgIHRoaXMuYWRkKHJlY3QpO1xyXG5cclxuICAgICAgICB2YXIgaWNvbnJlY3QgPSB7eDo1LCB5OiA1LCB3aWR0aDogMTUsIGhlaWdodDoxNX07XHJcbiAgICAgICAgdGhpcy5hZGQoZ3JhcGhpYy5tYWtlUGF0aCh0aGlzLmljb25QYXRoLCB7c3R5bGU6IHtmaWxsOiAnIzcyYTdkMCd9LHo6Mn0sIGljb25yZWN0KSk7XHJcblxyXG4gICAgICAgLy8gdGhpcy5hZGQoZ3JhcGhpYy5tYWtlUGF0aCh0aGlzLmljb25QYXRoMiwge3N0eWxlOiB7ZmlsbDogJyM0OTkwRTInfX0sIHJlY3QsXCJjZW50ZXJcIikpO1xyXG4gICAgICAgIHRoaXMucG9zaXRpb24gPSAgW21vZGVsLmdldChcImJvdW5kcy51cHBlckxlZnQueFwiKSwgbW9kZWwuZ2V0KFwiYm91bmRzLnVwcGVyTGVmdC55XCIpXTtcclxuICAgICAgICB2YXIgdGl0bGUgPSB0aGlzLmRyYXdUZXh0KG1vZGVsLmdldChcInByb3BlcnRpZXMubmFtZVwiKSk7XHJcbiAgICAgICAgdGl0bGUudGV4dC5uYW1lID0gXCJUaXRsZVwiO1xyXG4gICAgICAgIHRoaXMuYWRkKHRpdGxlLnRleHQpO1xyXG4gICAgfTtcclxuXHJcblx0enJVdGlsLmluaGVyaXRzKFNjcmlwdFRhc2tOb2RlLFRhc2tOb2RlKTtcclxuXHRtb2R1bGUuZXhwb3J0cyA9IFNjcmlwdFRhc2tOb2RlO1xyXG5cclxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2xpYi9maXNoLXRvcG8tYnBtbi9saWIvbm9kZS90YXNrL1NjcmlwdFRhc2tOb2RlLmpzXG4gKiogbW9kdWxlIGlkID0gODZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vTWFpbFRhc2voioLngrlcclxuXHJcblx0dmFyIFRhc2tOb2RlID0gcmVxdWlyZShcIi4vVGFza05vZGUuanNcIik7XHJcblx0dmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xyXG4gICAgdmFyIGdyYXBoaWMgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vZmlzaC10b3BvLWNvcmUvbGliL2dyYXBoaWMuanNcIik7XHJcbi8qKlxyXG4gKlxyXG4gKiAgPGcgcG9pbnRlci1ldmVudHM9XCJmaWxsXCIgbWluaW11bVNpemU9XCI4MiA0MlwiIGlkPVwic2lkLUI4M0RGQTlFLTAwNjYtNDAzMi1BOUU4LUE3RkYxOUMxQUI1RFwiIHRpdGxlPVwiU2NyaXB0IHRhc2tcIj5cclxuICogICAgIDxyZWN0IGlkPVwic2lkLUI4M0RGQTlFLTAwNjYtNDAzMi1BOUU4LUE3RkYxOUMxQUI1RHRleHRfZnJhbWVcIiBhbmNob3JzPVwiYm90dG9tIHRvcCByaWdodCBsZWZ0XCIgeD1cIjFcIiB5PVwiMVwiIHdpZHRoPVwiNzRcIiBoZWlnaHQ9XCIzOVwiIHJ4PVwiMTBcIiByeT1cIjEwXCIgc3Ryb2tlPVwibm9uZVwiIHN0cm9rZS13aWR0aD1cIjBcIiBmaWxsPVwibm9uZVwiPjwvcmVjdD5cclxuICogICAgIDxyZWN0IGlkPVwic2lkLUI4M0RGQTlFLTAwNjYtNDAzMi1BOUU4LUE3RkYxOUMxQUI1RGJnX2ZyYW1lXCIgcmVzaXplPVwidmVydGljYWwgaG9yaXpvbnRhbFwiIHg9XCIwXCIgeT1cIjBcIiB3aWR0aD1cIjgwXCIgaGVpZ2h0PVwiNDBcIiByeD1cIjEwXCIgcnk9XCIxMFwiIHN0cm9rZT1cIiNiYmJiYmJcIiBzdHJva2Utd2lkdGg9XCIxXCIgZmlsbD1cIiNmOWY5ZjlcIj48L3JlY3Q+XHJcbiAqICAgICA8cmVjdCB4bWxuczpvcnl4PVwiaHR0cDovL3d3dy5iM21uLm9yZy9vcnl4XCIgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIGlkPVwic2lkLUI4M0RGQTlFLTAwNjYtNDAzMi1BOUU4LUE3RkYxOUMxQUI1RGFyZWFfc3RhdGVcIiBhbmNob3JzPVwiYm90dG9tXCIgeD1cIjBcIiB5PVwiMzBcIiB3aWR0aD1cIjgwXCIgaGVpZ2h0PVwiMTBcIiByeD1cIjEwXCIgcnk9XCIxMFwiIHJlc2l6ZT1cImhvcml6b250YWxcIiBzdHJva2U9XCJub25lXCIgc3Ryb2tlLXdpZHRoPVwiMFwiIGZpbGw9XCJub25lXCIgc3R5bGU9XCJcIj48L3JlY3Q+XHJcbiAqICAgICA8dGV4dCB4bWxuczpvcnl4PVwiaHR0cDovL3d3dy5iM21uLm9yZy9vcnl4XCIgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIGZvbnQtc2l6ZT1cIjEyXCIgaWQ9XCJzaWQtQjgzREZBOUUtMDA2Ni00MDMyLUE5RTgtQTdGRjE5QzFBQjVEdGV4dF9uYW1lXCIgeD1cIjQzXCIgeT1cIjI0XCIgYWxpZ249XCJtaWRkbGUgY2VudGVyXCIgZml0dG9lbGVtPVwidGV4dF9mcmFtZVwiIHN0cm9rZT1cIiMzNzNlNDhcIiBzdHJva2Utd2lkdGg9XCIwcHRcIiBsZXR0ZXItc3BhY2luZz1cIi0wLjAxcHhcIiB0cmFuc2Zvcm09XCJyb3RhdGUoMCA0MyAyNClcIiBvcnl4OmZvbnRTaXplPVwiMTJcIiB0ZXh0LWFuY2hvcj1cIm1pZGRsZVwiPjx0c3BhbiB4PVwiNDNcIiB5PVwiMjRcIiBkeT1cIjVcIj5UYXNrPC90c3Bhbj48L3RleHQ+XHJcbiAqICAgICA8ZyBpZD1cInNpZC1CODNERkE5RS0wMDY2LTQwMzItQTlFOC1BN0ZGMTlDMUFCNURzY3JpcHRUYXNrXCIgdHJhbnNmb3JtPVwidHJhbnNsYXRlKDIsMikgc2NhbGUoMC44KVwiPlxyXG4gKiAgICAgICAgPHBhdGggYW5jaG9ycz1cInRvcCBsZWZ0XCIgZD1cIk0wLjMzMjYzODkzNiwxLjE3MzkxMzA0IEw4Ljk4MTI1MTI2LDYuNjUyMTczOTFcIiBpZD1cInNpZC0wOUI5N0M1RS1CRUE4LTQwQTItOUYyMi0zMDY0QTI3NDVEQkVMaW5lXCIgc3Ryb2tlPVwiI0ZGRkZGRlwiIHN0cm9rZS1saW5lY2FwPVwic3F1YXJlXCI+PC9wYXRoPlxyXG4gKiAgICAgICAgPHBhdGggYW5jaG9ycz1cInRvcCBsZWZ0XCIgZD1cIk0xNy41NTAwMzAyLDEuMTczOTEzMDQgTDguOTAxNDE3OTIsNi42NTIxNzM5MVwiIGlkPVwic2lkLTA5Qjk3QzVFLUJFQTgtNDBBMi05RjIyLTMwNjRBMjc0NURCRUxpbmUtQ29weS00XCIgc3Ryb2tlPVwiI0ZGRkZGRlwiIHN0cm9rZS1saW5lY2FwPVwic3F1YXJlXCI+PC9wYXRoPlxyXG4gKlx0ICAgPC9nPlxyXG4gKiA8L2c+XHJcbiAqL1xyXG4gICAgZnVuY3Rpb24gTWFpbFRhc2tOb2RlKG1vZGVsLGFwaSkge1xyXG4gICAgICAgIFRhc2tOb2RlLmNhbGwodGhpcyxtb2RlbCwgYXBpKTtcclxuICAgICAgICB0aGlzLnJlY3RTaXplID0ge3dpZHRoOjEwMCwgaGVpZ2h0OjYwfTtcclxuICAgICAgICB0aGlzLmljb25QYXRoID0gXCJNNDkuMDEzLDUxLjAwM2MxLjg0NywxLjMwMyw3LjQxNCw1LjE3NCwxNi43MDIsMTEuNjFTODIuMTE4LDc0LjAwNSw4Ny4wNjEsNzcuNDhjMC41NDMsMC4zODEsMS42OTcsMS4yMDksMy40NjIsMi40ODVjMS43NjUsMS4yNzcsMy4yMzIsMi4zMSw0LjM5OSwzLjA5N2MxLjE2OCwwLjc4NywyLjU4LDEuNjcsNC4yMzcsMi42NDdjMS42NTcsMC45NzcsMy4yMTksMS43MTEsNC42ODUsMi4xOThjMS40NjcsMC40OSwyLjgyNSwwLjczMyw0LjA3NCwwLjczM0gxMDhoMC4wODJjMS4yNDksMCwyLjYwNy0wLjI0Myw0LjA3NC0wLjczM2MxLjQ2Ni0wLjQ4NywzLjAyOS0xLjIyMiw0LjY4NS0yLjE5OGMxLjY1Ni0wLjk3OCwzLjA2OC0xLjg2LDQuMjM2LTIuNjQ3czIuNjM0LTEuODIsNC4zOTktMy4wOTdzMi45Mi0yLjEwNCwzLjQ2My0yLjQ4NWM0Ljk5Ni0zLjQ3NiwxNy43MDctMTIuMzAyLDM4LjEyOS0yNi40NzljMy45NjUtMi43NjksNy4yNzctNi4xMSw5LjkzOS0xMC4wMjFDMTc5LjY3LDM3LjA3MSwxODEsMzIuOTcsMTgxLDI4LjY3OWMwLTMuNTg1LTEuMjkxLTYuNjU0LTMuODcxLTkuMjA3Yy0yLjU4LTIuNTUzLTUuNjM2LTMuODI5LTkuMTY1LTMuODI5SDQ4LjAzNWMtNC4xODIsMC03LjQsMS40MTItOS42NTQsNC4yMzZDMzYuMTI3LDIyLjcwNCwzNSwyNi4yMzUsMzUsMzAuNDcxYzAsMy40MjIsMS40OTQsNy4xMyw0LjQ4MSwxMS4xMjJTNDUuNjQ2LDQ4LjcyMiw0OS4wMTMsNTEuMDAzeiBNMTcyLjg1Miw1OS43MmMtMTcuODE0LDEyLjA1Ny0zMS4zNCwyMS40MjctNDAuNTcyLDI4LjEwOGMtMy4wOTYsMi4yODEtNS42MDgsNC4wNjEtNy41MzcsNS4zMzZjLTEuOTI4LDEuMjc3LTQuNDk0LDIuNTgtNy42OTksMy45MTFjLTMuMjA0LDEuMzMxLTYuMTkxLDEuOTk2LTguOTYxLDEuOTk2SDEwOGgtMC4wODJjLTIuNzcsMC01Ljc1OC0wLjY2NS04Ljk2Mi0xLjk5NnMtNS43NzEtMi42MzQtNy42OTktMy45MTFjLTEuOTI4LTEuMjc1LTQuNDQtMy4wNTUtNy41MzYtNS4zMzZjLTcuMzMzLTUuMzc3LTIwLjgzLTE0Ljc0Ny00MC40OTItMjguMTA4Yy0zLjA5Ni0yLjA2My01LjgzOS00LjQyNy04LjIyOS03LjA4OHY2NC42ODhjMCwzLjU4NiwxLjI3Niw2LjY1NCwzLjgyOSw5LjIwN2MyLjU1MywyLjU1NCw1LjYyMiwzLjgzLDkuMjA3LDMuODNoMTE5LjkyOWMzLjU4NCwwLDYuNjUzLTEuMjc2LDkuMjA2LTMuODNjMi41NTQtMi41NTQsMy44MjktNS42MjEsMy44MjktOS4yMDdWNTIuNjMyQzE3OC42NjQsNTUuMjM4LDE3NS45NDksNTcuNjAyLDE3Mi44NTIsNTkuNzJ6XCI7XHJcbiAgICAgIC8vICB0aGlzLmljb25QYXRoMiA9IFwiTTkuNTk1OTU5NjU5ODM3NzU3IDAuNzU0NzQ5NzIxNDAwMDAwMSAgQzExLjE2MDgwNTc1OTgzNzc1MyAxLjUwOTQ5OTQ0MjQgMTEuNTc2NTE3ODU5ODM3NzU0IDIuNzQ2NjU0NjgyNCAxMS4wNzQ1Njc1NTk4Mzc3NTcgNS4yOTg1MzM3MDIzOTk5OTkgIEMxMC41NzI2MTcyNTk4Mzc3NTYgNy44NTA0MTI3MzI0IDEwLjAyODg2MDA1OTgzNzc1NCA3Ljk3MjkyMTgxMjQgOS41OTU5NTk2NTk4Mzc3NTcgOC45MjA3NjI1OTI0ICBDOS4xNjMwNTkyNzk4Mzc3NTMgOS44Njg2MDMzNzIzOTk5OTkgOS40NTE2NTk1MTk4Mzc3NTQgMTAuNjcwNjIyNDkyNCAxMC40NjE3NjA1NTk4Mzc3NTcgMTEuMTA4MDg3NDkyNCAgQzExLjQ3MTg2MTU1OTgzNzc1NSAxMS41NDU1NTI0OTI0IDE0LjI4NTcxNDI1OTgzNzc1NSAxMi44NTc5NDczOTI0IDE0LjI4NTcxNDM1OTgzNzc1NyAxMy41ODcwNTU2OTI0ICBDMTQuMjg1NzE0MzU5ODM3NzU3IDE0LjMxNjE2Mzk5MjQgMTMuMDU5MTYzMTU5ODM3NzU1IDE0LjI0MzI1MzA5MjQgMTEuOTc2OTEyMDU5ODM3NzU1IDE0LjI0MzI1MzA5MjQgIEMxMC44OTQ2NjA5NTk4Mzc3NTQgMTQuMjQzMjUzMDkyNCA2LjM0OTIwNjQwOTgzNzc1NSAxNC4yNDMyNTMwOTI0IDYuMzQ5MjA2NDA5ODM3NzU1IDE0LjI0MzI1MzA5MjQgIEw2LjE1MjA2MTk2OTgzNzc1NSAwLjQyOTkyNjI2OTQgIEM2LjE1MjA2MTk2OTgzNzc1NSAwLjQyOTkyNjI2OTQgOC4wMzExMTM1NDk4Mzc3NTUgMCA5LjU5NTk1OTY1OTgzNzc1NyAwLjc1NDc0OTcyMTQwMDAwMDEgIHpcIjtcclxuICAgICAgICB0aGlzLmJwbW5JbmZvID0ge3R5cGU6IDgsIG5hbWU6XCJNYWlsVGFza1wiIH07ICAgIC8v6IqC54K55L+h5oGvXHJcbiAgICAgICAgdGhpcy5yZW5kZXIobW9kZWwpO1xyXG4gICAgfVxyXG5cclxuICAgIE1haWxUYXNrTm9kZS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24obW9kZWwpIHtcclxuICAgICAgICB2YXIgcmVjdCA9IG5ldyBncmFwaGljLlJlY3Qoe1xyXG4gICAgICAgICAgICBzaGFwZToge1xyXG4gICAgICAgICAgICAgICAgeDogMC41LFxyXG4gICAgICAgICAgICAgICAgeTogMC41LFxyXG4gICAgICAgICAgICAgICAgd2lkdGg6IHRoaXMucmVjdFNpemUud2lkdGgtMSxcclxuICAgICAgICAgICAgICAgIGhlaWdodDogdGhpcy5yZWN0U2l6ZS5oZWlnaHQtMSxcclxuICAgICAgICAgICAgICAgIHI6IDdcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgc3R5bGU6IHtcclxuXHJcbiAgICAgICAgICAgICAgICBmaWxsOiAnI2Y5ZjlmOScsXHJcbiAgICAgICAgICAgICAgICBzdHJva2U6ICcjYmJiYmJiJ1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB6OjJcclxuICAgICAgICB9KTtcclxuICAgICAgICByZWN0Lm5hbWUgPSBcIlJlY3RcIjtcclxuICAgICAgICB0aGlzLmFkZChyZWN0KTtcclxuXHJcbiAgICAgICAgdmFyIGljb25yZWN0ID0ge3g6NSwgeTogNSwgd2lkdGg6IDIwLCBoZWlnaHQ6MTV9O1xyXG4gICAgICAgIHRoaXMuYWRkKGdyYXBoaWMubWFrZVBhdGgodGhpcy5pY29uUGF0aCwge3N0eWxlOiB7ZmlsbDogJyM3MmE3ZDAnfSx6OjJ9LCBpY29ucmVjdCkpO1xyXG5cclxuICAgICAgIC8vIHRoaXMuYWRkKGdyYXBoaWMubWFrZVBhdGgodGhpcy5pY29uUGF0aDIsIHtzdHlsZToge2ZpbGw6ICcjNDk5MEUyJ319LCByZWN0LFwiY2VudGVyXCIpKTtcclxuICAgICAgICB0aGlzLnBvc2l0aW9uID0gIFttb2RlbC5nZXQoXCJib3VuZHMudXBwZXJMZWZ0LnhcIiksIG1vZGVsLmdldChcImJvdW5kcy51cHBlckxlZnQueVwiKV07XHJcbiAgICAgICAgdmFyIHRpdGxlID0gdGhpcy5kcmF3VGV4dChtb2RlbC5nZXQoXCJwcm9wZXJ0aWVzLm5hbWVcIikpO1xyXG4gICAgICAgIHRpdGxlLnRleHQubmFtZSA9IFwiVGl0bGVcIjtcclxuICAgICAgICB0aGlzLmFkZCh0aXRsZS50ZXh0KTtcclxuICAgIH07XHJcblxyXG5cdHpyVXRpbC5pbmhlcml0cyhNYWlsVGFza05vZGUsVGFza05vZGUpO1xyXG5cdG1vZHVsZS5leHBvcnRzID0gTWFpbFRhc2tOb2RlO1xyXG5cclxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2xpYi9maXNoLXRvcG8tYnBtbi9saWIvbm9kZS90YXNrL01haWxUYXNrTm9kZS5qc1xuICoqIG1vZHVsZSBpZCA9IDg3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvL+i+ueeVjOS6i+S7ti0tLeaNleiOt+WumuaXtuWZqOS6i+S7tuiKgueCuVxyXG5cclxuXHR2YXIgRXZlbnROb2RlID0gcmVxdWlyZShcIi4uL0V2ZW50Tm9kZVwiKTtcclxuXHR2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XHJcbiAgICB2YXIgZ3JhcGhpYyA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi8uLi9maXNoLXRvcG8tY29yZS9saWIvZ3JhcGhpYy5qc1wiKTtcclxuXHJcbi8qKlxyXG4gKiA8ZyBwb2ludGVyLWV2ZW50cz1cImZpbGxcIiBpZD1cInNpZC1GRjBBREZDMC1EM0VDLTQyMzctQUQxNi1BMzYyNzNEMUZFNkRcIiB0aXRsZT1cIlN0YXJ0IGV2ZW50XCI+XHJcbiAqICAgIDxjaXJjbGUgaWQ9XCJzaWQtRjhERkJEQUQtMjg1Mi00QTlBLTg0RTktQTY1OTQzQTA5NjJCYmdfZnJhbWVcIiBjeD1cIjE2XCIgY3k9XCIxNlwiIHI9XCIxNVwiIHN0cm9rZT1cIiM1ODU4NThcIiBmaWxsPVwiI2ZmZmZmZlwiIHN0cm9rZS13aWR0aD1cIjFcIiBzdHlsZT1cInN0cm9rZS1kYXNoYXJyYXk6IDUuNSwgM1wiPjwvY2lyY2xlPlxyXG4gKiAgICA8Y2lyY2xlIGlkPVwic2lkLUY4REZCREFELTI4NTItNEE5QS04NEU5LUE2NTk0M0EwOTYyQmZyYW1lMl9ub25faW50ZXJydXB0aW5nXCIgY3g9XCIxNlwiIGN5PVwiMTZcIiByPVwiMTJcIiBzdHJva2U9XCIjNTg1ODU4XCIgZmlsbD1cIm5vbmVcIiBzdHJva2Utd2lkdGg9XCIxXCIgc3R5bGU9XCJzdHJva2UtZGFzaGFycmF5OiA0LjUsIDNcIj48L2NpcmNsZT5cclxuICogICAgPGNpcmNsZSBpZD1cInNpZC1GOERGQkRBRC0yODUyLTRBOUEtODRFOS1BNjU5NDNBMDk2MkJmcmFtZVwiIGN4PVwiMTZcIiBjeT1cIjE2XCIgcj1cIjE1XCIgc3Ryb2tlPVwiIzU4NTg1OFwiIGZpbGw9XCJub25lXCIgc3Ryb2tlLXdpZHRoPVwiMVwiPjwvY2lyY2xlPlxyXG4gKiAgICA8Y2lyY2xlIGlkPVwic2lkLUY4REZCREFELTI4NTItNEE5QS04NEU5LUE2NTk0M0EwOTYyQmZyYW1lMlwiIGN4PVwiMTZcIiBjeT1cIjE2XCIgcj1cIjEyXCIgc3Ryb2tlPVwiIzU4NTg1OFwiIGZpbGw9XCJub25lXCIgc3Ryb2tlLXdpZHRoPVwiMVwiPjwvY2lyY2xlPlxyXG4gKiAgICA8cGF0aCBpZD1cInNpZC1GOERGQkRBRC0yODUyLTRBOUEtODRFOS1BNjU5NDNBMDk2MkJwYXRoMVwiIHRyYW5zZm9ybT1cInRyYW5zbGF0ZSg2LDYpXCIgZD1cIk0gMTAgMCBDIDQuNDc3MTUyNSAwIDAgNC40NzcxNTI1IDAgMTAgQyAwIDE1LjUyMjg0NyA0LjQ3NzE1MjUgMjAgMTAgMjAgQyAxNS41MjI4NDcgMjAgMjAgMTUuNTIyODQ3IDIwIDEwIEMgMjAgNC40NzcxNTI1IDE1LjUyMjg0NyAxLjE4NDIzNzllLTE1IDEwIDAgeiBNIDkuMDkzNzUgMS4wMzEyNSBDIDkuMjI5MjE2NCAxLjAxNzQ5MjYgOS4zNjI4MjUgMS4wMzg5MzExIDkuNSAxLjAzMTI1IEwgOS41IDMuNSBMIDEwLjUgMy41IEwgMTAuNSAxLjAzMTI1IEMgMTUuMDYzNTI2IDEuMjg2NzgzMSAxOC43MTMyMTcgNC45MzY0NzM4IDE4Ljk2ODc1IDkuNSBMIDE2LjUgOS41IEwgMTYuNSAxMC41IEwgMTguOTY4NzUgMTAuNSBDIDE4LjcxMzIxNyAxNS4wNjM1MjYgMTUuMDYzNTI2IDE4LjcxMzIxNyAxMC41IDE4Ljk2ODc1IEwgMTAuNSAxNi41IEwgOS41IDE2LjUgTCA5LjUgMTguOTY4NzUgQyA0LjkzNjQ3MzggMTguNzEzMjE3IDEuMjg2NzgzMSAxNS4wNjM1MjYgMS4wMzEyNSAxMC41IEwgMy41IDEwLjUgTCAzLjUgOS41IEwgMS4wMzEyNSA5LjUgQyAxLjI3OTEwMiA1LjA3MzY0ODggNC43MjI1MzI2IDEuNDc1MTcxMyA5LjA5Mzc1IDEuMDMxMjUgeiBNIDkuNSA1IEwgOS41IDguMDYyNSBDIDguNjM3MzAwNyA4LjI4NDQ2MjcgOCA5LjA2ODAxOTUgOCAxMCBDIDggMTEuMTA0NTY5IDguODk1NDMwNSAxMiAxMCAxMiBDIDEwLjkzMTk4MSAxMiAxMS43MTU1MzcgMTEuMzYyNjk5IDExLjkzNzUgMTAuNSBMIDE0IDEwLjUgTCAxNCA5LjUgTCAxMS45Mzc1IDkuNSBDIDExLjc1NjY0MiA4Ljc5NzA1OTkgMTEuMjAyOTQgOC4yNDMzNTg1IDEwLjUgOC4wNjI1IEwgMTAuNSA1IEwgOS41IDUgeiBcIiBmaWxsPVwiIzU4NTg1OFwiIHN0cm9rZT1cIm5vbmVcIj48L3BhdGg+XHJcbiAqIDwvZz5cclxuICovXHJcblxyXG5cdGZ1bmN0aW9uIENhdGNoVGltZXJFdmVudE5vZGUobW9kZWwsIGFwaSkge1xyXG5cdFx0RXZlbnROb2RlLmNhbGwodGhpcyxtb2RlbCwgYXBpKTtcclxuICAgICAgICB0aGlzLnN0YXJ0SWNvbiA9ICdNIDEwIDAgQyA0LjQ3NzE1MjUgMCAwIDQuNDc3MTUyNSAwIDEwIEMgMCAxNS41MjI4NDcgNC40NzcxNTI1IDIwIDEwIDIwIEMgMTUuNTIyODQ3IDIwIDIwIDE1LjUyMjg0NyAyMCAxMCBDIDIwIDQuNDc3MTUyNSAxNS41MjI4NDcgMS4xODQyMzc5ZS0xNSAxMCAwIHogTSA5LjA5Mzc1IDEuMDMxMjUgQyA5LjIyOTIxNjQgMS4wMTc0OTI2IDkuMzYyODI1IDEuMDM4OTMxMSA5LjUgMS4wMzEyNSBMIDkuNSAzLjUgTCAxMC41IDMuNSBMIDEwLjUgMS4wMzEyNSBDIDE1LjA2MzUyNiAxLjI4Njc4MzEgMTguNzEzMjE3IDQuOTM2NDczOCAxOC45Njg3NSA5LjUgTCAxNi41IDkuNSBMIDE2LjUgMTAuNSBMIDE4Ljk2ODc1IDEwLjUgQyAxOC43MTMyMTcgMTUuMDYzNTI2IDE1LjA2MzUyNiAxOC43MTMyMTcgMTAuNSAxOC45Njg3NSBMIDEwLjUgMTYuNSBMIDkuNSAxNi41IEwgOS41IDE4Ljk2ODc1IEMgNC45MzY0NzM4IDE4LjcxMzIxNyAxLjI4Njc4MzEgMTUuMDYzNTI2IDEuMDMxMjUgMTAuNSBMIDMuNSAxMC41IEwgMy41IDkuNSBMIDEuMDMxMjUgOS41IEMgMS4yNzkxMDIgNS4wNzM2NDg4IDQuNzIyNTMyNiAxLjQ3NTE3MTMgOS4wOTM3NSAxLjAzMTI1IHogTSA5LjUgNSBMIDkuNSA4LjA2MjUgQyA4LjYzNzMwMDcgOC4yODQ0NjI3IDggOS4wNjgwMTk1IDggMTAgQyA4IDExLjEwNDU2OSA4Ljg5NTQzMDUgMTIgMTAgMTIgQyAxMC45MzE5ODEgMTIgMTEuNzE1NTM3IDExLjM2MjY5OSAxMS45Mzc1IDEwLjUgTCAxNCAxMC41IEwgMTQgOS41IEwgMTEuOTM3NSA5LjUgQyAxMS43NTY2NDIgOC43OTcwNTk5IDExLjIwMjk0IDguMjQzMzU4NSAxMC41IDguMDYyNSBMIDEwLjUgNSBMIDkuNSA1IHonO1xyXG4gICAgICAgIHRoaXMuaXRlbVNpemUgPSAxMDtcclxuXHRcdHRoaXMuYnBtbkluZm8gPSB7dHlwZTogNDMsIG5hbWU6XCJDYXRjaFRpbWVyRXZlbnRcIiB9OyAgICAvL+iKgueCueS/oeaBr1xyXG4gICAgICAgIHRoaXMucmVuZGVyKG1vZGVsKTtcclxuXHR9XHJcblxyXG4gICAgQ2F0Y2hUaW1lckV2ZW50Tm9kZS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24obW9kZWwpIHtcclxuXHJcbiAgICAgICAgdmFyIGNpcmNsZSA9IG5ldyBncmFwaGljLkNpcmNsZSh7XHJcbiAgICAgICAgICAgIHNoYXBlOiB7XHJcbiAgICAgICAgICAgICAgICBjeDogMCxcclxuICAgICAgICAgICAgICAgIGN5OiAwLFxyXG4gICAgICAgICAgICAgICAgcjogdGhpcy5pdGVtU2l6ZS0wLjVcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgIGZpbGw6ICcjZmZmZmZmJyxcclxuICAgICAgICAgICAgICAgIHN0cm9rZTonIzU4NTg1OCdcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgejoyXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgY2lyY2xlLm5hbWUgPSBcIkNpcmNsZVwiO1xyXG4gICAgICAgIHRoaXMuYWRkKGNpcmNsZSk7XHJcbiAgICAgICAgdmFyIGNpcmNsZTEgPSBuZXcgZ3JhcGhpYy5DaXJjbGUoe1xyXG4gICAgICAgICAgICBzaGFwZToge1xyXG4gICAgICAgICAgICAgICAgY3g6IDAsXHJcbiAgICAgICAgICAgICAgICBjeTogMCxcclxuICAgICAgICAgICAgICAgIHI6IHRoaXMuaXRlbVNpemUtM1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBzdHlsZToge1xyXG4gICAgICAgICAgICAgICAgZmlsbDogJyNmZmZmZmYnLFxyXG4gICAgICAgICAgICAgICAgc3Ryb2tlOicjNTg1ODU4J1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB6OjJcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmFkZChjaXJjbGUxKTtcclxuXHJcbiAgICAgICAgdmFyIGl0ZW1TaXplID0gdGhpcy5pdGVtU2l6ZSs2O1xyXG4gICAgICAgIHZhciByZWN0ID0ge3g6LWl0ZW1TaXplLzIsIHk6IC1pdGVtU2l6ZS8yLCB3aWR0aDogaXRlbVNpemUsIGhlaWdodDppdGVtU2l6ZX07XHJcbiAgICAgICAgdGhpcy5hZGQoZ3JhcGhpYy5tYWtlUGF0aCh0aGlzLnN0YXJ0SWNvbiwge3N0eWxlOiB7c3Ryb2tlOicjNTg1ODU4J30sejoyfSwgcmVjdCxcImNlbnRlclwiKSk7XHJcbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IFttb2RlbC5nZXQoXCJib3VuZHMudXBwZXJMZWZ0LnhcIikrdGhpcy5pdGVtU2l6ZSAsIG1vZGVsLmdldChcImJvdW5kcy51cHBlckxlZnQueVwiKSt0aGlzLml0ZW1TaXplXTtcclxuXHJcbiAgICB9O1xyXG5cclxuXHR6clV0aWwuaW5oZXJpdHMoQ2F0Y2hUaW1lckV2ZW50Tm9kZSwgRXZlbnROb2RlKTtcclxuXHRtb2R1bGUuZXhwb3J0cyA9IENhdGNoVGltZXJFdmVudE5vZGU7XHJcblxyXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vbGliL2Zpc2gtdG9wby1icG1uL2xpYi9ub2RlL2V2ZW50L2JvdW5kYXJ5ZXZlbnQvQ2F0Y2hUaW1lckV2ZW50Tm9kZS5qc1xuICoqIG1vZHVsZSBpZCA9IDg4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvL+i+ueeVjOS6i+S7ti0tLeaNleiOt+S/oeWPt+mHj+S6i+S7tlxyXG5cclxuXHR2YXIgRXZlbnROb2RlID0gcmVxdWlyZShcIi4uL0V2ZW50Tm9kZVwiKTtcclxuXHR2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XHJcbiAgICB2YXIgZ3JhcGhpYyA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi8uLi9maXNoLXRvcG8tY29yZS9saWIvZ3JhcGhpYy5qc1wiKTtcclxuXHJcbi8qKlxyXG4gKiA8ZyBwb2ludGVyLWV2ZW50cz1cImZpbGxcIiBpZD1cInNpZC1GRjBBREZDMC1EM0VDLTQyMzctQUQxNi1BMzYyNzNEMUZFNkRcIiB0aXRsZT1cIlN0YXJ0IGV2ZW50XCI+XHJcbiAqICAgIDxjaXJjbGUgaWQ9XCJzaWQtRjhERkJEQUQtMjg1Mi00QTlBLTg0RTktQTY1OTQzQTA5NjJCYmdfZnJhbWVcIiBjeD1cIjE2XCIgY3k9XCIxNlwiIHI9XCIxNVwiIHN0cm9rZT1cIiM1ODU4NThcIiBmaWxsPVwiI2ZmZmZmZlwiIHN0cm9rZS13aWR0aD1cIjFcIiBzdHlsZT1cInN0cm9rZS1kYXNoYXJyYXk6IDUuNSwgM1wiPjwvY2lyY2xlPlxyXG4gKiAgICA8Y2lyY2xlIGlkPVwic2lkLUY4REZCREFELTI4NTItNEE5QS04NEU5LUE2NTk0M0EwOTYyQmZyYW1lMl9ub25faW50ZXJydXB0aW5nXCIgY3g9XCIxNlwiIGN5PVwiMTZcIiByPVwiMTJcIiBzdHJva2U9XCIjNTg1ODU4XCIgZmlsbD1cIm5vbmVcIiBzdHJva2Utd2lkdGg9XCIxXCIgc3R5bGU9XCJzdHJva2UtZGFzaGFycmF5OiA0LjUsIDNcIj48L2NpcmNsZT5cclxuICogICAgPHBhdGggaWQ9XCJzaWQtM0NDMzM5MjQtNzNGMy00RDEzLUEyQTktMDI0MjUzMDY4MERFc2lnbmFsQ2F0Y2hpbmdcIiBzdHJva2U9XCIjNTg1ODU4XCIgZD1cIiBNNy43MTI0OTcxIDIwLjI0NzM0MiAgTDIyLjMzMzMzNCAyMC4yNDczNDIgIEwxNS4wMjI5MTUwMDAwMDAwMDEgNy41NzU5NTEyMDAwMDAwMDEgIEw3LjcxMjQ5NzEgMjAuMjQ3MzQyICB6XCIgc3R5bGU9XCJmaWxsOm5vbmU7c3Ryb2tlLXdpZHRoOjEuNDtzdHJva2UtbWl0ZXJsaW1pdDo0O3N0cm9rZS1kYXNoYXJyYXk6bm9uZVwiPjwvcGF0aD5cclxuICogPC9nPlxyXG4gKi9cclxuXHJcblx0ZnVuY3Rpb24gQ2F0Y2hTaWduYWxFdmVudE5vZGUobW9kZWwsIGFwaSkge1xyXG5cdFx0RXZlbnROb2RlLmNhbGwodGhpcyxtb2RlbCwgYXBpKTtcclxuICAgICAgICB0aGlzLnN0YXJ0SWNvbiA9ICdNNy43MTI0OTcxIDIwLjI0NzM0MiAgTDIyLjMzMzMzNCAyMC4yNDczNDIgIEwxNS4wMjI5MTUwMDAwMDAwMDEgNy41NzU5NTEyMDAwMDAwMDEgIEw3LjcxMjQ5NzEgMjAuMjQ3MzQyICB6JztcclxuICAgICAgICB0aGlzLml0ZW1TaXplID0gMTA7XHJcblx0XHR0aGlzLmJwbW5JbmZvID0ge3R5cGU6IDcyLCBuYW1lOlwiQ2F0Y2hTaWduYWxFdmVudFwiIH07ICAgIC8v6IqC54K55L+h5oGvXHJcbiAgICAgICAgdGhpcy5yZW5kZXIobW9kZWwpO1xyXG5cdH1cclxuXHJcbiAgICBDYXRjaFNpZ25hbEV2ZW50Tm9kZS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24obW9kZWwpIHtcclxuXHJcbiAgICAgICAgdmFyIGNpcmNsZSA9IG5ldyBncmFwaGljLkNpcmNsZSh7XHJcbiAgICAgICAgICAgIHNoYXBlOiB7XHJcbiAgICAgICAgICAgICAgICBjeDogMCxcclxuICAgICAgICAgICAgICAgIGN5OiAwLFxyXG4gICAgICAgICAgICAgICAgcjogdGhpcy5pdGVtU2l6ZS0wLjVcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgIGZpbGw6ICcjZmZmZmZmJyxcclxuICAgICAgICAgICAgICAgIHN0cm9rZTonIzU4NTg1OCdcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgejoyXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgY2lyY2xlLm5hbWUgPSBcIkNpcmNsZVwiO1xyXG4gICAgICAgIHRoaXMuYWRkKGNpcmNsZSk7XHJcbiAgICAgICAgdmFyIGNpcmNsZTEgPSBuZXcgZ3JhcGhpYy5DaXJjbGUoe1xyXG4gICAgICAgICAgICBzaGFwZToge1xyXG4gICAgICAgICAgICAgICAgY3g6IDAsXHJcbiAgICAgICAgICAgICAgICBjeTogMCxcclxuICAgICAgICAgICAgICAgIHI6IHRoaXMuaXRlbVNpemUtM1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBzdHlsZToge1xyXG4gICAgICAgICAgICAgICAgZmlsbDogJyNmZmZmZmYnLFxyXG4gICAgICAgICAgICAgICAgc3Ryb2tlOicjNTg1ODU4J1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB6OjJcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmFkZChjaXJjbGUxKTtcclxuXHJcbiAgICAgICAgdmFyIGl0ZW1TaXplID0gdGhpcy5pdGVtU2l6ZSs2O1xyXG4gICAgICAgIHZhciByZWN0ID0ge3g6LWl0ZW1TaXplLzIsIHk6IC1pdGVtU2l6ZS8yLTMsIHdpZHRoOiBpdGVtU2l6ZSwgaGVpZ2h0Oml0ZW1TaXplfTtcclxuICAgICAgICB0aGlzLmFkZChncmFwaGljLm1ha2VQYXRoKHRoaXMuc3RhcnRJY29uLCB7c3R5bGU6IHtzdHJva2U6JyM1ODU4NTgnLGZpbGw6JyNmZmZmZmYnfSx6OjJ9LCByZWN0LFwiY2VudGVyXCIpKTtcclxuICAgICAgICB0aGlzLnBvc2l0aW9uID0gW21vZGVsLmdldChcImJvdW5kcy51cHBlckxlZnQueFwiKSt0aGlzLml0ZW1TaXplICwgbW9kZWwuZ2V0KFwiYm91bmRzLnVwcGVyTGVmdC55XCIpK3RoaXMuaXRlbVNpemVdO1xyXG5cclxuICAgIH07XHJcblxyXG5cdHpyVXRpbC5pbmhlcml0cyhDYXRjaFNpZ25hbEV2ZW50Tm9kZSwgRXZlbnROb2RlKTtcclxuXHRtb2R1bGUuZXhwb3J0cyA9IENhdGNoU2lnbmFsRXZlbnROb2RlO1xyXG5cclxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2xpYi9maXNoLXRvcG8tYnBtbi9saWIvbm9kZS9ldmVudC9ib3VuZGFyeWV2ZW50L0NhdGNoU2lnbmFsRXZlbnROb2RlLmpzXG4gKiogbW9kdWxlIGlkID0gODlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8v6L6555WM5LqL5Lu2LS0tVGhyb3dTaWduYWxFdmVudOiKgueCuVxyXG5cclxuXHR2YXIgRXZlbnROb2RlID0gcmVxdWlyZShcIi4uL0V2ZW50Tm9kZVwiKTtcclxuXHR2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XHJcbiAgICB2YXIgZ3JhcGhpYyA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi8uLi9maXNoLXRvcG8tY29yZS9saWIvZ3JhcGhpYy5qc1wiKTtcclxuXHJcbi8qKlxyXG4gKiA8ZyBwb2ludGVyLWV2ZW50cz1cImZpbGxcIiBpZD1cInNpZC1GRjBBREZDMC1EM0VDLTQyMzctQUQxNi1BMzYyNzNEMUZFNkRcIiB0aXRsZT1cIlN0YXJ0IGV2ZW50XCI+XHJcbiAqICAgIDxjaXJjbGUgaWQ9XCJzaWQtRjhERkJEQUQtMjg1Mi00QTlBLTg0RTktQTY1OTQzQTA5NjJCYmdfZnJhbWVcIiBjeD1cIjE2XCIgY3k9XCIxNlwiIHI9XCIxNVwiIHN0cm9rZT1cIiM1ODU4NThcIiBmaWxsPVwiI2ZmZmZmZlwiIHN0cm9rZS13aWR0aD1cIjFcIiBzdHlsZT1cInN0cm9rZS1kYXNoYXJyYXk6IDUuNSwgM1wiPjwvY2lyY2xlPlxyXG4gKiAgICA8Y2lyY2xlIGlkPVwic2lkLUY4REZCREFELTI4NTItNEE5QS04NEU5LUE2NTk0M0EwOTYyQmZyYW1lMl9ub25faW50ZXJydXB0aW5nXCIgY3g9XCIxNlwiIGN5PVwiMTZcIiByPVwiMTJcIiBzdHJva2U9XCIjNTg1ODU4XCIgZmlsbD1cIm5vbmVcIiBzdHJva2Utd2lkdGg9XCIxXCIgc3R5bGU9XCJzdHJva2UtZGFzaGFycmF5OiA0LjUsIDNcIj48L2NpcmNsZT5cclxuICogICAgPHBhdGggaWQ9XCJzaWQtM0NDMzM5MjQtNzNGMy00RDEzLUEyQTktMDI0MjUzMDY4MERFc2lnbmFsQ2F0Y2hpbmdcIiBzdHJva2U9XCIjNTg1ODU4XCIgZD1cIiBNNy43MTI0OTcxIDIwLjI0NzM0MiAgTDIyLjMzMzMzNCAyMC4yNDczNDIgIEwxNS4wMjI5MTUwMDAwMDAwMDEgNy41NzU5NTEyMDAwMDAwMDEgIEw3LjcxMjQ5NzEgMjAuMjQ3MzQyICB6XCIgc3R5bGU9XCJmaWxsOm5vbmU7c3Ryb2tlLXdpZHRoOjEuNDtzdHJva2UtbWl0ZXJsaW1pdDo0O3N0cm9rZS1kYXNoYXJyYXk6bm9uZVwiPjwvcGF0aD5cclxuICogPC9nPlxyXG4gKi9cclxuXHJcblx0ZnVuY3Rpb24gVGhyb3dTaWduYWxFdmVudE5vZGUobW9kZWwsIGFwaSkge1xyXG5cdFx0RXZlbnROb2RlLmNhbGwodGhpcyxtb2RlbCwgYXBpKTtcclxuICAgICAgICB0aGlzLnN0YXJ0SWNvbiA9ICdNNy43MTI0OTcxIDIwLjI0NzM0MiAgTDIyLjMzMzMzNCAyMC4yNDczNDIgIEwxNS4wMjI5MTUwMDAwMDAwMDEgNy41NzU5NTEyMDAwMDAwMDEgIEw3LjcxMjQ5NzEgMjAuMjQ3MzQyICB6JztcclxuICAgICAgICB0aGlzLml0ZW1TaXplID0gMTA7XHJcblx0XHR0aGlzLmJwbW5JbmZvID0ge3R5cGU6IDc1LCBuYW1lOlwiVGhyb3dTaWduYWxFdmVudFwiIH07ICAgIC8v6IqC54K55L+h5oGvXHJcbiAgICAgICAgdGhpcy5yZW5kZXIobW9kZWwpO1xyXG5cdH1cclxuXHJcbiAgICBUaHJvd1NpZ25hbEV2ZW50Tm9kZS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24obW9kZWwpIHtcclxuXHJcbiAgICAgICAgdmFyIGNpcmNsZSA9IG5ldyBncmFwaGljLkNpcmNsZSh7XHJcbiAgICAgICAgICAgIHNoYXBlOiB7XHJcbiAgICAgICAgICAgICAgICBjeDogMCxcclxuICAgICAgICAgICAgICAgIGN5OiAwLFxyXG4gICAgICAgICAgICAgICAgcjogdGhpcy5pdGVtU2l6ZS0wLjVcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgIGZpbGw6ICcjZmZmZmZmJyxcclxuICAgICAgICAgICAgICAgIHN0cm9rZTonIzU4NTg1OCdcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgejoyXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgY2lyY2xlLm5hbWUgPSBcIkNpcmNsZVwiO1xyXG4gICAgICAgIHRoaXMuYWRkKGNpcmNsZSk7XHJcbiAgICAgICAgdmFyIGNpcmNsZTEgPSBuZXcgZ3JhcGhpYy5DaXJjbGUoe1xyXG4gICAgICAgICAgICBzaGFwZToge1xyXG4gICAgICAgICAgICAgICAgY3g6IDAsXHJcbiAgICAgICAgICAgICAgICBjeTogMCxcclxuICAgICAgICAgICAgICAgIHI6IHRoaXMuaXRlbVNpemUtM1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBzdHlsZToge1xyXG4gICAgICAgICAgICAgICAgZmlsbDogJyNmZmZmZmYnLFxyXG4gICAgICAgICAgICAgICAgc3Ryb2tlOicjNTg1ODU4J1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB6OjJcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmFkZChjaXJjbGUxKTtcclxuXHJcbiAgICAgICAgdmFyIGl0ZW1TaXplID0gdGhpcy5pdGVtU2l6ZSs2O1xyXG4gICAgICAgIHZhciByZWN0ID0ge3g6LWl0ZW1TaXplLzIsIHk6IC1pdGVtU2l6ZS8yLTMsIHdpZHRoOiBpdGVtU2l6ZSwgaGVpZ2h0Oml0ZW1TaXplfTtcclxuICAgICAgICB0aGlzLmFkZChncmFwaGljLm1ha2VQYXRoKHRoaXMuc3RhcnRJY29uLCB7c3R5bGU6IHtzdHJva2U6JyM1ODU4NTgnLGZpbGw6JyMwMDAwMDAnfSx6OjJ9LCByZWN0LFwiY2VudGVyXCIpKTtcclxuICAgICAgICB0aGlzLnBvc2l0aW9uID0gW21vZGVsLmdldChcImJvdW5kcy51cHBlckxlZnQueFwiKSt0aGlzLml0ZW1TaXplICwgbW9kZWwuZ2V0KFwiYm91bmRzLnVwcGVyTGVmdC55XCIpK3RoaXMuaXRlbVNpemVdO1xyXG5cclxuICAgIH07XHJcblxyXG5cdHpyVXRpbC5pbmhlcml0cyhUaHJvd1NpZ25hbEV2ZW50Tm9kZSwgRXZlbnROb2RlKTtcclxuXHRtb2R1bGUuZXhwb3J0cyA9IFRocm93U2lnbmFsRXZlbnROb2RlO1xyXG5cclxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2xpYi9maXNoLXRvcG8tYnBtbi9saWIvbm9kZS9ldmVudC9ib3VuZGFyeWV2ZW50L1Rocm93U2lnbmFsRXZlbnROb2RlLmpzXG4gKiogbW9kdWxlIGlkID0gOTBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vSW5jbHVzaXZlR2F0ZVdheeiKgueCuVxyXG5cclxuXHR2YXIgR2F0ZXdheU5vZGUgPSByZXF1aXJlKFwiLi9HYXRld2F5Tm9kZVwiKTtcclxuXHR2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XHJcbiAgICB2YXIgZ3JhcGhpYyA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi9maXNoLXRvcG8tY29yZS9saWIvZ3JhcGhpYy5qc1wiKTtcclxuXHJcbi8qKlxyXG4gKiA8ZyBwb2ludGVyLWV2ZW50cz1cImZpbGxcIiBpZD1cInNpZC1GRjBBREZDMC1EM0VDLTQyMzctQUQxNi1BMzYyNzNEMUZFNkRcIiB0aXRsZT1cIlN0YXJ0IGV2ZW50XCI+XHJcbiAqICAgIDxwYXRoIGQ9XCIgTTAgMTkuNTA2MzkzOTY0ICBMMTkuNTA2MzkzOTY0IDAgIEwzOS4wMTI3ODc5NjQgMTkuNTA2MzkzOTY0ICBMMTkuNTA2MzkzOTY0IDM5LjAxMjc4Nzk2NCAgTDAgMTkuNTA2MzkzOTY0ICBMMCAxOS41MDYzOTM5NjQgIHpcIiBpZD1cInNpZC02RDBFOTNEQS0wRTBCLTQ3RjAtQUY4NS0zRjMyMzAzNjc2NTFSZWN0YW5nbGUtMVwiIGZpbGw9XCIjRjZBNjIzXCI+PC9wYXRoPlxyXG4gKiAgICA8cGF0aCBkPVwiIE0xOS44NTEyMjE1NjQgMjcuNzgyMjU2MDY0MDAwMDAyICBDMjQuMjMxNDEwOTY0IDI3Ljc4MjI1NjA2NDAwMDAwMiAyNy43ODIyNTYwNjQwMDAwMDIgMjQuMjMxNDEwOTY0IDI3Ljc4MjI1NjA2NDAwMDAwMiAxOS44NTEyMjE1NjQgIEMyNy43ODIyNTYwNjQwMDAwMDIgMTUuNDcxMDMyMTYzOTk5OTk5IDI0LjIzMTQxMDk2NCAxMS45MjAxODcwNjM5OTk5OTkgMTkuODUxMjIxNTY0IDExLjkyMDE4NzA2Mzk5OTk5OSAgQzE1LjQ3MTAzMjE2Mzk5OTk5OSAxMS45MjAxODcwNjM5OTk5OTkgMTEuOTIwMTg3MDYzOTk5OTk5IDE1LjQ3MTAzMjE2Mzk5OTk5OSAxMS45MjAxODcwNjM5OTk5OTkgMTkuODUxMjIxNTY0ICBDMTEuOTIwMTg3MDYzOTk5OTk5IDI0LjIzMTQxMDk2NCAxNS40NzEwMzIxNjM5OTk5OTkgMjcuNzgyMjU2MDY0MDAwMDAyIDE5Ljg1MTIyMTU2NCAyNy43ODIyNTYwNjQwMDAwMDIgIHpcIiBpZD1cInNpZC02RDBFOTNEQS0wRTBCLTQ3RjAtQUY4NS0zRjMyMzAzNjc2NTFPdmFsLTRcIiBmaWxsPVwiI0ZGRkZGRlwiPjwvcGF0aD5cclxuICogPC9nPlxyXG4gKi9cclxuXHJcblx0ZnVuY3Rpb24gSW5jbHVzaXZlR2F0ZXdheU5vZGUobW9kZWwsIGFwaSkge1xyXG5cdFx0R2F0ZXdheU5vZGUuY2FsbCh0aGlzLCBtb2RlbCwgYXBpKTtcclxuICAgICAgICB0aGlzLnN0YXJ0SWNvbiA9ICdNMCAxOS41MDYzOTM5NjQgIEwxOS41MDYzOTM5NjQgMCAgTDM5LjAxMjc4Nzk2NCAxOS41MDYzOTM5NjQgIEwxOS41MDYzOTM5NjQgMzkuMDEyNzg3OTY0ICBMMCAxOS41MDYzOTM5NjQgIEwwIDE5LjUwNjM5Mzk2NCAgeic7XHJcbiAgICAgICAgdGhpcy5uZXh0SWNvbiA9ICdNMTkuODUxMjIxNTY0IDI3Ljc4MjI1NjA2NDAwMDAwMiAgQzI0LjIzMTQxMDk2NCAyNy43ODIyNTYwNjQwMDAwMDIgMjcuNzgyMjU2MDY0MDAwMDAyIDI0LjIzMTQxMDk2NCAyNy43ODIyNTYwNjQwMDAwMDIgMTkuODUxMjIxNTY0ICBDMjcuNzgyMjU2MDY0MDAwMDAyIDE1LjQ3MTAzMjE2Mzk5OTk5OSAyNC4yMzE0MTA5NjQgMTEuOTIwMTg3MDYzOTk5OTk5IDE5Ljg1MTIyMTU2NCAxMS45MjAxODcwNjM5OTk5OTkgIEMxNS40NzEwMzIxNjM5OTk5OTkgMTEuOTIwMTg3MDYzOTk5OTk5IDExLjkyMDE4NzA2Mzk5OTk5OSAxNS40NzEwMzIxNjM5OTk5OTkgMTEuOTIwMTg3MDYzOTk5OTk5IDE5Ljg1MTIyMTU2NCAgQzExLjkyMDE4NzA2Mzk5OTk5OSAyNC4yMzE0MTA5NjQgMTUuNDcxMDMyMTYzOTk5OTk5IDI3Ljc4MjI1NjA2NDAwMDAwMiAxOS44NTEyMjE1NjQgMjcuNzgyMjU2MDY0MDAwMDAyICB6JztcclxuICAgICAgICB0aGlzLml0ZW1TaXplID0gMjA7XHJcblx0XHR0aGlzLmJwbW5JbmZvID0ge3R5cGU6IDIwLCBuYW1lOlwiSW5jbHVzaXZlR2F0ZXdheVwiIH07ICAgIC8v6IqC54K55L+h5oGvXHJcbiAgICAgICAgdGhpcy5yZW5kZXIobW9kZWwpO1xyXG5cdH1cclxuXHJcbiAgICBJbmNsdXNpdmVHYXRld2F5Tm9kZS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24obW9kZWwpIHtcclxuICAgICAgICB2YXIgaXRlbVNpemUgPSB0aGlzLml0ZW1TaXplKjI7XHJcbiAgICAgICAgdmFyIHJlY3QgPSB7eDotaXRlbVNpemUvMiwgeTogLWl0ZW1TaXplLzIsIHdpZHRoOiBpdGVtU2l6ZSwgaGVpZ2h0Oml0ZW1TaXplfTtcclxuICAgICAgICB2YXIgcGF0aCA9IGdyYXBoaWMubWFrZVBhdGgodGhpcy5zdGFydEljb24sIHtzdHlsZToge2ZpbGw6ICcjRjZBNjIzJ30sejoyfSwgcmVjdCxcImNlbnRlclwiKTtcclxuICAgICAgICBwYXRoLm5hbWUgPSAnUGF0aCc7XHJcbiAgICAgICAgdGhpcy5hZGQocGF0aCk7XHJcbiAgICAgICAgdmFyIGl0ZW1TaXplMSA9IHRoaXMuaXRlbVNpemU7XHJcbiAgICAgICAgdmFyIHJlY3QxID0ge3g6LWl0ZW1TaXplMS8yLCB5OiAtaXRlbVNpemUxLzIsIHdpZHRoOiBpdGVtU2l6ZTEsIGhlaWdodDppdGVtU2l6ZTF9O1xyXG4gICAgICAgIHRoaXMuYWRkKGdyYXBoaWMubWFrZVBhdGgodGhpcy5uZXh0SWNvbiwge3N0eWxlOiB7ZmlsbDogJyNGRkZGRkYnfSx6OjJ9LCByZWN0MSxcImNlbnRlclwiKSk7XHJcbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IFttb2RlbC5nZXQoXCJib3VuZHMudXBwZXJMZWZ0LnhcIikraXRlbVNpemUxICwgbW9kZWwuZ2V0KFwiYm91bmRzLnVwcGVyTGVmdC55XCIpK2l0ZW1TaXplMV07XHJcbiAgICAgICAgdmFyIHRpdGxlID0gdGhpcy5kcmF3VGV4dChtb2RlbC5nZXQoXCJwcm9wZXJ0aWVzLm5hbWVcIikpO1xyXG4gICAgICAgIHRpdGxlLnRleHQubmFtZSA9IFwiVGl0bGVcIjtcclxuICAgICAgICB0aGlzLmFkZCh0aXRsZS50ZXh0KTtcclxuICAgIH07XHJcblxyXG5cdHpyVXRpbC5pbmhlcml0cyhJbmNsdXNpdmVHYXRld2F5Tm9kZSwgR2F0ZXdheU5vZGUpO1xyXG5cdG1vZHVsZS5leHBvcnRzID0gSW5jbHVzaXZlR2F0ZXdheU5vZGU7XHJcblxyXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vbGliL2Zpc2gtdG9wby1icG1uL2xpYi9ub2RlL2dhdGV3YXkvSW5jbHVzaXZlR2F0ZXdheU5vZGUuanNcbiAqKiBtb2R1bGUgaWQgPSA5MVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy/miYDmnIlHYXRlV2F56IqC54K555qE5Z+657G7XHJcblxyXG4gICAgdmFyIEJQTU5Ob2RlID0gcmVxdWlyZShcIi4uL0JQTU5Ob2RlXCIpO1xyXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xyXG4gICAgdmFyIEJvdW5kaW5nUmVjdCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvQm91bmRpbmdSZWN0LmpzJyk7XHJcbiAgICAvL+WIm+W7uk5vZGXnsbsg5omA5pyJ5b2i54q26YO957un5om/Tm9kZSAg5YyF5ousZnJvbUpTT04gdG9KU09OXHJcbiAgICAvL1xyXG4gICAgZnVuY3Rpb24gR2F0ZXdheU5vZGUobW9kZWwsIGFwaSkge1xyXG4gICAgICAgIEJQTU5Ob2RlLmNhbGwodGhpcywgbW9kZWwsIGFwaSk7XHJcbiAgICAgICAgdGhpcy5icG1uSW5mbyA9IHt0eXBlOiAtMSwgbmFtZTpcIkdhdGV3YXlOb2RlXCIgfTsgICAgLy/oioLngrnkv6Hmga9cclxuICAgICAgICB0aGlzLm1vZGVsID0gbW9kZWw7XHJcbiAgICB9XHJcblxyXG4gICAgR2F0ZXdheU5vZGUucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uKCkge1xyXG5cclxuICAgIH07XHJcblxyXG4gICAgR2F0ZXdheU5vZGUucHJvdG90eXBlLmdldFJlY3QgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgYm91bmRpbmdSZWN0ID0gdGhpcy5nZXRCb3VuZGluZ1JlY3QoKTtcclxuICAgICAgICAvL+WIm+W7uuacgOWwj+WMheWbtOebkuiZmue6v1xyXG4gICAgICAgIHZhciBwb2ludHMgPSBbXTtcclxuICAgICAgICBwb2ludHNbMF0gPVstYm91bmRpbmdSZWN0LndpZHRoLzIsLWJvdW5kaW5nUmVjdC5oZWlnaHQvMl07XHJcbiAgICAgICAgcG9pbnRzWzFdID1bYm91bmRpbmdSZWN0LndpZHRoLzIsLWJvdW5kaW5nUmVjdC5oZWlnaHQvMl07XHJcbiAgICAgICAgcG9pbnRzWzJdID1bYm91bmRpbmdSZWN0LndpZHRoLzIsYm91bmRpbmdSZWN0LmhlaWdodC8yXTtcclxuICAgICAgICBwb2ludHNbM10gPVstYm91bmRpbmdSZWN0LndpZHRoLzIsYm91bmRpbmdSZWN0LmhlaWdodC8yXTtcclxuICAgICAgICBwb2ludHNbNF0gPVstYm91bmRpbmdSZWN0LndpZHRoLzIsLWJvdW5kaW5nUmVjdC5oZWlnaHQvMl07XHJcbiAgICAgICAgdmFyIGJvdW5kUmVjdCA9IG5ldyBCb3VuZGluZ1JlY3QodGhpcy5wb3NpdGlvblswXSAtIGJvdW5kaW5nUmVjdC53aWR0aC8yICxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBvc2l0aW9uWzFdIC0gYm91bmRpbmdSZWN0LmhlaWdodC8yLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvdW5kaW5nUmVjdC53aWR0aCwgYm91bmRpbmdSZWN0LmhlaWdodCk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgeDogdGhpcy5wb3NpdGlvblswXSxcclxuICAgICAgICAgICAgeTogdGhpcy5wb3NpdGlvblsxXSxcclxuICAgICAgICAgICAgd2lkdGg6IGJvdW5kaW5nUmVjdC53aWR0aC8yLFxyXG4gICAgICAgICAgICBoZWlnaHQ6IGJvdW5kaW5nUmVjdC5oZWlnaHQvMixcclxuICAgICAgICAgICAgcG9pbnRzOiBwb2ludHMsXHJcbiAgICAgICAgICAgIGJvdW5kaW5nUmVjdDogYm91bmRSZWN0XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICB9O1xyXG4gICAgR2F0ZXdheU5vZGUucHJvdG90eXBlLnNldFBvc2l0aW9uID0gZnVuY3Rpb24ocFgscFkpIHtcclxuICAgICAgICAvLyBib2R5Li4uXHJcbiAgICAgICAgdGhpcy5hdHRyKCdwb3NpdGlvbicsW3BYLHBZXSk7XHJcbiAgICB9O1xyXG4gICAgR2F0ZXdheU5vZGUucHJvdG90eXBlLmdldEJvdW5kaW5nUmVjdCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBwYXRoID0gdGhpcy5jaGlsZE9mTmFtZShcIlBhdGhcIik7XHJcbiAgICAgICAgcmV0dXJuIHBhdGguZ2V0Qm91bmRpbmdSZWN0KCk7XHJcbiAgICB9O1xyXG5cclxuICAgIHpyVXRpbC5pbmhlcml0cyhHYXRld2F5Tm9kZSxCUE1OTm9kZSk7XHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IEdhdGV3YXlOb2RlO1xyXG5cclxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2xpYi9maXNoLXRvcG8tYnBtbi9saWIvbm9kZS9nYXRld2F5L0dhdGV3YXlOb2RlLmpzXG4gKiogbW9kdWxlIGlkID0gOTJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vRXhjbHVzaXZlR2F0ZVdheeiKgueCuVxyXG5cclxuXHR2YXIgR2F0ZXdheU5vZGUgPSByZXF1aXJlKFwiLi9HYXRld2F5Tm9kZVwiKTtcclxuXHR2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XHJcbiAgICB2YXIgZ3JhcGhpYyA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi9maXNoLXRvcG8tY29yZS9saWIvZ3JhcGhpYy5qc1wiKTtcclxuXHJcbi8qKlxyXG4gKiA8ZyBwb2ludGVyLWV2ZW50cz1cImZpbGxcIiBpZD1cInNpZC1GRjBBREZDMC1EM0VDLTQyMzctQUQxNi1BMzYyNzNEMUZFNkRcIiB0aXRsZT1cIlN0YXJ0IGV2ZW50XCI+XHJcbiAqICAgIDxwYXRoIGQ9XCIgTTAgMTkuNTA2MzkzOTY0ICBMMTkuNTA2MzkzOTY0IDAgIEwzOS4wMTI3ODc5NjQgMTkuNTA2MzkzOTY0ICBMMTkuNTA2MzkzOTY0IDM5LjAxMjc4Nzk2NCAgTDAgMTkuNTA2MzkzOTY0ICBMMCAxOS41MDYzOTM5NjQgIHpcIiBpZD1cInNpZC02RDBFOTNEQS0wRTBCLTQ3RjAtQUY4NS0zRjMyMzAzNjc2NTFSZWN0YW5nbGUtMVwiIGZpbGw9XCIjRjZBNjIzXCI+PC9wYXRoPlxyXG4gKiAgICA8cGF0aCBkPVwiIE04LjI3NTg2MjA2OSAxMS45NjU1MTcyNjkwMDAwMDEgIEwxLjQ5OTk5OTk5OSAxMS45NjU1MTcyNjkwMDAwMDEgIEwwIDExLjk2NTUxNzI2OTAwMDAwMSAgTDAgOC45NjU1MTcyMzkgIEwxLjQ5OTk5OTk5OSA4Ljk2NTUxNzIzOSAgTDguMjc1ODYyMDY5IDguOTY1NTE3MjM5ICBMOC4yNzU4NjIwNjkgMS40OTk5OTk5OTkgIEw4LjI3NTg2MjA2OSAwICBMMTEuMjc1ODYyMDY5IDAgIEwxMS4yNzU4NjIwNjkgMS40OTk5OTk5OTkgIEwxMS4yNzU4NjIwNjkgOC45NjU1MTcyMzkgIEwxOC43NDEzNzkyNjkgOC45NjU1MTcyMzkgIEwyMC4yNDEzNzkyNjkgOC45NjU1MTcyMzkgIEwyMC4yNDEzNzkyNjkgMTEuOTY1NTE3MjY5MDAwMDAxICBMMTguNzQxMzc5MjY5IDExLjk2NTUxNzI2OTAwMDAwMSAgTDExLjI3NTg2MjA2OSAxMS45NjU1MTcyNjkwMDAwMDEgIEwxMS4yNzU4NjIwNjkgMTguNzQxMzc5MjY5ICBMMTEuMjc1ODYyMDY5IDIwLjI0MTM3OTI2OSAgTDguMjc1ODYyMDY5IDIwLjI0MTM3OTI2OSAgTDguMjc1ODYyMDY5IDE4Ljc0MTM3OTI2OSAgTDguMjc1ODYyMDY5IDExLjk2NTUxNzI2OTAwMDAwMSAgelwiIGlkPVwic2lkLTFCODhEMkRGLUEwOEYtNDgzNy05MUYyLTkxRjY3QUNBQjI5QUxpbmUtQ29weVwiPjwvcGF0aD5cclxuICogPC9nPlxyXG4gKi9cclxuXHJcblx0ZnVuY3Rpb24gRXhjbHVzaXZlR2F0ZXdheU5vZGUobW9kZWwsIGFwaSkge1xyXG5cdFx0R2F0ZXdheU5vZGUuY2FsbCh0aGlzLCBtb2RlbCwgYXBpKTtcclxuICAgICAgICB0aGlzLnN0YXJ0SWNvbiA9ICdNMCAxOS41MDYzOTM5NjQgIEwxOS41MDYzOTM5NjQgMCAgTDM5LjAxMjc4Nzk2NCAxOS41MDYzOTM5NjQgIEwxOS41MDYzOTM5NjQgMzkuMDEyNzg3OTY0ICBMMCAxOS41MDYzOTM5NjQgIEwwIDE5LjUwNjM5Mzk2NCAgeic7XHJcbiAgICAgICAgdGhpcy5uZXh0SWNvbiA9ICdNMTkuOTA0MTI5MDY0MDAwMDAzIDE3LjY3Njk5Mzk2NDAwMDAwNSAgTDI0Ljk5NzQ1Nzg2NDAwMDAwNSAxMi41ODM2NjQ4NjQwMDAwMDMgIEwyNi4wNTgxMTgwNjQwMDAwMDYgMTEuNTIzMDA0NjY0MDAwMDAyICBMMjguMTc5NDM4NDY0IDEzLjY0NDMyNDk2NDAwMDAwMyAgTDI3LjExODc3ODI2NCAxNC43MDQ5ODUxNjQwMDAwMDIgIEwyMi4wMjU0NDkzNjQwMDAwMDQgMTkuNzk4MzE0MzY0ICBMMjcuMTE4Nzc4MjY0IDI0Ljg5MTY0MzQ2NDAwMDAwNSAgTDI4LjE3OTQzODQ2NCAyNS45NTIzMDM2NjQwMDAwMDYgIEwyNi4wNTgxMTgwNjQwMDAwMDYgMjguMDczNjIzOTY0MDAwMDAzICBMMjQuOTk3NDU3ODY0MDAwMDA1IDI3LjAxMjk2Mzc2NDAwMDAwNiAgTDE5LjkwNDEyOTA2NDAwMDAwMyAyMS45MTk2MzQ3NjQgIEwxNC44MTA4MDAxNjQwMDAwMDMgMjcuMDEyOTYzNzY0MDAwMDA2ICBMMTMuNzUwMTQwMDY0MDAwMDAyIDI4LjA3MzYyMzk2NDAwMDAwMyAgTDExLjYyODgxOTY2NDAwMDAwMyAyNS45NTIzMDM2NjQwMDAwMDYgIEwxMi42ODk0Nzk3NjQwMDAwMDMgMjQuODkxNjQzNDY0MDAwMDA1ICBMMTcuNzgyODA4NzY0MDAwMDAyIDE5Ljc5ODMxNDM2NCAgTDEyLjY4OTQ3OTc2NDAwMDAwMyAxNC43MDQ5ODUxNjQwMDAwMDIgIEwxMS42Mjg4MTk2NjQwMDAwMDMgMTMuNjQ0MzI0OTY0MDAwMDAzICBMMTMuNzUwMTQwMDY0MDAwMDAyIDExLjUyMzAwNDY2NDAwMDAwMiAgTDE0LjgxMDgwMDE2NDAwMDAwMyAxMi41ODM2NjQ4NjQwMDAwMDMgIEwxOS45MDQxMjkwNjQwMDAwMDMgMTcuNjc2OTkzOTY0MDAwMDA1ICB6JztcclxuICAgICAgICB0aGlzLml0ZW1TaXplID0gMjA7XHJcblx0XHR0aGlzLmJwbW5JbmZvID0ge3R5cGU6IDE3LCBuYW1lOlwiRXhjbHVzaXZlR2F0ZXdheVwiIH07ICAgIC8v6IqC54K55L+h5oGvXHJcbiAgICAgICAgdGhpcy5yZW5kZXIobW9kZWwpO1xyXG5cdH1cclxuXHJcbiAgICBFeGNsdXNpdmVHYXRld2F5Tm9kZS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24obW9kZWwpIHtcclxuICAgICAgICB2YXIgaXRlbVNpemUgPSB0aGlzLml0ZW1TaXplKjI7XHJcbiAgICAgICAgdmFyIHJlY3QgPSB7eDotaXRlbVNpemUvMiwgeTogLWl0ZW1TaXplLzIsIHdpZHRoOiBpdGVtU2l6ZSwgaGVpZ2h0Oml0ZW1TaXplfTtcclxuICAgICAgICB2YXIgcGF0aCA9IGdyYXBoaWMubWFrZVBhdGgodGhpcy5zdGFydEljb24sIHtzdHlsZToge2ZpbGw6ICcjRjZBNjIzJ30sejoyfSwgcmVjdCxcImNlbnRlclwiKTtcclxuICAgICAgICBwYXRoLm5hbWUgPSAnUGF0aCc7XHJcbiAgICAgICAgdGhpcy5hZGQocGF0aCk7XHJcbiAgICAgICAgdmFyIGl0ZW1TaXplMSA9IHRoaXMuaXRlbVNpemU7XHJcbiAgICAgICAgdmFyIHJlY3QxID0ge3g6LWl0ZW1TaXplMS8yLCB5OiAtaXRlbVNpemUxLzIsIHdpZHRoOiBpdGVtU2l6ZTEsIGhlaWdodDppdGVtU2l6ZTF9O1xyXG4gICAgICAgIHRoaXMuYWRkKGdyYXBoaWMubWFrZVBhdGgodGhpcy5uZXh0SWNvbiwge3N0eWxlOiB7ZmlsbDogJyNGRkZGRkYnfSx6OjJ9LCByZWN0MSxcImNlbnRlclwiKSk7XHJcbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IFttb2RlbC5nZXQoXCJib3VuZHMudXBwZXJMZWZ0LnhcIikraXRlbVNpemUxICwgbW9kZWwuZ2V0KFwiYm91bmRzLnVwcGVyTGVmdC55XCIpK2l0ZW1TaXplMV07XHJcbiAgICAgICAgdmFyIHRpdGxlID0gdGhpcy5kcmF3VGV4dChtb2RlbC5nZXQoXCJwcm9wZXJ0aWVzLm5hbWVcIikpO1xyXG4gICAgICAgIHRpdGxlLnRleHQubmFtZSA9IFwiVGl0bGVcIjtcclxuICAgICAgICB0aGlzLmFkZCh0aXRsZS50ZXh0KTtcclxuICAgIH07XHJcblxyXG5cdHpyVXRpbC5pbmhlcml0cyhFeGNsdXNpdmVHYXRld2F5Tm9kZSwgR2F0ZXdheU5vZGUpO1xyXG5cdG1vZHVsZS5leHBvcnRzID0gRXhjbHVzaXZlR2F0ZXdheU5vZGU7XHJcblxyXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vbGliL2Zpc2gtdG9wby1icG1uL2xpYi9ub2RlL2dhdGV3YXkvRXhjbHVzaXZlR2F0ZXdheU5vZGUuanNcbiAqKiBtb2R1bGUgaWQgPSA5M1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy9QYXJhbGxlbEdhdGVXYXnoioLngrlcclxuXHJcblx0dmFyIEdhdGV3YXlOb2RlID0gcmVxdWlyZShcIi4vR2F0ZXdheU5vZGVcIik7XHJcblx0dmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xyXG4gICAgdmFyIGdyYXBoaWMgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vZmlzaC10b3BvLWNvcmUvbGliL2dyYXBoaWMuanNcIik7XHJcblxyXG4vKipcclxuICogPGcgcG9pbnRlci1ldmVudHM9XCJmaWxsXCIgaWQ9XCJzaWQtRkYwQURGQzAtRDNFQy00MjM3LUFEMTYtQTM2MjczRDFGRTZEXCIgdGl0bGU9XCJTdGFydCBldmVudFwiPlxyXG4gKiAgICA8cGF0aCBkPVwiIE0wIDE5LjUwNjM5Mzk2NCAgTDE5LjUwNjM5Mzk2NCAwICBMMzkuMDEyNzg3OTY0IDE5LjUwNjM5Mzk2NCAgTDE5LjUwNjM5Mzk2NCAzOS4wMTI3ODc5NjQgIEwwIDE5LjUwNjM5Mzk2NCAgTDAgMTkuNTA2MzkzOTY0ICB6XCIgaWQ9XCJzaWQtNkQwRTkzREEtMEUwQi00N0YwLUFGODUtM0YzMjMwMzY3NjUxUmVjdGFuZ2xlLTFcIiBmaWxsPVwiI0Y2QTYyM1wiPjwvcGF0aD5cclxuICogICAgPHBhdGggZD1cIiBNMTkuOTA0MTI5MDY0MDAwMDAzIDE3LjY3Njk5Mzk2NDAwMDAwNSAgTDI0Ljk5NzQ1Nzg2NDAwMDAwNSAxMi41ODM2NjQ4NjQwMDAwMDMgIEwyNi4wNTgxMTgwNjQwMDAwMDYgMTEuNTIzMDA0NjY0MDAwMDAyICBMMjguMTc5NDM4NDY0IDEzLjY0NDMyNDk2NDAwMDAwMyAgTDI3LjExODc3ODI2NCAxNC43MDQ5ODUxNjQwMDAwMDIgIEwyMi4wMjU0NDkzNjQwMDAwMDQgMTkuNzk4MzE0MzY0ICBMMjcuMTE4Nzc4MjY0IDI0Ljg5MTY0MzQ2NDAwMDAwNSAgTDI4LjE3OTQzODQ2NCAyNS45NTIzMDM2NjQwMDAwMDYgIEwyNi4wNTgxMTgwNjQwMDAwMDYgMjguMDczNjIzOTY0MDAwMDAzICBMMjQuOTk3NDU3ODY0MDAwMDA1IDI3LjAxMjk2Mzc2NDAwMDAwNiAgTDE5LjkwNDEyOTA2NDAwMDAwMyAyMS45MTk2MzQ3NjQgIEwxNC44MTA4MDAxNjQwMDAwMDMgMjcuMDEyOTYzNzY0MDAwMDA2ICBMMTMuNzUwMTQwMDY0MDAwMDAyIDI4LjA3MzYyMzk2NDAwMDAwMyAgTDExLjYyODgxOTY2NDAwMDAwMyAyNS45NTIzMDM2NjQwMDAwMDYgIEwxMi42ODk0Nzk3NjQwMDAwMDMgMjQuODkxNjQzNDY0MDAwMDA1ICBMMTcuNzgyODA4NzY0MDAwMDAyIDE5Ljc5ODMxNDM2NCAgTDEyLjY4OTQ3OTc2NDAwMDAwMyAxNC43MDQ5ODUxNjQwMDAwMDIgIEwxMS42Mjg4MTk2NjQwMDAwMDMgMTMuNjQ0MzI0OTY0MDAwMDAzICBMMTMuNzUwMTQwMDY0MDAwMDAyIDExLjUyMzAwNDY2NDAwMDAwMiAgTDE0LjgxMDgwMDE2NDAwMDAwMyAxMi41ODM2NjQ4NjQwMDAwMDMgIEwxOS45MDQxMjkwNjQwMDAwMDMgMTcuNjc2OTkzOTY0MDAwMDA1ICB6XCIgaWQ9XCJzaWQtOEZDRDZDMDEtQjk3My00QzlDLUE5MEItM0QyQURGQzc1MjE3TGluZVwiIGZpbGw9XCIjRkZGRkZGXCI+PC9wYXRoPlxyXG4gKiA8L2c+XHJcbiAqL1xyXG5cclxuXHRmdW5jdGlvbiBQYXJhbGxlbEdhdGV3YXlOb2RlKG1vZGVsLCBhcGkpIHtcclxuXHRcdEdhdGV3YXlOb2RlLmNhbGwodGhpcywgbW9kZWwsIGFwaSk7XHJcbiAgICAgICAgdGhpcy5zdGFydEljb24gPSAnTTAgMTkuNTA2MzkzOTY0ICBMMTkuNTA2MzkzOTY0IDAgIEwzOS4wMTI3ODc5NjQgMTkuNTA2MzkzOTY0ICBMMTkuNTA2MzkzOTY0IDM5LjAxMjc4Nzk2NCAgTDAgMTkuNTA2MzkzOTY0ICBMMCAxOS41MDYzOTM5NjQgIHonO1xyXG4gICAgICAgIHRoaXMubmV4dEljb24gPSAnTTguMjc1ODYyMDY5IDExLjk2NTUxNzI2OTAwMDAwMSAgTDEuNDk5OTk5OTk5IDExLjk2NTUxNzI2OTAwMDAwMSAgTDAgMTEuOTY1NTE3MjY5MDAwMDAxICBMMCA4Ljk2NTUxNzIzOSAgTDEuNDk5OTk5OTk5IDguOTY1NTE3MjM5ICBMOC4yNzU4NjIwNjkgOC45NjU1MTcyMzkgIEw4LjI3NTg2MjA2OSAxLjQ5OTk5OTk5OSAgTDguMjc1ODYyMDY5IDAgIEwxMS4yNzU4NjIwNjkgMCAgTDExLjI3NTg2MjA2OSAxLjQ5OTk5OTk5OSAgTDExLjI3NTg2MjA2OSA4Ljk2NTUxNzIzOSAgTDE4Ljc0MTM3OTI2OSA4Ljk2NTUxNzIzOSAgTDIwLjI0MTM3OTI2OSA4Ljk2NTUxNzIzOSAgTDIwLjI0MTM3OTI2OSAxMS45NjU1MTcyNjkwMDAwMDEgIEwxOC43NDEzNzkyNjkgMTEuOTY1NTE3MjY5MDAwMDAxICBMMTEuMjc1ODYyMDY5IDExLjk2NTUxNzI2OTAwMDAwMSAgTDExLjI3NTg2MjA2OSAxOC43NDEzNzkyNjkgIEwxMS4yNzU4NjIwNjkgMjAuMjQxMzc5MjY5ICBMOC4yNzU4NjIwNjkgMjAuMjQxMzc5MjY5ICBMOC4yNzU4NjIwNjkgMTguNzQxMzc5MjY5ICBMOC4yNzU4NjIwNjkgMTEuOTY1NTE3MjY5MDAwMDAxICB6JztcclxuICAgICAgICB0aGlzLml0ZW1TaXplID0gMjA7XHJcblx0XHR0aGlzLmJwbW5JbmZvID0ge3R5cGU6IDIwLCBuYW1lOlwiUGFyYWxsZWxHYXRld2F5XCIgfTsgICAgLy/oioLngrnkv6Hmga9cclxuICAgICAgICB0aGlzLnJlbmRlcihtb2RlbCk7XHJcblx0fVxyXG5cclxuICAgIFBhcmFsbGVsR2F0ZXdheU5vZGUucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uKG1vZGVsKSB7XHJcbiAgICAgICAgdmFyIGl0ZW1TaXplID0gdGhpcy5pdGVtU2l6ZSoyO1xyXG4gICAgICAgIHZhciByZWN0ID0ge3g6LWl0ZW1TaXplLzIsIHk6IC1pdGVtU2l6ZS8yLCB3aWR0aDogaXRlbVNpemUsIGhlaWdodDppdGVtU2l6ZX07XHJcbiAgICAgICAgdmFyIHBhdGggPSBncmFwaGljLm1ha2VQYXRoKHRoaXMuc3RhcnRJY29uLCB7c3R5bGU6IHtmaWxsOiAnI0Y2QTYyMyd9LHo6Mn0sIHJlY3QsXCJjZW50ZXJcIik7XHJcbiAgICAgICAgcGF0aC5uYW1lID0gJ1BhdGgnO1xyXG4gICAgICAgIHRoaXMuYWRkKHBhdGgpO1xyXG4gICAgICAgIHZhciBpdGVtU2l6ZTEgPSB0aGlzLml0ZW1TaXplO1xyXG4gICAgICAgIHZhciByZWN0MSA9IHt4Oi1pdGVtU2l6ZTEvMiwgeTogLWl0ZW1TaXplMS8yLCB3aWR0aDogaXRlbVNpemUxLCBoZWlnaHQ6aXRlbVNpemUxfTtcclxuICAgICAgICB0aGlzLmFkZChncmFwaGljLm1ha2VQYXRoKHRoaXMubmV4dEljb24sIHtzdHlsZToge2ZpbGw6ICcjRkZGRkZGJ30sejoyfSwgcmVjdDEsXCJjZW50ZXJcIikpO1xyXG4gICAgICAgIHRoaXMucG9zaXRpb24gPSBbbW9kZWwuZ2V0KFwiYm91bmRzLnVwcGVyTGVmdC54XCIpK2l0ZW1TaXplMSAsIG1vZGVsLmdldChcImJvdW5kcy51cHBlckxlZnQueVwiKStpdGVtU2l6ZTFdO1xyXG4gICAgICAgIHZhciB0aXRsZSA9IHRoaXMuZHJhd1RleHQobW9kZWwuZ2V0KFwicHJvcGVydGllcy5uYW1lXCIpKTtcclxuICAgICAgICB0aXRsZS50ZXh0Lm5hbWUgPSBcIlRpdGxlXCI7XHJcbiAgICAgICAgdGhpcy5hZGQodGl0bGUudGV4dCk7XHJcbiAgICB9O1xyXG5cclxuXHR6clV0aWwuaW5oZXJpdHMoUGFyYWxsZWxHYXRld2F5Tm9kZSwgR2F0ZXdheU5vZGUpO1xyXG5cdG1vZHVsZS5leHBvcnRzID0gUGFyYWxsZWxHYXRld2F5Tm9kZTtcclxuXHJcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9saWIvZmlzaC10b3BvLWJwbW4vbGliL25vZGUvZ2F0ZXdheS9QYXJhbGxlbEdhdGV3YXlOb2RlLmpzXG4gKiogbW9kdWxlIGlkID0gOTRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8v5a2Q5rWB56iLXHJcblxyXG5cdHZhciBCUE1OTm9kZSA9IHJlcXVpcmUoXCIuL0JQTU5Ob2RlXCIpO1xyXG5cdHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcclxuICAgIHZhciBCb3VuZGluZ1JlY3QgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL0JvdW5kaW5nUmVjdC5qcycpO1xyXG4gICAgdmFyIGdyYXBoaWMgPSByZXF1aXJlKFwiLi4vLi4vLi4vZmlzaC10b3BvLWNvcmUvbGliL2dyYXBoaWMuanNcIik7XHJcbiAgICB2YXIgQ29ubmVjdG9yID0gcmVxdWlyZShcIi4uLy4uLy4uL2Zpc2gtdG9wby1jb3JlL2xpYi9zaGFwZXMvQ29ubmVjdG9yLmpzXCIpO1xyXG5cdC8v5Yib5bu6Tm9kZeexuyDmiYDmnInlvaLnirbpg73nu6fmib9Ob2RlXHJcblx0Ly9cclxuXHRmdW5jdGlvbiBTdWJQcm9jZXNzTm9kZShtb2RlbCwgYXBpKSB7XHJcblxyXG5cdFx0QlBNTk5vZGUuY2FsbCh0aGlzLCBtb2RlbCwgYXBpKTtcclxuXHRcdHRoaXMuYnBtbkluZm8gPSB7dHlwZTogLTEsIG5hbWU6XCJTdWJQcm9jZXNzXCIgfTsgICAgLy/oioLngrnkv6Hmga9cclxuICAgICAgICB0aGlzLm1vZGVsID0gbW9kZWw7XHJcbiAgICAgICAgdGhpcy5zbG90ID0gW107XHJcbiAgICAgICAgdGhpcy5zbG90RXZlbnQgPSBbXTtcclxuICAgICAgICB0aGlzLmlzQ2FuU2xvdCA9IHRydWU7XHJcbiAgICAgICAgdmFyIHdpZHRoLGhlaWdodDtcclxuICAgICAgICB3aWR0aCA9IG1vZGVsLmdldChcImJvdW5kcy5sb3dlclJpZ2h0LnhcIiktbW9kZWwuZ2V0KFwiYm91bmRzLnVwcGVyTGVmdC54XCIpO1xyXG4gICAgICAgIGhlaWdodCA9IG1vZGVsLmdldChcImJvdW5kcy5sb3dlclJpZ2h0LnlcIiktbW9kZWwuZ2V0KFwiYm91bmRzLnVwcGVyTGVmdC55XCIpO1xyXG4gICAgICAgIGlmKCF3aWR0aCB8fCB3aWR0aCA8PSAwKXtcclxuICAgICAgICAgICAgd2lkdGggPSAxNjA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmKCFoZWlnaHQgfHwgaGVpZ2h0IDw9IDApe1xyXG4gICAgICAgICAgICBoZWlnaHQgPSAxMDA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLnJlY3RTaXplID0ge3dpZHRoOndpZHRoLCBoZWlnaHQ6aGVpZ2h0fTtcclxuICAgICAgICB0aGlzLnJlbmRlcihtb2RlbCk7XHJcblx0fVxyXG5cclxuXHJcbiAgICBTdWJQcm9jZXNzTm9kZS5wcm90b3R5cGUuaW5pdEV2ZW50ID0gZnVuY3Rpb24oYXBpKSB7XHJcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgICAgIHZhciBNT1VTRV9FVkVOVF9OQU1FUyA9IFsnZGJsY2xpY2snLCAnY2xpY2snXTsvLydjbGljaycsICdkYmxjbGljaycsICdtb3VzZW92ZXInLCAnbW91c2VvdXQnXHJcblxyXG5cclxuICAgICAgICB6clV0aWwuZWFjaChNT1VTRV9FVkVOVF9OQU1FUywgZnVuY3Rpb24gKGV2ZU5hbWUpIHtcclxuICAgICAgICAgICAgdGhhdC5vbihldmVOYW1lLCBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHBhcmFtcyA9IHt9O1xyXG4gICAgICAgICAgICAgICAgcGFyYW1zLmV2ZW50ID0gZTtcclxuICAgICAgICAgICAgICAgIHZhciBjdXJyZW50ID0gZS50YXJnZXQ7XHJcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudC5wYXJlbnQgJiYgIGN1cnJlbnQucGFyZW50IGluc3RhbmNlb2YgQ29ubmVjdG9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcGFyYW1zLnR5cGUgPSBldmVOYW1lO1xyXG4gICAgICAgICAgICAgICAgcGFyYW1zLnRhcmdldCA9IHRoYXQ7XHJcbiAgICAgICAgICAgICAgICBhcGkudHJpZ2dlcihldmVOYW1lLCBwYXJhbXMpO1xyXG4gICAgICAgICAgICB9LCB0aGlzKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIFN1YlByb2Nlc3NOb2RlLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbihtb2RlbCkge1xyXG4gICAgXHR2YXIgcmVjdCA9IG5ldyBncmFwaGljLlJlY3Qoe1xyXG4gICAgICAgICAgICBzaGFwZToge1xyXG4gICAgICAgICAgICAgICAgeDogMC41LFxyXG4gICAgICAgICAgICAgICAgeTogMC41LFxyXG4gICAgICAgICAgICAgICAgd2lkdGg6IHRoaXMucmVjdFNpemUud2lkdGgtMSxcclxuICAgICAgICAgICAgICAgIGhlaWdodDogdGhpcy5yZWN0U2l6ZS5oZWlnaHQtMSxcclxuICAgICAgICAgICAgICAgIHI6IDdcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgc3R5bGU6IHtcclxuXHJcbiAgICAgICAgICAgICAgICBmaWxsOiAnI2Y5ZjlmOScsXHJcbiAgICAgICAgICAgICAgICBzdHJva2U6ICcjYmJiYmJiJ1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB6OjJcclxuICAgICAgICB9KTtcclxuICAgICAgICByZWN0Lm5hbWUgPSBcIlJlY3RcIjtcclxuICAgICAgICB0aGlzLmFkZChyZWN0KTtcclxuICAgICAgICB0aGlzLnBvc2l0aW9uID0gIFttb2RlbC5nZXQoXCJib3VuZHMudXBwZXJMZWZ0LnhcIiksIG1vZGVsLmdldChcImJvdW5kcy51cHBlckxlZnQueVwiKV07XHJcbiAgICAgICAgdmFyIHRpdGxlID0gdGhpcy5kcmF3VGV4dChtb2RlbC5nZXQoXCJwcm9wZXJ0aWVzLm5hbWVcIikpO1xyXG4gICAgICAgIHRpdGxlLnRleHQubmFtZSA9IFwiVGl0bGVcIjtcclxuICAgICAgICB0aGlzLmFkZCh0aXRsZS50ZXh0KTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIFN1YlByb2Nlc3NOb2RlLnByb3RvdHlwZS5nZXRSZWN0ID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgLy8gYm9keS4uLlxyXG4gICAgICAgIHZhciBib3VuZGluZ1JlY3QgPSB0aGlzLmdldEJvdW5kaW5nUmVjdCgpO1xyXG4gICAgICAgIC8v5Yib5bu65pyA5bCP5YyF5Zu055uS6Jma57q/XHJcbiAgICAgICAgdmFyIHBvaW50cyA9IFtdO1xyXG4gICAgICAgIHBvaW50c1swXSA9Wy1ib3VuZGluZ1JlY3Qud2lkdGgvMiwtYm91bmRpbmdSZWN0LmhlaWdodC8yXTtcclxuICAgICAgICBwb2ludHNbMV0gPVtib3VuZGluZ1JlY3Qud2lkdGgvMiwtYm91bmRpbmdSZWN0LmhlaWdodC8yXTtcclxuICAgICAgICBwb2ludHNbMl0gPVtib3VuZGluZ1JlY3Qud2lkdGgvMixib3VuZGluZ1JlY3QuaGVpZ2h0LzJdO1xyXG4gICAgICAgIHBvaW50c1szXSA9Wy1ib3VuZGluZ1JlY3Qud2lkdGgvMixib3VuZGluZ1JlY3QuaGVpZ2h0LzJdO1xyXG4gICAgICAgIHBvaW50c1s0XSA9Wy1ib3VuZGluZ1JlY3Qud2lkdGgvMiwtYm91bmRpbmdSZWN0LmhlaWdodC8yXTtcclxuXHJcbiAgICAgICAgdmFyIGJvdW5kUmVjdCA9IG5ldyBCb3VuZGluZ1JlY3QodGhpcy5wb3NpdGlvblswXSAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wb3NpdGlvblsxXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3VuZGluZ1JlY3Qud2lkdGgsIGJvdW5kaW5nUmVjdC5oZWlnaHQpO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHg6IHRoaXMucG9zaXRpb25bMF0rYm91bmRpbmdSZWN0LndpZHRoLzIsXHJcbiAgICAgICAgICAgIHk6IHRoaXMucG9zaXRpb25bMV0rYm91bmRpbmdSZWN0LmhlaWdodC8yLFxyXG4gICAgICAgICAgICB3aWR0aDogYm91bmRpbmdSZWN0LndpZHRoLFxyXG4gICAgICAgICAgICBoZWlnaHQ6IGJvdW5kaW5nUmVjdC5oZWlnaHQsXHJcbiAgICAgICAgICAgIHBvaW50czogcG9pbnRzLFxyXG4gICAgICAgICAgICBib3VuZGluZ1JlY3Q6IGJvdW5kUmVjdFxyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG5cclxuICAgIFN1YlByb2Nlc3NOb2RlLnByb3RvdHlwZS5zZXRQb3NpdGlvbiA9IGZ1bmN0aW9uKHBYLHBZKSB7XHJcbiAgICAgICAgLy8gYm9keS4uLlxyXG4gICAgICAgIHZhciBib3VuZGluZ1JlY3QgPSB0aGlzLmdldEJvdW5kaW5nUmVjdCgpO1xyXG4gICAgICAgIHRoaXMuYXR0cigncG9zaXRpb24nLFtwWC1ib3VuZGluZ1JlY3Qud2lkdGgvMixwWS1ib3VuZGluZ1JlY3QuaGVpZ2h0LzJdKTtcclxuXHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICBTdWJQcm9jZXNzTm9kZS5wcm90b3R5cGUucmVmcmVzaCA9IGZ1bmN0aW9uKG9wdCkge1xyXG4gICAgICAgIHZhciByZWN0ID0gdGhpcy5jaGlsZE9mTmFtZShcIlJlY3RcIik7XHJcbiAgICAgICAgcmVjdC5zZXRTaGFwZShvcHQuc2hhcGUpO1xyXG4gICAgICAgIHRoaXMuYXR0cigncG9zaXRpb24nLG9wdC5wb3NpdGlvbik7XHJcbiAgICAgICAgdGhpcy5yZWZyZXNoVGV4dCgpO1xyXG4gICAgfTtcclxuXHJcblxyXG5cclxuICAgIFN1YlByb2Nlc3NOb2RlLnByb3RvdHlwZS5nZXRCb3VuZGluZ1JlY3QgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgcmVjdCA9IHRoaXMuY2hpbGRPZk5hbWUoXCJSZWN0XCIpO1xyXG4gICAgICAgIHJldHVybiByZWN0LmdldEJvdW5kaW5nUmVjdCgpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIOagueaNruWxnuaAp+iuvue9ruaooeWei+aVsOaNrlxyXG4gICAgICogQHBhcmFtIHtbdHlwZV19IG9wdGlvbiBbZGVzY3JpcHRpb25dXHJcbiAgICAgKi9cclxuICAgIFN1YlByb2Nlc3NOb2RlLnByb3RvdHlwZS5zZXRNb2RlbCA9IGZ1bmN0aW9uKG9wdGlvbikge1xyXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgICAgICB2YXIgb3JpZ2luVGV4dCA9IHRoaXMubW9kZWwuZ2V0KFwicHJvcGVydGllcy5uYW1lXCIpO1xyXG4gICAgICAgIHRoaXMubW9kZWwubWVyZ2VPcHRpb24ob3B0aW9uKTtcclxuICAgICAgICBpZihvcmlnaW5UZXh0ICE9IG9wdGlvbi5wcm9wZXJ0aWVzLm5hbWUpIHtcclxuICAgICAgICAgICAgdmFyIHRpdGxlID0gdGhpcy5jaGlsZE9mTmFtZShcIlRpdGxlXCIpO1xyXG4gICAgICAgICAgICB2YXIgbmFtZUJ5dGVMZW5ndGggPSBvcHRpb24ucHJvcGVydGllcy5uYW1lLmxlbmd0aDtcclxuICAgICAgICAgICAgdmFyIHNob3dOYW1lO1xyXG4gICAgICAgICAgICBpZihuYW1lQnl0ZUxlbmd0aCA+IDY0KXtcclxuICAgICAgICAgICAgICAgIHNob3dOYW1lID0gb3B0aW9uLnByb3BlcnRpZXMubmFtZS5zdWJzdHIoMCw2NCkrJy4uJztcclxuICAgICAgICAgICAgICAgIHRoaXMuYWxhcm0uaXNTaG93ID0gdHJ1ZTtcclxuICAgICAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgICAgICBzaG93TmFtZSA9IG9wdGlvbi5wcm9wZXJ0aWVzLm5hbWU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFsYXJtLmlzU2hvdyA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRpdGxlLmF0dHIoXCJzdHlsZVwiLHt0ZXh0OnNob3dOYW1lfSk7XHJcbiAgICAgICAgICAgIHRoYXQucmVmcmVzaFRleHQodGhhdCk7XHJcbiAgICAgICAgICAgIHZhciBuYW1lID0gb3B0aW9uLnByb3BlcnRpZXMubmFtZTtcclxuICAgICAgICAgICAgdmFyIHRleHQgPSB0aGlzLmFsYXJtLmNoaWxkT2ZOYW1lKFwiVGV4dFwiKTtcclxuICAgICAgICAgICAgdGV4dC5hdHRyKFwic3R5bGVcIix7dGV4dDpuYW1lfSk7XHJcbiAgICAgICAgICAgIHZhciBncm91cFdpZHRoID0gdGV4dC5nZXRCb3VuZGluZ1JlY3QoKS53aWR0aCs0O1xyXG4gICAgICAgICAgICB2YXIgZ3JvdXBIZWlnaHQgPSB0ZXh0LmdldEJvdW5kaW5nUmVjdCgpLmhlaWdodCs4O1xyXG4gICAgICAgICAgICB2YXIgcG9pbnRzID0gW1xyXG4gICAgICAgICAgICAgICAgWzAsMF0sXHJcbiAgICAgICAgICAgICAgICBbZ3JvdXBXaWR0aCwwXSxcclxuICAgICAgICAgICAgICAgIFtncm91cFdpZHRoLGdyb3VwSGVpZ2h0XSxcclxuICAgICAgICAgICAgICAgIFtncm91cFdpZHRoLTMsZ3JvdXBIZWlnaHRdLFxyXG4gICAgICAgICAgICAgICAgW2dyb3VwV2lkdGgtNixncm91cEhlaWdodCszXSxcclxuICAgICAgICAgICAgICAgIFtncm91cFdpZHRoLTksZ3JvdXBIZWlnaHRdLFxyXG4gICAgICAgICAgICAgICAgWzAsZ3JvdXBIZWlnaHRdLFxyXG4gICAgICAgICAgICAgICAgWzAsMF1cclxuICAgICAgICAgICAgXTtcclxuICAgICAgICAgICAgdmFyIFBvbHlsaW5lID0gdGhpcy5hbGFybS5jaGlsZE9mTmFtZShcIlBvbHlsaW5lXCIpO1xyXG4gICAgICAgICAgICBQb2x5bGluZS5hdHRyKFwic2hhcGVcIix7cG9pbnRzOnBvaW50c30pO1xyXG4gICAgICAgICAgICB2YXIgZ3JvdXBQb3NpdGlvbiA9IFt0aGlzLnBvc2l0aW9uWzBdK3RoaXMuZ2V0Qm91bmRpbmdSZWN0KCkud2lkdGgtKHRoaXMuYWxhcm0uZ2V0Qm91bmRpbmdSZWN0KCkud2lkdGgtNiksdGhpcy5wb3NpdGlvblsxXS10aGlzLmFsYXJtLmdldEJvdW5kaW5nUmVjdCgpLmhlaWdodC0zXTtcclxuICAgICAgICAgICAgdGhpcy5hbGFybS5hdHRyKFwicG9zaXRpb25cIixncm91cFBvc2l0aW9uKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICBTdWJQcm9jZXNzTm9kZS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdGhpcy5tb2RlbC5zZXQoXCJyZXNvdXJjZUlkXCIsIHRoaXMucmVzb3VyY2VJZCk7XHJcbiAgICAgICAgdGhpcy5tb2RlbC5zZXQoXCJwcm9wZXJ0aWVzLnR5cGVcIiwgdGhpcy5icG1uSW5mby50eXBlKTtcclxuICAgICAgICB0aGlzLm1vZGVsLnNldChcInN0ZW5jaWwudHlwZVwiLCB0aGlzLmJwbW5JbmZvLm5hbWUpOyAgLy9zdGVuY2lsLmlkXHJcbiAgICAgICAgaWYgKHRoaXMuc2xvdEV2ZW50ICYmIHRoaXMuc2xvdEV2ZW50Lmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgdmFyIGFyclNsb3RFdmVudCA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gdGhpcy5zbG90RXZlbnQubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgICAgICAgICAgIGFyclNsb3RFdmVudC5wdXNoKHRoaXMuc2xvdEV2ZW50W2ldLnJlc291cmNlSWQpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5tb2RlbC5zZXQoXCJwcm9wZXJ0aWVzLnNsb3RFdmVudFwiLCBhcnJTbG90RXZlbnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAgICAgLy8gdmFyIHJlY3QgPSB0aGlzLmdldFJlY3QoKTtcclxuICAgICAgICAgICAgLy8gdGhpcy5tb2RlbC5zZXQoXCJib3VuZHMudXBwZXJMZWZ0LnhcIiwgcmVjdC54KTtcclxuICAgICAgICAgICAgLy8gdGhpcy5tb2RlbC5zZXQoXCJib3VuZHMudXBwZXJMZWZ0LnlcIiwgcmVjdC55KTtcclxuICAgICAgICAgICAgLy8gdGhpcy5tb2RlbC5zZXQoXCJib3VuZHMubG93ZXJSaWdodC54XCIsIHJlY3QueCArIHJlY3QuYm91bmRpbmdSZWN0LndpZHRoKTtcclxuICAgICAgICAgICAgLy8gdGhpcy5tb2RlbC5zZXQoXCJib3VuZHMubG93ZXJSaWdodC55XCIsIHJlY3QueSArIHJlY3QuYm91bmRpbmdSZWN0LmhlaWdodCk7XHJcblxyXG4gICAgICAgIHZhciByZWN0ID0gdGhpcy5nZXRSZWN0KCkuYm91bmRpbmdSZWN0O1xyXG4gICAgICAgIHRoaXMubW9kZWwuc2V0KFwiYm91bmRzLnVwcGVyTGVmdC54XCIsIHJlY3QueCk7XHJcbiAgICAgICAgdGhpcy5tb2RlbC5zZXQoXCJib3VuZHMudXBwZXJMZWZ0LnlcIiwgcmVjdC55KTtcclxuICAgICAgICB0aGlzLm1vZGVsLnNldChcImJvdW5kcy5sb3dlclJpZ2h0LnhcIiwgcmVjdC54ICsgcmVjdC53aWR0aCk7XHJcbiAgICAgICAgdGhpcy5tb2RlbC5zZXQoXCJib3VuZHMubG93ZXJSaWdodC55XCIsIHJlY3QueSArIHJlY3QuaGVpZ2h0KTtcclxuXHJcblxyXG5cclxuICAgICAgICAvLyDliqDlhaXlrZDmtYHnqIvnmoQg6IqC54K5XHJcbiAgICAgICAgdmFyIGFyckNoaWxkU2FocGVzID0gW107XHJcbiAgICAgICAgdGhpcy5lYWNoQ2hpbGQoZnVuY3Rpb24oY2hpbGQpe1xyXG4gICAgICAgICAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBCUE1OTm9kZSkge1xyXG4gICAgICAgICAgICAgICAgYXJyQ2hpbGRTYWhwZXMucHVzaChjaGlsZC50b0pTT04oKSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIENvbm5lY3Rvcikge1xyXG4gICAgICAgICAgICAgICAgYXJyQ2hpbGRTYWhwZXMucHVzaChjaGlsZC50b0pTT04oKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcblxyXG5cclxuICAgICAgICB0aGlzLm1vZGVsLnNldChcImNoaWxkU2hhcGVzXCIsIGFyckNoaWxkU2FocGVzKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5tb2RlbC5vcHRpb247XHJcbiAgICB9O1xyXG5cclxuXHR6clV0aWwuaW5oZXJpdHMoU3ViUHJvY2Vzc05vZGUsQlBNTk5vZGUpO1xyXG5cdG1vZHVsZS5leHBvcnRzID0gU3ViUHJvY2Vzc05vZGU7XHJcblxyXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vbGliL2Zpc2gtdG9wby1icG1uL2xpYi9ub2RlL1N1YlByb2Nlc3NOb2RlLmpzXG4gKiogbW9kdWxlIGlkID0gOTVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxyXG4gKiDov57mjqXnur9cclxuICogQGF1dGhvciB3YW5nLnhpYW9odVxyXG4gKi9cclxuXHJcbiAgICB2YXIgVXRpbCA9IHJlcXVpcmUoXCIuLi91dGlsLmpzXCIpO1xyXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xyXG4gICAgdmFyIGdyYXBoaWMgPSByZXF1aXJlKFwiLi4vZ3JhcGhpYy5qc1wiKTtcclxuICAgIHZhciBOb2RlID0gcmVxdWlyZShcIi4uL05vZGUuanNcIik7XHJcbiAgICB2YXIgc3ltYm9sVXRpbCA9IHJlcXVpcmUoXCIuL1N5bWJvbC5qc1wiKTtcclxuICAgIHZhciBIYW5kbGUgPSByZXF1aXJlKFwiLi9IYW5kbGUuanNcIik7XHJcbiAgICB2YXIgRWZmZWN0TGluZSA9IHJlcXVpcmUoXCIuL0VmZmVjdExpbmUuanNcIik7XHJcbiAgICB2YXIgQ29ubmVjdGlvblBvaW50ID0gcmVxdWlyZShcIi4vQ29ubmVjdGlvblBvaW50LmpzXCIpO1xyXG4gICAgdmFyIFBvaW50ID0gcmVxdWlyZShcIi4uL1BvaW50LmpzXCIpO1xyXG4gICAgLyoqXHJcbiAgICAgKiDmnoTpgKDlh73mlbBcclxuICAgICAqIEBwYXJhbSB7W3R5cGVdfSBvcHRpb25zIFtkZXNjcmlwdGlvbl1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gQ29ubmVjdG9yKG9wdGlvbnMpIHtcclxuICAgICAgICBOb2RlLmNhbGwodGhpcyk7XHJcbiAgICAgICAgdGhpcy5yZXNvdXJjZUlkID0gVXRpbC5nZXRVVUlEKCk7ICAvLyDnlJ/miJDoioLngrlJRFxyXG4gICAgICAgIHZhciBkZWZhdWx0T3B0aW9ucyA9IHtcclxuICAgICAgICAgICAgc3ltYm9sOiB7dHlwZTpcImFycm93XCIgLCBzaXplOiAxMCwgY29sb3I6XCIjMDAwMDAwXCJ9LCAgLy/nrq3lpLQgIOWPr+mAieWAvOS4uu+8miAnY2lyY2xlJywgJ3JlY3QnLCAncm91bmRSZWN0JywgJ3RyaWFuZ2xlJywgJ2RpYW1vbmQnLCAncGluJywgJ2Fycm93J1xyXG4gICAgICAgICAgICBzdHlsZToge2xpbmVXaWR0aDoxLCBzdHJva2U6XCIjMDAwMDAwXCIsIGxpbmVUeXBlOkNvbm5lY3Rvci5UWVBFX1NUUkFJR0hUfSwgICAgLy/moLflvI9cclxuICAgICAgICAgICAgaG92ZXJTdHlsZToge2xpbmVXaWR0aDoyLCBzdHJva2U6XCJsaW1lXCJ9LCAvL+enu+S4iuWOu+eahOagt+W8j1xyXG4gICAgICAgICAgICBhcnJvd0hvdmVyU3R5bGU6IHtmaWxsOlwibGltZVwifSxcclxuICAgICAgICAgICAgc2hhcGU6IHtwb2ludHM6bnVsbCwgc21vb3RoOmZhbHNlLCBzbW9vdGhDb25zdHJhaW50Om51bGx9LC8v5b2i54q2XHJcbiAgICAgICAgICAgIHBvc2l0aW9uOiBbMCwwXSxcclxuICAgICAgICAgICAgaXNFZGl0OiB0cnVlLCAgLy/mmK/lkKblj6/nvJbovpFcclxuICAgICAgICAgICAgdGV4dDoge1xyXG4gICAgICAgICAgICAgICAgdGV4dDogXCJcIixcclxuICAgICAgICAgICAgICAgIGNvbG9yOiAnIzAwMDAwMCcsIC8vIOaWh+acrOminOiJslxyXG4gICAgICAgICAgICAgICAgdGV4dEZvbnQ6ICcxMnB4IE1pY3Jvc29mdCBZYUhlaSdcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgejogMFxyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgb3B0ID0gb3B0aW9ucyB8fCB7fTtcclxuICAgICAgICB0aGlzLm9wdGlvbnMgPSB6clV0aWwubWVyZ2UoZGVmYXVsdE9wdGlvbnMsIG9wdCwgdHJ1ZSk7XHJcbiAgICAgICAgdGhpcy5tb2RlbCA9IG9wdGlvbnMubW9kZWw7XHJcbiAgICAgICAgdGhpcy5oYW5kbGVzID0gW107XHJcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uUG9pbnRzID0gW107XHJcbiAgICAgICAgdGhpcy5jb25Qb2ludHNHcm91cCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5zdGFydE5vZGUgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuZW5kTm9kZSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5saW5lID0gbnVsbDtcclxuICAgICAgICB0aGlzLmdyb3VwQ3VydmUgPSBuZXcgZ3JhcGhpYy5Hcm91cCgpO1xyXG4gICAgICAgIHRoaXMuaWNvbnMgPSBbXTsgIC8vIOeUqOS6juWtmOWCqOe6v+auteS4iumdoueahOaTjeS9nOWbvuagh1xyXG4gICAgICAgIHRoaXMucmVuZGVyKCk7XHJcbiAgICB9XHJcblxyXG4gICAgQ29ubmVjdG9yLlRZUEVfU1RSQUlHSFQgPSAnc3RyYWlnaHQnO1xyXG5cclxuICAgIENvbm5lY3Rvci5UWVBFX0pBR0dFRCA9ICdqYWdnZWQnO1xyXG5cclxuICAgIENvbm5lY3Rvci5UWVBFX0NVUlZFID0gJ2N1cnZlJztcclxuXHJcbiAgICBDb25uZWN0b3IuUkFESVVTID0gMztcclxuXHJcbiAgICBDb25uZWN0b3IuU1RBUlRfTk9ERSA9IFwic3RhcnROb2RlXCI7XHJcblxyXG4gICAgQ29ubmVjdG9yLkVORF9OT0RFID0gXCJlbmROb2RlXCI7XHJcblxyXG4gICAgQ29ubmVjdG9yLkxFRlQgPSBcImxlZnRcIjtcclxuXHJcbiAgICBDb25uZWN0b3IuUklHSFQgPSBcInJpZ2h0XCI7XHJcblxyXG4gICAgQ29ubmVjdG9yLlRPUCA9IFwidG9wXCI7XHJcblxyXG4gICAgQ29ubmVjdG9yLkJPVFRPTSA9IFwiYm90dG9tXCI7XHJcblxyXG4gICAgQ29ubmVjdG9yLkJPVFRPTSA9IFwiYm90dG9tXCI7XHJcblxyXG4gICAgQ29ubmVjdG9yLlNFUEVSQVRPUiA9IFwiLVwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiDph43mlrDnlLvnur/vvIzlpoLmnpzkvKDnqbrliJnmoLnmja50dXJuaW5nUG9pbnRzIOmHjeaWsOeUu+e6v1xyXG4gICAgICogQHBhcmFtICB7W3R5cGVdfSBwb2ludHMgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICogQHJldHVybiB7W3R5cGVdfSAgICAgICAgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICovXHJcbiAgICBDb25uZWN0b3IucHJvdG90eXBlLnJlZnJlc2ggPSBmdW5jdGlvbihwb2ludHMpIHtcclxuICAgICAgICBpZihwb2ludHMpIHtcclxuICAgICAgICAgICAgdGhpcy50dXJuaW5nUG9pbnRzID0gcG9pbnRzO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvL+Wwhlt4OjAseTowXei9rOWMluS4ulswLCAwXSAg57uZenJlbmRlcuS9v+eUqFxyXG4gICAgICAgIHZhciBwb2ludHMgPSBVdGlsLnRyYXNsYXRlUG9pbnRzKHRoaXMudHVybmluZ1BvaW50cyk7XHJcblxyXG4gICAgICAgIGlmKCh0aGlzLm9wdGlvbnMuc3R5bGUubGluZVR5cGUgPT0gQ29ubmVjdG9yLlRZUEVfQ1VSVkUpICYmIChwb2ludHMubGVuZ3RoID4gMikpIHtcclxuICAgICAgICAgICAgdGhpcy5tb2RpZnlDdXJ2ZSh0aGlzLnR1cm5pbmdQb2ludHMpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMubGluZS5hdHRyKCdzaGFwZScsIHtwb2ludHM6IHBvaW50c30pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGxpbmVUZXh0ID0gdGhpcy5jaGlsZE9mTmFtZSgnbGluZVRleHQnKTtcclxuICAgICAgICAvL+W8gOWni+ayoeacieWIm+W7uuaWh+acrO+8jOWQjuadpeS8oOi/m+adpXRleHTkuobvvIzpnIDopoHlhYjliJvlu7rmlofmnKxcclxuICAgICAgICBpZiAoIWxpbmVUZXh0ICAmJiB0aGlzLm9wdGlvbnMudGV4dC50ZXh0KSB7XHJcbiAgICAgICAgICAgIHZhciB0ZXh0ID0gdGhpcy5kcmF3VGV4dChcImxpbmVUZXh0XCIsIHRoaXMub3B0aW9ucy50ZXh0LnRleHQsMCwgMCk7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkKHRleHQudGV4dCk7XHJcbiAgICAgICAgICAgIGxpbmVUZXh0ID0gdGhpcy5jaGlsZE9mTmFtZSgnbGluZVRleHQnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGxpbmVUZXh0KSB7XHJcbiAgICAgICAgICAgIGxpbmVUZXh0LnNldFN0eWxlKFwidGV4dFwiLCB0aGlzLm9wdGlvbnMudGV4dC50ZXh0KTtcclxuXHJcbiAgICAgICAgICAgIHZhciB0ZXh0UG9pbnQgPSB0aGlzLmdldFRleHRQb3N0aW9uKHRoaXMub3B0aW9ucy50ZXh0KTtcclxuXHJcbiAgICAgICAgICAgIC8vIGlmICh0aGlzLm9wdGlvbnMuc3R5bGUubGluZVR5cGUgPT0gQ29ubmVjdG9yLlRZUEVfU1RSQUlHSFQgKSB7XHJcbiAgICAgICAgICAgIC8vICAgICBsaW5lVGV4dC5hdHRyKCdyb3RhdGlvbicsIHRoaXMuZ2V0VGV4dFJvdGF0aW9uKHRleHRQb2ludCkpO1xyXG4gICAgICAgICAgICAvLyB9XHJcblxyXG4gICAgICAgICAgICBsaW5lVGV4dC5hdHRyKFwicG9zaXRpb25cIiwgdGV4dFBvaW50KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHN5bWJvbFRvID0gdGhpcy5jaGlsZE9mTmFtZSgndG9TeW1ib2wnKTtcclxuICAgICAgICBpZihzeW1ib2xUbykge1xyXG4gICAgICAgICAgICBpZih0aGlzLm9wdGlvbnMuZWZmZWN0JiZ0aGlzLm9wdGlvbnMuZWZmZWN0LnNob3cpe1xyXG4gICAgICAgICAgICAgICAgbmV3IEVmZmVjdExpbmUoc3ltYm9sVG8sdGhpcy5vcHRpb25zLHRoaXMuZ3JvdXBDdXJ2ZSx0aGlzLnBvbHlMaW5lKTtcclxuICAgICAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgICAgICBzeW1ib2xUby5hdHRyKCdwb3NpdGlvbicsIHBvaW50c1twb2ludHMubGVuZ3RoIC0xXSk7XHJcbiAgICAgICAgICAgICAgICBzeW1ib2xUby5hdHRyKCdyb3RhdGlvbicsIFV0aWwudGFuZ2VudFJvdGF0aW9uKHRoaXMudHVybmluZ1BvaW50c1t0aGlzLnR1cm5pbmdQb2ludHMubGVuZ3RoLTJdLCB0aGlzLnR1cm5pbmdQb2ludHNbdGhpcy50dXJuaW5nUG9pbnRzLmxlbmd0aC0xXSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiDmuLLmn5NcclxuICAgICAqIEByZXR1cm4ge1t0eXBlXX0gW2Rlc2NyaXB0aW9uXVxyXG4gICAgICovXHJcbiAgICBDb25uZWN0b3IucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgICAgICAvLzEu5Yib5bu6566t5aS0XHJcbiAgICAgICAgdmFyIHN5bWJvbFRvID0gdGhpcy5jcmVhdGVTeW1ib2woJ3RvU3ltYm9sJywgdGhpcy5vcHRpb25zKTsgLy9hcnJvdyx0cmlhbmdsZVxyXG4gICAgICAgIGlmIChzeW1ib2xUbykge1xyXG4gICAgICAgICAgICB0aGlzLmFkZChzeW1ib2xUbyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLzIu5Yib5bu657q/XHJcbiAgICAgICAgdGhpcy5jdXJ2ZUxpbmUgPSBuZXcgZ3JhcGhpYy5CZXppZXJDdXJ2ZSh7XHJcbiAgICAgICAgICAgIHBvc2l0aW9uOiB0aGlzLm9wdGlvbnMucG9zaXRpb24sXHJcbiAgICAgICAgICAgIHN0eWxlOiB0aGlzLm9wdGlvbnMuc3R5bGUsXHJcbiAgICAgICAgICAgIHo6IHRoaXMub3B0aW9ucy56XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5ncm91cEN1cnZlLmFkZCh0aGlzLmN1cnZlTGluZSk7XHJcbiAgICAgICAgdGhpcy5hZGQodGhpcy5ncm91cEN1cnZlKTtcclxuXHJcbiAgICAgICAgdGhpcy5wb2x5TGluZSA9IG5ldyBncmFwaGljLlBvbHlsaW5lKHtcclxuICAgICAgICAgICAgcG9zaXRpb246IHRoaXMub3B0aW9ucy5wb3NpdGlvbixcclxuICAgICAgICAgICAgc2hhcGU6IHRoaXMub3B0aW9ucy5zaGFwZSxcclxuICAgICAgICAgICAgc3R5bGU6IHRoaXMub3B0aW9ucy5zdHlsZSxcclxuICAgICAgICAgICAgejogdGhpcy5vcHRpb25zLnpcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmFkZCh0aGlzLnBvbHlMaW5lKTtcclxuXHJcbiAgICAgICAgaWYoKHRoaXMub3B0aW9ucy5zdHlsZS5saW5lVHlwZSA9PSBDb25uZWN0b3IuVFlQRV9DVVJWRSkpIHtcclxuICAgICAgICAgICAgdGhpcy5saW5lID0gdGhpcy5ncm91cEN1cnZlO1xyXG4gICAgICAgICAgICB0aGlzLmNyZWF0ZUhvdmVyU3R5bGUodGhpcy5jdXJ2ZUxpbmUpO1xyXG4gICAgICAgICAgICB0aGlzLnBvbHlMaW5lLmhpZGUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMubGluZSA9IHRoaXMucG9seUxpbmU7XHJcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlSG92ZXJTdHlsZSh0aGlzLnBvbHlMaW5lKTtcclxuICAgICAgICAgICAgdGhpcy5jdXJ2ZUxpbmUuaGlkZSgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8zLuS+puWQrOe6v+S6i+S7tlxyXG4gICAgICAgIHZhciBNT1VTRV9FVkVOVF9OQU1FUyA9IFsnZGJsY2xpY2snLCAnY2xpY2snXTsvLydjbGljaycsICdkYmxjbGljaycsICdtb3VzZW92ZXInLCAnbW91c2VvdXQnXHJcbiAgICAgICAgenJVdGlsLmVhY2goTU9VU0VfRVZFTlRfTkFNRVMsIGZ1bmN0aW9uIChldmVOYW1lKSB7XHJcbiAgICAgICAgICAgIHRoaXMubGluZS5vbihldmVOYW1lLCB6clV0aWwuYmluZChmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAgICAgZS5jYW5jZWxCdWJibGUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgdmFyIHBhcmFtcyA9IHt9O1xyXG4gICAgICAgICAgICAgICAgcGFyYW1zLmV2ZW50ID0gZTtcclxuICAgICAgICAgICAgICAgIHBhcmFtcy50eXBlID0gXCJDb25uZWN0b3I6XCIgKyBldmVOYW1lO1xyXG4gICAgICAgICAgICAgICAgcGFyYW1zLnRhcmdldCA9IHRoYXQ7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXIocGFyYW1zLnR5cGUsIHBhcmFtcyk7XHJcbiAgICAgICAgICAgICAgICBpZih0aGlzLm9wdGlvbnMuaXNFZGl0ID09IGZhbHNlKXtyZXR1cm47fVxyXG5cclxuICAgICAgICAgICAgICAgIGlmKHRoaXMub3B0aW9ucy5pc0VkaXQgJiYgdGhpcy5jb25uZWN0aW9uUG9pbnRzLmxlbmd0aCA8IDEgJiYgdGhpcy50dXJuaW5nUG9pbnRzLmxlbmd0aCA+PTIpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNyZWF0ZUFsbGNvbm5lY3Rpb25Qb2ludCgpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZih0aGlzLmhhbmRsZXMubGVuZ3RoIDwgMSApIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNoYXBlU2V0SGFuZGxlKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sIHRoaXMpKTtcclxuICAgICAgICB9LCB0aGlzKTtcclxuXHJcbiAgICAgICAgLy8zLuWIm+W7uuiwg+aVtOe6v+eahOi/nuaOpeeCuVxyXG4gICAgICAgIGlmKHRoaXMub3B0aW9ucy5pc0VkaXQpIHtcclxuICAgICAgICAgICAgdGhpcy5jb25Qb2ludHNHcm91cCA9IG5ldyBncmFwaGljLkdyb3VwKCk7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkKHRoaXMuY29uUG9pbnRzR3JvdXApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy80LuWIm+W7uue6v+S4iuaWh+acrFxyXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMudGV4dC50ZXh0ICYmIHRoaXMub3B0aW9ucy50ZXh0LnRleHQgIT0gXCJcIikge1xyXG4gICAgICAgICAgICB2YXIgdGV4dCA9IHRoaXMuZHJhd1RleHQoXCJsaW5lVGV4dFwiLCB0aGlzLm9wdGlvbnMudGV4dC50ZXh0LDAsIDApO1xyXG4gICAgICAgICAgICB0aGlzLmFkZCh0ZXh0LnRleHQpO1xyXG4gICAgICAgIH1cclxuXHJcblxyXG4gICAgfTtcclxuXHJcbiAgICAvL+iuvue9rnN0eWxlXHJcbiAgICBDb25uZWN0b3IucHJvdG90eXBlLnNldFN0eWxlID0gZnVuY3Rpb24ob3B0aW9ucykge1xyXG4gICAgICAgIGlmKG9wdGlvbnMuY29sb3Ipe1xyXG4gICAgICAgICAgICBpZih0aGlzLm9wdGlvbnMuc3R5bGUubGluZVR5cGUgPT0gQ29ubmVjdG9yLlRZUEVfQ1VSVkUpe1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ncm91cEN1cnZlLmVhY2hDaGlsZChmdW5jdGlvbihjdXJ2ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnZlLmF0dHIoXCJzdHlsZVwiLHtzdHJva2U6b3B0aW9ucy5jb2xvcn0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGdyYXBoaWMuc2V0Tm9ybWFsU3R5bGUoY3VydmUsIHtzdHJva2U6b3B0aW9ucy5jb2xvcn0pO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wb2x5TGluZS5hdHRyKFwic3R5bGVcIix7c3Ryb2tlOm9wdGlvbnMuY29sb3J9KTtcclxuICAgICAgICAgICAgICAgIGdyYXBoaWMuc2V0Tm9ybWFsU3R5bGUodGhpcy5wb2x5TGluZSwge3N0cm9rZTpvcHRpb25zLmNvbG9yfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHN5bWJvbFRvID0gdGhpcy5jaGlsZE9mTmFtZSgndG9TeW1ib2wnKTtcclxuICAgICAgICAgICAgaWYgKHN5bWJvbFRvKSB7XHJcbiAgICAgICAgICAgICAgICBzeW1ib2xUby5hdHRyKFwic3R5bGVcIix7ZmlsbDpvcHRpb25zLmNvbG9yfSk7XHJcbiAgICAgICAgICAgICAgICBncmFwaGljLnNldE5vcm1hbFN0eWxlKHN5bWJvbFRvLCB7ZmlsbDpvcHRpb25zLmNvbG9yfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5vcHRpb25zLnN0eWxlLnN0cm9rZSA9IG9wdGlvbnMuY29sb3I7XHJcbiAgICAgICAgICAgIHRoaXMubW9kZWwuc2V0KFwib3B0aW9ucy5zdHlsZS5zdHJva2VcIiwgb3B0aW9ucy5jb2xvcik7XHJcbiAgICAgICAgICAgIHRoaXMubW9kZWwuc2V0KFwib3B0aW9ucy5zeW1ib2wuY29sb3JcIiwgb3B0aW9ucy5jb2xvcik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZihvcHRpb25zLnRleHQpe1xyXG4gICAgICAgICAgICAgdmFyIGxpbmVUZXh0ID0gdGhpcy5jaGlsZE9mTmFtZSgnbGluZVRleHQnKTtcclxuICAgICAgICAgICAgLy/lvIDlp4vmsqHmnInliJvlu7rmlofmnKzvvIzlkI7mnaXkvKDov5vmnaV0ZXh05LqG77yM6ZyA6KaB5YWI5Yib5bu65paH5pysXHJcbiAgICAgICAgICAgIGlmICghbGluZVRleHQgICYmIG9wdGlvbnMudGV4dC50ZXh0KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdGV4dCA9IHRoaXMuZHJhd1RleHQoXCJsaW5lVGV4dFwiLCBvcHRpb25zLnRleHQudGV4dCwwLCAwKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuYWRkKHRleHQudGV4dCk7XHJcbiAgICAgICAgICAgICAgICBsaW5lVGV4dCA9IHRoaXMuY2hpbGRPZk5hbWUoJ2xpbmVUZXh0Jyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmKG9wdGlvbnMudGV4dC50ZXh0IHx8IG9wdGlvbnMudGV4dC50ZXh0ID09IFwiXCIpe1xyXG4gICAgICAgICAgICAgICAgbGluZVRleHQuc2V0U3R5bGUoXCJ0ZXh0XCIsIG9wdGlvbnMudGV4dC50ZXh0KTtcclxuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy50ZXh0LnRleHQgPSBvcHRpb25zLnRleHQudGV4dDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgdGV4dFBvaW50ID0gdGhpcy5nZXRUZXh0UG9zdGlvbihvcHRpb25zLnRleHQpO1xyXG4gICAgICAgICAgICBsaW5lVGV4dC5hdHRyKFwicG9zaXRpb25cIiwgdGV4dFBvaW50KTtcclxuICAgICAgICAgICAgaWYob3B0aW9ucy50ZXh0LnRleHRQb3Mpe1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLnRleHQudGV4dFBvcyA9IG9wdGlvbnMudGV4dC50ZXh0UG9zO1xyXG4gICAgICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy50ZXh0LnRleHRQb3MgPSAnY2VudGVyJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZihvcHRpb25zLnRleHQuY29sb3Ipe1xyXG4gICAgICAgICAgICAgICAgbGluZVRleHQuYXR0cihcInN0eWxlXCIse1xyXG4gICAgICAgICAgICAgICAgICAgIGZpbGw6IG9wdGlvbnMudGV4dC5jb2xvclxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMudGV4dC5jb2xvciA9IG9wdGlvbnMudGV4dC5jb2xvcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLm1vZGVsLnNldChcIm9wdGlvbnMudGV4dFwiLCBvcHRpb25zLnRleHQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICog6I635Y+W57q/5q6155qE5L2N572uXHJcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IHRleHQge3RleHQ6JycsIGNvbG9yOicnLCB0ZXh0UG9zOicnfVxyXG4gICAgICogQHJldHVybiB7T2JqZWN0fSAgICAgIHt4LHl9XHJcbiAgICAgKi9cclxuICAgIENvbm5lY3Rvci5wcm90b3R5cGUuZ2V0VGV4dFBvc3Rpb24gPSBmdW5jdGlvbih0ZXh0KSB7XHJcbiAgICAgICAgdmFyIHRleHRQb3N0aW9uID0gW107XHJcbiAgICAgICAgdmFyIHRleHRXaWR0aCA9IGdyYXBoaWMudGV4dENvbnRhaW4uZ2V0V2lkdGgodGV4dC50ZXh0LCB0ZXh0LnRleHRGb250KTtcclxuICAgICAgICBpZih0ZXh0JiZ0ZXh0LnRleHRQb3Mpe1xyXG4gICAgICAgICAgICBpZih0ZXh0LnRleHRQb3MgPT0gJ3N0YXJ0Jyl7XHJcbiAgICAgICAgICAgICAgICB2YXIgeE9mZnNldCA9IHRleHQueE9mZnNldCB8fCAwO1xyXG4gICAgICAgICAgICAgICAgdGV4dFBvc3Rpb24gPSBbdGhpcy50dXJuaW5nUG9pbnRzWzBdLnggKyB4T2Zmc2V0LHRoaXMudHVybmluZ1BvaW50c1swXS55XTtcclxuICAgICAgICAgICAgfWVsc2UgaWYodGV4dC50ZXh0UG9zID09ICdlbmQnKXtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc3R5bGUubGluZVR5cGUgPT0gQ29ubmVjdG9yLlRZUEVfU1RSQUlHSFQgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBvaW50cyAgPSBVdGlsLmdldE1heExpbmVMZW5ndGgodGhpcy50dXJuaW5nUG9pbnRzKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFuZ2xlID0gVXRpbC5nZXRBbmdsZShwb2ludHNbMF0scG9pbnRzWzFdKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbGVuZ3RoID0gIFV0aWwuZGlzdGFuY2UocG9pbnRzWzBdLHBvaW50c1sxXSkgLSB0ZXh0V2lkdGg7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5ld1BvaW50ID0gVXRpbC5nZXRFbmRQb2ludChwb2ludHNbMF0sIGxlbmd0aCwgYW5nbGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRleHRQb3N0aW9uID0gW25ld1BvaW50LngsbmV3UG9pbnQueV07XHJcbiAgICAgICAgICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgICAgICAgICB0ZXh0UG9zdGlvbiA9IFt0aGlzLnR1cm5pbmdQb2ludHNbdGhpcy50dXJuaW5nUG9pbnRzLmxlbmd0aC0xXS54LHRoaXMudHVybmluZ1BvaW50c1t0aGlzLnR1cm5pbmdQb2ludHMubGVuZ3RoLTFdLnldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgICAgIHRleHRQb3N0aW9uID0gdGhpcy5taWRkbGUodGV4dCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgdmFyIHBvc2l0aW9uID0gdGhpcy5taWRkbGUodGV4dCk7XHJcbiAgICAgICAgICAgIHRleHRQb3N0aW9uID0gW3Bvc2l0aW9uWzBdLXRleHRXaWR0aC8yLHBvc2l0aW9uWzFdXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0ZXh0UG9zdGlvbjtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDojrflj5bnur/mrrXnmoTml4vovazop5LluqZcclxuICAgICAqIEBwYXJhbSAge09iamVjdH0gdGV4dFBvc3Rpb24ge3gseX1cclxuICAgICAqIEByZXR1cm4ge051bWJlcn0gICAgICAgICAgICAg6KeS5bqm5YC8XHJcbiAgICAgKi9cclxuICAgIENvbm5lY3Rvci5wcm90b3R5cGUuZ2V0VGV4dFJvdGF0aW9uID0gZnVuY3Rpb24odGV4dFBvc3Rpb24pIHtcclxuICAgICAgICAvL+iuoeeul+WHuuaegeWdkOagh+eahOinkuW6plxyXG4gICAgICAgIHZhciBwb2ludHMgID0gVXRpbC5nZXRNYXhMaW5lTGVuZ3RoKHRoaXMudHVybmluZ1BvaW50cyk7XHJcbiAgICAgICAgdmFyIGFuZ2xlID0gLSBNYXRoLmF0YW4yKHBvaW50c1sxXS55IC0gdGV4dFBvc3Rpb25bMV0sIHBvaW50c1sxXS54IC0gdGV4dFBvc3Rpb25bMF0pOyAgLy8sTWF0aC5QSS8yXHJcbiAgICAgICAgcmV0dXJuIGFuZ2xlO1xyXG4gICAgfTtcclxuXHJcbiAgICBDb25uZWN0b3IucHJvdG90eXBlLmNyZWF0ZUhvdmVyU3R5bGUgPSBmdW5jdGlvbihlbCkge1xyXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuaG92ZXJTdHlsZSkge1xyXG4gICAgICAgICAgICBncmFwaGljLnNldEVsZW1lbnRIb3ZlclN0bChlbCwgdGhpcy5vcHRpb25zLmhvdmVyU3R5bGUpO1xyXG5cclxuICAgICAgICAgICAgdmFyIHN5bWJvbFRvID0gdGhpcy5jaGlsZE9mTmFtZSgndG9TeW1ib2wnKTtcclxuICAgICAgICAgICAgaWYoc3ltYm9sVG8pe2dyYXBoaWMuc2V0RWxlbWVudEhvdmVyU3RsKHN5bWJvbFRvLCB0aGlzLm9wdGlvbnMuYXJyb3dIb3ZlclN0eWxlKTt9XHJcblxyXG4gICAgICAgICAgICBlbC5vbignbW91c2VvdmVyJywgenJVdGlsLmJpbmQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICBncmFwaGljLmRvRW50ZXJIb3ZlcihlbCk7XHJcbiAgICAgICAgICAgICAgICBpZihzeW1ib2xUbyl7Z3JhcGhpYy5kb0VudGVySG92ZXIoc3ltYm9sVG8pO31cclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLmdyb3VwQ3VydmUuZWFjaENoaWxkKGZ1bmN0aW9uKGxpbmUpIHtcclxuICAgICAgICAgICAgICAgICAgICBncmFwaGljLmRvRW50ZXJIb3ZlcihsaW5lKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9LHRoaXMpKVxyXG4gICAgICAgICAgICAgIC5vbignbW91c2VvdXQnLCB6clV0aWwuYmluZChmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIGdyYXBoaWMuZG9MZWF2ZUhvdmVyKGVsKTtcclxuICAgICAgICAgICAgICAgIGlmKHN5bWJvbFRvKXtncmFwaGljLmRvTGVhdmVIb3ZlcihzeW1ib2xUbyk7fVxyXG4gICAgICAgICAgICAgICAgdGhpcy5ncm91cEN1cnZlLmVhY2hDaGlsZChmdW5jdGlvbihsaW5lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZ3JhcGhpYy5kb0xlYXZlSG92ZXIobGluZSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSx0aGlzKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICog5Yib5bu6Tm9kZeeahOi/nuaOpeeCuVxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJuIHtbdHlwZV19IFtkZXNjcmlwdGlvbl1cclxuICAgICAqL1xyXG4gICAgQ29ubmVjdG9yLnByb3RvdHlwZS5jcmVhdGVBbGxjb25uZWN0aW9uUG9pbnQgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgc1JlY3QgPSB0aGlzLnN0YXJ0Tm9kZS5nZXRSZWN0PyB0aGlzLnN0YXJ0Tm9kZS5nZXRSZWN0KCkuYm91bmRpbmdSZWN0IDogVXRpbC5nZXRSZWN0KHRoaXMuc3RhcnROb2RlKS5ib3VuZGluZ1JlY3Q7XHJcblxyXG4gICAgICAgIHZhciBlUmVjdCA9IHRoaXMuZW5kTm9kZS5nZXRSZWN0PyB0aGlzLmVuZE5vZGUuZ2V0UmVjdCgpLmJvdW5kaW5nUmVjdCA6IFV0aWwuZ2V0UmVjdCh0aGlzLmVuZE5vZGUpLmJvdW5kaW5nUmVjdDtcclxuXHJcbiAgICAgICAgdmFyIHNDb25uZWN0b3JQb2ludCA9IFV0aWwuZ2V0Q29ubmVjdG9yUG9pbnRzKHNSZWN0KTtcclxuICAgICAgICB2YXIgZUNvbm5lY3RvclBvaW50ID0gVXRpbC5nZXRDb25uZWN0b3JQb2ludHMoZVJlY3QpO1xyXG5cclxuICAgICAgICB0aGlzLmNvbm5lY3Rpb25Qb2ludENyZWF0ZSh0aGlzLnN0YXJ0Tm9kZSwgc0Nvbm5lY3RvclBvaW50LmxlZnQsIENvbm5lY3Rvci5TVEFSVF9OT0RFICsgQ29ubmVjdG9yLlNFUEVSQVRPUiArIENvbm5lY3Rvci5MRUZUKTtcclxuICAgICAgICB0aGlzLmNvbm5lY3Rpb25Qb2ludENyZWF0ZSh0aGlzLnN0YXJ0Tm9kZSwgc0Nvbm5lY3RvclBvaW50LnJpZ2h0LCBDb25uZWN0b3IuU1RBUlRfTk9ERSArIENvbm5lY3Rvci5TRVBFUkFUT1IgKyBDb25uZWN0b3IuUklHSFQpO1xyXG4gICAgICAgIHRoaXMuY29ubmVjdGlvblBvaW50Q3JlYXRlKHRoaXMuc3RhcnROb2RlLCBzQ29ubmVjdG9yUG9pbnQudG9wLCBDb25uZWN0b3IuU1RBUlRfTk9ERSArIENvbm5lY3Rvci5TRVBFUkFUT1IgKyBDb25uZWN0b3IuVE9QKTtcclxuICAgICAgICB0aGlzLmNvbm5lY3Rpb25Qb2ludENyZWF0ZSh0aGlzLnN0YXJ0Tm9kZSwgc0Nvbm5lY3RvclBvaW50LmJvdHRvbSwgQ29ubmVjdG9yLlNUQVJUX05PREUgKyBDb25uZWN0b3IuU0VQRVJBVE9SICsgQ29ubmVjdG9yLkJPVFRPTSk7XHJcblxyXG4gICAgICAgIHRoaXMuY29ubmVjdGlvblBvaW50Q3JlYXRlKHRoaXMuZW5kTm9kZSwgZUNvbm5lY3RvclBvaW50LmxlZnQsIENvbm5lY3Rvci5FTkRfTk9ERSArIENvbm5lY3Rvci5TRVBFUkFUT1IgKyBDb25uZWN0b3IuTEVGVCk7XHJcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uUG9pbnRDcmVhdGUodGhpcy5lbmROb2RlLCBlQ29ubmVjdG9yUG9pbnQucmlnaHQsIENvbm5lY3Rvci5FTkRfTk9ERSArIENvbm5lY3Rvci5TRVBFUkFUT1IgKyBDb25uZWN0b3IuUklHSFQpO1xyXG4gICAgICAgIHRoaXMuY29ubmVjdGlvblBvaW50Q3JlYXRlKHRoaXMuZW5kTm9kZSwgZUNvbm5lY3RvclBvaW50LnRvcCwgQ29ubmVjdG9yLkVORF9OT0RFICsgQ29ubmVjdG9yLlNFUEVSQVRPUiArIENvbm5lY3Rvci5UT1ApO1xyXG4gICAgICAgIHRoaXMuY29ubmVjdGlvblBvaW50Q3JlYXRlKHRoaXMuZW5kTm9kZSwgZUNvbm5lY3RvclBvaW50LmJvdHRvbSwgQ29ubmVjdG9yLkVORF9OT0RFICsgQ29ubmVjdG9yLlNFUEVSQVRPUiArIENvbm5lY3Rvci5CT1RUT00pO1xyXG5cclxuXHJcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uUG9pbnRDcmVhdGUodGhpcywgdGhpcy50dXJuaW5nUG9pbnRzWzBdLmNsb25lKCksIENvbm5lY3Rpb25Qb2ludC5UWVBFX0NPTk5FQ1RPUik7XHJcblxyXG4gICAgICAgIHRoaXMuY29ubmVjdGlvblBvaW50Q3JlYXRlKHRoaXMsIHRoaXMudHVybmluZ1BvaW50c1t0aGlzLnR1cm5pbmdQb2ludHMubGVuZ3RoLTFdLmNsb25lKCksIENvbm5lY3Rpb25Qb2ludC5UWVBFX0NPTk5FQ1RPUik7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICog5Yib5bu66L+e5o6l54K5XHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtICB7W3R5cGVdfSBzaGFwZSBbZGVzY3JpcHRpb25dXHJcbiAgICAgKiBAcGFyYW0gIHtbdHlwZV19IHBvaW50IFtkZXNjcmlwdGlvbl1cclxuICAgICAqIEBwYXJhbSAge1t0eXBlXX0gdHlwZSAgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICogQHJldHVybiB7W3R5cGVdfSAgICAgICBbZGVzY3JpcHRpb25dXHJcbiAgICAgKi9cclxuICAgIENvbm5lY3Rvci5wcm90b3R5cGUuY29ubmVjdGlvblBvaW50Q3JlYXRlID0gZnVuY3Rpb24oc2hhcGUsIHBvaW50LCB0eXBlKSB7XHJcbiAgICAgICAgdmFyIGNvblBvaW50ID0gbmV3IENvbm5lY3Rpb25Qb2ludCh0aGlzLCBwb2ludCwgdHlwZSwgdGhpcy5vcHRpb25zKTtcclxuICAgICAgICB0aGlzLmNvblBvaW50c0dyb3VwLmFkZChjb25Qb2ludC5zaGFwZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICog5riF56m65o6n5Yi254K5XHJcbiAgICAgKiBAcmV0dXJuIHtbdHlwZV19IFtkZXNjcmlwdGlvbl1cclxuICAgICAqL1xyXG4gICAgQ29ubmVjdG9yLnByb3RvdHlwZS5jbGVhckhhbmRsZXMgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuaGFuZGxlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB0aGlzLnJlbW92ZSh0aGlzLmhhbmRsZXNbaV0uaGFuZGxlU2hhcGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmhhbmRsZXMgPSBbXTtcclxuICAgICAgICBpZiAodGhpcy5jb25Qb2ludHNHcm91cCkge1xyXG4gICAgICAgICAgICB0aGlzLmNvblBvaW50c0dyb3VwLnJlbW92ZUFsbCgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDliJvlu7rmi4bnur8g57q/5pat55qE5o6n5Yi254K5XHJcbiAgICAgKiBAcmV0dXJuIHtbdHlwZV19IFtkZXNjcmlwdGlvbl1cclxuICAgICAqL1xyXG4gICAgQ29ubmVjdG9yLnByb3RvdHlwZS5zaGFwZVNldEhhbmRsZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGZvcih2YXIgaT0xOyBpPHRoaXMudHVybmluZ1BvaW50cy5sZW5ndGgtMjsgaSsrKXtcclxuICAgICAgICAgICAgdmFyIGg7XHJcbiAgICAgICAgICAgIHZhciB4LCB5O1xyXG4gICAgICAgICAgICAvL+aYr+WQpuWcqOS4gOadoee6v+S4ilxyXG4gICAgICAgICAgICB2YXIgaXNDb2xsaW5lYWl0eUZpcnN0ID0gVXRpbC5jb2xsaW5lYXJpdHkodGhpcy50dXJuaW5nUG9pbnRzW2ktMV0sIHRoaXMudHVybmluZ1BvaW50c1tpXSwgdGhpcy50dXJuaW5nUG9pbnRzW2krMV0pO1xyXG4gICAgICAgICAgICB2YXIgaXNDb2xsaW5lYWl0eVNlY29uZCA9IFV0aWwuY29sbGluZWFyaXR5KHRoaXMudHVybmluZ1BvaW50c1tpXSwgdGhpcy50dXJuaW5nUG9pbnRzW2krMV0sIHRoaXMudHVybmluZ1BvaW50c1tpKzJdKTtcclxuICAgICAgICAgICAgaWYoICghaXNDb2xsaW5lYWl0eUZpcnN0ICYmICghaXNDb2xsaW5lYWl0eVNlY29uZCB8fCB0aGlzLnR1cm5pbmdQb2ludHNbaSsxXS5lcXVhbHModGhpcy50dXJuaW5nUG9pbnRzW2krMl0pKSlcclxuICAgICAgICAgICAgICAgIHx8ICggKCFpc0NvbGxpbmVhaXR5Rmlyc3QgfHwgdGhpcy50dXJuaW5nUG9pbnRzW2ktMV0uZXF1YWxzKHRoaXMudHVybmluZ1BvaW50c1tpXSkpICYmICFpc0NvbGxpbmVhaXR5U2Vjb25kICkpIHtcclxuXHJcbiAgICAgICAgICAgICAgICBpZih0aGlzLnR1cm5pbmdQb2ludHNbaV0ueCA9PT0gdGhpcy50dXJuaW5nUG9pbnRzW2krMV0ueCl7IC8vc2FtZSB2ZXJ0aWNhbFxyXG4gICAgICAgICAgICAgICAgICAgIHggPSB0aGlzLnR1cm5pbmdQb2ludHNbaV0ueDtcclxuICAgICAgICAgICAgICAgICAgICB5ID0gKHRoaXMudHVybmluZ1BvaW50c1tpXS55ICsgdGhpcy50dXJuaW5nUG9pbnRzW2krMV0ueSkgLyAyO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBoID0gbmV3IEhhbmRsZSgnaCcseCx5LHRoaXMpO1xyXG5cclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmKHRoaXMudHVybmluZ1BvaW50c1tpXS55ID09PSB0aGlzLnR1cm5pbmdQb2ludHNbaSsxXS55KXsgLy8gc2FtZSBob3Jpem9udGFsXHJcbiAgICAgICAgICAgICAgICAgICAgeCA9ICh0aGlzLnR1cm5pbmdQb2ludHNbaV0ueCArICB0aGlzLnR1cm5pbmdQb2ludHNbaSsxXS54KSAvIDI7XHJcbiAgICAgICAgICAgICAgICAgICAgeSA9IHRoaXMudHVybmluZ1BvaW50c1tpXS55O1xyXG4gICAgICAgICAgICAgICAgICAgIGggPSAgbmV3ICBIYW5kbGUoJ3YnLHgseSx0aGlzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGQoaC5oYW5kbGVTaGFwZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVzLnB1c2goaCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDliJvlu7rnrq3lpLRcclxuICAgICAqIEBwYXJhbSAge1t0eXBlXX0gbmFtZSAgICAgICBbZGVzY3JpcHRpb25dXHJcbiAgICAgKiBAcGFyYW0gIHtbdHlwZV19IG9wdGlvbnMgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICogQHJldHVybiB7W3R5cGVdfSAgICAgICAgICAgIFtkZXNjcmlwdGlvbl1cclxuICAgICAqL1xyXG4gICAgQ29ubmVjdG9yLnByb3RvdHlwZS5jcmVhdGVTeW1ib2wgPSBmdW5jdGlvbihuYW1lLCBvcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIHN5bWJvbFR5cGUgPSBvcHRpb25zLnN5bWJvbC50eXBlO1xyXG4gICAgICAgIHZhciBzeW1ib2xTaXplID10aGlzLm9wdGlvbnMuc3ltYm9sLnNpemU7XHJcbiAgICAgICAgaWYgKHN5bWJvbFR5cGUgPT09ICdub25lJykge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIXpyVXRpbC5pc0FycmF5KHN5bWJvbFNpemUpKSB7XHJcbiAgICAgICAgICAgIHN5bWJvbFNpemUgPSBbc3ltYm9sU2l6ZSwgc3ltYm9sU2l6ZV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBzeW1ib2xQYXRoID0gc3ltYm9sVXRpbC5jcmVhdGVTeW1ib2woXHJcbiAgICAgICAgICAgIHN5bWJvbFR5cGUsIC1zeW1ib2xTaXplWzBdIC8gMiwgLXN5bWJvbFNpemVbMV0gLyAyLFxyXG4gICAgICAgICAgICBzeW1ib2xTaXplWzBdLCBzeW1ib2xTaXplWzFdLCB0aGlzLm9wdGlvbnMuc3ltYm9sLmNvbG9yLCB0aGlzLm9wdGlvbnMuelxyXG4gICAgICAgICk7XHJcbiAgICAgICAgc3ltYm9sUGF0aC5uYW1lID0gbmFtZTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHN5bWJvbFBhdGg7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICog57uY5Yi257q/5q615LiK55qE5paH5pysXHJcbiAgICAgKiBAcGFyYW0gIHtbdHlwZV19IGNvbnRlbnQgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICogQHBhcmFtICB7W3R5cGVdfSBuYW1lIFtkZXNjcmlwdGlvbl1cclxuICAgICAqIEBwYXJhbSAge1t0eXBlXX0geCAgICAgICBbZGVzY3JpcHRpb25dXHJcbiAgICAgKiBAcGFyYW0gIHtbdHlwZV19IHkgICAgICAgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICogQHBhcmFtICB7W3R5cGVdfSBjb2xvciAgIFtkZXNjcmlwdGlvbl1cclxuICAgICAqIEByZXR1cm4ge1t0eXBlXX0gICAgICAgICBbZGVzY3JpcHRpb25dXHJcbiAgICAgKi9cclxuICAgIENvbm5lY3Rvci5wcm90b3R5cGUuZHJhd1RleHQgPSBmdW5jdGlvbiAobmFtZSxjb250ZW50LCB4LCB5LCBjb2xvcikge1xyXG4gICAgICAgIHZhciB0ZXh0ID0gbmV3IGdyYXBoaWMuVGV4dCh7XHJcbiAgICAgICAgICAgIHN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgICB0ZXh0OiBjb250ZW50LFxyXG4gICAgICAgICAgICAgICAgeDogeCxcclxuICAgICAgICAgICAgICAgIHk6IHksXHJcbiAgICAgICAgICAgICAgICBmaWxsOiBjb2xvciA/IGNvbG9yIDogdGhpcy5vcHRpb25zLnRleHQuY29sb3IsXHJcbiAgICAgICAgICAgICAgICB0ZXh0Rm9udDogdGhpcy5vcHRpb25zLnRleHQudGV4dEZvbnRcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgemxldmVsOiAyMFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRleHQubmFtZSA9IG5hbWU7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgdGV4dDogdGV4dCxcclxuICAgICAgICAgICAgcmVjdDogdGV4dC5nZXRCb3VuZGluZ1JlY3QoKVxyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICog6I635Y+W57q/5q6155qE5Lit6Ze05YC8XHJcbiAgICAgKiBAcmV0dXJuIHtbdHlwZV19IHRleHRcclxuICAgICAqL1xyXG4gICAgQ29ubmVjdG9yLnByb3RvdHlwZS5taWRkbGUgPSBmdW5jdGlvbih0ZXh0KXtcclxuXHJcbiAgICAgICAgaWYodGhpcy5vcHRpb25zLnN0eWxlLmxpbmVUeXBlID09IENvbm5lY3Rvci5UWVBFX1NUUkFJR0hUKXtcclxuICAgICAgICAgICAgdmFyIHBvaW50cyAgPSBVdGlsLmdldE1heExpbmVMZW5ndGgodGhpcy50dXJuaW5nUG9pbnRzKTtcclxuICAgICAgICAgICAgLy/lpoLmnpzmmK/msYLnur/mrrXkuIrnmoTmloflrZfnmoTkuK3pl7TlgLxcclxuICAgICAgICAgICAgLy8gaWYodGV4dCkge1xyXG4gICAgICAgICAgICAvLyAgICAgLy/lj5blh7rlrZfnmoTplb/luqbvvIzorqHnrpfop5LluqbvvIxcclxuICAgICAgICAgICAgLy8gICAgIHZhciB0ZXh0V2lkdGggPSBncmFwaGljLnRleHRDb250YWluLmdldFdpZHRoKHRleHQudGV4dCwgdGV4dC50ZXh0Rm9udCk7XHJcbiAgICAgICAgICAgIC8vICAgICB2YXIgYW5nbGUgPSBVdGlsLmdldEFuZ2xlKHBvaW50c1swXSxwb2ludHNbMV0pO1xyXG4gICAgICAgICAgICAvLyAgICAgdmFyIGxlbmd0aCA9ICBVdGlsLmRpc3RhbmNlKHBvaW50c1swXSxwb2ludHNbMV0pLzIgLSB0ZXh0V2lkdGgvMjtcclxuICAgICAgICAgICAgLy8gICAgIHZhciBuZXdQb2ludCA9IFV0aWwuZ2V0RW5kUG9pbnQocG9pbnRzWzBdLCBsZW5ndGgsIGFuZ2xlKTtcclxuICAgICAgICAgICAgLy8gICAgIHJldHVybiBbbmV3UG9pbnQueCwgbmV3UG9pbnQueV07XHJcbiAgICAgICAgICAgIC8vIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vICAgICB2YXIgbWlkZGxlWCA9IChwb2ludHNbMF0ueCArIHBvaW50c1sxXS54KS8yO1xyXG4gICAgICAgICAgICAvLyAgICAgdmFyIG1pZGRsZVkgPSAocG9pbnRzWzBdLnkgKyBwb2ludHNbMV0ueSkgLzI7XHJcbiAgICAgICAgICAgIC8vICAgICByZXR1cm4gW21pZGRsZVgsIG1pZGRsZVldO1xyXG4gICAgICAgICAgICAvLyB9XHJcbiAgICAgICAgICAgIHZhciBtaWRkbGVYID0gKHBvaW50c1swXS54ICsgcG9pbnRzWzFdLngpLzI7XHJcbiAgICAgICAgICAgIHZhciBtaWRkbGVZID0gKHBvaW50c1swXS55ICsgcG9pbnRzWzFdLnkpIC8yO1xyXG4gICAgICAgICAgICByZXR1cm4gW21pZGRsZVgsIG1pZGRsZVldO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmKHRoaXMub3B0aW9ucy5zdHlsZS5saW5lVHlwZSA9PSBDb25uZWN0b3IuVFlQRV9KQUdHRUQpe1xyXG5cclxuICAgICAgICAgICAgLy9maW5kIHRvdGFsIGRpc3RhbmNlXHJcbiAgICAgICAgICAgIHZhciBkaXN0YW5jZSA9IHRoaXMuZ2V0TGVuZ3RoKCk7XHJcblxyXG4gICAgICAgICAgICAvL2ZpbmQgYmV0d2VlbiB3aGF0IHR1cm5pbmcgcG9pbnRzIHRoZSBoYWxmIGRpc3RhbmNlIGlzXHJcbiAgICAgICAgICAgIHZhciBpbmRleCA9IC0xO1xyXG4gICAgICAgICAgICB2YXIgZWxsYXBzZWREaXN0YW5jZSA9IDA7XHJcbiAgICAgICAgICAgIGZvcih2YXIgaT0wOyBpPHRoaXMudHVybmluZ1BvaW50cy5sZW5ndGgtMTsgaSsrKXtcclxuICAgICAgICAgICAgICAgIGluZGV4ID0gaTtcclxuICAgICAgICAgICAgICAgIHZhciBzZWdtZW50ID0gVXRpbC5nZXRMZW5ndGgodGhpcy50dXJuaW5nUG9pbnRzW2ldLCB0aGlzLnR1cm5pbmdQb2ludHNbaSsxXSk7XHJcbiAgICAgICAgICAgICAgICBpZihlbGxhcHNlZERpc3RhbmNlICsgc2VnbWVudCA8IGRpc3RhbmNlIC8yKXtcclxuICAgICAgICAgICAgICAgICAgICBlbGxhcHNlZERpc3RhbmNlICs9IHNlZ21lbnQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNle1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvL3dlIGhhdmUgdGhlIG1pZGRsZSBkaXN0YW5jZSBzb21ld2hlcmUgYmV0d2VlbiBpKG5kZXgpIGFuZCBpKG5kZXgpKzFcclxuICAgICAgICAgICAgaWYoaW5kZXggIT0gLTEpe1xyXG4gICAgICAgICAgICAgICAgdmFyIG1pc3NpbmdEaXN0YW5jZSA9IGRpc3RhbmNlIC8gMiAtIGVsbGFwc2VkRGlzdGFuY2U7XHJcbiAgICAgICAgICAgICAgICBpZiggVXRpbC5yb3VuZCh0aGlzLnR1cm5pbmdQb2ludHNbaW5kZXhdLngsIDMpID09IFV0aWwucm91bmQodGhpcy50dXJuaW5nUG9pbnRzW2luZGV4ICsgMV0ueCwgMykgKXsgLy92ZXJ0aWNhbCBzZWdtZW50IChzYW1lIHgpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFt0aGlzLnR1cm5pbmdQb2ludHNbaW5kZXhdLngsIE1hdGgubWluKHRoaXMudHVybmluZ1BvaW50c1tpbmRleF0ueSwgdGhpcy50dXJuaW5nUG9pbnRzW2luZGV4ICsgMV0ueSkgKyBtaXNzaW5nRGlzdGFuY2VdO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmKCBVdGlsLnJvdW5kKHRoaXMudHVybmluZ1BvaW50c1tpbmRleF0ueSwgMykgPT0gVXRpbC5yb3VuZCh0aGlzLnR1cm5pbmdQb2ludHNbaW5kZXggKyAxXS55LCAzKSApIHsgLy9ob3Jpem9udGFsIHNlZ21lbnQgKHNhbWUgeSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW01hdGgubWluKHRoaXMudHVybmluZ1BvaW50c1tpbmRleF0ueCwgdGhpcy50dXJuaW5nUG9pbnRzW2luZGV4ICsgMV0ueCkgKyBtaXNzaW5nRGlzdGFuY2UsIHRoaXMudHVybmluZ1BvaW50c1tpbmRleF0ueV07XHJcbiAgICAgICAgICAgICAgICB9IGVsc2V7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkNvbm5lY3RvcjptaWRkbGUoKSAtIHRoaXMgc2hvdWxkIG5ldmVyIGhhcHBlbiBcIiArIHRoaXMudHVybmluZ1BvaW50c1tpbmRleF0gKyBcIiBcIiArIHRoaXMudHVybmluZ1BvaW50c1tpbmRleCArIDFdXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICsgXCIgbnIgb2YgcG9pbnRzIFwiICsgdGhpcy50dXJuaW5nUG9pbnRzLmxlbmd0aFxyXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmKHRoaXMub3B0aW9ucy5zdHlsZS5saW5lVHlwZSA9PSBDb25uZWN0b3IuVFlQRV9DVVJWRSl7XHJcbiAgICAgICAgICAgIHZhciB0ID0gMC41O1xyXG4gICAgICAgICAgICB2YXIgbCA9IHRoaXMuZ2V0TGVuZ3RoKCk7XHJcblxyXG4gICAgICAgICAgICB2YXIgd2Fsa2VkID0gMDtcclxuICAgICAgICAgICAgZm9yKHZhciBqID0wOyBqPCB0aGlzLnR1cm5pbmdQb2ludHMubGVuZ3RoLTE7IGorKyl7XHJcbiAgICAgICAgICAgICAgICBpZiggd2Fsa2VkICsgVXRpbC5kaXN0YW5jZSh0aGlzLnR1cm5pbmdQb2ludHNbal0sIHRoaXMudHVybmluZ1BvaW50c1tqKzFdKSA+IGwgKiB0ICl7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgd2Fsa2VkICs9IFV0aWwuZGlzdGFuY2UodGhpcy50dXJuaW5nUG9pbnRzW2pdLCB0aGlzLnR1cm5pbmdQb2ludHNbaisxXSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciByZXN0ID0gbCAqIHQgLSB3YWxrZWQ7XHJcbiAgICAgICAgICAgIHZhciBjdXJyZW50U2VnbWVudExlbmd0aCA9IFV0aWwuZGlzdGFuY2UodGhpcy50dXJuaW5nUG9pbnRzW2pdLCB0aGlzLnR1cm5pbmdQb2ludHNbaisxXSk7XHJcblxyXG4gICAgICAgICAgICAvL2ZpbmQgdGhlIHBvc2l0aW9uL3JhdGlvbiBvZiB0aGUgbWlkZGxlIG9mIFBvbHlsaW5lIG9uIGN1cnJlbnQgc2VnbWVudFxyXG4gICAgICAgICAgICB2YXIgc2VnbWVudFBlcmNlbnQgPSByZXN0IC8gY3VycmVudFNlZ21lbnRMZW5ndGg7XHJcblxyXG4gICAgICAgICAgICB2YXIgWHAgPSBzZWdtZW50UGVyY2VudCAqICh0aGlzLnR1cm5pbmdQb2ludHNbaisxXS54IC0gdGhpcy50dXJuaW5nUG9pbnRzW2pdLngpICsgdGhpcy50dXJuaW5nUG9pbnRzW2pdLng7XHJcbiAgICAgICAgICAgIHZhciBZcCA9IHNlZ21lbnRQZXJjZW50ICogKHRoaXMudHVybmluZ1BvaW50c1tqKzFdLnkgLSB0aGlzLnR1cm5pbmdQb2ludHNbal0ueSkgKyB0aGlzLnR1cm5pbmdQb2ludHNbal0ueTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBbWHAsIFlwXTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBmaW5kIHRvdGFsIGRpc3RhbmNlXHJcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFtkZXNjcmlwdGlvbl1cclxuICAgICAqL1xyXG4gICAgQ29ubmVjdG9yLnByb3RvdHlwZS5nZXRMZW5ndGggPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgLy9maW5kIHRvdGFsIGRpc3RhbmNlXHJcbiAgICAgICAgdmFyIGRpc3RhbmNlID0gMDtcclxuICAgICAgICBmb3IodmFyIGk9MDsgaTx0aGlzLnR1cm5pbmdQb2ludHMubGVuZ3RoLTE7IGkrKyl7XHJcbiAgICAgICAgICAgIGRpc3RhbmNlICs9IFV0aWwuZ2V0TGVuZ3RoKHRoaXMudHVybmluZ1BvaW50c1tpXSwgdGhpcy50dXJuaW5nUG9pbnRzW2krMV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZGlzdGFuY2U7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICog6L2sSlNPTuWvueixoVxyXG4gICAgICogQHJldHVybiB7W3R5cGVdfSBbZGVzY3JpcHRpb25dXHJcbiAgICAgKi9cclxuICAgIENvbm5lY3Rvci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgICAgIHRoaXMubW9kZWwuc2V0KFwicmVzb3VyY2VJZFwiLCB0aGlzLnJlc291cmNlSWQpO1xyXG4gICAgICAgIHRoaXMubW9kZWwuc2V0KFwicHJvcGVydGllcy50eXBlXCIsIDE0KTtcclxuXHJcbiAgICAgICAgdGhpcy5tb2RlbC5zZXQoXCJib3VuZHMudXBwZXJMZWZ0LnhcIiwgdGhpcy5wb3NpdGlvblswXSk7XHJcbiAgICAgICAgdGhpcy5tb2RlbC5zZXQoXCJib3VuZHMudXBwZXJMZWZ0LnlcIiwgdGhpcy5wb3NpdGlvblsxXSk7XHJcbiAgICAgICAgdGhpcy5tb2RlbC5zZXQoXCJib3VuZHMubG93ZXJSaWdodC54XCIsIHRoaXMucG9zaXRpb25bMF0gKyB0aGlzLmdldEJvdW5kaW5nUmVjdCgpLndpZHRoKTtcclxuICAgICAgICB0aGlzLm1vZGVsLnNldChcImJvdW5kcy5sb3dlclJpZ2h0LnlcIiwgdGhpcy5wb3NpdGlvblsxXSArIHRoaXMuZ2V0Qm91bmRpbmdSZWN0KCkuaGVpZ2h0KTtcclxuICAgICAgICB0aGlzLm1vZGVsLnNldChcInN0eWxlLnNQb3NcIiwgdGhpcy5zUG9zKTtcclxuICAgICAgICB0aGlzLm1vZGVsLnNldChcInN0eWxlLmVQb3NcIiwgdGhpcy5lUG9zKTtcclxuICAgICAgICB0aGlzLm1vZGVsLnNldChcImRvY2tlcnNcIix0aGlzLnR1cm5pbmdQb2ludHMpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLm1vZGVsLm9wdGlvbjtcclxuICAgIH07XHJcblxyXG4gICAgIC8qKlxyXG4gICAgICogcmVmcmVzaE1vZGVsXHJcbiAgICAgKiBAcmV0dXJuIHtbdHlwZV19IFtkZXNjcmlwdGlvbl1cclxuICAgICAqL1xyXG4gICAgQ29ubmVjdG9yLnByb3RvdHlwZS5yZWZyZXNoTW9kZWwgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB0aGlzLm1vZGVsLnNldChcIm9wdGlvbnMuZG9ja2Vyc1wiLHRoaXMudHVybmluZ1BvaW50cyk7XHJcbiAgICAgICAgdmFyIGljb25zID0gW107XHJcbiAgICAgICAgZm9yKHZhciBpID0gMDtpIDwgdGhpcy5pY29ucy5sZW5ndGg7aSsrKXtcclxuICAgICAgICAgICAgdmFyIGljb25Ob2RlID0gdGhpcy5pY29uc1tpXTtcclxuICAgICAgICAgICAgdmFyIG9wdGlvbiA9IFtpY29uTm9kZS5rZXkse1xyXG4gICAgICAgICAgICAgICAgaWNvbjppY29uTm9kZS5zdHlsZS5pbWFnZSxcclxuICAgICAgICAgICAgICAgIHdpZHRoOiBpY29uTm9kZS5zdHlsZS53aWR0aCxcclxuICAgICAgICAgICAgICAgIGhlaWdodDogaWNvbk5vZGUuc3R5bGUuaGVpZ2h0XHJcbiAgICAgICAgICAgIH1dO1xyXG4gICAgICAgICAgICBpY29ucy5wdXNoKG9wdGlvbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMubW9kZWwuc2V0KFwiaWNvbnNcIixpY29ucyk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICog6LCD5pW05puy57q/55qE5b2i54q2XHJcbiAgICAgKiBAcGFyYW0gIHthcnJheX0gcG9pbnRzIOeCueaVsOe7hFxyXG4gICAgICogQHJldHVybiB7dm9pZH1cclxuICAgICAqL1xyXG4gICAgQ29ubmVjdG9yLnByb3RvdHlwZS5tb2RpZnlDdXJ2ZSA9IGZ1bmN0aW9uKHBvaW50cykge1xyXG4gICAgICAgIHZhciBzb2wgPSB0aGlzLmdldEN1cnZlUG9pbnQocG9pbnRzKTtcclxuXHJcbiAgICAgICAgLy8gMS4g5aaC5p6c5puy57q/55qE5pWw6YePIOavlOaVsOmHj+eahOS4reaVsOmHj+imgeWwkSDliJnliKDpmaTlpJrkvZnnmoTnur/mrrVcclxuICAgICAgICB2YXIgd2lsbERlbEN1cnZlcyA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIGogPSBzb2wubGVuZ3RoLCBjbnRDdXJ2ZSA9IHRoaXMuZ3JvdXBDdXJ2ZS5jaGlsZENvdW50KCk7IGogPCBjbnRDdXJ2ZSA7IGorKykge1xyXG4gICAgICAgICAgICB3aWxsRGVsQ3VydmVzLnB1c2godGhpcy5ncm91cEN1cnZlLmNoaWxkQXQoaikpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB6clV0aWwuZWFjaCh3aWxsRGVsQ3VydmVzLCBmdW5jdGlvbihjdXJ2ZSkge1xyXG4gICAgICAgICAgICB0aGlzLmdyb3VwQ3VydmUucmVtb3ZlKGN1cnZlKTtcclxuICAgICAgICB9LCB0aGlzKTtcclxuICAgICAgICAvLyAyLiDpgY3ljobmm7Lnur8gICDlpoLmnpzlrZjlnKjliJnnm7TmjqXorr7nva7lvaLnirbvvIzlkKbliJnliJvlu7pcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNvbC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgbGluZSA9IHRoaXMuZ3JvdXBDdXJ2ZS5jaGlsZEF0KGkpO1xyXG4gICAgICAgICAgICBpZiAobGluZSkge1xyXG4gICAgICAgICAgICAgICAgbGluZS5hdHRyKCdzaGFwZScsIHNvbFtpXSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY3VyZSA9IG5ldyBncmFwaGljLkJlemllckN1cnZlKHtcclxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogdGhpcy5vcHRpb25zLnBvc2l0aW9uLFxyXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlOiB0aGlzLm9wdGlvbnMuc3R5bGUsXHJcbiAgICAgICAgICAgICAgICAgICAgc2hhcGU6IHNvbFtpXSxcclxuICAgICAgICAgICAgICAgICAgICB6OiB0aGlzLm9wdGlvbnMuelxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmdyb3VwQ3VydmUuYWRkKGN1cmUpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jcmVhdGVIb3ZlclN0eWxlKGN1cmUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDmoLnmja7kvKDlhaXnmoTngrnmlbDnu4TorqHnrpfmm7Lnur/nmoTngrlcclxuICAgICAqIEBwYXJhbSAge2FycmF5fSBQIOeCueaVsOe7hFxyXG4gICAgICogQHJldHVybiB7b2JqZWN0fSAgICAgICAg5puy57q/55qE54K55pWw57uEXHJcbiAgICAgKi9cclxuICAgIENvbm5lY3Rvci5wcm90b3R5cGUuZ2V0Q3VydmVQb2ludCA9IGZ1bmN0aW9uKFApIHtcclxuICAgICAgICB2YXIgbiA9IFAubGVuZ3RoO1xyXG4gICAgICAgIHZhciBzb2wgPSBbXTtcclxuICAgICAgICBpZiAobiA9PT0gMykge1xyXG4gICAgICAgICAgICBzb2wucHVzaCh7eDE6IFBbMF0ueCxcclxuICAgICAgICAgICAgICAgICAgIHkxOiBQWzBdLnksXHJcbiAgICAgICAgICAgICAgICAgICBjcHgxOiBQWzFdLngsXHJcbiAgICAgICAgICAgICAgICAgICBjcHkxOiBQWzFdLnksXHJcbiAgICAgICAgICAgICAgICAgICB4MjogUFsyXS54LFxyXG4gICAgICAgICAgICAgICAgICAgeTI6IFBbMl0ueVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiBzb2w7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKG4gPT09IDQpIHtcclxuICAgICAgICAgICAgc29sLnB1c2goe3gxOiBQWzBdLngsXHJcbiAgICAgICAgICAgICAgICAgICB5MTogUFswXS55LFxyXG4gICAgICAgICAgICAgICAgICAgY3B4MTogUFsxXS54LFxyXG4gICAgICAgICAgICAgICAgICAgY3B5MTogUFsxXS55LFxyXG4gICAgICAgICAgICAgICAgICAgY3B4MjogUFsyXS54LFxyXG4gICAgICAgICAgICAgICAgICAgY3B5MjogUFsyXS55LFxyXG4gICAgICAgICAgICAgICAgICAgeDI6IFBbM10ueCxcclxuICAgICAgICAgICAgICAgICAgIHkyOiBQWzNdLnlcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gc29sO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyoqQ29tcHV0ZXMgZmFjdG9yaWFsXHJcbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IGsgdGhlIG51bWJlclxyXG4gICAgICAgICAqICovXHJcbiAgICAgICAgZnVuY3Rpb24gZmFjdChrKXtcclxuICAgICAgICAgICAgaWYoaz09PTAgfHwgaz09PTEpe1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZXtcclxuICAgICAgICAgICAgICAgIHJldHVybiBrICogZmFjdChrLTEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKipDb21wdXRlcyBCZXJuc3RhaW4qL1xyXG4gICAgICAgIGZ1bmN0aW9uIEIoaSxuLHUpe1xyXG4gICAgICAgICAgICByZXR1cm4gZmFjdChuKSAvIChmYWN0KGkpICogZmFjdChuLWkpKSogTWF0aC5wb3codSwgaSkgKiBNYXRoLnBvdygxLXUsIG4taSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKipDb21wdXRlcyB0aGUgc3VtIGJldHdlZW4gdHdvIHBvaW50XHJcbiAgICAgICAgICpAcGFyYW0gcDEgLSB7UG9pbnR9XHJcbiAgICAgICAgICpAcGFyYW0gcDIgLSB7UG9pbnR9XHJcbiAgICAgICAgICpAcmV0dXJuIHtQb2ludH0gdGhlIHN1bSBvZiBpbml0aWFsIHBvaW50c1xyXG4gICAgICAgICAqKi9cclxuICAgICAgICBmdW5jdGlvbiBzdW0ocDEsIHAyKXtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludChwMS54ICsgcDIueCwgcDEueSArIHAyLnkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyoqQ29tcHV0ZXMgdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiBmaXJzdCB7UG9pbnR9IGFuZCBzZWNvbmQge1BvaW50fVxyXG4gICAgICAgICAqQHBhcmFtIHAxIC0ge1BvaW50fVxyXG4gICAgICAgICAqQHBhcmFtIHAyIC0ge1BvaW50fVxyXG4gICAgICAgICAqQHJldHVybiB7UG9pbnR9IHRoZSBzdW0gb2YgaW5pdGlhbCBwb2ludHNcclxuICAgICAgICAgKiovXHJcbiAgICAgICAgZnVuY3Rpb24gbWludXMocDEsIHAyKXtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludChwMS54IC0gcDIueCwgcDEueSAtIHAyLnkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyoqQ29tcHV0ZXMgdGhlIGRpdmlzaW9uIG9mIGEge1BvaW50fSBieSBhIG51bWJlclxyXG4gICAgICAgICAqQHBhcmFtIHAgLSB7UG9pbnR9XHJcbiAgICAgICAgICpAcGFyYW0gbnIgLSB7TnVtYmVyfVxyXG4gICAgICAgICAqQHJldHVybiB7UG9pbnR9XHJcbiAgICAgICAgICoqL1xyXG4gICAgICAgIGZ1bmN0aW9uIGRpdmlkZShwLCBucil7XHJcbiAgICAgICAgICAgIGlmKG5yID09IDApe1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgXCJEaXZpc2lvbiBieSB6ZXJvIG5vdCBhbGxvd2VkICh5ZXQgOikgXCIgKyB0aGlzLmNhbGxlZSA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludChwLngvbnIsIHAueS9ucik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKipDb21wdXRlcyB0aGUgbXVsdGlwbGljYXRpb24gb2YgYSB7UG9pbnR9IGJ5IGEgbnVtYmVyXHJcbiAgICAgICAgICpAcGFyYW0gcCAtIHtQb2ludH1cclxuICAgICAgICAgKkBwYXJhbSBuciAtIHtOdW1iZXJ9XHJcbiAgICAgICAgICpAcmV0dXJuIHtQb2ludH1cclxuICAgICAgICAgKiovXHJcbiAgICAgICAgZnVuY3Rpb24gbXVsdGlwbHkocCwgbnIpe1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFBvaW50IChwLnggKiBuciwgcC55ICogbnIpO1xyXG4gICAgICAgIH1cclxuXHJcblxyXG5cclxuXHJcbiAgICAgICAgLypcclxuICAgICAgICAgKkkgZG8gbm90IGdldCB3aHkgZmlyc3QgNCBtdXN0IGJlIDAgYW5kIGxhc3QgMyBvZiBzYW1lIHZhbHVlLi4uLi5cclxuICAgICAgICAgKmJ1dCBvdGhlcndpc2Ugd2Ugd2lsbCBnZXQgZGl2aXNpb24gYnkgemVyb1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHZhciBrID0gWzAsMCwwXTtcclxuXHJcbiAgICAgICAgdmFyIGo7XHJcbiAgICAgICAgZm9yKGo9MDtqPD1uLTM7aisrKXtcclxuICAgICAgICAgICAgay5wdXNoKGopO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgay5wdXNoKG4tMywgbi0zKTtcclxuXHJcblxyXG5cclxuICAgICAgICBmb3IoaT0xOyBpPD1uLTM7IGkrKyl7XHJcbiAgICAgICAgICAgIC8vcTEgLSBjb21wdXRlIHN0YXJ0IHBvaW50XHJcbiAgICAgICAgICAgIHZhciBxMSA9IGRpdmlkZSggc3VtKCBtdWx0aXBseShQW2ldLCBrW2krNF0gLSBrW2krMl0pLCBtdWx0aXBseShQW2krMV0sIGtbaSsyXSAtIGtbaSsxXSkgKSwga1tpKzRdIC0ga1tpKzFdKTtcclxuXHJcbiAgICAgICAgICAgIC8vcTAgLSBjb21wdXRlIDFzdCBjb250cm9sbCBwb2ludFxyXG4gICAgICAgICAgICB2YXIgcV8wMSA9IChrW2krM10gLSBrW2krMl0pIC8gKGtbaSszXSAtIGtbaSsxXSk7XHJcbiAgICAgICAgICAgIHZhciBxXzAyID0gZGl2aWRlKCBzdW0oIG11bHRpcGx5KFBbaS0xXSxrW2krM10gLSBrW2krMl0pLCBtdWx0aXBseShQW2ldLCBrW2krMl0gLSBrW2ldKSksIGtbaSszXSAtIGtbaV0pO1xyXG4gICAgICAgICAgICB2YXIgcV8wMyA9IG11bHRpcGx5KHExLCAoIGtbaSsyXSAtIGtbaSsxXSkvIChrW2krM10gLSBrW2krMV0pICk7XHJcbiAgICAgICAgICAgIHZhciBxMCA9IHN1bShtdWx0aXBseShxXzAyLCBxXzAxKSwgcV8wMyk7XHJcblxyXG4gICAgICAgICAgICAvL3EyIC0gY29tcHV0ZSAybmQgY29udHJvbGwgcG9pbnRcclxuICAgICAgICAgICAgdmFyIHEyID0gZGl2aWRlKCBzdW0oIG11bHRpcGx5KFBbaV0sIGtbaSs0XSAtIGtbaSszXSksIG11bHRpcGx5KFBbaSsxXSwga1tpKzNdIC0ga1tpKzFdKSApLCBrW2krNF0gLSBrW2krMV0gKTtcclxuXHJcbiAgICAgICAgICAgIC8vcTMgLSBjb21wdXRlIGVuZCBwb2ludFxyXG4gICAgICAgICAgICB2YXIgcV8zMSA9IChrW2krM10gLSBrW2krMl0pIC8gKGtbaSs0XSAtIGtbaSsyXSk7XHJcbiAgICAgICAgICAgIHZhciBxXzMyID0gZGl2aWRlKCBzdW0oIG11bHRpcGx5KFBbaSsxXSwga1tpKzVdIC0ga1tpKzNdKSwgbXVsdGlwbHkoUFtpKzJdLCBrW2krM10gLSBrW2krMl0pICkgLCBrW2krNV0gLSBrW2krMl0pO1xyXG4gICAgICAgICAgICB2YXIgcV8zMyA9IG11bHRpcGx5KHEyLCAoa1tpKzRdIC0ga1tpKzNdKS8oa1tpKzRdIC0ga1tpKzJdKSApO1xyXG4gICAgICAgICAgICB2YXIgcTMgPSBzdW0obXVsdGlwbHkocV8zMiwgcV8zMSksIHFfMzMpO1xyXG5cclxuICAgICAgICAgICAgLy9zdG9yZSBzb2x1dGlvblxyXG4gICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICBzb2wucHVzaCh7eDE6IHEwLngsXHJcbiAgICAgICAgICAgICAgICAgICB5MTogcTAueSxcclxuICAgICAgICAgICAgICAgICAgIGNweDE6IHExLngsXHJcbiAgICAgICAgICAgICAgICAgICBjcHkxOiBxMS55LFxyXG4gICAgICAgICAgICAgICAgICAgY3B4MjogcTIueCxcclxuICAgICAgICAgICAgICAgICAgIGNweTI6IHEyLnksXHJcbiAgICAgICAgICAgICAgICAgICB4MjogcTMueCxcclxuICAgICAgICAgICAgICAgICAgIHkyOiBxMy55XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBzb2w7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICBVdGlsLmluaGVyaXRzKENvbm5lY3RvcixOb2RlKTtcclxuXHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IENvbm5lY3RvcjtcclxuXHJcblxyXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vbGliL2Zpc2gtdG9wby1jb3JlL2xpYi9zaGFwZXMvQ29ubmVjdG9yLmpzXG4gKiogbW9kdWxlIGlkID0gOTZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0Jztcbi8vIFN5bWJvbCBmYWN0b3J5XHJcblxyXG5cclxuICAgIHZhciBncmFwaGljID0gcmVxdWlyZSgnLi4vZ3JhcGhpYycpO1xyXG4gICAgdmFyIEJvdW5kaW5nUmVjdCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvQm91bmRpbmdSZWN0Jyk7XHJcbiAgICAvKipcclxuICAgICAqIFRyaWFuZ2xlIHNoYXBlXHJcbiAgICAgKiBAaW5uZXJcclxuICAgICAqL1xyXG4gICAgdmFyIFRyaWFuZ2xlID0gZ3JhcGhpYy5leHRlbmRTaGFwZSh7XHJcbiAgICAgICAgdHlwZTogJ3RyaWFuZ2xlJyxcclxuICAgICAgICBzaGFwZToge1xyXG4gICAgICAgICAgICBjeDogMCxcclxuICAgICAgICAgICAgY3k6IDAsXHJcbiAgICAgICAgICAgIHdpZHRoOiAwLFxyXG4gICAgICAgICAgICBoZWlnaHQ6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIGJ1aWxkUGF0aDogZnVuY3Rpb24gKHBhdGgsIHNoYXBlKSB7XHJcbiAgICAgICAgICAgIHZhciBjeCA9IHNoYXBlLmN4O1xyXG4gICAgICAgICAgICB2YXIgY3kgPSBzaGFwZS5jeTtcclxuICAgICAgICAgICAgdmFyIHdpZHRoID0gc2hhcGUud2lkdGggLyAyO1xyXG4gICAgICAgICAgICB2YXIgaGVpZ2h0ID0gc2hhcGUuaGVpZ2h0IC8gMjtcclxuICAgICAgICAgICAgcGF0aC5tb3ZlVG8oY3gsIGN5IC0gaGVpZ2h0KTtcclxuICAgICAgICAgICAgcGF0aC5saW5lVG8oY3ggKyB3aWR0aCwgY3kgKyBoZWlnaHQpO1xyXG4gICAgICAgICAgICBwYXRoLmxpbmVUbyhjeCAtIHdpZHRoLCBjeSArIGhlaWdodCk7XHJcbiAgICAgICAgICAgIHBhdGguY2xvc2VQYXRoKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICAvKipcclxuICAgICAqIERpYW1vbmQgc2hhcGVcclxuICAgICAqIEBpbm5lclxyXG4gICAgICovXHJcbiAgICB2YXIgRGlhbW9uZCA9IGdyYXBoaWMuZXh0ZW5kU2hhcGUoe1xyXG4gICAgICAgIHR5cGU6ICdkaWFtb25kJyxcclxuICAgICAgICBzaGFwZToge1xyXG4gICAgICAgICAgICBjeDogMCxcclxuICAgICAgICAgICAgY3k6IDAsXHJcbiAgICAgICAgICAgIHdpZHRoOiAwLFxyXG4gICAgICAgICAgICBoZWlnaHQ6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIGJ1aWxkUGF0aDogZnVuY3Rpb24gKHBhdGgsIHNoYXBlKSB7XHJcbiAgICAgICAgICAgIHZhciBjeCA9IHNoYXBlLmN4O1xyXG4gICAgICAgICAgICB2YXIgY3kgPSBzaGFwZS5jeTtcclxuICAgICAgICAgICAgdmFyIHdpZHRoID0gc2hhcGUud2lkdGggLyAyO1xyXG4gICAgICAgICAgICB2YXIgaGVpZ2h0ID0gc2hhcGUuaGVpZ2h0IC8gMjtcclxuICAgICAgICAgICAgcGF0aC5tb3ZlVG8oY3gsIGN5IC0gaGVpZ2h0KTtcclxuICAgICAgICAgICAgcGF0aC5saW5lVG8oY3ggKyB3aWR0aCwgY3kpO1xyXG4gICAgICAgICAgICBwYXRoLmxpbmVUbyhjeCwgY3kgKyBoZWlnaHQpO1xyXG4gICAgICAgICAgICBwYXRoLmxpbmVUbyhjeCAtIHdpZHRoLCBjeSk7XHJcbiAgICAgICAgICAgIHBhdGguY2xvc2VQYXRoKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQaW4gc2hhcGVcclxuICAgICAqIEBpbm5lclxyXG4gICAgICovXHJcbiAgICB2YXIgUGluID0gZ3JhcGhpYy5leHRlbmRTaGFwZSh7XHJcbiAgICAgICAgdHlwZTogJ3BpbicsXHJcbiAgICAgICAgc2hhcGU6IHtcclxuICAgICAgICAgICAgLy8geCwgeSBvbiB0aGUgY3VzcFxyXG4gICAgICAgICAgICB4OiAwLFxyXG4gICAgICAgICAgICB5OiAwLFxyXG4gICAgICAgICAgICB3aWR0aDogMCxcclxuICAgICAgICAgICAgaGVpZ2h0OiAwXHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgYnVpbGRQYXRoOiBmdW5jdGlvbiAocGF0aCwgc2hhcGUpIHtcclxuICAgICAgICAgICAgdmFyIHggPSBzaGFwZS54O1xyXG4gICAgICAgICAgICB2YXIgeSA9IHNoYXBlLnk7XHJcbiAgICAgICAgICAgIHZhciB3ID0gc2hhcGUud2lkdGggLyA1ICogMztcclxuICAgICAgICAgICAgLy8gSGVpZ2h0IG11c3QgYmUgbGFyZ2VyIHRoYW4gd2lkdGhcclxuICAgICAgICAgICAgdmFyIGggPSBNYXRoLm1heCh3LCBzaGFwZS5oZWlnaHQpO1xyXG4gICAgICAgICAgICB2YXIgciA9IHcgLyAyO1xyXG5cclxuICAgICAgICAgICAgLy8gRGlzdCBvbiB5IHdpdGggdGFuZ2VudCBwb2ludCBhbmQgY2lyY2xlIGNlbnRlclxyXG4gICAgICAgICAgICB2YXIgZHkgPSByICogciAvIChoIC0gcik7XHJcbiAgICAgICAgICAgIHZhciBjeSA9IHkgLSBoICsgciArIGR5O1xyXG4gICAgICAgICAgICB2YXIgYW5nbGUgPSBNYXRoLmFzaW4oZHkgLyByKTtcclxuICAgICAgICAgICAgLy8gRGlzdCBvbiB4IHdpdGggdGFuZ2VudCBwb2ludCBhbmQgY2lyY2xlIGNlbnRlclxyXG4gICAgICAgICAgICB2YXIgZHggPSBNYXRoLmNvcyhhbmdsZSkgKiByO1xyXG5cclxuICAgICAgICAgICAgdmFyIHRhblggPSBNYXRoLnNpbihhbmdsZSk7XHJcbiAgICAgICAgICAgIHZhciB0YW5ZID0gTWF0aC5jb3MoYW5nbGUpO1xyXG5cclxuICAgICAgICAgICAgcGF0aC5hcmMoXHJcbiAgICAgICAgICAgICAgICB4LCBjeSwgcixcclxuICAgICAgICAgICAgICAgIE1hdGguUEkgLSBhbmdsZSxcclxuICAgICAgICAgICAgICAgIE1hdGguUEkgKiAyICsgYW5nbGVcclxuICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgIHZhciBjcExlbiA9IHIgKiAwLjY7XHJcbiAgICAgICAgICAgIHZhciBjcExlbjIgPSByICogMC43O1xyXG4gICAgICAgICAgICBwYXRoLmJlemllckN1cnZlVG8oXHJcbiAgICAgICAgICAgICAgICB4ICsgZHggLSB0YW5YICogY3BMZW4sIGN5ICsgZHkgKyB0YW5ZICogY3BMZW4sXHJcbiAgICAgICAgICAgICAgICB4LCB5IC0gY3BMZW4yLFxyXG4gICAgICAgICAgICAgICAgeCwgeVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICBwYXRoLmJlemllckN1cnZlVG8oXHJcbiAgICAgICAgICAgICAgICB4LCB5IC0gY3BMZW4yLFxyXG4gICAgICAgICAgICAgICAgeCAtIGR4ICsgdGFuWCAqIGNwTGVuLCBjeSArIGR5ICsgdGFuWSAqIGNwTGVuLFxyXG4gICAgICAgICAgICAgICAgeCAtIGR4LCBjeSArIGR5XHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIHBhdGguY2xvc2VQYXRoKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBcnJvdyBzaGFwZVxyXG4gICAgICogQGlubmVyXHJcbiAgICAgKi9cclxuICAgIHZhciBBcnJvdyA9IGdyYXBoaWMuZXh0ZW5kU2hhcGUoe1xyXG5cclxuICAgICAgICB0eXBlOiAnYXJyb3cnLFxyXG5cclxuICAgICAgICBzaGFwZToge1xyXG4gICAgICAgICAgICB4OiAwLFxyXG4gICAgICAgICAgICB5OiAwLFxyXG4gICAgICAgICAgICB3aWR0aDogMCxcclxuICAgICAgICAgICAgaGVpZ2h0OiAwXHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgYnVpbGRQYXRoOiBmdW5jdGlvbiAoY3R4LCBzaGFwZSkge1xyXG4gICAgICAgICAgICB2YXIgaGVpZ2h0ID0gc2hhcGUuaGVpZ2h0O1xyXG4gICAgICAgICAgICB2YXIgd2lkdGggPSBzaGFwZS53aWR0aDtcclxuICAgICAgICAgICAgdmFyIHggPSBzaGFwZS54O1xyXG4gICAgICAgICAgICB2YXIgeSA9IHNoYXBlLnk7XHJcbiAgICAgICAgICAgIHZhciBkeCA9IHdpZHRoIC8gMyAqIDI7XHJcbiAgICAgICAgICAgIGN0eC5tb3ZlVG8oeCwgeSk7XHJcbiAgICAgICAgICAgIGN0eC5saW5lVG8oeCArIGR4LCB5ICsgaGVpZ2h0KTtcclxuICAgICAgICAgICAgY3R4LmxpbmVUbyh4LCB5ICsgaGVpZ2h0IC8gNCAqIDMpO1xyXG4gICAgICAgICAgICBjdHgubGluZVRvKHggLSBkeCwgeSArIGhlaWdodCk7XHJcbiAgICAgICAgICAgIGN0eC5saW5lVG8oeCwgeSk7XHJcbiAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIE1hcCBvZiBwYXRoIGNvbnRydWN0b3JzXHJcbiAgICAgKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsIG1vZHVsZTp6cmVuZGVyL2dyYXBoaWMvUGF0aD59XHJcbiAgICAgKi9cclxuICAgIHZhciBzeW1ib2xDdG9ycyA9IHtcclxuICAgICAgICBsaW5lOiBncmFwaGljLkxpbmUsXHJcblxyXG4gICAgICAgIHJlY3Q6IGdyYXBoaWMuUmVjdCxcclxuXHJcbiAgICAgICAgcm91bmRSZWN0OiBncmFwaGljLlJlY3QsXHJcblxyXG4gICAgICAgIHNxdWFyZTogZ3JhcGhpYy5SZWN0LFxyXG5cclxuICAgICAgICBjaXJjbGU6IGdyYXBoaWMuQ2lyY2xlLFxyXG5cclxuICAgICAgICBkaWFtb25kOiBEaWFtb25kLFxyXG5cclxuICAgICAgICBwaW46IFBpbixcclxuXHJcbiAgICAgICAgYXJyb3c6IEFycm93LFxyXG5cclxuICAgICAgICB0cmlhbmdsZTogVHJpYW5nbGVcclxuICAgIH07XHJcblxyXG4gICAgdmFyIHN5bWJvbFNoYXBlTWFrZXJzID0ge1xyXG5cclxuICAgICAgICBsaW5lOiBmdW5jdGlvbiAoeCwgeSwgdywgaCwgc2hhcGUpIHtcclxuICAgICAgICAgICAgLy8gRklYTUVcclxuICAgICAgICAgICAgc2hhcGUueDEgPSB4O1xyXG4gICAgICAgICAgICBzaGFwZS55MSA9IHkgKyBoIC8gMjtcclxuICAgICAgICAgICAgc2hhcGUueDIgPSB4ICsgdztcclxuICAgICAgICAgICAgc2hhcGUueTIgPSB5ICsgaCAvIDI7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgcmVjdDogZnVuY3Rpb24gKHgsIHksIHcsIGgsIHNoYXBlKSB7XHJcbiAgICAgICAgICAgIHNoYXBlLnggPSB4O1xyXG4gICAgICAgICAgICBzaGFwZS55ID0geTtcclxuICAgICAgICAgICAgc2hhcGUud2lkdGggPSB3O1xyXG4gICAgICAgICAgICBzaGFwZS5oZWlnaHQgPSBoO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHJvdW5kUmVjdDogZnVuY3Rpb24gKHgsIHksIHcsIGgsIHNoYXBlKSB7XHJcbiAgICAgICAgICAgIHNoYXBlLnggPSB4O1xyXG4gICAgICAgICAgICBzaGFwZS55ID0geTtcclxuICAgICAgICAgICAgc2hhcGUud2lkdGggPSB3O1xyXG4gICAgICAgICAgICBzaGFwZS5oZWlnaHQgPSBoO1xyXG4gICAgICAgICAgICBzaGFwZS5yID0gTWF0aC5taW4odywgaCkgLyA0O1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNxdWFyZTogZnVuY3Rpb24gKHgsIHksIHcsIGgsIHNoYXBlKSB7XHJcbiAgICAgICAgICAgIHZhciBzaXplID0gTWF0aC5taW4odywgaCk7XHJcbiAgICAgICAgICAgIHNoYXBlLnggPSB4O1xyXG4gICAgICAgICAgICBzaGFwZS55ID0geTtcclxuICAgICAgICAgICAgc2hhcGUud2lkdGggPSBzaXplO1xyXG4gICAgICAgICAgICBzaGFwZS5oZWlnaHQgPSBzaXplO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGNpcmNsZTogZnVuY3Rpb24gKHgsIHksIHcsIGgsIHNoYXBlKSB7XHJcbiAgICAgICAgICAgIC8vIFB1dCBjaXJjbGUgaW4gdGhlIGNlbnRlciBvZiBzcXVhcmVcclxuICAgICAgICAgICAgc2hhcGUuY3ggPSB4ICsgdyAvIDI7XHJcbiAgICAgICAgICAgIHNoYXBlLmN5ID0geSArIGggLyAyO1xyXG4gICAgICAgICAgICBzaGFwZS5yID0gTWF0aC5taW4odywgaCkgLyAyO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGRpYW1vbmQ6IGZ1bmN0aW9uICh4LCB5LCB3LCBoLCBzaGFwZSkge1xyXG4gICAgICAgICAgICBzaGFwZS5jeCA9IHggKyB3IC8gMjtcclxuICAgICAgICAgICAgc2hhcGUuY3kgPSB5ICsgaCAvIDI7XHJcbiAgICAgICAgICAgIHNoYXBlLndpZHRoID0gdztcclxuICAgICAgICAgICAgc2hhcGUuaGVpZ2h0ID0gaDtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBwaW46IGZ1bmN0aW9uICh4LCB5LCB3LCBoLCBzaGFwZSkge1xyXG4gICAgICAgICAgICBzaGFwZS54ID0geCArIHcgLyAyO1xyXG4gICAgICAgICAgICBzaGFwZS55ID0geSArIGggLyAyO1xyXG4gICAgICAgICAgICBzaGFwZS53aWR0aCA9IHc7XHJcbiAgICAgICAgICAgIHNoYXBlLmhlaWdodCA9IGg7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgYXJyb3c6IGZ1bmN0aW9uICh4LCB5LCB3LCBoLCBzaGFwZSkge1xyXG4gICAgICAgICAgICBzaGFwZS54ID0geCArIHcgLyAyO1xyXG4gICAgICAgICAgICBzaGFwZS55ID0geSArIGggLyAyO1xyXG4gICAgICAgICAgICBzaGFwZS53aWR0aCA9IHc7XHJcbiAgICAgICAgICAgIHNoYXBlLmhlaWdodCA9IGg7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgdHJpYW5nbGU6IGZ1bmN0aW9uICh4LCB5LCB3LCBoLCBzaGFwZSkge1xyXG4gICAgICAgICAgICBzaGFwZS5jeCA9IHggKyB3IC8gMjtcclxuICAgICAgICAgICAgc2hhcGUuY3kgPSB5ICsgaCAvIDI7XHJcbiAgICAgICAgICAgIHNoYXBlLndpZHRoID0gdztcclxuICAgICAgICAgICAgc2hhcGUuaGVpZ2h0ID0gaDtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHZhciBzeW1ib2xCdWlsZFByb3hpZXMgPSB7fTtcclxuICAgIGZvciAodmFyIG5hbWUgaW4gc3ltYm9sQ3RvcnMpIHtcclxuICAgICAgICBzeW1ib2xCdWlsZFByb3hpZXNbbmFtZV0gPSBuZXcgc3ltYm9sQ3RvcnNbbmFtZV0oKTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgU3ltYm9sID0gZ3JhcGhpYy5leHRlbmRTaGFwZSh7XHJcblxyXG4gICAgICAgIHR5cGU6ICdzeW1ib2wnLFxyXG5cclxuICAgICAgICBzaGFwZToge1xyXG4gICAgICAgICAgICBzeW1ib2xUeXBlOiAnJyxcclxuICAgICAgICAgICAgeDogMCxcclxuICAgICAgICAgICAgeTogMCxcclxuICAgICAgICAgICAgd2lkdGg6IDAsXHJcbiAgICAgICAgICAgIGhlaWdodDogMFxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGJlZm9yZUJydXNoOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBzdHlsZSA9IHRoaXMuc3R5bGU7XHJcbiAgICAgICAgICAgIHZhciBzaGFwZSA9IHRoaXMuc2hhcGU7XHJcbiAgICAgICAgICAgIC8vIEZJWE1FXHJcbiAgICAgICAgICAgIGlmIChzaGFwZS5zeW1ib2xUeXBlID09PSAncGluJyAmJiBzdHlsZS50ZXh0UG9zaXRpb24gPT09ICdpbnNpZGUnKSB7XHJcbiAgICAgICAgICAgICAgICBzdHlsZS50ZXh0UG9zaXRpb24gPSBbJzUwJScsICc0MCUnXTtcclxuICAgICAgICAgICAgICAgIHN0eWxlLnRleHRBbGlnbiA9ICdjZW50ZXInO1xyXG4gICAgICAgICAgICAgICAgc3R5bGUudGV4dFZlcnRpY2FsQWxpZ24gPSAnbWlkZGxlJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGJ1aWxkUGF0aDogZnVuY3Rpb24gKGN0eCwgc2hhcGUpIHtcclxuICAgICAgICAgICAgdmFyIHN5bWJvbFR5cGUgPSBzaGFwZS5zeW1ib2xUeXBlO1xyXG4gICAgICAgICAgICB2YXIgcHJveHlTeW1ib2wgPSBzeW1ib2xCdWlsZFByb3hpZXNbc3ltYm9sVHlwZV07XHJcbiAgICAgICAgICAgIGlmIChzaGFwZS5zeW1ib2xUeXBlICE9PSAnbm9uZScpIHtcclxuICAgICAgICAgICAgICAgIGlmICghcHJveHlTeW1ib2wpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBEZWZhdWx0IHJlY3RcclxuICAgICAgICAgICAgICAgICAgICBzeW1ib2xUeXBlID0gJ3JlY3QnO1xyXG4gICAgICAgICAgICAgICAgICAgIHByb3h5U3ltYm9sID0gc3ltYm9sQnVpbGRQcm94aWVzW3N5bWJvbFR5cGVdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgc3ltYm9sU2hhcGVNYWtlcnNbc3ltYm9sVHlwZV0oXHJcbiAgICAgICAgICAgICAgICAgICAgc2hhcGUueCwgc2hhcGUueSwgc2hhcGUud2lkdGgsIHNoYXBlLmhlaWdodCwgcHJveHlTeW1ib2wuc2hhcGVcclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICBwcm94eVN5bWJvbC5idWlsZFBhdGgoY3R4LCBwcm94eVN5bWJvbC5zaGFwZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBQcm92aWRlIHNldENvbG9yIGhlbHBlciBtZXRob2QgdG8gYXZvaWQgZGV0ZXJtaW5lIGlmIHNldCB0aGUgZmlsbCBvciBzdHJva2Ugb3V0c2lkZVxyXG4gICAgdmFyIHN5bWJvbFBhdGhTZXRDb2xvciA9IGZ1bmN0aW9uIChjb2xvcikge1xyXG4gICAgICAgIGlmICh0aGlzLnR5cGUgIT09ICdpbWFnZScpIHtcclxuICAgICAgICAgICAgdmFyIHN5bWJvbFN0eWxlID0gdGhpcy5zdHlsZTtcclxuICAgICAgICAgICAgdmFyIHN5bWJvbFNoYXBlID0gdGhpcy5zaGFwZTtcclxuICAgICAgICAgICAgaWYgKHN5bWJvbFNoYXBlICYmIHN5bWJvbFNoYXBlLnN5bWJvbFR5cGUgPT09ICdsaW5lJykge1xyXG4gICAgICAgICAgICAgICAgc3ltYm9sU3R5bGUuc3Ryb2tlID0gY29sb3I7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fX2lzRW1wdHlCcnVzaCkge1xyXG4gICAgICAgICAgICAgICAgc3ltYm9sU3R5bGUuc3Ryb2tlID0gY29sb3I7XHJcbiAgICAgICAgICAgICAgICBzeW1ib2xTdHlsZS5maWxsID0gJyNmZmYnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gRklYTUUg5Yik5pat5Zu+5b2i6buY6K6k5piv5aGr5YWF6L+Y5piv5o+P6L6577yM5L2/55SoIG9ubHlTdHJva2UgP1xyXG4gICAgICAgICAgICAgICAgc3ltYm9sU3R5bGUuZmlsbCAmJiAoc3ltYm9sU3R5bGUuZmlsbCA9IGNvbG9yKTtcclxuICAgICAgICAgICAgICAgIHN5bWJvbFN0eWxlLnN0cm9rZSAmJiAoc3ltYm9sU3R5bGUuc3Ryb2tlID0gY29sb3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuZGlydHkoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHZhciBzeW1ib2xVdGlsID0ge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENyZWF0ZSBhIHN5bWJvbCBlbGVtZW50IHdpdGggZ2l2ZW4gc3ltYm9sIGNvbmZpZ3VyYXRpb246IHNoYXBlLCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCBjb2xvclxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzeW1ib2xUeXBlXHJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHhcclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0geVxyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3XHJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGhcclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gelxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb2xvclxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGNyZWF0ZVN5bWJvbDogZnVuY3Rpb24gKHN5bWJvbFR5cGUsIHgsIHksIHcsIGgsIGNvbG9yLCB6KSB7XHJcbiAgICAgICAgICAgIHZhciBpc0VtcHR5ID0gc3ltYm9sVHlwZS5pbmRleE9mKCdlbXB0eScpID09PSAwO1xyXG4gICAgICAgICAgICBpZiAoaXNFbXB0eSkge1xyXG4gICAgICAgICAgICAgICAgc3ltYm9sVHlwZSA9IHN5bWJvbFR5cGUuc3Vic3RyKDUsIDEpLnRvTG93ZXJDYXNlKCkgKyBzeW1ib2xUeXBlLnN1YnN0cig2KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgc3ltYm9sUGF0aDtcclxuXHJcbiAgICAgICAgICAgIGlmIChzeW1ib2xUeXBlLmluZGV4T2YoJ2ltYWdlOi8vJykgPT09IDApIHtcclxuICAgICAgICAgICAgICAgIHN5bWJvbFBhdGggPSBuZXcgZ3JhcGhpYy5JbWFnZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2U6IHN5bWJvbFR5cGUuc2xpY2UoOCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHg6IHgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHk6IHksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiB3LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGhcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIHo6IHpcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHN5bWJvbFR5cGUuaW5kZXhPZigncGF0aDovLycpID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBzeW1ib2xQYXRoID0gZ3JhcGhpYy5tYWtlUGF0aChzeW1ib2xUeXBlLnNsaWNlKDcpLCB7ejogen0sIG5ldyBCb3VuZGluZ1JlY3QoeCwgeSwgdywgaCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgc3ltYm9sUGF0aCA9IG5ldyBTeW1ib2woe1xyXG4gICAgICAgICAgICAgICAgICAgIHNoYXBlOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN5bWJvbFR5cGU6IHN5bWJvbFR5cGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHg6IHgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHk6IHksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiB3LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGhcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIHo6IHpcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBzeW1ib2xQYXRoLl9faXNFbXB0eUJydXNoID0gaXNFbXB0eTtcclxuXHJcbiAgICAgICAgICAgIHN5bWJvbFBhdGguc2V0Q29sb3IgPSBzeW1ib2xQYXRoU2V0Q29sb3I7XHJcblxyXG4gICAgICAgICAgICBzeW1ib2xQYXRoLnNldENvbG9yKGNvbG9yKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBzeW1ib2xQYXRoO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBzeW1ib2xVdGlsO1xyXG5cclxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2xpYi9maXNoLXRvcG8tY29yZS9saWIvc2hhcGVzL1N5bWJvbC5qc1xuICoqIG1vZHVsZSBpZCA9IDk3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcclxuICog55S75Y+l5p+EXHJcbiAqIEBhdXRob3Igd2FuZy54aWFvaHVcclxuICovXHJcblxyXG4gICAgdmFyIGdyYXBoaWMgPSByZXF1aXJlKFwiLi4vZ3JhcGhpYy5qc1wiKTtcclxuICAgIHZhciBVdGlsID0gcmVxdWlyZShcIi4uL3V0aWwuanNcIik7XHJcbiAgICBmdW5jdGlvbiBIYW5kbGUodHlwZSwgeCwgeSwgY29ubmVjdG9yKXtcclxuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xyXG5cclxuICAgICAgICB0aGlzLnggPSB4O1xyXG5cclxuICAgICAgICB0aGlzLnkgPSB5O1xyXG5cclxuICAgICAgICB0aGlzLnZpc2libGUgPSB0cnVlO1xyXG5cclxuICAgICAgICB0aGlzLmNvbm5lY3RvciA9IGNvbm5lY3RvcjtcclxuXHJcbiAgICAgICAgdGhpcy5oYW5kbGVTaGFwZSA9IG5ldyBncmFwaGljLkNpcmNsZSh7XHJcbiAgICAgICAgICAgIHNoYXBlOiB7XHJcbiAgICAgICAgICAgICAgICBjeDogeCxcclxuICAgICAgICAgICAgICAgIGN5OiB5LFxyXG4gICAgICAgICAgICAgICAgcjogSGFuZGxlLlJBRElVU1xyXG4gICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgIGZpbGw6IFwicmdiKDAsMjU1LDApXCIsXHJcbiAgICAgICAgICAgICAgICBzdHJva2U6XCJyZ2IoMCwwLDApXCJcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgeiA6IGNvbm5lY3Rvci5vcHRpb25zLnogKyAyLCAgLy/oioLngrla5Li6MSDnur/mrrXkuLowO1xyXG4gICAgICAgICAgICBkcmFnZ2FibGU6dHJ1ZVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5oYW5kbGVTaGFwZS5vbihcImRyYWdcIiwgZnVuY3Rpb24oZSkge1xyXG4gICAgICAgICAgICB0aGF0LmFjdGlvbkNvbm5lY3RvcihlLm9mZnNldFgsZS5vZmZzZXRZKTtcclxuICAgICAgICB9KTtcclxuICAgICAgIC8vIHJldHVybiB0aGlzLmNpcmNsZTtcclxuICAgIH1cclxuXHJcbiAgICBIYW5kbGUuUkFESVVTID0gNDtcclxuXHJcbiAgICBIYW5kbGUucHJvdG90eXBlID0ge1xyXG5cclxuICAgICAgICBjb25zdHJ1Y3RvciA6IEhhbmRsZSxcclxuXHJcbiAgICAgICAgZXF1YWxzIDogZnVuY3Rpb24oYW5vdGhlckhhbmRsZSl7XHJcbiAgICAgICAgICAgIGlmKCFhbm90aGVySGFuZGxlIGluc3RhbmNlb2YgSGFuZGxlKXtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudHlwZSA9PSBhbm90aGVySGFuZGxlLnR5cGVcclxuICAgICAgICAgICAgJiYgdGhpcy54ID09IGFub3RoZXJIYW5kbGUueFxyXG4gICAgICAgICAgICAmJiB0aGlzLnkgPT0gYW5vdGhlckhhbmRsZS55XHJcbiAgICAgICAgICAgICYmIHRoaXMudmlzaWJsZSA9PSBhbm90aGVySGFuZGxlLnZpc2libGU7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICog56e75Yqo5Y+l5p+EXHJcbiAgICAgICAgICogQHBhcmFtICB7W3R5cGVdfSBuZXdYIFtkZXNjcmlwdGlvbl1cclxuICAgICAgICAgKiBAcGFyYW0gIHtbdHlwZV19IG5ld1kgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICAgICAqIEByZXR1cm4ge1t0eXBlXX0gICAgICBbZGVzY3JpcHRpb25dXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgYWN0aW9uQ29ubmVjdG9yOiBmdW5jdGlvbihuZXdYLCBuZXdZKXtcclxuICAgICAgICAgICAgc3dpdGNoKHRoaXMudHlwZSl7XHJcbiAgICAgICAgICAgICAgICBjYXNlICd2JzpcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXg7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8g5om+5Ye65Lik5Liq6L2s5oqY54K577yI5Y+v56e75Yqo5Y+l5p+E5Zyo6L+Z5Lik5Liq6L2s5oqY54K55Lit6Ze077yJXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yKHZhciBpID0gMTsgaSA8IHRoaXMuY29ubmVjdG9yLnR1cm5pbmdQb2ludHMubGVuZ3RoLTE7IGkrKyl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHRoaXMuY29ubmVjdG9yLnR1cm5pbmdQb2ludHNbaS0xXS55ID09IHRoaXMuY29ubmVjdG9yLnR1cm5pbmdQb2ludHNbaV0ueVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgdGhpcy5jb25uZWN0b3IudHVybmluZ1BvaW50c1tpXS55ID09IHRoaXMueVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgTWF0aC5taW4odGhpcy5jb25uZWN0b3IudHVybmluZ1BvaW50c1tpXS54LCB0aGlzLmNvbm5lY3Rvci50dXJuaW5nUG9pbnRzW2ktMV0ueCkgPD0gdGhpcy54XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAmJiBNYXRoLm1heCh0aGlzLmNvbm5lY3Rvci50dXJuaW5nUG9pbnRzW2ldLngsIHRoaXMuY29ubmVjdG9yLnR1cm5pbmdQb2ludHNbaS0xXS54KSA+PSB0aGlzLngpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ID0gaTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB2YXIgZGVsdGFZID0gbmV3WSAtIHRoaXMueTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdHJhbnNsYXRpb25NYXRyaXggPSBVdGlsLnRyYW5zbGF0aW9uTWF0cml4KDAsIGRlbHRhWSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdG9yLnR1cm5pbmdQb2ludHNbaW5kZXgtMV0udHJhbnNmb3JtKHRyYW5zbGF0aW9uTWF0cml4KTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3Rvci50dXJuaW5nUG9pbnRzW2luZGV4XS50cmFuc2Zvcm0odHJhbnNsYXRpb25NYXRyaXgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdG9yLnJlZnJlc2goKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnkgPSBuZXdZOyAgLy/lsIblj6Xmn4TmlrDnmoTkvY3nva7otYvlgLznu5l5XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIGNhc2UgJ2gnOlxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmRleDtcclxuICAgICAgICAgICAgICAgICAgICAvLyDmib7lh7rkuKTkuKrovazmipjngrnvvIjlj6/np7vliqjlj6Xmn4TlnKjov5nkuKTkuKrovazmipjngrnkuK3pl7TvvIlcclxuICAgICAgICAgICAgICAgICAgICBmb3IodmFyIGkgPSAxOyBpIDwgdGhpcy5jb25uZWN0b3IudHVybmluZ1BvaW50cy5sZW5ndGgtMTsgaSsrKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYodGhpcy5jb25uZWN0b3IudHVybmluZ1BvaW50c1tpLTFdLnggPT0gdGhpcy5jb25uZWN0b3IudHVybmluZ1BvaW50c1tpXS54XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAmJiB0aGlzLmNvbm5lY3Rvci50dXJuaW5nUG9pbnRzW2ldLnggPT0gdGhpcy54XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAmJiBNYXRoLm1pbih0aGlzLmNvbm5lY3Rvci50dXJuaW5nUG9pbnRzW2ldLnksIHRoaXMuY29ubmVjdG9yLnR1cm5pbmdQb2ludHNbaS0xXS55KSA8PSB0aGlzLnlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICYmIE1hdGgubWF4KHRoaXMuY29ubmVjdG9yLnR1cm5pbmdQb2ludHNbaV0ueSwgdGhpcy5jb25uZWN0b3IudHVybmluZ1BvaW50c1tpLTFdLnkpID49IHRoaXMueSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ID0gaTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB2YXIgZGVsdGFYID0gbmV3WC10aGlzLng7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRyYW5zbGF0aW9uTWF0cml4ID0gVXRpbC50cmFuc2xhdGlvbk1hdHJpeChkZWx0YVgsIDApO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdG9yLnR1cm5pbmdQb2ludHNbaW5kZXgtMV0udHJhbnNmb3JtKHRyYW5zbGF0aW9uTWF0cml4KTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3Rvci50dXJuaW5nUG9pbnRzW2luZGV4XS50cmFuc2Zvcm0odHJhbnNsYXRpb25NYXRyaXgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdG9yLnJlZnJlc2goKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnggPSBuZXdYOyAvL+WwhuWPpeafhOaWsOeahOS9jee9rui1i+WAvOe7mXhcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAvLy4gdGhpcy5zaGFwZS51cGRhdGVNaWRkbGVUZXh0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIG1vZHVsZS5leHBvcnRzID0gSGFuZGxlO1xyXG5cclxuXHJcblxyXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vbGliL2Zpc2gtdG9wby1jb3JlL2xpYi9zaGFwZXMvSGFuZGxlLmpzXG4gKiogbW9kdWxlIGlkID0gOThcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxyXG4gKiDov57nur/liqjmgIHmlYjmnpxcclxuICogQGF1dGhvciBtaWFvLmN1bnpoaVxyXG4gKi9cclxuXHJcbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XHJcbiAgICB2YXIgdmVjMiA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdmVjdG9yJyk7XHJcbiAgICB2YXIgY3VydmVVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS9jdXJ2ZScpO1xyXG4gICAgdmFyIHN5bWJvbFV0aWwgPSByZXF1aXJlKCcuL1N5bWJvbC5qcycpO1xyXG5cclxuICAgIGZ1bmN0aW9uIEVmZmVjdExpbmUoc3ltYm9sLCBvcHRpb25zLCBncm91cEN1cnZlLCBwb2x5TGluZSkge1xyXG4gICAgICAgIHRoaXMuX2xhc3RGcmFtZSA9IDA7XHJcbiAgICAgICAgdGhpcy5fbGFzdEZyYW1lUGVyY2VudCA9IDA7XHJcbiAgICAgICAgdGhpcy5zeW1ib2wgPSBzeW1ib2w7XHJcbiAgICAgICAgdGhpcy5ncm91cEN1cnZlID0gZ3JvdXBDdXJ2ZTtcclxuICAgICAgICB0aGlzLmluaXRTeW1ib2wob3B0aW9ucywgcG9seUxpbmUpO1xyXG4gICAgfVxyXG4gICAgdmFyIEVmZmVjdExpbmVQcm90byA9IEVmZmVjdExpbmUucHJvdG90eXBlO1xyXG5cclxuICAgIEVmZmVjdExpbmVQcm90by5pbml0U3ltYm9sID0gZnVuY3Rpb24ob3B0aW9ucywgcG9seUxpbmUpIHtcclxuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5zeW1ib2wuejIgPSAxMDA7XHJcbiAgICAgICAgdGhpcy5zeW1ib2wuY3VsbGluZyA9IHRydWU7XHJcbiAgICAgICAgdmFyIHBlcmlvZCA9IG9wdGlvbnMuZWZmZWN0LnBlcmlvZCAqIDEwMDA7XHJcbiAgICAgICAgdGhpcy5zeW1ib2wuX190ID0gMDtcclxuICAgICAgICB0aGlzLnN5bWJvbC5zdG9wQW5pbWF0aW9uKCk7XHJcbiAgICAgICAgaWYgKChvcHRpb25zLnN0eWxlLmxpbmVUeXBlID09IFwiY3VydmVcIikpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuZ3JvdXBDdXJ2ZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGkgPSAwO1xyXG4gICAgICAgICAgICAgICAgcGVyaW9kID0gcGVyaW9kIC8gdGhpcy5ncm91cEN1cnZlLl9jaGlsZHJlbi5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmdyb3VwQ3VydmVBbmltYXRlKHRoaXMuZ3JvdXBDdXJ2ZS5fY2hpbGRyZW5bMF0sIGksIHBlcmlvZCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5zeW1ib2wuYW5pbWF0ZSgnJywgdHJ1ZSlcclxuICAgICAgICAgICAgICAgIC53aGVuKHBlcmlvZCwge1xyXG4gICAgICAgICAgICAgICAgICAgIF9fdDogMVxyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC5kZWxheSgwKVxyXG4gICAgICAgICAgICAgICAgLmR1cmluZyhmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGF0LnVwZGF0ZVN5bWJvbFBvc2l0aW9uUG9seWxpbmUoKTtcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAuc3RhcnQoKTtcclxuICAgICAgICAgICAgdGhpcy5zZXRBbmltYXRpb25Qb2ludHNQb2x5bGluZShwb2x5TGluZS5zaGFwZS5wb2ludHMpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9O1xyXG5cclxuICAgIEVmZmVjdExpbmVQcm90by5ncm91cEN1cnZlQW5pbWF0ZSA9IGZ1bmN0aW9uKGN1cnZlTGluZSwgaSwgcGVyaW9kKSB7XHJcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgICAgIGlmIChjdXJ2ZUxpbmUgPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIGN1cnZlTGluZSA9IHRoaXMuZ3JvdXBDdXJ2ZS5fY2hpbGRyZW5bMF07XHJcbiAgICAgICAgICAgIGkgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcG9pbnRzO1xyXG4gICAgICAgIHZhciBwb3MgPSBjdXJ2ZUxpbmUuc2hhcGU7XHJcbiAgICAgICAgcG9pbnRzID0gW1xyXG4gICAgICAgICAgICBbcG9zLngxLCBwb3MueTFdLFxyXG4gICAgICAgICAgICBbcG9zLngyLCBwb3MueTJdLFxyXG4gICAgICAgICAgICBbcG9zLmNweDEsIHBvcy5jcHkxXSxcclxuICAgICAgICAgICAgW3Bvcy5jcHgyLCBwb3MuY3B5Ml1cclxuICAgICAgICBdO1xyXG4gICAgICAgIHRoaXMuc2V0QW5pbWF0aW9uUG9pbnRzQmV6aWVyQ3VydmUocG9pbnRzKTtcclxuICAgICAgICB0aGlzLnN5bWJvbC5hbmltYXRlKCcnKVxyXG4gICAgICAgICAgICAud2hlbihwZXJpb2QsIHtcclxuICAgICAgICAgICAgICAgIF9fdDogMVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAuZGVsYXkoMClcclxuICAgICAgICAgICAgLmR1cmluZyhmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIHRoYXQudXBkYXRlU3ltYm9sUG9zaXRpb25CZXppZXJDdXJ2ZSgpO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAuZG9uZShmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIHRoYXQuc3ltYm9sLl9fdCA9IDA7XHJcbiAgICAgICAgICAgICAgICB0aGF0Lmdyb3VwQ3VydmVBbmltYXRlKHRoYXQuZ3JvdXBDdXJ2ZS5fY2hpbGRyZW5baSArIDFdLCBpICsgMSwgcGVyaW9kKTtcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgLnN0YXJ0KCk7XHJcblxyXG4gICAgfTtcclxuXHJcblxyXG4gICAgRWZmZWN0TGluZVByb3RvLnNldEFuaW1hdGlvblBvaW50c0JlemllckN1cnZlID0gZnVuY3Rpb24ocG9pbnRzKSB7XHJcbiAgICAgICAgdGhpcy5zeW1ib2wuX19wMSA9IHBvaW50c1swXTtcclxuICAgICAgICB0aGlzLnN5bWJvbC5fX3AyID0gcG9pbnRzWzFdO1xyXG4gICAgICAgIHRoaXMuc3ltYm9sLl9fY3AxID0gcG9pbnRzWzJdIHx8IFtcclxuICAgICAgICAgICAgKHBvaW50c1swXVswXSArIHBvaW50c1sxXVswXSkgLyAyLFxyXG4gICAgICAgICAgICAocG9pbnRzWzBdWzFdICsgcG9pbnRzWzFdWzFdKSAvIDJcclxuICAgICAgICBdO1xyXG4gICAgICAgIHRoaXMuc3ltYm9sLl9fY3AyID0gcG9pbnRzWzNdO1xyXG4gICAgfTtcclxuXHJcbiAgICBFZmZlY3RMaW5lUHJvdG8udXBkYXRlU3ltYm9sUG9zaXRpb25CZXppZXJDdXJ2ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBwMSA9IHRoaXMuc3ltYm9sLl9fcDE7XHJcbiAgICAgICAgdmFyIHAyID0gdGhpcy5zeW1ib2wuX19wMjtcclxuICAgICAgICB2YXIgY3AxID0gdGhpcy5zeW1ib2wuX19jcDE7XHJcbiAgICAgICAgdmFyIGNwMiA9IHRoaXMuc3ltYm9sLl9fY3AyO1xyXG4gICAgICAgIHZhciB0ID0gdGhpcy5zeW1ib2wuX190O1xyXG4gICAgICAgIHZhciBwb3MgPSB0aGlzLnN5bWJvbC5wb3NpdGlvbjtcclxuICAgICAgICB2YXIgdHgsIHR5O1xyXG4gICAgICAgIGlmIChjcDJbMF0gIT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHZhciBjdWJpY0F0ID0gY3VydmVVdGlsLmN1YmljQXQ7XHJcbiAgICAgICAgICAgIHZhciBjdWJpY0Rlcml2YXRpdmVBdCA9IGN1cnZlVXRpbC5jdWJpY0Rlcml2YXRpdmVBdDtcclxuICAgICAgICAgICAgcG9zWzBdID0gY3ViaWNBdChwMVswXSwgY3AxWzBdLCBjcDJbMF0sIHAyWzBdLCB0KTtcclxuICAgICAgICAgICAgcG9zWzFdID0gY3ViaWNBdChwMVsxXSwgY3AxWzFdLCBjcDJbMV0sIHAyWzFdLCB0KTtcclxuICAgICAgICAgICAgLy8gVGFuZ2VudFxyXG4gICAgICAgICAgICB0eCA9IGN1YmljRGVyaXZhdGl2ZUF0KHAxWzBdLCBjcDFbMF0sIGNwMlswXSwgcDJbMF0sIHQpO1xyXG4gICAgICAgICAgICB0eSA9IGN1YmljRGVyaXZhdGl2ZUF0KHAxWzFdLCBjcDFbMV0sIGNwMlsxXSwgcDJbMV0sIHQpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHZhciBxdWFkcmF0aWNBdCA9IGN1cnZlVXRpbC5xdWFkcmF0aWNBdDtcclxuICAgICAgICAgICAgdmFyIHF1YWRyYXRpY0Rlcml2YXRpdmVBdCA9IGN1cnZlVXRpbC5xdWFkcmF0aWNEZXJpdmF0aXZlQXQ7XHJcbiAgICAgICAgICAgIHBvc1swXSA9IHF1YWRyYXRpY0F0KHAxWzBdLCBjcDFbMF0sIHAyWzBdLCB0KTtcclxuICAgICAgICAgICAgcG9zWzFdID0gcXVhZHJhdGljQXQocDFbMV0sIGNwMVsxXSwgcDJbMV0sIHQpO1xyXG4gICAgICAgICAgICAvLyBUYW5nZW50XHJcbiAgICAgICAgICAgIHR4ID0gcXVhZHJhdGljRGVyaXZhdGl2ZUF0KHAxWzBdLCBjcDFbMF0sIHAyWzBdLCB0KTtcclxuICAgICAgICAgICAgdHkgPSBxdWFkcmF0aWNEZXJpdmF0aXZlQXQocDFbMV0sIGNwMVsxXSwgcDJbMV0sIHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnN5bWJvbC5yb3RhdGlvbiA9IC1NYXRoLmF0YW4yKHR5LCB0eCkgLSBNYXRoLlBJIC8gMjtcclxuXHJcbiAgICAgICAgdGhpcy5zeW1ib2wuaWdub3JlID0gZmFsc2U7XHJcbiAgICB9O1xyXG5cclxuICAgIEVmZmVjdExpbmVQcm90by5zZXRBbmltYXRpb25Qb2ludHNQb2x5bGluZSA9IGZ1bmN0aW9uKHBvaW50cykge1xyXG4gICAgICAgIHRoaXMuX3BvaW50cyA9IHBvaW50cztcclxuICAgICAgICB2YXIgYWNjTGVuQXJyID0gWzBdO1xyXG4gICAgICAgIHZhciBsZW4gPSAwO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBwMSA9IHBvaW50c1tpIC0gMV07XHJcbiAgICAgICAgICAgIHZhciBwMiA9IHBvaW50c1tpXTtcclxuICAgICAgICAgICAgbGVuICs9IHZlYzIuZGlzdChwMSwgcDIpO1xyXG4gICAgICAgICAgICBhY2NMZW5BcnIucHVzaChsZW4pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobGVuID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgYWNjTGVuQXJyLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgIGFjY0xlbkFycltqXSAvPSBsZW47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX29mZnNldHMgPSBhY2NMZW5BcnI7XHJcbiAgICAgICAgdGhpcy5fbGVuZ3RoID0gbGVuO1xyXG4gICAgICAgIHRoaXMuc3ltYm9sLl9sYXN0RnJhbWUgPSAwO1xyXG4gICAgICAgIHRoaXMuc3ltYm9sLl9fbGFzdEZyYW1lUGVyY2VudCA9IDA7XHJcbiAgICB9O1xyXG5cclxuICAgIEVmZmVjdExpbmVQcm90by51cGRhdGVTeW1ib2xQb3NpdGlvblBvbHlsaW5lID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIHQgPSB0aGlzLnN5bWJvbC5fX3Q7XHJcbiAgICAgICAgdmFyIHBvaW50cyA9IHRoaXMuX3BvaW50cztcclxuICAgICAgICB2YXIgb2Zmc2V0cyA9IHRoaXMuX29mZnNldHM7XHJcbiAgICAgICAgdmFyIGxlbiA9IHBvaW50cy5sZW5ndGg7XHJcblxyXG4gICAgICAgIGlmICghb2Zmc2V0cykge1xyXG4gICAgICAgICAgICAvLyBIYXMgbGVuZ3RoIDBcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGxhc3RGcmFtZSA9IHRoaXMuX2xhc3RGcmFtZTtcclxuICAgICAgICB2YXIgZnJhbWU7XHJcblxyXG4gICAgICAgIGlmICh0IDwgdGhpcy5fbGFzdEZyYW1lUGVyY2VudCkge1xyXG4gICAgICAgICAgICAvLyBTdGFydCBmcm9tIHRoZSBuZXh0IGZyYW1lXHJcbiAgICAgICAgICAgIC8vIFBFTkRJTkcgc3RhcnQgZnJvbSBsYXN0RnJhbWUgP1xyXG4gICAgICAgICAgICB2YXIgc3RhcnQgPSBNYXRoLm1pbihsYXN0RnJhbWUgKyAxLCBsZW4gLSAxKTtcclxuICAgICAgICAgICAgZm9yIChmcmFtZSA9IHN0YXJ0OyBmcmFtZSA+PSAwOyBmcmFtZS0tKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAob2Zmc2V0c1tmcmFtZV0gPD0gdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIFBFTkRJTkcgcmVhbGx5IG5lZWQgdG8gZG8gdGhpcyA/XHJcbiAgICAgICAgICAgIGZyYW1lID0gTWF0aC5taW4oZnJhbWUsIGxlbiAtIDIpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGZyYW1lID0gbGFzdEZyYW1lOyBmcmFtZSA8IGxlbjsgZnJhbWUrKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKG9mZnNldHNbZnJhbWVdID4gdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZyYW1lID0gTWF0aC5taW4oZnJhbWUgLSAxLCBsZW4gLSAyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmVjMi5sZXJwKFxyXG4gICAgICAgICAgICB0aGlzLnN5bWJvbC5wb3NpdGlvbiwgcG9pbnRzW2ZyYW1lXSwgcG9pbnRzW2ZyYW1lICsgMV0sXHJcbiAgICAgICAgICAgICh0IC0gb2Zmc2V0c1tmcmFtZV0pIC8gKG9mZnNldHNbZnJhbWUgKyAxXSAtIG9mZnNldHNbZnJhbWVdKVxyXG4gICAgICAgICk7XHJcblxyXG4gICAgICAgIHRoaXMuX2xhc3RGcmFtZSA9IGZyYW1lO1xyXG4gICAgICAgIHRoaXMuX2xhc3RGcmFtZVBlcmNlbnQgPSB0O1xyXG4gICAgICAgIHZhciBhbmdsZSA9IC1NYXRoLmF0YW4yKHBvaW50c1tmcmFtZSArIDFdWzFdIC0gcG9pbnRzW2ZyYW1lXVsxXSwgcG9pbnRzW2ZyYW1lICsgMV1bMF0gLSBwb2ludHNbZnJhbWVdWzBdKTtcclxuICAgICAgICB0aGlzLnN5bWJvbC5yb3RhdGlvbiA9IGFuZ2xlIC0gTWF0aC5QSSAvIDI7XHJcbiAgICAgICAgdGhpcy5zeW1ib2wuaWdub3JlID0gZmFsc2U7XHJcbiAgICB9O1xyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBFZmZlY3RMaW5lO1xyXG5cclxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2xpYi9maXNoLXRvcG8tY29yZS9saWIvc2hhcGVzL0VmZmVjdExpbmUuanNcbiAqKiBtb2R1bGUgaWQgPSA5OVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXHJcbiAqIOaOp+WItueCuVxyXG4gKiBAYXV0aG9yIHdhbmcueGlhb2h1XHJcbiAqL1xyXG5cclxuICAgIHZhciBncmFwaGljID0gcmVxdWlyZShcIi4uL2dyYXBoaWMuanNcIik7XHJcbiAgICB2YXIgVXRpbCA9IHJlcXVpcmUoXCIuLi91dGlsLmpzXCIpO1xyXG4gICAgZnVuY3Rpb24gQ29ubmVjdGlvblBvaW50KGNvbm5lY3RvciwgcG9pbnQsIHR5cGUsIG9wdGlvbnMpe1xyXG4gICAgICAgIHRoaXMuY29ubmVjdG9yID0gY29ubmVjdG9yO1xyXG5cclxuICAgICAgICB0aGlzLnBvaW50ID0gcG9pbnQuY2xvbmUoKTtcclxuXHJcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcclxuXHJcbiAgICAgICAgdGhpcy5jb2xvciA9IENvbm5lY3Rpb25Qb2ludC5OT1JNQUxfQ09MT1I7XHJcblxyXG4gICAgICAgIHRoaXMub1R5cGUgPSAnQ29ubmVjdGlvblBvaW50JztcclxuXHJcbiAgICAgICAgdGhpcy5zaGFwZSA9IG5ldyBncmFwaGljLkNpcmNsZSh7XHJcbiAgICAgICAgICAgIHNoYXBlOiB7XHJcbiAgICAgICAgICAgICAgICBjeDogdGhpcy5wb2ludC54LFxyXG4gICAgICAgICAgICAgICAgY3k6IHRoaXMucG9pbnQueSxcclxuICAgICAgICAgICAgICAgIHI6IENvbm5lY3Rpb25Qb2ludC5SQURJVVNcclxuICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgIHN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgICBmaWxsOiB0aGlzLmNvbG9yLFxyXG4gICAgICAgICAgICAgICAgc3Ryb2tlOicjMDAwMDAwJ1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB6IDogb3B0aW9ucy56ICsgMiAgLy/oioLngrla5Li6MSDnur/mrrXkuLowO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuc2hhcGUudHlwZSA9ICB0aGlzLnR5cGU7XHJcblxyXG4gICAgICAgIHRoaXMuc2hhcGUuY29ubmVjdG9yID0gY29ubmVjdG9yO1xyXG4gICAgICAgIC8vcmV0dXJuIHRoaXMuY2lyY2xlO1xyXG4gICAgfVxyXG5cclxuICAgIENvbm5lY3Rpb25Qb2ludC5OT1JNQUxfQ09MT1IgPSBcIiNGRkZGMzNcIjsgLy95ZWxsb3cuXHJcblxyXG4gICAgQ29ubmVjdGlvblBvaW50Lk9WRVJfQ09MT1IgPSBcIiNGRjk5MDBcIjsgLy9vcmFuZ2VcclxuXHJcbiAgICBDb25uZWN0aW9uUG9pbnQuQ09OTkVDVEVEX0NPTE9SID0gXCIjZmYwMDAwXCI7IC8vcmVkXHJcblxyXG4gICAgQ29ubmVjdGlvblBvaW50LlJBRElVUyA9IDQ7XHJcblxyXG4gICAgQ29ubmVjdGlvblBvaW50LlRZUEVfRklHVVJFID0gJ2ZpZ3VyZSc7XHJcblxyXG4gICAgQ29ubmVjdGlvblBvaW50LlRZUEVfQ09OTkVDVE9SID0gJ2Nvbm5lY3Rvcic7XHJcblxyXG4gICAgQ29ubmVjdGlvblBvaW50LnByb3RvdHlwZSA9IHtcclxuXHJcbiAgICAgICAgY29uc3RydWN0b3IgOiBDb25uZWN0aW9uUG9pbnQsXHJcblxyXG4gICAgICAgIGVxdWFscyA6IGZ1bmN0aW9uKGFub3RoZXJDb25uZWN0aW9uUG9pbnQpe1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wb2ludC5lcXVhbHMoYW5vdGhlckNvbm5lY3Rpb25Qb2ludC5wb2ludClcclxuICAgICAgICAgICAgJiYgdGhpcy5jb25uZWN0b3IgPT0gYW5vdGhlckNvbm5lY3Rpb25Qb2ludC5jb25uZWN0b3JcclxuICAgICAgICAgICAgJiYgdGhpcy50eXBlID09IGFub3RoZXJDb25uZWN0aW9uUG9pbnQudHlwZVxyXG4gICAgICAgICAgICAmJiB0aGlzLmNvbG9yID09IGFub3RoZXJDb25uZWN0aW9uUG9pbnQuY29sb3JcclxuICAgICAgICAgICAgJiYgdGhpcy5yYWRpdXMgPT0gYW5vdGhlckNvbm5lY3Rpb25Qb2ludC5yYWRpdXM7XHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICB9O1xyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBDb25uZWN0aW9uUG9pbnQ7XHJcblxyXG5cclxuXHJcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9saWIvZmlzaC10b3BvLWNvcmUvbGliL3NoYXBlcy9Db25uZWN0aW9uUG9pbnQuanNcbiAqKiBtb2R1bGUgaWQgPSAxMDBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxyXG4gKiBCUE1O6Z2Z5oCB5pa55rOV57G7XHJcbiAqIEBjbGFzcyBmaXNoLnRvcG8uRmlzaFRvcG9CcG1uLkJwbW5cclxuICovXHJcblxyXG5cdHZhciBCcG1uID0ge1xyXG5cdFx0QlBNTl9UWVBFOlwic3RlbmNpbC50eXBlXCIsXHJcblx0XHRCUE1OX1NDUklQVF9UQVNLOiBcIlNjcmlwdFRhc2tcIixcclxuXHRcdEJQTU5fRVZFTlRfU1VCX1BST0NFU1M6IFwiU3ViUHJvY2Vzc1Rhc2tcIixcclxuXHRcdEJQTU5fVEFTSzpcIlRhc2tcIixcclxuXHRcdFRFTVBMQVRFOiBcIkJQTU5EaWFncmFtXCIsXHJcblx0XHRSRVNPVVJDRV9JRDogXCJyZXNvdXJjZUlkXCIsXHJcblx0XHRTRVFVRU5DRV9GTE9XOiBcIlNlcXVlbmNlRmxvd1wiLFxyXG5cdFx0U1VCX1BST0NFU1M6IFwiU3ViUHJvY2Vzc1wiLFxyXG5cdFx0VVNFUl9EQVRBOiBcInByb3BlcnRpZXMudXNlckRhdGFcIixcclxuXHJcblx0XHRTVEFSVF9FVkVOVDogXCJTdGFydE5vbmVFdmVudFwiLFxyXG5cdFx0RU5EX0VWRU5UOiBcIkVuZE5vbmVFdmVudFwiLFxyXG5cdFx0VVNFUl9UQVNLOiBcIlVzZXJUYXNrXCIsXHJcblx0XHRNQU5VQUxfVEFTSzogXCJNYW51YWxUYXNrXCIsXHJcblx0XHRTQ1JJUFRfVEFTSzogXCJTY3JpcHRUYXNrXCIsXHJcblx0XHRNQUlMX1RBU0s6IFwiTWFpbFRhc2tcIixcclxuXHRcdENBVENIX1RJTUVSX0VWRU5UOiBcIkNhdGNoVGltZXJFdmVudFwiLFxyXG5cdFx0Q0FUQ0hfU0lHTkFMX0VWRU5UOiBcIkNhdGNoU2lnbmFsRXZlbnRcIixcclxuXHRcdFRIUk9XX1NJR05BTF9FVkVOVDogXCJUaHJvd1NpZ25hbEV2ZW50XCIsXHJcblx0XHRJTkNMVVNJVkVfR0FURVdBWTogXCJJbmNsdXNpdmVHYXRld2F5XCIsXHJcblx0XHRFWENMVVNJVkVfR0FURVdBWTogXCJFeGNsdXNpdmVHYXRld2F5XCIsXHJcblx0XHRQQVJBTExFTF9HQVRFV0FZOiBcIlBhcmFsbGVsR2F0ZXdheVwiLFxyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICog5Yik5pat6IqC54K55piv5ZCmIEJQTU7mqKHmnb8g57G75Z6LXHJcblx0XHQgKiBAcGFyYW0gIHtPYmplY3R9ICBub2RlIOmcgOimgeWIpOaWreexu+Wei+eahOiKgueCuVxyXG5cdFx0ICogQHJldHVybiB7Qm9vbGVhbn0gICAgICDmmK8g5ZCmXHJcblx0XHQgKi9cclxuXHRcdGlzVGVtcGxhdGU6IGZ1bmN0aW9uKG5vZGUpIHtcclxuXHRcdFx0dmFyIGJwbW50eXBlID0gbm9kZS5tb2RlbC5nZXQoQnBtbi5CUE1OX1RZUEUpO1xyXG5cdFx0XHRyZXR1cm4gYnBtbnR5cGUgPT09IEJwbW4uVEVNUExBVEU7XHJcblx0XHR9LFxyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICog5Yik5pat6IqC54K55piv5ZCmIEFjdGl2aXR5IOexu+Wei1xyXG5cdFx0ICogQHBhcmFtICB7T2JqZWN0fSAgbm9kZSDpnIDopoHliKTmlq3nsbvlnovnmoToioLngrlcclxuXHRcdCAqIEByZXR1cm4ge0Jvb2xlYW59ICAgICAg5pivIOWQplxyXG5cdFx0ICovXHJcblx0XHRpc0FjdGl2aXR5OiBmdW5jdGlvbihub2RlKSB7XHJcblx0XHRcdHZhciBicG1udHlwZSA9IG5vZGUubW9kZWwuZ2V0KEJwbW4uQlBNTl9UWVBFKTtcclxuXHRcdFx0cmV0dXJuIChicG1udHlwZS5pbmRleE9mKFwiVGFza1wiKSAhPSAtMSk7XHJcblx0XHR9LFxyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICog5Yik5pat6IqC54K55piv5ZCmIOWtkOa1geeoiyDnsbvlnotcclxuXHRcdCAqIEBwYXJhbSAge09iamVjdH0gIG5vZGUg6ZyA6KaB5Yik5pat57G75Z6L55qE6IqC54K5XHJcblx0XHQgKiBAcmV0dXJuIHtCb29sZWFufSAgICAgIOaYryDlkKZcclxuXHRcdCAqL1xyXG5cdFx0aXNTdWJQcm9jZXNzOiBmdW5jdGlvbihub2RlKSB7XHJcblx0XHRcdHZhciBicG1udHlwZSA9IG5vZGUubW9kZWwuZ2V0KEJwbW4uQlBNTl9UWVBFKTtcclxuXHRcdFx0cmV0dXJuICBicG1udHlwZSA9PSBCcG1uLlNVQl9QUk9DRVNTXHJcblx0XHR9LFxyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICog5Yik5pat6IqC54K55piv5ZCmIOe9keWFsyDnsbvlnotcclxuXHRcdCAqIEBwYXJhbSAge09iamVjdH0gIG5vZGUg6ZyA6KaB5Yik5pat57G75Z6L55qE6IqC54K5XHJcblx0XHQgKiBAcmV0dXJuIHtCb29sZWFufSAgICAgIOaYryDlkKZcclxuXHRcdCAqL1xyXG5cdFx0aXNHYXRld2F5OiBmdW5jdGlvbihub2RlKSB7XHJcblx0XHRcdHZhciBicG1udHlwZSA9IG5vZGUubW9kZWwuZ2V0KEJwbW4uQlBNTl9UWVBFKTtcclxuXHRcdFx0cmV0dXJuIGJwbW50eXBlLmluZGV4T2YoXCJHYXRld2F5XCIpICE9IC0xO1xyXG5cdFx0fSxcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIOWIpOaWreiKgueCueaYr+WQpiDnur/mrrUg57G75Z6LXHJcblx0XHQgKiBAcGFyYW0gIHtPYmplY3R9ICBub2RlIOmcgOimgeWIpOaWreexu+Wei+eahOiKgueCuVxyXG5cdFx0ICogQHJldHVybiB7Qm9vbGVhbn0gICAgICDmmK8g5ZCmXHJcblx0XHQgKi9cclxuXHRcdGlzRmxvdzogZnVuY3Rpb24obm9kZSkge1xyXG5cdFx0XHR2YXIgYnBtbnR5cGUgPSBub2RlLm1vZGVsLmdldChCcG1uLkJQTU5fVFlQRSk7XHJcblx0XHRcdHJldHVybiBicG1udHlwZSA9PT0gQnBtbi5TRVFVRU5DRV9GTE9XO1xyXG5cdFx0fSxcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIEBwcml2YXRlXHJcblx0XHQgKiDliKTmlq3mqKHlnovmmK/lkKYg57q/5q61IOexu+Wei1xyXG5cdFx0ICogQHBhcmFtICB7T2JqZWN0fSAgbW9kZWwg6ZyA6KaB5Yik5pat57G75Z6L55qE5qih5Z6LXHJcblx0XHQgKiBAcmV0dXJuIHtCb29sZWFufSAgICAgIOaYryDlkKZcclxuXHRcdCAqL1xyXG5cdFx0aXNGbG93TW9kZWw6IGZ1bmN0aW9uKG1vZGVsKSB7XHJcblx0XHRcdHZhciBicG1udHlwZSA9IG1vZGVsLmdldChCcG1uLkJQTU5fVFlQRSk7XHJcblx0XHRcdHJldHVybiBicG1udHlwZSA9PT0gQnBtbi5TRVFVRU5DRV9GTE9XO1xyXG5cdFx0fSxcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIOWIpOaWreiKgueCueaYr+WQpiDkuovku7Yg57G75Z6LXHJcblx0XHQgKiBAcGFyYW0gIHtPYmplY3R9ICBub2RlIOmcgOimgeWIpOaWreexu+Wei+eahOiKgueCuVxyXG5cdFx0ICogQHJldHVybiB7Qm9vbGVhbn0gICAgICDmmK8g5ZCmXHJcblx0XHQgKi9cclxuXHRcdGlzRXZlbnQ6IGZ1bmN0aW9uKG5vZGUpIHtcclxuXHRcdFx0dmFyIGJwbW50eXBlID0gbm9kZS5tb2RlbC5nZXQoQnBtbi5CUE1OX1RZUEUpO1xyXG5cdFx0XHRyZXR1cm4gYnBtbnR5cGUuaW5kZXhPZihcIkV2ZW50XCIpICE9IC0xO1xyXG5cdFx0fSxcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIOWIpOaWreiKgueCueaYr+WQpiDmj5Lns5/kuovku7Yg57G75Z6LXHJcblx0XHQgKiBAcGFyYW0gIHtPYmplY3R9ICBub2RlIOmcgOimgeWIpOaWreexu+Wei+eahOiKgueCuVxyXG5cdFx0ICogQHJldHVybiB7Qm9vbGVhbn0gICAgICDmmK8g5ZCmXHJcblx0XHQgKi9cclxuXHRcdGlzU2xvdEV2ZW50OiBmdW5jdGlvbihub2RlKSB7XHJcblx0XHRcdHZhciBicG1udHlwZSA9IG5vZGUubW9kZWwuZ2V0KEJwbW4uQlBNTl9UWVBFKTtcclxuXHRcdFx0cmV0dXJuIGJwbW50eXBlID09IEJwbW4uQ0FUQ0hfVElNRVJfRVZFTlQgfHwgYnBtbnR5cGUgPT0gQnBtbi5DQVRDSF9TSUdOQUxfRVZFTlQgfHwgYnBtbnR5cGUgPT0gQnBtbi5USFJPV19TSUdOQUxfRVZFTlQ7XHJcblx0XHR9LFxyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICog6I635Y+W5b2T5YmN6IqC54K555qE57G75Z6LXHJcblx0XHQgKiBAcGFyYW0gIHtPYmplY3R9ICBub2RlIOmcgOimgeWIpOaWreexu+Wei+eahOiKgueCuVxyXG5cdFx0ICogQHJldHVybiB7U3RyaW5nfSAgICAgIOiKgueCueeahOexu+Wei1xyXG5cdFx0ICovXHJcblx0XHRnZXRUeXBlOiBmdW5jdGlvbihub2RlKSB7XHJcblx0XHRcdHZhciBicG1udHlwZSA9IG5vZGUubW9kZWwuZ2V0KEJwbW4uQlBNTl9UWVBFKTtcclxuXHRcdFx0cmV0dXJuIGJwbW50eXBlO1xyXG5cdFx0fSxcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIOi/lOWbnuW9k+WJjeiKgueCueeahOagt+W8j+mAiemhuVxyXG5cdFx0ICogQHBhcmFtICB7T2JqZWN0fSAgbm9kZSDpnIDopoHliKTmlq3nsbvlnovnmoToioLngrlcclxuXHRcdCAqIEByZXR1cm4ge09iamVjdH0gICAgICDmoLflvI/lr7nosaFcclxuXHRcdCAqL1xyXG5cdFx0Z2V0U3R5bGU6IGZ1bmN0aW9uKG5vZGUpIHtcclxuXHRcdFx0cmV0dXJuIG5vZGUubW9kZWwub3B0aW9uLnN0eWxlO1xyXG5cdFx0fSxcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIOi/lOWbnuW9k+WJjeiKgueCueeahOWxnuaAp+mAiemhuVxyXG5cdFx0ICogQHBhcmFtICB7T2JqZWN0fSAgbm9kZSDpnIDopoHliKTmlq3nsbvlnovnmoToioLngrlcclxuXHRcdCAqIEByZXR1cm4gIHtPYmplY3R9ICAgICAg5bGe5oCn5a+56LGhXHJcblx0XHQgKi9cclxuXHRcdGdldFByb3A6IGZ1bmN0aW9uKG5vZGUpIHtcclxuXHRcdFx0cmV0dXJuIG5vZGUubW9kZWwub3B0aW9uLnByb3BlcnRpZXM7XHJcblx0XHR9LFxyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICog6I635Y+W55So5oi36Ieq5a6a5LmJ55qE5pWw5o2uXHJcblx0XHQgKiBAcGFyYW0gIHtPYmplY3R9ICBub2RlIOmcgOimgeWIpOaWreexu+Wei+eahOiKgueCuVxyXG5cdFx0ICogQHJldHVybiB7T2JqZWN0fSAgIOeUqOaIt+iHquWumuS5ieeahOaVsOaNrlxyXG5cdFx0ICovXHJcblx0XHRnZXRVc2VyRGF0YTogZnVuY3Rpb24obm9kZSkge1xyXG5cdFx0XHR2YXIgbW9kZWwgPSBub2RlLm1vZGVsO1xyXG5cdFx0XHRyZXR1cm4gbW9kZWwuZ2V0KEJwbW4uVVNFUl9EQVRBKTtcclxuXHRcdH0sXHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiDorr7nva7nlKjmiLfnmoToh6rlrprkuYnmlbDmja5cclxuXHRcdCAqIEBwYXJhbSAge09iamVjdH0gIG5vZGUg6ZyA6KaB5Yik5pat57G75Z6L55qE6IqC54K5XHJcblx0XHQgKiBAcGFyYW0ge09iamVjdH0gdXNlckRhdGEg55So5oi355qE6Ieq5a6a5LmJ5pWw5o2uXHJcblx0XHQgKi9cclxuXHRcdHNldFVzZXJEYXRhOiBmdW5jdGlvbihub2RlLCB1c2VyRGF0YSkge1xyXG5cdFx0XHR2YXIgbW9kZWwgPSBub2RlLm1vZGVsO1xyXG5cdFx0XHRtb2RlbC5zZXQoQnBtbi5VU0VSX0RBVEEsIHVzZXJEYXRhKTtcclxuXHRcdH1cclxuXHR9O1xyXG5cclxuXHRtb2R1bGUuZXhwb3J0cyA9IEJwbW47XHJcblxyXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vbGliL2Zpc2gtdG9wby1icG1uL2xpYi9CcG1uLmpzXG4gKiogbW9kdWxlIGlkID0gMTAxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcclxuICog6YCJ5Lit6IqC54K55ZCO77yM5Ye6546w55qE5pON5L2c5qGG5Y+K5oyJ6ZKuXHJcbiAqL1xyXG5cclxuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcclxuICAgIHZhciBncmFwaGljID0gcmVxdWlyZShcIi4uLy4uLy4uL2Zpc2gtdG9wby1jb3JlL2xpYi9ncmFwaGljLmpzXCIpO1xyXG4gICAgdmFyIHV0aWwgPSByZXF1aXJlKFwiLi4vLi4vLi4vZmlzaC10b3BvLWNvcmUvbGliL3V0aWwuanNcIik7XHJcbiAgICB2YXIgQnBtbiA9IHJlcXVpcmUoXCIuLi9CcG1uLmpzXCIpO1xyXG4gICAgdmFyIE9wZXJhdGlvbk5vZGUgPSByZXF1aXJlKFwiLi4vLi4vLi4vZmlzaC10b3BvLWNvcmUvbGliL21hbmFnZXIvT3BlcmF0aW9uTm9kZS5qc1wiKTtcclxuXHJcbiAgICBmdW5jdGlvbiBCcG1uT3BlcmF0aW9uTm9kZShub2RlLCB6ciwgZm9yYmlkRWRpdCkge1xyXG4gICAgICAgIE9wZXJhdGlvbk5vZGUuY2FsbCh0aGlzLCBub2RlLCB6ciwgZm9yYmlkRWRpdCk7XHJcbiAgICB9XHJcblxyXG4gICAgQnBtbk9wZXJhdGlvbk5vZGUucHJvdG90eXBlLnJlbmRlck90aGVyID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgaWYgKEJwbW4uaXNTdWJQcm9jZXNzKHRoaXMubm9kZSkpIHtcclxuICAgICAgICAgICAgLy/lt6bkuIrop5LmlL7lpKfnrq3lpLRcclxuICAgICAgICAgICAgdmFyIGxlZnRUb3BBcnJvdyA9IHsgeDogMCwgeTogMCwgd2lkdGg6IDEwLCBoZWlnaHQ6IDEwIH07XHJcbiAgICAgICAgICAgIHZhciBsZWZ0VG9wQXJyb3dQYXRoID0gJ00wIDEwMCBMMCAwIEwxMDAgMCBMMTAwIDIwIEwyMCAyMCBMMjAgMTAwIHonO1xyXG4gICAgICAgICAgICB0aGlzLmxlZnRUb3AgPSBncmFwaGljLm1ha2VQYXRoKGxlZnRUb3BBcnJvd1BhdGgsIHsgc3R5bGU6IHsgZmlsbDogJyMwMDAwMDAnIH0gfSwgbGVmdFRvcEFycm93KTtcclxuICAgICAgICAgICAgdGhpcy5sZWZ0VG9wLmF0dHIoXCJjdXJzb3JcIiwgXCJudy1yZXNpemVcIik7XHJcbiAgICAgICAgICAgIHRoaXMubGVmdFRvcC5pc1NlbGZDb21wdXRlUG9zID0gdHJ1ZTsgIC8vIOiHquW3seiuoeeul+S9jee9rlxyXG4gICAgICAgICAgICAvL+WPs+S4i+inkuaUvuWkp+eureWktFxyXG4gICAgICAgICAgICB2YXIgcmlnaHRCb3R0b21BcnJvdyA9IHsgeDogMCwgeTogMCwgd2lkdGg6IDEwLCBoZWlnaHQ6IDEwIH07XHJcbiAgICAgICAgICAgIHZhciByaWdodEJvdHRvbUFycm93UGF0aCA9ICdNMCAxMDAgTDEwMCAxMDAgTDEwMCAwIEw4MCAwIEw4MCA4MCBMMCA4MCB6JztcclxuICAgICAgICAgICAgdGhpcy5yaWdodEJvdHRvbSA9IGdyYXBoaWMubWFrZVBhdGgocmlnaHRCb3R0b21BcnJvd1BhdGgsIHsgc3R5bGU6IHsgZmlsbDogJyMwMDAwMDAnIH0gfSwgcmlnaHRCb3R0b21BcnJvdyk7XHJcbiAgICAgICAgICAgIHRoaXMucmlnaHRCb3R0b20uYXR0cihcImN1cnNvclwiLCBcInNlLXJlc2l6ZVwiKTtcclxuICAgICAgICAgICAgdGhpcy5yaWdodEJvdHRvbS5pc1NlbGZDb21wdXRlUG9zID0gdHJ1ZTsgIC8vIOiHquW3seiuoeeul+S9jee9rlxyXG5cclxuICAgICAgICAgICAgdGhpcy5hZGQodGhpcy5yaWdodEJvdHRvbSk7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkKHRoaXMubGVmdFRvcCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBCcG1uT3BlcmF0aW9uTm9kZS5wcm90b3R5cGUucmVmcmVzaFBvc2l0aW9uT3RoZXIgPSBmdW5jdGlvbihub2RlLG5vZGVSZWN0KSB7XHJcbiAgICAgICAgaWYgKEJwbW4uaXNTdWJQcm9jZXNzKHRoaXMubm9kZSkpIHtcclxuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgICAgICAgICB2YXIgc3RhcnRYLCBzdGFydFk7XHJcbiAgICAgICAgICAgIHZhciBwaXhlbCA9IDIwO1xyXG4gICAgICAgICAgICAvL+efqeW9ouacgOWwj+mVv+WSjOWuvVxyXG4gICAgICAgICAgICB2YXIgd2lkdGhNaW4gPSAxMDA7XHJcbiAgICAgICAgICAgIHZhciBoZWlnaHRNaW4gPSA2MDtcclxuICAgICAgICAgICAgdmFyIGxlZnRUb3BQb3NpdGlvbiwgbm93bGVmdFRvcFBvc2l0aW9uID0gW10sXHJcbiAgICAgICAgICAgICAgICBzdGFydFNsb3RQb2ludHMsIHN0YXJ0UG9zaXRpb247XHJcbiAgICAgICAgICAgIHRoaXMubGVmdFRvcC5vbignbW91c2Vkb3duJywgZnVuY3Rpb24oZSkge1xyXG4gICAgICAgICAgICAgICAgc3RhcnRTbG90UG9pbnRzID0gdXRpbC5nZXRTb2x0UG9pbnRzKG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgc3RhcnRQb3NpdGlvbiA9IHpyVXRpbC5jbG9uZShub2RlLnBvc2l0aW9uKTtcclxuICAgICAgICAgICAgICAgIGxlZnRUb3BQb3NpdGlvbiA9IG5vZGVSZWN0LnBvaW50c1swXTtcclxuICAgICAgICAgICAgICAgIHN0YXJ0WCA9IGUuZXZlbnQuY2xpZW50WDtcclxuICAgICAgICAgICAgICAgIHN0YXJ0WSA9IGUuZXZlbnQuY2xpZW50WTtcclxuICAgICAgICAgICAgICAgIGxlZnRTY2FsZURyYWcoZSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgZnVuY3Rpb24gbGVmdFNjYWxlRHJhZyhlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbGVmdEFycm93ID0gZnVuY3Rpb24oZSkgeyBsZWZ0QXJyb3dEcmFnKGUpOyB9O1xyXG5cclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGxlZnRBcnJvd0RyYWcoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vMuS4quWchumXtOi3neWkquWwj+aXtizkuI3lnKjmi5bliqhcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhhdC5yaWdodEJvdHRvbS5wb3NpdGlvblswXSAtIHRoYXQubGVmdFRvcC5wb3NpdGlvblswXSA8ICh3aWR0aE1pbiArIDEwKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhhdC5yaWdodEJvdHRvbS5wb3NpdGlvblsxXSAtIHRoYXQubGVmdFRvcC5wb3NpdGlvblsxXSA8IChoZWlnaHRNaW4gKyAxMCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQubGVmdFRvcC5wb3NpdGlvblswXSA9IHRoYXQucmlnaHRCb3R0b20ucG9zaXRpb25bMF0gLSAod2lkdGhNaW4gKyAxMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGF0LmxlZnRUb3AucG9zaXRpb25bMV0gPSB0aGF0LnJpZ2h0Qm90dG9tLnBvc2l0aW9uWzFdIC0gKGhlaWdodE1pbiArIDEwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQubGVmdFRvcC5wb3NpdGlvblswXSA9IHRoYXQucmlnaHRCb3R0b20ucG9zaXRpb25bMF0gLSAod2lkdGhNaW4gKyAxMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY2FsZVJlY3QodGhhdC5sZWZ0VG9wLCBlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGF0LnJpZ2h0Qm90dG9tLnBvc2l0aW9uWzFdIC0gdGhhdC5sZWZ0VG9wLnBvc2l0aW9uWzFdIDwgKGhlaWdodE1pbikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQubGVmdFRvcC5wb3NpdGlvblsxXSA9IHRoYXQucmlnaHRCb3R0b20ucG9zaXRpb25bMV0gLSAoaGVpZ2h0TWluICsgMTApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NhbGVSZWN0KHRoYXQubGVmdFRvcCwgZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY2FsZVJlY3QodGhhdC5sZWZ0VG9wLCBlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gc2NhbGVSZWN0KGRvbSwgZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZG9tUG9zaXRpb24gPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgbiA9IDA7IG4gPD0gTWF0aC5hYnMocGFyc2VJbnQoKGUuZXZlbnQuY2xpZW50WCAtIHN0YXJ0WCkgLyBwaXhlbCkpOyBuKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlLmV2ZW50LmNsaWVudFggLSBzdGFydFggPD0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vd2xlZnRUb3BQb3NpdGlvblswXSA9IGxlZnRUb3BQb3NpdGlvblswXSAtIHBpeGVsICogKG4pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbVBvc2l0aW9uWzBdID0gbm93bGVmdFRvcFBvc2l0aW9uWzBdIC0gMTA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbm93bGVmdFRvcFBvc2l0aW9uWzBdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vd2xlZnRUb3BQb3NpdGlvblswXSA9IGxlZnRUb3BQb3NpdGlvblswXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGVSZWN0LnBvaW50c1syXVswXSAtIG5vd2xlZnRUb3BQb3NpdGlvblswXSA+IHdpZHRoTWluKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vd2xlZnRUb3BQb3NpdGlvblswXSA9IGxlZnRUb3BQb3NpdGlvblswXSArIHBpeGVsICogKG4pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb21Qb3NpdGlvblswXSA9IG5vd2xlZnRUb3BQb3NpdGlvblswXSAtIDEwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbVBvc2l0aW9uWzBdID0gdGhhdC5yaWdodEJvdHRvbS5wb3NpdGlvblswXSAtIHdpZHRoTWluO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBtID0gMDsgbSA8PSBNYXRoLmFicyhwYXJzZUludCgoZS5ldmVudC5jbGllbnRZIC0gc3RhcnRZKSAvIHBpeGVsKSk7IG0rKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGUuZXZlbnQuY2xpZW50WSAtIHN0YXJ0WSA8PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm93bGVmdFRvcFBvc2l0aW9uWzFdID0gbGVmdFRvcFBvc2l0aW9uWzFdIC0gcGl4ZWwgKiAobSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9tUG9zaXRpb25bMV0gPSBub3dsZWZ0VG9wUG9zaXRpb25bMV0gLSAxMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFub3dsZWZ0VG9wUG9zaXRpb25bMV0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm93bGVmdFRvcFBvc2l0aW9uWzFdID0gbGVmdFRvcFBvc2l0aW9uWzFdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZVJlY3QucG9pbnRzWzJdWzFdIC0gbm93bGVmdFRvcFBvc2l0aW9uWzFdID4gaGVpZ2h0TWluKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vd2xlZnRUb3BQb3NpdGlvblsxXSA9IGxlZnRUb3BQb3NpdGlvblsxXSArIHBpeGVsICogKG0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb21Qb3NpdGlvblsxXSA9IG5vd2xlZnRUb3BQb3NpdGlvblsxXSAtIDEwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbVBvc2l0aW9uWzFdID0gdGhhdC5yaWdodEJvdHRvbS5wb3NpdGlvblsxXSAtIGhlaWdodE1pbjtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbS5hdHRyKFwicG9zaXRpb25cIiwgZG9tUG9zaXRpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcG9pbnRzID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50c1swXSA9IFtub3dsZWZ0VG9wUG9zaXRpb25bMF0sIG5vd2xlZnRUb3BQb3NpdGlvblsxXV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50c1sxXSA9IFtub2RlUmVjdC5wb2ludHNbMV1bMF0sIG5vd2xlZnRUb3BQb3NpdGlvblsxXV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50c1syXSA9IG5vZGVSZWN0LnBvaW50c1syXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzWzNdID0gW25vd2xlZnRUb3BQb3NpdGlvblswXSwgbm9kZVJlY3QucG9pbnRzWzNdWzFdIF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50c1s0XSA9IFtub3dsZWZ0VG9wUG9zaXRpb25bMF0sIG5vd2xlZnRUb3BQb3NpdGlvblsxXV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXJhbXMgPSB7fTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zLnR5cGUgPSBcIk9wZXJhdGlvbk5vZGU6c2NhbGVEcmFnTGVmdFwiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMucG9pbnRzID0gcG9pbnRzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGF0LnRyaWdnZXIocGFyYW1zLnR5cGUsIHBhcmFtcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhhdC56ci5vbignbW91c2Vtb3ZlJywgbGVmdEFycm93KTtcclxuICAgICAgICAgICAgICAgIHZhciBsZWZ0RW5kID0gZnVuY3Rpb24oZSkgeyBsZWZ0RHJhZ0VuZChlKSB9O1xyXG5cclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGxlZnREcmFnRW5kKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGF0LnpyLm9mZignbW91c2Vtb3ZlJywgbGVmdEFycm93KTtcclxuICAgICAgICAgICAgICAgICAgICB0aGF0LnpyLm9mZihcIm1vdXNldXBcIiwgbGVmdEVuZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhcmFtcyA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtcy5ldmVudCA9IGU7XHJcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zLmFycm93TmFtZSA9IFwibGVmdFwiO1xyXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtcy50eXBlID0gXCJPcGVyYXRpb25Ob2RlOnNjYWxlRHJhZ0VuZFwiO1xyXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtcy5zdGFydFNsb3RQb2ludHMgPSBzdGFydFNsb3RQb2ludHM7XHJcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zLnN0YXJ0UG9zaXRpb24gPSBzdGFydFBvc2l0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoYXQudHJpZ2dlcihwYXJhbXMudHlwZSwgcGFyYW1zKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoYXQuenIub24oXCJtb3VzZXVwXCIsIGxlZnRFbmQpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgcmlnaHRCb3R0b21Qb3NpdGlvbiwgbm93cmlnaHRCb3R0b21Qb3NpdGlvbiA9IFtdO1xyXG4gICAgICAgICAgICB0aGlzLnJpZ2h0Qm90dG9tLm9uKCdtb3VzZWRvd24nLCBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICAgICAgICBzdGFydFNsb3RQb2ludHMgPSB1dGlsLmdldFNvbHRQb2ludHMobm9kZSk7XHJcbiAgICAgICAgICAgICAgICBzdGFydFBvc2l0aW9uID0genJVdGlsLmNsb25lKG5vZGUucG9zaXRpb24pO1xyXG4gICAgICAgICAgICAgICAgcmlnaHRCb3R0b21Qb3NpdGlvbiA9IG5vZGVSZWN0LnBvaW50c1syXTtcclxuICAgICAgICAgICAgICAgIHN0YXJ0WCA9IGUuZXZlbnQuY2xpZW50WDtcclxuICAgICAgICAgICAgICAgIHN0YXJ0WSA9IGUuZXZlbnQuY2xpZW50WTtcclxuICAgICAgICAgICAgICAgIHJpZ2h0U2NhbGVEcmFnKGUpO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIHJpZ2h0U2NhbGVEcmFnKGUpIHtcclxuICAgICAgICAgICAgICAgIHZhciByaWdodEFycm93ID0gZnVuY3Rpb24oZSkgeyByaWdodEFycm93RHJhZyhlKTsgfTtcclxuXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiByaWdodEFycm93RHJhZyhlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8y5Liq5ZyG6Ze06Led5aSq5bCP5pe2LOS4jeWcqOaLluWKqFxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGF0LnJpZ2h0Qm90dG9tLnBvc2l0aW9uWzBdIC0gdGhhdC5sZWZ0VG9wLnBvc2l0aW9uWzBdIDwgKHdpZHRoTWluICsgMTApKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGF0LnJpZ2h0Qm90dG9tLnBvc2l0aW9uWzFdIC0gdGhhdC5sZWZ0VG9wLnBvc2l0aW9uWzFdIDwgKGhlaWdodE1pbiArIDEwKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5yaWdodEJvdHRvbS5wb3NpdGlvblswXSA9IHRoYXQubGVmdFRvcC5wb3NpdGlvblswXSArICh3aWR0aE1pbiArIDEwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQucmlnaHRCb3R0b20ucG9zaXRpb25bMV0gPSB0aGF0LmxlZnRUb3AucG9zaXRpb25bMV0gKyAoaGVpZ2h0TWluICsgMTApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5yaWdodEJvdHRvbS5wb3NpdGlvblswXSA9IHRoYXQubGVmdFRvcC5wb3NpdGlvblswXSArIHdpZHRoTWluO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NhbGVSZWN0KHRoYXQucmlnaHRCb3R0b20sIGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoYXQucmlnaHRCb3R0b20ucG9zaXRpb25bMV0gLSB0aGF0LmxlZnRUb3AucG9zaXRpb25bMV0gPCAoaGVpZ2h0TWluKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5yaWdodEJvdHRvbS5wb3NpdGlvblsxXSA9IHRoYXQubGVmdFRvcC5wb3NpdGlvblsxXSArIGhlaWdodE1pbjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjYWxlUmVjdCh0aGF0LnJpZ2h0Qm90dG9tLCBlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjYWxlUmVjdCh0aGF0LnJpZ2h0Qm90dG9tLCBlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gc2NhbGVSZWN0KGRvbSwgZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZG9tUG9zaXRpb24gPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgbiA9IDA7IG4gPD0gTWF0aC5hYnMocGFyc2VJbnQoKGUuZXZlbnQuY2xpZW50WCAtIHN0YXJ0WCkgLyBwaXhlbCkpOyBuKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlLmV2ZW50LmNsaWVudFggLSBzdGFydFggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm93cmlnaHRCb3R0b21Qb3NpdGlvblswXSA9IHJpZ2h0Qm90dG9tUG9zaXRpb25bMF0gKyBwaXhlbCAqIChuKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb21Qb3NpdGlvblswXSA9IG5vd3JpZ2h0Qm90dG9tUG9zaXRpb25bMF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbm93cmlnaHRCb3R0b21Qb3NpdGlvblswXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3dyaWdodEJvdHRvbVBvc2l0aW9uWzBdID0gcmlnaHRCb3R0b21Qb3NpdGlvblswXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vd3JpZ2h0Qm90dG9tUG9zaXRpb25bMF0gLSBub2RlUmVjdC5wb2ludHNbMF1bMF0gPiB3aWR0aE1pbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3dyaWdodEJvdHRvbVBvc2l0aW9uWzBdID0gcmlnaHRCb3R0b21Qb3NpdGlvblswXSAtIHBpeGVsICogKG4pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb21Qb3NpdGlvblswXSA9IG5vd3JpZ2h0Qm90dG9tUG9zaXRpb25bMF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9tUG9zaXRpb25bMF0gPSB0aGF0LmxlZnRUb3AucG9zaXRpb25bMF0gKyB3aWR0aE1pbjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgbSA9IDA7IG0gPD0gTWF0aC5hYnMocGFyc2VJbnQoKGUuZXZlbnQuY2xpZW50WSAtIHN0YXJ0WSkgLyBwaXhlbCkpOyBtKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlLmV2ZW50LmNsaWVudFkgLSBzdGFydFkgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm93cmlnaHRCb3R0b21Qb3NpdGlvblsxXSA9IHJpZ2h0Qm90dG9tUG9zaXRpb25bMV0gKyBwaXhlbCAqIChtKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb21Qb3NpdGlvblsxXSA9IG5vd3JpZ2h0Qm90dG9tUG9zaXRpb25bMV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbm93cmlnaHRCb3R0b21Qb3NpdGlvblsxXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3dyaWdodEJvdHRvbVBvc2l0aW9uWzFdID0gcmlnaHRCb3R0b21Qb3NpdGlvblsxXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vd3JpZ2h0Qm90dG9tUG9zaXRpb25bMV0gLSBub2RlUmVjdC5wb2ludHNbMF1bMV0gPiBoZWlnaHRNaW4pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm93cmlnaHRCb3R0b21Qb3NpdGlvblsxXSA9IHJpZ2h0Qm90dG9tUG9zaXRpb25bMV0gLSBwaXhlbCAqIChtKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9tUG9zaXRpb25bMV0gPSBub3dyaWdodEJvdHRvbVBvc2l0aW9uWzFdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb21Qb3NpdGlvblsxXSA9IHRoYXQubGVmdFRvcC5wb3NpdGlvblsxXSArIGhlaWdodE1pbjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZG9tLmF0dHIoXCJwb3NpdGlvblwiLCBkb21Qb3NpdGlvbik7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcG9pbnRzID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50c1swXSA9IG5vZGVSZWN0LnBvaW50c1swXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzWzFdID0gW25vd3JpZ2h0Qm90dG9tUG9zaXRpb25bMF0sIG5vZGVSZWN0LnBvaW50c1sxXVsxXV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50c1syXSA9IFtub3dyaWdodEJvdHRvbVBvc2l0aW9uWzBdLCBub3dyaWdodEJvdHRvbVBvc2l0aW9uWzFdXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzWzNdID0gW25vZGVSZWN0LnBvaW50c1szXVswXSwgbm93cmlnaHRCb3R0b21Qb3NpdGlvblsxXV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50c1s0XSA9IG5vZGVSZWN0LnBvaW50c1swXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhcmFtcyA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMudHlwZSA9IFwiT3BlcmF0aW9uTm9kZTpzY2FsZURyYWdSaWdodFwiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMucG9pbnRzID0gcG9pbnRzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGF0LnRyaWdnZXIocGFyYW1zLnR5cGUsIHBhcmFtcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhhdC56ci5vbignbW91c2Vtb3ZlJywgcmlnaHRBcnJvdyk7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmlnaHRFbmQgPSBmdW5jdGlvbihlKSB7IHJpZ2h0RHJhZ0VuZChlKSB9O1xyXG5cclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHJpZ2h0RHJhZ0VuZChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhhdC56ci5vZmYoJ21vdXNlbW92ZScsIHJpZ2h0QXJyb3cpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoYXQuenIub2ZmKFwibW91c2V1cFwiLCByaWdodEVuZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhcmFtcyA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtcy5ldmVudCA9IGU7XHJcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zLmFycm93TmFtZSA9IFwicmlnaHRcIjtcclxuICAgICAgICAgICAgICAgICAgICBwYXJhbXMudHlwZSA9IFwiT3BlcmF0aW9uTm9kZTpzY2FsZURyYWdFbmRcIjtcclxuICAgICAgICAgICAgICAgICAgICBwYXJhbXMuc3RhcnRTbG90UG9pbnRzID0gc3RhcnRTbG90UG9pbnRzO1xyXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtcy5zdGFydFBvc2l0aW9uID0gc3RhcnRQb3NpdGlvbjtcclxuICAgICAgICAgICAgICAgICAgICB0aGF0LnRyaWdnZXIocGFyYW1zLnR5cGUsIHBhcmFtcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGF0LnpyLm9uKFwibW91c2V1cFwiLCByaWdodEVuZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5sZWZ0VG9wLmF0dHIoXCJwb3NpdGlvblwiLCBbbm9kZVJlY3QucG9pbnRzWzBdWzBdIC0gMTAsIG5vZGVSZWN0LnBvaW50c1swXVsxXSAtIDEwXSk7XHJcbiAgICAgICAgICAgIHRoaXMucmlnaHRCb3R0b20uYXR0cihcInBvc2l0aW9uXCIsIFtub2RlUmVjdC5wb2ludHNbMl1bMF0sIG5vZGVSZWN0LnBvaW50c1syXVsxXV0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8g6K6h566X5pW05Liq55qE5L2N572uXHJcbiAgICAgICAgaWYgKG5vZGUucGFyZW50KSB7XHJcbiAgICAgICAgICAgIGlmIChCcG1uLmlzU3ViUHJvY2Vzcyhub2RlLnBhcmVudCkpIHsgLy9pZihub2RlLnBhcmVudC5tb2RlbC5nZXQoXCJzdGVuY2lsLnR5cGVcIikgPT0gXCJTdWJQcm9jZXNzXCIpe1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hdHRyKFwicG9zaXRpb25cIiwgW25vZGVSZWN0LnggKyBub2RlLnBhcmVudC5wb3NpdGlvblswXSwgbm9kZVJlY3QueSArIG5vZGUucGFyZW50LnBvc2l0aW9uWzFdXSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuYXR0cihcInBvc2l0aW9uXCIsIFtub2RlUmVjdC54LCBub2RlUmVjdC55XSlcclxuICAgICAgICB9XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICBCcG1uT3BlcmF0aW9uTm9kZS5BUlJPV19EUkFHRU5EID0gXCJPcGVyYXRpb25Ob2RlOmRyYWdlbmRBcnJvd1wiO1xyXG4gICAgQnBtbk9wZXJhdGlvbk5vZGUuQVJST1dfRFJBRyA9IFwiT3BlcmF0aW9uTm9kZTpkcmFnQXJyb3dcIjtcclxuICAgIEJwbW5PcGVyYXRpb25Ob2RlLkFSUk9XX0RSQUdTVEFSVCA9IFwiT3BlcmF0aW9uTm9kZTpkcmFnc3RhcnRBcnJvd1wiO1xyXG4gICAgQnBtbk9wZXJhdGlvbk5vZGUuREVMRVRFX0NMSUNLID0gXCJPcGVyYXRpb25Ob2RlOmRlbGV0ZUNsaWNrXCI7XHJcblxyXG4gICAgenJVdGlsLmluaGVyaXRzKEJwbW5PcGVyYXRpb25Ob2RlLCBPcGVyYXRpb25Ob2RlKTtcclxuXHJcblxyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBCcG1uT3BlcmF0aW9uTm9kZTtcclxuXHJcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9saWIvZmlzaC10b3BvLWJwbW4vbGliL25vZGUvQnBtbk9wZXJhdGlvbk5vZGUuanNcbiAqKiBtb2R1bGUgaWQgPSAxMDJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxyXG4gKiDpgInkuK3oioLngrnlkI7vvIzlh7rnjrDnmoTmk43kvZzmoYblj4rmjInpkq5cclxuICogQGF1dGhvciB3YW5nLnhpYW9odVxyXG4gKi9cclxuXHJcbiAgICB2YXIgTm9kZSA9IHJlcXVpcmUoXCIuLi9Ob2RlXCIpO1xyXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xyXG4gICAgdmFyIGdyYXBoaWMgPSByZXF1aXJlKFwiLi4vZ3JhcGhpYy5qc1wiKTtcclxuICAgIHZhciBDb25uZWN0b3IgPSByZXF1aXJlKFwiLi4vc2hhcGVzL0Nvbm5lY3Rvci5qc1wiKTtcclxuICAgIHZhciBlbnYgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL2VudicpO1xyXG5cclxuICAgIGZ1bmN0aW9uIE9wZXJhdGlvbk5vZGUobm9kZSwgenIsIGZvcmJpZEVkaXQpIHtcclxuICAgICAgICBOb2RlLmNhbGwodGhpcyk7XHJcbiAgICAgICAgdGhpcy5ub2RlID0gbm9kZTtcclxuICAgICAgICB0aGlzLnpyID0genI7XHJcbiAgICAgICAgdGhpcy5mb3JiaWRFZGl0ID0gZm9yYmlkRWRpdDsgLy9cclxuICAgICAgICB0aGlzLnJlbmRlcigpO1xyXG4gICAgfVxyXG5cclxuICAgIC8v5LqL5Lu2XHJcbiAgICBPcGVyYXRpb25Ob2RlLkFSUk9XX0RSQUdFTkQgPSBcIk9wZXJhdGlvbk5vZGU6ZHJhZ2VuZEFycm93XCI7XHJcbiAgICBPcGVyYXRpb25Ob2RlLkFSUk9XX0RSQUcgPSBcIk9wZXJhdGlvbk5vZGU6ZHJhZ0Fycm93XCI7XHJcbiAgICBPcGVyYXRpb25Ob2RlLkFSUk9XX0RSQUdTVEFSVCA9IFwiT3BlcmF0aW9uTm9kZTpkcmFnc3RhcnRBcnJvd1wiO1xyXG4gICAgT3BlcmF0aW9uTm9kZS5ERUxFVEVfQ0xJQ0sgPSBcIk9wZXJhdGlvbk5vZGU6ZGVsZXRlQ2xpY2tcIjtcclxuXHJcbiAgICBpZighZW52LmNhbnZhc1N1cHBvcnRlZCkge1xyXG4gICAgICAgIC8v5YaF572u5pON5L2c5Zu+5qCH55qE5Zu+5YOPXHJcbiAgICAgICAgT3BlcmF0aW9uTm9kZS5vcGljb25zID0ge1xyXG4gICAgICAgICAgICBTVFJBSUdIVDogJ00xMy45NjEsMi4zMDljLTAuMDUxLTAuMTIyLTAuMTQ4LTAuMjItMC4yNy0wLjI3TDEzLjUsMmgtNUM4LjIyNCwyLDgsMi4yMjQsOCwyLjVTOC4yMjQsMyw4LjUsM2gzLjc5M0wyLjE0NiwxMy4xNDZjLTAuMTk1LDAuMTk1LTAuMTk1LDAuNTEyLDAsMC43MDdzMC41MTIsMC4xOTUsMC43MDcsMEwxMywzLjcwN1Y3LjVDMTMsNy43NzYsMTMuMjI1LDgsMTMuNSw4UzE0LDcuNzc2LDE0LDcuNXYtNUwxMy45NjEsMi4zMDl6JyxcclxuICAgICAgICAgICAgSkFHR0VEOiAnTTk2LjA0NiwxMy42MDRIODQuMjEzYy0xLjEwNCwwLTIsMC44OTYtMiwydjQyLjE4OEgzOC4zMTR2LTEwLjc3YzAtMC43MTUtMC4zODEtMS4zNzUtMS0xLjczMmMtMC42MTktMC4zNTctMS4zODItMC4zNTUtMiwwTDIuOTU0LDYzLjk3N2MtMC42MTksMC4zNTctMSwxLjAxOC0xLDEuNzMyczAuMzgxLDEuMzc1LDEsMS43MzJsMzIuMzYsMTguNjg3YzAuMzA5LDAuMTc5LDAuNjU1LDAuMjY4LDEsMC4yNjhzMC42OS0wLjA4OSwxLTAuMjY4YzAuNjE5LTAuMzU3LDEtMS4wMTgsMS0xLjczMlY3My42MjVoNTcuNzMyYzEuMTA0LDAsMi0wLjg5NiwyLTJWMTUuNjA0Qzk4LjA0NiwxNC41LDk3LjE1MSwxMy42MDQsOTYuMDQ2LDEzLjYwNHonLFxyXG4gICAgICAgICAgICBDVVJWRTogJ001MTAuNTM2LDI2OC4wOThjMTMuNTQxLDAsMjcuMDc4LTUuMjA3LDM3LjM0Ny0xNS42YzIwLjM3OS0yMC42MjUsMjAuMTgtNTMuODY2LTAuNDQ1LTc0LjI0NUw0MTQuMTY3LDQ2LjU3Yy05LjkwNS05Ljc4Ni0yMy4zMjUtMTUuMjQ0LTM3LjIxNS0xNS4xNTRjLTEzLjkyMywwLjA4My0yNy4yNDQsNS42OTUtMzcuMDMsMTUuNTk5bC0xMjkuOTEyLDEzMS40OGMtMjAuMzc5LDIwLjYyNS0yMC4xOCw1My44NjYsMC40NDUsNzQuMjQ1YzIwLjYyNSwyMC4zNzksNTMuODY2LDIwLjE4LDc0LjI0NS0wLjQ0NWw0MC42MTgtNDEuMTA4YzAuMDIxLDAuNDY0LDAuMDI5LDAuOTI3LDAuMDYyLDEuMzk0YzQuMTc4LDU5LjAwOCw0LjY2OCwxMTkuODMyLDE2LjYzMywxNzcuOTMxYzIzLjkzNywxMTYuMjMyLDEwMy43MDUsMTkxLjk2MSwxOTEuNDg5LDI2NC4wMjRjNDcuMjkyLDM4LjgyMyw3OS42Niw5NC4xMjIsOTguNjAxLDE1MS42NzNjOS43NjUsMjkuNjY5LDE0LjcxNCw3Ny4xMTUsMTcuMjE1LDEwNy4xNTdjMi4yNjEsMjcuMTYxLDI1LjA4LDQ3Ljk3OCw1Mi4zMzMsNDcuNzA5bDEuMDYxLTAuMDFjMzAuMjI4LTAuMjk4LDUzLjgxLTI2LjIxMSw1MS4zMDYtNTYuMzM2Yy0yLjkyMS0zNS4xNS04Ljg1OC04OS44MjgtMjAuOTI1LTEyNy40OWMtMTYuMjgzLTUwLjgyMS00MC4wMTYtOTkuNDYzLTc0Ljc2Ni0xNDAuMjQ1Yy0zMy45OTMtMzkuODkyLTc1LjQ1Ni03Mi40MDMtMTEzLjMzOC0xMDguMzczYy00Ny4wOTEtNDQuNzEzLTg0Ljk3Ny05NS4xNjEtOTguMDA2LTE1OS43MTljLTEwLjU0MS01Mi4yMzEtMTIuNzg5LTEwNS4yMTUtMTYuNDYxLTE1OC41NjJsNDMuMTE4LDQyLjYwNEM0ODMuODcsMjYzLjA1Myw0OTcuMjA1LDI2OC4wOTgsNTEwLjUzNiwyNjguMDk4eicsXHJcbiAgICAgICAgICAgIERFTDogJ003My42NDEsNDUuOTU3bC0wLjAyMSwwLjI1MmMwLDAuMDMyLDAuMDIxLDAuMDYsMC4wMjEsMC4wODhjMCwwLjA2NS0wLjAyMiwwLjEyNi0wLjAyNiwwLjE5MWwtMi42ODUsNTQuODc4SDcwLjkxYy0wLjIzMSw0LjMwNC01LjE2NiwxMC44MS0zMS43NDgsMTAuODFjLTI2LjU4LDAtMzEuNTA5LTYuNTA2LTMxLjc0Ni0xMC44MUg3LjQxTDQuNzMxLDQ2LjQ4OGMtMC4wMDktMC4wNi0wLjAyOC0wLjEyNi0wLjAyOC0wLjE5MWMwLTAuMDMyLDAuMDEtMC4wNiwwLjAxLTAuMDg4bC0wLjAxLTAuMjUyaDAuMDI4YzAuMDk5LTAuNDY2LDAuMzY0LTAuOTE5LDAuNzg0LTEuMzUzYzMuNDM5LDMuNDc3LDE3LjE5MSw0LjA1MSwzMy42NDYsNC4wNTFzMzAuMjIxLTAuNTc0LDMzLjY0Mi00LjA1MWMwLjQyNiwwLjQzNCwwLjcxMSwwLjg4NywwLjc4NCwxLjM1M0g3My42NDF6IE03OC4zMzUsMjUuMTAydjYuNDA3YzAsMS4zMTYtMS4zNCwyLjU2Ny0zLjcxNSwzLjY5NmMtNi4yNjYsMi45MzYtMTkuNzc3LDQuOTc1LTM1LjQ1OSw0Ljk3NWMtMTUuNjY2LDAtMjkuMTg5LTIuMDM5LTM1LjQ0Mi00Ljk3NUMxLjMzLDM0LjA3NSwwLDMyLjgyNSwwLDMxLjUwOXYtNi40MDdjMC0zLjM3NCw4LjY4MS02LjI4NiwyMS4zNTktNy43MjRWMy45MjljMC0yLjE2LDEuNzY4LTMuOTI5LDMuOTMtMy45MjloMjYuMzE0YzIuMTY0LDAsMy45MzgsMS43NzMsMy45MzgsMy45Mzh2MTMuMjk2QzY4Ljk4LDE4LjYwNiw3OC4zMzMsMjEuNjExLDc4LjMzNSwyNS4xMDJ6IE00OC40MTYsMTEuMzk1YzAtMi4zNDgtMC4zMjEtNC4yNy0wLjcxNS00LjI3Yy0wLjM5MywwLTIuNjQxLDAtNC45NzksMGgtOC41NDVjLTIuMzUyLDAtNC41OTIsMC00Ljk4OSwwYy0wLjM4OCwwLTAuNzE0LDEuOTIyLTAuNzE0LDQuMjd2NS4zNjdsMS4wODMtMC4wNjVjMy4wNjctMC4xNzMsNi4yODYtMC4yNyw5LjU5NS0wLjI3MWMzLjIwMiwwLDYuMjkyLDAuMDk4LDkuMjY0LDAuMjUyVjExLjM5NXonXHJcbiAgICAgICAgfTtcclxuICAgIH1lbHNle1xyXG4gICAgICAgIE9wZXJhdGlvbk5vZGUub3BpY29ucyA9IHtcclxuICAgICAgICAgICAgU1RSQUlHSFQ6ICdkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUF3QUFBQU1DQVlBQUFCV2RWem5BQUFBQ1hCSVdYTUFBQXNUQUFBTEV3RUFtcHdZQUFBS1RXbERRMUJRYUc5MGIzTm9iM0FnU1VORElIQnliMlpwYkdVQUFIamFuVk4zV0pQM0ZqN2Y5MlVQVmtMWThMR1hiSUVBSWlPc0NNZ1FXYUlRa2dCaGhCQVNRTVdGaUFwV0ZCVVJuRWhWeElMVkNraWRpT0tnS0xoblFZcUlXb3RWWERqdUg5eW50WDE2NyszdCs5Zjd2T2VjNS96T2VjOFBnQkVTSnBIbW9tb0FPVktGUERyWUg0OVBTTVRKdllBQ0ZVamdCQ0FRNXN2Q1p3WEZBQUR3QTNsNGZuU3dQL3dCcjI4QUFnQncxUzRrRXNmaC80TzZVQ1pYQUNDUkFPQWlFdWNMQVpCU0FNZ3VWTWdVQU1nWUFMQlRzMlFLQUpRQUFHeDVmRUlpQUtvTkFPejBTVDRGQU5pcGs5d1hBTmlpSEtrSUFJMEJBSmtvUnlRQ1FMc0FZRldCVWl3Q3dNSUFvS3hBSWk0RXdLNEJnRm0yTWtjQ2dMMEZBSGFPV0pBUFFHQUFnSmxDTE13QUlEZ0NBRU1lRTgwRElFd0RvRERTditDcFgzQ0Z1RWdCQU1ETGxjMlhTOUl6RkxpVjBCcDM4dkRnNGlIaXdteXhRbUVYS1JCbUNlUWluSmViSXhOSTV3Tk16Z3dBQUJyNTBjSCtPRCtRNStiazRlWm01Mnp2OU1XaS9tdndieUkrSWZIZi9yeU1BZ1FBRUU3UDc5cGY1ZVhXQTNESEFiQjF2MnVwV3dEYVZnQm8zL2xkTTlzSm9Gb0swSHI1aTNrNC9FQWVucUZReUR3ZEhBb0xDKzBsWXFHOU1PT0xQdjh6NFcvZ2kzNzIvRUFlL3R0NjhBQnhta0NacmNDamcvMXhZVzUycmxLTzU4c0VRakZ1OStjai9zZUZmLzJPS2RIaU5MRmNMQldLOFZpSnVGQWlUY2Q1dVZLUlJDSEpsZUlTNlg4eThSK1cvUW1UZHcwQXJJWlB3RTYyQjdYTGJNQis3Z0VDaXc1WTBuWUFRSDd6TFl3YUM1RUFFR2MwTW5uM0FBQ1R2L21QUUNzQkFNMlhwT01BQUx6b0dGeW9sQmRNeGdnQUFFU2dnU3F3UVFjTXdSU3N3QTZjd1IyOHdCY0NZUVpFUUF3a3dEd1FRZ2JrZ0J3S29SaVdRUmxVd0RyWUJMV3dBeHFnRVpyaEVMVEJNVGdONStBU1hJSHJjQmNHWUJpZXdoaThoZ2tFUWNnSUUyRWhPb2dSWW83WUlzNElGNW1PQkNKaFNEU1NnS1FnNllnVVVTTEZ5SEtrQXFsQ2FwRmRTQ1B5TFhJVU9ZMWNRUHFRMjhnZ01vcjhpcnhITVpTQnNsRUQxQUoxUUxtb0h4cUt4cUJ6MFhRMEQxMkFscUpyMFJxMEhqMkF0cUtuMFV2b2RYUUFmWXFPWTREUk1RNW1qTmxoWEl5SFJXQ0pXQm9teHhaajVWZzFWbzgxWXgxWU4zWVZHOENlWWU4SUpBS0xnQlBzQ0Y2RUVNSnNncENRUjFoTVdFT29KZXdqdEJLNkNGY0pnNFF4d2ljaWs2aFB0Q1Y2RXZuRWVHSTZzWkJZUnF3bTdpRWVJWjRsWGljT0UxK1RTQ1FPeVpMa1Rnb2hKWkF5U1F0SmEwamJTQzJrVTZRKzBoQnBuRXdtNjVCdHlkN2tDTEtBckNDWGtiZVFENUJQa3Z2SncrUzNGRHJGaU9KTUNhSWtVcVNVRWtvMVpUL2xCS1dmTWtLWm9LcFJ6YW1lMUFpcWlEcWZXa2x0b0haUUwxT0hxUk0wZFpvbHpac1dROHVrTGFQVjBKcHBaMm4zYUMvcGRMb0ozWU1lUlpmUWw5SnI2QWZwNSttRDlIY01EWVlOZzhkSVlpZ1pheGw3R2FjWXR4a3ZtVXltQmRPWG1jaFVNTmN5RzVsbm1BK1liMVZZS3ZZcWZCV1J5aEtWT3BWV2xYNlY1NnBVVlhOVlA5VjVxZ3RVcTFVUHExNVdmYVpHVmJOUTQ2a0oxQmFyMWFrZFZidXBOcTdPVW5kU2oxRFBVVitqdmwvOWd2cGpEYktHaFVhZ2hraWpWR08zeGhtTklSYkdNbVh4V0VMV2NsWUQ2eXhybUUxaVc3TDU3RXgyQmZzYmRpOTdURk5EYzZwbXJHYVJacDNtY2MwQkRzYXg0UEE1Mlp4S3ppSE9EYzU3TFFNdFB5MngxbXF0WnExK3JUZmFldHErMm1MdGN1MFc3ZXZhNzNWd25VQ2RMSjMxT20wNjkzVUp1amE2VWJxRnV0dDF6K28rMDJQcmVla0o5Y3IxRHVuZDBVZjFiZlNqOVJmcTc5YnYwUjgzTURRSU5wQVpiREU0WS9ETWtHUG9hNWhwdU5Id2hPR29FY3RvdXBIRWFLUFJTYU1udUNidWgyZmpOWGdYUG1hc2J4eGlyRFRlWmR4clBHRmlhVExicE1Ta3hlUytLYzJVYTVwbXV0RzAwM1RNek1nczNLellyTW5zampuVm5HdWVZYjdadk52OGpZV2xSWnpGU29zMmk4ZVcycFo4eXdXV1RaYjNySmhXUGxaNVZ2VlcxNnhKMWx6ckxPdHQxbGRzVUJ0WG13eWJPcHZMdHFpdG02M0VkcHR0M3hUaUZJOHAwaW4xVTI3YU1lejg3QXJzbXV3RzdUbjJZZllsOW0zMnp4M01IQklkMWp0ME8zeHlkSFhNZG14d3ZPdWs0VFREcWNTcHcrbFhaeHRub1hPZDh6VVhwa3VReXhLWGRwY1hVMjJuaXFkdW4zckxsZVVhN3JyU3RkUDFvNXU3bTl5dDJXM1UzY3c5eFgyciswMHVteHZKWGNNOTcwSDA4UGRZNG5ITTQ1Mm5tNmZDODVEbkwxNTJYbGxlKzcwZVQ3T2NKcDdXTUczSTI4UmI0TDNMZTJBNlBqMWwrczdwQXo3R1BnS2ZlcCtIdnFhK0l0ODl2aU4rMW42WmZnZjhudnM3K3N2OWovaS80WG55RnZGT0JXQUJ3UUhsQWIyQkdvR3pBMnNESHdTWkJLVUhOUVdOQmJzR0x3dytGVUlNQ1ExWkgzS1RiOEFYOGh2NVl6UGNaeXlhMFJYS0NKMFZXaHY2TU13bVRCN1dFWTZHendqZkVINXZwdmxNNmN5MkNJamdSMnlJdUI5cEdaa1grWDBVS1NveXFpN3FVYlJUZEhGMDl5eldyT1JaKzJlOWp2R1BxWXk1Tzl0cXRuSjJaNnhxYkZKc1kreWJ1SUM0cXJpQmVJZjRSZkdYRW5RVEpBbnRpZVRFMk1ROWllTnpBdWRzbWpPYzVKcFVsblJqcnVYY29ya1g1dW5PeTU1M1BGazFXWkI4T0lXWUVwZXlQK1dESUVKUUx4aFA1YWR1VFIwVDhvU2JoVTlGdnFLTm9sR3h0N2hLUEpMbW5WYVY5ampkTzMxRCttaUdUMFoxeGpNSlQxSXJlWkVaa3JrajgwMVdSTmJlck0vWmNka3RPWlNjbEp5alVnMXBsclFyMXpDM0tMZFBaaXNya3cza2VlWnR5aHVUaDhyMzVDUDVjL1BiRld5RlROR2p0Rkt1VUE0V1RDK29LM2hiR0Z0NHVFaTlTRnJVTTk5bS91cjVJd3VDRm55OWtMQlF1TEN6MkxoNFdmSGdJcjlGdXhZamkxTVhkeTR4WFZLNlpIaHA4Tko5eTJqTHNwYjlVT0pZVWxYeWFubmM4bzVTZzlLbHBVTXJnbGMwbGFtVXljdHVydlJhdVdNVllaVmtWZTlxbDlWYlZuOHFGNVZmckhDc3FLNzRzRWE0NXVKWFRsL1ZmUFY1YmRyYTNrcTN5dTNyU091azYyNnM5MW0vcjBxOWFrSFYwSWJ3RGEwYjhZM2xHMTl0U3Q1MG9YcHE5WTdOdE0zS3pRTTFZVFh0Vzh5MnJOdnlvVGFqOW5xZGYxM0xWdjJ0cTdlKzJTYmExci9kZDN2ekRvTWRGVHZlNzVUc3ZMVXJlRmRydlVWOTlXN1M3b0xkanhwaUc3cS81bjdkdUVkM1Q4V2VqM3VsZXdmMlJlL3JhblJ2Yk55dnY3K3lDVzFTTm8wZVNEcHc1WnVBYjlxYjdacDN0WEJhS2c3Q1FlWEJKOSttZkh2alVPaWh6c1BjdzgzZm1YKzM5UWpyU0hrcjBqcS9kYXd0bzIyZ1BhRzk3K2lNbzUwZFhoMUh2cmYvZnU4eDQyTjF4eldQVjU2Z25TZzk4Zm5rZ3BQanAyU25ucDFPUHozVW1keDU5MHo4bVd0ZFVWMjlaMFBQbmo4WGRPNU10MS8zeWZQZTU0OWQ4THh3OUNMM1l0c2x0MHV0UGE0OVIzNXcvZUZJcjF0djYyWDN5KzFYUEs1MDlFM3JPOUh2MDMvNmFzRFZjOWY0MXk1ZG4zbTk3OGJzRzdkdUp0MGN1Q1c2OWZoMjl1MFhkd3J1VE54ZGVvOTRyL3krMnYzcUIvb1A2biswL3JGbHdHM2crR0RBWU0vRFdRL3ZEZ21IbnY2VS85T0g0ZEpIekVmVkkwWWpqWStkSHg4YkRScTk4bVRPaytHbnNxY1R6OHArVnY5NTYzT3I1OS85NHZ0THoxajgyUEFMK1l2UHY2NTVxZk55NzZ1cHJ6ckhJOGNmdk01NVBmR20vSzNPMjMzdnVPKzYzOGU5SDVrby9FRCtVUFBSK21QSHA5QlA5ejduZlA3OEwvZUU4L3NsMHA4ekFBQUFJR05JVWswQUFIb2xBQUNBZ3dBQStmOEFBSURwQUFCMU1BQUE2bUFBQURxWUFBQVhiNUpmeFVZQUFBQlFTVVJCVkhqYWxKRkJEb0F3Q01DcUg1ZWYxd3NoSWVxR1N6Z3N0RUFBbGE4QUFyREZTbmlUVHZiUC9sdFh2MUtJNmpTQjIzaFR1SEovNElld2c1c3dnVXVZd3NuT1laVWo5NHNhZ3lOeUR3RGExaG43WkNPS3d3QUFBQUJKUlU1RXJrSmdnZz09JyxcclxuICAgICAgICAgICAgSkFHR0VEOiAnZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFBd0FBQUFNQ0FZQUFBQldkVnpuQUFBQUNYQklXWE1BQUFzVEFBQUxFd0VBbXB3WUFBQUtUV2xEUTFCUWFHOTBiM05vYjNBZ1NVTkRJSEJ5YjJacGJHVUFBSGphblZOM1dKUDNGajdmOTJVUFZrTFk4TEdYYklFQUlpT3NDTWdRV2FJUWtnQmhoQkFTUU1XRmlBcFdGQlVSbkVoVnhJTFZDa2lkaU9LZ0tMaG5RWXFJV290VlhEanVIOXludFgxNjcrM3QrOWY3dk9lYzUvek9lYzhQZ0JFU0pwSG1vbW9BT1ZLRlBEcllINDlQU01USnZZQUNGVWpnQkNBUTVzdkNad1hGQUFEd0EzbDRmblN3UC93QnIyOEFBZ0J3MVM0a0VzZmgvNE82VUNaWEFDQ1JBT0FpRXVjTEFaQlNBTWd1Vk1nVUFNZ1lBTEJUczJRS0FKUUFBR3g1ZkVJaUFLb05BT3owU1Q0RkFOaXBrOXdYQU5paUhLa0lBSTBCQUprb1J5UUNRTHNBWUZXQlVpd0N3TUlBb0t4QUlpNEV3SzRCZ0ZtMk1rY0NnTDBGQUhhT1dKQVBRR0FBZ0psQ0xNd0FJRGdDQUVNZUU4MERJRXdEb0REU3YrQ3BYM0NGdUVnQkFNRExsYzJYUzlJekZMaVYwQnAzOHZEZzRpSGl3bXl4UW1FWEtSQm1DZVFpbkplYkl4Tkk1d05Nemd3QUFCcjUwY0grT0QrUTUrYms0ZVptNTJ6djlNV2kvbXZ3YnlJK0lmSGYvcnlNQWdRQUVFN1A3OXBmNWVYV0EzREhBYkIxdjJ1cFd3RGFWZ0JvMy9sZE05c0pvRm9LMEhyNWkzazQvRUFlbnFGUXlEd2RIQW9MQyswbFlxRzlNT09MUHY4ejRXL2dpMzcyL0VBZS90dDY4QUJ4bWtDWnJjQ2pnLzF4WVc1MnJsS081OHNFUWpGdTkrY2ovc2VGZi8yT0tkSGlOTEZjTEJXSzhWaUp1RkFpVGNkNXVWS1JSQ0hKbGVJUzZYOHk4UitXL1FtVGR3MEFySVpQd0U2MkI3WExiTUIrN2dFQ2l3NVkwbllBUUg3ekxZd2FDNUVBRUdjME1ubjNBQUNUdi9tUFFDc0JBTTJYcE9NQUFMem9HRnlvbEJkTXhnZ0FBRVNnZ1Nxd1FRY013UlNzd0E2Y3dSMjh3QmNDWVFaRVFBd2t3RHdRUWdia2dCd0tvUmlXUVJsVXdEcllCTFd3QXhxZ0VacmhFTFRCTVRnTjUrQVNYSUhyY0JjR1lCaWV3aGk4aGdrRVFjZ0lFMkVoT29nUllvN1lJczRJRjVtT0JDSmhTRFNTZ0tRZzZZZ1VVU0xGeUhLa0FxbENhcEZkU0NQeUxYSVVPWTFjUVBxUTI4Z2dNb3I4aXJ4SE1aU0JzbEVEMUFKMVFMbW9IeHFLeHFCejBYUTBEMTJBbHFKcjBScTBIajJBdHFLbjBVdm9kWFFBZllxT1k0RFJNUTVtak5saFhJeUhSV0NKV0JvbXh4Wmo1VmcxVm84MVl4MVlOM1lWRzhDZVllOElKQUtMZ0JQc0NGNkVFTUpzZ3BDUVIxaE1XRU9vSmV3anRCSzZDRmNKZzRReHdpY2lrNmhQdENWNkV2bkVlR0k2c1pCWVJxd203aUVlSVo0bFhpY09FMStUU0NRT3laTGtUZ29oSlpBeVNRdEphMGpiU0Mya1U2USswaEJwbkV3bTY1QnR5ZDdrQ0xLQXJDQ1hrYmVRRDVCUGt2dkp3K1MzRkRyRmlPSk1DYUlrVXFTVUVrbzFaVC9sQktXZk1rS1pvS3BSemFtZTFBaXFpRHFmV2tsdG9IWlFMMU9IcVJNMGRab2x6WnNXUTh1a0xhUFYwSnBwWjJuM2FDL3BkTG9KM1lNZVJaZlFsOUpyNkFmcDUrbUQ5SGNNRFlZTmc4ZElZaWdaYXhsN0dhY1l0eGt2bVV5bUJkT1htY2hVTU5jeUc1bG5tQStZYjFWWUt2WXFmQldSeWhLVk9wVldsWDZWNTZwVVZYTlZQOVY1cWd0VXExVVBxMTVXZmFaR1ZiTlE0NmtKMUJhcjFha2RWYnVwTnE3T1VuZFNqMURQVVYranZsLzlndnBqRGJLR2hVYWdoa2lqVkdPM3hobU5JUmJHTW1YeFdFTFdjbFlENnl4cm1FMWlXN0w1N0V4MkJmc2JkaTk3VEZORGM2cG1yR2FSWnAzbWNjMEJEc2F4NFBBNTJaeEt6aUhPRGM1N0xRTXRQeTJ4MW1xdFpxMStyVGZhZXRxKzJtTHRjdTBXN2V2YTczVnduVUNkTEozMU9tMDY5M1VKdWphNlVicUZ1dHQxeitvKzAyUHJlZWtKOWNyMUR1bmQwVWYxYmZTajlSZnE3OWJ2MFI4M01EUUlOcEFaYkRFNFkvRE1rR1BvYTVocHVOSHdoT0dvRWN0b3VwSEVhS1BSU2FNbnVDYnVoMmZqTlhnWFBtYXNieHhpckRUZVpkeHJQR0ZpYVRMYnBNU2t4ZVMrS2MyVWE1cG11dEcwMDNUTXpNZ3MzS3pZck1uc2pqblZuR3VlWWI3WnZOdjhqWVdsUlp6RlNvczJpOGVXMnBaOHl3V1dUWmIzckpoV1BsWjVWdlZXMTZ4SjFsenJMT3R0MWxkc1VCdFhtd3liT3B2THRxaXRtNjNFZHB0dDN4VGlGSThwMGluMVUyN2FNZXo4N0Fyc211d0c3VG4yWWZZbDltMzJ6eDNNSEJJZDFqdDBPM3h5ZEhYTWRteHd2T3VrNFRURHFjU3B3K2xYWnh0bm9YT2Q4elVYcGt1UXl4S1hkcGNYVTIybmlxZHVuM3JMbGVVYTdyclN0ZFAxbzV1N205eXQyVzNVM2N3OXhYMnIrMDB1bXh2SlhjTTk3MEgwOFBkWTRuSE00NTJubTZmQzg1RG5MMTUyWGxsZSs3MGVUN09jSnA3V01HM0kyOFJiNEwzTGUyQTZQajFsK3M3cEF6N0dQZ0tmZXArSHZxYStJdDg5dmlOKzFuNlpmZ2Y4bnZzNytzdjlqL2kvNFhueUZ2Rk9CV0FCd1FIbEFiMkJHb0d6QTJzREh3U1pCS1VITlFXTkJic0dMd3crRlVJTUNRMVpIM0tUYjhBWDhodjVZelBjWnl5YTBSWEtDSjBWV2h2Nk1Nd21UQjdXRVk2R3p3amZFSDV2cHZsTTZjeTJDSWpnUjJ5SXVCOXBHWmtYK1gwVUtTb3lxaTdxVWJSVGRIRjA5eXpXck9SWisyZTlqdkdQcVl5NU85dHF0bkoyWjZ4cWJGSnNZK3lidUlDNHFyaUJlSWY0UmZHWEVuUVRKQW50aWVURTJNUTlpZU56QXVkc21qT2M1SnBVbG5SanJ1WGNvcmtYNXVuT3k1NTNQRmsxV1pCOE9JV1lFcGV5UCtXRElFSlFMeGhQNWFkdVRSMFQ4b1NiaFU5RnZxS05vbEd4dDdoS1BKTG1uVmFWOWpqZE8zMUQrbWlHVDBaMXhqTUpUMUlyZVpFWmtya2o4MDFXUk5iZXJNL1pjZGt0T1pTY2xKeWpVZzFwbHJRcjF6QzNLTGRQWmlzcmt3M2tlZVp0eWh1VGg4cjM1Q1A1Yy9QYkZXeUZUTkdqdEZLdVVBNFdUQytvSzNoYkdGdDR1RWk5U0ZyVU05OW0vdXI1SXd1Q0ZueTlrTEJRdUxDejJMaDRXZkhnSXI5RnV4WWppMU1YZHk0eFhWSzZaSGhwOE5KOXkyakxzcGI5VU9KWVVsWHlhbm5jOG81U2c5S2xwVU1yZ2xjMGxhbVV5Y3R1cnZSYXVXTVZZWlZrVmU5cWw5VmJWbjhxRjVWZnJIQ3NxSzc0c0VhNDV1SlhUbC9WZlBWNWJkcmEza3EzeXUzclNPdWs2MjZzOTFtL3IwcTlha0hWMElid0RhMGI4WTNsRzE5dFN0NTBvWHBxOVk3TnRNM0t6UU0xWVRYdFc4eTJyTnZ5b1RhajlucWRmMTNMVnYydHE3ZSsyU2JhMXIvZGQzdnpEb01kRlR2ZTc1VHN2TFVyZUZkcnZVVjk5VzdTN29MZGp4cGlHN3EvNW43ZHVFZDNUOFdlajN1bGV3ZjJSZS9yYW5SdmJOeXZ2Nyt5Q1cxU05vMGVTRHB3NVp1QWI5cWI3WnAzdFhCYUtnN0NRZVhCSjkrbWZIdmpVT2loenNQY3c4M2ZtWCszOVFqclNIa3IwanEvZGF3dG8yMmdQYUc5NytpTW81MGRYaDFIdnJmL2Z1OHg0Mk4xeHpXUFY1NmduU2c5OGZua2dwUGpwMlNubnAxT1B6M1VtZHg1OTB6OG1XdGRVVjI5WjBQUG5qOFhkTzVNdDEvM3lmUGU1NDlkOEx4dzlDTDNZdHNsdDB1dFBhNDlSMzV3L2VGSXIxdHY2MlgzeSsxWFBLNTA5RTNyTzlIdjAzLzZhc0RWYzlmNDF5NWRuM205Nzhic0c3ZHVKdDBjdUNXNjlmaDI5dTBYZHdydVROeGRlbzk0ci95KzJ2M3FCL29QNm4rMC9yRmx3RzNnK0dEQVlNL0RXUS92RGdtSG52NlUvOU9INGRKSHpFZlZJMFlqalkrZEh4OGJEUnE5OG1UT2srR25zcWNUejhwK1Z2OTU2M09yNTkvOTR2dEx6MWo4MlBBTCtZdlB2NjU1cWZOeTc2dXByenJISThjZnZNNTVQZkdtL0szTzIzM3Z1Tys2MzhlOUg1a28vRUQrVVBQUittUEhwOUJQOXo3bmZQNzhML2VFOC9zbDBwOHpBQUFBSUdOSVVrMEFBSG9sQUFDQWd3QUErZjhBQUlEcEFBQjFNQUFBNm1BQUFEcVlBQUFYYjVKZnhVWUFBQUNnU1VSQlZIamFoTkd4RGNKQURJWGhMNkdLUkVkRmlWZ2tJNUE5YUJFRkRRVkRNQVVMVUxBQkV5RFJJN29JMnFPeGtBaVg1Q1EzSjcvbjM4OVNTdm9LZTZTZkdoTGtSS1dCVnhURkJBKzh2NThEempXdTRYekJNWXVFQlU3UmVFZnpnOWRwWHNmNEZqdFVmNFlkd1NxY3Q3Mm9HYVF6bnBqbEJHVW5sVGxlbUdHVGpTNWNxMkJ1WTRjRHBqM3BhWEFMOWhPV0k0ZVVJdTk2N09vcEpaOEJBUGRXL3VET3V3cnpBQUFBQUVsRlRrU3VRbUNDJyxcclxuICAgICAgICAgICAgQ1VSVkU6ICdkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUF3QUFBQU1DQVlBQUFCV2RWem5BQUFBQ1hCSVdYTUFBQXNUQUFBTEV3RUFtcHdZQUFBS1RXbERRMUJRYUc5MGIzTm9iM0FnU1VORElIQnliMlpwYkdVQUFIamFuVk4zV0pQM0ZqN2Y5MlVQVmtMWThMR1hiSUVBSWlPc0NNZ1FXYUlRa2dCaGhCQVNRTVdGaUFwV0ZCVVJuRWhWeElMVkNraWRpT0tnS0xoblFZcUlXb3RWWERqdUg5eW50WDE2NyszdCs5Zjd2T2VjNS96T2VjOFBnQkVTSnBIbW9tb0FPVktGUERyWUg0OVBTTVRKdllBQ0ZVamdCQ0FRNXN2Q1p3WEZBQUR3QTNsNGZuU3dQL3dCcjI4QUFnQncxUzRrRXNmaC80TzZVQ1pYQUNDUkFPQWlFdWNMQVpCU0FNZ3VWTWdVQU1nWUFMQlRzMlFLQUpRQUFHeDVmRUlpQUtvTkFPejBTVDRGQU5pcGs5d1hBTmlpSEtrSUFJMEJBSmtvUnlRQ1FMc0FZRldCVWl3Q3dNSUFvS3hBSWk0RXdLNEJnRm0yTWtjQ2dMMEZBSGFPV0pBUFFHQUFnSmxDTE13QUlEZ0NBRU1lRTgwRElFd0RvRERTditDcFgzQ0Z1RWdCQU1ETGxjMlhTOUl6RkxpVjBCcDM4dkRnNGlIaXdteXhRbUVYS1JCbUNlUWluSmViSXhOSTV3Tk16Z3dBQUJyNTBjSCtPRCtRNStiazRlWm01Mnp2OU1XaS9tdndieUkrSWZIZi9yeU1BZ1FBRUU3UDc5cGY1ZVhXQTNESEFiQjF2MnVwV3dEYVZnQm8zL2xkTTlzSm9Gb0swSHI1aTNrNC9FQWVucUZReUR3ZEhBb0xDKzBsWXFHOU1PT0xQdjh6NFcvZ2kzNzIvRUFlL3R0NjhBQnhta0NacmNDamcvMXhZVzUycmxLTzU4c0VRakZ1OStjai9zZUZmLzJPS2RIaU5MRmNMQldLOFZpSnVGQWlUY2Q1dVZLUlJDSEpsZUlTNlg4eThSK1cvUW1UZHcwQXJJWlB3RTYyQjdYTGJNQis3Z0VDaXc1WTBuWUFRSDd6TFl3YUM1RUFFR2MwTW5uM0FBQ1R2L21QUUNzQkFNMlhwT01BQUx6b0dGeW9sQmRNeGdnQUFFU2dnU3F3UVFjTXdSU3N3QTZjd1IyOHdCY0NZUVpFUUF3a3dEd1FRZ2JrZ0J3S29SaVdRUmxVd0RyWUJMV3dBeHFnRVpyaEVMVEJNVGdONStBU1hJSHJjQmNHWUJpZXdoaThoZ2tFUWNnSUUyRWhPb2dSWW83WUlzNElGNW1PQkNKaFNEU1NnS1FnNllnVVVTTEZ5SEtrQXFsQ2FwRmRTQ1B5TFhJVU9ZMWNRUHFRMjhnZ01vcjhpcnhITVpTQnNsRUQxQUoxUUxtb0h4cUt4cUJ6MFhRMEQxMkFscUpyMFJxMEhqMkF0cUtuMFV2b2RYUUFmWXFPWTREUk1RNW1qTmxoWEl5SFJXQ0pXQm9teHhaajVWZzFWbzgxWXgxWU4zWVZHOENlWWU4SUpBS0xnQlBzQ0Y2RUVNSnNncENRUjFoTVdFT29KZXdqdEJLNkNGY0pnNFF4d2ljaWs2aFB0Q1Y2RXZuRWVHSTZzWkJZUnF3bTdpRWVJWjRsWGljT0UxK1RTQ1FPeVpMa1Rnb2hKWkF5U1F0SmEwamJTQzJrVTZRKzBoQnBuRXdtNjVCdHlkN2tDTEtBckNDWGtiZVFENUJQa3Z2SncrUzNGRHJGaU9KTUNhSWtVcVNVRWtvMVpUL2xCS1dmTWtLWm9LcFJ6YW1lMUFpcWlEcWZXa2x0b0haUUwxT0hxUk0wZFpvbHpac1dROHVrTGFQVjBKcHBaMm4zYUMvcGRMb0ozWU1lUlpmUWw5SnI2QWZwNSttRDlIY01EWVlOZzhkSVlpZ1pheGw3R2FjWXR4a3ZtVXltQmRPWG1jaFVNTmN5RzVsbm1BK1liMVZZS3ZZcWZCV1J5aEtWT3BWV2xYNlY1NnBVVlhOVlA5VjVxZ3RVcTFVUHExNVdmYVpHVmJOUTQ2a0oxQmFyMWFrZFZidXBOcTdPVW5kU2oxRFBVVitqdmwvOWd2cGpEYktHaFVhZ2hraWpWR08zeGhtTklSYkdNbVh4V0VMV2NsWUQ2eXhybUUxaVc3TDU3RXgyQmZzYmRpOTdURk5EYzZwbXJHYVJacDNtY2MwQkRzYXg0UEE1Mlp4S3ppSE9EYzU3TFFNdFB5MngxbXF0WnExK3JUZmFldHErMm1MdGN1MFc3ZXZhNzNWd25VQ2RMSjMxT20wNjkzVUp1amE2VWJxRnV0dDF6K28rMDJQcmVla0o5Y3IxRHVuZDBVZjFiZlNqOVJmcTc5YnYwUjgzTURRSU5wQVpiREU0WS9ETWtHUG9hNWhwdU5Id2hPR29FY3RvdXBIRWFLUFJTYU1udUNidWgyZmpOWGdYUG1hc2J4eGlyRFRlWmR4clBHRmlhVExicE1Ta3hlUytLYzJVYTVwbXV0RzAwM1RNek1nczNLellyTW5zampuVm5HdWVZYjdadk52OGpZV2xSWnpGU29zMmk4ZVcycFo4eXdXV1RaYjNySmhXUGxaNVZ2VlcxNnhKMWx6ckxPdHQxbGRzVUJ0WG13eWJPcHZMdHFpdG02M0VkcHR0M3hUaUZJOHAwaW4xVTI3YU1lejg3QXJzbXV3RzdUbjJZZllsOW0zMnp4M01IQklkMWp0ME8zeHlkSFhNZG14d3ZPdWs0VFREcWNTcHcrbFhaeHRub1hPZDh6VVhwa3VReXhLWGRwY1hVMjJuaXFkdW4zckxsZVVhN3JyU3RkUDFvNXU3bTl5dDJXM1UzY3c5eFgyciswMHVteHZKWGNNOTcwSDA4UGRZNG5ITTQ1Mm5tNmZDODVEbkwxNTJYbGxlKzcwZVQ3T2NKcDdXTUczSTI4UmI0TDNMZTJBNlBqMWwrczdwQXo3R1BnS2ZlcCtIdnFhK0l0ODl2aU4rMW42WmZnZjhudnM3K3N2OWovaS80WG55RnZGT0JXQUJ3UUhsQWIyQkdvR3pBMnNESHdTWkJLVUhOUVdOQmJzR0x3dytGVUlNQ1ExWkgzS1RiOEFYOGh2NVl6UGNaeXlhMFJYS0NKMFZXaHY2TU13bVRCN1dFWTZHendqZkVINXZwdmxNNmN5MkNJamdSMnlJdUI5cEdaa1grWDBVS1NveXFpN3FVYlJUZEhGMDl5eldyT1JaKzJlOWp2R1BxWXk1Tzl0cXRuSjJaNnhxYkZKc1kreWJ1SUM0cXJpQmVJZjRSZkdYRW5RVEpBbnRpZVRFMk1ROWllTnpBdWRzbWpPYzVKcFVsblJqcnVYY29ya1g1dW5PeTU1M1BGazFXWkI4T0lXWUVwZXlQK1dESUVKUUx4aFA1YWR1VFIwVDhvU2JoVTlGdnFLTm9sR3h0N2hLUEpMbW5WYVY5ampkTzMxRCttaUdUMFoxeGpNSlQxSXJlWkVaa3JrajgwMVdSTmJlck0vWmNka3RPWlNjbEp5alVnMXBsclFyMXpDM0tMZFBaaXNya3cza2VlWnR5aHVUaDhyMzVDUDVjL1BiRld5RlROR2p0Rkt1VUE0V1RDK29LM2hiR0Z0NHVFaTlTRnJVTTk5bS91cjVJd3VDRm55OWtMQlF1TEN6MkxoNFdmSGdJcjlGdXhZamkxTVhkeTR4WFZLNlpIaHA4Tko5eTJqTHNwYjlVT0pZVWxYeWFubmM4bzVTZzlLbHBVTXJnbGMwbGFtVXljdHVydlJhdVdNVllaVmtWZTlxbDlWYlZuOHFGNVZmckhDc3FLNzRzRWE0NXVKWFRsL1ZmUFY1YmRyYTNrcTN5dTNyU091azYyNnM5MW0vcjBxOWFrSFYwSWJ3RGEwYjhZM2xHMTl0U3Q1MG9YcHE5WTdOdE0zS3pRTTFZVFh0Vzh5MnJOdnlvVGFqOW5xZGYxM0xWdjJ0cTdlKzJTYmExci9kZDN2ekRvTWRGVHZlNzVUc3ZMVXJlRmRydlVWOTlXN1M3b0xkanhwaUc3cS81bjdkdUVkM1Q4V2VqM3VsZXdmMlJlL3JhblJ2Yk55dnY3K3lDVzFTTm8wZVNEcHc1WnVBYjlxYjdacDN0WEJhS2c3Q1FlWEJKOSttZkh2alVPaWh6c1BjdzgzZm1YKzM5UWpyU0hrcjBqcS9kYXd0bzIyZ1BhRzk3K2lNbzUwZFhoMUh2cmYvZnU4eDQyTjF4eldQVjU2Z25TZzk4Zm5rZ3BQanAyU25ucDFPUHozVW1keDU5MHo4bVd0ZFVWMjlaMFBQbmo4WGRPNU10MS8zeWZQZTU0OWQ4THh3OUNMM1l0c2x0MHV0UGE0OVIzNXcvZUZJcjF0djYyWDN5KzFYUEs1MDlFM3JPOUh2MDMvNmFzRFZjOWY0MXk1ZG4zbTk3OGJzRzdkdUp0MGN1Q1c2OWZoMjl1MFhkd3J1VE54ZGVvOTRyL3krMnYzcUIvb1A2biswL3JGbHdHM2crR0RBWU0vRFdRL3ZEZ21IbnY2VS85T0g0ZEpIekVmVkkwWWpqWStkSHg4YkRScTk4bVRPaytHbnNxY1R6OHArVnY5NTYzT3I1OS85NHZ0THoxajgyUEFMK1l2UHY2NTVxZk55NzZ1cHJ6ckhJOGNmdk01NVBmR20vSzNPMjMzdnVPKzYzOGU5SDVrby9FRCtVUFBSK21QSHA5QlA5ejduZlA3OEwvZUU4L3NsMHA4ekFBQUFJR05JVWswQUFIb2xBQUNBZ3dBQStmOEFBSURwQUFCMU1BQUE2bUFBQURxWUFBQVhiNUpmeFVZQUFBQ2FTVVJCVkhqYWpOQTlEZ0VCRUliaFowVVVvaGVSS0YxQnEzVWVGMWlWUXFWUWFTUU80Z0NpNUFJU2pVWXBoTkVzeVNhN2RpZVpZcjdNKzgyUGlGQ1dTQkc1L0FjVVFRM1YwY2I3VzlRQnVyaGdCczBhd0FpbmlFaVRKRkcxL3pEYmZmclRLb0FON3VoVkFwaGt4eTV5ZWtuekdEY2MwQ29GTU1BU1R4elJMekF6eHhwN3ZQREFDcDJpNlVubWRzMGNkOWhHeExuc3g1OEJBRzhjM3BacGJNOC9BQUFBQUVsRlRrU3VRbUNDJyxcclxuICAgICAgICAgICAgREVMOiAnTTczLjY0MSw0NS45NTdsLTAuMDIxLDAuMjUyYzAsMC4wMzIsMC4wMjEsMC4wNiwwLjAyMSwwLjA4OGMwLDAuMDY1LTAuMDIyLDAuMTI2LTAuMDI2LDAuMTkxbC0yLjY4NSw1NC44NzhINzAuOTFjLTAuMjMxLDQuMzA0LTUuMTY2LDEwLjgxLTMxLjc0OCwxMC44MWMtMjYuNTgsMC0zMS41MDktNi41MDYtMzEuNzQ2LTEwLjgxSDcuNDFMNC43MzEsNDYuNDg4Yy0wLjAwOS0wLjA2LTAuMDI4LTAuMTI2LTAuMDI4LTAuMTkxYzAtMC4wMzIsMC4wMS0wLjA2LDAuMDEtMC4wODhsLTAuMDEtMC4yNTJoMC4wMjhjMC4wOTktMC40NjYsMC4zNjQtMC45MTksMC43ODQtMS4zNTNjMy40MzksMy40NzcsMTcuMTkxLDQuMDUxLDMzLjY0Niw0LjA1MXMzMC4yMjEtMC41NzQsMzMuNjQyLTQuMDUxYzAuNDI2LDAuNDM0LDAuNzExLDAuODg3LDAuNzg0LDEuMzUzSDczLjY0MXogTTc4LjMzNSwyNS4xMDJ2Ni40MDdjMCwxLjMxNi0xLjM0LDIuNTY3LTMuNzE1LDMuNjk2Yy02LjI2NiwyLjkzNi0xOS43NzcsNC45NzUtMzUuNDU5LDQuOTc1Yy0xNS42NjYsMC0yOS4xODktMi4wMzktMzUuNDQyLTQuOTc1QzEuMzMsMzQuMDc1LDAsMzIuODI1LDAsMzEuNTA5di02LjQwN2MwLTMuMzc0LDguNjgxLTYuMjg2LDIxLjM1OS03LjcyNFYzLjkyOWMwLTIuMTYsMS43NjgtMy45MjksMy45My0zLjkyOWgyNi4zMTRjMi4xNjQsMCwzLjkzOCwxLjc3MywzLjkzOCwzLjkzOHYxMy4yOTZDNjguOTgsMTguNjA2LDc4LjMzMywyMS42MTEsNzguMzM1LDI1LjEwMnogTTQ4LjQxNiwxMS4zOTVjMC0yLjM0OC0wLjMyMS00LjI3LTAuNzE1LTQuMjdjLTAuMzkzLDAtMi42NDEsMC00Ljk3OSwwaC04LjU0NWMtMi4zNTIsMC00LjU5MiwwLTQuOTg5LDBjLTAuMzg4LDAtMC43MTQsMS45MjItMC43MTQsNC4yN3Y1LjM2N2wxLjA4My0wLjA2NWMzLjA2Ny0wLjE3Myw2LjI4Ni0wLjI3LDkuNTk1LTAuMjcxYzMuMjAyLDAsNi4yOTIsMC4wOTgsOS4yNjQsMC4yNTJWMTEuMzk1eidcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuXHJcblxyXG5cclxuICAgIE9wZXJhdGlvbk5vZGUucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHRoaXMucmVuZGVyQmFzZSgpO1xyXG4gICAgICAgIGlmICghdGhpcy5mb3JiaWRFZGl0KSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVuZGVyT3RoZXIoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICBPcGVyYXRpb25Ob2RlLnByb3RvdHlwZS5yZW5kZXJCYXNlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdGhpcy5jcmVhdGVPcGVyYXRpb24oKTtcclxuICAgIH07XHJcblxyXG4gICAgT3BlcmF0aW9uTm9kZS5wcm90b3R5cGUuY3JlYXRlT3BlcmF0aW9uID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIG1lID0gdGhpcztcclxuICAgICAgICB0aGlzLnZpcnR1YWxSZWN0ID0gbmV3IGdyYXBoaWMuUG9seWxpbmUoeyBzdHlsZTogeyBsaW5lRGFzaDogWzJdIH0gfSk7XHJcbiAgICAgICAgdGhpcy52aXJ0dWFsUmVjdC5pc1NlbGZDb21wdXRlUG9zID0gdHJ1ZTsgIC8vIOiHquW3seiuoeeul+S9jee9rlxyXG4gICAgICAgIHRoaXMuYWRkKHRoaXMudmlydHVhbFJlY3QpO1xyXG5cclxuXHJcblxyXG4gICAgICAgIGlmICh0aGlzLm5vZGUub3BlcmF0aW9uSWNvbnMpIHtcclxuICAgICAgICAgICAgenJVdGlsLmVhY2godGhpcy5ub2RlLm9wZXJhdGlvbkljb25zLCBmdW5jdGlvbihpdGVtKSB7XHJcbiAgICAgICAgICAgICAgICAvL+ajgOafpeaYr+WQpuaYr+WGhee9ruWbvuagh1xyXG4gICAgICAgICAgICAgICAgdmFyIG9wSWNvbkluc3RhbmNlID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIGlmIChPcGVyYXRpb25Ob2RlLm9waWNvbnNbaXRlbS5uYW1lICsgXCJcIl0pIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZm9yYmlkRWRpdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpdGVtLm5hbWUgPT0gXCJERUxcIikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL+Weg+WcvuahtlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVjdDEgPSB7IHg6IDAsIHk6IDAsIHdpZHRoOiAxMCwgaGVpZ2h0OiAxNSB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvcEljb25JbnN0YW5jZSA9IGdyYXBoaWMubWFrZVBhdGgoT3BlcmF0aW9uTm9kZS5vcGljb25zW2l0ZW0ubmFtZSArIFwiXCJdLCB7IHN0eWxlOiB7IGZpbGw6ICcjMDAwMDAwJyB9IH0sIHJlY3QxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoaXRlbS5jYWxsYmFjayl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcEljb25JbnN0YW5jZS5vbihcImNsaWNrXCIsIGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLmRhdGEgPSBpdGVtO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUubm9kZSA9IG1lLm5vZGU7ICAvLyDlsIbmiYDpmYTnmoToioLngrnkuZ/kvKDpgJLlh7rljrtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbS5jYWxsYmFjaykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtLmNhbGxiYWNrKGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wSWNvbkluc3RhbmNlLm9uKFwiY2xpY2tcIiwgZnVuY3Rpb24oZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXJhbXMgPSB7fTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMuZXZlbnQgPSBlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtcy50YXJnZXQgPSB0aGlzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtcy50eXBlID0gT3BlcmF0aW9uTm9kZS5ERUxFVEVfQ0xJQ0s7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWUudHJpZ2dlcihwYXJhbXMudHlwZSwgcGFyYW1zKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZighZW52LmNhbnZhc1N1cHBvcnRlZCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVjdCA9IHsgeDogMCwgeTogMCwgd2lkdGg6IDE1LCBoZWlnaHQ6IDE1IH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcEljb25JbnN0YW5jZSA9IGdyYXBoaWMubWFrZVBhdGgoT3BlcmF0aW9uTm9kZS5vcGljb25zW2l0ZW0ubmFtZSArIFwiXCJdLCB7IHN0eWxlOiB7IGZpbGw6ICcjMDAwMDAwJyB9LGRyYWdnYWJsZTp0cnVlLHo6MTksbGluZVR5cGU6IENvbm5lY3RvcltcIlRZUEVfXCIgKyBpdGVtLm5hbWVdIH0sIHJlY3QpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbWFnZVVybCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2ltZycpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2VVcmwuc3JjID0gT3BlcmF0aW9uTm9kZS5vcGljb25zW2l0ZW0ubmFtZSArIFwiXCJdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BJY29uSW5zdGFuY2UgPSBuZXcgZ3JhcGhpYy5JbWFnZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2U6aW1hZ2VVcmwsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvcjogJ2RlZmF1bHQnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDoxNSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OjE1XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkcmFnZ2FibGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgejogMTksIC8vekluZGV4IOe9ruS6juacgOmrmFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVUeXBlOiBDb25uZWN0b3JbXCJUWVBFX1wiICsgaXRlbS5uYW1lXSAvL+WMuuWIhuS4jeWQjOeahOe6v+autVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBNT1VTRV9FVkVOVF9OQU1FUyA9IFsnZHJhZ3N0YXJ0JywgJ2RyYWcnLCAnZHJhZ2VuZCddO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB6clV0aWwuZWFjaChNT1VTRV9FVkVOVF9OQU1FUywgZnVuY3Rpb24oZXZlTmFtZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BJY29uSW5zdGFuY2Uub24oZXZlTmFtZSwgZnVuY3Rpb24oZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXJhbXMgPSB7fTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMuZXZlbnQgPSBlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtcy50eXBlID0gXCJPcGVyYXRpb25Ob2RlOlwiICsgZXZlTmFtZSArIFwiQXJyb3dcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZS50cmlnZ2VyKHBhcmFtcy50eXBlLCBwYXJhbXMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8v55So5oi36Ieq5a6a5LmJ55qE5Zu+5qCH5pS+5Zyo6L+Z6YeM77yM55So5oi35Lyg6L+b5p2l55qE5Zu+5qCH5Y+q6IO95ZON5bqUY2xpY2vkuovku7bvvIzlhbblroPkuovku7bmmoLkuI3mlK/mjIFcclxuICAgICAgICAgICAgICAgICAgICBvcEljb25JbnN0YW5jZSA9IG5ldyBncmFwaGljLkltYWdlKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlOiBpdGVtLmljb25QYXRoLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IGl0ZW0ud2lkdGggfHwgMTUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGl0ZW0uaGVpZ2h0IHx8IDE1XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHo6IDE5IC8vekluZGV4IOe9ruS6juacgOmrmFxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIG9wSWNvbkluc3RhbmNlLm9uKFwiY2xpY2tcIiwgZnVuY3Rpb24oZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlLmRhdGEgPSBpdGVtO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlLm5vZGUgPSBtZS5ub2RlOyAgLy8g5bCG5omA6ZmE55qE6IqC54K55Lmf5Lyg6YCS5Ye65Y67XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpdGVtLmNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtLmNhbGxiYWNrKGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL3RvZG8g55So5oi36Ieq5a6a5Zu+5qCHY2xpY2vkuovku7bmmK/lkKbopoHmtL7lj5HliLDlpJbpnaJcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIG9wSWNvbkluc3RhbmNlLm5hbWUgPSBpdGVtLm5hbWU7XHJcbiAgICAgICAgICAgICAgICBtZS5hZGQob3BJY29uSW5zdGFuY2UpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIE9wZXJhdGlvbk5vZGUucHJvdG90eXBlLnJlZnJlc2hQb3N0aW9uID0gZnVuY3Rpb24obm9kZSxub2RlUmVjdCkge1xyXG4gICAgICAgIHZhciBtZSA9IHRoaXM7XHJcbiAgICAgICAgdmFyIGkgPSAwO1xyXG4gICAgICAgIHZhciByYlBvaW50ID0gbm9kZVJlY3QucG9pbnRzWzJdOyAvL+WPluWPs+S4i+inkuWdkOagh1xyXG4gICAgICAgIC8vMS7lrprkvY3omZrmoYZcclxuICAgICAgICB0aGlzLnZpcnR1YWxSZWN0LnNldFNoYXBlKHsgcG9pbnRzOiBub2RlUmVjdC5wb2ludHMgfSk7XHJcbiAgICAgICAgLy8yLuWumuS9jeavj+S4quWwj+Wbvuagh1xyXG4gICAgICAgIHRoaXMuZWFjaENoaWxkKGZ1bmN0aW9uKG5vZGVJdGVtKSB7XHJcbiAgICAgICAgICAgIGlmICghbm9kZUl0ZW0uaXNTZWxmQ29tcHV0ZVBvcykge1xyXG4gICAgICAgICAgICAgICAgLy8gOHB45piv56ys5LiA5Liq5pON5L2c5oyJ6ZKu5Zu+5qCH55qE6Led56a7IOmdoOWkqui/keS4jeWlveeciyAgICAyMHB45piv5q+P5Liq5Zu+5qCH55qE6Ze06ZqUICAxMHB45piv5Zu+5qCH5ZCR5YGP55qE6Led56a7XHJcbiAgICAgICAgICAgICAgICBub2RlSXRlbS5hdHRyKFwicG9zaXRpb25cIiwgW3JiUG9pbnRbMF0gKyA4ICsgKGkrKyAqIDIwKSwgcmJQb2ludFsxXSAtIDEwXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgdGhpcy5yZWZyZXNoUG9zaXRpb25PdGhlcihub2RlLG5vZGVSZWN0KTtcclxuICAgIH07XHJcblxyXG4gICAgT3BlcmF0aW9uTm9kZS5wcm90b3R5cGUucmVuZGVyT3RoZXIgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAvL+eVmee7meaJqeWxleS9v+eUqFxyXG4gICAgfTtcclxuICAgIE9wZXJhdGlvbk5vZGUucHJvdG90eXBlLnJlZnJlc2hQb3NpdGlvbk90aGVyID0gZnVuY3Rpb24obm9kZSxub2RlUmVjdCkge1xyXG4gICAgICAgIC8v55WZ57uZ5omp5bGV5L2/55SoXHJcbiAgICAgICAgLy8zLuWumuS9jeaVtOS4qm9wZXJhdGlvbk5vZGVcclxuICAgICAgICBpZiAobm9kZS5wYXJlbnQgJiYgbm9kZS5wYXJlbnQuaXNCZyAmJiBub2RlLnBhcmVudC5pc0JnID09IHRydWUpIHtcclxuICAgICAgICAgICAgdGhpcy5hdHRyKFwicG9zaXRpb25cIiwgW25vZGVSZWN0LngsIG5vZGVSZWN0LnldKVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuYXR0cihcInBvc2l0aW9uXCIsIFtub2RlUmVjdC54ICsgbm9kZS5wYXJlbnQucG9zaXRpb25bMF0rbm9kZS5zaGFwZS54LCBub2RlUmVjdC55ICsgbm9kZS5wYXJlbnQucG9zaXRpb25bMV0rbm9kZS5zaGFwZS55XSlcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgenJVdGlsLmluaGVyaXRzKE9wZXJhdGlvbk5vZGUsIE5vZGUpO1xyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBPcGVyYXRpb25Ob2RlO1xyXG5cclxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2xpYi9maXNoLXRvcG8tY29yZS9saWIvbWFuYWdlci9PcGVyYXRpb25Ob2RlLmpzXG4gKiogbW9kdWxlIGlkID0gMTAzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcclxuICogYnBtbui/nue6v+euoeeQhuexu1xyXG4gKiBAYXV0aG9yIHdhbmcueGlhb2h1XHJcbiAqL1xyXG5cclxuXHR2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XHJcblx0dmFyIENvbm5lY3Rpb25NYW5hZ2VyID0gcmVxdWlyZShcIi4uLy4uLy4uL2Zpc2gtdG9wby1jb3JlL2xpYi9tYW5hZ2VyL0Nvbm5lY3Rpb25NYW5hZ2VyLmpzXCIpO1xyXG5cdHZhciBCUE1OTW9kZWwgPSByZXF1aXJlKFwiLi4vbW9kZWwvQlBNTk1vZGVsLmpzXCIpO1xyXG5cdHZhciBDb25uZWN0b3IgPSByZXF1aXJlKFwiLi4vLi4vLi4vZmlzaC10b3BvLWNvcmUvbGliL3NoYXBlcy9Db25uZWN0b3IuanNcIik7XHJcbiAgICB2YXIgUG9pbnQgPSByZXF1aXJlKFwiLi4vLi4vLi4vZmlzaC10b3BvLWNvcmUvbGliL1BvaW50LmpzXCIpO1xyXG5cdHZhciBjb25uZWN0aW9uTWFuYWdlckV4dGVuZCA9IHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiDliJvlu7rov57nur9cclxuICAgICAgICAgKiBAcGFyYW0gIHtbdHlwZV19IHN0YXJ0Tm9kZSBb5byA5aeL6IqC54K5XVxyXG4gICAgICAgICAqIEBwYXJhbSAge1t0eXBlXX0gZW5kTm9kZSAgIFvnu5PmnZ/oioLngrldXHJcbiAgICAgICAgICogQHBhcmFtICB7W3R5cGVdfSB0eXBlICAgICAgW+exu+Wei11cclxuICAgICAgICAgKiBAcGFyYW0ge1t0eXBlXX0gW2FwaV0gW2Rlc2NyaXB0aW9uXVxyXG4gICAgICAgICAqIEByZXR1cm4ge1t0eXBlXX0gICAgICAgICAgIFvov5Tlm57ov57nur9dXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgY29ubmVjdG9yQ3JlYXRlOmZ1bmN0aW9uKHN0YXJ0Tm9kZSxlbmROb2RlLHR5cGUsIGFwaSl7XHJcbiAgICAgICAgICAgIHZhciBtb2RlbCA9IG5ldyBCUE1OTW9kZWwoe30pO1xyXG4gICAgICAgICAgICBtb2RlbC5zZXQoXCJzdHlsZS5saW5lVHlwZVwiLCB0eXBlKTtcclxuICAgICAgICAgICAgbW9kZWwuc2V0KFwic3RlbmNpbC50eXBlXCIsIHRoaXMuc3RlbmNpbFR5cGUpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29ubmVjdG9yQ3JlYXRlQnlPcHRpb25zKHN0YXJ0Tm9kZSxlbmROb2RlLHttb2RlbDptb2RlbCwgaXNFZGl0OiB0cnVlLCBzdHlsZToge2xpbmVUeXBlOnR5cGV9fSwgYXBpKTtcclxuICAgICAgICB9LFxyXG5cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICog5qC55o2ub3BldGlvbnMubW9kZWwg5Y+N5bqP5YiX5YyW57q/XHJcbiAgICAgICAgICogQHBhcmFtICB7W3R5cGVdfSBzdGFydE5vZGUgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICAgICAqIEBwYXJhbSAge1t0eXBlXX0gZW5kTm9kZSAgIFtkZXNjcmlwdGlvbl1cclxuICAgICAgICAgKiBAcGFyYW0gIHtbdHlwZV19IG9wdGlvbnMgICBbZGVzY3JpcHRpb25dXHJcbiAgICAgICAgICogQHBhcmFtICB7W3R5cGVdfSBhcGkgICAgICAgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICAgICAqIEByZXR1cm4ge1t0eXBlXX0gICAgICAgICAgIFtkZXNjcmlwdGlvbl1cclxuICAgICAgICAgKi9cclxuICAgICAgICBjb25uZWN0b3JDcmVhdGVCeU9wdGlvbnM6ZnVuY3Rpb24oc3RhcnROb2RlLGVuZE5vZGUsb3B0aW9ucywgYXBpKXtcclxuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgICAgICAgICB2YXIgbW9kZWwgPSBvcHRpb25zLm1vZGVsO1xyXG4gICAgICAgICAgICB2YXIgY29ubmVjdG9yID0gbmV3IENvbm5lY3RvcihvcHRpb25zKTtcclxuICAgICAgICAgICAgY29ubmVjdG9yLnN0YXJ0Tm9kZSA9IHN0YXJ0Tm9kZTtcclxuICAgICAgICAgICAgY29ubmVjdG9yLmVuZE5vZGUgPSBlbmROb2RlO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5jb25uZWN0b3JzLnB1c2goY29ubmVjdG9yKTtcclxuXHJcbiAgICAgICAgICAgIC8v5Yik5pat5LiA5LiLc1BvcyxlUG9zXHJcbiAgICAgICAgICAgIGNvbm5lY3Rvci5zUG9zID0gbW9kZWwuZ2V0KFwic3R5bGUuc1Bvc1wiKTtcclxuICAgICAgICAgICAgY29ubmVjdG9yLmVQb3MgPSBtb2RlbC5nZXQoXCJzdHlsZS5lUG9zXCIpO1xyXG5cclxuICAgICAgICAgICAgLy/liKTmlq3kuIDkuIsgbW9kZWzph4zmnInmsqHmnIlkb2NrZXJz77yM5aaC5p6c5pyJ5YiZ6LCD55So5p6E6YCgcG9pbnTmlbDnu4QgIOaIluiAheiwg+eUqHJlZnJlc2hDb25uZWN0b3LorqHnrpflpoLkvZXnlLvnur9cclxuICAgICAgICAgICAgdmFyIGRvY2tlcnMgPSBtb2RlbC5nZXQoXCJkb2NrZXJzXCIpO1xyXG4gICAgICAgICAgICBpZiAoZG9ja2VycyAmJiBkb2NrZXJzLmxlbmd0aCA+PSAyKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcG9pbnRzID0gUG9pbnQubG9hZEFycmF5KGRvY2tlcnMpO1xyXG4gICAgICAgICAgICAgICAgY29ubmVjdG9yLnJlZnJlc2gocG9pbnRzKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVmcmVzaENvbm5lY3Rvcihjb25uZWN0b3IsdHJ1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGNvbm5lY3Rvci5jb25Qb2ludHNHcm91cC5vbihcImNsaWNrXCIsIGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgICAgICAgIHZhciBhcnJTcGxpdCA9IGUudGFyZ2V0LnR5cGUuc3BsaXQoQ29ubmVjdG9yLlNFUEVSQVRPUik7XHJcbiAgICAgICAgICAgICAgICB2YXIgY29ubmVjdG9yID0gZS50YXJnZXQuY29ubmVjdG9yO1xyXG4gICAgICAgICAgICAgICAgaWYgKGFyclNwbGl0WzBdID09PSBDb25uZWN0b3IuU1RBUlRfTk9ERSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbm5lY3Rvci5zUG9zID0gYXJyU3BsaXRbMV07XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGFyclNwbGl0WzBdID09PSBDb25uZWN0b3IuRU5EX05PREUpe1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbm5lY3Rvci5lUG9zID0gYXJyU3BsaXRbMV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGF0LnJlZnJlc2hDb25uZWN0b3IoY29ubmVjdG9yLHRydWUpO1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBwYXJhbXMgPSB7fTtcclxuICAgICAgICAgICAgICAgIHBhcmFtcy5ldmVudCA9IGU7XHJcbiAgICAgICAgICAgICAgICBwYXJhbXMudHlwZSA9IFwiY29uUG9pbnRzR3JvdXA6Y2xpY2tcIjtcclxuICAgICAgICAgICAgICAgIHBhcmFtcy5saW5lTm9kZSA9IHRoYXQuc2VsQ29ubmVjdG9yO1xyXG4gICAgICAgICAgICAgICAgYXBpLnRyaWdnZXIocGFyYW1zLnR5cGUsIHBhcmFtcyk7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuXHJcbiAgICAgICAgICAgIHZhciBNT1VTRV9FVkVOVF9OQU1FUyA9IFsnZGJsY2xpY2snLCAnY2xpY2snXTtcclxuICAgICAgICAgICAgenJVdGlsLmVhY2goTU9VU0VfRVZFTlRfTkFNRVMsIGZ1bmN0aW9uIChldmVOYW1lKSB7XHJcbiAgICAgICAgICAgICAgICBjb25uZWN0b3Iub24oXCJDb25uZWN0b3I6XCIgKyBldmVOYW1lLCBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNlbGVjdGVkID0gZS50YXJnZXQ7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICggdGhhdC5zZWxDb25uZWN0b3IgIT09IHNlbGVjdGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuc2VsQ29ubmVjdG9yICYmICB0aGF0LnJlZnJlc2hDb25uZWN0b3IodGhhdC5zZWxDb25uZWN0b3IpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGF0LnNlbENvbm5lY3RvciA9IHNlbGVjdGVkO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhcmFtcyA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtcy5ldmVudCA9IGU7XHJcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zLnR5cGUgPSBldmVOYW1lO1xyXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtcy50YXJnZXQgPSB0aGF0LnNlbENvbm5lY3RvcjtcclxuICAgICAgICAgICAgICAgICAgICBhcGkudHJpZ2dlcihwYXJhbXMudHlwZSwgcGFyYW1zKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIC8vMS7orr7nva7otbflp4voioLngrnnmoRvdXRnb2luZ+aVsOe7hCDkuLrnur/mrrXnmoRJRFxyXG4gICAgICAgICAgICB2YXIgc3RhcnROb2RlT3V0Z29pbmcgPSBzdGFydE5vZGUubW9kZWwuZ2V0KFwib3V0Z29pbmdcIik7XHJcbiAgICAgICAgICAgIHN0YXJ0Tm9kZU91dGdvaW5nLnB1c2goY29ubmVjdG9yLnJlc291cmNlSWQpO1xyXG4gICAgICAgICAgICAvLzIu6K6+572u57q/5q6155qEb3V0Z29pbmfmlbDnu4Qg5Li657uT5p2f6IqC54K555qESURcclxuICAgICAgICAgICAgdmFyIGNvbm5lY3Rvck91dGdvaW5nID0gY29ubmVjdG9yLm1vZGVsLmdldChcIm91dGdvaW5nXCIpO1xyXG4gICAgICAgICAgICBjb25uZWN0b3JPdXRnb2luZy5wdXNoKGVuZE5vZGUucmVzb3VyY2VJZCk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gY29ubmVjdG9yO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIOiuvue9rue6v+auteeahOaooeWei+aVsOaNriAgKOexu+WeiyDmloflrZcpXHJcbiAgICAgICAgICogQHBhcmFtIHtbdHlwZV19IGNvbm5lY3RvciBbZGVzY3JpcHRpb25dXHJcbiAgICAgICAgICogQHBhcmFtIHtbdHlwZV19IG9wdGlvbiAgICBbZGVzY3JpcHRpb25dXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgc2V0TW9kZWw6IGZ1bmN0aW9uKGNvbm5lY3Rvciwgb3B0aW9uKSB7XHJcbiAgICAgICAgICAgIHZhciBvcmlnaW5MaW5lVHlwZSA9ICBjb25uZWN0b3IubW9kZWwuZ2V0KFwic3R5bGUubGluZVR5cGVcIik7XHJcbiAgICAgICAgICAgIHZhciBvcmlnaW5OYW1lID0gY29ubmVjdG9yLm9wdGlvbnMudGV4dC50ZXh0O1xyXG4gICAgICAgICAgICBjb25uZWN0b3Iub3B0aW9ucy50ZXh0LnRleHQgPSAgb3B0aW9uLnByb3BlcnRpZXMubmFtZTtcclxuICAgICAgICAgICAgY29ubmVjdG9yLm1vZGVsLm1lcmdlT3B0aW9uKG9wdGlvbik7XHJcbiAgICAgICAgICAgIC8v5paH5a2X5LiN5LiA6Ie05pe2XHJcbiAgICAgICAgICAgIGlmIChvcmlnaW5OYW1lICE9IG9wdGlvbi5wcm9wZXJ0aWVzLm5hbWUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVmcmVzaENvbm5lY3Rvcihjb25uZWN0b3IsIHRydWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiDliLfmlrDov57mjqXnur9cclxuICAgICAgICAgKiBAcGFyYW0gIHtbdHlwZV19IG5vZGUgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICAgICAqIEByZXR1cm4ge1t0eXBlXX0gICAgICBbZGVzY3JpcHRpb25dXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgcmVmcmVzaExpbmVCeU5vZGU6IGZ1bmN0aW9uKG5vZGUpIHtcclxuICAgICAgICAgICAgZm9yKHZhciBpID0gMCwgbGVuID0gdGhpcy5jb25uZWN0b3JzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKXtcclxuICAgICAgICAgICAgICAgIGlmKHRoaXMuY29ubmVjdG9yc1tpXS5zdGFydE5vZGUgPT0gbm9kZSB8fCB0aGlzLmNvbm5lY3RvcnNbaV0uZW5kTm9kZSA9PSBub2RlKXtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlZnJlc2hDb25uZWN0b3IodGhpcy5jb25uZWN0b3JzW2ldLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHR9O1xyXG5cclxuXHR2YXIgQnBtbkNvbm5lY3Rpb25NYW5hZ2VyID0genJVdGlsLmV4dGVuZChDb25uZWN0aW9uTWFuYWdlciwgY29ubmVjdGlvbk1hbmFnZXJFeHRlbmQpO1xyXG5cdG1vZHVsZS5leHBvcnRzID0gQnBtbkNvbm5lY3Rpb25NYW5hZ2VyO1xyXG5cclxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2xpYi9maXNoLXRvcG8tYnBtbi9saWIvbWFuYWdlci9CcG1uQ29ubmVjdGlvbk1hbmFnZXIuanNcbiAqKiBtb2R1bGUgaWQgPSAxMDRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxyXG4gKiDov57nur/nrqHnkIbnsbtcclxuICogQGF1dGhvciB3YW5nLnhpYW9odVxyXG4gKi9cclxuXHJcbiAgICB2YXIgTm9kZSA9IHJlcXVpcmUoXCIuLi9Ob2RlXCIpO1xyXG4gICAgdmFyIFV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XHJcbiAgICB2YXIgZ3JhcGhpYyA9IHJlcXVpcmUoXCIuLi9ncmFwaGljLmpzXCIpO1xyXG4gICAgdmFyIFBvaW50ID0gcmVxdWlyZShcIi4uL1BvaW50LmpzXCIpO1xyXG4gICAgdmFyIENvbm5lY3RvciA9IHJlcXVpcmUoXCIuLi9zaGFwZXMvQ29ubmVjdG9yLmpzXCIpO1xyXG4gICAgdmFyIExvZyA9IHJlcXVpcmUoXCIuLi9Mb2cuanNcIik7XHJcbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XHJcbiAgICB2YXIgQ29ubmVjdGlvbk1hbmFnZXIgPSB7XHJcblxyXG4gICAgICAgIENMT1VEX1JBRElVUzogMTIsXHJcbiAgICAgICAgQ0xPVURfTElORVdJRFRIOiAzLFxyXG4gICAgICAgIENMT1VEX1NUUk9LRV9TVFlMRTogXCJyZ2JhKDI1NSwgMTUzLCAwLCAwLjgpXCIsIC8vb3JhbmdlXHJcbiAgICAgICAgc3RlbmNpbFR5cGUgOiBcIlNlcXVlbmNlRmxvd1wiLFxyXG4gICAgICAgIGNvbm5lY3RvcnM6IFtdLFxyXG4gICAgICAgIHNlbENvbm5lY3RvcjogbnVsbCxcclxuICAgICAgICB0ZW1wQ29ubmVjdG9yOiBudWxsLFxyXG5cclxuXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIOiuvue9rue6v+eahOS4jeWPr+e8lui+kVxyXG4gICAgICAgICAqIEBwYXJhbSAge1t0eXBlXX0gZm9yYmlkRWRpdCBbZGVzY3JpcHRpb25dXHJcbiAgICAgICAgICogQHJldHVybiB7W3R5cGVdfSAgICAgICAgICAgIFtkZXNjcmlwdGlvbl1cclxuICAgICAgICAgKi9cclxuICAgICAgICBjb25uZWN0b3JGb3JiaWRFZGl0OmZ1bmN0aW9uKGZvcmJpZEVkaXQpe1xyXG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XHJcbiAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7aSA8IHRoaXMuY29ubmVjdG9ycy5sZW5ndGg7aSsrKXtcclxuICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdG9yc1tpXS5vcHRpb25zLmlzRWRpdCA9ICFmb3JiaWRFZGl0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIOa4heepuui/nuaOpee6v1xyXG4gICAgICAgICAqIEByZXR1cm4ge1t0eXBlXX0gW2Rlc2NyaXB0aW9uXVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGNsZWFyU2VsZWN0Q29uOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgaWYgKENvbm5lY3Rpb25NYW5hZ2VyLnNlbENvbm5lY3RvciAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlZnJlc2hDb25uZWN0b3IodGhpcy5zZWxDb25uZWN0b3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiDliKDpmaTov57mjqXnur9cclxuICAgICAgICAgKiBAcmV0dXJuIHtbdHlwZV19IFtkZXNjcmlwdGlvbl1cclxuICAgICAgICAgKi9cclxuICAgICAgICBkZWxldGVTZWxlY3RDb246ZnVuY3Rpb24obm9kZSxfenIpe1xyXG4gICAgICAgICAgICB2YXIgZGVsZXRlTGluZT0gW107XHJcbiAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLmNvbm5lY3RvcnMubGVuZ3RoOyBpKyspe1xyXG4gICAgICAgICAgICAgICAgaWYodGhpcy5jb25uZWN0b3JzW2ldLnN0YXJ0Tm9kZSA9PSBub2RlIHx8IHRoaXMuY29ubmVjdG9yc1tpXS5lbmROb2RlID09IG5vZGUpe1xyXG4gICAgICAgICAgICAgICAgICAgIC8vMS7lsIbnur8g5omA6IGU55qEc3RhcnROb2Rl55qEb3V0Z29pbmfmlbDmja7liKDpmaRcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc3RhcnROb2RlT3V0Z29pbmcgPSB0aGlzLmNvbm5lY3RvcnNbaV0uc3RhcnROb2RlLm1vZGVsLmdldChcIm91dGdvaW5nXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGluZGV4ID0genJVdGlsLmluZGV4T2Yoc3RhcnROb2RlT3V0Z29pbmcsIHRoaXMuY29ubmVjdG9yc1tpXS5yZXNvdXJjZUlkKTtcclxuICAgICAgICAgICAgICAgICAgICBpZihpbmRleCAhPSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydE5vZGVPdXRnb2luZy5zcGxpY2UoaW5kZXgsMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIC8vMi7ku45fenLkuIrliKDpmaRcclxuICAgICAgICAgICAgICAgICAgICBfenIucmVtb3ZlKHRoaXMuY29ubmVjdG9yc1tpXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25uZWN0b3JzLnNwbGljZShpLCAxKTtcclxuICAgICAgICAgICAgICAgICAgICBpLS07XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxDb25uZWN0b3IgPSBudWxsO1xyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICog5Yig6Zmk6YCJ5a6a55qE57q/XHJcbiAgICAgICAgICogQHJldHVybiB7W3R5cGVdfSBbZGVzY3JpcHRpb25dXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZGVsZXRlTGluZTpmdW5jdGlvbihfenIpe1xyXG4gICAgICAgICAgICAvLzEu5bCG57q/IOaJgOiBlOeahHN0YXJ0Tm9kZeeahG91dGdvaW5n5pWw5o2u5Yig6ZmkXHJcbiAgICAgICAgICAgIHZhciBzdGFydE5vZGVPdXRnb2luZyA9IHRoaXMuc2VsQ29ubmVjdG9yLnN0YXJ0Tm9kZS5tb2RlbC5nZXQoXCJvdXRnb2luZ1wiKTtcclxuICAgICAgICAgICAgaW5kZXggPSB6clV0aWwuaW5kZXhPZihzdGFydE5vZGVPdXRnb2luZywgdGhpcy5zZWxDb25uZWN0b3IucmVzb3VyY2VJZCk7XHJcbiAgICAgICAgICAgIGlmKGluZGV4ICE9IC0xKSB7XHJcbiAgICAgICAgICAgICAgICBzdGFydE5vZGVPdXRnb2luZy5zcGxpY2UoaW5kZXgsMSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbm5lY3Rvck1hcCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IHRoaXMuZ2V0VHdvTm9kZUlkKHRoaXMuc2VsQ29ubmVjdG9yLnN0YXJ0Tm9kZSwgdGhpcy5zZWxDb25uZWN0b3IuZW5kTm9kZSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3Rvck1hcC5yZW1vdmVJdGVtKGtleSwgdGhpcy5zZWxDb25uZWN0b3IpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLzIu5LuOX3py5LiK5Yig6ZmkXHJcbiAgICAgICAgICAgIF96ci5yZW1vdmUodGhpcy5zZWxDb25uZWN0b3IpO1xyXG5cclxuXHJcbiAgICAgICAgICAgIC8vMy7ku47nur/mlbDmja7kuK3liKDpmaRcclxuICAgICAgICAgICAgdmFyIGluZGV4ID0genJVdGlsLmluZGV4T2YodGhpcy5jb25uZWN0b3JzLCB0aGlzLnNlbENvbm5lY3Rvcik7XHJcbiAgICAgICAgICAgIGlmKGluZGV4ICE9IC0xKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3RvcnMuc3BsaWNlKGluZGV4LDEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuc2VsQ29ubmVjdG9yID0gbnVsbDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIOmHjeaWsOeUu+e6v1xyXG4gICAgICAgICAqIEBwYXJhbSAge1t0eXBlXX0gY29ubmVjdG9yICAgICAgICAgIFtkZXNjcmlwdGlvbl1cclxuICAgICAgICAgKiBAcGFyYW0gIHtbdHlwZV19IGZvcmNlXHJcbiAgICAgICAgICogQHJldHVybiB7W3R5cGVdfSAgICAgICAgICAgICAgICAgICAgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHJlZnJlc2hDb25uZWN0b3I6IGZ1bmN0aW9uIChjb25uZWN0b3IsIGZvcmNlKSB7XHJcbiAgICAgICAgICAgIC8vIOWPquaciemcgOimgeW8uuWItuWIt+aWsCAg5oiW6ICFIOi/nue6v+S4uuepuu+8iDwyKeaXtiDmiY3ov5vooYzph43mlrDorqHnrpfph43nu5hcclxuICAgICAgICAgICAgaWYoIGZvcmNlIHx8ICghY29ubmVjdG9yLnR1cm5pbmdQb2ludHMpIHx8IChjb25uZWN0b3IudHVybmluZ1BvaW50cy5sZW5ndGggPCAyKSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaWYgKGNvbm5lY3Rvci5tb2RlbCAmJiBjb25uZWN0b3IubW9kZWwuZ2V0KFwic3R5bGUubGluZVR5cGVcIikpIHsgY29ubmVjdG9yLm9wdGlvbnMuc3R5bGUubGluZVR5cGUgPSBjb25uZWN0b3IubW9kZWwuZ2V0KFwic3R5bGUubGluZVR5cGVcIik7fVxyXG4gICAgICAgICAgICAgICAgdmFyIGFyclN0YXJ0RW5kUG9pbnQgPSB0aGlzLmdldFN0YXJ0RW5kUG9pbnQoY29ubmVjdG9yKTtcclxuICAgICAgICAgICAgICAgIHZhciBlc2NhcGVEaXN0YW5jZSA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICBpZihjb25uZWN0b3Iub3B0aW9ucy5wb3NpdGlvbiYmY29ubmVjdG9yLm9wdGlvbnMucG9zaXRpb24uZXNjYXBlRGlzdGFuY2Upe1xyXG4gICAgICAgICAgICAgICAgICAgIGVzY2FwZURpc3RhbmNlID0gY29ubmVjdG9yLm9wdGlvbnMucG9zaXRpb24uZXNjYXBlRGlzdGFuY2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgc29sdXRpb25zID0gdGhpcy5jb25uZWN0b3IyUG9pbnRzKGNvbm5lY3Rvci5vcHRpb25zLnN0eWxlLmxpbmVUeXBlLCBhcnJTdGFydEVuZFBvaW50WzBdLCBhcnJTdGFydEVuZFBvaW50WzFdLFxyXG4gICAgICAgICAgICAgICAgICAgIGFyclN0YXJ0RW5kUG9pbnRbMl0sIGFyclN0YXJ0RW5kUG9pbnRbM10sZXNjYXBlRGlzdGFuY2UpOyAgLy8gVFlQRV9TVFJBSUdIVCBUWVBFX0pBR0dFRFxyXG5cclxuXHJcbiAgICAgICAgICAgICAgICBjb25uZWN0b3IucmVmcmVzaChzb2x1dGlvbnNbMF1bMl0pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBjb25uZWN0b3IuY2xlYXJIYW5kbGVzKCk7ICAvL+a4heepumhhbmRsZVxyXG4gICAgICAgIH0sXHJcblxyXG5cclxuICAgICAgICBnZXRTdGFydEVuZFBvaW50OiBmdW5jdGlvbihjb25uZWN0b3IpIHtcclxuICAgICAgICAgICAgdmFyIHN0YXJ0Tm9kZSA9IGNvbm5lY3Rvci5zdGFydE5vZGU7XHJcbiAgICAgICAgICAgIHZhciBlbmROb2RlID0gY29ubmVjdG9yLmVuZE5vZGU7XHJcblxyXG4gICAgICAgICAgICB2YXIgc1JlY3QgPSBzdGFydE5vZGUuZ2V0UmVjdD8gc3RhcnROb2RlLmdldFJlY3QoKS5ib3VuZGluZ1JlY3QgOiBVdGlsLmdldFJlY3Qoc3RhcnROb2RlKS5ib3VuZGluZ1JlY3Q7XHJcbiAgICAgICAgICAgIHZhciBzQm91bmRzID0gW051bWJlcihzUmVjdC54KSwgTnVtYmVyKHNSZWN0LnkpLCBOdW1iZXIoc1JlY3QueCkgKyBOdW1iZXIoc1JlY3Qud2lkdGgpLCBOdW1iZXIoc1JlY3QueSkgKyBOdW1iZXIoc1JlY3QuaGVpZ2h0KV07XHJcblxyXG4gICAgICAgICAgICB2YXIgZVJlY3QgPSBzdGFydE5vZGUuZ2V0UmVjdD8gZW5kTm9kZS5nZXRSZWN0KCkuYm91bmRpbmdSZWN0IDogVXRpbC5nZXRSZWN0KGVuZE5vZGUpLmJvdW5kaW5nUmVjdDtcclxuICAgICAgICAgICAgdmFyIGVCb3VuZHMgPSBbTnVtYmVyKGVSZWN0LngpLCBOdW1iZXIoZVJlY3QueSksIE51bWJlcihlUmVjdC54KSArIE51bWJlcihlUmVjdC53aWR0aCksIE51bWJlcihlUmVjdC55KSArIE51bWJlcihlUmVjdC5oZWlnaHQpXTtcclxuXHJcblxyXG4gICAgICAgICAgICB2YXIgc0Nvbm5lY3RvclBvaW50ID0gVXRpbC5nZXRDb25uZWN0b3JQb2ludHMoc1JlY3QpO1xyXG4gICAgICAgICAgICB2YXIgZUNvbm5lY3RvclBvaW50ID0gVXRpbC5nZXRDb25uZWN0b3JQb2ludHMoZVJlY3QpO1xyXG5cclxuICAgICAgICAgICAgLy/liKTmlq3lpoLmnpzmsqHmnInmjIflrprkvY3nva7nmoTor50sIOWIpOaWreW8gOWni+iKgueCueWcqOe7k+adn+e7k+aenOW3pui+ueWImemHh+eUqCByaWdodC1sZWZ0IOWQpuWImemHh+eUqGxlZnQtcmlnaHRcclxuICAgICAgICAgICAgaWYgKCFjb25uZWN0b3Iuc1BvcyB8fCAhY29ubmVjdG9yLmVQb3MpIHtcclxuICAgICAgICAgICAgICAgIGlmIChzUmVjdC54IDwgZVJlY3QueCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbm5lY3Rvci5zUG9zID0gXCJyaWdodFwiO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbm5lY3Rvci5lUG9zID0gXCJsZWZ0XCI7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbm5lY3Rvci5zUG9zID0gXCJsZWZ0XCI7XHJcbiAgICAgICAgICAgICAgICAgICAgY29ubmVjdG9yLmVQb3MgPSBcInJpZ2h0XCI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHN0YXJ0UG9pbnQgPSAgdGhpcy5jYWxjUG9pbnRFeHByZXNzaW9uKGNvbm5lY3Rvci5zUG9zLCBzQ29ubmVjdG9yUG9pbnQpO1xyXG4gICAgICAgICAgICB2YXIgZW5kUG9pbnQgPSAgdGhpcy5jYWxjUG9pbnRFeHByZXNzaW9uKGNvbm5lY3Rvci5lUG9zLCBlQ29ubmVjdG9yUG9pbnQpO1xyXG4gICAgICAgICAgICByZXR1cm4gW3N0YXJ0UG9pbnQsIGVuZFBvaW50LHNCb3VuZHMsIGVCb3VuZHNdO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGNhbGNQb2ludEV4cHJlc3Npb246IGZ1bmN0aW9uKHBvcywgcG9pbnQpIHtcclxuICAgICAgICAgICAgdmFyIHZhcmlhYmxlID0ge3RvcDpwb2ludC50b3AueCxcclxuICAgICAgICAgICAgICAgIGxlZnQ6IHBvaW50LmxlZnQueSxcclxuICAgICAgICAgICAgICAgIHJpZ2h0OnBvaW50LnJpZ2h0LnksXHJcbiAgICAgICAgICAgICAgICBib3R0b206cG9pbnQuYm90dG9tLngsXHJcbiAgICAgICAgICAgICAgICBjZW50ZXI6cG9pbnQuY2VudGVyLnhcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIHZhciBleHByZXNzaW9uID0gIFwiPCUgcHJpbnQoXCIgKyBwb3MgKyBcIikgJT5cIjtcclxuICAgICAgICAgICAgdmFyIHZhbCA9IHBhcnNlSW50KFV0aWwudGVtcGxhdGUoZXhwcmVzc2lvbikodmFyaWFibGUpKTtcclxuICAgICAgICAgICAgaWYgKHBvcy5pbmRleE9mKFwidG9wXCIpIT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQodmFsLCBwb2ludC50b3AueSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocG9zLmluZGV4T2YoXCJsZWZ0XCIpIT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQocG9pbnQubGVmdC54LCB2YWwpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHBvcy5pbmRleE9mKFwicmlnaHRcIikhPSAtMSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludChwb2ludC5yaWdodC54LCB2YWwpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHBvcy5pbmRleE9mKFwiYm90dG9tXCIpIT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQodmFsLCBwb2ludC5ib3R0b20ueSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocG9zLmluZGV4T2YoXCJjZW50ZXJcIikhPSAtMSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludCh2YWwsIHBvaW50LmJvdHRvbS55KTtcclxuICAgICAgICAgICAgfWVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwicG9z5Y+C5pWw6ZSZ6K+vXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICog5Yib5bu65oiW5L+u5pS55Li05pe257q/XHJcbiAgICAgICAgICogQHBhcmFtICB7W3R5cGVdfSBzdGFydE5vZGUgICAgICAgICAgICAgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICAgICAqIEBwYXJhbSAge1t0eXBlXX0gckVuZFBvaW50ICAgICAgICAgICAgIFtkZXNjcmlwdGlvbl1cclxuICAgICAgICAgKiBAcGFyYW0gIHtbdHlwZV19IGxpbmVUeXBlIFtkZXNjcmlwdGlvbl1cclxuICAgICAgICAgKiBAcmV0dXJuIHtbdHlwZV19ICAgICAgICAgICAgICAgICAgICAgICBbZGVzY3JpcHRpb25dXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgbWFuYWdlVGVtcENvbm5lY3RvcjogZnVuY3Rpb24oc3RhcnROb2RlLCByRW5kUG9pbnQsIGxpbmVUeXBlKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgc1JlY3QgPSBzdGFydE5vZGUuZ2V0UmVjdD8gc3RhcnROb2RlLmdldFJlY3QoKS5ib3VuZGluZ1JlY3QgOiBVdGlsLmdldFJlY3Qoc3RhcnROb2RlKS5ib3VuZGluZ1JlY3Q7XHJcblxyXG4gICAgICAgICAgICB2YXIgc0JvdW5kcyA9IFtzUmVjdC54LCBzUmVjdC55LCBzUmVjdC54ICsgc1JlY3Qud2lkdGgsIHNSZWN0LnkgKyBzUmVjdC5oZWlnaHRdO1xyXG4gICAgICAgICAgICB2YXIgc0Nvbm5lY3RvclBvaW50ID0gVXRpbC5nZXRDb25uZWN0b3JQb2ludHMoc1JlY3QpO1xyXG5cclxuICAgICAgICAgICAgaWYgKCFDb25uZWN0aW9uTWFuYWdlci50ZW1wQ29ubmVjdG9yKSB7XHJcbiAgICAgICAgICAgICAgICBDb25uZWN0aW9uTWFuYWdlci50ZW1wQ29ubmVjdG9yID0gbmV3IENvbm5lY3Rvcih7aXNFZGl0OiBmYWxzZSwgc3R5bGU6IHtsaW5lVHlwZTpsaW5lVHlwZX19KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIGNvbm5lY3RvciA9ICBDb25uZWN0aW9uTWFuYWdlci50ZW1wQ29ubmVjdG9yO1xyXG4gICAgICAgICAgICAvL+WIpOaWreWmguaenOayoeacieaMh+WumuS9jee9rueahOivnSwg5Yik5pat5byA5aeL6IqC54K55Zyo57uT5p2f57uT5p6c5bem6L655YiZ6YeH55SoIHJpZ2h0LWxlZnQg5ZCm5YiZ6YeH55SobGVmdC1yaWdodFxyXG4gICAgICAgICAgICBpZiAoc1JlY3QueCA8IHJFbmRQb2ludC54KSB7XHJcbiAgICAgICAgICAgICAgICBjb25uZWN0b3Iuc1BvcyA9IFwicmlnaHRcIjtcclxuICAgICAgICAgICAgICAgIGNvbm5lY3Rvci5lUG9zID0gXCJsZWZ0XCI7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb25uZWN0b3Iuc1BvcyA9IFwibGVmdFwiO1xyXG4gICAgICAgICAgICAgICAgY29ubmVjdG9yLmVQb3MgPSBcInJpZ2h0XCI7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGNvbm5lY3Rvci5vcHRpb25zLnN0eWxlLmxpbmVUeXBlID0gbGluZVR5cGU7XHJcbiAgICAgICAgICAgIHZhciBzb2x1dGlvbnMgPSB0aGlzLmNvbm5lY3RvcjJQb2ludHMobGluZVR5cGUsIHNDb25uZWN0b3JQb2ludFtjb25uZWN0b3Iuc1Bvc10sIHJFbmRQb2ludCxcclxuICAgICAgICAgICAgICAgIHNCb3VuZHMsIG51bGwpOyAgLy8gVFlQRV9TVFJBSUdIVCBUWVBFX0pBR0dFRFxyXG5cclxuICAgICAgICAgICAgY29ubmVjdG9yLnJlZnJlc2goc29sdXRpb25zWzBdWzJdKTtcclxuICAgICAgICAgICAgcmV0dXJuIGNvbm5lY3RvcjtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiDliKDpmaTkuLTml7bnur9cclxuICAgICAgICAgKiBAcGFyYW0gIHtbdHlwZV19IHpyICAgICAgICAgICAgIFtkZXNjcmlwdGlvbl1cclxuICAgICAgICAgKi9cclxuICAgICAgICByZW1vdmVUZW1wQ29ubmVjdG9yOiBmdW5jdGlvbih6cikge1xyXG4gICAgICAgICAgICBpZiAoQ29ubmVjdGlvbk1hbmFnZXIudGVtcENvbm5lY3Rvcikge1xyXG4gICAgICAgICAgICAgICAgenIucmVtb3ZlKENvbm5lY3Rpb25NYW5hZ2VyLnRlbXBDb25uZWN0b3IpO1xyXG4gICAgICAgICAgICAgICAgQ29ubmVjdGlvbk1hbmFnZXIudGVtcENvbm5lY3RvciA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG5cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICog566X5Ye6IOS4pOS4quiKgueCuSDmjIflrprkuKTkuKrngrnlpoLkvZXogZTnur9cclxuICAgICAgICAgKiBAcGFyYW0gIHtbdHlwZV19IHR5cGUgICAgICAgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICAgICAqIEBwYXJhbSAge1t0eXBlXX0gc3RhcnRQb2ludCBbZGVzY3JpcHRpb25dXHJcbiAgICAgICAgICogQHBhcmFtICB7W3R5cGVdfSBlbmRQb2ludCAgIFtkZXNjcmlwdGlvbl1cclxuICAgICAgICAgKiBAcGFyYW0gIHtbdHlwZV19IHNCb3VuZHMgICAgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICAgICAqIEBwYXJhbSAge1t0eXBlXX0gZUJvdW5kcyAgICBbZGVzY3JpcHRpb25dXHJcbiAgICAgICAgICogQHJldHVybiB7W3R5cGVdfSAgICAgICAgICAgIFtkZXNjcmlwdGlvbl1cclxuICAgICAgICAgKi9cclxuICAgICAgICBjb25uZWN0b3IyUG9pbnRzOiBmdW5jdGlvbih0eXBlLCAgc3RhcnRQb2ludCwgZW5kUG9pbnQsIHNCb3VuZHMsIGVCb3VuZHMgLGVzY2FwZURpc3RhbmNlKXtcclxuICAgICAgICAgICAgdmFyICBmaWd1cmVFc2NhcGVEaXN0YW5jZSA9IFszMCwgMzBdO1xyXG4gICAgICAgICAgICBpZiAoZXNjYXBlRGlzdGFuY2UpIHtcclxuICAgICAgICAgICAgICAgIGlmICghenJVdGlsLmlzQXJyYXkoZXNjYXBlRGlzdGFuY2UpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZmlndXJlRXNjYXBlRGlzdGFuY2UgPSBbZXNjYXBlRGlzdGFuY2UsIGVzY2FwZURpc3RhbmNlXTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZmlndXJlRXNjYXBlRGlzdGFuY2UgPSBlc2NhcGVEaXN0YW5jZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgTG9nLmdyb3VwKFwiY29ubmVjdGlvbk1hbmFnZXI6IGNvbm5lY3RvcjJQb2ludHNcIik7XHJcblxyXG5cclxuICAgICAgICAgICAgTG9nLmluZm8oXCJDb25uZWN0aW9uTWFuYWdlcjogY29ubmVjdG9yMlBvaW50cyAoXCIgKyB0eXBlICsgXCIsIFwiICsgc3RhcnRQb2ludCArIFwiLCBcIiArIGVuZFBvaW50ICsgXCIsIFwiICsgc0JvdW5kcyArIFwiLCBcIiArIGVCb3VuZHMgKyAnKScpO1xyXG4gICAgICAgICAgICB2YXIgc29sdXRpb25zID0gW107XHJcblxyXG5cclxuXHJcbiAgICAgICAgICAgIHN3aXRjaCh0eXBlKXtcclxuICAgICAgICAgICAgICAgIGNhc2UgQ29ubmVjdG9yLlRZUEVfU1RSQUlHSFQ6ICAvL+ebtOe6v1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwb2ludHMgPSBbc3RhcnRQb2ludC5jbG9uZSgpLCBlbmRQb2ludC5jbG9uZSgpXTtcclxuICAgICAgICAgICAgICAgICAgICBzb2x1dGlvbnMucHVzaCggWydzdHJhaWdodCcsICdzdHJhaWdodCcsIHBvaW50c10gKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICBjYXNlIENvbm5lY3Rvci5UWVBFX0NVUlZFOiAgLy/mm7Lnur9cclxuXHJcbiAgICAgICAgICAgICAgICBjYXNlIENvbm5lY3Rvci5UWVBFX0pBR0dFRDogICAgLy/mipjnur9cclxuICAgICAgICAgICAgICAgICAgICB2YXIgc3RhcnRFeGl0UG9pbnQgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBlbmRFeGl0UG9pbnQgPSBudWxsO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL2ZpbmQgc3RhcnQgZXhpdCBwb2ludCAg5a+75om+5byA5aeL5Ye65Y+jXHJcbiAgICAgICAgICAgICAgICAgICAgaWYoc0JvdW5kcyAhPSBudWxsKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBvdGVudGlhbEV4aXRzID0gW107XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3RlbnRpYWxFeGl0cy5wdXNoKG5ldyBQb2ludChzdGFydFBvaW50LngsIHNCb3VuZHNbMV0gLSBmaWd1cmVFc2NhcGVEaXN0YW5jZVswXSkpOyAvL25vcnRoIOWMl1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3RlbnRpYWxFeGl0cy5wdXNoKG5ldyBQb2ludChzQm91bmRzWzJdICsgZmlndXJlRXNjYXBlRGlzdGFuY2VbMF0sIHN0YXJ0UG9pbnQueSkpOyAvL2Vhc3QgIOS4nFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3RlbnRpYWxFeGl0cy5wdXNoKG5ldyBQb2ludChzdGFydFBvaW50LngsIHNCb3VuZHNbM10gKyBmaWd1cmVFc2NhcGVEaXN0YW5jZVswXSkpOyAvL3NvdXRoICDljZdcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG90ZW50aWFsRXhpdHMucHVzaChuZXcgUG9pbnQoc0JvdW5kc1swXSAtIGZpZ3VyZUVzY2FwZURpc3RhbmNlWzBdLCBzdGFydFBvaW50LnkpKTsgLy93ZXN0ICDopb9cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vcGljayBjbG9zZXN0IGV4aXQgcG9pbnQgIOWvu+aJvuS4jiBzdGFydFBvaW50IOacgOmdoOi/keeahOWHuuWPo+eCuVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydEV4aXRQb2ludCA9IHBvdGVudGlhbEV4aXRzWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IodmFyIGk9MTsgaSA8IHBvdGVudGlhbEV4aXRzLmxlbmd0aDsgaSsrKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKFV0aWwuZGlzdGFuY2Uoc3RhcnRQb2ludCwgcG90ZW50aWFsRXhpdHNbaV0pIDwgVXRpbC5kaXN0YW5jZShzdGFydFBvaW50LCBzdGFydEV4aXRQb2ludCkpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0RXhpdFBvaW50ID0gcG90ZW50aWFsRXhpdHNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL2ZpbmQgZW5kIGV4aXQgcG9pbnQgIOWvu+aJvue7k+adn+WHuuWPo1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKGVCb3VuZHMgIT0gbnVsbCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwb3RlbnRpYWxFeGl0cyA9IFtdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgcG90ZW50aWFsRXhpdHMucHVzaChuZXcgUG9pbnQoZW5kUG9pbnQueCwgZUJvdW5kc1sxXSAtIGZpZ3VyZUVzY2FwZURpc3RhbmNlWzFdKSk7IC8vbm9ydGhcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG90ZW50aWFsRXhpdHMucHVzaChuZXcgUG9pbnQoZUJvdW5kc1syXSArIGZpZ3VyZUVzY2FwZURpc3RhbmNlWzFdLCBlbmRQb2ludC55KSk7IC8vZWFzdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3RlbnRpYWxFeGl0cy5wdXNoKG5ldyBQb2ludChlbmRQb2ludC54LCBlQm91bmRzWzNdICsgZmlndXJlRXNjYXBlRGlzdGFuY2VbMV0pKTsgLy9zb3V0aFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3RlbnRpYWxFeGl0cy5wdXNoKG5ldyBQb2ludChlQm91bmRzWzBdIC0gZmlndXJlRXNjYXBlRGlzdGFuY2VbMV0sIGVuZFBvaW50LnkpKTsgLy93ZXN0XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL3BpY2sgY2xvc2VzdCBleGl0IHBvaW50ICDlr7vmib7kuI4gZW5kUG9pbnQg5pyA6Z2g6L+R55qE5Ye65Y+j54K5XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZEV4aXRQb2ludCA9IHBvdGVudGlhbEV4aXRzWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IodmFyIGk9MTsgaSA8IHBvdGVudGlhbEV4aXRzLmxlbmd0aDsgaSsrKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKFV0aWwuZGlzdGFuY2UoZW5kUG9pbnQsIHBvdGVudGlhbEV4aXRzW2ldKSA8IFV0aWwuZGlzdGFuY2UoZW5kUG9pbnQsIGVuZEV4aXRQb2ludCkpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZEV4aXRQb2ludCA9IHBvdGVudGlhbEV4aXRzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL0Jhc2ljIHNvbHV0aW9uIOacgOWfuuacrOeahOino+WGs+aWueahiCAgIOS4uuWFtuS7luino+WGs+aWueahiOWBmuWHhuWkh1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzID0gW3N0YXJ0UG9pbnRdO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBnYXBJbmRleCA9IDA7IC8vdGhlIGluZGV4IG9mIHRoZSBnYXAgKHdoZXJlIGRvIHdlIG5lZWQgdG8gaW5zZXJ0IG5ldyBwb2ludHMpIERPIE5PVCBDSEFOR0UgSVRcclxuICAgICAgICAgICAgICAgICAgICBpZihzdGFydEV4aXRQb2ludCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHMucHVzaChzdGFydEV4aXRQb2ludCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGdhcEluZGV4ID0gMTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoZW5kRXhpdFBvaW50KXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcy5wdXNoKGVuZEV4aXRQb2ludCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHMucHVzaChlbmRQb2ludCk7XHJcblxyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9TTyAtIG5vIGFkZGl0aW9uYWwgcG9pbnRzICAgICBTMCDop6PlhrPmlrnmoYgg5LiN5re75Yqg5Lu75L2V54K5ICDln7rmnKzkuI3kvJrooqvph4fnlKhcclxuICAgICAgICAgICAgICAgICAgICB2YXIgczAgPSBQb2ludC5jbG9uZUFycmF5KHMpO1xyXG4gICAgICAgICAgICAgICAgICAgIHNvbHV0aW9ucy5wdXNoKFsnczAnLCAnczAnLCBzMF0pO1xyXG5cclxuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vUzEgICBTMSDop6PlhrPmlrnmoYggIOWPquacieS4gOS4quaKmOeCuVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzMSA9IFBvaW50LmNsb25lQXJyYXkocyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vZmlyc3QgdmFyaWFudCAgIOesrOS4gOS4quWPmOS9kyBzMSBzMV8x5pa55qGIICDmipjnur/ngrnlnKggc3RhcnRFeGl0UG9pbnTnmoRYIOS4jiBlbmRFeGl0UG9pbnTnmoQgWeS9jee9rlxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzMV8xID0gUG9pbnQuY2xvbmVBcnJheShzMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgczFfMS5zcGxpY2UoZ2FwSW5kZXggKyAxLCAwLCBuZXcgUG9pbnQoczFfMVtnYXBJbmRleF0ueCAsIHMxXzFbZ2FwSW5kZXgrMV0ueSkgKTtcclxuICAgICAgICAgICAgICAgICAgICBzb2x1dGlvbnMucHVzaChbJ3MxJywgJ3MxXzEnLCBzMV8xXSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vc2Vjb25kIHZhcmlhbnQgIOesrOS6jOWPmOS9kyBzMSBzMS0y5pa55qGIICDmipjnur/ngrnlnKggZW5kRXhpdFBvaW5055qEWCDkuI4gIHN0YXJ0RXhpdFBvaW5055qEWeS9jee9rlxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzMV8yID0gUG9pbnQuY2xvbmVBcnJheShzMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgczFfMi5zcGxpY2UoZ2FwSW5kZXggKyAxLCAwLCBuZXcgUG9pbnQoczFfMltnYXBJbmRleCsxXS54ICwgczFfMltnYXBJbmRleF0ueSkgKTtcclxuICAgICAgICAgICAgICAgICAgICBzb2x1dGlvbnMucHVzaChbJ3MxJywgJ3MxXzInLCBzMV8yXSk7XHJcblxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL1MyICBTMiDop6PlhrPmlrnmoYggIOa3u+WKoOS4pOS4quaKmOeCuVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL1ZhcmlhbnQgSSAgIHMyXzHmlrnmoYhcclxuICAgICAgICAgICAgICAgICAgICB2YXIgczJfMSA9IFBvaW50LmNsb25lQXJyYXkocyk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHMyXzFfMSA9IG5ldyBQb2ludCggKHMyXzFbZ2FwSW5kZXhdLnggKyBzMl8xW2dhcEluZGV4KzFdLngpIC8gMiwgIHMyXzFbZ2FwSW5kZXhdLnkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzMl8xXzIgPSBuZXcgUG9pbnQoIChzMl8xW2dhcEluZGV4XS54ICsgczJfMVtnYXBJbmRleCsxXS54KSAvIDIsICBzMl8xW2dhcEluZGV4KzFdLnkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHMyXzEuc3BsaWNlKGdhcEluZGV4ICsgMSwgMCwgczJfMV8xLCBzMl8xXzIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHNvbHV0aW9ucy5wdXNoKFsnczInLCAnczJfMScsIHMyXzFdKTtcclxuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vVmFyaWFudCBJSSAgczJfMeaWueahiCAgMeaKmOe6v+eCuSB4OiBzdGFydEV4aXRQb2ludOeahFgg5L2N572uIHk6IHN0YXJ0RXhpdFBvaW5055qEeStlbmRFeGl0UG9pbnTnmoR5LzJcclxuICAgICAgICAgICAgICAgICAgICAvLzHmipjnur/ngrkgeDplbmRFeGl0UG9pbnTnmoR4ICB5OnN0YXJ0RXhpdFBvaW5055qEeStlbmRFeGl0UG9pbnTnmoR5LzJcclxuICAgICAgICAgICAgICAgICAgICB2YXIgczJfMiA9IFBvaW50LmNsb25lQXJyYXkocyk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHMyXzJfMSA9IG5ldyBQb2ludCggczJfMltnYXBJbmRleF0ueCwgKHMyXzJbZ2FwSW5kZXhdLnkgKyBzMl8yW2dhcEluZGV4KzFdLnkpLzIgKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgczJfMl8yID0gbmV3IFBvaW50KCBzMl8yW2dhcEluZGV4KzFdLngsIChzMl8yW2dhcEluZGV4XS55ICsgczJfMltnYXBJbmRleCsxXS55KS8yKTtcclxuICAgICAgICAgICAgICAgICAgICBzMl8yLnNwbGljZShnYXBJbmRleCArIDEsIDAsIHMyXzJfMSwgczJfMl8yKTtcclxuICAgICAgICAgICAgICAgICAgICBzb2x1dGlvbnMucHVzaChbJ3MyJywgJ3MyXzInLCBzMl8yXSk7XHJcblxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL1ZhcmlhbnQgSUlJXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHMyXzMgPSBQb2ludC5jbG9uZUFycmF5KHMpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vZmluZCB0aGUgYW1vdW50IChzdG9yZWQgaW4gZGVsdGEpIG9mIHBpeGVscyB3ZSBuZWVkIHRvIG1vdmUgcmlnaHQgc28gbm8gaW50ZXJzZWN0aW9uIHdpdGggYSBmaWd1cmUgd2lsbCBiZSBwcmVzZW50XHJcbiAgICAgICAgICAgICAgICAgICAgLy8hU2VlOiAgL2RvY3VtZW50cy9zcGVjcy9jb25uZWN0ZWRfZmlndXJlc19kZWx0YXMuanBnIGZpbGVcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVhc3RFeGl0cyA9IFtzMl8zW2dhcEluZGV4XS54ICsgMjAsIHMyXzNbZ2FwSW5kZXgrMV0ueCArIDIwXTsgLy9hZGQgcG9pbnRzIFggY29vcmRpbmF0ZXMgdG8gYmUgYWJsZSB0byBnZW5lcmF0ZSBWYXJpYW50IElJSSBldmVuIGluIHRoZSBhYnNlbmNlIG9mIGZpZ3VyZXMgOnBcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYoc0JvdW5kcyl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVhc3RFeGl0cy5wdXNoKHNCb3VuZHNbMl0gKyAyMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZihlQm91bmRzKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWFzdEV4aXRzLnB1c2goZUJvdW5kc1syXSArIDIwKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBlYXN0RXhpdCA9IFV0aWwubWF4KGVhc3RFeGl0cyk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHMyXzNfMSA9IG5ldyBQb2ludCggZWFzdEV4aXQsIHMyXzNbZ2FwSW5kZXhdLnkgKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgczJfM18yID0gbmV3IFBvaW50KCBlYXN0RXhpdCwgczJfM1tnYXBJbmRleCsxXS55ICk7XHJcbiAgICAgICAgICAgICAgICAgICAgczJfMy5zcGxpY2UoZ2FwSW5kZXggKyAxLCAwLCBzMl8zXzEsIHMyXzNfMik7XHJcbiAgICAgICAgICAgICAgICAgICAgc29sdXRpb25zLnB1c2goWydzMicsICdzMl8zJywgczJfM10pO1xyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9WYXJpYW50IElWICBzMl805pa55qGIXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHMyXzQgPSBQb2ludC5jbG9uZUFycmF5KHMpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vZmluZCB0aGUgYW1vdW50IChzdG9yZWQgaW4gZGVsdGEpIG9mIHBpeGVscyB3ZSBuZWVkIHRvIG1vdmUgdXAgc28gbm8gaW50ZXJzZWN0aW9uIHdpdGggYSBmaWd1cmUgd2lsbCBiZSBwcmVzZW50XHJcbiAgICAgICAgICAgICAgICAgICAgLy8hU2VlOiAgL2RvY3VtZW50cy9zcGVjcy9jb25uZWN0ZWRfZmlndXJlc19kZWx0YXMuanBnIGZpbGVcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5vcnRoRXhpdHMgPSBbczJfNFtnYXBJbmRleF0ueSAtIDIwLCBzMl80W2dhcEluZGV4KzFdLnkgLSAyMF07IC8vYWRkIHBvaW50cyB5IGNvb3JkaW5hdGVzIHRvIGJlIGFibGUgdG8gZ2VuZXJhdGUgVmFyaWFudCBJSUkgZXZlbiBpbiB0aGUgYWJzZW5jZSBvZiBmaWd1cmVzIDpwXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmKHNCb3VuZHMpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBub3J0aEV4aXRzLnB1c2goc0JvdW5kc1sxXSAtIDIwKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmKGVCb3VuZHMpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBub3J0aEV4aXRzLnB1c2goZUJvdW5kc1sxXSAtIDIwKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBub3J0aEV4aXQgPSBVdGlsLm1pbihub3J0aEV4aXRzKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgczJfNF8xID0gbmV3IFBvaW50KCBzMl80W2dhcEluZGV4XS54LCBub3J0aEV4aXQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzMl80XzIgPSBuZXcgUG9pbnQoIHMyXzRbZ2FwSW5kZXgrMV0ueCwgbm9ydGhFeGl0KTtcclxuICAgICAgICAgICAgICAgICAgICBzMl80LnNwbGljZShnYXBJbmRleCArIDEsIDAsIHMyXzRfMSwgczJfNF8yKTtcclxuICAgICAgICAgICAgICAgICAgICBzb2x1dGlvbnMucHVzaChbJ3MyJywgJ3MyXzQnLCBzMl80XSk7XHJcblxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL1ZhcmlhbnQgVlxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzMl81ID0gUG9pbnQuY2xvbmVBcnJheShzKTtcclxuICAgICAgICAgICAgICAgICAgICAvL2ZpbmQgdGhlIGFtb3VudCAoc3RvcmVkIGluIGRlbHRhKSBvZiBwaXhlbHMgd2UgbmVlZCB0byBtb3ZlIGxlZnQgc28gbm8gaW50ZXJzZWN0aW9uIHdpdGggYSBmaWd1cmUgd2lsbCBiZSBwcmVzZW50XHJcbiAgICAgICAgICAgICAgICAgICAgLy8hU2VlOiAgL2RvY3VtZW50cy9zcGVjcy9jb25uZWN0ZWRfZmlndXJlc19kZWx0YXMuanBnIGZpbGVcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHdlc3RFeGl0cyA9IFtzMl81W2dhcEluZGV4XS54IC0gMjAsIHMyXzVbZ2FwSW5kZXgrMV0ueCAtIDIwXTsgLy9hZGQgcG9pbnRzIHggY29vcmRpbmF0ZXMgdG8gYmUgYWJsZSB0byBnZW5lcmF0ZSBWYXJpYW50IElJSSBldmVuIGluIHRoZSBhYnNlbmNlIG9mIGZpZ3VyZXMgOnBcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYoc0JvdW5kcyl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdlc3RFeGl0cy5wdXNoKHNCb3VuZHNbMF0gLSAyMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZihlQm91bmRzKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2VzdEV4aXRzLnB1c2goZUJvdW5kc1swXSAtIDIwKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciB3ZXN0RXhpdCA9IFV0aWwubWluKHdlc3RFeGl0cyk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHMyXzVfMSA9IG5ldyBQb2ludCggd2VzdEV4aXQsIHMyXzVbZ2FwSW5kZXhdLnkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzMl81XzIgPSBuZXcgUG9pbnQoIHdlc3RFeGl0LCBzMl81W2dhcEluZGV4KzFdLnkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHMyXzUuc3BsaWNlKGdhcEluZGV4ICsgMSwgMCwgczJfNV8xLCBzMl81XzIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHNvbHV0aW9ucy5wdXNoKFsnczInLCAnczJfNScsIHMyXzVdKTtcclxuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vVmFyaWFudCBWSVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzMl82ID0gUG9pbnQuY2xvbmVBcnJheShzKTtcclxuICAgICAgICAgICAgICAgICAgICAvL2ZpbmQgdGhlIGFtb3VudCAoc3RvcmVkIGluIGRlbHRhKSBvZiBwaXhlbHMgd2UgbmVlZCB0byBtb3ZlIGRvd24gc28gbm8gaW50ZXJzZWN0aW9uIHdpdGggYSBmaWd1cmUgd2lsbCBiZSBwcmVzZW50XHJcbiAgICAgICAgICAgICAgICAgICAgLy8hU2VlOiAgL2RvY3VtZW50cy9zcGVjcy9jb25uZWN0ZWRfZmlndXJlc19kZWx0YXMuanBnIGZpbGVcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNvdXRoRXhpdHMgPSBbczJfNltnYXBJbmRleF0ueSArIDIwLCBzMl82W2dhcEluZGV4KzFdLnkgKyAyMF07IC8vYWRkIHBvaW50cyB5IGNvb3JkaW5hdGVzIHRvIGJlIGFibGUgdG8gZ2VuZXJhdGUgVmFyaWFudCBJSUkgZXZlbiBpbiB0aGUgYWJzZW5jZSBvZiBmaWd1cmVzIDpwXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmKHNCb3VuZHMpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzb3V0aEV4aXRzLnB1c2goc0JvdW5kc1szXSArIDIwKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmKGVCb3VuZHMpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzb3V0aEV4aXRzLnB1c2goZUJvdW5kc1szXSArIDIwKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzb3V0aEV4aXQgPSBVdGlsLm1heChzb3V0aEV4aXRzKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgczJfNl8xID0gbmV3IFBvaW50KCBzMl82W2dhcEluZGV4XS54LCBzb3V0aEV4aXQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzMl82XzIgPSBuZXcgUG9pbnQoIHMyXzZbZ2FwSW5kZXgrMV0ueCwgc291dGhFeGl0KTtcclxuICAgICAgICAgICAgICAgICAgICBzMl82LnNwbGljZShnYXBJbmRleCArIDEsIDAsIHMyXzZfMSwgczJfNl8yKTtcclxuICAgICAgICAgICAgICAgICAgICBzb2x1dGlvbnMucHVzaChbJ3MyJywgJ3MyXzYnLCBzMl82XSk7XHJcblxyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9GSUxURVIgc29sdXRpb25zXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8qQWxnb3JpdGhtXHJcbiAgICAgICAgICAgICAgICAgICAgICogMC4gc29sdXRpb25zIGFyZSBvcmRlcmVkIGZyb20gbWluaW1tdW4gbnIgb2YgcG9pbnRzIHRvIG1heGltdW0gPjopXHJcbiAgICAgICAgICAgICAgICAgICAgICogMS4gcmVtb3ZlIGFsbCBzb2x1dGlvbnMgdGhhdCBhcmUgbm90IG9ydGhvZ29uYWwgKG1haW5seSBzMCBzb2x1dGlvbilcclxuICAgICAgICAgICAgICAgICAgICAgKiAyLiByZW1vdmUgYWxsIHNvbHV0aW9ucyB0aGF0IGdvIGJhY2t3YXJkICh3ZSB3aWxsIG5vdCBuZWVkIHRoZW0gZXZlcilcclxuICAgICAgICAgICAgICAgICAgICAgKiAzLiByZW1vdmUgYWxsIHNvbHV0aW9ucyB3aXRoIGludGVyc2VjdGlvbnNcclxuICAgICAgICAgICAgICAgICAgICAgKiA0LiBwaWNrIGZpcnN0IGNsYXNzIG9mIHNvbHV0aW9ucyB3aXRoIHNhbWUgbnIgb2YgcG9pbnRzIChleDogMilcclxuICAgICAgICAgICAgICAgICAgICAgKiA1LiBwaWNrIHRoZSBmaXJzdCBzb2x1dGlvbiB3aXRoIDkwIGRlZ3JlZSBhbmdsZXMgKGxlc3MgdHVybmFyb3VuZHMpXHJcbiAgICAgICAgICAgICAgICAgICAgICogKG5vdCBpbnRlcmVzdGV0ZWQpIHNvcnQgYnkgbGVuZ3RoIDpwXHJcbiAgICAgICAgICAgICAgICAgICAgICovXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vMS4gZmlsdGVyIG5vbiBvcnRvZ29uYWwgc29sdXRpb25zIOWIoOmZpOS4jeaYr+ato+S6pOebtOe6v+eahOaWueahiFxyXG4gICAgICAgICAgICAgICAgICAgIGlmKHRydWUpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBMb2cuaW5mbyhcIkZpbHRlciBvcnRob2dvbmFsIHNvbHV0aW9ucy4gSW5pdGlhbCBudW1iZXIgb2Ygc29sdXRpb25zID0gXCIgKyBzb2x1dGlvbnMubGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9ydGhvZ29uYWxTb2x1dGlvbiA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IodmFyIGw9MDsgbDxzb2x1dGlvbnMubGVuZ3RoOyBsKyspe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNvbHV0aW9uID0gc29sdXRpb25zW2xdWzJdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoVXRpbC5vcnRob2dvbmFsUGF0aChzb2x1dGlvbikpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9ydGhvZ29uYWxTb2x1dGlvbi5wdXNoKHNvbHV0aW9uc1tsXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgc29sdXRpb25zID0gb3J0aG9nb25hbFNvbHV0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBMb2cuaW5mbyhcIlxcblxcdE9ydGhvZ29uYWxTb2x1dGlvbnMgPSBcIiArIHNvbHV0aW9ucy5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8yLiBmaWx0ZXIgYmFja3dhcmQgc29sdXRpb25zICDov4fmu6Qg5YCS6YCA55qE5pa55qGIXHJcbiAgICAgICAgICAgICAgICAgICAgaWYodHJ1ZSl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vZG8gbm90IGFsbG93IHN0YXJ0IGFuZCBlbmQgcG9pbnRzIHRvIGNvaW5jaWRlIC0gaWdub3JlIHRoZW1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoc3RhcnRQb2ludC5lcXVhbHMoZW5kUG9pbnQpKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIExvZy5pbmZvKFwiU3RhcnQgYW5kIGVuZCBwb2ludCBjb2luY2lkZS4uLnNraXAgYmFja3dhcmQgc29sdXRpb24uIEkgdGhpbmsgd2Ugd2lsbCBqdXN0IGZhbGwgb24gczAgOilcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIExvZy5pbmZvKFwiRmlsdGVyIGJhY2t3YXJkIHNvbHV0aW9ucy4gSW5pdGlhbCBudW1iZXIgb2Ygc29sdXRpb25zID0gXCIgKyBzb2x1dGlvbnMubGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmb3J3YXJkU29sdXRpb25zID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGVtcCA9ICcnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yKHZhciBsPTA7IGw8c29sdXRpb25zLmxlbmd0aDsgbCsrKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc29sdXRpb24gPSBzb2x1dGlvbnNbbF1bMl07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoVXRpbC5mb3J3YXJkUGF0aChzb2x1dGlvbikpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3J3YXJkU29sdXRpb25zLnB1c2goc29sdXRpb25zW2xdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVtcCA9IHRlbXAgKyAgXCJcXG5cXHRcIiArIHNvbHV0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvbHV0aW9ucyA9IGZvcndhcmRTb2x1dGlvbnM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBMb2cuaW5mbyhcIlxcblxcdCBGb3J3YXJkU29sdXRpb25zID0gXCIgKyBzb2x1dGlvbnMubGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHNvbHV0aW9ucy5sZW5ndGggPT0gMCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTG9nLmluZm8oXCJEaXNjYXJkZWQgc29sdXRpb25zOiBcIiArIHRlbXApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8zLiBGaWx0ZXIgbm9uIGludGVyc2VjdGluZyBzb2x1dGlvbnMgIOWOu+mZpOayoeacieS6pOmbhigp55qE5pa55qGIXHJcbiAgICAgICAgICAgICAgICAgICAgaWYodHJ1ZSl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIExvZy5pbmZvKFwiRmlsdGVyIG5vbiBpbnRlcnNlY3Rpbmcgc29sdXRpb25zLiBJbml0aWFsIG51bWJlciBvZiBzb2x1dGlvbnMgPSBcIiArIHNvbHV0aW9ucy5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbm9uSW50ZXJzZWN0aW9uU29sdXRpb25zID0gW11cclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yKHZhciBsPTA7IGw8c29sdXRpb25zLmxlbmd0aDsgbCsrKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzb2x1dGlvbiA9IHNvbHV0aW9uc1tsXVsyXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vTG9nLmluZm8oXCJTb2x1dGlvbiBpZD0gXCIgKyBzb2x1dGlvbnNbbF1bMV0gKyAnIG5yIHBvaW50cyA9ICcgKyBzb2x1dGlvbi5sZW5ndGggKyBcIiwgcG9pbnRzID0gXCIgKyBzb2x1dGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW50ZXJzZWN0ID0gZmFsc2U7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlubmVyTGluZXMgPSBzb2x1dGlvbi5zbGljZSgpOyAvL2p1c3QgYSBzaGFsbG93IGNvcHlcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKklmIGFueSBib3VuZHMganVzdCB0cmltIHRoZSBzb2x1dGlvbi4gU28gd2UgYXZvaWQgdGhlIHN0cmFuZ2UgY2FzZSB3aGVuIGEgY29ubmVjdGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICpzdGFydGVzIGZyb20gYSBwb2ludCBvbiBhIGZpZ3VyZSBhbmQgZW5kcyBpbnNpZGUgb2YgdGhlIHNhbWUgZmlndXJlLCBidXQgbm90IG9uIGEgY29ubmVjdGlvbiBwb2ludCovXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihlQm91bmRzIHx8IHNCb3VuZHMpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vaTBubmVyTGluZXMgPSBpbm5lckxpbmVzLnNsaWNlKDAsIGlubmVyTGluZXMubGVuZ3RoIC0gMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5uZXJMaW5lcyA9IGlubmVyTGluZXMuc2xpY2UoMSwgaW5uZXJMaW5lcy5sZW5ndGggLSAxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL0xvZy5pbmZvKFwiXFx0IGVCb3VuZHMgcHJlc2VudCxpbm5lckxpbmVzIG5yLiBwb2ludHMgPSBcIiArIGlubmVyTGluZXMubGVuZ3RoICsgXCIsIHBvaW50cyA9IFwiICsgaW5uZXJMaW5lcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL25vdyB0ZXN0IGZvciBpbnRlcnNlY3Rpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHNCb3VuZHMpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludGVyc2VjdCA9IGludGVyc2VjdCB8fCBVdGlsLnBvbHlsaW5lSW50ZXJzZWN0c1JlY3RhbmdsZShpbm5lckxpbmVzLCBzQm91bmRzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGVCb3VuZHMpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludGVyc2VjdCA9IGludGVyc2VjdCB8fCBVdGlsLnBvbHlsaW5lSW50ZXJzZWN0c1JlY3RhbmdsZShpbm5lckxpbmVzLCBlQm91bmRzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZighaW50ZXJzZWN0KXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub25JbnRlcnNlY3Rpb25Tb2x1dGlvbnMucHVzaChzb2x1dGlvbnNbbF0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL0lmIGFsbCBzb2x1dGlvbnMgaW50ZXJzZWN0IHRoYW4gdGhpcyBpcyBkZXN0aW55ICA6KSBhbmQganVzdCBpZ25vcmUgdGhlIGludGVyc2VjdGlvbiBmaWx0ZXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYobm9uSW50ZXJzZWN0aW9uU29sdXRpb25zLmxlbmd0aCAhPSAwKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vcmVhc2lnbiB0byBzb2x1dGlvbnNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvbHV0aW9ucyA9IG5vbkludGVyc2VjdGlvblNvbHV0aW9ucztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgTG9nLmluZm8oXCJcXG5cXHQgbm9uSW50ZXJzZWN0aW9uU29sdXRpb25zID0gXCIgKyBzb2x1dGlvbnMubGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLzQuIGdldCBmaXJzdCBjbGFzcyBvZiBzb2x1dGlvbnMgd2l0aCBzYW1lIG5yIG9mIHBvaW50cyDpgInmi6nkuI7nrKzkuIDkuKrmlrnmoYjngrnmlbDkuIDmoLflpJrnmoTmlrnmoYjvvIjlm6DkuLrnrKzkuIDkuKrmlrnmoYjngrnmlbDmnIDlsJHvvIlcclxuICAgICAgICAgICAgICAgICAgICBpZih0cnVlKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgTG9nLmluZm8oXCJHZXQgZmlyc3QgY2xhc3Mgb2Ygc29sdXRpb25zIHdpdGggc2FtZSBuciBvZiBwb2ludHNcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHNvbHV0aW9ucy5sZW5ndGggPT0gMCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBMb2cuaW5mbyhcIlRoaXMgaXMgbm90IHBvc3NpYmxlXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZmlyc3RTb2x1dGlvbiA9IHNvbHV0aW9uc1swXVsyXTsgLy9waWNrIGZpcnN0IHNvbHV0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuck9mUG9pbnRzID0gZmlyc3RTb2x1dGlvbi5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzYW1lTnJQb2ludHNTb2x1dGlvbiA9IFtdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yKHZhciBsPTA7IGw8c29sdXRpb25zLmxlbmd0aDsgbCsrKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzb2x1dGlvbiA9IHNvbHV0aW9uc1tsXVsyXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHNvbHV0aW9uLmxlbmd0aCA9PSBuck9mUG9pbnRzKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzYW1lTnJQb2ludHNTb2x1dGlvbi5wdXNoKHNvbHV0aW9uc1tsXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvbHV0aW9ucyA9IHNhbWVOclBvaW50c1NvbHV0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblxyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLyo1LiAg6K6h566X6Lev5b6E5YiG5pWwIO+8jOWPluacgOWIhuaVsOmrmOeahFxyXG4gICAgICAgICAgICAgICAgICAgICBQaWNrIHRoZSBmaXJzdCBzb2x1dGlvbiB3aXRoIDkwIGRlZ3JlZSBhbmdsZXMgKGxlc3MgdHVybmFyb3VuZHMpXHJcbiAgICAgICAgICAgICAgICAgICAgICppbiBjYXNlIHdlIGhhdmUgbW9yZSB0aGFuIG9uZSBzb2x1dGlvbiBpbiBvdXIgY2xhc3NcclxuICAgICAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgICAgICBpZih0cnVlKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgTG9nLmluZm8oXCJwaWNrIHRoZSBmaXJzdCBzb2x1dGlvbiB3aXRoIDkwIGRlZ3JlZSBhbmdsZXMgKGxlc3MgdHVybmFyb3VuZHMpXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc29sSW5kZXggPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IodmFyIGw9MDsgbDxzb2x1dGlvbnMubGVuZ3RoOyBsKyspe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNvbHV0aW9uID0gc29sdXRpb25zW2xdWzJdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoVXRpbC5zY29yZVBhdGgoIHNvbHV0aW9uc1tzb2xJbmRleF1bMl0gKSA8IFV0aWwuc2NvcmVQYXRoKCBzb2x1dGlvbnNbbF1bMl0gKSApe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvbEluZGV4ID0gbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzb2x1dGlvbnMgPSBbc29sdXRpb25zW3NvbEluZGV4XV07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vU01PT1RISU5HIGN1cnZlXHJcbiAgICAgICAgICAgIGlmKHR5cGUgPT09IENvbm5lY3Rvci5UWVBFX0NVUlZFKXtcclxuICAgICAgICAgICAgICAgIHRoaXMuc21vb3RoQ3VydmUoc29sdXRpb25zKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvL0VORCBTTU9PVEhJTkcgY3VydmVcclxuXHJcbiAgICAgICAgICAgIExvZy5ncm91cEVuZCgpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHNvbHV0aW9ucztcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzbW9vdGhDdXJ2ZTogZnVuY3Rpb24oc29sdXRpb25zKXtcclxuICAgICAgICAgICAgdmFyIG9wdGlvbiA9IDM7XHJcblxyXG4gICAgICAgICAgICBzd2l0Y2gob3B0aW9uKXtcclxuICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICAvL2RvIG5vdGhpbmdcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICBjYXNlIDE6IC8vYWRkIGludGVybWVkaWF0ZSBwb2ludHNcclxuICAgICAgICAgICAgICAgICAgICAvL0FkZCB0aGUgbWlkZGxlIHBvaW50IGZvciBzdGFydCBhbmQgZW5kIHNlZ21lbnQgc28gdGhhdCB3ZSBcImZvcmNlXCIgdGhlXHJcbiAgICAgICAgICAgICAgICAgICAgLy9jdXJ2ZSB0byBib3RoIGNvbWUgXCJwZXJwZW5kaWN1bGFyXCIgb24gYm91bmRzIGFuZCBhbHNvIG1ha2UgdGhlIGN1cnZlXHJcbiAgICAgICAgICAgICAgICAgICAgLy9cImZsZWVcIiBtb3JlIGZyb20gYm91bmRzIChvbiBleGl0KVxyXG4gICAgICAgICAgICAgICAgICAgIGZvcih2YXIgcz0wOyBzPHNvbHV0aW9ucy5sZW5ndGg7IHMrKyl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzb2xUdXJuaW5nUG9pbnRzID0gc29sdXRpb25zW3NdWzJdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9maXJzdCBzZWdtZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhMSA9IHNvbFR1cm5pbmdQb2ludHNbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhMiA9IHNvbFR1cm5pbmdQb2ludHNbMV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdGFydE1pZGRsZVBvaW50ID0gVXRpbC5nZXRNaWRkbGUoYTEsIGEyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc29sVHVybmluZ1BvaW50cy5zcGxpY2UoMSwwLCBzdGFydE1pZGRsZVBvaW50KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vbGFzdCBzZWdtZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhMyA9IHNvbFR1cm5pbmdQb2ludHNbc29sVHVybmluZ1BvaW50cy5sZW5ndGggLSAyXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGE0ID0gc29sVHVybmluZ1BvaW50c1tzb2xUdXJuaW5nUG9pbnRzLmxlbmd0aCAtIDFdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZW5kTWlkZGxlUG9pbnQgPSBVdGlsLmdldE1pZGRsZShhMywgYTQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzb2xUdXJuaW5nUG9pbnRzLnNwbGljZShzb2xUdXJuaW5nUG9pbnRzLmxlbmd0aCAtIDEsIDAsIGVuZE1pZGRsZVBvaW50KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgY2FzZSAyOiAvL3JlbW92ZSBwb2ludHNcclxuICAgICAgICAgICAgICAgICAgICBmb3IodmFyIHM9MDsgczxzb2x1dGlvbnMubGVuZ3RoOyBzKyspe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc29sVHlwZT0gc29sdXRpb25zW3NdWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihzb2xUeXBlID09ICdzMScgfHwgc29sVHlwZSA9PSAnczInKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzb2xUdXJuaW5nUG9pbnRzID0gc29sdXRpb25zW3NdWzJdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc29sVHVybmluZ1BvaW50cy5zcGxpY2UoMSwxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvbFR1cm5pbmdQb2ludHMuc3BsaWNlKHNvbFR1cm5pbmdQb2ludHMubGVuZ3RoIC0gMiwgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgY2FzZSAzOlxyXG4gICAgICAgICAgICAgICAgICAgIC8qcmVtb3ZlIGNvbGluZWFyIHBvaW50IGZvciBzMSBhcyBpdCBzZWVtcyB0aGF0IG1vcmUgY29saW5lYXIgcG9pbnRzIGRvIG5vdCBsb29rIGdvb2RcclxuICAgICAgICAgICAgICAgICAgICAgKiBvbiBvcmdhbmljIHNvbHV0aW9ucyA+OkQqL1xyXG4gICAgICAgICAgICAgICAgICAgIGZvcih2YXIgcz0wOyBzPHNvbHV0aW9ucy5sZW5ndGg7IHMrKyl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzb2xUeXBlPSBzb2x1dGlvbnNbc11bMF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHNvbFR5cGUgPT0gJ3MxJyl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc29sVHVybmluZ1BvaW50cyA9IHNvbHV0aW9uc1tzXVsyXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZWR1Y2VkU29sdXRpb24gPSBVdGlsLmNvbGxpbmVhclJlZHVjdGlvbihzb2xUdXJuaW5nUG9pbnRzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvbHV0aW9uc1tzXVsyXSA9IHJlZHVjZWRTb2x1dGlvbjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfS8vZW5kIHN3aXRjaFxyXG5cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBDb25uZWN0aW9uTWFuYWdlcjtcclxuXHJcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9saWIvZmlzaC10b3BvLWNvcmUvbGliL21hbmFnZXIvQ29ubmVjdGlvbk1hbmFnZXIuanNcbiAqKiBtb2R1bGUgaWQgPSAxMDVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxyXG4gKiDml6Xlv5fnsbtcclxuICogQGF1dGhvciB3YW5nLnhpYW9odVxyXG4gKi9cclxuXHJcblxyXG4gICAgdmFyIExvZyAgPSB7XHJcbiAgICAgICAgTE9HX0xFVkVMX05PTkUgIDogMCxcclxuXHJcbiAgICAgICAgTE9HX0xFVkVMX0RFQlVHIDogMSxcclxuXHJcbiAgICAgICAgTE9HX0xFVkVMX0lORk8gOiAyLFxyXG5cclxuICAgICAgICBMT0dfTEVWRUxfRVJST1IgOiAzLFxyXG5cclxuICAgICAgICBsZXZlbCA6IHRoaXMuTE9HX0xFVkVMX0VSUk9SLFxyXG4gICAgICAgIFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICogVGhlIGxlc3MgaW1wb3J0YW50IG9mIGFsbCBtZXNzYWdlc1xyXG4gICAgICAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgLSB0aGUgbWVzc2FnZSB0byBiZSBsb2dnZWRcclxuICAgICAgICAqKi9cclxuICAgICAgICBkZWJ1ZzogZnVuY3Rpb24gKG1lc3NhZ2Upe1xyXG4gICAgICAgICAgICBpZih0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpe1xyXG4gICAgICAgICAgICAgICAgaWYodGhpcy5sZXZlbCA8PSB0aGlzLkxPR19MRVZFTF9ERUJVRyl7XHJcbiAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgLy9pbiBGRiBpcyBkZWJ1Z1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKHR5cGVvZiBjb25zb2xlLmRlYnVnID09ICdmdW5jdGlvbicpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmRlYnVnKG1lc3NhZ2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNley8vVE9ETzogaW4gSUUgaXMgbG9nXHJcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgY29uc29sZS5pbmZvKG1lc3NhZ2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAqIFRoZSBjb21tb25seSB1c2VkIGxvZyBtZXNzYWdlXHJcbiAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSAtIHRoZSBtZXNzYWdlIHRvIGJlIGxvZ2dlZFxyXG4gICAgICAgICoqL1xyXG4gICAgICAgIGluZm8gOiBmdW5jdGlvbiAobWVzc2FnZSl7XHJcbiAgICAgICAgICAgIGlmKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyl7XHJcbiAgICAgICAgICAgICAgICBpZih0aGlzLmxldmVsIDw9IHRoaXMuTE9HX0xFVkVMX0lORk8pe1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhtZXNzYWdlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICogVGhlIHdvcnNlIGtpbmQgb2YgbWVzc2FnZS4gVXN1YWxseSBhIGNyYXNoXHJcbiAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSAtIHRoZSBtZXNzYWdlIHRvIGJlIGxvZ2dlZFxyXG4gICAgICAgICoqL1xyXG4gICAgICAgIGVycm9yIDogZnVuY3Rpb24gKG1lc3NhZ2Upe1xyXG4gICAgICAgICAgICBpZih0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpe1xyXG4gICAgICAgICAgICAgICAgaWYodGhpcy5sZXZlbCA8PSB0aGlzLkxPR19MRVZFTF9FUlJPUil7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqU3RhcnQgZ3JvdXBpbmcgdGhlIGxvZyBtZXNzYWdlc1xyXG4gICAgICAgICAqQHBhcmFtIHtTdHJpbmd9IHRpdGxlIC0gdGhlIHRpdGxlIG9mIHRoZSBncm91cFxyXG4gICAgICAgICAqQHNlZSA8YSBocmVmPVwiaHR0cDovL2dldGZpcmVidWcuY29tL2xvZ2dpbmdcIj5odHRwOi8vZ2V0ZmlyZWJ1Zy5jb20vbG9nZ2luZzwvYT5cclxuICAgICAgICAgKiovXHJcbiAgICAgICAgZ3JvdXAgOiBmdW5jdGlvbih0aXRsZSl7XHJcbiAgICAgICAgICAgIGlmKHRoaXMubGV2ZWwgPD0gdGhpcy5MT0dfTEVWRUxfSU5GTyl7IC8vaWdub3JlIGdyb3VwIGlmIGxldmVsIG5vdCBkZWJ1ZyBvciBpbmZvXHJcbiAgICAgICAgICAgICAgICBpZih0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpeyAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgLyoqSWYgd2UgZG8gbm90IHRlc3QgZm9yIGdyb3VwKCkgZnVuY3Rpb24geW91IHdpbGwgZ2V0IGFuIGVycm9yIGluIE9wZXJhXHJcbiAgICAgICAgICAgICAgICAgICAgICphcyBPcGVyYSBoYXMgaXQncyBvd24gY29uc29sZS4uLndoaWNoIGRvZXMgbm90IGhhdmUgYSBncm91cCgpIGZ1bmN0aW9uKi9cclxuICAgICAgICAgICAgICAgICAgICBpZih0eXBlb2YgY29uc29sZS5ncm91cCA9PT0gJ2Z1bmN0aW9uJyl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZ3JvdXAodGl0bGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKkVuZHMgY3VycmVudCBtZXNzYWdlIGdyb3VwaW5nKi9cclxuICAgICAgICBncm91cEVuZCA6IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgICAgIGlmKHRoaXMubGV2ZWwgPD0gdGhpcy5MT0dfTEVWRUxfSU5GTyl7IC8vaWdub3JlIGdyb3VwIGlmIGxldmVsIG5vdCBkZWJ1ZyBvciBpbmZvXHJcbiAgICAgICAgICAgICAgICBpZih0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpe1xyXG4gICAgICAgICAgICAgICAgICAgIC8qKklmIHdlIGRvIG5vdCB0ZXN0IGZvciBncm91cEVuZCgpIGZ1bmN0aW9uIHlvdSB3aWxsIGdldCBhbiBlcnJvciBpbiBPcGVyYVxyXG4gICAgICAgICAgICAgICAgICAgICAqYXMgT3BlcmEgaGFzIGl0J3Mgb3duIGNvbnNvbGUuLi53aGljaCBkb2VzIG5vdCBoYXZlIGEgZ3JvdXAoKSBmdW5jdGlvbiovXHJcbiAgICAgICAgICAgICAgICAgICAgaWYodHlwZW9mIGNvbnNvbGUuZ3JvdXBFbmQgPT09ICdmdW5jdGlvbicpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmdyb3VwRW5kKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH07XHJcblxyXG4gICAgLy9Mb2cubGV2ZWwgPSBMb2cuTE9HX0xFVkVMX0RFQlVHOyBcclxuICAgIExvZy5sZXZlbCA9IExvZy5MT0dfTEVWRUxfRVJST1I7IFxyXG4gICAgLy9Mb2cubGV2ZWwgPSBMb2cuTE9HX0xFVkVMX0VSUk9SO1xyXG4gICAgLy9Mb2cubGV2ZWwgPSBMb2cuTE9HX0xFVkVMX05PTkU7XHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IExvZztcclxuICAgIFxyXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vbGliL2Zpc2gtdG9wby1jb3JlL2xpYi9Mb2cuanNcbiAqKiBtb2R1bGUgaWQgPSAxMDZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxyXG4gKiDov57nur/mk43kvZznsbtcclxuICogQGF1dGhvciBtaWFvLmN1bnpoaVxyXG4gKi9cclxuXHJcblx0dmFyIE5vZGUgPSByZXF1aXJlKFwiLi4vTm9kZVwiKTtcclxuXHR2YXIgVXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcclxuXHR2YXIgZ3JhcGhpYyA9IHJlcXVpcmUoXCIuLi9ncmFwaGljLmpzXCIpO1xyXG4gICAgdmFyIFBvaW50ID0gcmVxdWlyZShcIi4uL1BvaW50LmpzXCIpO1xyXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xyXG4gICAgdmFyIENvbm5lY3Rpb25NYW5hZ2VyID0gcmVxdWlyZSgnLi9Db25uZWN0aW9uTWFuYWdlci5qcycpO1xyXG4gICAgdmFyIExpbmVPcGVyYXRpb25NYW5hZ2VyID0ge1xyXG4gICAgICAgIExpbmVPcGVyYXRpb25zOltdLFxyXG4gICAgICAgIGlzRWRpdDp0cnVlLFxyXG4gICAgICAgIGNyZWF0T3BlcmF0aW9uOmZ1bmN0aW9uKGtleSxvYmosYXBpKXtcclxuICAgICAgICAgICAgdmFyIGxpbmVPcGVyYXRpb24gPSBuZXcgZ3JhcGhpYy5JbWFnZSh7XHJcbiAgICAgICAgICAgICAgICBzdHlsZToge1xyXG4gICAgICAgICAgICAgICAgICAgIGltYWdlOm9iai5pY29uLFxyXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiBvYmoud2lkdGh8fDE1LFxyXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogb2JqLmhlaWdodHx8MTVcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGxpbmVPcGVyYXRpb24ua2V5ID0ga2V5O1xyXG4gICAgICAgICAgICBsaW5lT3BlcmF0aW9uLm9wZXJhdGlvbiA9IHRydWU7XHJcbiAgICAgICAgICAgIGxpbmVPcGVyYXRpb24uaGlkZSgpO1xyXG4gICAgICAgICAgICBvYmoubGluZU5vZGUuaWNvbnMucHVzaChsaW5lT3BlcmF0aW9uKTtcclxuICAgICAgICAgICAgTGluZU9wZXJhdGlvbk1hbmFnZXIuTGluZU9wZXJhdGlvbnMucHVzaChsaW5lT3BlcmF0aW9uKTtcclxuXHJcbiAgICAgICAgICAgIC8v5bCP5Zu+5qCHIOeCueWHu+S6i+S7tiAg5aaC5p6c5pyJ5Zue6LCD5YiZ6LCD55So5Zue6LCD77yM5ZCm5YiZ5rS+5Y+R5LqL5Lu2XHJcbiAgICAgICAgICAgIGxpbmVPcGVyYXRpb24ub24oXCJjbGlja1wiLGZ1bmN0aW9uKGUpe1xyXG4gICAgICAgICAgICAgICAgaWYob2JqLmNhbGxiYWNrKXtcclxuICAgICAgICAgICAgICAgICAgICBvYmouY2FsbGJhY2sob2JqLmxpbmVOb2RlKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhcmFtcyA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtcy5ldmVudCA9IGU7XHJcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zLnR5cGUgPSBcImNsaWNrXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zLmVsZW1lbnRUeXBlID0gXCJMaW5lT3BlcmF0aW9uSWNvblwiO1xyXG4gICAgICAgICAgICAgICAgICAgIGFwaS50cmlnZ2VyKHBhcmFtcy50eXBlLCBwYXJhbXMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiBsaW5lT3BlcmF0aW9uO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIOiuoeeul+Wwj+Wbvuagh+eahOS9jee9ru+8jOW5tuaYvuekulxyXG4gICAgICAgICAqIEBwYXJhbSAge1t0eXBlXX0gY29ubmVjdG9yIFtkZXNjcmlwdGlvbl1cclxuICAgICAgICAgKiBAcmV0dXJuIHtbdHlwZV19ICAgICAgICAgICBbZGVzY3JpcHRpb25dXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgYmluZE9wZXJhdGlvbjpmdW5jdGlvbihjb25uZWN0b3Ipe1xyXG4gICAgICAgICAgICBpZihMaW5lT3BlcmF0aW9uTWFuYWdlci5pc0VkaXQgPT0gZmFsc2Upe3JldHVybjt9XHJcbiAgICAgICAgICAgIHZhciBwb2ludFBvc2l0aW9uID0gY29ubmVjdG9yLm1pZGRsZSgpO1xyXG4gICAgICAgICAgICB2YXIgbGVuZ3RoID0gW107XHJcbiAgICAgICAgICAgIGZvcih2YXIgaiA9IDA7IGogPCBjb25uZWN0b3IuaWNvbnMubGVuZ3RoOyBqKyspe1xyXG4gICAgICAgICAgICAgICAgbGVuZ3RoLnB1c2goY29ubmVjdG9yLmljb25zW2pdLnN0eWxlLndpZHRoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgdG90YWxMZW5ndGggPSAwO1xyXG4gICAgICAgICAgICBmb3IodmFyIG0gPSAwOyBtIDwgY29ubmVjdG9yLmljb25zLmxlbmd0aDsgbSsrKXtcclxuICAgICAgICAgICAgICAgICAgICB0b3RhbExlbmd0aCArPSBsZW5ndGhbbV0rMTA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGNvbm5lY3Rvci5pY29ucy5sZW5ndGg7IGkrKyl7XHJcbiAgICAgICAgICAgICAgICB2YXIgY29ubmVjdG9yUG9zaXRpb24gPSAwO1xyXG4gICAgICAgICAgICAgICAgZm9yKHZhciBrID0gMDsgayA8IGk7IGsrKyl7XHJcbiAgICAgICAgICAgICAgICAgICAgY29ubmVjdG9yUG9zaXRpb24gKz0gbGVuZ3RoW2tdKzEwO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29ubmVjdG9yLmljb25zW2ldLmF0dHIoXCJwb3NpdGlvblwiLFtwb2ludFBvc2l0aW9uWzBdK2Nvbm5lY3RvclBvc2l0aW9uLXRvdGFsTGVuZ3RoLzIscG9pbnRQb3NpdGlvblsxXSs1XSk7XHJcbiAgICAgICAgICAgICAgICBjb25uZWN0b3IuaWNvbnNbaV0uc2hvdygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgaGlkZUFsbExpbmVPcGVyYXRpb246IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBsaSA9IDA7IGxpIDwgTGluZU9wZXJhdGlvbk1hbmFnZXIuTGluZU9wZXJhdGlvbnMubGVuZ3RoOyBsaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaWNvbiA9ICBMaW5lT3BlcmF0aW9uTWFuYWdlci5MaW5lT3BlcmF0aW9uc1tsaV07XHJcbiAgICAgICAgICAgICAgICBpY29uLmhpZGUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGFkZEljb246IGZ1bmN0aW9uKGtleSwgb2JqLCB6ciwgYXBpKSB7XHJcbiAgICAgICAgICAgIC8v5Yik5pat5piv5bCP5Zu+5qCH5ZCm5a2Y5ZyoIO+8jOWtmOWcqOWImeebtOaOpei/lOWbnlxyXG4gICAgICAgICAgICBpZihvYmoubGluZU5vZGUuaWNvbnMpe1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmoubGluZU5vZGUuaWNvbnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAob2JqLmxpbmVOb2RlLmljb25zW2ldLmtleSA9PSBrZXkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgTGluZU9wZXJhdGlvbk1hbmFnZXIuYmluZE9wZXJhdGlvbihvYmoubGluZU5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgbGluZU9wZXJhdGlvbiA9IExpbmVPcGVyYXRpb25NYW5hZ2VyLmNyZWF0T3BlcmF0aW9uKGtleSwgb2JqLCBhcGkpO1xyXG4gICAgICAgICAgICB6ci5hZGQobGluZU9wZXJhdGlvbik7XHJcbiAgICAgICAgICAgIExpbmVPcGVyYXRpb25NYW5hZ2VyLmJpbmRPcGVyYXRpb24ob2JqLmxpbmVOb2RlKTtcclxuICAgICAgICAgICAgcmV0dXJuIGxpbmVPcGVyYXRpb247XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgZGVsZXRlSWNvbk9iajogZnVuY3Rpb24ocGFyZW50WnIsbGluZU5vZGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIGljb246XCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUF3QUFBQU9CQU1BQUFEcGsrRGZBQUFBQkdkQlRVRUFBTEdQQy94aEJRQUFBQUZ6VWtkQ0FLN09IT2tBQUFBdFVFeFVSUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBTUdnS0Q0QUFBQVBkRkpPVXdESC9nK2FnRVNqNFk2elVpUm5oN2xud2JrQUFBQkxTVVJCVkFqWFkyQmdZRFpnQUlFbm5rQ2E3YTVjWUd3Q3d3a2xJT2hoTUJFRWdtSUdubEFnT01EQXByaFFVR2dEQTV2V2RKY2lYSlJHUjBkVEFnUHpRMEZCU2FCcHpNYkdCZ3dBSW9VVzNzUTJFZGtBQUFBQVNVVk9SSzVDWUlJPVwiLFxyXG4gICAgICAgICAgICAgICAgd2lkdGg6IDEyLFxyXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAxNCxcclxuICAgICAgICAgICAgICAgIGxpbmVOb2RlOmxpbmVOb2RlLFxyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2s6ZnVuY3Rpb24oZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGk8bGluZU5vZGUuaWNvbnMubGVuZ3RoO2krKyl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudFpyLnJlbW92ZShsaW5lTm9kZS5pY29uc1tpXSlcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgQ29ubmVjdGlvbk1hbmFnZXIuZGVsZXRlTGluZShwYXJlbnRacik7XHJcbiAgICAgICAgICAgICAgICAgICAgTGluZU9wZXJhdGlvbk1hbmFnZXIuaGlkZUFsbExpbmVPcGVyYXRpb24oKTtcclxuICAgICAgICAgICAgICAgICAgICBlLmNhbmNlbEJ1YmJsZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgfTtcclxuXHJcblx0bW9kdWxlLmV4cG9ydHMgPSBMaW5lT3BlcmF0aW9uTWFuYWdlcjtcclxuXHJcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9saWIvZmlzaC10b3BvLWNvcmUvbGliL21hbmFnZXIvTGluZU9wZXJhdGlvbk1hbmFnZXIuanNcbiAqKiBtb2R1bGUgaWQgPSAxMDdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxyXG4gKiDovoXliqnnur/mk43kvZznsbtcclxuICogQGF1dGhvciBtaWFvLmN1bnpoaVxyXG4gKi9cclxuXHJcblx0dmFyIE5vZGUgPSByZXF1aXJlKFwiLi4vTm9kZVwiKTtcclxuXHR2YXIgVXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcclxuXHR2YXIgZ3JhcGhpYyA9IHJlcXVpcmUoXCIuLi9ncmFwaGljLmpzXCIpO1xyXG4gICAgdmFyIFBvaW50ID0gcmVxdWlyZShcIi4uL1BvaW50LmpzXCIpO1xyXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xyXG5cclxuICAgIHZhciBHdWlkZWxpbmVzID0ge1xyXG4gICAgICAgIHZpcnR1YWxYTGluZTpudWxsLFxyXG4gICAgICAgIHZpcnR1YWxZTGluZTpudWxsLFxyXG4gICAgICAgIGNyZWF0ZUd1aWRlbGluZXM6ZnVuY3Rpb24oenIpe1xyXG4gICAgICAgICAgICAvL+WIm+W7unjovbTomZrnur9cclxuICAgICAgICAgICAgdGhpcy52aXJ0dWFsWExpbmUgPSBuZXcgZ3JhcGhpYy5MaW5lKHtcclxuICAgICAgICAgICAgICAgIHN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGluZURhc2g6IFs1XVxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHo6IDNcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIC8v5Yib5bu6Wei9tOiZmue6v1xyXG4gICAgICAgICAgICB0aGlzLnZpcnR1YWxZTGluZSA9IG5ldyBncmFwaGljLkxpbmUoe1xyXG4gICAgICAgICAgICAgICAgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgICAgICBsaW5lRGFzaDogWzVdXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgejogM1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgenIuYWRkKHRoaXMudmlydHVhbFhMaW5lKTtcclxuICAgICAgICAgICAgenIuYWRkKHRoaXMudmlydHVhbFlMaW5lKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGp1ZGdlQWxpZ25tZW50OmZ1bmN0aW9uKG5vd1JlY3RQb3NpdGlvbixkb21BcnJheSxtYXhXaWR0aCxtYXhIZWlnaHQpe1xyXG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XHJcbiAgICAgICAgICAgIC8v5b6q546v5Yik5pat5rC05bmz5a+56b2QXHJcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwLCBsZW4gPSBkb21BcnJheS5sZW5ndGg7IGogPCBsZW47IGorKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKG5vd1JlY3RQb3NpdGlvblsxXSA9PSBkb21BcnJheVtqXS5wb3NpdGlvblsxXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoYXQudmlydHVhbFhMaW5lLmF0dHIoJ3Bvc2l0aW9uJywgWzAsIG5vd1JlY3RQb3NpdGlvblsxXV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoYXQudmlydHVhbFhMaW5lLmF0dHIoXCJzaGFwZVwiLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHgyOiBtYXhXaWR0aFxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhhdC52aXJ0dWFsWExpbmUuYXR0cihcInNoYXBlXCIsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeDI6IDBcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvL+W+queOr+WIpOaWreWeguebtOWvuem9kFxyXG4gICAgICAgICAgICBmb3IgKHZhciBtID0gMCwgbGVuMSA9IGRvbUFycmF5Lmxlbmd0aDsgbSA8IGxlbjE7IG0rKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKG5vd1JlY3RQb3NpdGlvblswXSA9PSBkb21BcnJheVttXS5wb3NpdGlvblswXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoYXQudmlydHVhbFlMaW5lLmF0dHIoJ3Bvc2l0aW9uJywgW25vd1JlY3RQb3NpdGlvblswXSwgMF0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoYXQudmlydHVhbFlMaW5lLmF0dHIoXCJzaGFwZVwiLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHkyOiBtYXhIZWlnaHRcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhhdC52aXJ0dWFsWUxpbmUuYXR0cihcInNoYXBlXCIsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeTI6IDBcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG5cdG1vZHVsZS5leHBvcnRzID0gR3VpZGVsaW5lcztcclxuXHJcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9saWIvZmlzaC10b3BvLWNvcmUvbGliL21hbmFnZXIvR3VpZGVsaW5lcy5qc1xuICoqIG1vZHVsZSBpZCA9IDEwOFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXG4gICAgcmVxdWlyZSgnLi9ncmFwaGljJyk7XG4gICAgcmVxdWlyZSgnLi4venJlbmRlcicpLnJlZ2lzdGVyUGFpbnRlcigndm1sJywgcmVxdWlyZSgnLi9QYWludGVyJykpO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34venJlbmRlci9saWIvdm1sL3ZtbC5qc1xuICoqIG1vZHVsZSBpZCA9IDEwOVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gaHR0cDovL3d3dy53My5vcmcvVFIvTk9URS1WTUxcbi8vIFRPRE8gVXNlIHByb3h5IGxpa2Ugc3ZnIGluc3RlYWQgb2Ygb3ZlcndyaXRlIGJydXNoIG1ldGhvZHNcblxuXG5pZiAoIXJlcXVpcmUoJy4uL2NvcmUvZW52JykuY2FudmFzU3VwcG9ydGVkKSB7XG4gICAgdmFyIHZlYzIgPSByZXF1aXJlKCcuLi9jb3JlL3ZlY3RvcicpO1xuICAgIHZhciBCb3VuZGluZ1JlY3QgPSByZXF1aXJlKCcuLi9jb3JlL0JvdW5kaW5nUmVjdCcpO1xuICAgIHZhciBDTUQgPSByZXF1aXJlKCcuLi9jb3JlL1BhdGhQcm94eScpLkNNRDtcbiAgICB2YXIgY29sb3JUb29sID0gcmVxdWlyZSgnLi4vdG9vbC9jb2xvcicpO1xuICAgIHZhciB0ZXh0Q29udGFpbiA9IHJlcXVpcmUoJy4uL2NvbnRhaW4vdGV4dCcpO1xuICAgIHZhciBSZWN0VGV4dCA9IHJlcXVpcmUoJy4uL2dyYXBoaWMvbWl4aW4vUmVjdFRleHQnKTtcbiAgICB2YXIgRGlzcGxheWFibGUgPSByZXF1aXJlKCcuLi9ncmFwaGljL0Rpc3BsYXlhYmxlJyk7XG4gICAgdmFyIFpJbWFnZSA9IHJlcXVpcmUoJy4uL2dyYXBoaWMvSW1hZ2UnKTtcbiAgICB2YXIgVGV4dCA9IHJlcXVpcmUoJy4uL2dyYXBoaWMvVGV4dCcpO1xuICAgIHZhciBQYXRoID0gcmVxdWlyZSgnLi4vZ3JhcGhpYy9QYXRoJyk7XG5cbiAgICB2YXIgR3JhZGllbnQgPSByZXF1aXJlKCcuLi9ncmFwaGljL0dyYWRpZW50Jyk7XG5cbiAgICB2YXIgdm1sQ29yZSA9IHJlcXVpcmUoJy4vY29yZScpO1xuXG4gICAgdmFyIHJvdW5kID0gTWF0aC5yb3VuZDtcbiAgICB2YXIgc3FydCA9IE1hdGguc3FydDtcbiAgICB2YXIgYWJzID0gTWF0aC5hYnM7XG4gICAgdmFyIGNvcyA9IE1hdGguY29zO1xuICAgIHZhciBzaW4gPSBNYXRoLnNpbjtcbiAgICB2YXIgbWF0aE1heCA9IE1hdGgubWF4O1xuXG4gICAgdmFyIGFwcGx5VHJhbnNmb3JtID0gdmVjMi5hcHBseVRyYW5zZm9ybTtcblxuICAgIHZhciBjb21tYSA9ICcsJztcbiAgICB2YXIgaW1hZ2VUcmFuc2Zvcm1QcmVmaXggPSAncHJvZ2lkOkRYSW1hZ2VUcmFuc2Zvcm0uTWljcm9zb2Z0JztcblxuICAgIHZhciBaID0gMjE2MDA7XG4gICAgdmFyIFoyID0gWiAvIDI7XG5cbiAgICB2YXIgWkxFVkVMX0JBU0UgPSAxMDAwMDA7XG4gICAgdmFyIFpfQkFTRSA9IDEwMDA7XG5cbiAgICB2YXIgaW5pdFJvb3RFbFN0eWxlID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgIGVsLnN0eWxlLmNzc1RleHQgPSAncG9zaXRpb246YWJzb2x1dGU7bGVmdDowO3RvcDowO3dpZHRoOjFweDtoZWlnaHQ6MXB4Oyc7XG4gICAgICAgIGVsLmNvb3Jkc2l6ZSA9IFogKyAnLCcgICsgWjtcbiAgICAgICAgZWwuY29vcmRvcmlnaW4gPSAnMCwwJztcbiAgICB9O1xuXG4gICAgdmFyIGVuY29kZUh0bWxBdHRyaWJ1dGUgPSBmdW5jdGlvbiAocykge1xuICAgICAgICByZXR1cm4gU3RyaW5nKHMpLnJlcGxhY2UoLyYvZywgJyZhbXA7JykucmVwbGFjZSgvXCIvZywgJyZxdW90OycpO1xuICAgIH07XG5cbiAgICB2YXIgcmdiMlN0ciA9IGZ1bmN0aW9uIChyLCBnLCBiKSB7XG4gICAgICAgIHJldHVybiAncmdiKCcgKyBbciwgZywgYl0uam9pbignLCcpICsgJyknO1xuICAgIH07XG5cbiAgICB2YXIgYXBwZW5kID0gZnVuY3Rpb24gKHBhcmVudCwgY2hpbGQpIHtcbiAgICAgICAgaWYgKGNoaWxkICYmIHBhcmVudCAmJiBjaGlsZC5wYXJlbnROb2RlICE9PSBwYXJlbnQpIHtcbiAgICAgICAgICAgIHBhcmVudC5hcHBlbmRDaGlsZChjaGlsZCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIHJlbW92ZSA9IGZ1bmN0aW9uIChwYXJlbnQsIGNoaWxkKSB7XG4gICAgICAgIGlmIChjaGlsZCAmJiBwYXJlbnQgJiYgY2hpbGQucGFyZW50Tm9kZSA9PT0gcGFyZW50KSB7XG4gICAgICAgICAgICBwYXJlbnQucmVtb3ZlQ2hpbGQoY2hpbGQpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciBnZXRaSW5kZXggPSBmdW5jdGlvbiAoemxldmVsLCB6LCB6Mikge1xuICAgICAgICAvLyB6IOeahOWPluWAvOiMg+WbtOS4uiBbMCwgMTAwMF1cbiAgICAgICAgcmV0dXJuIChwYXJzZUZsb2F0KHpsZXZlbCkgfHwgMCkgKiBaTEVWRUxfQkFTRSArIChwYXJzZUZsb2F0KHopIHx8IDApICogWl9CQVNFICsgejI7XG4gICAgfTtcblxuICAgIHZhciBwYXJzZVBlcmNlbnQgPSBmdW5jdGlvbiAodmFsdWUsIG1heFZhbHVlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUubGFzdEluZGV4T2YoJyUnKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQodmFsdWUpIC8gMTAwICogbWF4VmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VGbG9hdCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG5cbiAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgICogUEFUSFxuICAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgIHZhciBzZXRDb2xvckFuZE9wYWNpdHkgPSBmdW5jdGlvbiAoZWwsIGNvbG9yLCBvcGFjaXR5KSB7XG4gICAgICAgIHZhciBjb2xvckFyciA9IGNvbG9yVG9vbC5wYXJzZShjb2xvcik7XG4gICAgICAgIG9wYWNpdHkgPSArb3BhY2l0eTtcbiAgICAgICAgaWYgKGlzTmFOKG9wYWNpdHkpKSB7XG4gICAgICAgICAgICBvcGFjaXR5ID0gMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29sb3JBcnIpIHtcbiAgICAgICAgICAgIGVsLmNvbG9yID0gcmdiMlN0cihjb2xvckFyclswXSwgY29sb3JBcnJbMV0sIGNvbG9yQXJyWzJdKTtcbiAgICAgICAgICAgIGVsLm9wYWNpdHkgPSBvcGFjaXR5ICogY29sb3JBcnJbM107XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIGdldENvbG9yQW5kQWxwaGEgPSBmdW5jdGlvbiAoY29sb3IpIHtcbiAgICAgICAgdmFyIGNvbG9yQXJyID0gY29sb3JUb29sLnBhcnNlKGNvbG9yKTtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHJnYjJTdHIoY29sb3JBcnJbMF0sIGNvbG9yQXJyWzFdLCBjb2xvckFyclsyXSksXG4gICAgICAgICAgICBjb2xvckFyclszXVxuICAgICAgICBdO1xuICAgIH07XG5cbiAgICB2YXIgdXBkYXRlRmlsbE5vZGUgPSBmdW5jdGlvbiAoZWwsIHN0eWxlLCB6ckVsKSB7XG4gICAgICAgIC8vIFRPRE8gcGF0dGVyblxuICAgICAgICB2YXIgZmlsbCA9IHN0eWxlLmZpbGw7XG4gICAgICAgIGlmIChmaWxsICE9IG51bGwpIHtcbiAgICAgICAgICAgIC8vIE1vZGlmaWVkIGZyb20gZXhjYW52YXNcbiAgICAgICAgICAgIGlmIChmaWxsIGluc3RhbmNlb2YgR3JhZGllbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgZ3JhZGllbnRUeXBlO1xuICAgICAgICAgICAgICAgIHZhciBhbmdsZSA9IDA7XG4gICAgICAgICAgICAgICAgdmFyIGZvY3VzID0gWzAsIDBdO1xuICAgICAgICAgICAgICAgIC8vIGFkZGl0aW9uYWwgb2Zmc2V0XG4gICAgICAgICAgICAgICAgdmFyIHNoaWZ0ID0gMDtcbiAgICAgICAgICAgICAgICAvLyBzY2FsZSBmYWN0b3IgZm9yIG9mZnNldFxuICAgICAgICAgICAgICAgIHZhciBleHBhbnNpb24gPSAxO1xuICAgICAgICAgICAgICAgIHZhciByZWN0ID0genJFbC5nZXRCb3VuZGluZ1JlY3QoKTtcbiAgICAgICAgICAgICAgICB2YXIgcmVjdFdpZHRoID0gcmVjdC53aWR0aDtcbiAgICAgICAgICAgICAgICB2YXIgcmVjdEhlaWdodCA9IHJlY3QuaGVpZ2h0O1xuICAgICAgICAgICAgICAgIGlmIChmaWxsLnR5cGUgPT09ICdsaW5lYXInKSB7XG4gICAgICAgICAgICAgICAgICAgIGdyYWRpZW50VHlwZSA9ICdncmFkaWVudCc7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0cmFuc2Zvcm0gPSB6ckVsLnRyYW5zZm9ybTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHAwID0gW2ZpbGwueCAqIHJlY3RXaWR0aCwgZmlsbC55ICogcmVjdEhlaWdodF07XG4gICAgICAgICAgICAgICAgICAgIHZhciBwMSA9IFtmaWxsLngyICogcmVjdFdpZHRoLCBmaWxsLnkyICogcmVjdEhlaWdodF07XG4gICAgICAgICAgICAgICAgICAgIGlmICh0cmFuc2Zvcm0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFwcGx5VHJhbnNmb3JtKHAwLCBwMCwgdHJhbnNmb3JtKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFwcGx5VHJhbnNmb3JtKHAxLCBwMSwgdHJhbnNmb3JtKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgZHggPSBwMVswXSAtIHAwWzBdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZHkgPSBwMVsxXSAtIHAwWzFdO1xuICAgICAgICAgICAgICAgICAgICBhbmdsZSA9IE1hdGguYXRhbjIoZHgsIGR5KSAqIDE4MCAvIE1hdGguUEk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSBhbmdsZSBzaG91bGQgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyLlxuICAgICAgICAgICAgICAgICAgICBpZiAoYW5nbGUgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbmdsZSArPSAzNjA7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBWZXJ5IHNtYWxsIGFuZ2xlcyBwcm9kdWNlIGFuIHVuZXhwZWN0ZWQgcmVzdWx0IGJlY2F1c2UgdGhleSBhcmVcbiAgICAgICAgICAgICAgICAgICAgLy8gY29udmVydGVkIHRvIGEgc2NpZW50aWZpYyBub3RhdGlvbiBzdHJpbmcuXG4gICAgICAgICAgICAgICAgICAgIGlmIChhbmdsZSA8IDFlLTYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFuZ2xlID0gMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZ3JhZGllbnRUeXBlID0gJ2dyYWRpZW50cmFkaWFsJztcbiAgICAgICAgICAgICAgICAgICAgdmFyIHAwID0gW2ZpbGwueCAqIHJlY3RXaWR0aCwgZmlsbC55ICogcmVjdEhlaWdodF07XG4gICAgICAgICAgICAgICAgICAgIHZhciB0cmFuc2Zvcm0gPSB6ckVsLnRyYW5zZm9ybTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNjYWxlID0genJFbC5zY2FsZTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHdpZHRoID0gcmVjdFdpZHRoO1xuICAgICAgICAgICAgICAgICAgICB2YXIgaGVpZ2h0ID0gcmVjdEhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgZm9jdXMgPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBQZXJjZW50IGluIGJvdW5kaW5nIHJlY3RcbiAgICAgICAgICAgICAgICAgICAgICAgIChwMFswXSAtIHJlY3QueCkgLyB3aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIChwMFsxXSAtIHJlY3QueSkgLyBoZWlnaHRcbiAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRyYW5zZm9ybSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXBwbHlUcmFuc2Zvcm0ocDAsIHAwLCB0cmFuc2Zvcm0pO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgd2lkdGggLz0gc2NhbGVbMF0gKiBaO1xuICAgICAgICAgICAgICAgICAgICBoZWlnaHQgLz0gc2NhbGVbMV0gKiBaO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGltZW5zaW9uID0gbWF0aE1heCh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgc2hpZnQgPSAyICogMCAvIGRpbWVuc2lvbjtcbiAgICAgICAgICAgICAgICAgICAgZXhwYW5zaW9uID0gMiAqIGZpbGwuciAvIGRpbWVuc2lvbiAtIHNoaWZ0O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gc29ydCB0aGUgY29sb3Igc3RvcHMgaW4gYXNjZW5kaW5nIG9yZGVyIGJ5IG9mZnNldCxcbiAgICAgICAgICAgICAgICAvLyBvdGhlcndpc2UgSUUgd29uJ3QgaW50ZXJwcmV0IGl0IGNvcnJlY3RseS5cbiAgICAgICAgICAgICAgICB2YXIgc3RvcHMgPSBmaWxsLmNvbG9yU3RvcHMuc2xpY2UoKTtcbiAgICAgICAgICAgICAgICBzdG9wcy5zb3J0KGZ1bmN0aW9uKGNzMSwgY3MyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjczEub2Zmc2V0IC0gY3MyLm9mZnNldDtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIHZhciBsZW5ndGggPSBzdG9wcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgLy8gQ29sb3IgYW5kIGFscGhhIGxpc3Qgb2YgZmlyc3QgYW5kIGxhc3Qgc3RvcFxuICAgICAgICAgICAgICAgIHZhciBjb2xvckFuZEFscGhhTGlzdCA9IFtdO1xuICAgICAgICAgICAgICAgIHZhciBjb2xvcnMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzdG9wID0gc3RvcHNbaV07XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb2xvckFuZEFscGhhID0gZ2V0Q29sb3JBbmRBbHBoYShzdG9wLmNvbG9yKTtcbiAgICAgICAgICAgICAgICAgICAgY29sb3JzLnB1c2goc3RvcC5vZmZzZXQgKiBleHBhbnNpb24gKyBzaGlmdCArICcgJyArIGNvbG9yQW5kQWxwaGFbMF0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaSA9PT0gMCB8fCBpID09PSBsZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvckFuZEFscGhhTGlzdC5wdXNoKGNvbG9yQW5kQWxwaGEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGxlbmd0aCA+PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb2xvcjEgPSBjb2xvckFuZEFscGhhTGlzdFswXVswXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbG9yMiA9IGNvbG9yQW5kQWxwaGFMaXN0WzFdWzBdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgb3BhY2l0eTEgPSBjb2xvckFuZEFscGhhTGlzdFswXVsxXSAqIHN0eWxlLm9wYWNpdHk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBvcGFjaXR5MiA9IGNvbG9yQW5kQWxwaGFMaXN0WzFdWzFdICogc3R5bGUub3BhY2l0eTtcblxuICAgICAgICAgICAgICAgICAgICBlbC50eXBlID0gZ3JhZGllbnRUeXBlO1xuICAgICAgICAgICAgICAgICAgICBlbC5tZXRob2QgPSAnbm9uZSc7XG4gICAgICAgICAgICAgICAgICAgIGVsLmZvY3VzID0gJzEwMCUnO1xuICAgICAgICAgICAgICAgICAgICBlbC5hbmdsZSA9IGFuZ2xlO1xuICAgICAgICAgICAgICAgICAgICBlbC5jb2xvciA9IGNvbG9yMTtcbiAgICAgICAgICAgICAgICAgICAgZWwuY29sb3IyID0gY29sb3IyO1xuICAgICAgICAgICAgICAgICAgICBlbC5jb2xvcnMgPSBjb2xvcnMuam9pbignLCcpO1xuICAgICAgICAgICAgICAgICAgICAvLyBXaGVuIGNvbG9ycyBhdHRyaWJ1dGUgaXMgdXNlZCwgdGhlIG1lYW5pbmdzIG9mIG9wYWNpdHkgYW5kIG86b3BhY2l0eTJcbiAgICAgICAgICAgICAgICAgICAgLy8gYXJlIHJldmVyc2VkLlxuICAgICAgICAgICAgICAgICAgICBlbC5vcGFjaXR5ID0gb3BhY2l0eTI7XG4gICAgICAgICAgICAgICAgICAgIC8vIEZJWE1FIGdfb186b3BhY2l0eSA/XG4gICAgICAgICAgICAgICAgICAgIGVsLm9wYWNpdHkyID0gb3BhY2l0eTE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChncmFkaWVudFR5cGUgPT09ICdyYWRpYWwnKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsLmZvY3VzcG9zaXRpb24gPSBmb2N1cy5qb2luKCcsJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gRklYTUUgQ2hhbmdlIGZyb20gR3JhZGllbnQgZmlsbCB0byBjb2xvciBmaWxsXG4gICAgICAgICAgICAgICAgc2V0Q29sb3JBbmRPcGFjaXR5KGVsLCBmaWxsLCBzdHlsZS5vcGFjaXR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgdXBkYXRlU3Ryb2tlTm9kZSA9IGZ1bmN0aW9uIChlbCwgc3R5bGUpIHtcbiAgICAgICAgLy8gaWYgKHN0eWxlLmxpbmVKb2luICE9IG51bGwpIHtcbiAgICAgICAgLy8gICAgIGVsLmpvaW5zdHlsZSA9IHN0eWxlLmxpbmVKb2luO1xuICAgICAgICAvLyB9XG4gICAgICAgIC8vIGlmIChzdHlsZS5taXRlckxpbWl0ICE9IG51bGwpIHtcbiAgICAgICAgLy8gICAgIGVsLm1pdGVybGltaXQgPSBzdHlsZS5taXRlckxpbWl0ICogWjtcbiAgICAgICAgLy8gfVxuICAgICAgICAvLyBpZiAoc3R5bGUubGluZUNhcCAhPSBudWxsKSB7XG4gICAgICAgIC8vICAgICBlbC5lbmRjYXAgPSBzdHlsZS5saW5lQ2FwO1xuICAgICAgICAvLyB9XG4gICAgICAgIGlmIChzdHlsZS5saW5lRGFzaCAhPSBudWxsKSB7XG4gICAgICAgICAgICBlbC5kYXNoc3R5bGUgPSBzdHlsZS5saW5lRGFzaC5qb2luKCcgJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0eWxlLnN0cm9rZSAhPSBudWxsICYmICEoc3R5bGUuc3Ryb2tlIGluc3RhbmNlb2YgR3JhZGllbnQpKSB7XG4gICAgICAgICAgICBzZXRDb2xvckFuZE9wYWNpdHkoZWwsIHN0eWxlLnN0cm9rZSwgc3R5bGUub3BhY2l0eSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIHVwZGF0ZUZpbGxBbmRTdHJva2UgPSBmdW5jdGlvbiAodm1sRWwsIHR5cGUsIHN0eWxlLCB6ckVsKSB7XG4gICAgICAgIHZhciBpc0ZpbGwgPSB0eXBlID09ICdmaWxsJztcbiAgICAgICAgdmFyIGVsID0gdm1sRWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUodHlwZSlbMF07XG4gICAgICAgIC8vIFN0cm9rZSBtdXN0IGhhdmUgbGluZVdpZHRoXG4gICAgICAgIGlmIChzdHlsZVt0eXBlXSAhPSBudWxsICYmIHN0eWxlW3R5cGVdICE9PSAnbm9uZScgJiYgKGlzRmlsbCB8fCAoIWlzRmlsbCAmJiBzdHlsZS5saW5lV2lkdGgpKSkge1xuICAgICAgICAgICAgdm1sRWxbaXNGaWxsID8gJ2ZpbGxlZCcgOiAnc3Ryb2tlZCddID0gJ3RydWUnO1xuICAgICAgICAgICAgLy8gRklYTUUgUmVtb3ZlIGJlZm9yZSB1cGRhdGluZywgb3Igc2V0IGBjb2xvcnNgIHdpbGwgdGhyb3cgZXJyb3JcbiAgICAgICAgICAgIGlmIChzdHlsZVt0eXBlXSBpbnN0YW5jZW9mIEdyYWRpZW50KSB7XG4gICAgICAgICAgICAgICAgcmVtb3ZlKHZtbEVsLCBlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWVsKSB7XG4gICAgICAgICAgICAgICAgZWwgPSB2bWxDb3JlLmNyZWF0ZU5vZGUodHlwZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlzRmlsbCA/IHVwZGF0ZUZpbGxOb2RlKGVsLCBzdHlsZSwgenJFbCkgOiB1cGRhdGVTdHJva2VOb2RlKGVsLCBzdHlsZSk7XG4gICAgICAgICAgICBhcHBlbmQodm1sRWwsIGVsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZtbEVsW2lzRmlsbCA/ICdmaWxsZWQnIDogJ3N0cm9rZWQnXSA9ICdmYWxzZSc7XG4gICAgICAgICAgICByZW1vdmUodm1sRWwsIGVsKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgcG9pbnRzID0gW1tdLCBbXSwgW11dO1xuICAgIHZhciBwYXRoRGF0YVRvU3RyaW5nID0gZnVuY3Rpb24gKGRhdGEsIG0pIHtcbiAgICAgICAgdmFyIE0gPSBDTUQuTTtcbiAgICAgICAgdmFyIEMgPSBDTUQuQztcbiAgICAgICAgdmFyIEwgPSBDTUQuTDtcbiAgICAgICAgdmFyIEEgPSBDTUQuQTtcbiAgICAgICAgdmFyIFEgPSBDTUQuUTtcblxuICAgICAgICB2YXIgc3RyID0gW107XG4gICAgICAgIHZhciBuUG9pbnQ7XG4gICAgICAgIHZhciBjbWRTdHI7XG4gICAgICAgIHZhciBjbWQ7XG4gICAgICAgIHZhciBpO1xuICAgICAgICB2YXIgeGk7XG4gICAgICAgIHZhciB5aTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGRhdGEubGVuZ3RoOykge1xuICAgICAgICAgICAgY21kID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgY21kU3RyID0gJyc7XG4gICAgICAgICAgICBuUG9pbnQgPSAwO1xuICAgICAgICAgICAgc3dpdGNoIChjbWQpIHtcbiAgICAgICAgICAgICAgICBjYXNlIE06XG4gICAgICAgICAgICAgICAgICAgIGNtZFN0ciA9ICcgbSAnO1xuICAgICAgICAgICAgICAgICAgICBuUG9pbnQgPSAxO1xuICAgICAgICAgICAgICAgICAgICB4aSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgeWkgPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgIHBvaW50c1swXVswXSA9IHhpO1xuICAgICAgICAgICAgICAgICAgICBwb2ludHNbMF1bMV0gPSB5aTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBMOlxuICAgICAgICAgICAgICAgICAgICBjbWRTdHIgPSAnIGwgJztcbiAgICAgICAgICAgICAgICAgICAgblBvaW50ID0gMTtcbiAgICAgICAgICAgICAgICAgICAgeGkgPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgIHlpID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICBwb2ludHNbMF1bMF0gPSB4aTtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRzWzBdWzFdID0geWk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgUTpcbiAgICAgICAgICAgICAgICBjYXNlIEM6XG4gICAgICAgICAgICAgICAgICAgIGNtZFN0ciA9ICcgYyAnO1xuICAgICAgICAgICAgICAgICAgICBuUG9pbnQgPSAzO1xuICAgICAgICAgICAgICAgICAgICB2YXIgeDEgPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgIHZhciB5MSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHgyID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgeTIgPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgIHZhciB4MztcbiAgICAgICAgICAgICAgICAgICAgdmFyIHkzO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY21kID09PSBRKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDb252ZXJ0IHF1YWRyYXRpYyB0byBjdWJpYyB1c2luZyBkZWdyZWUgZWxldmF0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICB4MyA9IHgyO1xuICAgICAgICAgICAgICAgICAgICAgICAgeTMgPSB5MjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHgyID0gKHgyICsgMiAqIHgxKSAvIDM7XG4gICAgICAgICAgICAgICAgICAgICAgICB5MiA9ICh5MiArIDIgKiB5MSkgLyAzO1xuICAgICAgICAgICAgICAgICAgICAgICAgeDEgPSAoeGkgKyAyICogeDEpIC8gMztcbiAgICAgICAgICAgICAgICAgICAgICAgIHkxID0gKHlpICsgMiAqIHkxKSAvIDM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4MyA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHkzID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHBvaW50c1swXVswXSA9IHgxO1xuICAgICAgICAgICAgICAgICAgICBwb2ludHNbMF1bMV0gPSB5MTtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRzWzFdWzBdID0geDI7XG4gICAgICAgICAgICAgICAgICAgIHBvaW50c1sxXVsxXSA9IHkyO1xuICAgICAgICAgICAgICAgICAgICBwb2ludHNbMl1bMF0gPSB4MztcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRzWzJdWzFdID0geTM7XG5cbiAgICAgICAgICAgICAgICAgICAgeGkgPSB4MztcbiAgICAgICAgICAgICAgICAgICAgeWkgPSB5MztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBBOlxuICAgICAgICAgICAgICAgICAgICB2YXIgeCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHZhciB5ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN4ID0gMTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN5ID0gMTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFuZ2xlID0gMDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEV4dHJhY3QgU1JUIGZyb20gbWF0cml4XG4gICAgICAgICAgICAgICAgICAgICAgICB4ID0gbVs0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHkgPSBtWzVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3ggPSBzcXJ0KG1bMF0gKiBtWzBdICsgbVsxXSAqIG1bMV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3kgPSBzcXJ0KG1bMl0gKiBtWzJdICsgbVszXSAqIG1bM10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYW5nbGUgPSBNYXRoLmF0YW4yKC1tWzFdIC8gc3ksIG1bMF0gLyBzeCk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB2YXIgY3ggPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgIHZhciBjeSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJ4ID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcnkgPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgIHZhciBzdGFydEFuZ2xlID0gZGF0YVtpKytdICsgYW5nbGU7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlbmRBbmdsZSA9IGRhdGFbaSsrXSArIHN0YXJ0QW5nbGUgKyBhbmdsZTtcbiAgICAgICAgICAgICAgICAgICAgLy8gRklYTUVcbiAgICAgICAgICAgICAgICAgICAgLy8gdmFyIHBzaSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2xvY2t3aXNlID0gZGF0YVtpKytdO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciB4MCA9IGN4ICsgY29zKHN0YXJ0QW5nbGUpICogcng7XG4gICAgICAgICAgICAgICAgICAgIHZhciB5MCA9IGN5ICsgc2luKHN0YXJ0QW5nbGUpICogcnk7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHgxID0gY3ggKyBjb3MoZW5kQW5nbGUpICogcng7XG4gICAgICAgICAgICAgICAgICAgIHZhciB5MSA9IGN5ICsgc2luKGVuZEFuZ2xlKSAqIHJ5O1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciB0eXBlID0gY2xvY2t3aXNlID8gJyB3YSAnIDogJyBhdCAnO1xuICAgICAgICAgICAgICAgICAgICBpZiAoTWF0aC5hYnMoeDAgLSB4MSkgPCAxZS0xMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSUUgd29uJ3QgcmVuZGVyIGFyY2hlcyBkcmF3biBjb3VudGVyIGNsb2Nrd2lzZSBpZiB4MCA9PSB4MS5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyhlbmRBbmdsZSAtIHN0YXJ0QW5nbGUpID4gMWUtMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9mZnNldCB4MCBieSAxLzgwIG9mIGEgcGl4ZWwuIFVzZSBzb21ldGhpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGF0IGNhbiBiZSByZXByZXNlbnRlZCBpbiBiaW5hcnlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2xvY2t3aXNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHgwICs9IDI3MCAvIFo7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQXZvaWQgY2FzZSBkcmF3IGZ1bGwgY2lyY2xlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKE1hdGguYWJzKHkwIC0gY3kpIDwgMWUtMTApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChjbG9ja3dpc2UgJiYgeDAgPCBjeCkgfHwgKCFjbG9ja3dpc2UgJiYgeDAgPiBjeCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkxIC09IDI3MCAvIFo7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5MSArPSAyNzAgLyBaO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKChjbG9ja3dpc2UgJiYgeTAgPCBjeSkgfHwgKCFjbG9ja3dpc2UgJiYgeTAgPiBjeSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeDEgKz0gMjcwIC8gWjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHgxIC09IDI3MCAvIFo7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHN0ci5wdXNoKFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdW5kKCgoY3ggLSByeCkgKiBzeCArIHgpICogWiAtIFoyKSwgY29tbWEsXG4gICAgICAgICAgICAgICAgICAgICAgICByb3VuZCgoKGN5IC0gcnkpICogc3kgKyB5KSAqIFogLSBaMiksIGNvbW1hLFxuICAgICAgICAgICAgICAgICAgICAgICAgcm91bmQoKChjeCArIHJ4KSAqIHN4ICsgeCkgKiBaIC0gWjIpLCBjb21tYSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdW5kKCgoY3kgKyByeSkgKiBzeSArIHkpICogWiAtIFoyKSwgY29tbWEsXG4gICAgICAgICAgICAgICAgICAgICAgICByb3VuZCgoeDAgKiBzeCArIHgpICogWiAtIFoyKSwgY29tbWEsXG4gICAgICAgICAgICAgICAgICAgICAgICByb3VuZCgoeTAgKiBzeSArIHkpICogWiAtIFoyKSwgY29tbWEsXG4gICAgICAgICAgICAgICAgICAgICAgICByb3VuZCgoeDEgKiBzeCArIHgpICogWiAtIFoyKSwgY29tbWEsXG4gICAgICAgICAgICAgICAgICAgICAgICByb3VuZCgoeTEgKiBzeSArIHkpICogWiAtIFoyKVxuICAgICAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgICAgIHhpID0geDE7XG4gICAgICAgICAgICAgICAgICAgIHlpID0geTE7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgQ01ELlI6XG4gICAgICAgICAgICAgICAgICAgIHZhciBwMCA9IHBvaW50c1swXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHAxID0gcG9pbnRzWzFdO1xuICAgICAgICAgICAgICAgICAgICAvLyB4MCwgeTBcbiAgICAgICAgICAgICAgICAgICAgcDBbMF0gPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgIHAwWzFdID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICAvLyB4MSwgeTFcbiAgICAgICAgICAgICAgICAgICAgcDFbMF0gPSBwMFswXSArIGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgcDFbMV0gPSBwMFsxXSArIGRhdGFbaSsrXTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAobSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXBwbHlUcmFuc2Zvcm0ocDAsIHAwLCBtKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFwcGx5VHJhbnNmb3JtKHAxLCBwMSwgbSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBwMFswXSA9IHJvdW5kKHAwWzBdICogWiAtIFoyKTtcbiAgICAgICAgICAgICAgICAgICAgcDFbMF0gPSByb3VuZChwMVswXSAqIFogLSBaMik7XG4gICAgICAgICAgICAgICAgICAgIHAwWzFdID0gcm91bmQocDBbMV0gKiBaIC0gWjIpO1xuICAgICAgICAgICAgICAgICAgICBwMVsxXSA9IHJvdW5kKHAxWzFdICogWiAtIFoyKTtcbiAgICAgICAgICAgICAgICAgICAgc3RyLnB1c2goXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB4MCwgeTBcbiAgICAgICAgICAgICAgICAgICAgICAgICcgbSAnLCBwMFswXSwgY29tbWEsIHAwWzFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8geDEsIHkwXG4gICAgICAgICAgICAgICAgICAgICAgICAnIGwgJywgcDFbMF0sIGNvbW1hLCBwMFsxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHgxLCB5MVxuICAgICAgICAgICAgICAgICAgICAgICAgJyBsICcsIHAxWzBdLCBjb21tYSwgcDFbMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB4MCwgeTFcbiAgICAgICAgICAgICAgICAgICAgICAgICcgbCAnLCBwMFswXSwgY29tbWEsIHAxWzFdXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgQ01ELlo6XG4gICAgICAgICAgICAgICAgICAgIC8vIEZJWE1FIFVwZGF0ZSB4aSwgeWlcbiAgICAgICAgICAgICAgICAgICAgc3RyLnB1c2goJyB4ICcpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoblBvaW50ID4gMCkge1xuICAgICAgICAgICAgICAgIHN0ci5wdXNoKGNtZFN0cik7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBuUG9pbnQ7IGsrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcCA9IHBvaW50c1trXTtcblxuICAgICAgICAgICAgICAgICAgICBtICYmIGFwcGx5VHJhbnNmb3JtKHAsIHAsIG0pO1xuICAgICAgICAgICAgICAgICAgICAvLyDkuI0gcm91bmQg5Lya6Z2e5bi45oWiXG4gICAgICAgICAgICAgICAgICAgIHN0ci5wdXNoKFxuICAgICAgICAgICAgICAgICAgICAgICAgcm91bmQocFswXSAqIFogLSBaMiksIGNvbW1hLCByb3VuZChwWzFdICogWiAtIFoyKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGsgPCBuUG9pbnQgLSAxID8gY29tbWEgOiAnJ1xuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzdHIuam9pbignJyk7XG4gICAgfTtcblxuICAgIC8vIFJld3JpdGUgdGhlIG9yaWdpbmFsIHBhdGggbWV0aG9kXG4gICAgUGF0aC5wcm90b3R5cGUuYnJ1c2hWTUwgPSBmdW5jdGlvbiAodm1sUm9vdCkge1xuICAgICAgICB2YXIgc3R5bGUgPSB0aGlzLnN0eWxlO1xuXG4gICAgICAgIHZhciB2bWxFbCA9IHRoaXMuX3ZtbEVsO1xuICAgICAgICBpZiAoIXZtbEVsKSB7XG4gICAgICAgICAgICB2bWxFbCA9IHZtbENvcmUuY3JlYXRlTm9kZSgnc2hhcGUnKTtcbiAgICAgICAgICAgIGluaXRSb290RWxTdHlsZSh2bWxFbCk7XG5cbiAgICAgICAgICAgIHRoaXMuX3ZtbEVsID0gdm1sRWw7XG4gICAgICAgIH1cblxuICAgICAgICB1cGRhdGVGaWxsQW5kU3Ryb2tlKHZtbEVsLCAnZmlsbCcsIHN0eWxlLCB0aGlzKTtcbiAgICAgICAgdXBkYXRlRmlsbEFuZFN0cm9rZSh2bWxFbCwgJ3N0cm9rZScsIHN0eWxlLCB0aGlzKTtcblxuICAgICAgICB2YXIgbSA9IHRoaXMudHJhbnNmb3JtO1xuICAgICAgICB2YXIgbmVlZFRyYW5zZm9ybSA9IG0gIT0gbnVsbDtcbiAgICAgICAgdmFyIHN0cm9rZUVsID0gdm1sRWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3N0cm9rZScpWzBdO1xuICAgICAgICBpZiAoc3Ryb2tlRWwpIHtcbiAgICAgICAgICAgIHZhciBsaW5lV2lkdGggPSBzdHlsZS5saW5lV2lkdGg7XG4gICAgICAgICAgICAvLyBHZXQgdGhlIGxpbmUgc2NhbGUuXG4gICAgICAgICAgICAvLyBEZXRlcm1pbmFudCBvZiB0aGlzLm1fIG1lYW5zIGhvdyBtdWNoIHRoZSBhcmVhIGlzIGVubGFyZ2VkIGJ5IHRoZVxuICAgICAgICAgICAgLy8gdHJhbnNmb3JtYXRpb24uIFNvIGl0cyBzcXVhcmUgcm9vdCBjYW4gYmUgdXNlZCBhcyBhIHNjYWxlIGZhY3RvclxuICAgICAgICAgICAgLy8gZm9yIHdpZHRoLlxuICAgICAgICAgICAgaWYgKG5lZWRUcmFuc2Zvcm0gJiYgIXN0eWxlLnN0cm9rZU5vU2NhbGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGV0ID0gbVswXSAqIG1bM10gLSBtWzFdICogbVsyXTtcbiAgICAgICAgICAgICAgICBsaW5lV2lkdGggKj0gc3FydChhYnMoZGV0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdHJva2VFbC53ZWlnaHQgPSBsaW5lV2lkdGggKyAncHgnO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHBhdGggPSB0aGlzLnBhdGg7XG4gICAgICAgIGlmICh0aGlzLl9fZGlydHlQYXRoKSB7XG4gICAgICAgICAgICBwYXRoLmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgdGhpcy5idWlsZFBhdGgocGF0aCwgdGhpcy5zaGFwZSk7XG4gICAgICAgICAgICBwYXRoLnRvU3RhdGljKCk7XG4gICAgICAgICAgICB0aGlzLl9fZGlydHlQYXRoID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICB2bWxFbC5wYXRoID0gcGF0aERhdGFUb1N0cmluZyhwYXRoLmRhdGEsIHRoaXMudHJhbnNmb3JtKTtcblxuICAgICAgICB2bWxFbC5zdHlsZS56SW5kZXggPSBnZXRaSW5kZXgodGhpcy56bGV2ZWwsIHRoaXMueiwgdGhpcy56Mik7XG5cbiAgICAgICAgLy8gQXBwZW5kIHRvIHJvb3RcbiAgICAgICAgYXBwZW5kKHZtbFJvb3QsIHZtbEVsKTtcblxuICAgICAgICAvLyBUZXh0XG4gICAgICAgIGlmIChzdHlsZS50ZXh0KSB7XG4gICAgICAgICAgICB0aGlzLmRyYXdSZWN0VGV4dCh2bWxSb290LCB0aGlzLmdldEJvdW5kaW5nUmVjdCgpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlUmVjdFRleHQodm1sUm9vdCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgUGF0aC5wcm90b3R5cGUub25SZW1vdmUgPSBmdW5jdGlvbiAodm1sUm9vdCkge1xuICAgICAgICByZW1vdmUodm1sUm9vdCwgdGhpcy5fdm1sRWwpO1xuICAgICAgICB0aGlzLnJlbW92ZVJlY3RUZXh0KHZtbFJvb3QpO1xuICAgIH07XG5cbiAgICBQYXRoLnByb3RvdHlwZS5vbkFkZCA9IGZ1bmN0aW9uICh2bWxSb290KSB7XG4gICAgICAgIGFwcGVuZCh2bWxSb290LCB0aGlzLl92bWxFbCk7XG4gICAgICAgIHRoaXMuYXBwZW5kUmVjdFRleHQodm1sUm9vdCk7XG4gICAgfTtcblxuICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAgKiBJTUFHRVxuICAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgICB2YXIgaXNJbWFnZSA9IGZ1bmN0aW9uIChpbWcpIHtcbiAgICAgICAgLy8gRklYTUUgaW1nIGluc3RhbmNlb2YgSW1hZ2Ug5aaC5p6cIGltZyDmmK/kuIDkuKrlrZfnrKbkuLLnmoTml7blgJnvvIxJRTgg5LiL5Lya5oql6ZSZXG4gICAgICAgIHJldHVybiAodHlwZW9mIGltZyA9PT0gJ29iamVjdCcpICYmIGltZy50YWdOYW1lICYmIGltZy50YWdOYW1lLnRvVXBwZXJDYXNlKCkgPT09ICdJTUcnO1xuICAgICAgICAvLyByZXR1cm4gaW1nIGluc3RhbmNlb2YgSW1hZ2U7XG4gICAgfTtcblxuICAgIC8vIFJld3JpdGUgdGhlIG9yaWdpbmFsIHBhdGggbWV0aG9kXG4gICAgWkltYWdlLnByb3RvdHlwZS5icnVzaFZNTCA9IGZ1bmN0aW9uICh2bWxSb290KSB7XG4gICAgICAgIHZhciBzdHlsZSA9IHRoaXMuc3R5bGU7XG4gICAgICAgIHZhciBpbWFnZSA9IHN0eWxlLmltYWdlO1xuXG4gICAgICAgIC8vIEltYWdlIG9yaWdpbmFsIHdpZHRoLCBoZWlnaHRcbiAgICAgICAgdmFyIG93O1xuICAgICAgICB2YXIgb2g7XG5cbiAgICAgICAgaWYgKGlzSW1hZ2UoaW1hZ2UpKSB7XG4gICAgICAgICAgICB2YXIgc3JjID0gaW1hZ2Uuc3JjO1xuICAgICAgICAgICAgaWYgKHNyYyA9PT0gdGhpcy5faW1hZ2VTcmMpIHtcbiAgICAgICAgICAgICAgICBvdyA9IHRoaXMuX2ltYWdlV2lkdGg7XG4gICAgICAgICAgICAgICAgb2ggPSB0aGlzLl9pbWFnZUhlaWdodDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBpbWFnZVJ1bnRpbWVTdHlsZSA9IGltYWdlLnJ1bnRpbWVTdHlsZTtcbiAgICAgICAgICAgICAgICB2YXIgb2xkUnVudGltZVdpZHRoID0gaW1hZ2VSdW50aW1lU3R5bGUud2lkdGg7XG4gICAgICAgICAgICAgICAgdmFyIG9sZFJ1bnRpbWVIZWlnaHQgPSBpbWFnZVJ1bnRpbWVTdHlsZS5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgaW1hZ2VSdW50aW1lU3R5bGUud2lkdGggPSAnYXV0byc7XG4gICAgICAgICAgICAgICAgaW1hZ2VSdW50aW1lU3R5bGUuaGVpZ2h0ID0gJ2F1dG8nO1xuXG4gICAgICAgICAgICAgICAgLy8gZ2V0IHRoZSBvcmlnaW5hbCBzaXplXG4gICAgICAgICAgICAgICAgb3cgPSBpbWFnZS53aWR0aDtcbiAgICAgICAgICAgICAgICBvaCA9IGltYWdlLmhlaWdodDtcblxuICAgICAgICAgICAgICAgIC8vIGFuZCByZW1vdmUgb3ZlcmlkZXNcbiAgICAgICAgICAgICAgICBpbWFnZVJ1bnRpbWVTdHlsZS53aWR0aCA9IG9sZFJ1bnRpbWVXaWR0aDtcbiAgICAgICAgICAgICAgICBpbWFnZVJ1bnRpbWVTdHlsZS5oZWlnaHQgPSBvbGRSdW50aW1lSGVpZ2h0O1xuXG4gICAgICAgICAgICAgICAgLy8gQ2FjaGluZyBpbWFnZSBvcmlnaW5hbCB3aWR0aCwgaGVpZ2h0IGFuZCBzcmNcbiAgICAgICAgICAgICAgICB0aGlzLl9pbWFnZVNyYyA9IHNyYztcbiAgICAgICAgICAgICAgICB0aGlzLl9pbWFnZVdpZHRoID0gb3c7XG4gICAgICAgICAgICAgICAgdGhpcy5faW1hZ2VIZWlnaHQgPSBvaDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGltYWdlID0gc3JjO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGltYWdlID09PSB0aGlzLl9pbWFnZVNyYykge1xuICAgICAgICAgICAgICAgIG93ID0gdGhpcy5faW1hZ2VXaWR0aDtcbiAgICAgICAgICAgICAgICBvaCA9IHRoaXMuX2ltYWdlSGVpZ2h0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghaW1hZ2UpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB4ID0gc3R5bGUueCB8fCAwO1xuICAgICAgICB2YXIgeSA9IHN0eWxlLnkgfHwgMDtcblxuICAgICAgICB2YXIgZHcgPSBzdHlsZS53aWR0aDtcbiAgICAgICAgdmFyIGRoID0gc3R5bGUuaGVpZ2h0O1xuXG4gICAgICAgIHZhciBzdyA9IHN0eWxlLnNXaWR0aDtcbiAgICAgICAgdmFyIHNoID0gc3R5bGUuc0hlaWdodDtcbiAgICAgICAgdmFyIHN4ID0gc3R5bGUuc3ggfHwgMDtcbiAgICAgICAgdmFyIHN5ID0gc3R5bGUuc3kgfHwgMDtcblxuICAgICAgICB2YXIgaGFzQ3JvcCA9IHN3ICYmIHNoO1xuXG4gICAgICAgIHZhciB2bWxFbCA9IHRoaXMuX3ZtbEVsO1xuICAgICAgICBpZiAoIXZtbEVsKSB7XG4gICAgICAgICAgICAvLyBGSVhNRSDkvb/nlKggZ3JvdXAg5ZyoIGxlZnQsIHRvcCDpg73kuI3mmK8gMCDnmoTml7blgJnlsLHml6Dms5XmmL7npLrkuobjgIJcbiAgICAgICAgICAgIC8vIHZtbEVsID0gdm1sQ29yZS5jcmVhdGVOb2RlKCdncm91cCcpO1xuICAgICAgICAgICAgdm1sRWwgPSB2bWxDb3JlLmRvYy5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgIGluaXRSb290RWxTdHlsZSh2bWxFbCk7XG5cbiAgICAgICAgICAgIHRoaXMuX3ZtbEVsID0gdm1sRWw7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdm1sRWxTdHlsZSA9IHZtbEVsLnN0eWxlO1xuICAgICAgICB2YXIgaGFzUm90YXRpb24gPSBmYWxzZTtcbiAgICAgICAgdmFyIG07XG4gICAgICAgIHZhciBzY2FsZVggPSAxO1xuICAgICAgICB2YXIgc2NhbGVZID0gMTtcbiAgICAgICAgaWYgKHRoaXMudHJhbnNmb3JtKSB7XG4gICAgICAgICAgICBtID0gdGhpcy50cmFuc2Zvcm07XG4gICAgICAgICAgICBzY2FsZVggPSBzcXJ0KG1bMF0gKiBtWzBdICsgbVsxXSAqIG1bMV0pO1xuICAgICAgICAgICAgc2NhbGVZID0gc3FydChtWzJdICogbVsyXSArIG1bM10gKiBtWzNdKTtcblxuICAgICAgICAgICAgaGFzUm90YXRpb24gPSBtWzFdIHx8IG1bMl07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhhc1JvdGF0aW9uKSB7XG4gICAgICAgICAgICAvLyBJZiBmaWx0ZXJzIGFyZSBuZWNlc3NhcnkgKHJvdGF0aW9uIGV4aXN0cyksIGNyZWF0ZSB0aGVtXG4gICAgICAgICAgICAvLyBmaWx0ZXJzIGFyZSBib2ctc2xvdywgc28gb25seSBjcmVhdGUgdGhlbSBpZiBhYmJzb2x1dGVseSBuZWNlc3NhcnlcbiAgICAgICAgICAgIC8vIFRoZSBmb2xsb3dpbmcgY2hlY2sgZG9lc24ndCBhY2NvdW50IGZvciBza2V3cyAod2hpY2ggZG9uJ3QgZXhpc3RcbiAgICAgICAgICAgIC8vIGluIHRoZSBjYW52YXMgc3BlYyAoeWV0KSBhbnl3YXkuXG4gICAgICAgICAgICAvLyBGcm9tIGV4Y2FudmFzXG4gICAgICAgICAgICB2YXIgcDAgPSBbeCwgeV07XG4gICAgICAgICAgICB2YXIgcDEgPSBbeCArIGR3LCB5XTtcbiAgICAgICAgICAgIHZhciBwMiA9IFt4LCB5ICsgZGhdO1xuICAgICAgICAgICAgdmFyIHAzID0gW3ggKyBkdywgeSArIGRoXTtcbiAgICAgICAgICAgIGFwcGx5VHJhbnNmb3JtKHAwLCBwMCwgbSk7XG4gICAgICAgICAgICBhcHBseVRyYW5zZm9ybShwMSwgcDEsIG0pO1xuICAgICAgICAgICAgYXBwbHlUcmFuc2Zvcm0ocDIsIHAyLCBtKTtcbiAgICAgICAgICAgIGFwcGx5VHJhbnNmb3JtKHAzLCBwMywgbSk7XG5cbiAgICAgICAgICAgIHZhciBtYXhYID0gbWF0aE1heChwMFswXSwgcDFbMF0sIHAyWzBdLCBwM1swXSk7XG4gICAgICAgICAgICB2YXIgbWF4WSA9IG1hdGhNYXgocDBbMV0sIHAxWzFdLCBwMlsxXSwgcDNbMV0pO1xuXG4gICAgICAgICAgICB2YXIgdHJhbnNmb3JtRmlsdGVyID0gW107XG4gICAgICAgICAgICB0cmFuc2Zvcm1GaWx0ZXIucHVzaCgnTTExPScsIG1bMF0gLyBzY2FsZVgsIGNvbW1hLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ00xMj0nLCBtWzJdIC8gc2NhbGVZLCBjb21tYSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdNMjE9JywgbVsxXSAvIHNjYWxlWCwgY29tbWEsXG4gICAgICAgICAgICAgICAgICAgICAgICAnTTIyPScsIG1bM10gLyBzY2FsZVksIGNvbW1hLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0R4PScsIHJvdW5kKHggKiBzY2FsZVggKyBtWzRdKSwgY29tbWEsXG4gICAgICAgICAgICAgICAgICAgICAgICAnRHk9Jywgcm91bmQoeSAqIHNjYWxlWSArIG1bNV0pKTtcblxuICAgICAgICAgICAgdm1sRWxTdHlsZS5wYWRkaW5nID0gJzAgJyArIHJvdW5kKG1heFgpICsgJ3B4ICcgKyByb3VuZChtYXhZKSArICdweCAwJztcbiAgICAgICAgICAgIC8vIEZJWE1FIERYSW1hZ2VUcmFuc2Zvcm0g5ZyoIElFMTEg55qE5YW85a655qih5byP5LiL5LiN6LW35L2c55SoXG4gICAgICAgICAgICB2bWxFbFN0eWxlLmZpbHRlciA9IGltYWdlVHJhbnNmb3JtUHJlZml4ICsgJy5NYXRyaXgoJ1xuICAgICAgICAgICAgICAgICsgdHJhbnNmb3JtRmlsdGVyLmpvaW4oJycpICsgJywgU2l6aW5nTWV0aG9kPWNsaXApJztcblxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKG0pIHtcbiAgICAgICAgICAgICAgICB4ID0geCAqIHNjYWxlWCArIG1bNF07XG4gICAgICAgICAgICAgICAgeSA9IHkgKiBzY2FsZVkgKyBtWzVdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdm1sRWxTdHlsZS5maWx0ZXIgPSAnJztcbiAgICAgICAgICAgIHZtbEVsU3R5bGUubGVmdCA9IHJvdW5kKHgpICsgJ3B4JztcbiAgICAgICAgICAgIHZtbEVsU3R5bGUudG9wID0gcm91bmQoeSkgKyAncHgnO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGltYWdlRWwgPSB0aGlzLl9pbWFnZUVsO1xuICAgICAgICB2YXIgY3JvcEVsID0gdGhpcy5fY3JvcEVsO1xuXG4gICAgICAgIGlmICghaW1hZ2VFbCkge1xuICAgICAgICAgICAgaW1hZ2VFbCA9IHZtbENvcmUuZG9jLmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgdGhpcy5faW1hZ2VFbCA9IGltYWdlRWw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGltYWdlRUxTdHlsZSA9IGltYWdlRWwuc3R5bGU7XG4gICAgICAgIGlmIChoYXNDcm9wKSB7XG4gICAgICAgICAgICAvLyBOZWVkcyBrbm93IGltYWdlIG9yaWdpbmFsIHdpZHRoIGFuZCBoZWlnaHRcbiAgICAgICAgICAgIGlmICghIChvdyAmJiBvaCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgdG1wSW1hZ2UgPSBuZXcgSW1hZ2UoKTtcbiAgICAgICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICAgICAgdG1wSW1hZ2Uub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB0bXBJbWFnZS5vbmxvYWQgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBvdyA9IHRtcEltYWdlLndpZHRoO1xuICAgICAgICAgICAgICAgICAgICBvaCA9IHRtcEltYWdlLmhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgLy8gQWRqdXN0IGltYWdlIHdpZHRoIGFuZCBoZWlnaHQgdG8gZml0IHRoZSByYXRpbyBkZXN0aW5hdGlvblNpemUgLyBzb3VyY2VTaXplXG4gICAgICAgICAgICAgICAgICAgIGltYWdlRUxTdHlsZS53aWR0aCA9IHJvdW5kKHNjYWxlWCAqIG93ICogZHcgLyBzdykgKyAncHgnO1xuICAgICAgICAgICAgICAgICAgICBpbWFnZUVMU3R5bGUuaGVpZ2h0ID0gcm91bmQoc2NhbGVZICogb2ggKiBkaCAvIHNoKSArICdweCc7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQ2FjaGluZyBpbWFnZSBvcmlnaW5hbCB3aWR0aCwgaGVpZ2h0IGFuZCBzcmNcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5faW1hZ2VXaWR0aCA9IG93O1xuICAgICAgICAgICAgICAgICAgICBzZWxmLl9pbWFnZUhlaWdodCA9IG9oO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLl9pbWFnZVNyYyA9IGltYWdlO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdG1wSW1hZ2Uuc3JjID0gaW1hZ2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbWFnZUVMU3R5bGUud2lkdGggPSByb3VuZChzY2FsZVggKiBvdyAqIGR3IC8gc3cpICsgJ3B4JztcbiAgICAgICAgICAgICAgICBpbWFnZUVMU3R5bGUuaGVpZ2h0ID0gcm91bmQoc2NhbGVZICogb2ggKiBkaCAvIHNoKSArICdweCc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghIGNyb3BFbCkge1xuICAgICAgICAgICAgICAgIGNyb3BFbCA9IHZtbENvcmUuZG9jLmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgICAgIGNyb3BFbC5zdHlsZS5vdmVyZmxvdyA9ICdoaWRkZW4nO1xuICAgICAgICAgICAgICAgIHRoaXMuX2Nyb3BFbCA9IGNyb3BFbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBjcm9wRWxTdHlsZSA9IGNyb3BFbC5zdHlsZTtcbiAgICAgICAgICAgIGNyb3BFbFN0eWxlLndpZHRoID0gcm91bmQoKGR3ICsgc3ggKiBkdyAvIHN3KSAqIHNjYWxlWCk7XG4gICAgICAgICAgICBjcm9wRWxTdHlsZS5oZWlnaHQgPSByb3VuZCgoZGggKyBzeSAqIGRoIC8gc2gpICogc2NhbGVZKTtcbiAgICAgICAgICAgIGNyb3BFbFN0eWxlLmZpbHRlciA9IGltYWdlVHJhbnNmb3JtUHJlZml4ICsgJy5NYXRyaXgoRHg9J1xuICAgICAgICAgICAgICAgICAgICArICgtc3ggKiBkdyAvIHN3ICogc2NhbGVYKSArICcsRHk9JyArICgtc3kgKiBkaCAvIHNoICogc2NhbGVZKSArICcpJztcblxuICAgICAgICAgICAgaWYgKCEgY3JvcEVsLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICB2bWxFbC5hcHBlbmRDaGlsZChjcm9wRWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGltYWdlRWwucGFyZW50Tm9kZSAhPSBjcm9wRWwpIHtcbiAgICAgICAgICAgICAgICBjcm9wRWwuYXBwZW5kQ2hpbGQoaW1hZ2VFbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpbWFnZUVMU3R5bGUud2lkdGggPSByb3VuZChzY2FsZVggKiBkdykgKyAncHgnO1xuICAgICAgICAgICAgaW1hZ2VFTFN0eWxlLmhlaWdodCA9IHJvdW5kKHNjYWxlWSAqIGRoKSArICdweCc7XG5cbiAgICAgICAgICAgIHZtbEVsLmFwcGVuZENoaWxkKGltYWdlRWwpO1xuXG4gICAgICAgICAgICBpZiAoY3JvcEVsICYmIGNyb3BFbC5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgdm1sRWwucmVtb3ZlQ2hpbGQoY3JvcEVsKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9jcm9wRWwgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGZpbHRlclN0ciA9ICcnO1xuICAgICAgICB2YXIgYWxwaGEgPSBzdHlsZS5vcGFjaXR5O1xuICAgICAgICBpZiAoYWxwaGEgPCAxKSB7XG4gICAgICAgICAgICBmaWx0ZXJTdHIgKz0gJy5BbHBoYShvcGFjaXR5PScgKyByb3VuZChhbHBoYSAqIDEwMCkgKyAnKSAnO1xuICAgICAgICB9XG4gICAgICAgIGZpbHRlclN0ciArPSBpbWFnZVRyYW5zZm9ybVByZWZpeCArICcuQWxwaGFJbWFnZUxvYWRlcihzcmM9JyArIGltYWdlICsgJywgU2l6aW5nTWV0aG9kPXNjYWxlKSc7XG5cbiAgICAgICAgaW1hZ2VFTFN0eWxlLmZpbHRlciA9IGZpbHRlclN0cjtcblxuICAgICAgICB2bWxFbC5zdHlsZS56SW5kZXggPSBnZXRaSW5kZXgodGhpcy56bGV2ZWwsIHRoaXMueiwgdGhpcy56Mik7XG5cbiAgICAgICAgLy8gQXBwZW5kIHRvIHJvb3RcbiAgICAgICAgYXBwZW5kKHZtbFJvb3QsIHZtbEVsKTtcblxuICAgICAgICAvLyBUZXh0XG4gICAgICAgIGlmIChzdHlsZS50ZXh0KSB7XG4gICAgICAgICAgICB0aGlzLmRyYXdSZWN0VGV4dCh2bWxSb290LCB0aGlzLmdldEJvdW5kaW5nUmVjdCgpKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBaSW1hZ2UucHJvdG90eXBlLm9uUmVtb3ZlID0gZnVuY3Rpb24gKHZtbFJvb3QpIHtcbiAgICAgICAgcmVtb3ZlKHZtbFJvb3QsIHRoaXMuX3ZtbEVsKTtcblxuICAgICAgICB0aGlzLl92bWxFbCA9IG51bGw7XG4gICAgICAgIHRoaXMuX2Nyb3BFbCA9IG51bGw7XG4gICAgICAgIHRoaXMuX2ltYWdlRWwgPSBudWxsO1xuXG4gICAgICAgIHRoaXMucmVtb3ZlUmVjdFRleHQodm1sUm9vdCk7XG4gICAgfTtcblxuICAgIFpJbWFnZS5wcm90b3R5cGUub25BZGQgPSBmdW5jdGlvbiAodm1sUm9vdCkge1xuICAgICAgICBhcHBlbmQodm1sUm9vdCwgdGhpcy5fdm1sRWwpO1xuICAgICAgICB0aGlzLmFwcGVuZFJlY3RUZXh0KHZtbFJvb3QpO1xuICAgIH07XG5cblxuICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAgKiBURVhUXG4gICAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgdmFyIERFRkFVTFRfU1RZTEVfTk9STUFMID0gJ25vcm1hbCc7XG5cbiAgICB2YXIgZm9udFN0eWxlQ2FjaGUgPSB7fTtcbiAgICB2YXIgZm9udFN0eWxlQ2FjaGVDb3VudCA9IDA7XG4gICAgdmFyIE1BWF9GT05UX0NBQ0hFX1NJWkUgPSAxMDA7XG4gICAgdmFyIGZvbnRFbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXG4gICAgdmFyIGdldEZvbnRTdHlsZSA9IGZ1bmN0aW9uIChmb250U3RyaW5nKSB7XG4gICAgICAgIHZhciBmb250U3R5bGUgPSBmb250U3R5bGVDYWNoZVtmb250U3RyaW5nXTtcbiAgICAgICAgaWYgKCFmb250U3R5bGUpIHtcbiAgICAgICAgICAgIC8vIENsZWFyIGNhY2hlXG4gICAgICAgICAgICBpZiAoZm9udFN0eWxlQ2FjaGVDb3VudCA+IE1BWF9GT05UX0NBQ0hFX1NJWkUpIHtcbiAgICAgICAgICAgICAgICBmb250U3R5bGVDYWNoZUNvdW50ID0gMDtcbiAgICAgICAgICAgICAgICBmb250U3R5bGVDYWNoZSA9IHt9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgc3R5bGUgPSBmb250RWwuc3R5bGU7XG4gICAgICAgICAgICB2YXIgZm9udEZhbWlseTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgc3R5bGUuZm9udCA9IGZvbnRTdHJpbmc7XG4gICAgICAgICAgICAgICAgZm9udEZhbWlseSA9IHN0eWxlLmZvbnRGYW1pbHkuc3BsaXQoJywnKVswXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvbnRTdHlsZSA9IHtcbiAgICAgICAgICAgICAgICBzdHlsZTogc3R5bGUuZm9udFN0eWxlIHx8IERFRkFVTFRfU1RZTEVfTk9STUFMLFxuICAgICAgICAgICAgICAgIHZhcmlhbnQ6IHN0eWxlLmZvbnRWYXJpYW50IHx8IERFRkFVTFRfU1RZTEVfTk9STUFMLFxuICAgICAgICAgICAgICAgIHdlaWdodDogc3R5bGUuZm9udFdlaWdodCB8fCBERUZBVUxUX1NUWUxFX05PUk1BTCxcbiAgICAgICAgICAgICAgICBzaXplOiBwYXJzZUZsb2F0KHN0eWxlLmZvbnRTaXplIHx8IDEyKSB8IDAsXG4gICAgICAgICAgICAgICAgZmFtaWx5OiBmb250RmFtaWx5IHx8ICdNaWNyb3NvZnQgWWFIZWknXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBmb250U3R5bGVDYWNoZVtmb250U3RyaW5nXSA9IGZvbnRTdHlsZTtcbiAgICAgICAgICAgIGZvbnRTdHlsZUNhY2hlQ291bnQrKztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm9udFN0eWxlO1xuICAgIH07XG5cbiAgICB2YXIgdGV4dE1lYXN1cmVFbDtcbiAgICAvLyBPdmVyd3JpdGUgbWVhc3VyZSB0ZXh0IG1ldGhvZFxuICAgIHRleHRDb250YWluLm1lYXN1cmVUZXh0ID0gZnVuY3Rpb24gKHRleHQsIHRleHRGb250KSB7XG4gICAgICAgIHZhciBkb2MgPSB2bWxDb3JlLmRvYztcbiAgICAgICAgaWYgKCF0ZXh0TWVhc3VyZUVsKSB7XG4gICAgICAgICAgICB0ZXh0TWVhc3VyZUVsID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgdGV4dE1lYXN1cmVFbC5zdHlsZS5jc3NUZXh0ID0gJ3Bvc2l0aW9uOmFic29sdXRlO3RvcDotMjAwMDBweDtsZWZ0OjA7J1xuICAgICAgICAgICAgICAgICsgJ3BhZGRpbmc6MDttYXJnaW46MDtib3JkZXI6bm9uZTt3aGl0ZS1zcGFjZTpwcmU7JztcbiAgICAgICAgICAgIHZtbENvcmUuZG9jLmJvZHkuYXBwZW5kQ2hpbGQodGV4dE1lYXN1cmVFbCk7XG4gICAgICAgIH1cblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGV4dE1lYXN1cmVFbC5zdHlsZS5mb250ID0gdGV4dEZvbnQ7XG4gICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgICAvLyBJZ25vcmUgZmFpbHVyZXMgdG8gc2V0IHRvIGludmFsaWQgZm9udC5cbiAgICAgICAgfVxuICAgICAgICB0ZXh0TWVhc3VyZUVsLmlubmVySFRNTCA9ICcnO1xuICAgICAgICAvLyBEb24ndCB1c2UgaW5uZXJIVE1MIG9yIGlubmVyVGV4dCBiZWNhdXNlIHRoZXkgYWxsb3cgbWFya3VwL3doaXRlc3BhY2UuXG4gICAgICAgIHRleHRNZWFzdXJlRWwuYXBwZW5kQ2hpbGQoZG9jLmNyZWF0ZVRleHROb2RlKHRleHQpKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHdpZHRoOiB0ZXh0TWVhc3VyZUVsLm9mZnNldFdpZHRoXG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciB0bXBSZWN0ID0gbmV3IEJvdW5kaW5nUmVjdCgpO1xuXG4gICAgdmFyIGRyYXdSZWN0VGV4dCA9IGZ1bmN0aW9uICh2bWxSb290LCByZWN0LCB0ZXh0UmVjdCwgZnJvbVRleHRFbCkge1xuXG4gICAgICAgIHZhciBzdHlsZSA9IHRoaXMuc3R5bGU7XG4gICAgICAgIHZhciB0ZXh0ID0gc3R5bGUudGV4dDtcbiAgICAgICAgaWYgKCF0ZXh0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgeDtcbiAgICAgICAgdmFyIHk7XG4gICAgICAgIHZhciBhbGlnbiA9IHN0eWxlLnRleHRBbGlnbjtcbiAgICAgICAgdmFyIGZvbnRTdHlsZSA9IGdldEZvbnRTdHlsZShzdHlsZS50ZXh0Rm9udCk7XG4gICAgICAgIC8vIEZJWE1FIGVuY29kZUh0bWxBdHRyaWJ1dGUgP1xuICAgICAgICB2YXIgZm9udCA9IGZvbnRTdHlsZS5zdHlsZSArICcgJyArIGZvbnRTdHlsZS52YXJpYW50ICsgJyAnICsgZm9udFN0eWxlLndlaWdodCArICcgJ1xuICAgICAgICAgICAgKyBmb250U3R5bGUuc2l6ZSArICdweCBcIicgKyBmb250U3R5bGUuZmFtaWx5ICsgJ1wiJztcblxuICAgICAgICB2YXIgYmFzZWxpbmUgPSBzdHlsZS50ZXh0QmFzZWxpbmU7XG4gICAgICAgIHZhciB2ZXJ0aWNhbEFsaWduID0gc3R5bGUudGV4dFZlcnRpY2FsQWxpZ247XG5cbiAgICAgICAgdGV4dFJlY3QgPSB0ZXh0UmVjdCB8fCB0ZXh0Q29udGFpbi5nZXRCb3VuZGluZ1JlY3QodGV4dCwgZm9udCwgYWxpZ24sIGJhc2VsaW5lKTtcblxuICAgICAgICAvLyBUcmFuc2Zvcm0gcmVjdCB0byB2aWV3IHNwYWNlXG4gICAgICAgIHZhciBtID0gdGhpcy50cmFuc2Zvcm07XG4gICAgICAgIC8vIElnbm9yZSB0cmFuc2Zvcm0gZm9yIHRleHQgaW4gb3RoZXIgZWxlbWVudFxuICAgICAgICBpZiAobSAmJiAhZnJvbVRleHRFbCkge1xuICAgICAgICAgICAgdG1wUmVjdC5jb3B5KHJlY3QpO1xuICAgICAgICAgICAgdG1wUmVjdC5hcHBseVRyYW5zZm9ybShtKTtcbiAgICAgICAgICAgIHJlY3QgPSB0bXBSZWN0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFmcm9tVGV4dEVsKSB7XG4gICAgICAgICAgICB2YXIgdGV4dFBvc2l0aW9uID0gc3R5bGUudGV4dFBvc2l0aW9uO1xuICAgICAgICAgICAgdmFyIGRpc3RhbmNlID0gc3R5bGUudGV4dERpc3RhbmNlO1xuICAgICAgICAgICAgLy8gVGV4dCBwb3NpdGlvbiByZXByZXNlbnRlZCBieSBjb29yZFxuICAgICAgICAgICAgaWYgKHRleHRQb3NpdGlvbiBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICAgICAgeCA9IHJlY3QueCArIHBhcnNlUGVyY2VudCh0ZXh0UG9zaXRpb25bMF0sIHJlY3Qud2lkdGgpO1xuICAgICAgICAgICAgICAgIHkgPSByZWN0LnkgKyBwYXJzZVBlcmNlbnQodGV4dFBvc2l0aW9uWzFdLCByZWN0LmhlaWdodCk7XG5cbiAgICAgICAgICAgICAgICBhbGlnbiA9IGFsaWduIHx8ICdsZWZ0JztcbiAgICAgICAgICAgICAgICBiYXNlbGluZSA9IGJhc2VsaW5lIHx8ICd0b3AnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlcyA9IHRleHRDb250YWluLmFkanVzdFRleHRQb3NpdGlvbk9uUmVjdChcbiAgICAgICAgICAgICAgICAgICAgdGV4dFBvc2l0aW9uLCByZWN0LCB0ZXh0UmVjdCwgZGlzdGFuY2VcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHggPSByZXMueDtcbiAgICAgICAgICAgICAgICB5ID0gcmVzLnk7XG5cbiAgICAgICAgICAgICAgICAvLyBEZWZhdWx0IGFsaWduIGFuZCBiYXNlbGluZSB3aGVuIGhhcyB0ZXh0UG9zaXRpb25cbiAgICAgICAgICAgICAgICBhbGlnbiA9IGFsaWduIHx8IHJlcy50ZXh0QWxpZ247XG4gICAgICAgICAgICAgICAgYmFzZWxpbmUgPSBiYXNlbGluZSB8fCByZXMudGV4dEJhc2VsaW5lO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgeCA9IHJlY3QueDtcbiAgICAgICAgICAgIHkgPSByZWN0Lnk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZlcnRpY2FsQWxpZ24pIHtcbiAgICAgICAgICAgIHN3aXRjaCAodmVydGljYWxBbGlnbikge1xuICAgICAgICAgICAgICAgIGNhc2UgJ21pZGRsZSc6XG4gICAgICAgICAgICAgICAgICAgIHkgLT0gdGV4dFJlY3QuaGVpZ2h0IC8gMjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnYm90dG9tJzpcbiAgICAgICAgICAgICAgICAgICAgeSAtPSB0ZXh0UmVjdC5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIC8vICd0b3AnXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZ25vcmUgYmFzZWxpbmVcbiAgICAgICAgICAgIGJhc2VsaW5lID0gJ3RvcCc7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZm9udFNpemUgPSBmb250U3R5bGUuc2l6ZTtcbiAgICAgICAgLy8gMS43NSBpcyBhbiBhcmJpdHJhcnkgbnVtYmVyLCBhcyB0aGVyZSBpcyBubyBpbmZvIGFib3V0IHRoZSB0ZXh0IGJhc2VsaW5lXG4gICAgICAgIHN3aXRjaCAoYmFzZWxpbmUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2hhbmdpbmcnOlxuICAgICAgICAgICAgY2FzZSAndG9wJzpcbiAgICAgICAgICAgICAgICB5ICs9IGZvbnRTaXplIC8gMS43NTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ21pZGRsZSc6XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgLy8gY2FzZSBudWxsOlxuICAgICAgICAgICAgLy8gY2FzZSAnYWxwaGFiZXRpYyc6XG4gICAgICAgICAgICAvLyBjYXNlICdpZGVvZ3JhcGhpYyc6XG4gICAgICAgICAgICAvLyBjYXNlICdib3R0b20nOlxuICAgICAgICAgICAgICAgIHkgLT0gZm9udFNpemUgLyAyLjI1O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAoYWxpZ24pIHtcbiAgICAgICAgICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnY2VudGVyJzpcbiAgICAgICAgICAgICAgICB4IC09IHRleHRSZWN0LndpZHRoIC8gMjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgICAgICAgICB4IC09IHRleHRSZWN0LndpZHRoO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgLy8gY2FzZSAnZW5kJzpcbiAgICAgICAgICAgICAgICAvLyBhbGlnbiA9IGVsZW1lbnRTdHlsZS5kaXJlY3Rpb24gPT0gJ2x0cicgPyAncmlnaHQnIDogJ2xlZnQnO1xuICAgICAgICAgICAgICAgIC8vIGJyZWFrO1xuICAgICAgICAgICAgLy8gY2FzZSAnc3RhcnQnOlxuICAgICAgICAgICAgICAgIC8vIGFsaWduID0gZWxlbWVudFN0eWxlLmRpcmVjdGlvbiA9PSAncnRsJyA/ICdyaWdodCcgOiAnbGVmdCc7XG4gICAgICAgICAgICAgICAgLy8gYnJlYWs7XG4gICAgICAgICAgICAvLyBkZWZhdWx0OlxuICAgICAgICAgICAgLy8gICAgIGFsaWduID0gJ2xlZnQnO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNyZWF0ZU5vZGUgPSB2bWxDb3JlLmNyZWF0ZU5vZGU7XG5cbiAgICAgICAgdmFyIHRleHRWbWxFbCA9IHRoaXMuX3RleHRWbWxFbDtcbiAgICAgICAgdmFyIHBhdGhFbDtcbiAgICAgICAgdmFyIHRleHRQYXRoRWw7XG4gICAgICAgIHZhciBza2V3RWw7XG4gICAgICAgIGlmICghdGV4dFZtbEVsKSB7XG4gICAgICAgICAgICB0ZXh0Vm1sRWwgPSBjcmVhdGVOb2RlKCdsaW5lJyk7XG4gICAgICAgICAgICBwYXRoRWwgPSBjcmVhdGVOb2RlKCdwYXRoJyk7XG4gICAgICAgICAgICB0ZXh0UGF0aEVsID0gY3JlYXRlTm9kZSgndGV4dHBhdGgnKTtcbiAgICAgICAgICAgIHNrZXdFbCA9IGNyZWF0ZU5vZGUoJ3NrZXcnKTtcblxuICAgICAgICAgICAgLy8gRklYTUUgV2h5IGhlcmUgaXMgbm90IGNhbW1lbCBjYXNlXG4gICAgICAgICAgICAvLyBBbGlnbiAnY2VudGVyJyBzZWVtcyB3cm9uZ1xuICAgICAgICAgICAgdGV4dFBhdGhFbC5zdHlsZVsndi10ZXh0LWFsaWduJ10gPSAnbGVmdCc7XG5cbiAgICAgICAgICAgIGluaXRSb290RWxTdHlsZSh0ZXh0Vm1sRWwpO1xuXG4gICAgICAgICAgICBwYXRoRWwudGV4dHBhdGhvayA9IHRydWU7XG4gICAgICAgICAgICB0ZXh0UGF0aEVsLm9uID0gdHJ1ZTtcblxuICAgICAgICAgICAgdGV4dFZtbEVsLmZyb20gPSAnMCAwJztcbiAgICAgICAgICAgIHRleHRWbWxFbC50byA9ICcxMDAwIDAuMDUnO1xuXG4gICAgICAgICAgICBhcHBlbmQodGV4dFZtbEVsLCBza2V3RWwpO1xuICAgICAgICAgICAgYXBwZW5kKHRleHRWbWxFbCwgcGF0aEVsKTtcbiAgICAgICAgICAgIGFwcGVuZCh0ZXh0Vm1sRWwsIHRleHRQYXRoRWwpO1xuXG4gICAgICAgICAgICB0aGlzLl90ZXh0Vm1sRWwgPSB0ZXh0Vm1sRWw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyDov5nph4zmmK/lnKjliY3pnaIgYXBwZW5kQ2hpbGQg5L+d6K+B6aG65bqP55qE5YmN5o+Q5LiLXG4gICAgICAgICAgICBza2V3RWwgPSB0ZXh0Vm1sRWwuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgIHBhdGhFbCA9IHNrZXdFbC5uZXh0U2libGluZztcbiAgICAgICAgICAgIHRleHRQYXRoRWwgPSBwYXRoRWwubmV4dFNpYmxpbmc7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY29vcmRzID0gW3gsIHldO1xuICAgICAgICB2YXIgdGV4dFZtbEVsU3R5bGUgPSB0ZXh0Vm1sRWwuc3R5bGU7XG4gICAgICAgIC8vIElnbm9yZSB0cmFuc2Zvcm0gZm9yIHRleHQgaW4gb3RoZXIgZWxlbWVudFxuICAgICAgICBpZiAobSAmJiBmcm9tVGV4dEVsKSB7XG4gICAgICAgICAgICBhcHBseVRyYW5zZm9ybShjb29yZHMsIGNvb3JkcywgbSk7XG5cbiAgICAgICAgICAgIHNrZXdFbC5vbiA9IHRydWU7XG5cbiAgICAgICAgICAgIHNrZXdFbC5tYXRyaXggPSBtWzBdLnRvRml4ZWQoMykgKyBjb21tYSArIG1bMl0udG9GaXhlZCgzKSArIGNvbW1hICtcbiAgICAgICAgICAgIG1bMV0udG9GaXhlZCgzKSArIGNvbW1hICsgbVszXS50b0ZpeGVkKDMpICsgJywwLDAnO1xuXG4gICAgICAgICAgICAvLyBUZXh0IHBvc2l0aW9uXG4gICAgICAgICAgICBza2V3RWwub2Zmc2V0ID0gKHJvdW5kKGNvb3Jkc1swXSkgfHwgMCkgKyAnLCcgKyAocm91bmQoY29vcmRzWzFdKSB8fCAwKTtcbiAgICAgICAgICAgIC8vIExlZnQgdG9wIHBvaW50IGFzIG9yaWdpblxuICAgICAgICAgICAgc2tld0VsLm9yaWdpbiA9ICcwIDAnO1xuXG4gICAgICAgICAgICB0ZXh0Vm1sRWxTdHlsZS5sZWZ0ID0gJzBweCc7XG4gICAgICAgICAgICB0ZXh0Vm1sRWxTdHlsZS50b3AgPSAnMHB4JztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNrZXdFbC5vbiA9IGZhbHNlO1xuICAgICAgICAgICAgdGV4dFZtbEVsU3R5bGUubGVmdCA9IHJvdW5kKHgpICsgJ3B4JztcbiAgICAgICAgICAgIHRleHRWbWxFbFN0eWxlLnRvcCA9IHJvdW5kKHkpICsgJ3B4JztcbiAgICAgICAgfVxuXG4gICAgICAgIHRleHRQYXRoRWwuc3RyaW5nID0gZW5jb2RlSHRtbEF0dHJpYnV0ZSh0ZXh0KTtcbiAgICAgICAgLy8gVE9ET1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGV4dFBhdGhFbC5zdHlsZS5mb250ID0gZm9udDtcbiAgICAgICAgfVxuICAgICAgICAvLyBFcnJvciBmb250IGZvcm1hdFxuICAgICAgICBjYXRjaCAoZSkge31cblxuICAgICAgICB1cGRhdGVGaWxsQW5kU3Ryb2tlKHRleHRWbWxFbCwgJ2ZpbGwnLCB7XG4gICAgICAgICAgICBmaWxsOiBmcm9tVGV4dEVsID8gc3R5bGUuZmlsbCA6IHN0eWxlLnRleHRGaWxsLFxuICAgICAgICAgICAgb3BhY2l0eTogc3R5bGUub3BhY2l0eVxuICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgdXBkYXRlRmlsbEFuZFN0cm9rZSh0ZXh0Vm1sRWwsICdzdHJva2UnLCB7XG4gICAgICAgICAgICBzdHJva2U6IGZyb21UZXh0RWwgPyBzdHlsZS5zdHJva2UgOiBzdHlsZS50ZXh0U3Ryb2tlLFxuICAgICAgICAgICAgb3BhY2l0eTogc3R5bGUub3BhY2l0eSxcbiAgICAgICAgICAgIGxpbmVEYXNoOiBzdHlsZS5saW5lRGFzaFxuICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICB0ZXh0Vm1sRWwuc3R5bGUuekluZGV4ID0gZ2V0WkluZGV4KHRoaXMuemxldmVsLCB0aGlzLnosIHRoaXMuejIpO1xuXG4gICAgICAgIC8vIEF0dGFjaGVkIHRvIHJvb3RcbiAgICAgICAgYXBwZW5kKHZtbFJvb3QsIHRleHRWbWxFbCk7XG4gICAgfTtcblxuICAgIHZhciByZW1vdmVSZWN0VGV4dCA9IGZ1bmN0aW9uICh2bWxSb290KSB7XG4gICAgICAgIHJlbW92ZSh2bWxSb290LCB0aGlzLl90ZXh0Vm1sRWwpO1xuICAgICAgICB0aGlzLl90ZXh0Vm1sRWwgPSBudWxsO1xuICAgIH07XG5cbiAgICB2YXIgYXBwZW5kUmVjdFRleHQgPSBmdW5jdGlvbiAodm1sUm9vdCkge1xuICAgICAgICBhcHBlbmQodm1sUm9vdCwgdGhpcy5fdGV4dFZtbEVsKTtcbiAgICB9O1xuXG4gICAgdmFyIGxpc3QgPSBbUmVjdFRleHQsIERpc3BsYXlhYmxlLCBaSW1hZ2UsIFBhdGgsIFRleHRdO1xuXG4gICAgLy8gSW4gY2FzZSBEaXNwbGF5YWJsZSBoYXMgYmVlbiBtaXhlZCBpbiBSZWN0VGV4dFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcHJvdG8gPSBsaXN0W2ldLnByb3RvdHlwZTtcbiAgICAgICAgcHJvdG8uZHJhd1JlY3RUZXh0ID0gZHJhd1JlY3RUZXh0O1xuICAgICAgICBwcm90by5yZW1vdmVSZWN0VGV4dCA9IHJlbW92ZVJlY3RUZXh0O1xuICAgICAgICBwcm90by5hcHBlbmRSZWN0VGV4dCA9IGFwcGVuZFJlY3RUZXh0O1xuICAgIH1cblxuICAgIFRleHQucHJvdG90eXBlLmJydXNoVk1MID0gZnVuY3Rpb24gKHZtbFJvb3QpIHtcbiAgICAgICAgdmFyIHN0eWxlID0gdGhpcy5zdHlsZTtcbiAgICAgICAgaWYgKHN0eWxlLnRleHQpIHtcbiAgICAgICAgICAgIHRoaXMuZHJhd1JlY3RUZXh0KHZtbFJvb3QsIHtcbiAgICAgICAgICAgICAgICB4OiBzdHlsZS54IHx8IDAsIHk6IHN0eWxlLnkgfHwgMCxcbiAgICAgICAgICAgICAgICB3aWR0aDogMCwgaGVpZ2h0OiAwXG4gICAgICAgICAgICB9LCB0aGlzLmdldEJvdW5kaW5nUmVjdCgpLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlUmVjdFRleHQodm1sUm9vdCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgVGV4dC5wcm90b3R5cGUub25SZW1vdmUgPSBmdW5jdGlvbiAodm1sUm9vdCkge1xuICAgICAgICB0aGlzLnJlbW92ZVJlY3RUZXh0KHZtbFJvb3QpO1xuICAgIH07XG5cbiAgICBUZXh0LnByb3RvdHlwZS5vbkFkZCA9IGZ1bmN0aW9uICh2bWxSb290KSB7XG4gICAgICAgIHRoaXMuYXBwZW5kUmVjdFRleHQodm1sUm9vdCk7XG4gICAgfTtcbn1cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3pyZW5kZXIvbGliL3ZtbC9ncmFwaGljLmpzXG4gKiogbW9kdWxlIGlkID0gMTEwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcblxuaWYgKCFyZXF1aXJlKCcuLi9jb3JlL2VudicpLmNhbnZhc1N1cHBvcnRlZCkge1xuICAgIHZhciB1cm4gPSAndXJuOnNjaGVtYXMtbWljcm9zb2Z0LWNvbTp2bWwnO1xuXG4gICAgdmFyIGNyZWF0ZU5vZGU7XG4gICAgdmFyIHdpbiA9IHdpbmRvdztcbiAgICB2YXIgZG9jID0gd2luLmRvY3VtZW50O1xuXG4gICAgdmFyIHZtbEluaXRlZCA9IGZhbHNlO1xuXG4gICAgdHJ5IHtcbiAgICAgICAgIWRvYy5uYW1lc3BhY2VzLnpydm1sICYmIGRvYy5uYW1lc3BhY2VzLmFkZCgnenJ2bWwnLCB1cm4pO1xuICAgICAgICBjcmVhdGVOb2RlID0gZnVuY3Rpb24gKHRhZ05hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBkb2MuY3JlYXRlRWxlbWVudCgnPHpydm1sOicgKyB0YWdOYW1lICsgJyBjbGFzcz1cInpydm1sXCI+Jyk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIGNyZWF0ZU5vZGUgPSBmdW5jdGlvbiAodGFnTmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIGRvYy5jcmVhdGVFbGVtZW50KCc8JyArIHRhZ05hbWUgKyAnIHhtbG5zPVwiJyArIHVybiArICdcIiBjbGFzcz1cInpydm1sXCI+Jyk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gRnJvbSByYXBoYWVsXG4gICAgdmFyIGluaXRWTUwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh2bWxJbml0ZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2bWxJbml0ZWQgPSB0cnVlO1xuXG4gICAgICAgIHZhciBzdHlsZVNoZWV0cyA9IGRvYy5zdHlsZVNoZWV0cztcbiAgICAgICAgaWYgKHN0eWxlU2hlZXRzLmxlbmd0aCA8IDMxKSB7XG4gICAgICAgICAgICBkb2MuY3JlYXRlU3R5bGVTaGVldCgpLmFkZFJ1bGUoJy56cnZtbCcsICdiZWhhdmlvcjp1cmwoI2RlZmF1bHQjVk1MKScpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L21zNTMxMTk0JTI4VlMuODUlMjkuYXNweFxuICAgICAgICAgICAgc3R5bGVTaGVldHNbMF0uYWRkUnVsZSgnLnpydm1sJywgJ2JlaGF2aW9yOnVybCgjZGVmYXVsdCNWTUwpJyk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gTm90IHVzZWluZyByZXR1cm4gdG8gYXZvaWQgZXJyb3Igd2hlbiBjb252ZXJ0aW5nIHRvIENvbW1vbkpTIG1vZHVsZVxuICAgIG1vZHVsZS5leHBvcnRzID0ge1xuICAgICAgICBkb2M6IGRvYyxcbiAgICAgICAgaW5pdFZNTDogaW5pdFZNTCxcbiAgICAgICAgY3JlYXRlTm9kZTogY3JlYXRlTm9kZVxuICAgIH07XG59XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi96cmVuZGVyL2xpYi92bWwvY29yZS5qc1xuICoqIG1vZHVsZSBpZCA9IDExMVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBWTUwgUGFpbnRlci5cbiAqXG4gKiBAbW9kdWxlIHpyZW5kZXIvdm1sL1BhaW50ZXJcbiAqL1xuXG5cblxuICAgIHZhciB6ckxvZyA9IHJlcXVpcmUoJy4uL2NvcmUvbG9nJyk7XG4gICAgdmFyIHZtbENvcmUgPSByZXF1aXJlKCcuL2NvcmUnKTtcblxuICAgIGZ1bmN0aW9uIHBhcnNlSW50MTAodmFsKSB7XG4gICAgICAgIHJldHVybiBwYXJzZUludCh2YWwsIDEwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAYWxpYXMgbW9kdWxlOnpyZW5kZXIvdm1sL1BhaW50ZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBWTUxQYWludGVyKHJvb3QsIHN0b3JhZ2UpIHtcblxuICAgICAgICB2bWxDb3JlLmluaXRWTUwoKTtcblxuICAgICAgICB0aGlzLnJvb3QgPSByb290O1xuXG4gICAgICAgIHRoaXMuc3RvcmFnZSA9IHN0b3JhZ2U7XG5cbiAgICAgICAgdmFyIHZtbFZpZXdwb3J0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cbiAgICAgICAgdmFyIHZtbFJvb3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblxuICAgICAgICB2bWxWaWV3cG9ydC5zdHlsZS5jc3NUZXh0ID0gJ2Rpc3BsYXk6aW5saW5lLWJsb2NrO292ZXJmbG93OmhpZGRlbjtwb3NpdGlvbjpyZWxhdGl2ZTt3aWR0aDozMDBweDtoZWlnaHQ6MTUwcHg7JztcblxuICAgICAgICB2bWxSb290LnN0eWxlLmNzc1RleHQgPSAncG9zaXRpb246YWJzb2x1dGU7bGVmdDowO3RvcDowOyc7XG5cbiAgICAgICAgcm9vdC5hcHBlbmRDaGlsZCh2bWxWaWV3cG9ydCk7XG5cbiAgICAgICAgdGhpcy5fdm1sUm9vdCA9IHZtbFJvb3Q7XG4gICAgICAgIHRoaXMuX3ZtbFZpZXdwb3J0ID0gdm1sVmlld3BvcnQ7XG5cbiAgICAgICAgdGhpcy5yZXNpemUoKTtcblxuICAgICAgICAvLyBNb2RpZnkgc3RvcmFnZVxuICAgICAgICB2YXIgb2xkRGVsRnJvbU1hcCA9IHN0b3JhZ2UuZGVsRnJvbU1hcDtcbiAgICAgICAgdmFyIG9sZEFkZFRvTWFwID0gc3RvcmFnZS5hZGRUb01hcDtcbiAgICAgICAgc3RvcmFnZS5kZWxGcm9tTWFwID0gZnVuY3Rpb24gKGVsSWQpIHtcbiAgICAgICAgICAgIHZhciBlbCA9IHN0b3JhZ2UuZ2V0KGVsSWQpO1xuXG4gICAgICAgICAgICBvbGREZWxGcm9tTWFwLmNhbGwoc3RvcmFnZSwgZWxJZCk7XG5cbiAgICAgICAgICAgIGlmIChlbCkge1xuICAgICAgICAgICAgICAgIGVsLm9uUmVtb3ZlICYmIGVsLm9uUmVtb3ZlKHZtbFJvb3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHN0b3JhZ2UuYWRkVG9NYXAgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgIC8vIERpc3BsYXlhYmxlIGFscmVhZHkgaGFzIGEgdm1sIG5vZGVcbiAgICAgICAgICAgIGVsLm9uQWRkICYmIGVsLm9uQWRkKHZtbFJvb3QpO1xuXG4gICAgICAgICAgICBvbGRBZGRUb01hcC5jYWxsKHN0b3JhZ2UsIGVsKTtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLl9maXJzdFBhaW50ID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBWTUxQYWludGVyLnByb3RvdHlwZSA9IHtcblxuICAgICAgICBjb25zdHJ1Y3RvcjogVk1MUGFpbnRlcixcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7SFRNTERpdkVsZW1lbnR9XG4gICAgICAgICAqL1xuICAgICAgICBnZXRWaWV3cG9ydFJvb3Q6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl92bWxWaWV3cG9ydDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5Yi35pawXG4gICAgICAgICAqL1xuICAgICAgICByZWZyZXNoOiBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgIHZhciBsaXN0ID0gdGhpcy5zdG9yYWdlLmdldERpc3BsYXlMaXN0KHRydWUsIHRydWUpO1xuXG4gICAgICAgICAgICB0aGlzLl9wYWludExpc3QobGlzdCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX3BhaW50TGlzdDogZnVuY3Rpb24gKGxpc3QpIHtcbiAgICAgICAgICAgIHZhciB2bWxSb290ID0gdGhpcy5fdm1sUm9vdDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBlbCA9IGxpc3RbaV07XG4gICAgICAgICAgICAgICAgaWYgKGVsLmludmlzaWJsZSB8fCBlbC5pZ25vcmUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFlbC5fX2FscmVhZHlOb3RWaXNpYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbC5vblJlbW92ZSh2bWxSb290KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBTZXQgYXMgYWxyZWFkeSBpbnZpc2libGVcbiAgICAgICAgICAgICAgICAgICAgZWwuX19hbHJlYWR5Tm90VmlzaWJsZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZWwuX19hbHJlYWR5Tm90VmlzaWJsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWwub25BZGQodm1sUm9vdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWwuX19hbHJlYWR5Tm90VmlzaWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZWwuX19kaXJ0eSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWwuYmVmb3JlQnJ1c2ggJiYgZWwuYmVmb3JlQnJ1c2goKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIChlbC5icnVzaFZNTCB8fCBlbC5icnVzaCkuY2FsbChlbCwgdm1sUm9vdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbC5hZnRlckJydXNoICYmIGVsLmFmdGVyQnJ1c2goKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbC5fX2RpcnR5ID0gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl9maXJzdFBhaW50KSB7XG4gICAgICAgICAgICAgICAgLy8gRGV0YWNoZWQgZnJvbSBkb2N1bWVudCBhdCBmaXJzdCB0aW1lXG4gICAgICAgICAgICAgICAgLy8gdG8gYXZvaWQgcGFnZSByZWZyZXNoaW5nIHRvbyBtYW55IHRpbWVzXG5cbiAgICAgICAgICAgICAgICAvLyBGSVhNRSDlpoLmnpzmr4/mrKHpg73lhYggcmVtb3ZlQ2hpbGQg5Y+v6IO95Lya5a+86Ie05LiA5Lqb5aGr5YWF5ZKM5o+P6L6555qE5pWI5p6c5pS55Y+YXG4gICAgICAgICAgICAgICAgdGhpcy5fdm1sVmlld3BvcnQuYXBwZW5kQ2hpbGQodm1sUm9vdCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fZmlyc3RQYWludCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHJlc2l6ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHdpZHRoID0gdGhpcy5fZ2V0V2lkdGgoKTtcbiAgICAgICAgICAgIHZhciBoZWlnaHQgPSB0aGlzLl9nZXRIZWlnaHQoKTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuX3dpZHRoICE9IHdpZHRoICYmIHRoaXMuX2hlaWdodCAhPSBoZWlnaHQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl93aWR0aCA9IHdpZHRoO1xuICAgICAgICAgICAgICAgIHRoaXMuX2hlaWdodCA9IGhlaWdodDtcblxuICAgICAgICAgICAgICAgIHZhciB2bWxWaWV3cG9ydFN0eWxlID0gdGhpcy5fdm1sVmlld3BvcnQuc3R5bGU7XG4gICAgICAgICAgICAgICAgdm1sVmlld3BvcnRTdHlsZS53aWR0aCA9IHdpZHRoICsgJ3B4JztcbiAgICAgICAgICAgICAgICB2bWxWaWV3cG9ydFN0eWxlLmhlaWdodCA9IGhlaWdodCArICdweCc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgZGlzcG9zZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5yb290LmlubmVySFRNTCA9ICcnO1xuXG4gICAgICAgICAgICB0aGlzLl92bWxSb290ID1cbiAgICAgICAgICAgIHRoaXMuX3ZtbFZpZXdwb3J0ID1cbiAgICAgICAgICAgIHRoaXMuc3RvcmFnZSA9IG51bGw7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0V2lkdGg6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl93aWR0aDtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXRIZWlnaHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9oZWlnaHQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY2xlYXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMucm9vdC5yZW1vdmVDaGlsZCh0aGlzLnZtbFZpZXdwb3J0KTtcbiAgICAgICAgfSxcblxuICAgICAgICBfZ2V0V2lkdGg6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciByb290ID0gdGhpcy5yb290O1xuICAgICAgICAgICAgdmFyIHN0bCA9IHJvb3QuY3VycmVudFN0eWxlO1xuXG4gICAgICAgICAgICByZXR1cm4gKChyb290LmNsaWVudFdpZHRoIHx8IHBhcnNlSW50MTAoc3RsLndpZHRoKSlcbiAgICAgICAgICAgICAgICAgICAgLSBwYXJzZUludDEwKHN0bC5wYWRkaW5nTGVmdClcbiAgICAgICAgICAgICAgICAgICAgLSBwYXJzZUludDEwKHN0bC5wYWRkaW5nUmlnaHQpKSB8IDA7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2dldEhlaWdodDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHJvb3QgPSB0aGlzLnJvb3Q7XG4gICAgICAgICAgICB2YXIgc3RsID0gcm9vdC5jdXJyZW50U3R5bGU7XG5cbiAgICAgICAgICAgIHJldHVybiAoKHJvb3QuY2xpZW50SGVpZ2h0IHx8IHBhcnNlSW50MTAoc3RsLmhlaWdodCkpXG4gICAgICAgICAgICAgICAgICAgIC0gcGFyc2VJbnQxMChzdGwucGFkZGluZ1RvcClcbiAgICAgICAgICAgICAgICAgICAgLSBwYXJzZUludDEwKHN0bC5wYWRkaW5nQm90dG9tKSkgfCAwO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vIE5vdCBzdXBwb3J0ZWQgbWV0aG9kc1xuICAgIGZ1bmN0aW9uIGNyZWF0ZU1ldGhvZE5vdFN1cHBvcnQobWV0aG9kKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB6ckxvZygnSW4gSUU4LjAgVk1MIG1vZGUgcGFpbnRlciBub3Qgc3VwcG9ydCBtZXRob2QgXCInICsgbWV0aG9kICsgJ1wiJyk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIG5vdFN1cHBvcnRlZE1ldGhvZHMgPSBbXG4gICAgICAgICdnZXRMYXllcicsICdpbnNlcnRMYXllcicsICdlYWNoTGF5ZXInLCAnZWFjaEJ1aWxkaW5MYXllcicsICdlYWNoT3RoZXJMYXllcicsICdnZXRMYXllcnMnLFxuICAgICAgICAnbW9kTGF5ZXInLCAnZGVsTGF5ZXInLCAnY2xlYXJMYXllcicsICd0b0RhdGFVUkwnLCAncGF0aFRvSW1hZ2UnXG4gICAgXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm90U3VwcG9ydGVkTWV0aG9kcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbmFtZSA9IG5vdFN1cHBvcnRlZE1ldGhvZHNbaV07XG4gICAgICAgIFZNTFBhaW50ZXIucHJvdG90eXBlW25hbWVdID0gY3JlYXRlTWV0aG9kTm90U3VwcG9ydChuYW1lKTtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IFZNTFBhaW50ZXI7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi96cmVuZGVyL2xpYi92bWwvUGFpbnRlci5qc1xuICoqIG1vZHVsZSBpZCA9IDExMlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==